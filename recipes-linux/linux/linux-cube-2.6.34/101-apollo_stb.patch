diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/hardware/cache-l2x0.h linux-2.6.34/arch/arm/include/asm/hardware/cache-l2x0.h
--- linux-2.6.34.orig/arch/arm/include/asm/hardware/cache-l2x0.h	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/hardware/cache-l2x0.h	2010-09-07 22:16:40.000000000 -0500
@@ -49,6 +49,8 @@
 #define L2X0_CLEAN_INV_WAY		0x7FC
 #define L2X0_LOCKDOWN_WAY_D		0x900
 #define L2X0_LOCKDOWN_WAY_I		0x904
+#define L2X0_ADDR_FILTERING_START	0xC00
+#define L2X0_ADDR_FILTERING_END		0xC04
 #define L2X0_TEST_OPERATION		0xF00
 #define L2X0_LINE_DATA			0xF10
 #define L2X0_LINE_TAG			0xF30
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/hardware/coresight.h linux-2.6.34/arch/arm/include/asm/hardware/coresight.h
--- linux-2.6.34.orig/arch/arm/include/asm/hardware/coresight.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/hardware/coresight.h	2010-09-07 22:16:40.000000000 -0500
@@ -48,8 +48,6 @@ struct tracectx {
 /* CoreSight Component Registers */
 #define CSCR_CLASS	0xff4
 
-#define CSCR_PRSR	0x314
-
 #define UNLOCK_MAGIC	0xc5acce55
 
 /* ETM control register, "ETM Architecture", 3.3.1 */
@@ -132,6 +130,12 @@ struct tracectx {
 				ETMCTRL_BRANCH_OUTPUT | \
 				ETMCTRL_DO_CONTEXTID)
 
+/* ETM management registers, "ETM Architecture", 3.5.24 */
+#define ETMMR_OSLAR	0x300
+#define ETMMR_OSLSR	0x304
+#define ETMMR_OSSRR	0x308
+#define ETMMR_PDSR	0x314
+
 /* ETB registers, "CoreSight Components TRM", 9.3 */
 #define ETBR_DEPTH		0x04
 #define ETBR_STATUS		0x0c
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/hardware/ip3106.h linux-2.6.34/arch/arm/include/asm/hardware/ip3106.h
--- linux-2.6.34.orig/arch/arm/include/asm/hardware/ip3106.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/include/asm/hardware/ip3106.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,620 @@
+/*
+ *  linux/asm/hardware/ip3106.h
+ *
+ *  Copyright(C) 2006, NXP BV, All rights reserved.
+ *  Author: Jean-Paul Saman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARM_ARCH_HARDWARE_IP3106_H
+#define __ASM_ARM_ARCH_HARDWARE_IP3106_H	1
+
+#ifdef __KERNEL__
+#include <mach/pnx8492.h>
+
+
+/**
+ * Registers overview
+ *
+ * The IP3106 UART has the following registers that are accessible at an offset
+ * to the base address of the UART. The base address is dependend on the memory
+ * layout of the board that uses the IP3106.
+ *
+ *	Register	Address	R/RW	Description
+ *	Name		Offset
+ *  ---------------------------------------------------------------------------
+ *	RBR		0x000	R	Receive Buffer Register
+ *	THR		0x000	W	Transmit Holding Register
+ *	DLL		0x000	RW	Divisor Latch (LSB)
+ *	IER		0x004	RW	Interrupt Enable Register
+ *	DLM		0x004	RW	Divisor Latch MSB
+ *	IIR		0x008	R	Interrupt Identification Register
+ *	FCR		0x008	W	FIFO Control Register
+ *	LCR		0x00C	RW	Line Control Register
+ *	MCR		0x010	RW	Mocem Control Register
+ *	LSR		0x014	R	Line Status Register
+ *	MSR		0x018	R	Modem Status Register
+ *	SCR		0x01C	RW	Scratch Register
+ *	ACR		0x020	RW	Auto-baud Control Register
+ *	ICR		0x024	RW	IrDA Control Register
+ *	FDR		0x028	RW	Fractional Diveder Register
+ *	POP		0x030	W	NHP Pop Register
+ *	MODE		0x034	RW	NHP Mode Selection Register
+ *	CFG		0xFD4	R	Configuration Register
+ * 	INTCE		0xFD8	W	Interrupt Clear Enable Register
+ *	INTSE		0xFDC	W	Interrupt Set Enable Register
+ *	INTS		0xFE0	R	Interrupt Status Register
+ * 	INTE		0xFE4	R	Interrupt Enable Register
+ *	INTCS		0xFE8	W	Interrupt Clear Status Register
+ * 	INTCE		0xFEC	W	Interrupt Set Status Register
+ *	MID		0xFFC	R	Module Identification Register
+ */
+
+/* --------------------------------------------------------------------------
+ *  Register offsets from base address
+*  -------------------------------------------------------------------------*/
+#define IP3106_UART_RBR_REG         0x000        /* Receiver Buffer Register */
+#define IP3106_UART_THR_REG         0x000        /* Transmit Holding Register*/
+#define IP3106_UART_DLL_REG         0x000        /* Divisor Latch LSB */
+#define IP3106_UART_DLM_REG         0x004        /* Divisor Latch MSB */
+#define IP3106_UART_IER_REG         0x004        /* Interrupt Enable Register*/
+#define IP3106_UART_IIR_REG         0x008        /* Interrupt ID Register */
+#define IP3106_UART_FCR_REG         0x008        /* FIFO Control Register */
+#define IP3106_UART_LCR_REG         0x00C        /* Line Control Register */
+#define IP3106_UART_MCR_REG         0x010        /* Modem Control Register */
+#define IP3106_UART_LSR_REG         0x014        /* Line Status Register */
+#define IP3106_UART_MSR_REG         0x018        /* Modem Status Register */
+#define IP3106_UART_SCR_REG         0x01C        /* Scratch Pad Register */
+#define IP3106_UART_ACR_REG         0x020        /* Auto-baud Control Register */
+#define IP3106_UART_ICR_REG         0x024        /* IrDA Control Register */
+#define IP3106_UART_FDR_REG         0x028        /* Fractional Divider Register*/
+#define IP3106_UART_OSR_REG         0x02C        /* Over Sampling Register*/
+#define IP3106_UART_POP_REG         0x030        /* NHP Pop Register */
+#define IP3106_UART_MODE_REG        0x034        /* NHP Mode Register */
+#define IP3106_UART_CFG_REG         (0x3F5 << 2) /* Configuration Register */
+#define IP3106_UART_INTCE_REG       (0x3F6 << 2) /* Int Clear Enable Register */
+#define IP3106_UART_INTSE_REG       (0x3F7 << 2) /* Int Set Enable Register */
+#define IP3106_UART_INTS_REG        (0x3F8 << 2) /* Int Status Register */
+#define IP3106_UART_INTE_REG        (0x3F9 << 2) /* Int Enable Register */
+#define IP3106_UART_INTCS_REG       (0x3FA << 2) /* Int Clear Status Register*/
+#define IP3106_UART_INTSS_REG       (0x3FB << 2) /* Int Set Status Register*/
+#define IP3106_UART_MID_REG         (0x3FF << 2) /* Module Id Register*/
+
+#define IP3106_UART_REGS_NUMBER     13
+
+/* --------------------------------------------------------------------------
+ *  Receiver Fifo Buffer Register (RBR) (0x00) - Read Only
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_RBR_FIFO_REG_MSK      0x000000FF /* RBR FIFO register mask */
+#define IP3106_UART_RBR_FIFO_REG_RW_MSK   0x00000000 /* Read/Write bits*/
+
+/* Data */
+#define IP3106_UART_RBR_FIFO_REG_DATA_POS          0
+#define IP3106_UART_RBR_FIFO_REG_DATA_LEN          8
+#define IP3106_UART_RBR_FIFO_REG_DATA_MSK 0x000000FF
+
+/* --------------------------------------------------------------------------
+ *  Transmitter Fifo Holding Register (THR) (0x00) - Write Only
+ *  -------------------------------------------------------------------------*/
+
+#define IP3106_UART_THR_FIFO_REG_MSK      0x000000FF /* THR FIFO register mask */
+#define IP3106_UART_THR_FIFO_REG_RW_MSK   0x00000000 /* Read/Write bits */
+
+/* Data */
+#define IP3106_UART_THR_FIFO_REG_DATA_POS          0
+#define IP3106_UART_THR_FIFO_REG_DATA_LEN          8
+#define IP3106_UART_THR_FIFO_REG_DATA_MSK 0x000000FF
+
+/* --------------------------------------------------------------------------
+ *  Divisor Latch LSB Register (DLL) (0x00) - Read/Write
+ *  ------------------------------------------------------------------------*/
+#define IP3106_UART_DLL_REG_MSK           0x000000FF /* DLL register mask */
+#define IP3106_UART_DLL_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* Data */
+#define IP3106_UART_DLL_REG_DATA_POS               0
+#define IP3106_UART_DLL_REG_DATA_LEN               8
+#define IP3106_UART_DLL_REG_DATA_MSK      0x000000FF
+
+/* --------------------------------------------------------------------------
+ *  Interrupt Holding Register  (IER) (0X04) - Read/Write
+ *  -------------------------------------------------------------------------*/
+/* Interrupt register mask */
+#define IP3106_UART_IER_REG_MSK           0x0000038F /* Bits 4, 5 and 6 are unused */
+#define IP3106_UART_IER_REG_RW_MSK        0x0000038F /* Read/Write bits */
+
+/* Receive Data Interrupt Enable */
+#define IP3106_UART_IER_RDAI_E_POS                 0
+#define IP3106_UART_IER_RDAI_E_LEN                 1
+#define IP3106_UART_IER_RDAI_E_MSK        0x00000001
+/* THRE Interrupt Enable */
+#define IP3106_UART_IER_THREI_E_POS                1
+#define IP3106_UART_IER_THREI_E_LEN                1
+#define IP3106_UART_IER_THREI_E_MSK       0x00000002
+/* Rx Line Status Interrupt Enable */
+#define IP3106_UART_IER_RLSI_E_POS                 2
+#define IP3106_UART_IER_RLSI_E_LEN                 1
+#define IP3106_UART_IER_RLSI_E_MSK        0x00000004
+/* Modem Status Interrupt Enable */
+#define IP3106_UART_IER_MSI_E_POS                  3
+#define IP3106_UART_IER_MSI_E_LEN                  1
+#define IP3106_UART_IER_MSI_E_MSK         0x00000008
+/* Auto CTS Interrupt Enable */
+#define IP3106_UART_IER_CTSI_E_POS                 7
+#define IP3106_UART_IER_CTSI_E_LEN                 1
+#define IP3106_UART_IER_CTSI_E_MSK        0x00000080
+/* End of Auto-baud Interrupt Enable */
+#define IP3106_UART_IER_ABEOI_E_POS                8
+#define IP3106_UART_IER_ABEOI_E_LEN                1
+#define IP3106_UART_IER_ABEOI_E_MSK       0x00000100
+/* Auto-baud TimeOut Interrupt Enable */
+#define IP3106_UART_IER_ABTOI_E_POS                9
+#define IP3106_UART_IER_ABTOI_E_LEN                1
+#define IP3106_UART_IER_ABTOI_E_MSK       0x00000200
+
+/* --------------------------------------------------------------------------
+ *  Divisor Latch MSB Register (DLM) (0x04) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_DLM_REG_MSK           0x000000FF /* DLM register mask */
+#define IP3106_UART_DLM_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* Data */
+#define IP3106_UART_DLM_REG_DATA_POS               0
+#define IP3106_UART_DLM_REG_DATA_LEN               8
+#define IP3106_UART_DLM_REG_DATA_MSK      0x000000FF
+
+/* --------------------------------------------------------------------------
+ *  Interrupt ID Register  (IIR) (0x08) - Read Only
+ *  -------------------------------------------------------------------------*/
+/* Interrupt ID mask */
+#define IP3106_UART_IIR_REG_MSK           0x0000029F /* Bits 4 and 5 are unused */
+#define IP3106_UART_IIR_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* Interrupt Pending */
+#define IP3106_UART_IIR_PENDING_POS                0
+#define IP3106_UART_IIR_PENDING_LEN                1
+#define IP3106_UART_IIR_PENDING_MSK       0x00000001
+/* Interrupt Identification */
+#define IP3106_UART_IIR_ID_POS                     1
+#define IP3106_UART_IIR_ID_LEN                     3
+#define IP3106_UART_IIR_ID_MSK            0x0000000E
+/* FIFO Enable */
+#define IP3106_UART_IIR_FIFOS_EN_POS               6
+#define IP3106_UART_IIR_FIFOS_EN_LEN               2
+#define IP3106_UART_IIR_FIFOS_EN_MSK      0x000000C0
+/* End of Auto-baud Interrupt Enable */
+#define IP3106_UART_IIR_ABEO_INT_POS               8
+#define IP3106_UART_IIR_ABEO_INT_LEN               1
+#define IP3106_UART_IIR_ABEO_INT_MSK      0x00000100
+/* Auto-baud TimeOut Interrupt Enable */
+#define IP3106_UART_IIR_ABTO_INT_POS               9
+#define IP3106_UART_IIR_ABTO_INT_LEN               1
+#define IP3106_UART_IIR_ABTO_INT_MSK      0x00000200
+
+/* Valid values */
+/* Interrupt Identification */
+#define IP3106_UART_IIR_MSI_INT_ID        (0x00000000) /* Modem Int Id */
+#define IP3106_UART_IIR_THRE_INT_ID       (0x00000001) /* THRE Int Id */
+#define IP3106_UART_IIR_RDA_INT_ID        (0x00000002) /* RDA Int Id */
+#define IP3106_UART_IIR_RLS_INT_ID        (0x00000003) /* Rx Line Status Int Id */
+#define IP3106_UART_IIR_CTI_INT_ID        (0x00000006) /* Char TI Int Id */
+#define IP3106_UART_IIR_INT_MASK          (0x0000000E) /* Mask */
+
+/* --------------------------------------------------------------------------
+ *  FIFO Control Register (FCR) (0x08) - Write Only
+ *  ------------------------------------------------------------------------*/
+/* FIFO Control mask */
+#define IP3106_UART_FCR_REG_MSK           0x0000009F /* Bits 4 and 5 are unused */
+#define IP3106_UART_FCR_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* FIFO Enable */
+#define IP3106_UART_FCR_FIF_ENA_POS                0
+#define IP3106_UART_FCR_FIF_ENA_LEN                1
+#define IP3106_UART_FCR_FIF_ENA_MSK       0x00000001
+/* RX FIFO Reset */
+#define IP3106_UART_FCR_RXF_RES_POS                1
+#define IP3106_UART_FCR_RXF_RES_LEN                1
+#define IP3106_UART_FCR_RXF_RES_MSK       0x00000002
+/* TX FIFO Reset */
+#define IP3106_UART_FCR_TXF_RES_POS                2
+#define IP3106_UART_FCR_TXF_RES_LEN                1
+#define IP3106_UART_FCR_TXF_RES_MSK       0x00000004
+/* DMA Mode Select */
+#define IP3106_UART_FCR_DMA_POS                    3
+#define IP3106_UART_FCR_DMA_LEN                    1
+#define IP3106_UART_FCR_DMA_MSK           0x00000008
+/* RX Trigger Level Select */
+#define IP3106_UART_FCR_RX_TRIGGER_POS             6
+#define IP3106_UART_FCR_RX_TRIGGER_LEN             2
+#define IP3106_UART_FCR_RX_TRIGGER_MSK    0x000000C0
+
+/* Valid values */
+#define IP3106_UART_FCR_INT_1_DEEP            (0x0)
+#define IP3106_UART_FCR_INT_4_DEEP            (0x1)
+#define IP3106_UART_FCR_INT_8_DEEP            (0x2)
+#define IP3106_UART_FCR_INT_14_DEEP           (0x3)
+
+#define IP3106_UART_FCR_RX_TRIG_LEVEL_0       (0x0)
+#define IP3106_UART_FCR_RX_TRIG_LEVEL_1       (0x1)
+#define IP3106_UART_FCR_RX_TRIG_LEVEL_2       (0x2)
+#define IP3106_UART_FCR_RX_TRIG_LEVEL_3       (0x3)
+
+/* --------------------------------------------------------------------------
+ *  Line Control Register (LCR) (0x0C) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_LCR_REG_MSK           0x000000FF /* Line Control mask */
+#define IP3106_UART_LCR_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* Word Length Select */
+#define IP3106_UART_LCR_WORD_LEN_POS               0
+#define IP3106_UART_LCR_WORD_LEN_LEN               2
+#define IP3106_UART_LCR_WORD_LEN_MSK      0x00000003
+/* Stop Bit Select */
+#define IP3106_UART_LCR_STOPB_POS                  2
+#define IP3106_UART_LCR_STOPB_LEN                  1
+#define IP3106_UART_LCR_STOPB_MSK         0x00000004
+/* Parity Enable */
+#define IP3106_UART_LCR_PAR_EN_POS                 3
+#define IP3106_UART_LCR_PAR_EN_LEN                 1
+#define IP3106_UART_LCR_PAR_EN_MSK        0x00000008
+/* Parity Select */
+#define IP3106_UART_LCR_PAR_SEL_POS                4
+#define IP3106_UART_LCR_PAR_SEL_LEN                2
+#define IP3106_UART_LCR_PAR_SEL_MSK       0x00000030
+/* Break Control */
+#define IP3106_UART_LCR_BRK_CTL_POS                6
+#define IP3106_UART_LCR_BRK_CTL_LEN                1
+#define IP3106_UART_LCR_BRK_CTL_MSK       0x00000040
+/* Divisor Latch Access Bit */
+#define IP3106_UART_LCR_DLAB_POS                   7
+#define IP3106_UART_LCR_DLAB_LEN                   1
+#define IP3106_UART_LCR_DLAB_MSK          0x00000080
+
+/* Valid values */
+/* Word Length Select */
+#define IP3106_UART_LCR_WORDLEN_5BIT          (0x0)
+#define IP3106_UART_LCR_WORDLEN_6BIT          (0x1)
+#define IP3106_UART_LCR_WORDLEN_7BIT          (0x2)
+#define IP3106_UART_LCR_WORDLEN_8BIT          (0x3)
+
+/* Stop Bit Select */
+#define IP3106_UART_LCR_1_STOP_BIT            (0x0)
+#define IP3106_UART_LCR_2_STOP_BIT            (0x1)
+
+/* Parity Select */
+#define IP3106_UART_LCR_PARITY_ODD            (0x0)
+#define IP3106_UART_LCR_PARITY_EVEN           (0x1)
+#define IP3106_UART_LCR_PARITY_MARK           (0x2)
+#define IP3106_UART_LCR_PARITY_SPACE          (0x3)
+
+/* Parity Enable */
+#define IP3106_UART_LCR_NO_PARITY             (0x0)
+#define IP3106_UART_LCR_PARITY                (0x1)
+
+/* Break Control */
+#define IP3106_UART_LCR_NO_BREAK_TR           (0x0)
+#define IP3106_UART_LCR_BREAK_TR              (0x1)
+
+/* Divisor Latches */
+#define IP3106_UART_LCR_NO_DIV_LAB            (0x0)
+#define IP3106_UART_LCR_DIV_LAB               (0x1)
+
+/* --------------------------------------------------------------------------
+ *  Modem Control Register (MCR) (0x10) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_MCR_REG_MSK           0x000000FF /* Modem Control mask */
+#define IP3106_UART_MCR_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* NDTR Control */
+#define IP3106_UART_MCR_DTR_POS                    0
+#define IP3106_UART_MCR_DTR_LEN                    1
+#define IP3106_UART_MCR_DTR_MSK           0x00000001
+/* NRTS Control */
+#define IP3106_UART_MCR_RTS_POS                    1
+#define IP3106_UART_MCR_RTS_LEN                    1
+#define IP3106_UART_MCR_RTS_MSK           0x00000002
+/* NOUT Control */
+#define IP3106_UART_MCR_OUT_POS                    2
+#define IP3106_UART_MCR_OUT_LEN                    2
+#define IP3106_UART_MCR_OUT_MSK           0x0000000C
+/* LOOPBACK Control */
+#define IP3106_UART_MCR_LOOP_POS                   4
+#define IP3106_UART_MCR_LOOP_LEN                   1
+#define IP3106_UART_MCR_LOOP_MSK          0x00000010
+/* Auto RTS Flow Control Enable */
+#define IP3106_UART_MCR_ARTS_EN_POS                6
+#define IP3106_UART_MCR_ARTS_EN_LEN                1
+#define IP3106_UART_MCR_ARTS_EN_MSK       0x00000040
+/* Auto CTS Flow Control Enable */
+#define IP3106_UART_MCR_ACTS_EN_POS                7
+#define IP3106_UART_MCR_ACTS_EN_LEN                1
+#define IP3106_UART_MCR_ACTS_EN_MSK       0x00000080
+
+/* Valid values */
+/* Loopback Mode Select */
+#define IP3106_UART_MCR_NO_LOOPBACK           (0x0)
+#define IP3106_UART_MCR_LOOPBACK              (0x1)
+
+/* --------------------------------------------------------------------------
+ *  Line Status Register (LSR) (0x14) - Read Only
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_LSR_REG_MSK           0x000000FF /* Line Status mask */
+#define IP3106_UART_LSR_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* Receiver Data Ready */
+#define IP3106_UART_LSR_DR_POS                     0
+#define IP3106_UART_LSR_DR_LEN                     1
+#define IP3106_UART_LSR_DR_MSK            0x00000001
+/* Overrun Error */
+#define IP3106_UART_LSR_OE_POS                     1
+#define IP3106_UART_LSR_OE_LEN                     1
+#define IP3106_UART_LSR_OE_MSK            0x00000002
+/* Parity Error */
+#define IP3106_UART_LSR_PE_POS                     2
+#define IP3106_UART_LSR_PE_LEN                     1
+#define IP3106_UART_LSR_PE_MSK            0x00000004
+/* Framing Error */
+#define IP3106_UART_LSR_FE_POS                     3
+#define IP3106_UART_LSR_FE_LEN                     1
+#define IP3106_UART_LSR_FE_MSK            0x00000008
+/* Break Interrupt */
+#define IP3106_UART_LSR_BI_POS                     4
+#define IP3106_UART_LSR_BI_LEN                     1
+#define IP3106_UART_LSR_BI_MSK            0x00000010
+/* Transmitter Holding Register Empty */
+#define IP3106_UART_LSR_THRE_POS                   5
+#define IP3106_UART_LSR_THRE_LEN                   1
+#define IP3106_UART_LSR_THRE_MSK          0x00000020
+/* Transmitter Empty */
+#define IP3106_UART_LSR_TEMT_POS                   6
+#define IP3106_UART_LSR_TEMT_LEN                   1
+#define IP3106_UART_LSR_TEMT_MSK          0x00000040
+/* Error in RX FIFO */
+#define IP3106_UART_LSR_RXERR_POS                  7
+#define IP3106_UART_LSR_RXERR_LEN                  1
+#define IP3106_UART_LSR_RXERR_MSK         0x00000080
+
+/* --------------------------------------------------------------------------
+ *  Modem Status Register (MSR) (0x18) - Read Only
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_MSR_REG_MSK           0x000000FF /* Modem Status mask */
+#define IP3106_UART_MSR_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* Delta NCTS */
+#define IP3106_UART_MSR_DCTS_POS                   0
+#define IP3106_UART_MSR_DCTS_LEN                   1
+#define IP3106_UART_MSR_DCTS_MSK          0x00000001
+/* Delta NDSR */
+#define IP3106_UART_MSR_DDSR_POS                   1
+#define IP3106_UART_MSR_DDSR_LEN                   1
+#define IP3106_UART_MSR_DDSR_MSK          0x00000002
+/* Trailing Edge NRI */
+#define IP3106_UART_MSR_TERI_POS                   2
+#define IP3106_UART_MSR_TERI_LEN                   1
+#define IP3106_UART_MSR_TERI_MSK          0x00000004
+/* Delta NDCD */
+#define IP3106_UART_MSR_DDCD_POS                   3
+#define IP3106_UART_MSR_DDCD_LEN                   1
+#define IP3106_UART_MSR_DDCD_MSK          0x00000008
+/* Clear to Send State */
+#define IP3106_UART_MSR_CTS_POS                    4
+#define IP3106_UART_MSR_CTS_LEN                    1
+#define IP3106_UART_MSR_CTS_MSK           0x00000010
+/* Data Set Ready State */
+#define IP3106_UART_MSR_DSR_POS                    5
+#define IP3106_UART_MSR_DSR_LEN                    1
+#define IP3106_UART_MSR_DSR_MSK           0x00000020
+/* Ring Indicator State */
+#define IP3106_UART_MSR_RI_POS                     6
+#define IP3106_UART_MSR_RI_LEN                     1
+#define IP3106_UART_MSR_RI_MSK            0x00000040
+/* Data Carrier Detect State */
+#define IP3106_UART_MSR_DCD_POS                    7
+#define IP3106_UART_MSR_DCD_LEN                    1
+#define IP3106_UART_MSR_DCD_MSK           0x00000080
+
+/* --------------------------------------------------------------------------
+ *  Scratch Pad Register (SCR) (0x1C) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_SCR_REG_MSK           0x000000FF /* SCR register mask */
+#define IP3106_UART_SCR_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* Data */
+#define IP3106_UART_SCR_REG_DATA_POS               0
+#define IP3106_UART_SCR_REG_DATA_LEN               8
+#define IP3106_UART_SCR_REG_DATA_MSK      0x000000FF
+
+/* --------------------------------------------------------------------------
+ *  Auto-baud Control Register (ACR) (0x20) - Read/Write
+ *  -------------------------------------------------------------------------*/
+/* ACR register mask */
+#define IP3106_UART_ACR_REG_MSK           0x00000307 /* Bits 3-7 are unused */
+#define IP3106_UART_ACR_REG_RW_MSK        0x00000007 /* Read/Write bits */
+
+/* Power-on/Reset mask & value */
+#define IP3106_UART_ACR_REG_POR_MSK       0x00000307
+#define IP3106_UART_ACR_REG_POR_VAL       0x00000000
+
+/* Start */
+#define IP3106_UART_ACR_START_POS                  0
+#define IP3106_UART_ACR_START_LEN                  1
+#define IP3106_UART_ACR_START_MSK         0x00000001
+
+/* Mode */
+#define IP3106_UART_ACR_MODE_POS                   1
+#define IP3106_UART_ACR_MODE_LEN                   1
+#define IP3106_UART_ACR_MODE_MSK          0x00000002
+
+/* Auto Restart */
+#define IP3106_UART_ACR_ARES_POS                   2
+#define IP3106_UART_ACR_ARES_LEN                   1
+#define IP3106_UART_ACR_ARES_MSK          0x00000004
+
+/* End of Auto-baud Interrupt Clear */
+#define IP3106_UART_ACR_ABEOIC_POS                 8
+#define IP3106_UART_ACR_ABEOIC_LEN                 1
+#define IP3106_UART_ACR_ABEOIC_MSK        0x00000100
+
+/* Auto-baud TimeOut Interrupt Clear */
+#define IP3106_UART_ACR_ABTOIC_POS                 9
+#define IP3106_UART_ACR_ABTOIC_LEN                 1
+#define IP3106_UART_ACR_ABTOIC_MSK        0x00000200
+
+/* --------------------------------------------------------------------------
+ *  IrDA Control Register (ICR) (0x24) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_ICR_REG_MSK           0x0000003F /* ICR register mask */
+#define IP3106_UART_ICR_REG_RW_MSK        0x0000003F /* Read/Write bits */
+
+/* Enable */
+#define IP3106_UART_ICR_EN_POS                     0
+#define IP3106_UART_ICR_EN_LEN                     1
+#define IP3106_UART_ICR_EN_MSK            0x00000001
+
+/* Invert */
+#define IP3106_UART_ICR_INV_POS                    1
+#define IP3106_UART_ICR_INV_LEN                    1
+#define IP3106_UART_ICR_INV_MSK           0x00000002
+
+/* Fixed Pulse Width */
+#define IP3106_UART_ICR_FPW_POS                    2
+#define IP3106_UART_ICR_FPW_LEN                    1
+#define IP3106_UART_ICR_FPW_MSK           0x00000004
+
+/* Pulse Divisor */
+#define IP3106_UART_ICR_PD_POS                     3
+#define IP3106_UART_ICR_PD_LEN                     3
+#define IP3106_UART_ICR_PD_MSK            0x00000038
+
+/* Valid Values */
+/* Pulse Divisor */
+#define IP3106_UART_ICR_VAL_PD2                  (0)
+#define IP3106_UART_ICR_VAL_PD4                  (1)
+#define IP3106_UART_ICR_VAL_PD8                  (2)
+#define IP3106_UART_ICR_VAL_PD16                 (3)
+#define IP3106_UART_ICR_VAL_PD32                 (4)
+#define IP3106_UART_ICR_VAL_PD64                 (5)
+#define IP3106_UART_ICR_VAL_PD128                (6)
+#define IP3106_UART_ICR_VAL_PD256                (7)
+
+/* --------------------------------------------------------------------------
+ *  Fractional Divider Register (FDR) (0x28) - Read/Write
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_FDR_REG_MSK           0x000000FF /* ICR register mask */
+#define IP3106_UART_FDR_REG_RW_MSK        0x000000FF /* Read/Write bits */
+
+/* Divisor */
+#define IP3106_UART_FDR_DIV_POS                    0
+#define IP3106_UART_FDR_DIV_LEN                    4
+#define IP3106_UART_FDR_DIV_MSK           0x0000000F
+
+/* Multiplier */
+#define IP3106_UART_FDR_MUL_POS                    4
+#define IP3106_UART_FDR_MUL_LEN                    4
+#define IP3106_UART_FDR_MUL_MSK           0x000000F0
+
+/* --------------------------------------------------------------------------
+ *  Configuration Register (CFG) (0xFD4) - Read Only
+ *  -------------------------------------------------------------------------*/
+/* CFG register mask */
+#define IP3106_UART_CFG_REG_MSK           0x00003333 /* Bits 2,3, 6,7, 10,11 are unused */
+#define IP3106_UART_CFG_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* Type */
+#define IP3106_UART_CFG_TYPE_POS                   0
+#define IP3106_UART_CFG_TYPE_LEN                   2
+#define IP3106_UART_CFG_TYPE_MSK          0x00000003
+
+/* Modem */
+#define IP3106_UART_CFG_MODEM_POS                  4
+#define IP3106_UART_CFG_MODEM_LEN                  2
+#define IP3106_UART_CFG_MODEM_MSK         0x00000030
+
+/* DMA */
+#define IP3106_UART_CFG_DMA_POS                    8
+#define IP3106_UART_CFG_DMA_LEN                    1
+#define IP3106_UART_CFG_DMA_MSK           0x00000100
+
+/* Level */
+#define IP3106_UART_CFG_LEVEL_POS                  9
+#define IP3106_UART_CFG_LEVEL_LEN                  1
+#define IP3106_UART_CFG_LEVEL_MSK         0x00000200
+
+/* IrDA */
+#define IP3106_UART_CFG_IRDA_POS                  12
+#define IP3106_UART_CFG_IRDA_LEN                   1
+#define IP3106_UART_CFG_IRDA_MSK          0x00001000
+
+/* NHP compliant */
+#define IP3106_UART_CFG_NHP_POS                   13
+#define IP3106_UART_CFG_NHP_LEN                    1
+#define IP3106_UART_CFG_NHP_MSK           0x00002000
+
+/* Valid Values */
+/* Type */
+#define IP3106_UART_CFG_VAL_450                (0x0)
+#define IP3106_UART_CFG_VAL_550                (0x1)
+#define IP3106_UART_CFG_VAL_650                (0x2)
+#define IP3106_UART_CFG_VAL_750                (0x3)
+
+/* Modem */
+#define IP3106_UART_CFG_VAL_NO_MODEM           (0x0)
+#define IP3106_UART_CFG_VAL_RTSCTS             (0x1)
+#define IP3106_UART_CFG_VAL_FULL_MODEM         (0x2)
+
+/* DMA */
+#define IP3106_UART_CFG_VAL_NO_DMA             (0x0)
+#define IP3106_UART_CFG_VAL_HAS_DMA            (0x1)
+
+/* Level */
+#define IP3106_UART_CFG_VAL_NO_LEVEL           (0x0)
+#define IP3106_UART_CFG_VAL_HAS_LEVEL          (0x1)
+
+/* IrDA */
+#define IP3106_UART_CFG_VAL_NO_IRDA            (0x0)
+#define IP3106_UART_CFG_VAL_HAS_IRDA           (0x1)
+
+/* NHP */
+#define IP3106_UART_CFG_VAL_NO_NHP             (0x0)
+#define IP3106_UART_CFG_VAL_HAS_NHP            (0x1)
+
+/* --------------------------------------------------------------------------
+ *  Module Identification Register (MID) (0xFFC) - Read Only
+ *  -------------------------------------------------------------------------*/
+#define IP3106_UART_MID_REG_MSK           0xFFFFFFFF /* MID register mask */
+#define IP3106_UART_MID_REG_RW_MSK        0x00000000 /* Read/Write bits */
+
+/* Aperture */
+#define IP3106_UART_MID_APERTURE_POS               0
+#define IP3106_UART_MID_APERTURE_LEN               8
+#define IP3106_UART_MID_APERTURE_MSK      0x000000FF
+
+/* Minor Revision */
+#define IP3106_UART_MID_MINOR_POS                  8
+#define IP3106_UART_MID_MINOR_LEN                  4
+#define IP3106_UART_MID_MINOR_MSK         0x00000F00
+
+/* Major Revision */
+#define IP3106_UART_MID_MAJOR_POS                 12
+#define IP3106_UART_MID_MAJOR_LEN                  4
+#define IP3106_UART_MID_MAJOR_MSK         0x0000F000
+
+/* Unique Identification Number */
+#define IP3106_UART_MID_ID_POS                    16
+#define IP3106_UART_MID_ID_LEN                    16
+#define IP3106_UART_MID_ID_MSK            0xFFFF0000
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_ARM_ARCH_HARDWARE_IP3106_H */
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/hardware/pl080.h linux-2.6.34/arch/arm/include/asm/hardware/pl080.h
--- linux-2.6.34.orig/arch/arm/include/asm/hardware/pl080.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/hardware/pl080.h	2010-09-07 22:16:40.000000000 -0500
@@ -43,7 +43,7 @@
 
 /* Per channel configuration registers */
 
-#define PL008_Cx_STRIDE				(0x20)
+#define PL080_Cx_STRIDE				(0x20)
 #define PL080_Cx_BASE(x)			((0x100 + (x * 0x20)))
 #define PL080_Cx_SRC_ADDR(x)			((0x100 + (x * 0x20)))
 #define PL080_Cx_DST_ADDR(x)			((0x104 + (x * 0x20)))
@@ -68,6 +68,8 @@
 #define PL080_CONTROL_TC_IRQ_EN			(1 << 31)
 #define PL080_CONTROL_PROT_MASK			(0x7 << 28)
 #define PL080_CONTROL_PROT_SHIFT		(28)
+#define PL080_CONTROL_PROT_CACHE		(1 << 30)
+#define PL080_CONTROL_PROT_BUFF			(1 << 29)
 #define PL080_CONTROL_PROT_SYS			(1 << 28)
 #define PL080_CONTROL_DST_INCR			(1 << 27)
 #define PL080_CONTROL_SRC_INCR			(1 << 26)
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/io.h linux-2.6.34/arch/arm/include/asm/io.h
--- linux-2.6.34.orig/arch/arm/include/asm/io.h	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/io.h	2010-09-07 22:16:40.000000000 -0500
@@ -26,6 +26,7 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 #include <asm/memory.h>
+#include <asm/system.h>
 
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
@@ -185,30 +186,28 @@ extern void _memset_io(volatile void __i
 #define readl_relaxed(c) ({ u32 __v = le32_to_cpu((__force __le32) \
 					__raw_readl(__mem_pci(c))); __v; })
 
-#define writeb_relaxed(v,c)	__raw_writeb(v,__mem_pci(c))
-#define writew_relaxed(v,c)	__raw_writew((__force u16) \
-					cpu_to_le16(v),__mem_pci(c))
-#define writel_relaxed(v,c)	__raw_writel((__force u32) \
-					cpu_to_le32(v),__mem_pci(c))
-					
+#define writeb_relaxed(v,c)	((void)__raw_writeb(v,__mem_pci(c)))
+#define writew_relaxed(v,c)	((void)__raw_writew((__force u16) \
+					cpu_to_le16(v),__mem_pci(c)))
+#define writel_relaxed(v,c)	((void)__raw_writel((__force u32) \
+					cpu_to_le32(v),__mem_pci(c)))
+
 #ifdef CONFIG_ARM_DMA_MEM_BUFFERABLE
-#define readb(c)		({ u8  __v = readb_relaxed(c); rmb(); __v; })
-#define readw(c)		({ u16 __v = readw_relaxed(c); rmb(); __v; })
-#define readl(c)		({ u32 __v = readl_relaxed(c); rmb(); __v; })
-
-#define writeb(v,c)		({ wmb(); writeb_relaxed(v,c); })
-#define writew(v,c)		({ wmb(); writew_relaxed(v,c); })
-#define writel(v,c)		({ wmb(); writel_relaxed(v,c); })
+#define __iormb()		rmb()
+#define __iowmb()		wmb()
 #else
-#define readb(c)		readb_relaxed(c)
-#define readw(c)		readw_relaxed(c)
-#define readl(c)		readl_relaxed(c)
-
-#define writeb(v,c)		writeb_relaxed(v,c)
-#define writew(v,c)		writew_relaxed(v,c)
-#define writel(v,c)		writel_relaxed(v,c)
+#define __iormb()		do { } while (0)
+#define __iowmb()		do { } while (0)
 #endif
 
+#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
+#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
+#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+
+#define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })
+#define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })
+#define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
+
 #define readsb(p,d,l)		__raw_readsb(__mem_pci(p),d,l)
 #define readsw(p,d,l)		__raw_readsw(__mem_pci(p),d,l)
 #define readsl(p,d,l)		__raw_readsl(__mem_pci(p),d,l)
@@ -259,13 +258,13 @@ extern void _memset_io(volatile void __i
  * io{read,write}{8,16,32} macros
  */
 #ifndef ioread8
-#define ioread8(p)	({ unsigned int __v = __raw_readb(p); __v; })
-#define ioread16(p)	({ unsigned int __v = le16_to_cpu((__force __le16)__raw_readw(p)); __v; })
-#define ioread32(p)	({ unsigned int __v = le32_to_cpu((__force __le32)__raw_readl(p)); __v; })
-
-#define iowrite8(v,p)	__raw_writeb(v, p)
-#define iowrite16(v,p)	__raw_writew((__force __u16)cpu_to_le16(v), p)
-#define iowrite32(v,p)	__raw_writel((__force __u32)cpu_to_le32(v), p)
+#define ioread8(p)	({ unsigned int __v = __raw_readb(p); __iormb(); __v; })
+#define ioread16(p)	({ unsigned int __v = le16_to_cpu((__force __le16)__raw_readw(p)); __iormb(); __v; })
+#define ioread32(p)	({ unsigned int __v = le32_to_cpu((__force __le32)__raw_readl(p)); __iormb(); __v; })
+
+#define iowrite8(v,p)	({ __iowmb(); (void)__raw_writeb(v, p); })
+#define iowrite16(v,p)	({ __iowmb(); (void)__raw_writew((__force __u16)cpu_to_le16(v), p); })
+#define iowrite32(v,p)	({ __iowmb(); (void)__raw_writel((__force __u32)cpu_to_le32(v), p); })
 
 #define ioread8_rep(p,d,c)	__raw_readsb(p,d,c)
 #define ioread16_rep(p,d,c)	__raw_readsw(p,d,c)
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/memory.h linux-2.6.34/arch/arm/include/asm/memory.h
--- linux-2.6.34.orig/arch/arm/include/asm/memory.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/memory.h	2010-09-07 22:16:40.000000000 -0500
@@ -32,7 +32,7 @@
  * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area
  */
 #define PAGE_OFFSET		UL(CONFIG_PAGE_OFFSET)
-#define TASK_SIZE		(UL(CONFIG_PAGE_OFFSET) - UL(0x01000000))
+#define TASK_SIZE		(UL(CONFIG_PAGE_OFFSET) - UL(0x01800000))
 #define TASK_UNMAPPED_BASE	(UL(CONFIG_PAGE_OFFSET) / 3)
 
 /*
@@ -45,7 +45,7 @@
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
  */
 #ifndef CONFIG_THUMB2_KERNEL
-#define MODULES_VADDR		(PAGE_OFFSET - 16*1024*1024)
+#define MODULES_VADDR		(PAGE_OFFSET - 24*1024*1024)
 #else
 /* smaller range for Thumb-2 symbols relocation (2^24)*/
 #define MODULES_VADDR		(PAGE_OFFSET - 8*1024*1024)
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/setup.h linux-2.6.34/arch/arm/include/asm/setup.h
--- linux-2.6.34.orig/arch/arm/include/asm/setup.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/setup.h	2010-09-07 22:16:40.000000000 -0500
@@ -143,6 +143,22 @@ struct tag_memclk {
 	__u32 fmemclk;
 };
 
+#define ATAG_MAC    0x5441000A
+#define MAX_MAC_TAGS 2
+struct tag_mac {
+   __u8 mac_addr[2][6]; 
+};
+#define ATAG_MEMMAP    0x5441000C
+#define MAX_MEMMAP_TAGS 14
+struct memmap_pool_def {
+        __u16 pool_type;
+        __u16 bank;
+        __u32 offset;
+        __u32 size;
+};
+struct tag_memmap {
+        struct memmap_pool_def pool_def[MAX_MEMMAP_TAGS];
+};
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -165,6 +181,8 @@ struct tag {
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
+		struct tag_memmap	memmap;
+		struct tag_mac mac;
 	} u;
 };
 
diff -Naurp linux-2.6.34.orig/arch/arm/include/asm/tlbflush.h linux-2.6.34/arch/arm/include/asm/tlbflush.h
--- linux-2.6.34.orig/arch/arm/include/asm/tlbflush.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/include/asm/tlbflush.h	2010-09-07 22:16:40.000000000 -0500
@@ -378,7 +378,11 @@ static inline void local_flush_tlb_mm(st
 	if (tlb_flag(TLB_V6_I_ASID))
 		asm("mcr p15, 0, %0, c8, c5, 2" : : "r" (asid) : "cc");
 	if (tlb_flag(TLB_V7_UIS_ASID))
+#ifdef CONFIG_ARM_ERRATA_720789
+		asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
+#else
 		asm("mcr p15, 0, %0, c8, c3, 2" : : "r" (asid) : "cc");
+#endif
 
 	if (tlb_flag(TLB_BTB)) {
 		/* flush the branch target cache */
@@ -424,7 +428,11 @@ local_flush_tlb_page(struct vm_area_stru
 	if (tlb_flag(TLB_V6_I_PAGE))
 		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (uaddr) : "cc");
 	if (tlb_flag(TLB_V7_UIS_PAGE))
+#ifdef CONFIG_ARM_ERRATA_720789
+		asm("mcr p15, 0, %0, c8, c3, 3" : : "r" (uaddr & PAGE_MASK) : "cc");
+#else
 		asm("mcr p15, 0, %0, c8, c3, 1" : : "r" (uaddr) : "cc");
+#endif
 
 	if (tlb_flag(TLB_BTB)) {
 		/* flush the branch target cache */
diff -Naurp linux-2.6.34.orig/arch/arm/Kconfig linux-2.6.34/arch/arm/Kconfig
--- linux-2.6.34.orig/arch/arm/Kconfig	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -729,6 +729,15 @@ config ARCH_U300
 	help
 	  Support for ST-Ericsson U300 series mobile platforms.
 
+config ARCH_APOLLO
+	bool "NXP Apollo Platform"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select HAVE_CLK
+	select SOC_PNX8492
+	help
+	  Support for NXP's Apollo platform based on a Cortex-A9.
+	  
 config ARCH_U8500
 	bool "ST-Ericsson U8500 Series"
 	select CPU_V7
@@ -901,6 +910,8 @@ source "arch/arm/mach-versatile/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+source "arch/arm/mach-apollo/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -1004,6 +1015,18 @@ config PL310_ERRATA_588369
 	   is not correctly implemented in PL310 as clean lines are not
 	   invalidated as a result of these operations. Note that this errata
 	   uses Texas Instrument's secure monitor api.
+
+config ARM_ERRATA_720789
+	bool "ARM errata: TLBIASIDIS and TLBIMVAIS operations can broadcast a faulty ASID"
+	depends on CPU_V7 && SMP
+	help
+	  This option enables the workaround for the 720789 Cortex-A9 (prior to
+	  r2p0) erratum. A faulty ASID can be sent to the other CPUs for the
+	  broadcasted CP15 TLB maintenance operations TLBIASIDIS and TLBIMVAIS.
+	  As a consequence of this erratum, some TLB entries which should be
+	  invalidated are not, resulting in an incoherency in the system page
+	  tables. The workaround changes the TLB flushing routines to invalidate
+	  entries regardless of the ASID.
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -1037,7 +1060,7 @@ config ISA_DMA_API
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE || ARCH_APOLLO
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
@@ -1076,10 +1099,10 @@ source "kernel/time/Kconfig"
 config SMP
 	bool "Symmetric Multi-Processing (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && (REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP ||\
-		 MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || ARCH_U8500)
+		 MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || ARCH_U8500 || MACH_APOLLO_A9MP)
 	depends on GENERIC_CLOCKEVENTS
 	select USE_GENERIC_SMP_HELPERS
-	select HAVE_ARM_SCU if (ARCH_REALVIEW || ARCH_OMAP4 || ARCH_U8500)
+	select HAVE_ARM_SCU if (ARCH_REALVIEW || ARCH_OMAP4 || ARCH_U8500 || MACH_APOLLO_A9MP)
 	help
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -1148,9 +1171,9 @@ config HOTPLUG_CPU
 config LOCAL_TIMERS
 	bool "Use local timer interrupts"
 	depends on SMP && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || \
-		REALVIEW_EB_A9MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || ARCH_U8500)
+		REALVIEW_EB_A9MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || ARCH_U8500 || MACH_APOLLO_A9MP)
 	default y
-	select HAVE_ARM_TWD if (ARCH_REALVIEW || ARCH_OMAP4 || ARCH_U8500)
+	select HAVE_ARM_TWD if (ARCH_REALVIEW || ARCH_OMAP4 || ARCH_U8500 || MACH_APOLLO_A9MP)
 	help
 	  Enable support for local timers on SMP platforms, rather then the
 	  legacy IPI broadcast method.  Local timers allows the system
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/armksyms.c linux-2.6.34/arch/arm/kernel/armksyms.c
--- linux-2.6.34.orig/arch/arm/kernel/armksyms.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/armksyms.c	2010-09-07 22:16:40.000000000 -0500
@@ -47,6 +47,8 @@ extern void __aeabi_uidiv(void);
 extern void __aeabi_uidivmod(void);
 extern void __aeabi_ulcmp(void);
 
+extern void __aeabi_uldivmod(void);
+
 extern void fpundefinstr(void);
 
 
@@ -137,6 +139,7 @@ EXPORT_SYMBOL(__aeabi_lmul);
 EXPORT_SYMBOL(__aeabi_uidiv);
 EXPORT_SYMBOL(__aeabi_uidivmod);
 EXPORT_SYMBOL(__aeabi_ulcmp);
+EXPORT_SYMBOL(__aeabi_uldivmod);
 #endif
 
 	/* bitops */
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/etm.c linux-2.6.34/arch/arm/kernel/etm.c
--- linux-2.6.34.orig/arch/arm/kernel/etm.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/etm.c	2010-09-07 22:16:40.000000000 -0500
@@ -543,7 +543,9 @@ static int __init etm_probe(struct amba_
 	t->etm_portsz = 1;
 
 	etm_unlock(t);
-	ret = etm_readl(t, CSCR_PRSR);
+	(void)etm_readl(t, ETMMR_PDSR);
+	/* dummy first read */
+	(void)etm_readl(&tracer, ETMMR_OSSRR);
 
 	t->ncmppairs = etm_readl(t, ETMR_CONFCODE) & 0xf;
 	etm_writel(t, 0x440, ETMR_CTRL);
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/head.S linux-2.6.34/arch/arm/kernel/head.S
--- linux-2.6.34.orig/arch/arm/kernel/head.S	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/head.S	2010-09-07 22:16:40.000000000 -0500
@@ -302,8 +302,6 @@ __create_page_tables:
 	movhi	r3, #0x0800
 	add	r6, r0, r3
 	ldr	r3, [r8, #MACHINFO_PHYSIO]
-	mov	r3, r3, lsr #20			@ 1MB-aligned address
-	mov	r3, r3, lsl #20
 	orr	r3, r3, r7
 1:	str	r3, [r0], #4
 	add	r3, r3, #1 << 20
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/init_task.c linux-2.6.34/arch/arm/kernel/init_task.c
--- linux-2.6.34.orig/arch/arm/kernel/init_task.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/init_task.c	2010-09-07 22:16:40.000000000 -0500
@@ -35,3 +35,4 @@ union thread_union init_thread_union __i
 struct task_struct init_task = INIT_TASK(init_task);
 
 EXPORT_SYMBOL(init_task);
+EXPORT_SYMBOL(init_mm);
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/module.c linux-2.6.34/arch/arm/kernel/module.c
--- linux-2.6.34.orig/arch/arm/kernel/module.c	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/module.c	2010-09-07 22:16:40.000000000 -0500
@@ -144,7 +144,7 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
 			offset += sym->st_value - loc;
 			if (offset & 3 ||
 			    offset <= (s32)0xfe000000 ||
-			    offset >= (s32)0x02000000) {
+			    offset >= (s32)0x03000000) {
 				printk(KERN_ERR
 				       "%s: relocation out of range, section "
 				       "%d reloc %d sym '%s'\n", module->name,
diff -Naurp linux-2.6.34.orig/arch/arm/kernel/relocate_kernel.S linux-2.6.34/arch/arm/kernel/relocate_kernel.S
--- linux-2.6.34.orig/arch/arm/kernel/relocate_kernel.S	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/kernel/relocate_kernel.S	2010-09-07 22:16:40.000000000 -0500
@@ -10,6 +10,12 @@ relocate_new_kernel:
 	ldr	r0,kexec_indirection_page
 	ldr	r1,kexec_start_address
 
+	/*
+	 * If there is no indirection page (we are doing crashdumps)
+	 * skip any relocation.
+	 */
+	cmp	r0, #0
+	beq	2f
 
 0:	/* top, read another word for the indirection page */
 	ldr	r3, [r0],#4
diff -Naurp linux-2.6.34.orig/arch/arm/lib/csumpartialcopyuser.S linux-2.6.34/arch/arm/lib/csumpartialcopyuser.S
--- linux-2.6.34.orig/arch/arm/lib/csumpartialcopyuser.S	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/lib/csumpartialcopyuser.S	2010-09-07 22:16:40.000000000 -0500
@@ -71,7 +71,7 @@
 		.pushsection .fixup,"ax"
 		.align	4
 9001:		mov	r4, #-EFAULT
-		ldr	r5, [fp, #4]		@ *err_ptr
+		ldr	r5, [sp, #8*4]		@ *err_ptr
 		str	r4, [r5]
 		ldmia	sp, {r1, r2}		@ retrieve dst, len
 		add	r2, r2, r1
diff -Naurp linux-2.6.34.orig/arch/arm/lib/lib1funcs.S linux-2.6.34/arch/arm/lib/lib1funcs.S
--- linux-2.6.34.orig/arch/arm/lib/lib1funcs.S	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/lib/lib1funcs.S	2010-09-07 22:16:40.000000000 -0500
@@ -338,6 +338,43 @@ ENDPROC(__aeabi_idivmod)
 
 #endif
 
+#ifdef CONFIG_AEABI
+
+/* Patch added by NXP for unsigned long division in kernel
+    Inputs:-    r0, r1   -   divisor
+                r2, r3   -   divident  ( the higher bit is ignored in current implementation as we call __do_div64
+    Outputs:-   r0, r1   -   quotient
+                r2, r3   -   remainder
+*/
+
+ENTRY(__aeabi_uldivmod)
+      stmfd    sp!, {r4, lr}
+
+#ifdef __ARMEB__  /* If we have big-endian then move r3 to r4, because __do_div64 has 32-bit divisor */
+      mov      r4, r3
+#else
+      mov      r4, r2
+#endif
+      bl       __do_div64    /* The result is in r2 and r3 . and this is also written in assembly */
+
+      mov      r4, r0
+      mov      r0, r2
+      mov      r2, r4
+
+      mov      r4, r1
+      mov      r1, r3
+      mov      r3, r4
+
+#ifndef __ARMEB__
+      mov      r4, r2
+      mov      r2, r3
+      mov      r3, r4
+#endif
+
+      ldmfd    sp!, {r4, lr}
+      mov      pc, lr
+#endif
+
 Ldiv0:
 
 	str	lr, [sp, #-8]!
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/apollo.c linux-2.6.34/arch/arm/mach-apollo/apollo.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/core.h>
+
+
+MACHINE_START(APOLLO, "NXP BL-STB platform")
+	.phys_io	= IO_START,
+	.io_pg_offst	= ((IO_OFFSET) >> 18) & 0xfffc,
+	.boot_params	= (int)NULL,
+	.map_io		= apollo_map_io,
+	.init_irq	= apollo_init_irq,
+	.timer		= &apollo_timer,
+	.init_machine	= apollo_init,
+	.fixup          = apollo_fixup,
+MACHINE_END
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/ethernet.c linux-2.6.34/arch/arm/mach-apollo/ethernet.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/ethernet.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/ethernet.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <mach/gmac_eth_drv.h>
+#include <asm/setup.h>
+
+#ifdef CONFIG_USING_APOLLO_SOC_GMAC0
+static gmac_platform_data_t gmac0_platform_data =
+{
+	0,
+	GMAC0_CLK_CSR_VAL,
+	GMAC0_MAX_SPEED,
+	{0x00,0x06,0x37,0xFF,0xFF,0x01},
+};
+
+static struct resource gmac0_resources[] = {
+	{
+		.start		= GMAC0_BASE,
+		.end		= GMAC0_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= IRQ_GMAC0,
+		.end		= IRQ_GMAC0,
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= IRQ_GMAC0_POWER,
+		.end		= IRQ_GMAC0_POWER,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gmac0_device = {
+	.name		= "LIPP_6300ETH",
+	.id		= 0,
+	.dev.platform_data	= &gmac0_platform_data,
+	.num_resources	= ARRAY_SIZE(gmac0_resources),
+	.resource	= gmac0_resources,
+};
+#endif
+
+#ifdef CONFIG_USING_APOLLO_SOC_GMAC1
+static gmac_platform_data_t gmac1_platform_data =
+{
+	0,
+	GMAC1_CLK_CSR_VAL,
+	GMAC1_MAX_SPEED,
+	{0x00,0x06,0x37,0xFF,0xFF,0x02},
+};
+
+static struct resource gmac1_resources[] = {
+	{
+		.start		= GMAC1_BASE,
+		.end		= GMAC1_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= IRQ_GMAC1,
+		.end		= IRQ_GMAC1,
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= IRQ_GMAC1_POWER,
+		.end		= IRQ_GMAC1_POWER,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gmac1_device = {
+	.name		= "LIPP_6300ETH",
+	.id		= 1,
+	.dev.platform_data	= &gmac1_platform_data,
+	.num_resources	= ARRAY_SIZE(gmac1_resources),
+	.resource	= gmac1_resources,
+};
+#endif
+
+static int __init apollo_ethernet_init(void)
+{
+    unsigned int regVal;
+    int err = 0;
+
+#ifdef CONFIG_USING_APOLLO_SOC_GMAC0
+    /* Determine if GMAC0 is accessible by checking clock reg */
+    regVal = readl(APOLLO_CLK_GMAC0_AHBCLK);
+    if ( regVal != 0 )
+    {
+        /* See if its physical GMAC0 or GMAC1*/
+        /* Only GMAC0 has Internal PHY */
+        if (gmac0_resources[0].start == GMAC0_BASE)
+        {
+            /* Read the Global GMAC0 Control Register */
+            regVal = readl(GMAC0_CTRL_GLOBAL_REG);
+            /* Find out if Internal/External PHY bit is set by microloader */
+            gmac0_platform_data.isExternal = (regVal & 0x2000) >> 13;
+        }
+        else
+        {
+            /* GMAC1 has only External PHY */    
+            gmac0_platform_data.isExternal = 1;
+        }
+
+        /* Register GMAC0 */
+        if (platform_device_register(&gmac0_device))
+        {
+            err--;
+        }
+    }
+#endif
+
+#ifdef CONFIG_USING_APOLLO_SOC_GMAC1
+    /* Determine if GMAC1 is accessible by checking clock reg */
+    regVal = readl(APOLLO_CLK_GMAC1_AHBCLK);
+    if ( regVal != 0 )
+    {
+        /* See if its physical GMAC0 or GMAC1*/
+        /* Only GMAC0 has Internal PHY */
+        if (gmac1_resources[0].start == GMAC0_BASE)
+        {
+            /* Read the Global GMAC0 Control Register */
+            regVal = readl(GMAC0_CTRL_GLOBAL_REG);
+            /* Find out if Internal/External PHY bit is set by microloader */
+            gmac1_platform_data.isExternal = (regVal & 0x2000) >> 13;
+        }
+        else
+        {
+            /* GMAC1 has only External PHY */
+            gmac1_platform_data.isExternal = 1;
+        }
+
+        /* Register the GMAC1 */
+        if (platform_device_register(&gmac1_device))
+        {
+            err--;
+        }
+    }
+#endif
+    return err;
+}
+
+arch_initcall(apollo_ethernet_init);
+
+/* Mac address from TAG List */
+unsigned char stb_mac_address[2][6];
+EXPORT_SYMBOL(stb_mac_address);
+
+/* Reading MAC address from ATAG list */
+static int __init parse_tag_mac_address(const struct tag *tag)
+{
+  int i;
+  static int unitNum=0;
+
+  printk("EMAC address found in ATAG list ...\n");
+  for (i=0; i <6; i++) {
+         stb_mac_address[unitNum][i]=(u8)(tag->u.mac.mac_addr[unitNum][i]);
+  }
+  printk(" Mac 0 address bytes = %02x:%02x:%02x:%02x:%02x:%02x\n",stb_mac_address[unitNum][0], stb_mac_address[unitNum][1], stb_mac_address[unitNum][2],
+                                                   stb_mac_address[unitNum][3], stb_mac_address[unitNum][4], stb_mac_address[unitNum][5]);
+
+  if(unitNum==0)
+      unitNum=1;
+
+#ifdef CONFIG_USING_APOLLO_SOC_GMAC1
+  for (i=0; i <6; i++) {
+            stb_mac_address[unitNum][i]=(u8)(tag->u.mac.mac_addr[0][i]);
+          
+            if(i==5)
+                stb_mac_address[unitNum][i]=stb_mac_address[unitNum][i]+1;
+  }
+  printk(" Mac 1 address bytes = %02x:%02x:%02x:%02x:%02x:%02x\n",stb_mac_address[unitNum][0], stb_mac_address[unitNum][1], stb_mac_address[unitNum][2],
+                                                   stb_mac_address[unitNum][3], stb_mac_address[unitNum][4], stb_mac_address[unitNum][5]);  
+#endif
+
+  return 0;
+}
+__tagtable(ATAG_MAC, parse_tag_mac_address);
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/gcs.c linux-2.6.34/arch/arm/mach-apollo/gcs.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/gcs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/gcs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <mach/nor.h>
+#include <mach/gcs.h>
+#include <linux/io.h>
+
+ 
+static struct resource apollo_gcs_resources[] = {
+    {
+        .start      = APOLLO_GCS_CFG_BASE,
+        .end        = (APOLLO_GCS_CFG_BASE + APOLLO_GCS_CFG_LEN - 1),
+        .flags      = IORESOURCE_MEM,
+    },
+        
+};
+
+
+/* Do we need a GCS device ?
+static uint64_t apollo_gcs_dma_mask = ~(uint32_t)0;
+static struct platform_device apollo_gcs_device = {
+    .name       = "nx_gcs",
+    .id     = -1,
+    .num_resources  = ARRAY_SIZE(apollo_gcs_resources),
+    .resource   = apollo_gcs_resources,
+    .dev = {
+        .dma_mask = &apollo_gcs_dma_mask,
+        .coherent_dma_mask = 0xFFFFFFFF,
+    },
+};
+
+We could aggregate all the GCS peripherals here -
+static struct platform_device *apollo_gcs_platform_devs[] __initdata = {
+   &apollo_gcs_device,
+    &apollo_ip2016_device,
+   &apollo_sfc_device,
+};
+*/
+
+static int __init apollo_gcs_init(void)
+{
+    void __iomem *gcs_base=NULL;
+    
+    /**
+     * FIXME: This configuration must come from bootloader
+     */
+   gcs_base = (void*)apollo_gcs_resources[0].start;
+
+   #if 0
+   apollo_configure_gcs(base, gcs_base);
+   #endif
+
+
+   if (PCI_HOST_MODE_ENABLED)
+   {
+      writel(0x1, gcs_base + 0x0);   /* GCS PCI mode  */
+      writel(0x0, gcs_base + 0x4);   /* PCI host mode */
+      
+      writel(0x2, gcs_base + 0x8);
+      writel(0x01, gcs_base + 0x64); /* setup to SFC GCS Clock Mux */
+      
+      writel(0x4, gcs_base + 0x70); /* Enable NAND back-off for PCI requests */
+   }
+   else
+   {
+      writel(0x2, gcs_base + 0x008);
+      writel(0x01, gcs_base + 0x064); /* setup to SFC GCS Clock Mux */
+   }
+
+   /*return platform_add_devices(apollo_gcs_platform_devs, ARRAY_SIZE(apollo_gcs_platform_devs));*/
+   return 0;
+
+}
+
+#if 0 /* Revisit if we need to Reset the GCS @ kernel startup */
+static int __init apollo_configure_gcs( void __iomem *gcs_base)
+{
+    u32 rst_val, boot_sel;
+    /* Reset GCS */
+    rst_val = readl((unsigned long *)(0xe06e6010));
+    rst_val |= 0x200;
+    writel(rst_val, (unsigned long *)(0xe06e6010));
+    rst_val &= ~0x00000200;
+    writel(rst_val, (unsigned long *)(0xe06e6010));
+   
+
+    /* let burst-cfg register be default values */
+    /* default values for always_clk_cfg */
+    /* ebi_cfg - default values */
+
+    /* setup GCS_CONFIG for DCSN accesses */
+    writel(0x00, gcs_base + 0x000);              /* setup to ISA mode */
+    writel(0x01, gcs_base + 0x064);              /* setup to SFC GCS Clock Mux */
+    writel(APOLLO_NOR_BASE, gcs_base + 0x00C);   /* base address */
+    writel(0x00000000, gcs_base + 0x024);        /* remap address */
+    writel(0x03, gcs_base + 0x008);              /* remap enable, byte enable */
+
+    /* lets keep default addresses... */
+    /* dcsn-mmio accesses at 0x0000, and for DMA, the addresses shall be
+     * starting from 0xC0000000
+     */
+
+    /* 
+     * ahb_dscn_nor_aperture - same as default. though the chip addresses only
+     * 8 MBytes
+     */
+    /* Configure chip select Routing */
+    boot_sel = readl((unsigned long *)0xE06E6030);
+    if(boot_sel == 0xFFFFFFFD){
+        writel(0x00000000, gcs_base + 0x050); /* nor_cs_route  - IO_CS0 on SoC is connected to NOR flash */
+        writel(0x00000002, gcs_base + 0x054); /* nand_cs_route - IO_CS2 on SoC is connected to NAND flash */
+    }
+    else if(boot_sel == 0xFFFFFFDB){
+        writel(0x00000000, gcs_base + 0x058); /* sfc_cs_route  - IO_CS0 on SoC is connected to SFC flash */
+        writel(0x00000002, gcs_base + 0x050); /* nor_cs_route  - IO_CS2 on SoC is connected to NOR flash */
+    }
+    else {
+        writel(0x00000000, gcs_base + 0x054); /* nand_cs_route - IO_CS0 on SoC is connected to NAND flash */
+        writel(0x00000002, gcs_base + 0x058); /* sfc_cs_route  - IO_CS2 on SoC is connected to SFC flash */
+    }
+    
+    /* 
+     * Here yet we do not know who is going to setup GCS_CONFIG to select
+     * different chip-select at the SoC side. This is done here just for a
+     * temporarily
+     */
+
+    /*
+     * 
+     * The NOR flash is mapped at 0xC0000000 till +256MB for accessing with
+     * MMIO (using DCSN). It is mapped at 0x00000000 till +256MB for accessing
+     * with DMA. These are the default values as we understand.
+     * The NOR flash is connected to CS0 of the SoC and also CS0 of the IP_2016
+     * controller
+     */
+     return 0;
+}
+#endif
+arch_initcall(apollo_gcs_init);
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/gcs_dmac.c linux-2.6.34/arch/arm/mach-apollo/gcs_dmac.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/gcs_dmac.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/gcs_dmac.c	2010-09-07 23:01:30.000000000 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <mach/gcs_dmac.h>
+#include <mach/irqs.h>
+
+static struct resource apollo_gcs_dmac_resources[] = {
+	{
+		.start		= APOLLO_GCS_DMAC_BASE,
+		.end		= (APOLLO_GCS_DMAC_BASE + APOLLO_GCS_DMAC_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= IRQ_GCS_DMA,
+		.end		= IRQ_GCS_DMA,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static uint64_t apollo_gcs_dma_mask = ~(uint32_t)0;
+static struct platform_device apollo_gcs_dmac_device = {
+	.name		= "gcs_dma",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(apollo_gcs_dmac_resources),
+	.resource	= apollo_gcs_dmac_resources,
+	.dev = {
+		.dma_mask = &apollo_gcs_dma_mask,
+		.coherent_dma_mask = 0xFFFFFFFFU,
+	},
+};
+
+static int __init apollo_gcs_dmac_init(void)
+{
+	return platform_device_register(&apollo_gcs_dmac_device);
+}
+arch_initcall(apollo_gcs_dmac_init);
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/globaltimer.c linux-2.6.34/arch/arm/mach-apollo/globaltimer.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/globaltimer.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/globaltimer.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+#include <linux/time.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/core.h>
+#include <mach/hardware.h>
+#include <mach/globaltimer.h>
+
+#undef DEBUG_GLOBAL_TIMERS
+
+static unsigned long global_timer_vaddr  = 0;
+static unsigned long global_timer_irqnbr = 0;
+unsigned long global_timer_freq          = 0;
+
+static void timer_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *clk)
+{
+	unsigned long ctrl = 0;
+#ifdef DEBUG_GLOBAL_TIMERS
+    printk("GT: timer_set_mode = %d\n", mode);
+#endif
+
+	ctrl = readl(global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		ctrl |= (GLOBAL_TIMER_CTRL_IRQ_ENA |
+                 GLOBAL_TIMER_CTRL_COMP_ENA |
+                 GLOBAL_TIMER_CTRL_TIMER_ENA |
+		         GLOBAL_TIMER_CTRL_AUTO_INC);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+        writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+        writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+        writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_HIGH);
+        writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_LOW);
+		ctrl = 0x0;
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+        ctrl &= ~GLOBAL_TIMER_CTRL_IRQ_ENA;
+        break;
+
+    case CLOCK_EVT_MODE_RESUME:
+	ctrl |= GLOBAL_TIMER_CTRL_IRQ_ENA;
+        break;
+
+    default:
+	printk("Unknown timer event = %d\n", mode);
+        ctrl = 0x00;
+        break;
+	}
+    
+	writel(ctrl, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+}
+
+static int timer_set_next_event(unsigned long evt,
+				struct clock_event_device *dev)
+{
+	unsigned long ctrl;
+
+#ifdef DEBUG_GLOBAL_TIMERS
+    printk("GT:timer_set_next_event %lx\n", evt);
+#endif
+
+	/* The comparator needs to be disabled as race conditions
+	 * exist: we need to update the comparator value in two
+	 * steps as it is a 64 bit value */
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+	writel(evt, global_timer_vaddr + GLOBAL_TIMER_AUTO_INCREMENT);
+	writel(evt, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_LOW);
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_HIGH);
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+    ctrl = (GLOBAL_TIMER_CTRL_COMP_ENA |
+            GLOBAL_TIMER_CTRL_TIMER_ENA |
+            GLOBAL_TIMER_CTRL_IRQ_ENA);
+
+	/* Enable comparator + interrupt again */
+	writel(ctrl, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent = {
+	.name			= "global_timer_evt",
+	.features		= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode		= timer_set_mode,
+	.set_next_event	= timer_set_next_event,
+	.rating			= 300,
+	.cpumask		= cpu_all_mask,
+};
+
+static void __init global_clockevents_init(unsigned int timer_irq)
+{
+	timer0_clockevent.irq = timer_irq;
+
+    clockevents_calc_mult_shift(&timer0_clockevent, global_timer_freq, 4);
+
+#ifdef DEBUG_GLOBAL_TIMERS
+    printk("GT: timer0_clockevent->mult = 0x%x, timer0_clockevent->shift = 0x%x\n", 
+                (unsigned int)timer0_clockevent.mult, timer0_clockevent.shift);
+#endif
+
+	timer0_clockevent.max_delta_ns = clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	timer0_clockevent.min_delta_ns = clockevent_delta2ns(0xf, &timer0_clockevent);
+
+	clockevents_register_device(&timer0_clockevent);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t global_timer_interrupt_handler(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+	
+	/* clear the interrupt */
+	writel(GLOBAL_TIMER_STAT_EVENT, (global_timer_vaddr + GLOBAL_TIMER_STATUS));
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction global_timer_irq = {
+	.name		= "Cortex A9 Global Timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= global_timer_interrupt_handler,
+};
+
+static cycle_t global_get_cycles(struct clocksource *cs)
+{
+	uint32_t upper, lower;
+
+	/* The upper 32 bits might wrap around when reading the lower 32 bits,
+	 * so we continue reading until we are sure that the upper 32 bits
+	 * stayed the same while reading the lower 32 bits */
+	do {
+		upper = readl(global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+		lower = readl(global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+	} while (upper != readl(global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH));
+
+#ifdef DEBUG_GLOBAL_TIMERS
+//    printk("GT:global_get_cycles\n");
+#endif
+	return (((uint64_t)upper << 32) + lower);
+}
+
+static struct clocksource clocksource_global = {
+	.name	= "global_timer_src",
+	.rating = 300,
+	.read	= global_get_cycles,
+	.mask	= CLOCKSOURCE_MASK(64),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init global_clocksource_init(void)
+{
+	unsigned long ctrl = 0;
+	unsigned long count = (global_timer_freq / HZ);
+
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+	writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_HIGH);
+	writel(count, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_LOW);
+	writel(count, global_timer_vaddr + GLOBAL_TIMER_AUTO_INCREMENT);
+	ctrl = (GLOBAL_TIMER_CTRL_IRQ_ENA   | GLOBAL_TIMER_CTRL_COMP_ENA |
+	        GLOBAL_TIMER_CTRL_TIMER_ENA | GLOBAL_TIMER_CTRL_AUTO_INC);
+	writel(ctrl, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+
+	clocksource_calc_mult_shift(&clocksource_global, global_timer_freq, 4);
+
+#ifdef DEBUG_GLOBAL_TIMERS
+	printk("GT: clocksource_global->mult = 0x%x, clocksource_global->shift = 0x%x\n", 
+                        clocksource_global.mult, clocksource_global.shift);
+#endif
+
+	clocksource_register(&clocksource_global);
+}
+
+void __init global_timer_init(void)
+{
+
+#ifdef CONFIG_LOCAL_TIMERS
+        twd_base = __io_address(APOLLO_CORTEX_A9_PRIV_TIMER_BASE);
+#endif
+	setup_irq(global_timer_irqnbr, &global_timer_irq);
+
+	global_clocksource_init();
+
+	global_clockevents_init(global_timer_irqnbr);
+}
+
+void __init apollo_global_timer_init(unsigned long vaddr, unsigned long irq, unsigned long freq)
+{
+	global_timer_vaddr  = vaddr;
+	global_timer_irqnbr = irq;
+	global_timer_freq   = freq;
+  
+	global_timer_init();
+}
+#if 0
+static struct apollo_pm_timer_save pm_timer_save;
+void apollo_pm_timer_save(void)
+{
+    /*saving all the timer registers*/
+    pm_timer_save.low      =  readl(global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+    pm_timer_save.high     =  readl(global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+    pm_timer_save.control  =  readl(global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+    pm_timer_save.status   =  readl(global_timer_vaddr + GLOBAL_TIMER_STATUS);
+    pm_timer_save.cmp_low  =  readl(global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_LOW);
+    pm_timer_save.cmp_high =  readl(global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_HIGH);
+    pm_timer_save.auto_inc =  readl(global_timer_vaddr + GLOBAL_TIMER_CTRL_AUTO_INC);
+
+    writel(0x0, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+
+    return;
+}
+#endif
+
+void apollo_pm_timer_restore(void)
+{
+   unsigned long ctrl = 0;
+   unsigned long count = (global_timer_freq / HZ) + 1;
+
+   writel(0x0, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+
+   writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_HIGH);
+   writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COUNT_LOW);
+   writel(0x0, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_HIGH);
+   writel(count, global_timer_vaddr + GLOBAL_TIMER_COMPARATOR_LOW);
+   writel(count, global_timer_vaddr + GLOBAL_TIMER_AUTO_INCREMENT);
+   ctrl |=  (GLOBAL_TIMER_CTRL_COMP_ENA |
+             GLOBAL_TIMER_CTRL_TIMER_ENA | GLOBAL_TIMER_CTRL_AUTO_INC);
+   writel(ctrl, global_timer_vaddr + GLOBAL_TIMER_CONTROL);
+
+   return;
+}
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/gpio.c linux-2.6.34/arch/arm/mach-apollo/gpio.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/gpio.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/gpio.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: ??
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+ 
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+
+/**
+ * GPIO0 (Left): Resources and device data structure
+ **/
+static struct resource gpio0_resources[] = {
+	{
+		.start	= GPIO0_BASE,
+		.end	= GPIO0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= GPIO0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct apollo_gpio_platform_data gpio0_platform_data = {
+	.nr_gpio	= GPIO0_MAX_NR,
+	.irq_base	= GPIO0_IRQ_BASE,
+	.first_pin	= GPIO0_START_PIN,
+};
+
+static struct platform_device gpio0_device = {
+	.name			= "gpio_apollo",
+	.id			= 0,
+	.dev.platform_data	= &gpio0_platform_data,
+	.num_resources		= ARRAY_SIZE(gpio0_resources),
+	.resource		= gpio0_resources,
+};
+
+/**
+ * GPIO1 (Right): Resources and device data structure
+ **/
+static struct resource gpio1_resources[] = {
+	{
+		.start = GPIO1_BASE,
+		.end   = GPIO1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = GPIO1_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct apollo_gpio_platform_data gpio1_platform_data = {
+	.nr_gpio = GPIO1_MAX_NR,
+	.irq_base = GPIO1_IRQ_BASE,
+	.first_pin = GPIO1_START_PIN,
+};
+
+static struct platform_device gpio1_device = {
+	.name			= "gpio_apollo",
+	.id			= 1,
+	.dev.platform_data	= &gpio1_platform_data,
+	.num_resources		= ARRAY_SIZE(gpio1_resources),
+	.resource		= gpio1_resources,
+};
+
+static struct platform_device *gpio_devs[] __initdata = {
+	&gpio0_device,
+	&gpio1_device,
+};
+
+static int __init apollo_gpio_init(void)
+{
+	return platform_add_devices(gpio_devs, ARRAY_SIZE(gpio_devs));
+}
+arch_initcall(apollo_gpio_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/headsmp.S linux-2.6.34/arch/arm/mach-apollo/headsmp.S
--- linux-2.6.34.orig/arch/arm/mach-apollo/headsmp.S	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/headsmp.S	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * Apollo specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(apollo_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+1:	.long	.
+	.long	pen_release
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/hotplug.c linux-2.6.34/arch/arm/mach-apollo/hotplug.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/hotplug.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/hotplug.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ *  linux/arch/arm/mach-apollo/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+
+#include <asm/cacheflush.h>
+
+extern volatile int pen_release;
+
+static DECLARE_COMPLETION(cpu_killed);
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+	flush_cache_all();
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, #0x04\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  :
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		asm(".word	0xe320f003\n"
+		    :
+		    :
+		    : "memory", "cc");
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * The trouble is, letting people know about this is not really
+		 * possible, since we are currently running incoherently, and
+		 * therefore cannot safely call printk() or anything else
+		 */
+#ifdef DEBUG
+		printk("CPU%u: spurious wakeup call\n", cpu);
+#endif
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return wait_for_completion_timeout(&cpu_killed, 5000);
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+#ifdef DEBUG
+	unsigned int this_cpu = hard_smp_processor_id();
+	if (cpu != this_cpu) {
+		printk(KERN_CRIT "Eek! platform_cpu_die running on %u, should be %u\n",
+			   this_cpu, cpu);
+		BUG();
+	}
+#endif
+	printk(KERN_NOTICE "CPU%u: shutdown\n", cpu);
+	complete(&cpu_killed);
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu);
+	cpu_leave_lowpower();
+}
+
+int mach_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/apollo_logo.h linux-2.6.34/arch/arm/mach-apollo/include/mach/apollo_logo.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/apollo_logo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/apollo_logo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1369 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd.
+ *
+ * All prior copyright rights in this work and the accompanying software
+ * products transferred to Trident Microsystems (Far East) Ltd. by written
+ * agreement.  All rights reserved.
+ *
+ *
+ *   name:          splash_logo.c
+ *   version:
+ *   date_modified: Jun 17, 2010
+ *   derived_by:    ddouglass
+ */
+
+#ifndef APOLLO_LOGO_H
+#define APOLLO_LOGO_H
+
+static unsigned int __initdata logo_width = 214;
+static unsigned int __initdata logo_height = 100;
+
+/*  Use this macro to extract the pixel data.  */
+
+#define HEADER_PIXEL(data,pixel) {\
+pixel[0] = (((data[0] - 33) << 2) | ((data[1] - 33) >> 4)); \
+pixel[1] = ((((data[1] - 33) & 0xF) << 4) | ((data[2] - 33) >> 2)); \
+pixel[2] = ((((data[2] - 33) & 0x3) << 6) | ((data[3] - 33))); \
+data += 4; \
+}
+static char __initdata *header_data =
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`````````P\\````_`````````````````````````P\\_"
+	"`````````P\\_`````````````````````P\\_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````P\\_`P\\_```_`````PX_"
+	"_N(G_N<J`@4Y`P\\_`````````P\\_`P\\_`````@\\^RO8IN^\\B^PL\\`P\\_````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````P\\_`P\\^```_`PT^_NDK]J(%^\\<8`@8Y`P\\_`````````@X^`P\\_`P``UOLM"
+	"FM`5H^09^@L\\`P\\_````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P`_`P`_`P`_`P\\_``\\_``\\_`P\\__>@J\\W7N\\%[@^L$6````````"
+	"`P\\_`P\\_`````@\\_ZP4U;LP#@]4,WOXP`P\\_`````P\\_````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````P`_`@\\^``````\\_``\\_`P``_^XN"
+	"\\X/UZ1V_](CX_NXM`````````P\\_`@X^````\\0<XA-<.)JOGD-H1`0\\^`P``````"
+	"`@X^````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````@\\^`@\\_`P```@(X]IP!Z2.`Z\"\"]^<48`PX^`````P\\_`P\\_````]0@ZI.09"
+	"+J[J:,D!T_HL`````P\\_`@X^`````P\\_````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````P`^`@`_`P``^K\\5[4+1YA\"O[UO?_N`N````"
+	"`P\\_`PX_``\\`````N>XB1+?S*JSHON`C```````_`P\\_`@X_````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"``````````````````````````````````````````````\\_``X^`P\\_`@\\`__<S"
+	"\\6?EZ!>X[$+/^;D0`00Y`P`_`P\\^``\\_`@\\_W?XP9\\?`$*#>=<\\%Y`,U`````P\\^"
+	"`P\\_`P\\````_````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_`P\\_`P\\_`````@,Y^*0&Z2B^[#O(^;4/`@<[```_`P\\_``\\_``\\_]PHZ?-(("
+	"&J3B.K/OU/HL_`X^```_`@\\_`P\\_````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````P\\_`P\\_`````P\\__>,G[4C4YQ\"S\\6_I__TU`P``"
+	"```_`@X_````_`T^KNH=+*KG)*;DEMX4^PP\\`````P`_`@`^`P`_``\\``P`_````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````P\\_`````P\\_`P\\_`````/8R"
+	"]8_[Z!V\\[4'2^;L3`PX_`@`_`@\\^```_````X?`Q3[WW!);42KGTWO\\Q`@\\_`P\\_"
+	"`PX_`````P`_`@`^````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````````````P\\_"
+	"`````P\\_`P\\_`````PT^^;P2ZS/'Z!6X]9/]__HT``\\_`@\\^`@X^````\\0<XE]\\5"
+	"#YW<$Z#>A]@._`X^`````P\\_`P\\_`````P`_`P`_````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````P\\_`P\\_`````P\\__-@B\\&?CYQ\"OZB3!^;<1`@T^"
+	"`P`_`PX^`P\\_````O_$E,K#L\")O::<D!U?LM`````P\\_`P\\_``````\\`````````"
+	"`P`_````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````P\\^`````PX^_^\\M"
+	"\\WKOZAZ\\ZB.`\\W[R_>$G`@X^```_`P\\_````W?\\P<<L#!934&:/AJ^@=`0\\^````"
+	"`P\\_`P\\_````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````P`_`````````P`_````"
+	"```````````_`P```@D\\]IP!ZS'%YQ\"O[D74_=DC`@D[`@T^`P\\_````````F-`5"
+	"(ZCE$9S:<,T%W_\\Q```````^```_`````P\\_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P`_`@`^`````````P\\_`@X^`P\\_`P\\__>DK[D[9YA\"NYQNX\\G+L`?\\W"
+	"``\\``P```P\\``0X^T_HL4+SW!)C71KCSRO8H_PX]```_`P\\^`P\\_```````_````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````P`_`P`_`P`_`P`_`P\\_`P\\_`````/TU"
+	"]IT\"Z2;!Y1\"K[#O-^+4/`@<[`````P\\_```_]0DY>-$($IW;&Y_=B=D/]0DZ````"
+	"`P\\_`P\\_`P\\_```_````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````P`_````````"
+	"`@\\^`@`_`P`_``\\``P``_-HB[4/3YA\"RYQ.V\\G3M`00Y`@```P``````^`P\\P?(D"
+	"+JWI!)#0-K#LP/$D_0T\\`````@X^`P\\````_```_````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````P\\_`@\\^`@\\^`P\\_````_^`N](OXZ!BXYQ&P[D[8^;\\5"
+	"`````P\\_`P\\_````Y@(T9LH!#9K8#I[;=M$(\\`@Y`P\\_`P\\_```````_`P\\`````"
+	"```_````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````````````````````````````````````_`````P\\``@X^`@\\_```_`PT^"
+	"^+$-[#;+YQ\"PZ1FZ]9#\\`/TU`P\\_```^`P\\__`X^N>XB(:?D!);43KSVPO,F`@\\_"
+	"`P\\_`@X^``````\\_``````````\\_````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```_`P\\_`@\\``@\\_`PT^_-PD\\&7DYA\"OYQ&S[4C5^\\H:`P\\_`P\\_`P`^`P\\_W_\\Q"
+	"=\\`&!9?5!)?5?M,+]@DZ`P\\_`P\\_`P\\_`````P```P\\_``\\_````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````P````\\_``\\_`@```@\\_`0$W\\X+TZ22^YA\"MZ!BY]IX#"
+	"__DT`P\\_`P\\_`P\\__`X^JN@<*:OG!)74!)C7@]8,^0H[`P\\_`P```P\\_`P\\^`P\\_"
+	"`P\\_``\\_````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````P\\_`PX^`P```@<["
+	"^+@1[3S-YQ\"MYQ6X[U#:_-PD`P`_`P`_`P\\_````S?<K6\\+[!Y?4!Y?5-K'ML.D="
+	"``\\_`````P```@LP`@HL`PTZ``\\_``````\\_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````````````````````````````````````````````````````````_```^"
+	"```_`P\\``P\\``````P``_><I\\%O?Z!>WYQ\"N[#C-^K0/`@(X``````\\```\\`\\@<X"
+	"=L`'%Z+@!)+0#IK8@]8,X`$R`````P\\^`@8=`?GN`O\\$`PX^``\\`````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P`_`P`_`P`_`P\\_`P\\_`P\\___PU]Z,%ZA^\\YQ\"PZ!:Z\\6CG"
+	"`?\\V`````P\\_`P\\_^`P]M>P@,*WI!)'0!IC6*ZWHR/8H``\\_`````PLQ`?#.`.BP"
+	"`OGQ`P````````````\\_````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````P```````P`_`P`^`P\\^````"
+	"^]$?[DW7Z!.UYQ\"PZS7*]IP\"`P<[`P\\``P\\_````[P<W9\\G`%)_;!)33(ZGEAM@."
+	"[`<X`````PX]`@(/`=I``.6J`P$+`P````\\_``\\_````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\_`P\\^`P```/@T]9']Z!FYYQ\"TYQ\"O\\6+C_N0G`PT^````````]PHZ"
+	"KND<(ZGE!)32'*/A=L\\'[04V`P\\_`P```@@G`>[(`=-D`NJ]`P<A`P````\\_``\\_"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````P\\_`P\\^````^L07[E#8YA*PZ!.W[#K-"
+	"]Z0%`@4Z`P\\_````````T?DL3[[W\"IO8!([.'J3@AM@.`@X_`````@\\``?W``MN\""
+	"`=-H`?3@`PTW`P\\_``````````\\_````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````P\\``@X``P\\_```_"
+	"`PP^](KXZ!R[YA\"QZR;\"]I'\\_NHK`@X^`P```P\\_^0L[F-\\4#I[;!);5!YC5.K'L"
+	"FM`6_@T]`````P@D`NW&`=)B`MV,`O`&`@```P\\_```_```_````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\_`@X_`P\\_`PT^_-\\E[E3;YA\"LYQ:V[U/;_>$F`````P\\_`````@\\_"
+	"O>`D3;KU!)32!)?6.[3OBMD/T?HL_`X``````OCN`MN#`M1F`N['`P@E`@```P\\_"
+	"``\\_```_````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P```````P\\_`````P```P\\_`````08[](OYZBK\"YA\"MZRK$"
+	"^*H)`/TV`P\\_`P```@X_\\@8W<LT$\"IS:!);5#I[<F-X4\\`@Y`0\\_`P\\^``8@`>:N"
+	"`-!7`=EZ`OX\"`PXZ`@```P\\^``\\_```````_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````P```P```P\\_`P\\_````"
+	"`@D\\^\\\\=[4+1YQ\"SYQ\"T[3K/^LH;`@@[`P\\_````_PT]G^(7,*WI!)+1!)C7(*GF"
+	"ON`D`````P\\``PPS`?#0`=AT`=9N`>['`PDI`@\\``P`_`P\\^```_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`P\\_````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````P\\_`P\\_````````````````````````"
+	"`````````````````P\\_`P\\_````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P````\\_`@```@```@``````_N8I\\FWIZ1JZYA\"QYQ\"W[4#1_-(?`@D\\``\\``@X^"
+	"U_PN1[KT!IK9!)33$)[<;<P#WO\\Q`````PX[`@(-`-V)`=!6`>*9`@05`@X\\`@``"
+	"`@\\^`P\\_````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````P\\_`@X^````````````````"
+	"`````````````````````````P\\_`````````P\\_`P\\_`````````P\\_````````"
+	"`````````````````````````````````````````````````````````P\\_`@X^"
+	"`````````````````````````````````````````P\\_`P\\_````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````P\\_`````@X^`@\\_``\\_`0$X^*H)ZB\"^Z!\"TYA\"Q"
+	"YQ:Y[E7<_>(G`PT^````[04VAM<.%*'>!)32!YO9/++MRO8H_@T^`````@HL`O'/"
+	"`=-B`=-A`N[(`PX[``````\\_`````P\\_`@X^^P<X^04U^04U^04U^04U^04U^04U"
+	"^04U^04U^04U^04U]`4U]`4U]`0T]`0T]`0T]`0T^04U^04U^04U^04U]`0U]`0T"
+	"]`0T]`0T]`0T]`0T]`0T]`0U]`4U^04U^04U^04U^04U^04U^04U^04U_@HZ`P\\_"
+	"`P\\_`````P\\_`````````````````````````````````P\\_`````P\\_`@X^````"
+	"`````@X^`P\\_````````````````````````````````````````````````````"
+	"`````````````P\\_`````````0T]^`@X]`0T^04U^`@X_@HZ_@HZ_@HZ_@HZ`0T]"
+	"`P\\_````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````P\\_`P\\_`P\\_"
+	"`P\\__-,?\\%W?YQ\"RZ!\"UYA\"NZB_$]9G``@4Y`````@\\_Q_0H+J[K!IG7!)/2(J?C"
+	"B-@-]@DY`````P\\_`P$/`M^/`=%=`>*<`OX\"`P\\]`````````````P\\_]`0TS=H+"
+	"N\\?YNL?YNL;XN<7WN<7WN<7WN,7WN,7WM\\3WM\\3VM\\/VM\\3UM\\/UM\\+TML+TN,3V"
+	"N\\CZN\\CZO,C[O,CZN<7XML+UM<'TML/UML/UML+UML/UML/UM\\3VM\\/WN,7WN<;X"
+	"NL?YN\\?YN<;XO\\O]WNL<`0T]`P\\_````````````````````````````````````"
+	"`````````P\\_`P\\_`P\\_`````````P\\_`P\\_`````P\\_`P\\_````````````````"
+	"`````````````````````````````````````````````P\\_]@(RU>(3O<G[P,W^"
+	"R]@(T]\\0U.$2TM\\/W.D9\\?XN````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````@\\_````````````]Z<'ZB?#YQ\"TY1\"QYA\"S[U[@_N,G`PP^````"
+	"YP(TA=8-#IO:!)C7!)73,J_JKNH>^`P\\`P\\_`@<C`>[(`=)A`MN!`?CL`@X[`P`_"
+	"```````_`````0T]Y/$BC9G,9W2G97*E8&R@8&R?8&V@8&ZA8&ZA86ZA8W\"C97*E"
+	":'2G:G>J;7FL<'RO<GZR<7ZP;7JM;'FL;'FL;'BL;GNN=8*U=(&T<7ZQ<'VP<'VP"
+	";7JM;'FL:G>J9G.F8G\"C8&ZA8W\"B:76H9W2G=H.UN<;X_`P\\`````P\\`````````"
+	"`````````````````````P\\_`````````@X^`P\\_````````````````````````"
+	"`@X^`P\\_````````````````````````````````````````````````````````"
+	"`````P\\_\\O\\OR-4&G*C:>X>Z<7^Q=(&T=8*U<'VOD9W0TM\\0````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````P````\\_`P```P\\__-@B\\&3DZ!&TYQ\"V"
+	"YQ6V[4W7^+(.`@D\\``\\_````M.P@.K/N!I;6!)?5!)C65+_YXP$R`@\\_``\\_`_OY"
+	"`MN#`=!7`>J[`P8?`P```P\\_``\\_``X`````_@H[U>(3=(&S3%F-6669<7VP@8_!"
+	"A9+%A9/%B9;(CIO,DI_1EZ/6FZC:H:W?I+'CK+CJJ;7ID)S/7FN>5F.65&\"46F>:"
+	">H>ZKKKLM\\3VKKKMJ[CJJ[CKI[/FHZ_BGZS>F:78D9[0?XR_9W*F4EZ23UR09W2G"
+	"ML/U`````````````````````````````````````````````P\\_`@X^`````P\\_"
+	"^04UU^05Q]4%VN<8_@DZ``\\`````````````````````````````````````````"
+	"`````````````````````P\\_`````P\\_^P<WZ?8ET=X/G*G;:G>J4V\"35F.64%V0"
+	"@8V`SML,````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````````````````````````````````````````_````````````````````"
+	"`P\\_`/\\V\\W[SZB*`YA\"OZ!.X[3_0]ZL)`/XV`P\\_`P\\_ZP0U=,X%!IO8!)C6!)74"
+	"'*7BA]@.`````P```P8@`NJZ`M%=`=AX`?OX`PTY`P```P\\^``\\_``\\`````^P@X"
+	"R=8'<7ZQ:'6HEZ/5Q=($V><7W>H;W>L<X>X?Y_,CZ_@G[?HK\\?XN]@(R^04U_`P\\"
+	"]@$SPL[`:G>J76J=66:99G.GI+'C^@8U````_`T\\_@LZ_PL[^@8W]`0T]0$Q\\/TM"
+	"Z?<FU^46K[SN>(6X6F::=(&TQ-$\"`````````````P\\_````````````````````"
+	"`````````P\\_`P\\_````_0DYS=D+CIK,<7ZQDI_1W^P=_PL[````````````````"
+	"`````````````````````````````````````````````````P\\_`P\\_````````"
+	"````V.46B)3'6&687FN>66:9D9[0VN<8````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`````````````````P\\_````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````^```_`P\\_`@X^`P\\_`@D\\^\\P;[3O.YQ\"PZ!\"RZ1BY\\W[S_^LL`````P\\_"
+	"_@T]H>08-*_K!)/3!)G7!I?64;[WP?(F`````PPV`O'0`M=O`=-@`>FX`@<F`@``"
+	"`P\\_`P`^```_``\\`````]P0SM\\3V<7ZQG*C:ZO<H````````````````````````"
+	"````````````````````````]0$QN,;W9W2G7&F<6&69:G:JL+WO^04U``````\\`"
+	"````````````````````````````````^04UN\\CZ9W.F>H:YR]@)`````P\\_`@X^"
+	"`````````````````````````````````````````P\\_[OLJC9K-76F>3EN.86ZA"
+	"LK_Q]0$Q````````````````````````````````````````````````````````"
+	"`````P\\_`````````P\\_`````0T]W.D:C9K,6F>:7VR@6VB;FZC9XN`@````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````P\\_`````````````````@X^`P\\_````````````"
+	"`@X^`P\\_````````````````````````````````````````````````````````"
+	"```````````````````````````````_```_`P\\_`P\\_```_`?\\V\\X/TZ2*]YQ\"Q"
+	"Z!\"TZ!BW\\W[Q_NLL`````@X^X?`Q4[_Y\")K:!)?7!)C7$)_=C=H0]PH\\`PXZ`OW`"
+	"`MV)`LU,`=EZ`?GR`@PV`@```@\\^`P\\^```_````````\\/TMH*W?BI;)R]@)````"
+	"`P\\_`P\\_````````````````````````````````````````[_PLJ[CJ9'&D76J="
+	"66::;WROO,G[^P<W`````````````````````````````````P\\_`P\\_````ZO<G"
+	"AY/&B)3'SML,`````P\\_`P\\_````````````````````````````````````````"
+	"_0DYS]P,<'RO66:966688W\"CHJ_A[_PL````````````````````````````````"
+	"````````````````````````````````````````````````_`P\\T-T.A9+$66:9"
+	"7VR?7FN=IK/DZO@H````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````P\\_`P\\_`P\\_"
+	"`````P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_````````````````````````````````"
+	"```````````````````````````````````````````````````_`P\\````_```_"
+	"``\\_`P``_>(G[D/2Z!*WYA\"SYA\"QZ1R^^*`,`0$W````]PDZA]@.'Z7C!)74!)G7"
+	"\")K94K[WQ_4G`P\\_`PPR`^['`=5H`M!7`>.?`@08`@X]`@\\_`@X^`P\\^```_`P``"
+	"````\\?XNK+CJN,3WZ?8F`````P\\_`@X^`````````````````````````P\\_````"
+	"````````Z?<FGZS>86ZA76J=6F>:=(&TQ]4&^`@X````````````````````````"
+	"`````````P\\_`@X^````]0$QGZO>F*37TM\\/`````````````P\\_````````````"
+	"````````````````````````]`0TO\\S]9W.G6V>:7&B<86ZAHJ_@[OPL````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````_PL[Q-$#?8J]66:97VR?8&V@L+SN\\O\\O````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P\\_`@X^`P\\_`````````P\\_[?HK\\_`Q_PL[````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\``````P\\_`@X]`````/DS]I`$Z2\"]Z!\"TZ!\"TZ1N[[UK?_><I````"
+	"`@\\_R/0H-+#M!9G8!)C7!)C6#)[:E-X3[`<Y`P\\_`@06`>&4`=!8`==S`^[+``LQ"
+	"``\\``````````P```P`_``\\^````^@8WV>86Y_0D^`@X`````````````P\\_````"
+	"`````````````````````@X^`P\\_````Y?(BE:+38&V@7&J=6VB;>H:YU.(2_@L["
+	"`````````````````````````````````P\\_`@X^````^@8WR]@(Q=(#YO,C````"
+	"````````````````````````````````````````````````^P@WS-H);GNN5&*6"
+	"56*5;'FLOLO\\]`0T````````````````````````````````````````````````"
+	"`````````````````````P\\_`@X^`P\\__@H[N\\?Y=X.V6F>:7VV@8W\"CN<7X^@8V"
+	"`P\\_````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````P\\_````````_@DY[OLKSML,KKKM"
+	"W>H;_0DY````````````````````````````````````````````````````````"
+	"```````````````````````````````````_`P\\``P\\_`P\\_````^\\D9[4C5YQ2U"
+	"YQ\"SZ!2X[D[7^L(5`@8[````WO\\P<<T%\"IO9!)C5!)G7!);5%Z/@OO$D`P```PHK"
+	"`?+7`=5L`<]3`N&7`OS^`PX]``````\\_`````P```P`_```_`P\\_`P\\_`@X^`P\\_"
+	"`P\\_`P\\_`P\\_`````````````````````````````````P\\_`P\\_````X.T=BI?)"
+	"7VR?76J=7&F<@(R_W^P=_`P\\`````````````````````````````````P\\_`P\\_"
+	"`````@X^_0DY_0DY_`P\\````````````````````````````````````````````"
+	"`````````@X^Z_@HDI[08W\"C9W.FEZ37Z?8G`@X^````````````````````````"
+	"`````````````````````````````````````````````P\\_`P\\_`P\\__@HZLK[Q"
+	"<GZQ66>:7VV@9W2GPL_`_`P\\`P\\_````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````````````P\\_"
+	"`@X^]`0TU>(2I;+C=8*U;'FLT-T._`P\\````````````````````````````````"
+	"`````````````````````````````````````````````````````````````@X^"
+	"`P\\_`P\\___,O\\X/SZ!\"TYA\"UYQ\"PZR_&]I7]`@P]`P\\_`0X^I^8:'J?C!)G7!)K8"
+	"!);4!Y?50+;RU/PN``````$*`=V,`=!9`M1J`O#-`@LS`P\\^``````X^`P``````"
+	"`````````@X^`P\\_`````````````@X^`P\\_````````````````````````````"
+	"`P\\_````````````V>86?XN^8&V@7&F<7VR?AY3'Y_0E`0T]````````````````"
+	"`````````````````````P\\_`````P\\_`@X^`@X^`@X^`````````P\\_````````"
+	"`````````````````````P\\_````````````_PL[W.D:L;WOM\\/UYO,C_`P\\``\\_"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P\\`_0DYJ;7H;7JM6VB;7VR?;GNOR=<(`P\\_`P\\_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P\\_````````_@HZQM,#?8J]6&696&:9=H.VV^D9`P\\_````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`````````PX_^;$-[3_/YA\"OYQ\"UYA\"N[E3;^](?````"
+	"````S?<J7\\/]!Y?5!)K6!)K7%*#=3+CSI.49\\PD]``LL`?#1`=)@`=!5`=^.`?KV"
+	"`P\\^`P\\``P\\_``````\\_`````````P\\_`````````P\\_`````P\\_`````````P\\_"
+	"`````````````````````````````````P\\`````T=X/=(&S7VR?7&F<8W\"CD)W0"
+	"[OLK`PX^`````````````````````````````````P\\_`P\\_`P\\_`P\\_`````P\\_"
+	"`P\\_`P\\_`P\\_`````````````````````````````````````P\\_`P\\_`P\\_`P\\_"
+	"_@HZ\\?XN\\_`P`0T]`````P\\_`P\\_`P\\_````````````````````````````````"
+	"`````P\\_`P\\_`````````````````````P\\_````^04WH*S?:7:I6F>:8&V@>(6X"
+	"T=\\0`P\\_`P\\_`````````````````````````````````````````````P\\_`P\\_"
+	"`P\\_`````````````````````P\\_`P\\_````````````````````````````````"
+	"`P\\_`P\\_`````````````P\\_`P\\_`````````````````P\\_`P\\_````````````"
+	"`P\\_`P\\_`````````````````````````````````P\\_````^04UI[/D97*E4%Z1"
+	"76N=@H[!XN\\@`P\\_````````````````````````````````````````````````"
+	"```````````````````````````_`````P\\````_`````````PX_`/8R\\V_KZ16Y"
+	"YQ\"TZ!\"UZ1Z\\]8WZ`@,X``\\__`X_B-D/&Z7B!)73!)G6!IO:3[WWMNL@[P8X`@\\^"
+	"`_OV`M^2`<Y4`-)>`.S$`P8?`P\\_`P\\_`@X^````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"RM<):G>I8&V@7&F<9G.FFJ;9]@(R`P\\_`````````````````````````P\\_````"
+	"`P\\_`@X^`````````P\\_`P\\_`@X^`````````````P\\_````````````````````"
+	"`````P\\_`````````@X^`P\\_`````````````````P\\_`@X^````````````````"
+	"`````````````````P\\_`````````P\\_`@X^`````````````````````````P\\_"
+	"\\O\\PEJ/69G.F6VB;7VR?@H_\"V>87`P\\_`P\\_````````````````````````````"
+	"`P\\_`````````P\\_`P\\_`@X^`P\\_`````P\\_`````````````P\\_`@X^````````"
+	"`````P\\_`P\\_`````````````@X^`P\\_`````````````@X^`P\\_`````````P\\_"
+	"`````P\\_`@X^`````````````P\\_`@X^`````````````P\\_`````````````P\\_"
+	"````````]@(RFZ;997*E5F.69'&DC9G,Z?8F````````````````````````````"
+	"`````````P\\_`````````````````````````````````````P`````_```_`P\\`"
+	"`@X^`````@@\\^;L3[3_0YQ\"QZ!\"WZ!\"S[4#0^;T3`PX_`0X_V/TO3;SV!)33!)G7"
+	"!);6#)W<@M4,_`X_`````PHL`NN\\`M)@`=%<`-V(`OO]`@X]`P\\_```^```^`P\\`"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`PX^P<[_9'&C8&V@7&F<:W>KI+#B^@8W`````P\\_````"
+	"`````````P\\_`````````@X^`P\\_`````````````````P\\_`@X^`````P\\_`@X^"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_`@X^`````````````````````P\\_`````````````@X^````````````````"
+	"`````````````````````P\\_[OLLCIO-8F^B7&F<8&V@C)G+X.T>`P\\_`P\\_````"
+	"`````````````````P\\_`````````P\\_`P\\_`````````````````````````@X_"
+	"`@X^`````````````P\\_`P\\_`@X^`````````@X^`@X^`@X^`````````P\\_`P\\_"
+	"`@X^`````````````P\\_`````````````````````````````````````````P\\_"
+	"`@X^````````````````````````````]@(REJ+59G.F5F.69G.FFJ;9[_LL````"
+	"`````````````````````````````````````P\\_````````````````````````"
+	"`````````````P`_`P`_`P\\_`P\\_`````?\\W\\73NZ2\"^YQ\"SZ!&VYQ\"Q[U7;^\\P<"
+	"`PX_^PP\\CML0):GE!)33!)K8!)?6%:+?C=H/`P\\_``\\\\`OKV`MV*`<U,`=9O`?/;"
+	"`PHK`P```P\\^`P\\^```^````````````````````````````````````````````"
+	"`````````````````````````````````````````P\\_^04VM\\/U86ZB86ZA7&F<"
+	"<'VPK;OM_0DY`````````````````````````P\\_`P\\_`P\\_`P\\_`@X^_0DY^04U"
+	"_PL[`@X^`P\\_`````P\\_`P\\_`P\\_`0T]_0HY^`<W^P<W_PL[`P\\_`P\\_`0T]`0T^"
+	"`@X^`P\\_`P\\_`P\\_`P\\``P\\_`P\\_`P\\_`````````````````````````P\\_`P\\_"
+	"`````P\\_`P\\_`0T]^`@X]P,S\\?XN[OPL\\?XN]P,T_0DY_`T]Z_@HAY/&7FN>7&F<"
+	"86ZAEJ+5Y?(C`P\\_`P\\_`P\\_`````````````````````P\\_`P\\_`P\\_`P\\_````"
+	"`P\\__PL[^P<W]0$Q\\/TNZO<IY_0E[_PM^04U_`P]`````P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_^P<W[_TM^04U_`P\\`````P\\_`P\\_`P\\_`````P\\__@HZ^P<W]@(R"
+	"\\?XN\\?XO^04U_@L[`P\\^`P\\_`P\\_`P\\_`0T]_`P\\_PL[_`P\\_PL[`@X^\\/TNCYS-"
+	"9'&D5V27:G>JI;+D[OPL_`P\\_@HZ_@HZ_PL[_`P\\_PL[_PP\\_PL[_`P\\`@X^`P\\_"
+	"```````````````````````````````````_`P```P`_```^```_`PX__N,G[3_1"
+	"YQ\"SYQ\"TZ!\"UZ!.U]('T_^DK``\\`XO`R1[KT!YO:!)?6!)G7\"9W:8,7]R?8H````"
+	"``PU`^FY`]-G`]%:`>&6`@,4`P\\]`````P\\^`P\\^```^```````_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_\\/TNK+GL7VR?86ZA6FB;>(2WNL;X_PL[`````````P\\_`P\\_`````````@X^"
+	"`P\\_````````\\/XMO\\S^HJ_@V>86^`@X`````P\\_`````````0T]Y?(BP<[`K;KL"
+	"K;KLT-T-^P<V^P<WZ/4FZ?8F\\_`P]P(S]`,T^`@Y_PL[_PL\\`P\\_`````P\\_````"
+	"`````````P\\_`````P\\_`P\\_`````````@X^XNX?M\\/UEJ+4@8V`>8:Y@Y##F*37"
+	"NL?XW.D:W>D;@8[!7&F<76J=9'&DH*S?ZO<G`P\\_`P\\_`P\\_````````````````"
+	"`````@X^`@X^`P\\_````````\\_`PSML,K+GKCYO-@8Z`?(F\\?8J]@X_\"HJ[AVN<9"
+	"`````````````@X^`@X^`P\\_````````\\_`PML+TAI/%P,W_]0$Q`````P\\_`@X^"
+	"````````]`0TS=L+J+7HD)W0AI+%B97(GJO=R=<'\\_\\P````````_@HZ[/DJV^@9"
+	"UN,3U>$2U>$2UN,3PL[`?8J\\8W\"B7&B<:'6HCIO-O,G[Q]4%QM,$S-D)U.$1UN,4"
+	"UN,4UN,3UN,3W>H:]0$Q`P\\_`````````````````````````````````P``````"
+	"`P\\_`@\\^`P```?\\W^*L)Z23!YQ\"QZ!\"TZ!\"VZR_(^;X3``L^\\PLZGN$7'J3B!)?6"
+	"!)G7!IK7+Z[JL>L?^@P^``TU`?GS`=N$`<]6`=)B`N6C`P@H`````@\\_`P``````"
+	"`P\\````^````````````````````````````````````````````````````````"
+	"`````````````````````````@X^Z/4EHZ_A7&J=86ZA66::?XN^Q=(#_PL\\````"
+	"`P\\_`````P\\_`P\\_`@X^````````_`P\\WNL<I[3F=8.V<'ROQ]0%^04U````````"
+	"`P\\_Y?(CO,CZE*#3>(6Y;7JL:'6HC9K,R]@(Y/$BM\\/UH:W@HZ_AI;#CI[/FJ;7G"
+	"M<'TU.$3_@HZ`````````````P\\_`````````@X^`P\\_`````P\\_YO0DN,7WD)W/"
+	"?XR^=X2W<GVQ:'6H7FN>76J=<'VPCYS.GJK<<G^R7VR?76J=9G.FK+?I[OLK`P\\_"
+	"`````````````P\\_`````P\\_`@X^````````````Z?8GP,W^FZC;@H[!=(&T;'FL"
+	"8&V@5F.65&&46F>:9W2HD9W0S-D*_0DZ````````````````_`P\\W^L<J;7G<GZQ"
+	"6VF=LK[P\\O\\O````````````]`0TT-T-I+#AAY3&<GZR8F^C6F:;6F>;97*E?HN^"
+	"L;WO[/DJ`P\\_[/DJK;GL?XR^@H_\"@Y#\"AI+&B)3'@(V_:G>I8F^B8&V@97*E=(&T"
+	"@H_\"A)##@8[!@Y#\"A9'#@X_\"@8V`?HJ]?8F\\G:G<WNL<`P\\_````````````````"
+	"`````````````````P`_`````P\\_`@\\^`P``_^HL\\6KGZ!BYYQ\"SYQ\"SYQ6V[UG>"
+	"_N<J````T_HL3+SU\"YK8!)?7!)C6#IS::\\L\"Y@(T`````P8<`>.?`=)C`LY3`=AU"
+	"`>W'`PLP`P```P```P`````````````_````````````````````````````````"
+	"`````````````````````````````````````P\\_`````````@X^W^L=F*777&F<"
+	"86ZA66:9AI+%T-T._`P\\`````P\\_`P\\_`````P\\_`P\\_````\\?XNR]@(DI_29W2G"
+	"4V\"3:G>JRM<(^P<W````_0DYU>$2EZ/6:G:I5F.65F.75V274%V09'&DGJK;W^P<"
+	"PL[_F:77>86X8&V@8F^B7FN>=8&TL;WP^@8V`````````````````P\\_`P\\_`P\\_"
+	"````^`@XT]`1GZS?@8Z`B)3&H:W@L\\#RNL;XM,#RFJ;9<7^Q66686&279G.F9'&D"
+	"8F^B76J=9W2GML/T\\O\\O`P\\_`````````````````P\\_`P\\_`P\\_````^@8WU>,4"
+	"H:W@?XR_>X>ZB9;)FZC;J;;IH:[@A9+$9'&D76J=5F687&F<AI+$V.45_PL[````"
+	"````]0$RS]P-DY_29W.G4V\"48&V@OLK]]P,U````````\\O`PO,CZD)S/AI'%EZ/5"
+	"G:G<E:+5?8J^7FN>5V2856&5<7VQM,#S_@HZZ?8GHJ_A=(&S@(V_@Y#\"BI;)BI;)"
+	"?(B[8W\"C8&V@86ZA;WRODZ#2GJO=F:;9DZ#3CYS.AY/&@8V`>XBZ<G^Q;'FLEJ+4"
+	"WNH;`P\\_``````````````````````````````````\\``P`_`P`_``\\_````^\\D:"
+	"[#3*YQ&VYQ\"VYQ\"RZ2\"\\](;U`_8S]`\\]G^,8$*#=!)C6!)C6!)C6)JGEK^D>]PD["
+	"`P\\_`?S_`M=P`M!9`M-A`>2D`@(1`@X[`P\\```X```\\`````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_`P\\_`@X^U>(4CYO.7&F<8&V@6F>:CYO-V^@9`0T]`````````````@X^`P\\_"
+	"`P\\_ZO<HML+T=8&T6F>:66:97VR?>(:YV.47_`P\\_PL[U>(4AI+%86ZA66:976J="
+	"86ZA8W\"C7FN>9'\"CD9W/\\_\\P````Z/4FI+#B7FN>6VB;5&&4;WROM\\/T^P<W````"
+	"`P\\_`````P\\_`P\\_````````^@8VT-T-AY3&>(6WIK/EX^`@`P\\_````````````"
+	"]`0UP<W_@X_!6VB;7&F<8&V@86ZA76J=:G>KP,W_]P0S`P\\_`P\\_`````P\\_`@X^"
+	"`P\\_`````P\\_^@8WR=<(A9+$:WBKDY_2QM,$[/DJ_`P]`````0T]U>(3CYS.8F^B"
+	"7VR?6&688&VAG:G<\\O\\P`@X^[_PMP,S^?(B[7&F<6&6876J=:G:IR]@)_PL[````"
+	"]@(RM\\3V>H>ZBI;)S]P-^@8V`P\\_^04UQ=,#=(&T86Z@6VB;6VB;@(V`[?HJ^P<X"
+	"Y?(CV>87XN\\?Y/$A[OLJY?(CN,3W:G>K76J=7FN>A9+$X^\\?`@T]_PL\\]`0U\\?XO"
+	"Z?8GX>\\?VN@8S]P-QM,#V>86]@(R`P\\_````````````````````````````````"
+	"`````P\\_`P\\_`P```/@S]9C`Z!FXYA\"VYQ\"UZ!6Y[DW8_<\\=`PP^R/@J4[WX!)C5"
+	"!)G8!);5&*+@<<T&[P8X`````P<B`>[)`=)@`L]5`=R'`O7F`P\\^`@\\``P\\_``\\_"
+	"``\\_````````````````````````````````````````````````````````````"
+	"`````````````````````````P\\_`P\\_`@X^S=H+AI/&7&F<8&V@7&J=F*77Y_0D"
+	"`@X^`````````````P\\__0DYS-D)DY_1:G>J76J=76J=76N>8&V@@8V`YO,C`@X^"
+	"Q]0&@8[!A9+%N,3WN,7WC9G,8&R@8&V@76J=9G.EEZ36]P(T````^`@XPL[`:7:H"
+	"7VR?6&68>X>ZQ-$\"_0DX`````````P\\_`P\\_`P\\_````]P,SO\\S]=X2VC9O-R]H*"
+	"]P,S`0T]`````P\\_`P\\_`P\\_`P\\_^`@XQ=(#=H.V7FN>8&V@86ZA7FN><7VOR]@)"
+	"^P<W`P\\_`````P\\_`P\\_`P\\_`P\\_`P\\_]@(RK[OM>8:YA)'$QM0%[?HK^`@X`@X^"
+	"`````P\\_````^@8VQ]0&;7JM7FN>76J=7VR@@(V`XN\\?VN<7F:78:G:J7FR?7FR?"
+	"7VR?7VN>;WRNU>(2````]0$QK[SN<W^RH:S?X>X?_0DZ````````````YO0DF:77"
+	"9'&D76J=7&F<=H.UVN46_@HZ_`P]_PL[_`P\\_`P\\```_\\_`PN\\CZ9W2G7&F<7VR?"
+	"CIK,\\OXP`````````````P\\_`0T^_`P\\_PL[_0DY^P<W_@HZ`@X^`P\\_````````"
+	"`````````````````````````````P\\_`P\\_````_-4@\\&+CYQ6RYQ\"VYQ\"TZ!J["
+	"\\6+D`/@T_@``C=P2%*+?!)G6!)O9!)+1)ZGEGN,8_0P^`````OCP`=R&`M%;`L]2"
+	"`N2G`P(.`P```@\\``P\\^```^```_````````````````````````````````````"
+	"`````````````````````````````````````````````P\\_`````````0T]Q-$!"
+	"?(F\\7&B;86ZA76J=H:W?\\O\\O`@X^`````````````@X^\\_`PK;GKFJ;8FZC::7:I"
+	"8&V@76J=8W\"CC)C+\\O\\OSML+B9;)A9'%T]`0]@(R^`@XS-D*>86X6V>;5&&59W.G"
+	"H:W@^`@X````^P<XQ-$#:7:I8&V@6F>:@8[\"S]P-_@HZ`````````P\\_`P\\_````"
+	"]`0UO<G\\>H:YC)C+T-T._`P\\`````````P\\_`@X^`@X^`P\\_`````P\\_Z?8FHJ_A"
+	"8F^B7VR?8&V@7VR?=H.UU>,3_PL[`P\\_`````P\\_`P\\_````````\\/TMI;'C=X.V"
+	"D9[1U^05^P<W`````````````````````````P\\_X^`@>(6W7FN>7FJ=86VA>XB\\"
+	"VN<7O\\O]DY_2E*'4<GZQ8V^B7VR?8&V@>8:YXN`A]P,SM\\/U<G^RG*C:WNH;`P\\_"
+	"`````````P\\_````\\/TMK[OM:'6H7&F=76J==8*UTMX0^`@Y````````````````"
+	"````[OLKK;KL8W\"C6F>:8V^BE:'4^@8W`````P\\_````````````````````````"
+	"`````````````P\\_`````````````````````````````````P\\_`````````P\\_"
+	"^*<(ZS'(YQ&RZ!\"VYQ\"TZ!FZ\\V/E`_TWR?TM4+[X!9;4!)O8!)K8!YK73[SVR_<J"
+	"_P\\```DD`NNZ`M!;`=%=`-9O`/'3`0DJ`@\\``P`_`P`_`@\\``P``````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\_````_`P\\NL;Y=(\"S7&F<8&V@86V@JK;H^`@X`P\\_````````````"
+	"`@X^]`0TSML,UN,2S]P-<7ZQ7VR?6F>:9W2GDZ#2UN(3FZC:BI?)QM,%_`L\\````"
+	"````\\?XNJK;H:'6H4E^3=(\"SO,G[_`P\\````]0$RNL;X97.F7VR?6F>:AY3'V>86"
+	"_PL[`````@X^`P\\_````_@HZPL[`@(V`=8.US=H+_@HZ`````@X^`@X^`@X^````"
+	"`````P\\_`P\\_`P\\_^@8VQ=(#:G>J7VR?7FN>7VR@>X>ZW^P<`@X^`P\\_`P\\_`P\\_"
+	"````````\\?XNLK[P;7FMBI;)T]`1`````````````@X^`````P\\_`P\\_````````"
+	"Y_,D>H>Z7VR?66:98&ZAD)S.Y/$BW.D9S=H+T=\\0?HN]8F^B7&F<8W\"CA9'$U^05"
+	"O,?Z?HN]@8Z`V^@8`0T]`````@X^`P\\_````````\\O\\PM\\/U:G:J7&F<7FN>=X2V"
+	"T^$2_0@Y`````````P\\_`@X^````Y_0DGJO=8&V?66>:9W.FGZO=_PLZ````````"
+	"`````````````````````````````````P\\_````````````````````````````"
+	"`````````````````P\\___$O\\G/LYQ\"UYQ\"UYQ\"WYA\"SZR;!]WSQ^OLS>M<+&Z7A"
+	"!)74!)K8!)?5-+'KF=`5]`L\\`P\\\\`OGM`MZ*`LY1`=-B`>6F`?\\&`@\\]`@\\_`P`_"
+	"`P`_`P```P``````````````````````````````````````````````````````"
+	"`````````````````````````````````````P\\__@H[L;WO;7NM76J=7VR?9G.F"
+	"L[_R`PX^`P```````P\\_`P\\_`P\\_`@X^`@X^`P\\_U>(3;7JM7FN>7&F<:7>IC)G+"
+	"FJ?8DZ#2Q-(\"`P\\_`P\\_````````_PL[XN\\?G:G<?(F\\H:[@YO,C`@X^````[?HJ"
+	"K[OL8F^B7VR?6VB<CYO.X^`@`0T]`````P\\_`P\\_`0T]U^,4?HJ]:'2GL;[O_PL["
+	"`````P\\_`P\\_`P\\_`P\\_`````````P\\_`P\\_`P\\_`PX^V.45=H.U8&V@76J=86VA"
+	"@(R_Z/4E`````P\\_`P\\_`P\\_`P\\_^`@XP<W_;'BK>8:YSML,`````P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_````_PL[T-T.<G^R6VB;5F.7;GRON\\?Z^P<W````````Y/$B"
+	"=X2W7FN?76J=9W*EAY/&I;+C>86X<X\"SRM<(_PL\\`````P\\_`P\\_`P\\_````````"
+	"\\?XNL[_Q:7:I7&B<7FN>>H>YW.D:_PL[`````````P\\_`P\\_````X>X>DY_18&V@"
+	"6&68;7FLJK;H`@X^````````````````````````````````````````````````"
+	"`````````````````````````````````````````PP^^K`4[4K4YA\"OZ!\"VYQ\"U"
+	"YA\"R]5?=_M4@R_<I.+?P!)?5!)K7!)G6!YK8@=4,[08X`P\\_`P@H`>FS`=5I`M!8"
+	"`=1G`O#.`P@D`P\\_`@```P\\_`P`_```````_````````````````````````````"
+	"`````````````````````````````````````````````````````````````P\\_"
+	"^@<WJ+7F:'6H76J=7FN>;WRNO<CZ`````P\\_`````P\\_`````@X^`P\\_````^@8W"
+	"P]$\":'6H76N>7VV@9G*E<7ZP>(6WQM0#^`DY`````P\\_`P\\_`P\\_`````0T]]@(R"
+	"Z_@H\\O\\O`P\\_`P\\_````YO,CH[#B7VR@7FN>7FN>EZ/5[/DI`@X^`````````P\\_"
+	"[OLKD9W086V@CIO-[/HJ`@X^`````P\\_````````````````````````````````"
+	"````XN\\??8J]86ZA6VB;8W\"CB97)[OLL`````````P\\_`````@X^R]D(?(F\\97*E"
+	"O\\S^]P,S`````P\\_`P\\_`@X^`P\\_`@X^`P\\_`P\\_````YO,CEZ/58F^A4V&49G2E"
+	"GZS>\\O\\P`P\\_````_0DYS]P.<7ZQ7VN>8&R@9'&D;WRO9'&D<7ZQL+SM_PLZ````"
+	"`P\\_`@X^`````P\\_`P\\_````[/HJIK/E9W2G7&F<7FN>@(V_Z?8F`P\\_````````"
+	"````````````V^@8A9+$7VV@5F27<G^RML+S`````````P\\_````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`PP^^+0.ZS[,Y1\"GYQ\"NYQ\"PZ1^__X?X\\O(M>-8+%Z3?!)74!)K8!)?5&*3@J^@<"
+	"`````PTT`O7D`MI^`M%8`=)?`=5J`O#0``@D``\\_``\\_`P\\_`P`````_```_````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````P\\_]0$QGZO=8G\"B7FN>7&F<=X.VQ=,$````````````"
+	"`P\\_`P\\_````````````]/`QN<7W9'&D76J=8F^B8&V@:76HI;+DZO<H`````P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`````````````````P\\_`P\\_````WNL;EZ/676J=76J=8V^B"
+	"GJK=\\O\\O`P\\_`P\\_````]0$QL[_P97&E<W^RO<G[_`P\\`````P\\_`P\\_````````"
+	"`````````````````````P\\_````Y/$B?HN^86ZA66>:9G*EE:'4\\_\\P````````"
+	"`P\\_`P\\_X>X>CYS.86V@CYO-[/DJ`````P\\_`P\\_`P\\_`P\\_`P\\_````````_@HZ"
+	"U^05FJ?98V^A56&5:7:II[/EY_0D`@X^````````]`0SPL\\!;'FL7FJ>8FZB86ZA"
+	"7VR?8&Z@I++C[?LI`````````P\\_`````P\\_`P\\_`P\\_````Z/8FF:;897*D6VB;"
+	"86V@B)3'\\?XN`````P\\_````````````````TM`1>8:Y7VR?56*6>(2WP,S]`P\\_"
+	"`P\\_`P\\_````````````````````````````````````````````````````````"
+	"`````````````````````````PX^_=PC\\6_HZ2*\\ZBG![4K6^)3__-XEQ.`D+;#K"
+	"!9K8!)C6!)G7#)W;8L7_U?LM`````PDJ`>>L`M1F`=!9`=%;`M-@`O#/`P@E`P\\_"
+	"`P```````````P``````````````````````````````````````````````````"
+	"`````````````````````````````````````````````@X^[?LKE:+576J>7FN>"
+	"6F>:?XV_SMP-`````````````P\\_`````P\\_````````[_PLK[SN86VA76J=7VR?"
+	"8&V@?(F[W.D:`0T]`````@X^`P\\_`````````P\\_`````P\\_`````````P\\_`@X^"
+	"````UN,4C)G,7&F<76J=9G.FIK+D^@8V`````````@X^U.$2=X2W6&68FZ?9YO,D"
+	"`PX^`P\\_`@X^`P\\_`P\\_````````````````````````````````W^P=?(B[86ZA"
+	"6&68:'6HH*W?]@(S`````P\\_````^@8VJ;7H8W\"C;'BKQ]0%_@HZ`P\\_`@X^`P\\_"
+	"````````````_PL[W>L<L+WO?8J]6VF;7&B;@(R_ML+TZ/4F`P\\_````````````"
+	"\\O\\OML+T9W2G7FJ>8V^C76J=6VB:D)W/V^D9`````P\\_`````P\\_`````P\\_````"
+	"````````X_$ACIO-8W\"C6F>:97&DDY_2]@(S`````````````````P\\_`P\\_RM<("
+	"<7ZQ7VR>5F.7?XR_RM<(`P\\_`````````P\\_````````````````````````````"
+	"`````````````````````````````````````````P\\_`````P\\_`@<[^\\06](7W"
+	"](GY^KP3``(YX@`Z>M8*#YO9!)C6!)G8!)K8*:SHN.TA^@L]`````@,0`MV'`=-@"
+	"`]);`M)>`==U`?CL`@LR`P\\_```_``\\_````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````@X^Y?,CC9K-6F>:7FN>6F>:BI;(U^05`````P\\_`@X^`````P\\_````````"
+	"````ZO<GI;'D8&R@76J=6VB;9W2GG:G;^P<W`````P\\_`````````P\\_`P\\_````"
+	"`P\\_`````````P\\_````````````SML-@8[!6VB;7&F<:G>JKKKL`0T]````````"
+	"[/DII[/F66:99'*EP,W^`0T^`P\\_````````````````````````````````````"
+	"`````P\\_`@X^V.45=X.V8&V@5F.6:WBKJ[CI]`4U`````P\\__PL[UN,3>8:Y5F.7"
+	"C9K-\\?XN`@X^`````````````@\\^^@8VZ/4EQM,$E*'4:'6H66>::G>JE*#2RM<("
+	"^P<W`````````P\\_`@X^````[?HJJ;7H8W\"C76J=86ZA7VR?<X\"QS-@)_0DZ````"
+	"`P\\_`@X^`````P\\_````````````````W.H;@Y##86ZA66:9:7:IGZO=^@8W````"
+	"````````````````_PL[P<W^:WBJ7FN>6&68B)3'U>(3````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````P\\_`P\\_`P\\_`PH\\`@4Z`@4Z`PD\\````L.\\@*:WG!IC5!)K7!)?6#IS;5+_Y"
+	"Y@(T`````PDH`O+3`M1H`M!:`M)@`MM\\`>[)`@DH`@```P\\_``\\_```_````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````0T]VN<9AY/&66:97FN>7&F<DZ#2WNL;````"
+	"`P\\_`P\\_`````````P\\_`P\\_````Y/$AFZ?97VR?7FN?6&69<GZRO<G[_@HZ`P\\_"
+	"`@X^````````````````````````````````````````````````Q=,#=X2W7&F="
+	"6VB<;GNNML+T````````````S-D)>(6X6&68@8W!VN<8`````P\\_`P\\_````````"
+	"`````````````````````````````P\\__@HZS]P-<GZP8&V@5V27;WROM\\/U^@8V"
+	"````````\\/XNG*G:7VR?:G>JLK_Q`P\\_`P\\_`````0T]^@8VZ/8FPL[_D9W0:W>K"
+	"8W\"D>XB\\H:[AR]D)[_PL_PL[`P\\_`P\\_`P\\_`P\\_`@X^````Z/4EG*C;8F^B7FN>"
+	"76J=;'BLJK?I\\?XN`````P\\_`P\\_`P\\_`````````````````P\\_`P\\_U>(3>X>Z"
+	"86V@6&68;'FLJ;;G_PL[````````````````````]`0TML/T97*D7FN=66:9D)W/"
+	"W^P=`P\\_````````````````````````````````````````````````````````"
+	"`````````````````````````````P\\_`P\\_`````````````````P\\_X@$Q<,T#"
+	"!)C5!)G6!)O8!)?5$)W;6<+[Y`,T`P\\_`?\\$`M^-`M%?`L]6`=EY`N_*`@LO`@``"
+	"`@```P\\_``\\_````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````0T]SML,?XR^"
+	"6&687FN>76J=GJK=Y?(B`````````````P\\_`````@X^`P\\_````WNP<D9[07FN>"
+	"7FN>66:9@8Z`W.@:_`P\\`P\\_`@X^````````````````````````````````````"
+	"````````````O<G[;7JN7&J>6F>;=H*UO\\O]`````P\\_\\_`PJ+7G7&F<7FN?H[#B"
+	"ZO<G`````P\\_`P\\_`````````````````````````````````````P\\_^@8VQ=,#"
+	":WBJ7VR?6&27=8&TP<W`^`@X````_PL[T]`1<7VP56.6B97(U>(3`````````0T]"
+	"W^P=K[SN@H^`:WBJ=H.VEZ77P,S_XN\\A]0(R_0DY`@\\^`````````P\\_`@X^`@X^"
+	"`@X^````X^`@D)W/86ZA76J=76J=?(B\\U>(4_@HZ`````@X^`P\\_`````P\\_````"
+	"````````````_`P\\S=H+<G^S8&V@6&68<'VPL[_Q_`P\\`````````P\\_````````"
+	"\\?XOK+GK7VR?76J=6F>:F*77Z?8G`P\\_````````````````````````````````"
+	"`````````````````````````````````````````````````P\\_````````````"
+	"`````P\\_`````P\\_I.49,:_J!)33!)K7!)O9!)33&J+@BMD0\\@@Z`PPL`?#/`=-E"
+	"`=)>`=!6`=V(`OCM`@X[`@\\_`@\\^`PX^``\\_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_````````_`P\\Q-$!>(2W5V277FN>7FN>J;7G[/DI`````````````````P\\_"
+	"````````````U^06AI/%76J=7&F<8&V@EJ'4\\O\\P`@X_`````````P\\_````````"
+	"`````````````````````````````````@X^M+_R97&D7FJ=6F>:?8J]Q]0%````"
+	"`@X^U.$2B)3(4V\"4:'6IP<W_]P,S`````````````P\\_````````````````````"
+	"`````````````P\\_]0$RNL;Y97*E7FN>6F>:>X>ZS-D*_0DY````Z_@HI;+D7VR?"
+	"66::GZS>Y/$AZ?8FR=8'J+3FD)S.A9+%CIK-IK+DQ=(\"X>\\?]`0T````````````"
+	"`````P\\_`P\\_````````````````````W>H;A9+$8&V@76J=7VR?A)'$YO,D`0T^"
+	"`````````````P\\_````````````````````_@HYQ=(#:7:J7FR>6&68=H.VO<G["
+	"`0T]`P\\_`@X^````````````Z?<GHJ_A7&F<7FN>7FN>H:W?\\?XN`P\\_````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````````_`````````P\\_`P\\_`````P\\_Z00U8\\;_\"9O:!)C7!)O8!)C7$)_="
+	"5<#YS?@L_@\\``_W^`>&8`=!8`M-@`=!8`>\"1`?OW`0XZ`@\\_`@\\_`P\\^``\\_````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````P\\_`P\\__`P\\NL;W<G^R5V277FN>8F^BL[_P"
+	"\\O\\O````````````````````````````````T=X.?8J]76J=6F:9:W>JJK;H_0DY"
+	"`P\\_`````````````````````````````````````````````````P\\__@DYJK?I"
+	"7VR?7FN>66:9A)'#S]P-````_PL[LK[Q;WNO5V67=X2VUN05_`P\\````````````"
+	"`````````````````````````````````````P\\_[OLKK[KM8W\"C7VR?6F>;@(V`"
+	"U^05_PL[````T=\\0?8J\\7&F<76N>BYC*L+SOI[/ED)O/AY/'E:+3LK_PU.$3]@(R"
+	"`P\\_`````````P\\_`````P\\_`P\\_`P\\_`P\\_`````````````````P\\_U>(3>X>Z"
+	"8&V@7FN>8&V@B9;)[?HK```_````````````````````````````````````^04U"
+	"O,CZ8W\"C76J=6&:8?(F\\R-4&`0T]`````P\\_````````````X>\\?F:786F>:76J="
+	"9'&DJ;;G]`0S`P\\_````````````````````````````````````````````````"
+	"```````````````````````````````````````_```_````````````^0L[H.(7"
+	"+:WI!)74!)O:!)K8!);50K?SM>PA_@T]``\\``?'0`M9M`M%;`M)A`]!9`N*<`/\\%"
+	"`@X\\`@X_`@X^`P\\```````\\_````````````````````````````````````````"
+	"`````````````````````````````````````````````````P\\_````````_PL["
+	"KKON;GNN66:87VR?9G.FO,C[]`0T`````````````````````P\\_````````R=8'"
+	"=X.V7FN>66:9>(2VN\\?X_`P\\`````P\\_````````````````````````````````"
+	"`````````````P\\_\\O`PHJ[@76N>7FN>6&68C)C+V.45````]@(REJ/57FN>7VR?"
+	"B);(YO,D`````````````````````````````````````````````P\\_`P\\_`P\\_"
+	"Z/4EHZ_A86ZA7FN>7&F<AY3%X^`@`P\\^^`@XML+T9'&D7FN>7VV@:':I=(&TA)##"
+	"HJ_AS-H*\\_`P`````````````P\\_`@X^`P\\_`````P\\_`````````````````P\\_"
+	"`````````````@X^S-H*<G^R7VR?7FN>8F^BD)S/]P,T`````P\\_````````````"
+	"````````````````````\\O\\OL;[P7FN>7FJ=6668@Y#\"U.$2`0T]`````````@X^"
+	"`P\\_````VN<7D)S.66::76J=:WBJL\\#Q_0DY`P\\_````````````````````````"
+	"```````````````````````````````````````````````````````````````_"
+	"`P\\_`P\\_```_```_X`$R2;OU\")O9!)?5!)O:!)K8!9?68L;_XP$S`P\\``PHJ`.>M"
+	"`M%;`=%@`=)?`M)A`NBQ`@48`P\\]`P`_`@\\^`P\\_``\\`````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````_0DYI+#B:WBJ6F>97FN>;'FLQ]0$_@HZ````````````"
+	"```````````````_`@X_P<W`;GNN7VR?66:9@X_\"R-4&`0T]`````P\\_````````"
+	"`````````````````````````````````````P\\_Z?8FF*376VB;76J=6&68E*'3"
+	"X.X>````X>X?@Y##5F.697*EFJ?9\\/TM`````P\\_`P\\_````````````````````"
+	"`````````````P\\_`P\\_`P\\_XN\\?EZ/57FN>7&F=7FN?CYS-[/DI`P\\_YO,CG*C:"
+	"66:976J=:WBKE:+5Q=,$Y?(C]0$Q_0DY`P\\_`````P\\_`P\\_`P\\_`P\\_`P\\_````"
+	"`````````````P\\_`P\\_````````````````_@HZP]$\";7JM7VR?76J=97*EF:78"
+	"_0@Y````````````````````````````````````````Z_@HI[+E76J=7FJ=6F:9"
+	"B97(WNL;`0T]`````````P\\_`P\\_````T-X/A9/%66:97&F<<GVQO<C[`0T]`PX^"
+	"````````````````````````````````````````````````````````````````"
+	"```````````````````_`````P\\_`P\\^````\\`DYF=`5&Z/@!);4!)K9!)O9!)K8"
+	"!)?6;<L$[`<Z`P\\[`O\\\"`>\"2`=!6`M)@`=)@`>6F`?W``@XY`P\\_`@`_`@`^`P\\_"
+	"``\\`````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````^P<WF*779G.F6VB;7VR?"
+	"<7ZQT-T.`P\\_`````````````````````````P\\__PL[N,3V9W2G8&V@66B;CIO-"
+	"U>(3`@X^`````P\\_`````````````````````````````````````````````P\\_"
+	"W^P<CYS/6&697FJ>6VB:G:K<Z?8G_`P\\RM<'=X2W4V\"4:G>JJ+3F\\_`Q`````@X^"
+	"`P\\_`````````````````````````````````````````P\\_V^@9BY?*76N>7&F<"
+	"8F^CEZ36\\_`O`@X^SML+A9'#5F.66V>:BY?*S]P,_0DY`@X^````````````````"
+	"`@X^`@X^`````````````````````````````P\\_`P\\_````````````````]`4U"
+	"NL?X9W2F7VR?6V>::G>JI+#C_`P\\````````````````````````````````````"
+	"````Y/$BG*G;6VB;7FN>7&F<D)S/Y?,B`@X^`````P\\_````````````Q]4%?(J\\"
+	"66:97&F<>(6XQ=($`@X^`@\\_````````````````````````````````````````"
+	"`````````````````````````````````````````P\\_```````_`P\\_````S?@J"
+	"1KKT!YG7!);5!)O:!)K8!)?5(ZGEE]\\4^`P^`PTX`_/;`=I]`M!7`=)@`M1C`_#."
+	"``DG`````P\\^`@\\^`@`^`P`_`````P\\_````````````````````````````````"
+	"`````````````````````````````````````````````````````````````P\\_"
+	"````]0$QCIO.8W\"C6VB;8&V@>8:YV><7`````````````````````````````P\\_"
+	"^04TK[OM86V@8&V@6VB;EZ36X.T=`@X^`````````P\\_````````````````````"
+	"`````````P\\_`````````P\\_U>,3B);'6&6876N>76J=IK+E\\O\\P^`@XML+S;GNN"
+	"4V\"3;7JNL;[P]@(R`````````````````````````````````````````````P\\_"
+	"`````P\\_T]`1@(V`7FN>6VB;:'6HH*W@^@8V_`P\\N,3U<7ZP6&277&>;H:[@ZO<G"
+	"`````````````@X^`````P\\_`````````P\\_`````````````````P\\_`````P\\_"
+	"`P\\_````````````````\\?XOL+WO86Z@7FN>6F:9;WNNKKOM`0T]`````````P\\_"
+	"`````````````P\\_````````````WNL;DY_26F>:76J=8&R@F*37[?LK`@X^````"
+	"````````````````OLO\\=(&T6F>:7&F<@Y##S=L,`P\\_`````````P\\_````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````P\\_`P\\_````\\0<XE=X3$I[<!)G7!)O8!)O9!)K8\"IK8:\\H!U/LM`P\\``PLO"
+	"`NBU`M5L`=%;`M)@`M1F`^[+``<B`P```P\\^`P\\_`P`_`P`_`P`_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````ZO<HAY3'86ZA6VB;86ZAA9'#X.T=````````"
+	"`````````````````````P\\_\\?XMIK/D7FJ>7VR?76F<H*S>Z/4E`@X^````````"
+	"`````````````````````````````````````P\\_`P\\_`@X^R]D)@8[!66:97FR?"
+	"7VR?L+SN_0@X^04VIK+D:7:I5&&4<'VPML+U]P,T````````````````````````"
+	"`````````````````````````P\\_`P\\_RM<(=8*V7FN>7&F<;'FLJK;I_@HZ_PL["
+	"I;'C97*D6V>;7VN>J;;HZ_DI`P\\_`````````P\\_````````````````````````"
+	"`````````````````P\\_`P\\_`P\\__@HZ]P,S]P,S```_[/DIIK/F7FN>7VR?6&68"
+	"<W^RM\\/V`0T^`P\\_`P\\_`````````````````````P\\_`P\\_````U^04BI7(66:9"
+	"7&F<8V^BH*S?]P,T`@X^`````````````P\\_````M,'S;'FL6VB<7&F=CIO.U^04"
+	"`P\\_`P\\_`P\\_````````````````````````````````````````````````````"
+	"```````````````_```_`P\\``````P\\_`P\\_````P/(E3KSV\");4!)K8!)S:!)K8"
+	"!9K8*ZWIK^D>^@L]`P`^`P,2`MZ.`M%@`=)>`=)>`M1G`N[(`P8?`@```P`_```_"
+	"`````P`_`P`_````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````0T]W^P=@([!8&V@"
+	"6VB<86ZBDI[0YO(C`````P\\_`P\\_`````````````````@X^Y_0EG:K<7&F<86ZA"
+	"86V?J+3F[OLK`P\\_`````````````````````````````````````````````@X^"
+	"`P\\_`@X^P<W`>H>Z66:97FN>86Z@N,7W`0T]]`0TG*G;9W2G56*5<'VPM\\/V]P,T"
+	"`````````````````````````````````````````````````P\\_`P\\_P<[_:WBK"
+	"7VR?6VB;<'VPL\\#R_`P\\]0$QEJ/68&V@76J=86VAL+SN[_PM`P\\_````````````"
+	"`````````````````````````````````P\\_`````P\\_`P\\_`P\\_YO,CP<W^R=8&"
+	"_@HZZ/4EG*G<7&F=7VR?5F27>(.VP<W^`@X^`P\\_`@X^````````````````````"
+	"`P\\_`P\\_````T-T.@(R_6V>:7&F<9W2FJ;;G_@HZ`@X^`````````P\\_`````@X_"
+	"JK;H9'&D76J=76J=F:;9W^L=`P\\_`P\\_`P\\_````````````````````````````"
+	"```````````````````````````````````````_```_```_`P\\_`P\\_````_`X^"
+	"C-H0%J/@!)?5!)K8!)S:!)?5#)S:7,/\\VOTO`````PLP`?CI`=AS`=!9`M%:`=%:"
+	"`=V(`?CM`@LP```````````_`P`_`````````P`_````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````_@HZUN,4>8:Y7VR?7&B<8V^CG:G<ZO<G`````P\\_`P\\_````````````"
+	"`````0T^W>H:E*#366:98&V@8W\"CK[ON]@(R`P\\_````````````````````````"
+	"`````````````````P\\_`````````@X^N,3V=(\"S6&687FN>:7:JPL[``@X^]`0T"
+	"FZ?:9W.F56*5;WVPML+U]P,S`````P\\_`P\\_````````````````````````````"
+	"`````````P\\__`P\\N,7V8W\"C8&V@6VB;=X2VO,G[`0T]Z?8FCIO.76J=7FN>86ZA"
+	"L;WP\\/TM`P\\_`````````````````````````````````````````````````P\\_"
+	"`P\\_`P\\_````R]@)E:'3Q=(#_PL[X>X>E*#36VB;7FN?5V28?8J]RM<(`@X^````"
+	"`````P\\_`````````````P\\_````````````Q]0%=X.V7&F<7&F<;7JML[_Q_`P\\"
+	"`P\\_````````````````^P<WGZO>7VR?7FN>7&F<H*S>Y/$B`P\\_`````````P\\_"
+	"```````````````````````````````````````````````````````````_````"
+	"```_```^`@X_`P\\_`@\\_V/TO6L'\\!);5!)K7!)O9!)S9!)?5$Z#>B=@/[P8W````"
+	"`PLP`?;E`=5I`LQ+`M%=`=N!`?'4`08?`@X^````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````^@8WRM<(<X\"R7FN>7&F<97*EJK;I[OLL"
+	"`````````````P\\_`````````````0T]U.$1BYC*6&688&V@97*EM<'S^P<W`P\\_"
+	"```````````````````````````````````````````````````_`0T^K;GL;WNN"
+	"66:97VR?<7^RR=8'`@X_]P,TFJ;:9W.F56.6;GJML+SN]@(R`````@X^`P\\_````"
+	"`````````````````````````````````P\\_]`0TKKOL7VR@8&V@6F>:?HN^QM0%"
+	"`P\\_WNL<AY3'6VB;7FN>7VR?J[CI[?HJ`P\\_`````````P\\_````````````````"
+	"`````````````````````@X^`P\\_````]`0TK[ONBY?*Y/$B````V.45BY?)6F>:"
+	"7FN>666:A9'%U.$2`@X^`````````````````````````````````P\\_````OLK\\"
+	";GNN76J=6VB;=8*UO<G[`0T^``````\\``P`_`````@X^[_PLEZ357&F<7VR?7FN="
+	"I;'DY_0E`P\\_````````````````````````````````````````````````````"
+	"`````````````````````P\\````_```_```]```__`X^G.$6+:WI!)33!)O8!)S8"
+	"!)O8!);3&Z;BL>H>]`H[``````TX`_`(`N.@`=M``N*?`O/;`@8?`@\\^`@````X^"
+	"``\\_````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````]P,TO\\O]"
+	";GNN76J=7&F<:7:IM\\/U\\_`P`````````````````P\\_`@X^````_`P\\R]@)@H_\""
+	"5V278&V@9G.FNL?X_`P\\`P\\_````````````````````````````````````````"
+	"`````P\\_````^P<XH[#B:G>J6VB;7VR?>X>ZT-T.`P\\_]P,SFJ;:9G.G5F.6:G>J"
+	"I+#C\\O\\P`````````````````````````````````````````````````P\\_[?HJ"
+	"I+#B76J=8&V@6F>:A9+%T-X/`@T^U^44@H_!6F>:7VR?76J=H*S>YO,C`P\\_`P\\_"
+	"`@X^````````````````````````````````````````````````````T=X/G*C;"
+	"I[/F_0DY````SML+@8[!66:97VN?6F::C9G,W>H;`P\\_````````````````````"
+	"`````````````````P\\_ML+T:'6H7VR?6F>:?HN]QM,$`@X^`````P`_``\\`````"
+	"`0T]Y/$@CYS.7&F<7VR?8&V@J[CJ[/DI`P\\_````````````````````````````"
+	"`````````````````````````````````````````````````P\\_`P\\_```^```_"
+	"\\0<X6\\+\\\"IW:!)?5!)O9!)O9!)K7!)C5,K#KUOLM`@\\^```_`P\\_`PTX`@,1`OX#"
+	"`P4<`PTX`@\\^`P`_`P\\_`P\\_`P\\_````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````\\_`PL[_R:WBK7&F<76J=;WNNP\\_`]P,S````````````````"
+	"`P\\_`P\\_````_`P\\P,W_>XF\\6&687VR?:'6HO\\S]`````P\\_````````````````"
+	"````````````````````````````````````]@(SF:;997*E7&F<7VR?@Y##V.46"
+	"````]P,SGJO=9W6H5F279G.FE*'3[OLK````````````````````````````````"
+	"```````````````````_XN\\@F:;86VB<8&V@66:9C9K,V><8`@X^U.(2@(V_66:9"
+	"7VR?6VB;DI[0W>H;`P\\_`P\\_`P\\_`````````````````````````````````P\\_"
+	"`P\\_````````^@<WHJ[AG*C;V^@9`0T]````QM,#>8:X6F>;7VR?6F>:DY_2Y_0D"
+	"`P\\_`````````````````````````````````P\\_^P<WK;GK9'*E7VR?66:9AY/%"
+	"S]P-`PX_`````P\\_````````_PL[V.45AY/&6F>:8&V@8F^ALK[P\\/PM`P\\_````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\_`P\\^```_]`L[L^P@+*SI!);4!)K8!)O9!)K9!);6(*;C?-(*\\P@Y"
+	"`P\\_`P`^`@\\^`@\\_`0X[`PXZ`PX\\`P\\``@\\_`P`^`P\\^`@```P``````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````P\\_`P\\_````[_PMJ+3G:'6H7&F=76J==(\"S"
+	"T=X.^`@X````````````````````````````_PL[ML/V=(&T66:97FN>:WBKQ=($"
+	"`````P\\_`````````````````````````````````````````````````P\\_\\/TM"
+	"CYS/86ZA76J=7VR@C9K,W>L;````^04UI[3F:7:I5V2786ZA@H_!XN\\?`P\\_````"
+	"`````````````````````````````````````````P\\_V.46CYS/6F>:8&V@6F>:"
+	"E:+4X_$A`0T]U>(3@8[!6VB;8&V@76J>?8F]S]P,`P\\_`````P\\_````````````"
+	"`````````````````P\\_`P\\_`@X^````^04VO<K[D)S/O\\O]```_````````O<GZ"
+	"<7VP7&F<7VR?76J=F:;9[OHL`P\\_`````````````````````````````````@X^"
+	"\\/TNHZ_B86ZA7VR?66:9D)S/U^05`P\\_``````\\`````````_@HZRM<(?XR^66:9"
+	"8&V@8W&DM\\3W\\_`Q`P\\_````````````````````````````````````````````"
+	"```````````````````````````_`P\\````_```_````YP(T:\\L!%*#=!);5!)S9"
+	"!)O9!)K8!)740+;RP/$E_0T]`P`_`@`]`@X^`@`_`P```@```@```@\\_`PX^``X^"
+	"`@`^``\\`````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````P\\_`@X^````"
+	"Z_@IFZC:97*E7&F<7VN?>X>YW.H9_`P[````````````````````````````_0HZ"
+	"J[CJ;7JM6V>:7FN><G^QRM@)````````````````````````````````````````"
+	"`````````````````0T^Y_0EAY/&7FN>76J=86ZAEZ/7X^`@````^@8WML+T;GNO"
+	"66:97FN><'ROS=L+_0DY`````````````P\\_`````````````````P\\_````````"
+	"````S]P,AI/%66>:7VR?7&F<GZO=Z_DI`@X^X.T=B9;(7&F<8&ZA7VR?;'BKNL;X"
+	"_`P\\`P\\_`````````P\\_`````````````````````@X^`P\\_````_`P\\U>(2AY3&"
+	"KKKMZ_@I````````````M,#R:'6H7FN>7FN>8F^BHZ_B]0$Q`P\\_````````````"
+	"`````````````````````@T^Y_0EFJ?976J>8&V@6VB;F:77W^P<`P\\_``\\`````"
+	"````````^`@XOLK\\>8:Y6F>:86ZA97*EOLK\\^04U`P\\_`P\\_`````````P\\_````"
+	"`````````````````````````````````````````````````P\\````_```_````"
+	"`@X^Q?(F+*[H!)G7!)G7!)S9!)O9!)K8!)C66L+\\Z@,T`P\\_`P\\_`PX^`P\\^`P`_"
+	"`P```P`_`P`^`P\\_`P\\_`@\\_`P\\_```^```_````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P\\_`P\\_````YO,CCYS.8W\"B6VB;86ZA@X_!Y?,B`PX^````````"
+	"`````````````P\\_````^P<WHJ[@9W2G7&F<7FN>>(6YS]P-`````````P\\_````"
+	"`````P\\_````````````````````````````````_PL[W.D:@(R_7&F<7FN>9'\"D"
+	"HJ[AZ/4F````_0DYR=4&=H.V6F>;76J=8V^BJKCI[_PL`````P\\_`P\\_````````"
+	"`````````````````P\\_`P\\_````QM0$?HN]6F>97VR?76J=IK/E]/`P````\\?XN"
+	"EZ/68&V@8&V@8&Z@7VR?HJ_A[OLK`P\\_`````P\\_```````````````_`````@X^"
+	"`P\\_`````@X_U^05F*77DZ#2W.H:`````P\\_```````_J[CJ86^B7FR?7FN>9W.F"
+	"J[;I^P<W`P\\_`P\\````_`````````P\\_`````````````0T]W^P=DI[16VB;8&V@"
+	"76J=H*S>Y?(B`P\\_`````P\\_`@X^````^P<WLK[Q<W^R6F>:8&V@9W.FQ-$!_0DY"
+	"`P\\_`````P\\_`P\\_````````````````````````````````````````````````"
+	"`````````````@X^`P\\_````[04VD-L0\"IS:!)?5!)O9!)O:!)O9!)C6%*+??=(*"
+	"^PH\\`````````````P`````_```_```````````````````````_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"```````````````````````````````````````````````_X.T=A9'$8FZA6VB;"
+	"8W\"CC)C*Z_@H`P\\_`````````````````````````@X^]P(RF:;99'&D76J=76N>"
+	"?XN^U.$2`````````````@X^`@X^````````````````````````````````````"
+	"^`@XT-T.>H>Z7&F<7FN>9G*FKKKM[OLK````_`P\\W>L<@H_\"7&F<76J=7FN>@8V`"
+	"U>,3`````````P\\_`@X^`P\\_`````````P\\_`@X^`P\\_`````@X^M<+U<X\"S6VB;"
+	"7FN>7FN>L+SN_@DY``\\__PL\\J[?J:7:I7FN>8FZA6F>;B)7(TMX0`P\\_`````P\\_"
+	"`````````P\\``@X``@X^````````_`P\\WNL<GJK=?(F[U.(2_0DY`````P\\_````"
+	"_0DZI+#C76J=8&V@76N>;'BKL[_Q_`P\\`````````P\\``@X^`P\\_````````````"
+	"````_`P\\U>(3BY?*6F>:8&V@7FN?I[/DZ_@H`P\\_`````P\\_`P\\_````^04UI;+D"
+	";'JL6F>:8&V@:'6HS-D*`@X^`````P\\_`P\\_`P\\_````````````````````````"
+	"`````````````````````````````````````P\\_`P\\_````T?DK6,#Z!9C6!)C6"
+	"!)S:!)K9!)G7!9332KKTO.`D`````P\\_`P\\_```````````_```_````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````P\\_W.D:?XN^86V@6F>:9G.FEJ/5]/`Q`````P\\_````````````````````"
+	"`@X^[?HJDY_086V@7&F<7&J=A9'$V>87`````P\\_`P\\_`P\\_`P\\_````````````"
+	"````````````````````````^04VP\\`!<X\"S6F>:7VR?:'6HO<G[]@(Q`````P\\^"
+	"]0$REJ/58F^A76J=8&V@86ZBI[3F[/HJ`P\\_`P\\_`P\\_`````P\\_`P\\_`P\\_`P\\_"
+	"`````0T]X>T>CYO-86Z@7VR?7VR?8W\"BO,CZ`````````@X^R-4&?XR^66:986ZA"
+	"7&F<:WBLJK;J`0T]`````P\\_`````````P\\``P\\``P\\_`````0T]W.L:CYS.?(F\\"
+	"O<G\\^P<W`````P\\_`````P\\_\\O\\NG*C:76J=8&V@76J=<G^ROLK]`````@X^`P\\_"
+	"`P\\_`P\\_`P\\_`````P\\_`P\\_````_PL[RM<(A)#\"6VB;8&V@8&V?L+WN\\_`P````"
+	"`P\\_`P\\_`P\\_````]0(RFJ?::'6H6VB;8&V@:W>JU^04`````0T\\`@X^`P\\_`P\\_"
+	"`````````````````````````````````````````````````````````P\\_````"
+	"`P\\_````J^@<(JCE!)C7!)K7!)S:!)S:!)O9!IK8<<T$WO\\P`````P\\_`P\\_````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`P\\_`````P\\_V>46=H.V8&R?66:9:WBKIK/E^`@Y````"
+	"`P\\_`````````````````````0T]Y?(CBI?*7FN>7&F<7&F<E*#2V^@8\\?XNV><7"
+	"_@HZ`````````````````````````````````P\\_`P\\_````]@(SML/U;GJM6F>:"
+	"8&R@;WNNR=8'VN<8S]P,VN<7_@HZN<7W<X\"S6&688F^B76F=<G^QK;KL]@$Q````"
+	"`P\\_`````@X^`P\\_`P\\_`````P\\_W.D;CIO-9W.F7VN>86ZA7VN>;7JMOLO]Z_DI"
+	"T=\\.^P<WZO<GGZO=6F>:8&V@8&V@7&F<?XR_U>,2_`P\\`P\\_`````P\\_`P\\_`P\\_"
+	"````_@HZT=X/@H_!>8:XL;[O]`0T`P\\_`P\\_`@X^`````0T]Y_0EE*'36VB<86ZA"
+	"76J=?(F\\NL;YWNL<O\\O\\[/DH```_`````````````P\\_`@X^````_@HZP,S^?(B["
+	"6F>:8F^B8W\"CL+WNT-T-P<W_X^`@_0DY`````P\\_[OPLD)W/97*E76J=86ZA<'VP"
+	"M\\/VO\\O^NL;X\\O\\P`@X^````````````````````````````````````````````"
+	"`````````````````P\\_`````P\\`W_\\Q<<T$\")K7!)K8!)O9!)K8!9S:%Z3A1+GS"
+	"KND=]`HZ`````P`_`@`^``\\`````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````P\\_`````````@X^`P\\_`````0T]R]@):G:I"
+	"7VN>6668;7JMKKKL`0T]`P\\_`@X^`````````````P\\_````_`P\\W>H;A)'#6VB;"
+	"7FN>7FN>@X_!HJ[@KKKLN\\GZ^@8V`````````````````````````````````P\\_"
+	"`@X^````\\O`PJ;;H:7:I6F>:8F^B:G:IDZ#2DY_2GZO>T-T-`0T]XN\\@DZ'366::"
+	"8&VA8&V@7&F;=H.UL+[OX>X>_0DY````````````````\\_`PRM<(DY_3=(&T97&D"
+	"86V@8FZA8&V@:G>JC)K-H[#BJK;I\\?\\O`P\\_Q-(\";WRO6VB;8&V@7&F<97*DDI_1"
+	"V.46^`@X````````````_0DZZ/4FOLK\\@X_#<'VPJ[CI[OLK`````P\\_`P\\_````"
+	"`P\\__`P\\WNL<CIK-6F>:86ZA7VR?;GNNAY3'FZC9J+3EZ?8F```````_````````"
+	"````````````_0DYM,#R=(\"S6V>;8F^B8G\"C@H_\"C)G*DI[0V.46^`@X`````@X^"
+	"Y_0DAI/%86Z@7FN>86ZA97*D?(B\\BYC+KKKM]0$R`P\\_````````````````````"
+	"`````````````````````````````````````````P\\_`P\\_`@\\_H^09-K#L!973"
+	"!)O9!)O9!)K8!)O9(:CE?M,)WO\\P``\\_`@`_`P`_`P`_````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````````````P\\_````"
+	"`P\\_`P\\_````[?HKJ[?I8&R?7FN>6VB;:G>JGZS?]`,T`````P\\_`````P\\_`P\\_"
+	"````````_PL[U.$2?HJ]6F>:7VR?7&J=9G.F=(\"SE:'4S-D*_0DY````````````"
+	"`````````````````````P\\_`P\\_````[_TMG*G=9W2G6VB;8&V@76J=8&V@>(2W"
+	"K;GLZ?8F`@X^`@X^P,W^<X\"S6VB;7VR?7FN>7&F<:G>JF*78R-8&Y/$B[/HJZ?<G"
+	"V>86K[ON@Y##=H.WG:K=?(B[86ZA8&ZA7FN>76J=9W2GAY3&O,C\\]P,S````Z/8F"
+	"H*W?8&V?6VB;7VR?76N>8F^BD9W/P]$!X>\\?Y_0EW^T>R-8&FZC:;WNO9W2HK;CK"
+	"\\/TM`````P\\_`P\\_`P\\_````````_PL\\UN,4AY3'6F>:86ZA7FN>7&F=:G>ID9[/"
+	"S]P,^04U````````````````````````````^`<WJ;;H;7JM7&B<7VR?7&J=7VV@"
+	"=X2WJK?HZO<H`0T]````_`P\\X.T=?(F\\76N>7FR?76J=7VR?<7ZPH:[@WNH;`0T]"
+	"`````P\\_`````````````````````````````````````````````P\\_````````"
+	"`````P\\__@T]=M$'$J'>!)?6!)O9!)S9!)O9!)C6#)O9;LL\"V_TP`P\\``P\\^`P\\_"
+	"``````\\`````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````P\\_`P\\_`0T]_@L[^P<XP,S`>8:Y7&F<8&V@7VR?7VR?>H:Z"
+	"R]@)]P,S_PL[`0T]`P\\_`P\\_````````_@HZRM<(>8:Y6&687&F<6FB;<7^RKKOM"
+	"Y_0E`P\\_`P\\_`P\\_`P\\_````````````````````````````````````[/DID)S."
+	"9'&D66:97&F<9'&DD)S/T-T/^P<W````````````[?HJK;KL8W\"B6F>:7VR?8&V@"
+	"76N>6VF<;GJMAI+%DZ#2C)G+<GZQ7VR??XR`QM0%V>86B)7'6F>;76J=6VB;9W2G"
+	"G:C;W.D:`P\\_`````````0T]WNL:A9+#7VR?6F>:8&R?7FN>76J=:WBK?8J]A9/%"
+	">XBZ9'*E6668<G^RN,7W]`0U`````P\\_`P\\_`P\\_````````````_@HZS=H*@8Z`"
+	"66:97VR?6FB:=(&SKKOLZ_@H`P\\_`````P\\_`P\\_`P\\_`````````P\\_````^04U"
+	"GJO<9W2G6F>:6VF<8W&DD9W/SML,_0HZ`P\\_````````_PL[U^04=(&T66>:6FB;"
+	"86V@@Y##R=<(]P0T`````P\\_`P\\_`P\\_````````````````````````````````"
+	"`````````````````P\\_`P\\_`P\\_`@X^ZP0U5+_X!)?6!)G8!)O9!)S:!)C7!)/1"
+	"#9W:HN08\\`DY`P```@\\_`P\\_``\\`````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````P\\_`P``^04UV>87LK_PF*37<G^R"
+	"5F.65V276&685V2856*666::<7ZRD9W1M\\+UW^L<`0T]`````P\\_````_0DYO<G["
+	"<'VP4%V07VV@B9?*R=<'\\?XO`@X]`````P\\_`P\\_`P\\_````````````````````"
+	"````````````````YO,D?XN^6&6756*6=(\"SK[OMYO,D_@HZ`````P\\_`P\\_`P\\_"
+	"`@X_Z/4EI[/E;'FL5V275V276FB;6F>:66:966685F*65&&58V^BE*#3TM`0^@8V"
+	"WNL<@H_!4%Z166:9=X2WML+UY_0E_`P\\`P\\_`P\\_`P\\_````_@DYUN,4C)G,7VR?"
+	"56*56&685F.656.65&*54V\"445Z16F>:B)3(R-4']P,S`````P\\_`P\\_`P\\_`P\\_"
+	"````````````_0DYP<W_=H.V3UR07FN?B);(RM<(]@(R`PX_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`````````````P\\_\\_`PCIO-66:95F.6<'VOKKKLXN\\@_0HZ`````````P\\_"
+	"````^P<WQ]0%:'6H3EN.9W2HFJ78W.D:^P<W`````P\\_`P\\_`P\\_`P\\_````````"
+	"`````````````````````````````````````````@X^`@X^`P\\__PT^KNH=,J[I"
+	"!)72!)K8!)O8!)G7$J#=-K'L<LX%X/`R`P\\_`P\\_`@`^`P\\_``\\`````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_\\`$QQ-(\"BI7)>8:Y<X\"S<GZQ=H.V=H.V=H*V=8*U<W^S<7ZQ=8&TF*36T-X."
+	"_`P\\````````````_0DYM\\/U;'BK:'6HH:[@VN@8^`@Y`````````P\\_`@X^````"
+	"`````P\\_````````````````````````````````Z/0EB)7':WBKC9G,Q,`\"[_LL"
+	"`P\\_`````````@X^`@X^`@X^`````0T]Z?8FO,CZCYS.<'VP8F^B7FR?76F=8&V@"
+	";7JMB97(ML+TX>X>`0T]`0T]V>87?XN^8&VAC)G+R-4&\\O\\O`P\\_`````P\\_`@X^"
+	"`@X^````````_PHZV.86JK;HA9+$<GZR:G:I9G.F9W6H<'VQA9+%K+GKV.46^P<X"
+	"`P\\``P\\_`@X^````````````````````````^`DYOLO]>H>Y:G>KG*G=UN04^`@X"
+	"`````````P\\_`P\\_`````````````P\\_`````````@X^[_PLB97'9G.FB9;)PL[_"
+	"[?HJ`@X^`````````````P\\_````^@8WRM<(=H*U>86XKKOMY?(B`0T]````````"
+	"`P\\_`P\\_`````````P\\_`````````````````````````````````````````P\\_"
+	"````````````Z`4V8\\;_$Z#<!)?4!)O9!)O8!)31**GE@]<,XO`Q`@`_```_`@\\]"
+	"``X^``\\_``````\\`````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````P\\_````^08VV><7LK[PL;[PN<7WO<GZO,CZO,CZO,CZ"
+	"O,C[O,C[N<7XL+SNP,W^X^`@`0T]`````P\\_````_@L[S=L+F:;8JK?IZ?8F````"
+	"`````````@X^`P\\_`````P\\_`````````````````````````P\\_````````````"
+	"\\O`PN\\?YK[SNU^05`@X^`````````@X^`P\\_`````````````@X^`P\\_````_@HZ"
+	"VN<8M,'RFZC9D9[1E*'3H:[ANL?YW.D9_`P\\`````````0T]X^`AI[/FHJ[@U.(3"
+	"`P\\_`````````@X^`P\\_`````````@X^`P\\_````````\\O\\OT-T.ML+UJK;IJ+3F"
+	"K[SMOLO\\U>,3^04T`````````P\\^`P\\_`````P\\_````````````````````_PL["
+	"UN,4K+GJL;[OY/(A`````````P\\_`P\\_`````````P\\_````````````````````"
+	"`@X^]@$QL;WOJ+3FT]`1`0T]`````````@X^`P\\_`P\\_````````_PL[X^`AL[_Q"
+	"Q=(#\\O\\O`````````````@X^`P\\_`````P\\_````````````````````````````"
+	"`````````````````````````P\\_````]PDZM>P@)JKF!)G7!)K9!)O:!)O8!)+0"
+	"0K/OL.L?_PT^`````@\\^`@\\^``X^``\\_````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````````````````````````P\\_`P\\_`0T]_@HZ"
+	"_@H[_PL[_PL[_PL[_PL[_PL[_PL[_PL[_PL[_@HZ_PL[`@X^`P\\_`P\\_````````"
+	"`@X^^@8V\\/TM]`0T`P\\_`P\\_`P\\_`````P\\_`P\\_````````````````````````"
+	"`````````````P\\_`P\\_`````@X^_@HZ_@HZ`0T]`````P\\_`P\\_`P\\_`P\\_````"
+	"`````````P\\_`P\\_`P\\_`P\\_`0T]_@HZ]P,R[?HJ[OPL^@8W_PL[`0T]`P\\_````"
+	"`````P\\__@HZ\\_`P^04T`0T]`````````P\\_`P\\_`P\\_`````````P\\_`P\\_`P\\_"
+	"`````P\\_`0T\\_PL[_0DY_0DY_@HZ_PL\\`0T]`P\\_`P\\_`P\\_`P\\_`P\\_````````"
+	"`````````````P\\_`````P\\__PLZ^`@X_0DY`@X^`P```P\\_`````P\\_`P\\_````"
+	"`````````````````````````@X^`0T]^@8V_0DY`0T]`````P\\_`P\\_`P\\_`P\\_"
+	"`````P\\_`P\\_`P\\_`0T]_@HZ_`P\\`P\\_`P\\_`P\\_`````P\\_`P\\_````````````"
+	"````````````````````````````````````````````````````]0DZP?(E:LD\""
+	"$IS:!)?6!)S:!)O9!)O9'J;C>=$(VOTO`0X_`P\\^`@\\_`@\\_``\\_``\\_``\\_````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````P\\_````````````````````````````````````````````````````"
+	"`````````P\\_`P\\_`````P\\_`P\\_`@X^`@X^`P\\_`````P\\_`P\\_````````````"
+	"`````````````````````````````````````P\\_`P\\_`P\\_````````````````"
+	"`P\\_`P\\_`P\\_`````````````````````````P\\_`P\\_`````P\\_`````P\\_`@X^"
+	"`@X^`P\\_`P\\_`P\\_`P\\_`````P\\_`P\\_`P\\_`@X^`P\\_`P\\_`P\\_`````P\\_````"
+	"`````````````````P\\_`P\\_`````````P\\_`P\\_`````````````P\\_`P\\_````"
+	"`P\\_`@X^`P\\_`````````````````````````````@X^`PX^``\\_`````````P\\_"
+	"`P\\_`@X^`````````````````````````````````P\\_`P\\_`P\\_`P\\_`P\\_````"
+	"`P\\_`````P\\_`P\\_`````````````P\\_`P\\_`P\\_`P\\_`````````P\\_`P\\_`P\\_"
+	"````````````````````````````````````````````````````````````````"
+	"````````````W?XPB-@.,Z_K\"9G8!)G7!)O9!)G7\")W:;<P#S/<I_0P]`P\\_```^"
+	"`@X_`@\\```````\\_``X^````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````````````````````P\\_`````P\\_````````````````````````"
+	"`````````````````````````````P\\_`````````P\\_`@X^````````````````"
+	"`P\\_`````````P\\_`````````````````````````````````````````P\\_````"
+	"`````@X^`P\\_`````````````@X^`P\\_`````P\\_`````````````````P\\_````"
+	"`````P\\_`@X^`````````````````````````P\\_`@X^`````@X^`P\\_````````"
+	"`````P\\_`P\\_`````````P\\_`````````````````````````````````@X^`P\\_"
+	"`````````````@X^`P\\_````````````````````````````````````````````"
+	"`@X^`P\\_`````````````@X^`P\\_`````P\\_````````````````````````````"
+	"`P\\_`@X^`````````````````P\\_`````````````P\\_`````````````````@X^"
+	"`P\\_`````````P\\_`````````P\\_````````````````````````````````````"
+	"````````````````````````````````````Q_0G7L3]%:/@!)G8!)K8!)O9!)C6"
+	"\"IW:E=T2\\P@X`````P\\_`P\\``P\\``P\\_`@```P\\_``\\_````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`P\\_`P\\_`````````````````P\\_`P\\_````````````````````````````````"
+	"`````````````````````````````P\\_`P\\_`````````````P\\_`P\\_````````"
+	"`````````````````````````````P\\_`P\\_`````````````````````````P\\_"
+	"`P\\_`````P\\_`P\\_`````````````P\\_`P\\_````````````````````````````"
+	"`````````````````P\\_`P\\_`````````````P\\_`P\\_````````````````````"
+	"`````````````````````````P\\_`P\\_`````````````P\\_`P\\_````````````"
+	"`````````````````````````P\\_`P\\_`````````````````P\\_````````````"
+	"`````````````````````P\\_`P\\_`````````P\\_````````````````````````"
+	"````````````````````````````````````````````````````````````M>P@"
+	"0;;Q\"9W;!)K8!)K8!)K8!)C7%:'>G=`4\\P@X```````_```^`P\\``P`````_````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"`````````````P\\_````F^$6(*?D!)K8!)K9!)K9!)C7\")K9.K+NSO@J`P\\_```_"
+	"```^```_````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````Z@0U=L`&!YG7!)C7!)K8!)S9"
+	"!)G8!9G8+:WIQ/,G`P\\_```_```^```_````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"H>,82[GS!)/2!)C7!)K8!)S8!)C7\"IK9/;7PR_8I`P\\_```_```^```_````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````3;SV(Z?C!)74!)K9!)O8!)S9!)?5$I[;8L;_X@$R"
+	"`````P\\^`P\\^```_````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````%:3A\"IW;!)G7!)O9"
+	"!)O9!)O9!);4%)S;<,T$Y@(T`````P\\^`P\\_`````P\\_````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````\"IW<!9K9!)G7!)K7!);4!)/2!([-!I/22KKUVOTO```````_`P\\_`P\\_"
+	"`P\\^`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_````````/[7Q':;B!)G6#J#<):GE0K7P3+CS5[WX"
+	"C]H1Z@0U`````@X``@X_`P\\_`````P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_````````E]\\4<<T$"
+	"4[[W8,7^?=,*H>08L.L?M^XBW/XP^`P]`````PX_`P\\_`P\\_```_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_`P\\_"
+	"`P\\_`P\\_````````_@T]^`P]^PP\\^`P\\_0T]_PT^_`X^_`X^`@\\_`P\\_``````\\`"
+	"``\\``````P\\`````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````````````````````````````````````"
+	"````````````````````````````````";
+
+#endif // APOLLO_LOGO_H
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/board.h linux-2.6.34/arch/arm/mach-apollo/include/mach/board.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/board.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/board.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_BOARD_H
+#define __ARCH_MACH_BOARD_H
+
+#include <mach/pnx8492.h>
+
+/*
+ * Board tile identification (APOLLO_SYS_PROCID)
+ */
+#define APOLLO_PROC_MASK		0xFF000000
+#define APOLLO_PROC_UNUSED		0x00000000
+#define APOLLO_PROC_A9UP		0x02000000
+#define APOLLO_PROC_A9MP1		0x04000000
+#define APOLLO_PROC_A9MP2		0x06000000
+#define APOLLO_PROC_A9MP4		0x0C000000
+
+
+#define check_apollo_proc(proc_type)								\
+	((readl(__io_address(APOLLO_SYS_PROCID)) & APOLLO_PROC_MASK)	\
+	 == proc_type)
+
+#ifdef CONFIG_MACH_APOLLO_1SI_A9UP
+#define core_tile_a9up()	1
+#else
+#define core_tile_a9up()	0
+#endif
+
+#ifdef CONFIG_MACH_APOLLO_1SI_A9MP1
+#define core_tile_a9mp1()	1
+#else
+#define core_tile_a9mp1()	0
+#endif
+
+#ifdef CONFIG_APOLLO_MP2
+#define core_tile_a9mp2()	check_apollo_proc(APOLLO_PROC_A9MP2)
+#else
+#define core_tile_a9mp2()	0
+#endif
+
+#ifdef CONFIG_APOLLO_MP4
+#define core_tile_a9mp4()	check_apollo_proc(APOLLO_PROC_A9MP4)
+#else
+#define core_tile_a9mp4()	0
+#endif
+
+#define machine_is_apollo_up() (machine_is_apollo() && core_tile_a9up())
+#define machine_is_apollo_mp() (machine_is_apollo() && \
+								(core_tile_a9mp1() || core_tile_a9mp2() || core_tile_a9mp4()))
+
+#endif	/* __ARCH_MACH_BOARD_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/cm.h linux-2.6.34/arch/arm/mach-apollo/include/mach/cm.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/cm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/cm.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/* Copyright (c) 2007 NXP B.V.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   Clock module specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8XXX_CM_H
+#define __PNX8XXX_CM_H
+
+#ifdef CONFIG_SOC_PNX85500
+#include <glb.h>
+#else
+#include <mach/pnx8492.h>
+#endif
+
+/* PNX8XXX clock registers */
+
+#define PNX8XXX_DFT_FREQ_CTL    (PNX8XXX_CLOCK_BASE+0xC00)
+#define PNX8XXX_DFT_DONE_MASK   0x00000002
+#define PNX8XXX_DFT_RESULT_MASK 0xFFFF0000
+#define PNX8XXX_DFT_TIMEOUT     1000
+
+/* Allocated PLL sources: provided by hardware */
+#define ARM_PLL_NR_M0		81	/* !! value to be checked !! */
+#define MIPS_PLL_NR_M0		81
+#define TM_PLL_NR_M0		92
+#define MEM_PLL_NR_M0		78
+
+/* Allocated PLL sources: provided by hardware */
+#define ARM_PLL_NR_M1		103	/* !! value to be checked !! */
+#define MIPS_PLL_NR_M1		103
+#define TM_PLL_NR_M1		105
+#define MEM_PLL_NR_M1		100
+
+/* Defaults when clock source is illegal */
+#define ARM_CLOCK_DEFAULT	525000000	/* !! value to be checked !! */
+#define MIPS_CLOCK_DEFAULT	525000000
+
+#define PNX8XXX_CLK_USB_30_CTL_0  (PNX8XXX_CLOCK_BASE+0x264)
+#define PNX8XXX_CLK_USB_30_CTL_1  (PNX8XXX_CLOCK_BASE+0x444)
+#define PNX8XXX_CLK_USB_30_CTL_2  (PNX8XXX_CLOCK_BASE+0x270)
+
+#define PNX8XXX_CLK_USB_AHB_CTL_0  (PNX8XXX_CLOCK_BASE+0x26C)
+#define PNX8XXX_CLK_USB_AHB_CTL_1  (PNX8XXX_CLOCK_BASE+0x510)
+#define PNX8XXX_CLK_USB_AHB_CTL_2  (PNX8XXX_CLOCK_BASE+0x274)
+
+#define SET_CLOCK(clockreg,state)	{		\
+	uint32_t i;					\
+	i = __raw_readl(clockreg) & ~1;			\
+	__raw_writel(i | state, clockreg);		\
+}
+
+#define SET_CLOCKSRC(clockreg,src)	{		\
+	uint32_t i;					\
+	i = __raw_readl(clockreg) & ~6;			\
+	__raw_writel(i | (src << 1), clockreg);		\
+}
+
+#define USB_AHB_SRC_XTAL	0x00
+#define USB_AHB_SRC_PLL		0x01
+
+#define ENABLE_CLOCK(clockreg)	SET_CLOCK(clockreg,1)
+#define DISABLE_CLOCK(clockreg)	SET_CLOCK(clockreg,0)
+
+#endif /* __PNX8XXX_CM_H */
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/core.h linux-2.6.34/arch/arm/mach-apollo/include/mach/core.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/core.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/core.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_CORE_H
+#define __ARCH_MACH_CORE_H
+
+#include <asm/system.h>
+
+struct machine_desc;
+struct tag;
+struct meminfo;
+
+extern void __init	apollo_map_io(void);
+extern void __init	apollo_init_irq(void);
+extern struct sys_timer	apollo_timer;
+#ifdef CONFIG_LOCAL_TIMERS
+extern void __iomem	*twd_base;
+#endif
+extern void __init	apollo_init(void);
+
+extern void __init      apollo_fixup(struct machine_desc *pmach,
+				struct tag *ptag,
+				char **pptr,
+				struct meminfo *pmem);
+
+extern void __iomem *gic_cpu_base_addr;
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/dma.h linux-2.6.34/arch/arm/mach-apollo/include/mach/dma.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/dma.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/dma.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ARCH_MACH_DMA_H
+#define __ARCH_MACH_DMA_H
+
+#define MAX_DMA_ADDRESS		0Xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/entry-macro.S linux-2.6.34/arch/arm/mach-apollo/include/mach/entry-macro.S
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/entry-macro.S	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/entry-macro.S	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =gic_cpu_base_addr
+		ldr	\base, [\base]
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.  To wit:
+		 *
+		 * Interrupts 0-15 are IPI
+		 * 16-28 are reserved
+		 * 29-31 are local.  We allow 30 to be used for the watchdog.
+		 * 32-1020 are global
+		 * 1021-1022 are reserved
+		 * 1023 is "spurious" (no interrupt)
+		 *
+		 * For now, we ignore all IPI and Local Interrupts so only return an interrupt if its
+		 * 27,28 or between 30 and 1020.  The test_for_ipi routine below will pick up on IPIs.
+		 * The test_for_ltirq below will pick up the Local Timer interrupts.
+		 *
+		 * A simple read from the controller will tell us the number of the highest
+                 * priority enabled interrupt.  We then just need to check whether it is in the
+		 * valid range for an IRQ.
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \irqstat, [\base, #GIC_CPU_INTACK] /* bits 12-10 = src CPU, 9-0 = int # */
+
+		ldr	\tmp, =1021
+
+		bic     \irqnr, \irqstat, #0x1c00
+		
+        	cmp     \irqnr, #29     /* Check for Local Timer Interrupt */
+        	cmpne   \irqnr, #16	/* Check for IPI Interrupts */
+		cmpcc	\irqnr, \irqnr
+		cmpne	\irqnr, \tmp
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		cmp	\irqnr, #16
+		strcc	\irqstat, [\base, #GIC_CPU_EOI]
+		cmpcs	\irqnr, \irqnr
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		mov 	\tmp, #0
+		cmp	\irqnr, #29
+		moveq	\tmp, #1
+		streq	\irqstat, [\base, #GIC_CPU_EOI]
+		cmp	\tmp, #0
+		.endm
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gcs_dmac.h linux-2.6.34/arch/arm/mach-apollo/include/mach/gcs_dmac.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gcs_dmac.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/gcs_dmac.h	2010-09-07 22:59:55.000000000 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for DMAC IP_1902.
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 0.0.1      Sundar A        09-09-2009   Created for APOLLO
+ */
+/** 
+ * FIXME: This must be removed soon after integrating with DMA_ENGINE
+ **/
+#ifndef __GCS_DMAC_H__
+#define __GCS_DMAC_H__
+
+#include <asm/sizes.h>
+#include <mach/pnx8492.h>
+
+#define   	APOLLO_GCS_DMAC_BASE	(ARM_A9_HOST_MMIO_BASE + 0x34000)
+#define		APOLLO_GCS_DMAC_LEN	SZ_4K
+
+#endif /* __MACH_DMAC_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gcs.h linux-2.6.34/arch/arm/mach-apollo/include/mach/gcs.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gcs.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/gcs.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for EFMC IP_2070.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 1.0.0		Sundarapandian A		20090720		Updated for APOLLO
+ */
+#ifndef _GCS_H_
+#define _GCS_H_
+
+/* #include <mach/platform.h> */
+#include <mach/irqs.h>
+
+#define APOLLO_GCS_CFG_BASE_PHYS         (ARM_A9_HOST_MMIO_BASE + 0x36000)
+#define APOLLO_GCS_CFG_BASE              (APOLLO_GCS_CFG_BASE_PHYS)  
+#define APOLLO_GCS_CFG_LEN               (0x1000)
+
+/* GCS Mode Register */
+#define APOLLO_GCS_MODE_REG              (APOLLO_GCS_CFG_BASE + 0x0)
+#define APOLLO_GCS_MODE_PCI_ISA_MODE                        (1UL<<0)
+#define APOLLO_GCS_MODE_SDIO_MUX                            (1UL<<1)
+#define APOLLO_GCS_MODE_SDIO_FORCE                          (1UL<<2)
+
+/* GCS SDIO Chip Select Route */
+#define APOLLO_GCS_SDIO_CS_ROUTE        (APOLLO_GCS_CFG_BASE + 0x60)
+
+/* GCS Clock Mux Register */
+#define APOLLO_GCS_CLOCK_MUX            (APOLLO_GCS_CFG_BASE + 0x64)
+#define APOLLO_GCS_CLOCK_MUX_EN                             (1UL<<0)
+
+/* GCS SDIO Clock Mux Register */
+#define APOLLO_GCS_SDIO_CLOCK_MUX       (APOLLO_GCS_CFG_BASE + 0x68)
+#define APOLLO_GCS_SDIO_CLOCK_MUX_EN                        (1UL<<0)
+
+#define APOLLO_GCS_SDIO_HPROT           (APOLLO_GCS_CFG_BASE + 0x6c)
+
+#endif /* _GCS_H_ */
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/globaltimer.h linux-2.6.34/arch/arm/mach-apollo/include/mach/globaltimer.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/globaltimer.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/globaltimer.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author:	Frank Dols <frank.dols@nxp.com>
+ *		Mischa Jonker <mischa.jonker@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_GLOBALTIMER_H
+#define __ASM_ARCH_GLOBALTIMER_H
+
+#define GLOBAL_TIMER_COUNT_LOW		0x00
+#define GLOBAL_TIMER_COUNT_HIGH		0x04
+#define GLOBAL_TIMER_CONTROL		0x08
+#define GLOBAL_TIMER_STATUS		0x0C
+#define GLOBAL_TIMER_COMPARATOR_LOW	0x10
+#define GLOBAL_TIMER_COMPARATOR_HIGH	0x14
+#define GLOBAL_TIMER_AUTO_INCREMENT	0x18
+
+#define GLOBAL_TIMER_CTRL_AUTO_INC	0x08
+#define GLOBAL_TIMER_CTRL_IRQ_ENA	0x04
+#define GLOBAL_TIMER_CTRL_COMP_ENA	0x02
+#define GLOBAL_TIMER_CTRL_TIMER_ENA	0x01
+
+#define GLOBAL_TIMER_STAT_EVENT		0x01
+
+struct apollo_pm_timer_save {
+    u32     low;
+    u32     high;
+    u32     control;
+    u32     status; /*no need to restore....*/
+    u32     cmp_low;
+    u32     cmp_high;
+    u32     auto_inc;
+};
+extern void apollo_pm_timer_save(void);
+extern void apollo_pm_timer_restore(void);
+extern void apollo_core_intc_init(unsigned long vaddr);
+
+extern void apollo_global_timer_init(unsigned long vaddr,
+					unsigned long irq,
+					unsigned long freq);
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gmac_eth_drv.h linux-2.6.34/arch/arm/mach-apollo/include/mach/gmac_eth_drv.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gmac_eth_drv.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/gmac_eth_drv.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: ??
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_GMAC_ETH_DRV_H__
+#define __ARCH_MACH_GMAC_ETH_DRV_H__
+
+
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+
+/* Information, which can vary between two ethernet IPs */
+typedef struct gmac_platform_data
+{
+	__u32 isExternal;
+	__u32 clk_csr_val;
+	__u32 max_speed;
+	__u8 mac_addr[6];
+
+}gmac_platform_data_t,*pgmac_platform_data_t;
+
+/* Internal/External PHY */
+#define GMAC0_BASE	(ARM_A9_HOST_MMIO_BASE + 0x7c000U)
+#define IRQ_GMAC0		IRQ_ETHR_MAC_0
+#define IRQ_GMAC0_POWER		IRQ_ETHR_PWR_0
+#define GMAC0_CLK_CSR_VAL (0x1U)
+#define GMAC0_CTRL_GLOBAL_REG (ARM_A9_HOST_MMIO_BASE + 0xea300U)
+
+#ifdef CONFIG_GMAC0_MODE_RGMII
+#define GMAC0_MAX_SPEED (1000U)
+#else
+#define GMAC0_MAX_SPEED (100U)
+#endif
+
+/* External PHY  */
+#define GMAC1_BASE	(ARM_A9_HOST_MMIO_BASE + 0xb8000U)
+#define IRQ_GMAC1		IRQ_ETHR_MAC_1
+#define IRQ_GMAC1_POWER		IRQ_ETHR_PWR_1
+#define GMAC1_CLK_CSR_VAL (0x1U)
+#define GMAC1_CTRL_GLOBAL_REG (ARM_A9_HOST_MMIO_BASE + 0xea304U)
+
+#ifdef CONFIG_GMAC1_MODE_RGMII
+#define GMAC1_MAX_SPEED (1000U)
+#else
+#define GMAC1_MAX_SPEED (100U)
+#endif
+
+#endif /* __ARCH_MACH_GMAC_ETH_DRV_H__ */
+
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gpio.h linux-2.6.34/arch/arm/mach-apollo/include/mach/gpio.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/gpio.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/gpio.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: ??
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_APOLLO_GPIO_H
+#define __ARCH_MACH_APOLLO_GPIO_H
+
+
+#include <mach/pnx8492.h>
+/* #include <mach/irqs.h> TODO: irqs.h file includes gpio.h file */
+#include <asm-generic/gpio.h>
+
+#if 1
+/**
+ * FIXME: 
+ * Interrupt numbers in irqs.h is still invaild and
+ * so we go on with our own declaration.
+ **/
+#define IRQ_GPIO_L 32 /* Left GPIO */
+#define IRQ_GPIO_R 102 /* Right GPIO */
+#endif
+
+/**
+ * GPIO-0: Left GPIO configuration
+ **/
+#define GPIO0_IRQ       IRQ_GPIO_L
+#define GPIO0_MAX_NR    74
+#if 0 /*TODO::AVALON*/
+#define GPIO0_BASE      (ARM_A9_HOST_MMIO_BASE + 0x069000)
+#else
+#define GPIO0_BASE      (ARM_A9_HOST_MMIO_BASE + 0x0D5000)
+#endif
+#define GPIO0_IRQ_BASE  IRQ_MAX_NBR
+#define GPIO0_START_PIN 0
+
+/**
+ * GPIO-1: Right GPIO configuration
+ **/
+#define GPIO1_IRQ IRQ_GPIO_R
+#define GPIO1_MAX_NR    58
+#if 0 /*TODO::AVALON*/
+#define GPIO1_BASE      (ARM_A9_HOST_MMIO_BASE + 0x0D5000)
+#else
+#define GPIO1_BASE      (ARM_A9_HOST_MMIO_BASE + 0x069000)
+#endif
+#define GPIO1_IRQ_BASE  (GPIO0_IRQ_BASE + GPIO0_MAX_NR)
+#define GPIO1_START_PIN GPIO0_MAX_NR
+
+/**
+ * Platform data structure
+ **/
+struct apollo_gpio_platform_data {
+	int first_pin;
+	int nr_gpio;
+	int irq_base;
+};
+
+#define gpio_to_irq(gpio) __gpio_to_irq(gpio)
+
+/**
+ * GPIO <--> PIO mapping in Apollo SoC
+ **/
+#define PIO008      (GPIO0_START_PIN + 0)
+#define PIO009      (GPIO0_START_PIN + 1)
+#define PIO010      (GPIO0_START_PIN + 2)
+#define PIO011      (GPIO0_START_PIN + 3)
+#define PIO012      (GPIO0_START_PIN + 4)
+#define PIO013      (GPIO0_START_PIN + 5)
+#define PIO014      (GPIO0_START_PIN + 6)
+#define PIO015      (GPIO0_START_PIN + 7)
+#define PIO016      (GPIO0_START_PIN + 8)
+#define PIO024      (GPIO0_START_PIN + 9)
+#define PIO027      (GPIO0_START_PIN + 10)
+#define PIO068      (GPIO0_START_PIN + 11)
+#define PIO069      (GPIO0_START_PIN + 12)
+#define PIO071      (GPIO0_START_PIN + 13)
+#define PIO072      (GPIO0_START_PIN + 14)
+#define PIO073      (GPIO0_START_PIN + 15)
+#define PIO074      (GPIO0_START_PIN + 16)
+#define PIO075      (GPIO0_START_PIN + 17)
+#define PIO082      (GPIO0_START_PIN + 18)
+#define PIO083      (GPIO0_START_PIN + 19)
+#define PIO084      (GPIO0_START_PIN + 20)
+#define PIO085      (GPIO0_START_PIN + 21)
+#define PIO086      (GPIO0_START_PIN + 22)
+#define PIO087      (GPIO0_START_PIN + 23)
+#define PIO088      (GPIO0_START_PIN + 24)
+#define PIO089      (GPIO0_START_PIN + 25)
+#define PIO090      (GPIO0_START_PIN + 26)
+#define PIO091      (GPIO0_START_PIN + 27)
+#define PIO092      (GPIO0_START_PIN + 28)
+#define PIO093      (GPIO0_START_PIN + 29)
+#define PIO103      (GPIO0_START_PIN + 30)
+#define PIO118      (GPIO0_START_PIN + 31)
+#define PIO119      (GPIO0_START_PIN + 32)
+#define PIO120      (GPIO0_START_PIN + 33)
+#define PIO121      (GPIO0_START_PIN + 34)
+#define PIO122      (GPIO0_START_PIN + 35)
+#define PIO128      (GPIO0_START_PIN + 36)
+#define PIO129      (GPIO0_START_PIN + 37)
+#define PIO130      (GPIO0_START_PIN + 38)
+#define PIO141      (GPIO0_START_PIN + 39)
+#define PIO142      (GPIO0_START_PIN + 40)
+#define PIO143      (GPIO0_START_PIN + 41)
+#define PIO144      (GPIO0_START_PIN + 42)
+#define PIO145      (GPIO0_START_PIN + 43)
+#define PIO146      (GPIO0_START_PIN + 44)
+#define PIO147      (GPIO0_START_PIN + 45)
+#define PIO148      (GPIO0_START_PIN + 46)
+#define PIO149      (GPIO0_START_PIN + 47)
+#define PIO150      (GPIO0_START_PIN + 48)
+#define PIO161      (GPIO0_START_PIN + 49)
+#define PIO162      (GPIO0_START_PIN + 50)
+#define PIO164      (GPIO0_START_PIN + 51)
+#define PIO165      (GPIO0_START_PIN + 52)
+#define PIO169      (GPIO0_START_PIN + 53)
+#define PIO172      (GPIO0_START_PIN + 54)
+#define PIO173      (GPIO0_START_PIN + 55)
+#define PIO174      (GPIO0_START_PIN + 56)
+#define PIO175      (GPIO0_START_PIN + 57)
+#define PIO176      (GPIO0_START_PIN + 58)
+#define PIO177      (GPIO0_START_PIN + 59)
+#define PIO178      (GPIO0_START_PIN + 60)
+#define PIO179      (GPIO0_START_PIN + 61)
+#define PIO180      (GPIO0_START_PIN + 62)
+#define PIO181      (GPIO0_START_PIN + 63)
+#define PIO182      (GPIO0_START_PIN + 64)
+#define PIO183      (GPIO0_START_PIN + 65)
+#define PIO184      (GPIO0_START_PIN + 66)
+#define PIO185      (GPIO0_START_PIN + 67)
+#define PIO186      (GPIO0_START_PIN + 68)
+#define PIO187      (GPIO0_START_PIN + 69)
+#define PIO188      (GPIO0_START_PIN + 70)
+#define PIO189      (GPIO0_START_PIN + 71)
+#define PIO190      (GPIO0_START_PIN + 72)
+#define PIO191      (GPIO0_START_PIN + 73)
+
+/**
+ * PIOs in GPIO right
+ **/
+#define PIO001      (GPIO1_START_PIN + 0)
+#define PIO002      (GPIO1_START_PIN + 1)
+#define PIO003      (GPIO1_START_PIN + 2)
+#define PIO004      (GPIO1_START_PIN + 3)
+#define PIO005      (GPIO1_START_PIN + 4)
+#define PIO006      (GPIO1_START_PIN + 5)
+#define PIO007      (GPIO1_START_PIN + 6)
+#define PIO019      (GPIO1_START_PIN + 7)
+#define PIO020      (GPIO1_START_PIN + 8)
+#define PIO021      (GPIO1_START_PIN + 9)
+#define PIO022      (GPIO1_START_PIN + 10)
+#define PIO025      (GPIO1_START_PIN + 11)
+#define PIO031      (GPIO1_START_PIN + 12)
+#define PIO032      (GPIO1_START_PIN + 13)
+#define PIO033      (GPIO1_START_PIN + 14)
+#define PIO034      (GPIO1_START_PIN + 15)
+#define PIO035      (GPIO1_START_PIN + 16)
+#define PIO036      (GPIO1_START_PIN + 17)
+#define PIO037      (GPIO1_START_PIN + 18)
+#define PIO039      (GPIO1_START_PIN + 19)
+#define PIO044      (GPIO1_START_PIN + 20)
+#define PIO045      (GPIO1_START_PIN + 21)
+#define PIO048      (GPIO1_START_PIN + 22)
+#define PIO049      (GPIO1_START_PIN + 23)
+#define PIO051      (GPIO1_START_PIN + 24)
+#define PIO052      (GPIO1_START_PIN + 25)
+#define PIO063      (GPIO1_START_PIN + 26)
+#define PIO064      (GPIO1_START_PIN + 27)
+#define PIO065      (GPIO1_START_PIN + 28)
+#define PIO070      (GPIO1_START_PIN + 29)
+#define PIO077      (GPIO1_START_PIN + 30)
+#define PIO109      (GPIO1_START_PIN + 31)
+#define PIO110      (GPIO1_START_PIN + 32)
+#define PIO111      (GPIO1_START_PIN + 33)
+#define PIO112      (GPIO1_START_PIN + 34)
+#define PIO113      (GPIO1_START_PIN + 35)
+#define PIO114      (GPIO1_START_PIN + 36)
+#define PIO115      (GPIO1_START_PIN + 37)
+#define PIO116      (GPIO1_START_PIN + 38)
+#define PIO117      (GPIO1_START_PIN + 39)
+#define PIO151      (GPIO1_START_PIN + 40)
+#define PIO152      (GPIO1_START_PIN + 41)
+#define PIO153      (GPIO1_START_PIN + 42)
+#define PIO154      (GPIO1_START_PIN + 43)
+#define PIO155      (GPIO1_START_PIN + 44)
+#define PIO156      (GPIO1_START_PIN + 45)
+#define PIO157      (GPIO1_START_PIN + 46)
+#define PIO158      (GPIO1_START_PIN + 47)
+#define PIO159      (GPIO1_START_PIN + 48)
+#define PIO170      (GPIO1_START_PIN + 49)
+#define PIO171      (GPIO1_START_PIN + 50)
+#define PIO193      (GPIO1_START_PIN + 51)
+#define PIO194      (GPIO1_START_PIN + 52)
+#define PIO195      (GPIO1_START_PIN + 53)
+#define PIO196      (GPIO1_START_PIN + 54)
+#define PIO197      (GPIO1_START_PIN + 55)
+#define PIO198      (GPIO1_START_PIN + 56)
+#define PIO199      (GPIO1_START_PIN + 57)
+
+#endif /* __ARCH_MACH_APOLLO_GPIO_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/hardware.h linux-2.6.34/arch/arm/mach-apollo/include/mach/hardware.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/hardware.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/hardware.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/pnx8492.h>
+
+/*
+ * PCI space virtual addresses
+ */
+#define APOLLO_PCI_VIRT_BASE		(void __iomem *)APOLLO_PCI_CORE_BASE
+#define APOLLO_PCI_CFG_VIRT_BASE	(void __iomem *)APOLLO_PCI_CORE_BASE
+
+/* guesswork !! required for: drivers/pci/setup-res.c */
+#define PCIBIOS_MIN_IO			0x44000000
+#define PCIBIOS_MIN_MEM			0x50000000
+
+#define pcibios_assign_all_busses()	1
+
+/* macro to get at IO space when running virtually */
+
+#define IO_OFFSET	0xE0400000
+#define IO_BASE		0xE0400000	/* VA of Peripheral space */
+#define IO_SIZE		0x0B000000	/* More than Enough */
+#define IO_START	0xE0400000	/* Base address Peripheral space */
+
+#ifdef CONFIG_MMU
+#define IO_ADDRESS(x)	(((x) - IO_OFFSET) + IO_BASE)
+#define __IOMEM(x)	((void __iomem*)(((x) - IO_OFFSET) + IO_BASE))
+#else
+#define IO_ADDRESS(x)	(x)
+#define __IOMEM(x)	(x)
+#endif
+#define __io_address(n)	__io(IO_ADDRESS(n))
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/io.h linux-2.6.34/arch/arm/mach-apollo/include/mach/io.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/io.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/io.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <asm/cacheflush.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+/* DMA operations */
+inline static void dma_cache_inv(unsigned long start, unsigned long size)
+{
+        void *_start = (void*) start;
+	dmac_map_area(_start,size,2); //DMA_FROM_DEVICE); Due to recursive includes, linux/dma-mapping.h is not visible
+}
+
+inline static void dma_cache_wback(unsigned long start, unsigned long size)
+{
+        void *_start = (void*) start;
+	dmac_unmap_area(_start,size,1); //DMA_TO_DEVICE);
+}
+
+inline static void dma_cache_wback_inv(unsigned long start, unsigned long size)
+{
+        void *_start = (void*) start;
+        void *_end = (void*) (start + size);
+	dmac_flush_range(_start,_end);
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/irqs.h linux-2.6.34/arch/arm/mach-apollo/include/mach/irqs.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/irqs.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/irqs.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <mach/pnx8492.h>
+#include <mach/gpio.h> /* TODO: Added to get the proper GPIO related defines */
+
+/* ------------------------------------------------------------------------
+ *  Interrupts - bit assignment (primary)
+ *	Cortex A9 interrupt distributor can handle 224 interrupts.
+ *	permitted values are 0, 32, 64, 96, 128, 160, 192, 224.
+ *
+ *  REMARK: for the real assignment, see bottom of file -> IRQ_...
+ *
+ * ------------------------------------------------------------------------
+ */
+
+/* ------------------------------------------------------------------------
+ * Cortex A9 internal interrupts are not going via the Distributor
+ * ------------------------------------------------------------------------
+ */
+#define INT_SGI_ID00		0   /* Cortex A9 SW generated IRQ id-0 */
+#define INT_SGI_ID01		1   /* Cortex A9 SW generated IRQ id-1 */
+#define INT_SGI_ID02		2   /* Cortex A9 SW generated IRQ id-2 */
+#define INT_SGI_ID03		3   /* Cortex A9 SW generated IRQ id-3 */
+#define INT_SGI_ID04		4   /* Cortex A9 SW generated IRQ id-4 */
+#define INT_SGI_ID05		5   /* Cortex A9 SW generated IRQ id-5 */
+#define INT_SGI_ID06		6   /* Cortex A9 SW generated IRQ id-6 */
+#define INT_SGI_ID07		7   /* Cortex A9 SW generated IRQ id-7 */
+#define INT_SGI_ID08		8   /* Cortex A9 SW generated IRQ id-8 */
+#define INT_SGI_ID09		9   /* Cortex A9 SW generated IRQ id-9 */
+#define INT_SGI_ID10		10  /* Cortex A9 SW generated IRQ id-10 */
+#define INT_SGI_ID11		11  /* Cortex A9 SW generated IRQ id-11 */
+#define INT_SGI_ID12		12  /* Cortex A9 SW generated IRQ id-12 */
+#define INT_SGI_ID13		13  /* Cortex A9 SW generated IRQ id-13 */
+#define INT_SGI_ID14		14  /* Cortex A9 SW generated IRQ id-14 */
+#define INT_SGI_ID15		15  /* Cortex A9 SW generated IRQ id-15 */
+#define INT_SOURCE16		16  /* reserved by by ARM */
+#define INT_SOURCE17		17  /* reserved by by ARM */
+#define INT_SOURCE18		18  /* reserved by by ARM */
+#define INT_SOURCE19		19  /* reserved by by ARM */
+#define INT_SOURCE20		20  /* reserved by by ARM */
+#define INT_SOURCE21		21  /* reserved by by ARM */
+#define INT_SOURCE22		22  /* reserved by by ARM */
+#define INT_SOURCE23		23  /* reserved by by ARM */
+#define INT_SOURCE24		24  /* reserved by by ARM */
+#define INT_SOURCE25		25  /* reserved by by ARM */
+#define INT_SOURCE26		26  /* reserved by by ARM */
+#define INT_A9_GLOB_TIMER	27  /* Cortex A9 global timer        */
+#define INT_A9_LEGACY_FIQ	28  /* Cortex A9 nFIQ in legacy mode */
+#define INT_A9_PRIV_TIMER	29  /* Cortex A9 privat timer        */
+#define INT_A9_WDG_TIMER	30  /* Cortex A9 watchdog timer      */
+#define INT_A9_LEGACY_IRQ	31  /* Cortex A9 nIRQ in legacy mode */
+/*
+ * Interrupt  0 - 31 is internal Cortex A9 (local per core),
+ *           32 - 223 are external interrupts (via Distributor).
+ */
+#define IRQ_DISTR_OFFSET	32  /* IRQ offset to non internal irq's */
+
+#define P_IN_BEGIN_OF_LIST	0   /* GIC IRQ-PIN starts from here */
+#define P_IN_GPIO_LEFT		0   /* gpio_out_gic_l */
+#define P_IN_IPC_CORTEXM3	1   /* intrpt_ipc0 = intrpt_cortexm3 */
+#define P_IN_IPC_CORTEXA9	2   /* intrpt_ipc1 = intrpt_cortexa9 */
+#define P_IN_IPC_ARM926		3   /* intrpt_ipc2 = intrpt_arm926 */
+#define P_IN_IPC_TM_VDSP	4   /* intrpt_ipc3 = intrpt_tm_vdsp */
+#define P_IN_IPC_TM_ADSP	5   /* intrpt_ipc4 = intrpt_tm_adsp */
+#define P_IN_CGU_CLOCK		6   /* intrpt_clock (CGU) */
+#define P_IN_SATA		7   /* intrpt_sata */
+#define P_IN_ETHR_MAC0		8   /* intrpt_ethernet_mac_0 */
+#define P_IN_ETHR_PWR0		9   /* intrpt_ethernet_pwr_0 */
+#define P_IN_NS			10  /* intrpt_ns */
+#define P_IN_PT0		11  /* pt0_irq (Pulse Timer) */
+#define P_IN_PT1		12  /* pt1_irq */
+#define P_IN_CEC		13  /* cec_int_n */
+#define P_IN_UART_A0            14  /* uart_intreq_a0 */
+#define P_IN_UART_A1            15  /* uart_intreq_a2 */
+#define P_IN_UART_A2            16  /* uart intreq_a1 */
+#define P_IN_UART_A3            17  /* uart intreq_a3 */
+#define P_IN_SPI_COMB		18  /* intrpt_spi_combined */
+#define P_IN_SPI_DMAC		19  /* intrpt_spi_dmacintr */
+#define P_IN_SM0		20  /* sm0_irq (SMartcard) */
+#define P_IN_SM1		21  /* sm1_irq */
+#define P_IN_IR_IO		22  /* ir_req (Irin/out) */
+#define P_IN_I2C2		23  /* intrpt_iic2 */
+#define P_IN_I2C3		24  /* intrpt_iic3 */
+#define P_IN_I2C4		25  /* intrpt_iic4 */
+#define P_IN_RTC0		26  /* timer_irq[23:0]->[49:26] (timers/RTC) */
+/* ... gap in list ... */
+#define P_IN_SDCN		50  /* intrpt_sdcn */
+#define P_IN_TSA		51  /* tsa_irq */
+#define P_IN_MCX		52  /* mcx_irq */
+#define P_IN_TSP		53  /* tsp_irq */
+#define P_IN_TSR		54  /* tsr_irq */
+#define P_IN_TSX		55  /* tsx_irq */
+#define P_IN_VD0		56  /* vd0_irq */
+#define P_IN_VD1		57  /* vd1_irq */
+#define P_IN_VD2		58  /* vd2_irq */
+#define P_IN_VD3		59  /* vd3_irq */
+#define P_IN_CAM		60  /* cam_irq */
+#define P_IN_USB0		61  /* intrpt_usb0 */
+#define P_IN_USB1		62  /* intrpt_usb1 */
+#define P_IN_USB2		63  /* intrpt_usb2 */
+#define P_IN_DMA_MON0		64  /* intrpt_mtlmon0 (DMA monitor) */
+#define P_IN_DMA_MON1		65  /* intrpt_mtlmon1 */
+#define P_IN_DMA_MON2		66  /* intrpt_mtlmon2 */
+#define P_IN_DMA_MON3		67  /* intrpt_mtlmon3 */
+#define P_IN_DMA_NETW		68  /* intreq_h0 (DMA netw hub) */
+#define P_IN_DMA_HUB		69  /* intreq_h1 (DMA arb, con) */
+#define P_IN_GPIO_RIGHT		70  /* gpio_out_gic_r */
+#define P_IN_DRAW2D		71  /* intrpt_draw2d */
+#define P_IN_GPPM		72  /* intrpt_gppm (PCI + IO/Flash Cntl+SDIO)(GCS) */
+#define P_IN_PCI_DMA		73  /* intrpt_pci_dma */
+#define P_IN_PCI		74  /* intrpt_pci */
+#define P_IN_PCI_IN		75  /* pci_inta_in */
+#define P_IN_GCS_DMA		76  /* dmacintr */
+#define P_IN_TURING_CLK		77  /* ckl_irq	TURING + FUSE_CTRL */
+#define P_IN_CRYPTO		78  /* crypto_irq */
+#define P_IN_NEWT		79  /* newt_intreq */
+#define P_IN_SSP_HOST0		80  /* ssp_host_int[1:0] */
+#define P_IN_SSP_HOST1		81  /* */
+#define P_IN_M_CARD		82  /* o_cc_irq	(M-Card CCIF) */
+#define P_IN_ACP_DMA_1902	83  /* dmacintr	(DMAC_1902) */
+#define P_IN_THALIA		84  /* thalia_irq (IMG SGX531) */
+#define P_IN_APB0		85  /* vdec_apb_intr[2:0] = FMVD (malone, arm926 , Video Dsp , Video dsp gic) */
+#define P_IN_APB1		86  /* */
+#define P_IN_APB2		87  /* */
+#define P_IN_VPIPE0		88  /* irq_vpipe[6:0] vsd_vpipe (mbvp_s2k9+cpipe_s2k9 + CPIPE_S2V0 ) */
+#define P_IN_VPIPE1		89  /* */
+#define P_IN_VPIPE2		90  /* */
+#define P_IN_VPIPE3		91  /* */
+#define P_IN_VPIPE4		92  /* */
+#define P_IN_VPIPE5		93  /* */
+#define P_IN_VPIPE6		94  /* */
+#define P_IN_SPDO		95  /* intrpt_spdo */
+#define P_IN_IPC5		96  /* intrpt_ipc5 */
+#define P_IN_IPC6		97  /* intrpt_ipc6 */
+#define P_IN_IPC7		98  /* intrpt_ipc7 */
+#define P_IN_AO_HDMI		99  /* intrpt_ao_hdmi (AO to HDMI) */
+#define P_IN_AO_BTSC		100 /* intrpt_ao_btsc (AO to BTSC) */
+#define P_IN_AO			101 /* intrpt_ao (AO NS ADAC) */
+#define P_IN_DENC		102 /* denc_dcs_cp_irq */
+#define P_IN_ADCN		103 /* intrpt_adcn (Host ARM MMIO) */
+#define P_IN_AVDSN		104 /* intrpt_avdsn (A/V Control MMIO BUS) */
+#define P_IN_HDMITX		105 /* intrpt_hdmitx */
+#define P_IN_ETHR_MAC1		106 /* intrpt_ethernet_mac_1 (GMAC) */
+#define P_IN_ETHR_PWR1		107 /* intrpt_ethernet_pwr_1 */
+#define P_IN_VIP		108 /* intrpt_vip*/
+#define P_IN_IP_2017		109 /* intrpt_ip_2017_intr */
+#define P_IN_SFC		110 /* intrpt_sfc */
+#define P_IN_DMA_MON4		111 /* intrpt_mtlmon4 */
+#define P_IN_DMA_MON5		112 /* intrpt_mtlmon5 */
+#define P_IN_DMA_MON6		113 /* intrpt_mtlmon6 */
+#define P_IN_DMA_MON7		114 /* intrpt_mtlmon7 */
+#define P_IN_TYPHOON		115 /* typhoon_interrupt */
+#define P_IN_AI			116 /* intrpt_ai */
+#define P_IN_I2C5		117 /* intrpt_iic5 */
+#define P_IN_AUX_CTI_TRIG7	118 /* aux_ctitrigout2[7] (CS-GDS) */
+#define P_IN_AUX_CTI_TRIG6	119 /* aux_ctitrigout2[6] */
+#define P_IN_PWM1		120 /* PWM1 */
+#define P_IN_PWM2		121 /* PWM2 */
+#define P_IN_PWM3		122 /* PWM3 */
+#define P_IN_GMAC_PHY		123 /* intrpt_gmac_phy */
+#define P_IN_SD_CARD		124 /* intrpt_sdcard */
+#define P_IN_PMU		125 /* intrpt_pmuirq */
+#define P_IN_A3CRC		126 /* intrpt_a3crc_done */
+#define P_IN_127RESERVED	127 /* Reserved */
+#define P_IN_L2_CCR		128 /* l2ccintr (L2 cache only on the A9 IRQ(128)) */
+#define P_IN_COMM_RX		129 /* COMMRX */
+#define P_IN_COMM_TX		130 /* COMMTX */
+#define P_IN_A9_CTI		131 /* a9_ctiirq */
+#define P_IN_132RESERVED	132 /* Reserved [255:164]->[223-132] */
+/* ... gap in list ... */
+#define P_IN_223RESERVED	223 /* */
+#define P_IN_END_OF_LIST	224 /* END OF LIST (NOT USABLE IRQ-PIN)*/
+/* End of supported interrupts in Apollo */
+
+/* ------------------------------------------------------------------------
+ *
+ * DO THE REAL IRQ ASSIGNMENTS...
+ *
+ * ------------------------------------------------------------------------
+ */
+#define IRQ_LOWEST_NBR		INT_SGI_ID00
+/* Cortex A9 core internal interrupts */
+#define IRQ_A9_GLOB_TIMER	INT_A9_GLOB_TIMER
+#define IRQ_A9_PRIV_TIMER	INT_A9_PRIV_TIMER
+#define IRQ_A9WDTIM		INT_A9_WDG_TIMER
+/* Cortex A9 external core provided interrupts */
+#define IRQ_GPIO_LEFT		(P_IN_GPIO_LEFT		+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_CORTEXM3	(P_IN_IPC_CORTEXM3	+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_CORTEXA9	(P_IN_IPC_CORTEXA9	+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_ARM926		(P_IN_IPC_ARM926	+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_TM_VDSP		(P_IN_IPC_TM_VDSP	+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_TM_ADSP		(P_IN_IPC_TM_ADSP	+ IRQ_DISTR_OFFSET)
+#define IRQ_CGU_CLOCK		(P_IN_CGU_CLOCK		+ IRQ_DISTR_OFFSET)
+#define IRQ_SATA		(P_IN_SATA		+ IRQ_DISTR_OFFSET)
+#define IRQ_ETHR_MAC_0		(P_IN_ETHR_MAC0		+ IRQ_DISTR_OFFSET)
+#define IRQ_ETHR_PWR_0		(P_IN_ETHR_PWR0		+ IRQ_DISTR_OFFSET)
+#define IRQ_NS			(P_IN_NS		+ IRQ_DISTR_OFFSET)
+#define IRQ_PT_0		(P_IN_PT0		+ IRQ_DISTR_OFFSET)
+#define IRQ_PT_1		(P_IN_PT1		+ IRQ_DISTR_OFFSET)
+#define IRQ_CEC			(P_IN_CEC		+ IRQ_DISTR_OFFSET)
+#define IRQ_UART_0		(P_IN_UART_A0		+ IRQ_DISTR_OFFSET)
+#define IRQ_UART_1		(P_IN_UART_A1		+ IRQ_DISTR_OFFSET)
+#define IRQ_UART_2		(P_IN_UART_A2		+ IRQ_DISTR_OFFSET)
+#define IRQ_UART_3		(P_IN_UART_A3		+ IRQ_DISTR_OFFSET)
+#define IRQ_SPI_COMB		(P_IN_SPI_COMB		+ IRQ_DISTR_OFFSET)
+#define IRQ_SPI_DMAC		(P_IN_SPI_DMAC		+ IRQ_DISTR_OFFSET)
+#define IRQ_SM0			(P_IN_SM0		+ IRQ_DISTR_OFFSET)
+#define IRQ_SM1			(P_IN_SM1		+ IRQ_DISTR_OFFSET)
+#define IRQ_IR_IO		(P_IN_IR_IO		+ IRQ_DISTR_OFFSET)
+#define IRQ_I2C_2		(P_IN_I2C2		+ IRQ_DISTR_OFFSET)
+#define IRQ_I2C_3		(P_IN_I2C3		+ IRQ_DISTR_OFFSET)
+#define IRQ_I2C_4		(P_IN_I2C4		+ IRQ_DISTR_OFFSET)
+#define IRQ_RTC0		(P_IN_RTC0		+ IRQ_DISTR_OFFSET)
+/* ... gap in list ... [23:0]->[49:26] (timers/RTC) ... */
+#define IRQ_SDCN		(P_IN_SDCN		+ IRQ_DISTR_OFFSET)
+#define IRQ_TSA			(P_IN_TSA		+ IRQ_DISTR_OFFSET)
+#define IRQ_MCX			(P_IN_MCX		+ IRQ_DISTR_OFFSET)
+#define IRQ_TSP			(P_IN_TSP		+ IRQ_DISTR_OFFSET)
+#define IRQ_TSR			(P_IN_TSR		+ IRQ_DISTR_OFFSET)
+#define IRQ_TSX			(P_IN_TSX		+ IRQ_DISTR_OFFSET)
+#define IRQ_VD_0		(P_IN_VD0		+ IRQ_DISTR_OFFSET)
+#define IRQ_VD_1		(P_IN_VD1		+ IRQ_DISTR_OFFSET)
+#define IRQ_VD_2		(P_IN_VD2		+ IRQ_DISTR_OFFSET)
+#define IRQ_VD_3		(P_IN_VD3		+ IRQ_DISTR_OFFSET)
+#define IRQ_CAM			(P_IN_CAM		+ IRQ_DISTR_OFFSET)
+#define IRQ_USB_0		(P_IN_USB0		+ IRQ_DISTR_OFFSET)
+#define IRQ_USB_1		(P_IN_USB1		+ IRQ_DISTR_OFFSET)
+#define IRQ_USB_2		(P_IN_USB2		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_0		(P_IN_DMA_MON0		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_1		(P_IN_DMA_MON1		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_2		(P_IN_DMA_MON2		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_3		(P_IN_DMA_MON3		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_NETW		(P_IN_DMA_NETW		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_HUB		(P_IN_DMA_HUB		+ IRQ_DISTR_OFFSET)
+#define IRQ_GPIO_RIGHT		(P_IN_GPIO_RIGHT	+ IRQ_DISTR_OFFSET)
+#define IRQ_DRAW2D		(P_IN_DRAW2D		+ IRQ_DISTR_OFFSET)
+#define IRQ_GPPM		(P_IN_GPPM		+ IRQ_DISTR_OFFSET)
+#define IRQ_PCI_DMA		(P_IN_PCI_DMA		+ IRQ_DISTR_OFFSET)
+#define IRQ_PCI			(P_IN_PCI		+ IRQ_DISTR_OFFSET)
+#define IRQ_PCI_IN		(P_IN_PCI_IN		+ IRQ_DISTR_OFFSET)
+#define IRQ_GCS_DMA		(P_IN_GCS_DMA		+ IRQ_DISTR_OFFSET)
+#define IRQ_TURING_CLK		(P_IN_TURING_CLK	+ IRQ_DISTR_OFFSET)
+#define IRQ_CRYPTO		(P_IN_CRYPTO		+ IRQ_DISTR_OFFSET)
+#define IRQ_NEWT		(P_IN_NEWT		+ IRQ_DISTR_OFFSET)
+#define IRQ_SSP_HOST_0		(P_IN_SSP_HOST0		+ IRQ_DISTR_OFFSET)
+#define IRQ_SSP_HOST_1		(P_IN_SSP_HOST1		+ IRQ_DISTR_OFFSET)
+#define IRQ_M_CARD		(P_IN_M_CARD		+ IRQ_DISTR_OFFSET)
+#define IRQ_ACP_DMA_1902	(P_IN_ACP_DMA_1902	+ IRQ_DISTR_OFFSET)
+#define IRQ_THALIA		(P_IN_THALIA		+ IRQ_DISTR_OFFSET)
+#define IRQ_APB_0		(P_IN_APB0		+ IRQ_DISTR_OFFSET)
+#define IRQ_APB_1		(P_IN_APB1		+ IRQ_DISTR_OFFSET)
+#define IRQ_APB_2		(P_IN_APB2		+ IRQ_DISTR_OFFSET)
+#define IRQ_VPIPE_0		(P_IN_VPIPE0		+ IRQ_DISTR_OFFSET)
+#define IRQ_VPIPE_1		(P_IN_VPIPE1		+ IRQ_DISTR_OFFSET)
+#define IRQ_VPIPE_2		(P_IN_VPIPE2		+ IRQ_DISTR_OFFSET)
+#define IRQ_VPIPE_3		(P_IN_VPIPE3		+ IRQ_DISTR_OFFSET)
+#define IRQ_VPIPE_4		(P_IN_VPIPE4		+ IRQ_DISTR_OFFSET)
+#define IRQ_SPDO		(P_IN_SPDO		+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_5		(P_IN_IPC5		+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_6		(P_IN_IPC6		+ IRQ_DISTR_OFFSET)
+#define IRQ_IPC_7		(P_IN_IPC7		+ IRQ_DISTR_OFFSET)
+#define IRQ_AO_HDMI		(P_IN_AO_HDMI		+ IRQ_DISTR_OFFSET)
+#define IRQ_AO_BTSC		(P_IN_AO_BTSC		+ IRQ_DISTR_OFFSET)
+#define IRQ_AO			(P_IN_AO		+ IRQ_DISTR_OFFSET)
+#define IRQ_DENC		(P_IN_DENC		+ IRQ_DISTR_OFFSET)
+#define IRQ_ADCN		(P_IN_ADCN		+ IRQ_DISTR_OFFSET)
+#define IRQ_AVDSN		(P_IN_AVDSN		+ IRQ_DISTR_OFFSET)
+#define IRQ_HDMITX		(P_IN_HDMITX		+ IRQ_DISTR_OFFSET)
+#define IRQ_ETHR_MAC_1		(P_IN_ETHR_MAC1		+ IRQ_DISTR_OFFSET)
+#define IRQ_ETHR_PWR_1		(P_IN_ETHR_PWR1		+ IRQ_DISTR_OFFSET)
+#define IRQ_VIP			(P_IN_VIP		+ IRQ_DISTR_OFFSET)
+#define IRQ_IP_2017		(P_IN_IP_2017		+ IRQ_DISTR_OFFSET)
+#define IRQ_SFC			(P_IN_SFC		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_4		(P_IN_DMA_MON4		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_5		(P_IN_DMA_MON5		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_6		(P_IN_DMA_MON6		+ IRQ_DISTR_OFFSET)
+#define IRQ_DMA_MON_7		(P_IN_DMA_MON7		+ IRQ_DISTR_OFFSET)
+#define IRQ_TYPHOON		(P_IN_TYPHOON		+ IRQ_DISTR_OFFSET)
+#define IRQ_AI			(P_IN_AI		+ IRQ_DISTR_OFFSET)
+#define IRQ_I2C_5		(P_IN_I2C5		+ IRQ_DISTR_OFFSET)
+#define IRQ_AUX_CTI_TRIG_7	(P_IN_AUX_CTI_TRIG7	+ IRQ_DISTR_OFFSET)
+#define IRQ_AUX_CTI_TRIG_6	(P_IN_AUX_CTI_TRIG6	+ IRQ_DISTR_OFFSET)
+#define IRQ_PWM_1		(P_IN_PWM1		+ IRQ_DISTR_OFFSET)
+#define IRQ_PWM_2		(P_IN_PWM2		+ IRQ_DISTR_OFFSET)
+#define IRQ_PWM_3		(P_IN_PWM3		+ IRQ_DISTR_OFFSET)
+#define IRQ_GMAC_PHY		(P_IN_GMAC_PHY		+ IRQ_DISTR_OFFSET)
+#define IRQ_SD_CARD		(P_IN_SD_CARD		+ IRQ_DISTR_OFFSET)
+#define IRQ_PMU			(P_IN_PMU		+ IRQ_DISTR_OFFSET)
+#define IRQ_A3CRC		(P_IN_A3CRC		+ IRQ_DISTR_OFFSET)
+#define IRQ_127_RESERVED	(P_IN_127RESERVED	+ IRQ_DISTR_OFFSET)
+#define IRQ_L2_CCR		(P_IN_L2_CCR		+ IRQ_DISTR_OFFSET)
+#define IRQ_COMM_RX		(P_IN_COMM_RX		+ IRQ_DISTR_OFFSET)
+#define IRQ_COMM_TX		(P_IN_COMM_TX		+ IRQ_DISTR_OFFSET)
+#define IRQ_A9_CTI		(P_IN_A9_CTI		+ IRQ_DISTR_OFFSET)
+#define IRQ_132_RESERVED	(P_IN_132RESERVED	+ IRQ_DISTR_OFFSET)
+/* ... gap in list ... [255:164]->[223-132] ... */
+#define IRQ_223_RESERVED	(P_IN_223RESERVED	+ IRQ_DISTR_OFFSET)
+#define IRQ_MAX_NBR		(P_IN_END_OF_LIST	+ IRQ_DISTR_OFFSET)
+
+/* ------------------------------------------------------------------------
+ *   Additional IRQ assignment i.f.o. generic kernel parts
+ * ------------------------------------------------------------------------
+ */
+#define IRQ_GLOBALTIMER		IRQ_A9_GLOB_TIMER
+#define IRQ_LOCALTIMER		IRQ_A9_PRIV_TIMER
+
+#define IRQ_LOCALWDOG		IRQ_A9WDTIM
+#define IRQ_GIC_START		(P_IN_BEGIN_OF_LIST + IRQ_DISTR_OFFSET)
+
+#ifdef  CONFIG_GPIO_APOLLO  /*TODO: Commented the wrong define use #ifdef CONFIG_APOLLO_GPIO*/
+#define NR_IRQS			(GPIO1_IRQ_BASE + GPIO1_MAX_NR)
+#else
+#define NR_IRQS			IRQ_MAX_NBR
+#endif
+#define DISTR_MAX_IRQS		NR_IRQS
+
+#ifndef NR_IRQS
+#error "NR_IRQS not defined by the board-specific files"
+#endif
+
+#endif /* __ASM_ARCH_IRQS_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/localtimers.h linux-2.6.34/arch/arm/mach-apollo/include/mach/localtimers.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/localtimers.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/localtimers.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,42 @@
+
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author:	Frank Dols <frank.dols@nxp.com>
+ *		Mischa Jonker <mischa.jonker@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_LOCALTIMER_H
+#define __ASM_ARCH_LOCALTIMER_H
+
+#define LOCAL_TIMER_RELOAD		0x00
+#define LOCAL_TIMER_COUNTER		0x04
+#define LOCAL_TIMER_CONTROL		0x08
+#define LOCAL_TIMER_STATUS		0x0C
+
+#define LOCAL_TIMER_CTRL_IRQ_ENA	0x04
+#define LOCAL_TIMER_CTRL_AUTORELOAD_ENA	0x02
+#define LOCAL_TIMER_CTRL_TIMER_ENA	0x01
+
+#define LOCAL_TIMER_STAT_EVENT		0x01
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/memory.h linux-2.6.34/arch/arm/mach-apollo/include/mach/memory.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/memory.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/memory.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/* PCI Direct Mappings */
+#define APOLLO_PCI_MEM_BASE_0_LO 0xA0000000
+#define APOLLO_PCI_MEM_BASE_0_HI 0xBFDFFFFF
+#define APOLLO_PCI_MEM_BASE_1_LO 0xBFE00000
+#define APOLLO_PCI_MEM_BASE_1_HI 0xBFFFFFFF
+
+#define APOLLO_PCI_MEM_BASE_0    APOLLO_PCI_MEM_BASE_0_LO
+#define APOLLO_PCI_MEM_BASE_1    APOLLO_PCI_MEM_BASE_1_LO
+
+#define APOLLO_PCI_MEM_BASE_0_SIZE  (APOLLO_PCI_MEM_BASE_0_HI - APOLLO_PCI_MEM_BASE_0_LO)
+#define APOLLO_PCI_MEM_BASE_1_SIZE  (APOLLO_PCI_MEM_BASE_1_HI - APOLLO_PCI_MEM_BASE_1_LO)
+
+#if 0
+/* Sizes of above maps */
+#define APOLLO_PCIMEM			0x20000000
+#define APOLLO_PCIMEM_SIZE		0x10000000	/* 256Mb */
+
+#define APOLLO_PCIIO			0x30000000
+#define APOLLO_PCIIO_SIZE		0x00100000
+#endif
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET			UL(0x00000000)
+
+/*
+ * Sparsemem definitions, only valid for high PHYS_OFFSET.
+ *
+ * Most of our boards have 512MB or 256M of RAM. There are 2 banks at 0 and
+ * 0x20000000. The memory exists as 256/128M at 0 and 256/128 at  
+ * 0x20000000.
+ *
+ * The macros below define a section size of 512MB and a non-linear virtual to
+ * physical mapping:
+ *
+ * 0x00000000 -> PAGE_OFFSET
+ * 0x20000000 -> PAGE_OFFSET + 0x10000000
+ */
+#ifdef CONFIG_SPARSEMEM
+
+#define MAX_PHYSMEM_BITS    32 /* The top bit is set for virtual space so
+                                  you need all 32-bits for an address */
+
+#define SECTION_SIZE_BITS   28 /* log2(256M) = 28 */
+
+#define __phys_to_virt(phys) ({                                 \
+        unsigned long virt = 0;                                 \
+        if (((phys) >= 0x20000000UL))                           \
+                virt = (phys) - 0x10000000UL + PAGE_OFFSET;     \
+        else                                                    \
+                virt = (phys) + PAGE_OFFSET;                    \
+        virt;                                                   \
+})
+
+
+#define __virt_to_phys(virt) ({                                 \
+        unsigned long phys = 0;                                 \
+        if (((virt) >= PAGE_OFFSET + 0x10000000UL))             \
+                phys = (virt) - PAGE_OFFSET + 0x10000000UL;     \
+        else if ((virt) >= PAGE_OFFSET)                         \
+                phys = (virt) - PAGE_OFFSET;                    \
+        phys;                                                   \
+})
+
+#endif
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nand.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nand.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nand.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nand.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for EFMC IP_2070.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 1.0.0		Sundarapandian A		20090720		Updated for APOLLO
+ */
+#include <mach/pnx8492.h>
+#define   APOLLO_IP2017_BASE          (ARM_A9_HOST_MMIO_BASE + 0x31000)
+#define	  APOLLO_IP2017_LEN           SZ_4K
+#define   APOLLO_INT_FLASH_CTRL_NAND  141
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nor.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nor.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nor.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nor.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for EFMC IP_2070.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 1.0.0		Sundarapandian A		20090720		Updated for APOLLO
+ */
+#ifndef _NOR_H_
+#define _NOR_H_
+
+/* #include <mach/platform.h> */
+#include <mach/irqs.h>
+
+#define APOLLO_IP2016_BASE_PHYS          (ARM_A9_HOST_MMIO_BASE + 0x30000)
+#define APOLLO_IP2016_BASE               (APOLLO_IP2016_BASE_PHYS)  
+#define APOLLO_IP2016_LEN                (0x1000)
+
+#define APOLLO_NOR_BASE                  (0xD0000000)
+#define APOLLO_NOR_LEN                   SZ_128M
+
+#define APOLLO_IP2016_POWER_DOWN_CFG_OFFSET    (0xFF4)
+#define APOLLO_IP2016_POWER_DOWN_MASK        (0x00000001)
+#define APOLLO_IP2016_POWER_DOWN_ENABLE      (1UL<<0)
+#define APOLLO_IP2016_POWER_DOWN_DISABLE     (0UL<<0)
+
+#endif /* _NOR_H_ */
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_dmac_1902_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_dmac_1902_dev.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_dmac_1902_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_dmac_1902_dev.h	2010-09-07 22:57:58.000000000 -0500
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for DMA Controller IP_1902
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090528     Draft-Initial version
+ *
+ */
+
+#ifndef __ARCH_MACH_NX_DMAC_1902_DEV_H_
+#define __ARCH_MACH_NX_DMAC_1902_DEV_H_
+
+
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+
+#define APOLLO_DMAC_1902_ACP_BASE_PHYS  (ARM_A9_HOST_MMIO_BASE + 0x2A000)
+#define APOLLO_DMAC_1902_ACP_BASE       (APOLLO_DMAC_1902_ACP_BASE_PHYS)  
+#define APOLLO_DMAC_1902_ACP_LEN        (0x1000)
+
+#define APOLLO_INT_DMAC_1902_ACP        ( IRQ_ACP_DMA_1902 )
+
+#define APOLLO_DMAC_1902_UART_SPI_BASE_PHYS  (ARM_A9_HOST_MMIO_BASE + 0xE5000)
+#define APOLLO_DMAC_1902_UART_SPI_BASE       (APOLLO_DMAC_1902_UART_SPI_BASE_PHYS)  
+#define APOLLO_DMAC_1902_UART_SPI_LEN        (0x1000)
+
+#define APOLLO_INT_DMAC_1902_UART_SPI        ( IRQ_SPI_DMAC )
+
+#endif /* __ARCH_MACH_NX_DMAC_1902_DEV_H_ */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_dmac_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_dmac_dev.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_dmac_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_dmac_dev.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for DMAC IP_1902.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 0.0.1	Bangaragiri G	20080402	Draft-Initial version
+ * 0.1.0	Bangaragiri G	20080804	Proposal-After self review
+ * 0.2.0	Bangaragiri G	20080925	Proposal-After including review comments
+ * 1.0.0	Bangaragiri G	20090305	Accepted-After testing on TV550M0 board
+ */
+ 
+#ifndef __ARCH_MACH_NX_DMAC_DEV_H
+#define __ARCH_MACH_NX_DMAC_DEV_H
+
+
+/* Fix me: To be taken from glb.h */
+#define		APOLLO_DMAC_BASE		(0xE0634000)
+#define		APOLLO_DMAC_LEN			(4096)
+#define		APOLLO_INT_FLASH_DMA		115  /* Fixme, has to come from irqs.h !! */
+
+#define		NX_DMAC_INT_STATUS		(0x000)
+#define		NX_DMAC_INT_TC_STATUS		(0x004)
+#define		NX_DMAC_INT_TC_CLR		(0x008)
+#define		NX_DMAC_INT_ERR_STATUS		(0x00C)
+#define		NX_DMAC_INT_ERR_CLR		(0x010)
+#define		NX_DMAC_INT_RAW_TC_STATUS	(0x014)
+#define		NX_DMAC_INT_RAW_ERR_STATUS	(0x018)
+#define		NX_DMAC_ENLD_CHANS		(0x01C)
+#define		NX_DMAC_SOFT_BREQ		(0x020)
+#define		NX_DMAC_SOFT_SREQ		(0x024)
+#define		NX_DMAC_SOFT_LBREQ		(0x028)
+#define		NX_DMAC_SOFT_LSREQ		(0x02C)
+#define		NX_DMAC_CONFIG			(0x030)
+#define		NX_DMAC_SYNC			(0x034)
+#define		NX_DMAC_CHAN0_SRC		(0x100)
+#define		NX_DMAC_CHAN0_DST		(0x104)
+#define		NX_DMAC_CHAN0_LLI		(0x108)
+#define		NX_DMAC_CHAN0_CTRL		(0x10C)
+#define		NX_DMAC_CHAN0_CONFIG		(0x110)
+#define		NX_DMAC_PERI_ID0		(0xFE0)
+#define		NX_DMAC_PERI_ID1		(0xFE4)
+#define		NX_DMAC_PERI_ID2		(0xFE8)
+#define		NX_DMAC_PERI_ID3		(0xFEC)
+#define		NX_DMAC_CELL_ID0		(0xFF0)
+#define		NX_DMAC_CELL_ID1		(0xFF4)
+#define		NX_DMAC_CELL_ID2		(0xFF8)
+#define		NX_DMAC_CELL_ID3		(0xFFC)
+
+#define		NX_DMAC_CHAN_OFF		(0x020)
+
+#endif /* __ARCH_MACH_NX_DMAC_DEV_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_nand_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_nand_dev.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_nand_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_nand_dev.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for EFMC IP_2070.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks
+ * 0.0.1	Bangaragiri G		20080402	Draft-Initial version
+ * 0.1.0	Bangaragiri G		20080804	Proposal-After self review
+ * 0.2.0	Bangaragiri G		20080925	Proposal-After including review comments
+ * 1.0.0	Bangaragiri G		20090305	Accepted-After testing on TV550M0 board
+ * 1.1.0	Bangaragiri G		20090318	Accepted-Updates after OneNAND tests
+ * 1.1.0	Sundarapandian A	20090720	Updated for APOLLO
+ */
+ 
+#ifndef __ARCH_MACH_NX_NAND_DEV_H
+#define __ARCH_MACH_NX_NAND_DEV_H
+
+
+/* FIXME: To be taken from glb.h */
+#define   APOLLO_IP2017_BASE          (0xE0631000)
+#define	  APOLLO_IP2017_LEN           (4096)
+#define   APOLLO_INT_FLASH_CTRL_NAND  (141)  /* Fixme, has to come from irqs.h !! */
+#if 0
+#define   PNX8XXX_ESMC_BASE           (0x1BE2A000)
+#define	  PNX8XXX_ESMC_LEN		      (4096)
+#define	  PNX8XXX_AHB_ONENAND_BASE    (0x1BC60000)
+#define	  PNX8XXX_ONENAND_LEN         (128 * 1024)
+#endif
+
+/* NAND/OneNAND select bit in GLB_MISC2 */
+#define NAND_SELECT  (0x00000100)
+
+/* OneNAND defines */
+#define ONENAND_MAX_PAGE_SIZE  (2048)
+#define ONENAND_2016_AHB_SIZE  (0x40000000)	
+
+/* Base address defintions */
+#define NX_NAND_AHB_INTFC_BUF  	      (0x0000000) /* Physical address of AHB buffer */
+
+/* Max Data buffer size */
+#define NX_NAND_BLK_SIZE          (512)
+
+/* Max OOB buffer size */
+#define NX_NAND_MAX_OOB_SIZE      (128)
+
+/* Maximum AHB buffer size */
+#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
+
+/* NAND CONTROLLER register definitions */
+#define NX_NAND_INT_ENA_OFFSET    (0xFE4)
+
+#define NX_NAND_POWER_DOWN_CFG_OFFSET (0xFF4)
+#define   NX_NAND_POWER_DOWN_MASK     (0x00000001)
+#define   NX_NAND_POWER_DOWN_ENABLE   (1UL<<0)
+#define   NX_NAND_POWER_DOWN_DISABLE  (0UL<<0)
+
+#define NX_NAND_INT_READY_START   (20)
+
+
+#define NX_NAND_INT_OOB_READ      (1<<0)
+#define NX_NAND_INT_OOB_WRITE     (1<<1)
+#define NX_NAND_INT_BLK_READ      (1<<2)
+#define NX_NAND_INT_BLK_WRITE     (1<<3)
+#define NX_NAND_INT_ENC           (1<<4)
+#define NX_NAND_INT_DEC           (1<<5)
+#define NX_NAND_INT_DEC_0_ERR     (1<<6)
+#define NX_NAND_INT_DEC_1_ERR     (1<<7)
+#define NX_NAND_INT_DEC_2_ERR     (1<<8)
+#define NX_NAND_INT_DEC_3_ERR     (1<<9)
+#define NX_NAND_INT_DEC_4_ERR     (1<<10)
+#define NX_NAND_INT_DEC_5_ERR     (1<<11)
+#define NX_NAND_INT_DEC_UNCOR     (1<<12)
+#define NX_NAND_INT_AES_DEC       (1<<13)
+#define NX_NAND_INT_SEQ_READ      (1<<14)
+#define NX_NAND_INT_SEQ_WRITE     (1<<15)
+#define NX_NAND_INT_BUSY1         (1<<16)
+#define NX_NAND_INT_BUSY2         (1<<17)
+#define NX_NAND_INT_BUSY3         (1<<18)
+#define NX_NAND_INT_BUSY4         (1<<19)
+#define NX_NAND_INT_READY1        (1<<20)
+#define NX_NAND_INT_READY2        (1<<21)
+#define NX_NAND_INT_READY3        (1<<22)
+#define NX_NAND_INT_READY4        (1<<23)
+
+/* Position of address */
+#define NX_NAND_SP_ADDR_MASK      (0xFF)
+#define NX_NAND_SP_ADDR_MASK1     (0x03)
+
+#define NX_NAND_SP_ADDR1_POS      (0)
+#define NX_NAND_SP_ADDR2_POS      (9)
+#define NX_NAND_SP_ADDR3_POS      (17)
+#define NX_NAND_SP_ADDR4_POS      (29)
+
+/* Cmd FIFO bit information */
+#define NX_NAND_CMD_FIFO_CE_START  (19)
+#define NX_NAND_CMD_FIFO_ADDR_CYC  (0x0)
+#define NX_NAND_CMD_FIFO_CMD_CYC   (0x1)
+#define NX_NAND_CMD_FIFO_POST_CMD  (0x2)
+
+#endif /* __ARCH_MACH_NX_NAND_DEV_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_sdiomc_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_sdiomc_dev.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_sdiomc_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_sdiomc_dev.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver SD/SDIO/MMC controller IP_3413
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1	Mahadev K Cholachagudda  20090216     Draft-Initial version
+ *
+ */
+
+#ifndef __ARCH_MACH_NX_SDIOMC_DEV_H_
+#define __ARCH_MACH_NX_SDIOMC_DEV_H_
+
+
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+
+#define APOLLO_SDIOMC_BASE_PHYS  (ARM_A9_HOST_MMIO_BASE + 0x35000)
+#define APOLLO_SDIOMC_BASE (APOLLO_SDIOMC_BASE_PHYS)  
+#define APOLLO_SDIOMC_LEN  (0x1000)
+
+#define APOLLO_INT_SDIOMC  ( 156)  /* Fixme, has to come from irqs.h !! */
+
+/*!
+ * This structure is used to store the platform specific SD/SDIO/MMC controller
+ * IP_3413 configuration information, which is later passed onto the Linux
+ * driver for SD/SDIO/MMC controller IP_3413 driver.
+ */
+struct nx_sdiomc_platform_data {
+  unsigned long num_slots;   /*!< This parameter represents number of slots that are configured in SD/SDIO/MMC controller IP_3413 configuration */
+};
+
+#endif /* __ARCH_MACH_NX_SDIOMC_DEV_H_ */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_spi_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_spi_dev.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/nx_spi_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_spi_dev.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: ??
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_NX_SPI_DEV_H_
+#define __ARCH_MACH_NX_SPI_DEV_H_
+
+
+#include <linux/spi/spi.h>
+#include <linux/nx_dmac_1902.h>
+
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+
+/*FIXME:: Move this NX_SPI_BASE_SPI0 to mach/pnx8492.h*/
+#define NX_SPI_BASE_SPI0	(ARM_A9_HOST_MMIO_BASE + 0xE0000)
+#define IRQ_SPI0		IRQ_SPI_COMB
+
+#define NXP_SPI_NUM_CHIPSELECTS	6
+
+struct nx_spi_platform_data
+{
+     struct nx_dmac_1902_slave *slave_tx;
+     struct nx_dmac_1902_slave *slave_rx;
+     struct spi_board_info   *spi_devices;
+     int plfdatasize;
+};
+
+/* SPI */
+struct nx_spi_controller_data
+{
+    u8 tx_int_threshold;
+    u8 rx_int_threshold;
+    u8 dma_tx_burst;
+    u8 dma_rx_burst;
+    u32 spi_ip_clk;
+    u8 txchan_num;
+    u8 rxchan_num;
+};
+
+#endif /* __ARCH_MACH_NX_SPI_DEV_H_ */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pci.h linux-2.6.34/arch/arm/mach-apollo/include/mach/pci.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pci.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/pci.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright (C) 2007 NXP B.V.
+ *
+ * BRIEF MODULE DESCRIPTION
+ * PCI specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8492_PCI_H
+#define __PNX8492_PCI_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <mach/pnx8492.h>
+
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+#define PCI_CMD_IOR			0x20
+#define PCI_CMD_IOW			0x30
+#define PCI_CMD_CONFIG_READ		0xa0
+#define PCI_CMD_CONFIG_WRITE		0xb0
+
+#define PCI_IO_TIMEOUT			1000
+#define PCI_IO_RETRY			5
+/* Timeout for IO and CFG accesses.
+   This is in 1/1024 th of a jiffie(=10ms)
+   i.e. approx 10us */
+#define PCI_IO_JIFFIES_TIMEOUT		40
+#define PCI_IO_JIFFIES_SHIFT		10
+
+#define PCI_BYTE_ENABLE_MASK		0x0000000f
+#define PCI_CFG_BUS_SHIFT		16
+#define PCI_CFG_FUNC_SHIFT		8
+#define PCI_CFG_REG_SHIFT		2
+
+#define PCI_SETUP			(IPA051_PCI_PORT_0 + 0x0010)
+#define PCI_SETUP_DIS_REQGNT		(1<<30)
+#define PCI_SETUP_DIS_REQGNTA		(1<<29)
+#define PCI_SETUP_DIS_REQGNTB		(1<<28)
+#define PCI_SETUP_D2_SUPPORT		(1<<27)
+#define PCI_SETUP_D1_SUPPORT		(1<<26)
+#define PCI_SETUP_EN_TA			(1<<24)
+#define PCI_SETUP_EN_PCI2MMI		(1<<23)
+#define PCI_SETUP_EN_XIO		(1<<22)
+#define PCI_SETUP_BASE18_PREF		(1<<21)
+#define PCI_SETUP_BASE10_SIZE_16M	0x3
+#define PCI_SETUP_BASE10_SIZE_32M	0x4
+#define PCI_SETUP_BASE10_SIZE_64M	0x5
+#define PCI_SETUP_BASE10_SIZE_128M	0x6
+#define PCI_SETUP_BASE10_SIZE_256M	0x7
+#define PCI_SETUP_BASE18_SIZE_16M	0x3
+#define PCI_SETUP_BASE18_SIZE_32M	0x4
+#define PCI_SETUP_BASE18_SIZE_64M	0x5
+#define PCI_SETUP_BASE18_SIZE_128M	0x6
+#define PCI_SETUP_BASE18_SIZE_256M	0x7
+#define PCI_SETUP_BASE18_SIZE(X)	(X<<18)
+#define PCI_SETUP_BASE18_EN		(1<<17)
+#define PCI_SETUP_BASE14_PREF		(1<<16)
+#define PCI_SETUP_BASE14_SIZE(X)	(X<<12)
+#define PCI_SETUP_BASE14_EN		(1<<11)
+#define PCI_SETUP_BASE10_PREF		(1<<10)
+#define PCI_SETUP_BASE10_SIZE_BSHIFT	(7)
+#define PCI_SETUP_BASE10_SIZE(X)	(X<<7)
+#define PCI_SETUP_BASE10_SIZE_MASK	(PCI_SETUP_BASE10_SIZE(7))
+#define PCI_SETUP_CFGMANAGE_EN		(1<<1)
+#define PCI_SETUP_PCIARB_EN		(1<<0)
+
+#define PCI_CTRL			(IPA051_PCI_PORT_0 + 0x0014)
+#define PCI_SWPB_DCS_PCI		(1<<16)
+#define PCI_SWPB_PCI_PCI		(1<<15)
+#define PCI_SWPB_PCI_DCS		(1<<14)
+#define PCI_REG_WR_POST			(1<<13)
+#define PCI_XIO_WR_POST			(1<<12)
+#define PCI_PCI2_WR_POST		(1<<13)
+#define PCI_PCI1_WR_POST		(1<<12)
+#define PCI_SERR_SEEN			(1<<11)
+#define PCI_B10_SPEC_RD			(1<<6)
+#define PCI_B14_SPEC_RD			(1<<5)
+#define PCI_B18_SPEC_RD			(1<<4)
+#define PCI_B10_NOSUBWORD		(1<<3)
+#define PCI_B14_NOSUBWORD		(1<<2)
+#define PCI_B18_NOSUBWORD		(1<<1)
+#define PCI_RETRY_TMREN			(1<<0)
+
+#define PCI_BASE_0_LO			(IPA051_PCI_PORT_0 + 0x0018)
+#define PCI_BASE_0_HI			(IPA051_PCI_PORT_0 + 0x001C)
+#define PCI_BASE_1_LO			(IPA051_PCI_PORT_0 + 0x0020)
+#define PCI_BASE_1_HI			(IPA051_PCI_PORT_0 + 0x0024)
+#define PCI_RDLIFETIM			(IPA051_PCI_PORT_0 + 0x0028)
+#define PCI_GPPM_ADDR			(IPA051_PCI_PORT_0 + 0x002C)
+#define PCI_GPPM_WDAT			(IPA051_PCI_PORT_0 + 0x0030)
+#define PCI_GPPM_RDAT			(IPA051_PCI_PORT_0 + 0x0034)
+#define PCI_GPPM_CTRL			(IPA051_PCI_PORT_0 + 0x0038)
+#define GPPM_DONE			(1<<10)
+#define INIT_PCI_CYCLE			(1<<9)
+#define GPPM_CMD(X)			(((X)&0xf)<<4)
+#define GPPM_BYTEEN(X)			((X)&0xf)
+#define PCI_UNLOCKREG			(IPA051_PCI_PORT_0 + 0x003C)
+#define UNLOCK_SSID(X)			(((X)&0xff)<<8)
+#define UNLOCK_SETUP(X)			(((X)&0xff)<<0)
+#define UNLOCK_MAGIC			0xCA
+#define PCI_DEV_VEND_ID			(IPA051_PCI_PORT_0 + 0x0040)
+#define DEVICE_ID(X)			(((X)>>16)&0xffff)
+#define VENDOR_ID(X)			(((X)&0xffff))
+#define PCI_CFG_CMDSTAT			(IPA051_PCI_PORT_0 + 0x0044)
+#define PCI_CFG_STATUS(X)		(((X)>>16)&0xffff)
+#define PCI_CFG_COMMAND(X)		((X)&0xffff)
+#define PCI_CLASS_REV			(IPA051_PCI_PORT_0 + 0x0048)
+#define PCI_CLASSCODE(X)		(((X)>>8)&0xffffff)
+#define PCI_REVID(X)			((X)&0xff)
+#define PCI_LAT_TMR			(IPA051_PCI_PORT_0 + 0x004c)
+#define PCI_BASE10			(IPA051_PCI_PORT_0 + 0x0050)
+#define PCI_BASE14			(IPA051_PCI_PORT_0 + 0x0054)
+#define PCI_BASE18			(IPA051_PCI_PORT_0 + 0x0058)
+#define PCI_SUBSYS_ID			(IPA051_PCI_PORT_0 + 0x006c)
+#define PCI_CAP_PTR			(IPA051_PCI_PORT_0 + 0x0074)
+#define PCI_CFG_MISC			(IPA051_PCI_PORT_0 + 0x007c)
+#define PCI_PMC				(IPA051_PCI_PORT_0 + 0x0080)
+#define PCI_PWR_STATE			(IPA051_PCI_PORT_0 + 0x0084)
+#define PCI_IO				(IPA051_PCI_PORT_0 + 0x0088)
+#define PCI_SLVTUNING			(IPA051_PCI_PORT_0 + 0x008C)
+#define PCI_DMATUNING			(IPA051_PCI_PORT_0 + 0x0090)
+#define PCI_ADDR_REMAP_ENABLE (IPA051_PCI_PORT_0 + 0x009C)
+#define PCI_DMAEADDR			(IPA051_PCI_PORT_0 + 0x0800)
+#define PCI_DMAIADDR			(IPA051_PCI_PORT_0 + 0x0804)
+#define PCI_DMALEN			(IPA051_PCI_PORT_0 + 0x0808)
+#define PCI_DMACTRL			(IPA051_PCI_PORT_0 + 0x080C)
+#define PCI_XIOCTRL			(IPA051_PCI_PORT_0 + 0x0810)
+#define PCI_SEL0PROF			(IPA051_PCI_PORT_0 + 0x0814)
+#define PCI_SEL1PROF			(IPA051_PCI_PORT_0 + 0x0818)
+#define PCI_SEL2PROF			(IPA051_PCI_PORT_0 + 0x081C)
+#define PCI_GPXIOADDR			(IPA051_PCI_PORT_0 + 0x0820)
+#define PCI_NANDCTRLS			(IPA051_PCI_PORT_0 + 0x0830)
+#define PCI_SEL3PROF			(IPA051_PCI_PORT_0 + 0x0834)
+#define PCI_SEL4PROF			(IPA051_PCI_PORT_0 + 0x0838)
+#define PCI_GPXIO_STAT			(IPA051_PCI_PORT_0 + 0x0FB0)
+#define PCI_GPXIO_IMASK			(IPA051_PCI_PORT_0 + 0x0FB4)
+#define PCI_GPXIO_ICLR			(IPA051_PCI_PORT_0 + 0x0FB8)
+#define PCI_GPXIO_ISET			(IPA051_PCI_PORT_0 + 0x0FBC)
+#define PCI_GPPM_STATUS			(IPA051_PCI_PORT_0 + 0x0FC0)
+#define GPPM_DONE			(1<<10)
+#define GPPM_ERR			(1<<9)
+#define GPPM_MPAR_ERR			(1<<8)
+#define GPPM_PAR_ERR			(1<<7)
+#define GPPM_R_MABORT			(1<<2)
+#define GPPM_R_TABORT			(1<<1)
+#define PCI_GPPM_IMASK			(IPA051_PCI_PORT_0 + 0x0FC4)
+#define PCI_GPPM_ICLR			(IPA051_PCI_PORT_0 + 0x0FC8)
+#define PCI_GPPM_ISET			(IPA051_PCI_PORT_0 + 0x0FCC)
+#define PCI_DMA_STATUS			(IPA051_PCI_PORT_0 + 0x0FD0)
+#define PCI_DMA_IMASK			(IPA051_PCI_PORT_0 + 0x0FD4)
+#define PCI_DMA_ICLR			(IPA051_PCI_PORT_0 + 0x0FD8)
+#define PCI_DMA_ISET			(IPA051_PCI_PORT_0 + 0x0FDC)
+#define PCI_ISTATUS			(IPA051_PCI_PORT_0 + 0x0FE0)
+#define PCI_IMASK			(IPA051_PCI_PORT_0 + 0x0FE4)
+#define PCI_ICLR			(IPA051_PCI_PORT_0 + 0x0FE8)
+#define PCI_ISET			(IPA051_PCI_PORT_0 + 0x0FEC)
+#define PCI_MOD_ID			(IPA051_PCI_PORT_0 + 0x0FFC)
+
+/*
+ *  PCI configuration cycle AD bus definition
+ */
+/* Type 0 */
+#define PCI_CFG_TYPE0_REG_SHF		0
+#define PCI_CFG_TYPE0_FUNC_SHF		8
+
+/* Type 1 */
+#define PCI_CFG_TYPE1_REG_SHF		0
+#define PCI_CFG_TYPE1_FUNC_SHF		8
+#define PCI_CFG_TYPE1_DEV_SHF		11
+#define PCI_CFG_TYPE1_BUS_SHF		16
+
+/*
+ *  Ethernet device DP83816 definition
+ */
+#define DP83816_IRQ_ETHER		66
+
+#define PNX8XXX_SLAVE_DTL_TUNING	*(volatile unsigned long *)(PNX8XXX_XIO_BASE_VIRT + 0x8c)
+
+typedef struct {
+	u16	vendor;
+	u16	device;
+	u32	bar0_base;
+	u32	bar0_sz;
+	u32	bar1_base;
+	u32	bar1_sz;
+	u32	bar2_base;
+	u32	bar2_sz;
+	char*	description;
+	int	enum_done;
+} pci_enumeration_static_t;
+
+#endif /* __PNX8492_PCI_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pm.h linux-2.6.34/arch/arm/mach-apollo/include/mach/pm.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/pm.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_APOLLO_PM_H
+#define __ASM_ARCH_APOLLO_PM_H
+
+
+struct apollo_pm_stdby_ctrlr_ops
+{
+	int (*prepare)(void);
+	int (*enter)(unsigned long);
+	int (*exit)(void);
+	int (*finish)(void);
+	int (*recover)(void);
+};
+struct apollo_pm_gic_dist_save {
+    u32     cpu_ctrl;
+    u32     cpu_primask;
+    u32     cpu_binpoint;
+    u32     cpu_intack;
+    u32     cpu_eoi;
+    u32     cpu_runningpri;
+    u32     cpu_highpri;
+    u32     dist_enable_set[8];
+    u32     dist_enable_clear[8];
+    u32     dist_pending_set[8];
+    u32     dist_softint;
+};
+
+extern int apollo_pm_register(struct apollo_pm_stdby_ctrlr_ops *pOps);
+
+
+#endif /* __ASM_ARCH_APOLLO_PM_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pnx8492.h linux-2.6.34/arch/arm/mach-apollo/include/mach/pnx8492.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/pnx8492.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/pnx8492.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_PNX8492_H
+#define __ARCH_MACH_PNX8492_H
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+
+
+#ifdef CONFIG_EXECUTE_ON_SIMULATOR
+#define APOLLO_CORTEX_FREQ			(100 * 1000 * 1000)
+#define APOLLO_PERIPHERALS_FREQ			(1.84 * APOLLO_CORTEX_FREQ)
+#else
+#ifdef CONFIG_EXECUTE_ON_EMULATOR
+#define APOLLO_CORTEX_FREQ			(500 * 1000 * 1000)
+#define APOLLO_PERIPHERALS_FREQ			(APOLLO_CORTEX_FREQ / 2)
+#else
+#define APOLLO_CORTEX_FREQ			(500 * 1000 * 1000)
+#define APOLLO_PERIPHERALS_FREQ			(APOLLO_CORTEX_FREQ / 2)
+#endif /* CONFIG_EXECUTE_ON_EMULATOR */
+#endif /* CONFIG_EXECUTE_ON_SIMULATOR */
+
+#define MAX_TIMER				2
+#define MAX_PERIOD				699050
+#define TICKS_PER_uSEC				1
+
+/*
+ *  These are u_seconds NOT ticks.
+ */
+#define mSEC_1					1000
+#define mSEC_5					(mSEC_1 * 5)
+#define mSEC_10					(mSEC_1 * 10)
+#define mSEC_25					(mSEC_1 * 25)
+#define SEC_1					(mSEC_1 * 1000)
+
+/* 
+ *  SDRAM
+ */
+#define APOLLO_SDRAM_BASE			0x00000000
+
+/*
+ *  MMIO Devices
+ */
+#define ARM_A9_HOST_MMIO_BASE			0xE0600000
+#define HOST_ARM_MMIO_APERTURE			0x1FFFFF
+
+/*
+ * Device port addresses
+ */
+#define MMIO_GCS_BASE            (ARM_A9_HOST_MMIO_BASE + 0x36000)
+#define MMIO_SATA_BASE           (ARM_A9_HOST_MMIO_BASE + 0x38000)
+
+#define MMIO_RGU_BASE            (ARM_A9_HOST_MMIO_BASE + 0xE6000)
+#define  RST_CONFIG_REG          (MMIO_RGU_BASE + 0x30)
+#define   PCI_HOST_MODE_ENABLED  (((readl(RST_CONFIG_REG)&(1<<23)) &&   \
+                                   !(readl(RST_CONFIG_REG)&(1<<16)))?   \
+                                  true:false)
+
+#define MMIO_CLOCK_BASE          (ARM_A9_HOST_MMIO_BASE + 0xE7000)
+
+#define MMIO_GLB_BASE            (ARM_A9_HOST_MMIO_BASE + 0xEA000)
+#define  ALT_PIN_MUX_REG_0       (MMIO_GLB_BASE + 0x140)
+#define  GLBREG_MISC1            (MMIO_GLB_BASE + 0x500)
+
+
+#ifdef CONFIG_EXECUTE_ON_SIMULATOR
+#define UART1_PORT0_OFFSET			0xE0000	/* Uart 1 -> Console */
+#define UART2_PORT0_OFFSET			0xE1000	/* Uart 2 -> Console */
+#define UART3_PORT0_OFFSET			0xE2000	/* Uart 3 -> Console */
+#define UART4_PORT0_OFFSET			0xE3000	/* Uart 4 -> Console */
+#else
+#define UART1_PORT0_OFFSET			0xE1000
+#define UART2_PORT0_OFFSET			0xE2000
+#define UART3_PORT0_OFFSET			0xE3000
+#define UART4_PORT0_OFFSET			0xE4000
+#endif
+
+#define USB_PORT0_OFFSET			0x6C000
+#define USB_PORT1_OFFSET			0x6D000
+#define USB_PORT2_OFFSET			0x6E000
+
+#define GPIO_PORT0_OFFSET			0x69000
+
+#define PCI_PORT0_OFFSET			0x2F000
+
+/* MMIO device addresses */
+#define MMIO_UART1_BASE				(ARM_A9_HOST_MMIO_BASE + UART1_PORT0_OFFSET)
+#define MMIO_UART2_BASE				(ARM_A9_HOST_MMIO_BASE + UART2_PORT0_OFFSET)
+#define MMIO_UART3_BASE				(ARM_A9_HOST_MMIO_BASE + UART3_PORT0_OFFSET)
+#define MMIO_UART4_BASE				(ARM_A9_HOST_MMIO_BASE + UART4_PORT0_OFFSET)
+
+#define MMIO_USB_PORT0				(ARM_A9_HOST_MMIO_BASE + USB_PORT0_OFFSET)
+#define MMIO_USB_PORT1				(ARM_A9_HOST_MMIO_BASE + USB_PORT1_OFFSET)
+#define MMIO_USB_PORT2				(ARM_A9_HOST_MMIO_BASE + USB_PORT2_OFFSET)
+
+#define MMIO_GPIO_PORT0				(ARM_A9_HOST_MMIO_BASE + GPIO_PORT0_OFFSET)
+
+#define MMIO_PCI_PORT0				(ARM_A9_HOST_MMIO_BASE + PCI_PORT0_OFFSET)
+
+/* DEVICE NAMES TO BE USED */
+#define IP3106_UART_PORT_0			MMIO_UART1_BASE
+#define IP3106_UART_PORT_1			MMIO_UART2_BASE
+#define IP3106_UART_PORT_2			MMIO_UART3_BASE
+#define IP3106_UART_PORT_3			MMIO_UART4_BASE
+
+#define IP9028_USB_PORT_0			MMIO_USB_PORT0
+#define IP9028_USB_PORT_1			MMIO_USB_PORT1
+#define IP9028_USB_PORT_2			MMIO_USB_PORT2
+
+#define IPXXXX_GPIO_PORT_0			MMIO_GPIO_PORT0
+
+#define IPA051_PCI_PORT_0			MMIO_PCI_PORT0
+
+/* GMAC0 Clock Registers */
+#define APOLLO_CLK_GMAC0_AHBCLK     		(MMIO_CLOCK_BASE + 0x03C0)
+#define APOLLO_CLK_GMAC0_PHY_TX     		(MMIO_CLOCK_BASE + 0x03C4)
+#define APOLLO_CLK_GMAC0_PHY_RX     		(MMIO_CLOCK_BASE + 0x03C8)
+#define APOLLO_CLK_GMAC0_RMII       		(MMIO_CLOCK_BASE + 0x03CC)
+#define APOLLO_CLK_GMAC0_TXCLK_OUT  		(MMIO_CLOCK_BASE + 0x03D0)
+
+/* GMAC1 Clock Registers */
+#define APOLLO_CLK_GMAC1_AHBCLK     		(MMIO_CLOCK_BASE + 0x03D4)
+#define APOLLO_CLK_GMAC1_PHY_TX     		(MMIO_CLOCK_BASE + 0x03D8)
+#define APOLLO_CLK_GMAC1_PHY_RX     		(MMIO_CLOCK_BASE + 0x03DC)
+#define APOLLO_CLK_GMAC1_RMII       		(MMIO_CLOCK_BASE + 0x03E0)
+#define APOLLO_CLK_GMAC1_TXCLK_OUT  		(MMIO_CLOCK_BASE + 0x03E4)
+
+/* GPIO registers */
+#define GPIO_0_15_MODE_CTL0			*(volatile unsigned long *)(IPXXXX_GPIO_PORT_0 + 0x000)
+
+/*
+ * Cortex A9 Internal Peripheral IP
+ */
+#define APOLLO_CORTEX_A9_PERIPHBASE		0xE0100000
+#define APOLLO_CORTEX_A9_SCU_OFFSET		0x0000
+#define APOLLO_CORTEX_A9_INTC_OFFSET		0x0100
+#define APOLLO_CORTEX_A9_GLOB_TIMER_OFFSET	0x0200
+#define APOLLO_CORTEX_A9_PRIV_TIMER_OFFSET	0x0600
+#define APOLLO_CORTEX_A9_DISTR_OFFSET		0x1000
+#define APOLLO_CORTEX_A9_L2CACHE_OFFSET		0x2000
+/* device names to be used */
+#define APOLLO_CORTEX_A9_SCU_BASE		(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_SCU_OFFSET)
+#define APOLLO_CORTEX_A9_INTC_BASE		(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_INTC_OFFSET)
+#define APOLLO_CORTEX_A9_GLOB_TIMER_BASE	(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_GLOB_TIMER_OFFSET)
+#define APOLLO_CORTEX_A9_PRIV_TIMER_BASE	(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_PRIV_TIMER_OFFSET)
+#define APOLLO_CORTEX_A9_DISTR_BASE		(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_DISTR_OFFSET)
+#define APOLLO_CORTEX_A9_L2CACHE_BASE		(APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_L2CACHE_OFFSET)
+
+/*
+ * Cortex A9 Registers
+ */
+
+#define APOLLO_SYS_BASE				(0x80000000) /* This is wrong as we do not know what sys-base expects */
+#define APOLLO_RESET_BASE			(ARM_A9_HOST_MMIO_BASE + 0xE6000)
+#define APOLLO_RESET_LOCKCMD_OFFSET		0x28
+#define APOLLO_RESET_LOCKSTAT_OFFSET		0x2c
+#define APOLLO_RESET_SOFTRESET_OFFSET		0x08
+/* device names to be used */
+#define APOLLO_RESET_LOCKCMD			(APOLLO_RESET_BASE + APOLLO_RESET_LOCKCMD_OFFSET)
+#define APOLLO_RESET_LOCKSTAT			(APOLLO_RESET_BASE + APOLLO_RESET_LOCKSTAT_OFFSET)
+#define APOLLO_RESET_SOFTRESET			(APOLLO_RESET_BASE + APOLLO_RESET_SOFTRESET_OFFSET)
+
+/* RTC */
+#define APOLLO_RTC_BASE				(ARM_A9_HOST_MMIO_BASE + 0xbc000)
+
+/*
+ * Tile-specific addresses
+ */
+#define PNX8XXX_CLOCK_BASE			MMIO_CLOCK_BASE	/* clock module */ 
+
+/* ChipID and Revision ID defines */
+#define CHIPID_APOLLO    0x1
+#define CHIPID_SHINER_S  0x2
+#define CHIPID_SHINER_IP 0x3
+#define CHIPID_HELIOS    0x4
+
+#define CHIP_REV_M0 0x1
+
+/*
+ * these spaces are mapped using the following base registers:
+ *
+ * Usage Local Bus Memory         Base/Map registers used
+ *
+ * Mem   50000000 - 5FFFFFFF      LB_BASE0/LB_MAP0,  non prefetch
+ * Mem   60000000 - 6FFFFFFF      LB_BASE1/LB_MAP1,  prefetch
+ * IO    44000000 - 4FFFFFFF      LB_BASE2/LB_MAP2,  IO
+ * Cfg   42000000 - 42FFFFFF	  PCI config
+ *
+ */
+#define APOLLO_PCI_CORE_BASE		IPA051_PCI_PORT_0
+#define APOLLO_SYS_PCICTL		IPA051_PCI_PORT_0
+#define __IO_ADDRESS(n) ((void __iomem *)(unsigned long)IO_ADDRESS(n))
+
+#define SYS_PCICTL			__IO_ADDRESS(APOLLO_SYS_PCICTL)
+#define PCI_IMAP0			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x0)
+#define PCI_IMAP1			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x4)
+#define PCI_IMAP2			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x8)
+#define PCI_SMAP0			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x10)
+#define PCI_SMAP1			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x14)
+#define PCI_SMAP2			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0x18)
+#define PCI_SELFID			__IO_ADDRESS(APOLLO_PCI_CORE_BASE+0xc)
+
+#define DEVICE_ID_OFFSET		0x00
+#define CSR_OFFSET			0x04
+#define CLASS_ID_OFFSET			0x08
+
+#define VP_PCI_DEVICE_ID		0x00000000	/* real value to be gained from real silicon !! */
+#define VP_PCI_CLASS_ID			0x00000000	/* real value to be gained from real silicon !! */
+
+#endif /* __ARCH_MACH_PNX8492_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/scu.h linux-2.6.34/arch/arm/mach-apollo/include/mach/scu.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/scu.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/scu.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASMARM_ARCH_SCU_H
+#define __ASMARM_ARCH_SCU_H
+
+/*
+ * SCU registers
+ */
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+#define SCU_INVALIDATE		0x0c
+#define SCU_FPGA_REVISION	0x10
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/sfc.h linux-2.6.34/arch/arm/mach-apollo/include/mach/sfc.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/sfc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/sfc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for EFMC IP_2070.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 1.0.0		Sundarapandian A		20090720		Updated for APOLLO
+ */
+#ifndef _SFC_H_
+#define _SFC_H_
+
+/* #include <mach/platform.h> */
+#include <mach/irqs.h>
+
+#define APOLLO_SFC_CFG_BASE_PHYS         (ARM_A9_HOST_MMIO_BASE + 0x32000)
+#define APOLLO_SFC_CFG_BASE              (APOLLO_SFC_CFG_BASE_PHYS)  
+#define APOLLO_SFC_CFG_LEN               (0x1000)
+
+#endif /* _SFC_H_ */
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/smp.h linux-2.6.34/arch/arm/mach-apollo/include/mach/smp.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/smp.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/smp.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef ASM_ARM_ARCH_SMP_H
+#define ASM_ARM_ARCH_SMP_H
+
+#include <asm/hardware/gic.h>
+
+
+#define hard_smp_processor_id()				\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void smp_cross_call(const struct cpumask *mask)
+{
+	gic_raise_softirq(mask, 1);
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/splash_logo.h linux-2.6.34/arch/arm/mach-apollo/include/mach/splash_logo.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/splash_logo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/splash_logo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd.
+ *
+ * All prior copyright rights in this work and the accompanying software
+ * products transferred to Trident Microsystems (Far East) Ltd. by written
+ * agreement.  All rights reserved.
+ *
+ *
+ *   name:          splash_logo.c
+ *   version:
+ *   date_modified: Jun 17, 2010
+ *   derived_by:    ddouglass
+ */
+
+#ifndef SPLASH_LOGO_H
+#define SPLASH_LOGO_H
+
+void __init apollo_splash( void );
+
+#endif // SPLASH_LOGO_H
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/system.h linux-2.6.34/arch/arm/mach-apollo/include/mach/system.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/system.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/system.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/pnx8492.h>
+
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	__raw_writel(0xf8, IO_ADDRESS(APOLLO_RESET_LOCKCMD));
+	__raw_writel(0x2b, IO_ADDRESS(APOLLO_RESET_LOCKCMD));
+	__raw_writel(0x1, IO_ADDRESS(APOLLO_RESET_LOCKSTAT));
+	__raw_writel(0x1, IO_ADDRESS(APOLLO_RESET_SOFTRESET));
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/timex.h linux-2.6.34/arch/arm/mach-apollo/include/mach/timex.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/timex.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/timex.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+ 
+#ifndef __ARCH_MACH_TIMEX_H
+#define __ARCH_MACH_TIMEX_H
+
+#define CLOCK_TICK_RATE		1193180
+
+#ifdef CONFIG_EXECUTE_ON_EMULATOR
+#define UART_CLOCK_RATE		(73000/4)
+#else
+#ifdef CONFIG_EXECUTE_ON_SIMULATOR
+#define UART_CLOCK_RATE		(50000000/16)
+#else
+#define UART_CLOCK_RATE		(50000000)
+#endif
+#endif
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/usbudc.h linux-2.6.34/arch/arm/mach-apollo/include/mach/usbudc.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/usbudc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/usbudc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_USBUDC_H
+#define __ASM_ARCH_USBUDC_H
+
+// USB_UDC_CHECK: the USB UDC driver is ported from two code bases. (a) FSL code (b) NOCONA code
+// enable below macro for FSL port, disable below macro for NOCONA port.
+// additionally, update the drivers/usb/gadget/Makefile accodingly.
+
+#ifndef CONFIG_USBCV_TEST	// NO USBCV test, perform USB UDC Normal operation.
+#define	FSL_PORT			// use USB UDC driver ported from FSL codebase
+//#define	NOCONA_PORT		// use USB UDC driver ported from NOCONA codebase
+#else
+#define	CI_PORT			// Perform USBCV tests, use USB UDC driver ported from CI13xxx_udc codebase
+#endif
+
+#endif /* __ASM_ARCH_IRQS_H */
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/vmalloc.h linux-2.6.34/arch/arm/mach-apollo/include/mach/vmalloc.h
--- linux-2.6.34.orig/arch/arm/mach-apollo/include/mach/vmalloc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/vmalloc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+ 
+#ifndef __ARCH_MACH_VMALLOC_H
+#define __ARCH_MACH_VMALLOC_H
+
+#ifdef CONFIG_VMSPLIT_3G
+#ifdef CONFIG_ARCH_SPARSEMEM_ENABLE
+#define VMALLOC_OFFSET		(8*1024*1024)
+/* Hardcoding - real bad. We want the vmalloc space to start from 0xe800 0000 */
+/* for 3g/1G split as we have MMIO till 0xe7ff ffff */
+#define VMALLOC_START		((0xe8000000 + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_END		(PAGE_OFFSET + 0x3d000000)
+#else
+#error "3G/1G memory split is only supported with Sparsemem, pls fix the kernel config"
+#endif
+#else
+#define VMALLOC_END		(PAGE_OFFSET + 0x50000000)
+#endif
+
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/Kconfig linux-2.6.34/arch/arm/mach-apollo/Kconfig
--- linux-2.6.34.orig/arch/arm/mach-apollo/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,142 @@
+menu "Apollo Platform Types"
+	depends on ARCH_APOLLO
+
+config MACH_APOLLO_VPE_A9UP
+	bool "VPE Cortex-A9 Single Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9UP
+	select EXECUTE_WITHOUT_UBOOT
+	select EXECUTE_ON_SIMULATOR
+	help
+	  Enable support for the A9 single (uni) core platform.
+
+config MACH_APOLLO_EMU_A9UP
+	bool "Emulator Cortex-A9 Single Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9UP
+	select EXECUTE_WITHOUT_UBOOT
+	select EXECUTE_ON_EMULATOR
+	help
+	  Enable support for the A9 single (uni) core platform in Veloce Emulator.
+
+config MACH_APOLLO_VPE_A9MP1
+	bool "VPE Cortex-A9 MP1 Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9MP
+	select MACH_APOLLO_A9MP1
+	select EXECUTE_WITHOUT_UBOOT
+	select EXECUTE_ON_SIMULATOR
+	help
+	  Enable support for the Cortex-A9MPCore MP1 platform.
+
+config MACH_APOLLO_EMU_A9MP1
+	bool "Emulator Cortex-A9 MP1 Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9MP
+	select MACH_APOLLO_A9MP1
+	select EXECUTE_WITHOUT_UBOOT
+	select EXECUTE_ON_EMULATOR
+	help
+	  Enable support for the Cortex-A9MPCore MP1 platform in a Veloce Emulator.
+
+# ************************************************ #
+# >> above platforms are supported (Sept. 2009) << #
+# ************************************************ #
+
+config MACH_APOLLO_1SI_A9UP
+	bool "Cortex-A9 Single Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9UP
+	select EXECUTE_ON_SILICON
+	help
+	  Enable support for the A9 single (uni) core platform.
+
+config MACH_APOLLO_1SI_A9MP1
+	bool "Cortex-A9 MP1 Processor"
+	select GENERIC_APOLLO_IP
+	select MACH_APOLLO_A9MP
+	select MACH_APOLLO_A9MP1
+	select EXECUTE_ON_SILICON
+	help
+	  Enable support for the Cortex-A9MPCore MP1 platform.
+
+config APOLLO_SPARSEMEM_ENABLE
+	bool "Apollo Sparsemem Memory Map"
+	default y
+	select ARCH_SPARSEMEM_ENABLE
+	help
+	  As the 2 DDR controllers are not contigous, SPARSEMEM allows us to map our 
+	  Physical RAM effectively in Kernel virtual space.
+
+endmenu
+
+menu "Apollo Platform Options"
+	depends on ARCH_APOLLO
+
+config APOLLO_SPLASH
+     bool "Apollo Splash Screen"
+     select APOLLO_SPLASH_SCREEN
+     help
+        Enable the boot splash screen.
+
+endmenu
+
+source "drivers/dcs_net/Kconfig"
+
+# *************************************************************** #
+# None visible menu options where the platform is dependent upon. #
+# *************************************************************** #
+
+config GENERIC_APOLLO_IP
+	bool
+	select MACH_APOLLO
+	select CPU_V7
+	select CPU_32v7
+	select ARM_GIC
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select IP3106
+	select SERIAL_IP3106_CONSOLE
+	select ARCH_REQUIRE_GPIOLIB
+
+config SOC_PNX8492
+	bool
+	depends on USB_SUPPORT
+	select USB_ARCH_HAS_EHCI
+	select USB_EHCI_HCD
+	select USB_EHCI_IP9028
+	#select PCI
+	select PM
+
+config MACH_APOLLO
+	bool
+
+config MACH_APOLLO_A9UP
+	bool
+
+config MACH_APOLLO_A9MP
+	bool
+	select SMP
+
+config MACH_APOLLO_A9MP1
+	bool
+
+config MACH_APOLLO_A9MP2
+	bool
+
+config MACH_APOLLO_A9MP4
+	bool
+
+config EXECUTE_WITHOUT_UBOOT
+	bool
+
+config EXECUTE_ON_SIMULATOR
+	bool
+
+config EXECUTE_ON_EMULATOR
+	bool
+
+config EXECUTE_ON_SILICON
+	bool
+
+# ********************** EOF ******************************
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/localtimer.c linux-2.6.34/arch/arm/mach-apollo/localtimer.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/localtimer.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/localtimer.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+#include <asm/irq.h>
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+        evt->irq = IRQ_LOCALTIMER;
+        twd_timer_setup(evt);
+}
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/Makefile linux-2.6.34/arch/arm/mach-apollo/Makefile
--- linux-2.6.34.orig/arch/arm/mach-apollo/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,45 @@
+#
+# Copyright 2010 Trident Microsystems (Far East) Ltd. 
+# All prior copyright rights in this work and the accompanying software 
+# products transferred to Trident Microsystems (Far East) Ltd. by written 
+# agreement.  All rights reserved.
+#
+#
+# Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+# Author: OKC <okc.helpdesk@nxp.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+#
+# Object file lists for the linux kernel.
+#
+obj-y					:= pnx8492.o globaltimer.o
+obj-$(CONFIG_MACH_APOLLO)		+= apollo.o
+obj-$(CONFIG_APOLLO_SPLASH)             += splash_logo.o
+obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o localtimer.o
+obj-$(CONFIG_PCI)			+= pci.o
+obj-$(CONFIG_PM)			+= pm.o sleep.o
+obj-$(CONFIG_HOTPLUG_CPU) 		+= hotplug.o
+obj-$(CONFIG_LIPP_6300ETH)		+= ethernet.o
+obj-$(CONFIG_NX_DMAC_1902)		+= nx_dmac_1902_dev.o
+obj-$(CONFIG_MMC_SDHCI_NX_SDIOMC)	+= nx_sdiomc_dev.o
+obj-$(CONFIG_SPI)			+= nx_spi_dev.o
+obj-$(CONFIG_GPIO_APOLLO)		+= gpio.o
+obj-$(CONFIG_MTD_NX_NAND)               += nand.o gcs_dmac.o gcs.o
+obj-$(CONFIG_MTD_APOLLO_NOR)            += nor.o gcs_dmac.o gcs.o
+obj-$(CONFIG_MTD_NX_SFC)                += sfc.o gcs_dmac.o gcs.o
+obj-$(CONFIG_SATA_APOLLO) 		+= sata.o
+obj-$(CONFIG_RTC_DRV_APOLLO)		+= rtc.o
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/nand.c linux-2.6.34/arch/arm/mach-apollo/nand.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/nand.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/nand.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <mach/nand.h>
+#include <linux/io.h>
+ 
+static struct resource apollo_ip2017_resources[] = {
+	{
+		.start		= APOLLO_IP2017_BASE,
+		.end		= (APOLLO_IP2017_BASE + APOLLO_IP2017_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= APOLLO_INT_FLASH_CTRL_NAND,
+		.end		= APOLLO_INT_FLASH_CTRL_NAND,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static uint64_t apollo_2017_dma_mask = ~(uint32_t)0;
+static struct platform_device apollo_ip2017_device = {
+	.name		= "nx_2017",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(apollo_ip2017_resources),
+	.resource	= apollo_ip2017_resources,
+	.dev = {
+		.dma_mask = &apollo_2017_dma_mask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+};
+
+static int __init apollo_nand_init(void)
+{
+#if 1
+	/**
+	 * FIXME: This configuration must come from bootloader
+	 **/
+	void * __iomem base = ioremap(apollo_ip2017_resources[0].start,
+			APOLLO_IP2017_LEN);
+	if (base == NULL) {
+		printk(KERN_ERR "NAND_DEVICE: out of memory?!\n");
+		return -ENOMEM;
+	}
+	writel(0x014, base + 0x04C);
+#ifdef CONFIG_EXECUTE_ON_EMULATOR
+	writel(0x02644448, base + 0x050); /* Set timings */
+	writel(0x00108444, base + 0x054);
+#endif
+
+   if (PCI_HOST_MODE_ENABLED)
+      writel(0x3FE, base + 0x010);
+   else
+      writel(0x3F, base + 0x010);
+
+	iounmap(base);
+#endif /* FIXME: Remove it once the bootloader is updated */
+	return platform_device_register (&apollo_ip2017_device);
+}
+arch_initcall(apollo_nand_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/nor.c linux-2.6.34/arch/arm/mach-apollo/nor.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/nor.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/nor.c	2010-09-07 23:01:11.000000000 -0500
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <mach/nor.h>
+#include <linux/io.h>
+#include <mach/gcs_dmac.h>
+ 
+static struct resource apollo_ip2016_resources[] = {
+    {
+        .start      = APOLLO_IP2016_BASE,
+        .end        = (APOLLO_IP2016_BASE + APOLLO_IP2016_LEN - 1),
+        .flags      = IORESOURCE_MEM,
+    },
+    {
+        .start		= APOLLO_NOR_BASE,
+        .end		= (APOLLO_NOR_BASE + APOLLO_NOR_LEN -1),
+        .flags		= IORESOURCE_MEM,
+    },
+    {
+        .start		= APOLLO_GCS_DMAC_BASE,
+        .end		= (APOLLO_GCS_DMAC_BASE + APOLLO_GCS_DMAC_LEN - 1),
+        .flags		= IORESOURCE_MEM,
+    },
+};
+
+/*
+ * Apolo NOR Configuration.
+ */
+static struct physmap_flash_data nx_nor_data = {
+    .width      = 2,
+};
+
+static uint64_t apollo_2016_dma_mask = ~(uint32_t)0;
+static struct platform_device apollo_ip2016_device = {
+    .name           = "nx_2016",
+    .id             = -1,
+    .num_resources  = ARRAY_SIZE(apollo_ip2016_resources),
+    .resource       = apollo_ip2016_resources,
+    .dev            = {
+                       .platform_data  = &nx_nor_data,
+                       .dma_mask = &apollo_2016_dma_mask,
+                       .coherent_dma_mask = 0xFFFFFFFF,
+                      },
+};
+
+static int __init apollo_nor_init(void)
+{
+    void __iomem *base=NULL;
+
+    /**
+     * FIXME: This configuration must come from bootloader
+     */
+    base = (void*)apollo_ip2016_resources[0].start;
+
+    /* IP_2016 Settings */
+    /* setup IP_2016 */
+    writel(0x01, base + 0x000);         /* width=16-bit for AM29LV641DL90**, async mode */
+    
+    writel(0x00022495, base + 0x004);   /* read-timing register. Keep it maximum */
+    writel(0x00022495, base + 0x008);   /* write-timing register. Keep it maximum */
+   
+    return platform_device_register (&apollo_ip2016_device);
+ }
+
+arch_initcall(apollo_nor_init);
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/nx_dmac_1902_dev.c linux-2.6.34/arch/arm/mach-apollo/nx_dmac_1902_dev.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/nx_dmac_1902_dev.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/nx_dmac_1902_dev.c	2010-09-07 22:54:05.000000000 -0500
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver for DMA Controller IP_1902
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090528     Draft-Initial version
+ *
+ */
+
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <mach/nx_dmac_1902_dev.h>
+
+static struct resource dmac_1902_acp_resources[] = {
+	[0] = {
+		.start		= APOLLO_DMAC_1902_ACP_BASE,
+		.end		= (APOLLO_DMAC_1902_ACP_BASE + APOLLO_DMAC_1902_ACP_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= APOLLO_INT_DMAC_1902_ACP,
+		.end		= APOLLO_INT_DMAC_1902_ACP,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+u64 dmac_1902_acp_dmamask = ~(u32)0;
+struct platform_device dmac_1902_acp_device = {
+	.name		= "nx_dmac_1902",
+	.id		= 1,
+	.dev = {
+		.dma_mask = &dmac_1902_acp_dmamask,
+	},
+	.num_resources	= ARRAY_SIZE(dmac_1902_acp_resources),
+	.resource	= dmac_1902_acp_resources,
+};
+
+EXPORT_SYMBOL(dmac_1902_acp_device);
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+static struct resource dmac_1902_uart_spi_resources[] = {
+	[0] = {
+		.start		= APOLLO_DMAC_1902_UART_SPI_BASE,
+		.end		= (APOLLO_DMAC_1902_UART_SPI_BASE + APOLLO_DMAC_1902_UART_SPI_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= APOLLO_INT_DMAC_1902_UART_SPI,
+		.end		= APOLLO_INT_DMAC_1902_UART_SPI,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+u64 dmac_1902_uart_spi_dmamask = ~(u32)0;
+struct platform_device dmac_1902_uart_spi_device = {
+	.name		= "nx_dmac_1902",
+	.id		= 2,
+	.dev = {
+		.dma_mask = &dmac_1902_uart_spi_dmamask,
+	},
+	.num_resources	= ARRAY_SIZE(dmac_1902_uart_spi_resources),
+	.resource	= dmac_1902_uart_spi_resources,
+};
+#endif
+
+static struct platform_device *apollo_dmac_1902_platform_devs[] __initdata = {
+	&dmac_1902_acp_device,
+#ifdef CONFIG_SPI_NX_DMAC_1902
+	&dmac_1902_uart_spi_device
+#endif
+};
+
+static int __init apollo_dmac_1902_init(void)
+{
+	return platform_add_devices(apollo_dmac_1902_platform_devs, ARRAY_SIZE(apollo_dmac_1902_platform_devs));
+}
+
+arch_initcall(apollo_dmac_1902_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/nx_sdiomc_dev.c linux-2.6.34/arch/arm/mach-apollo/nx_sdiomc_dev.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/nx_sdiomc_dev.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/nx_sdiomc_dev.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Device driver SD/SDIO/MMC controller IP_3413
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090216     Draft-Initial version
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <mach/nx_sdiomc_dev.h>
+#include <mach/gcs.h>
+
+static struct resource apollo_sdiomc_resources[] = {
+	[0] = {
+		.start		= APOLLO_SDIOMC_BASE,
+		.end		  = (APOLLO_SDIOMC_BASE + APOLLO_SDIOMC_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= APOLLO_INT_SDIOMC,
+		.end		  = APOLLO_INT_SDIOMC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+u64 apollo_sdiomc_dmamask = ~(u32)0;
+static struct nx_sdiomc_platform_data apollo_sdiomc_data = {
+  .num_slots = 1,
+};
+
+static struct platform_device apollo_sdiomc_device = {
+	.name		= "nx_sdiomc",
+	.id		= 0,
+  .dev = {
+    .dma_mask = &apollo_sdiomc_dmamask,
+    .platform_data = &apollo_sdiomc_data,
+  },
+	.num_resources = ARRAY_SIZE(apollo_sdiomc_resources),
+	.resource	= apollo_sdiomc_resources,
+};
+
+static struct platform_device *apollo_sdiomc_platform_devs[] __initdata = {
+	&apollo_sdiomc_device,
+};
+
+static void __init apollo_sdiomc_pin_mux_init(void)
+{
+   unsigned int val;
+
+   /* Determine the pin mux setting based on Kernel Config options */
+
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_ON_IO_BUS
+   /* Setup the GCS */
+   val = APOLLO_GCS_MODE_SDIO_FORCE;
+   writel(val, APOLLO_GCS_MODE_REG);
+
+   /* Setup the Alt Reg 0 for SDIO pin mux */
+   val = readl(0xE06EA140);
+   val |= 0x00000004;
+   writel(val, 0xE06EA140);
+
+   /* Setup the SDIO CS to external */
+   val = 0x1;
+   writel( val, APOLLO_GCS_SDIO_CS_ROUTE);
+
+   /* Setup the SDIO clock source */
+   val = APOLLO_GCS_CLOCK_MUX_EN;
+   writel( val, APOLLO_GCS_SDIO_CLOCK_MUX);
+
+#else
+   /* Setup the GCS */
+   val = APOLLO_GCS_MODE_SDIO_MUX;
+   writel(val, APOLLO_GCS_MODE_REG);
+
+   /* Setup the Alt Reg 0 for SDIO pin mux */
+   val = readl(0xE06EA140);
+   val |= 0x00000020;
+   writel(val, 0xE06EA140);
+
+   /* Setup the GPIO PIN MUX 5 for SDIO */
+   /* Clear rgmii1 - txer, txen, txd3, txd2, txd1, txd0, txck, rxer, rxdv*/
+   val = readl(0xE06EA114);
+   val &= ~0x00790036;
+   writel(val, 0xE06EA114);
+#endif
+
+   /* Setup the Alt Reg 1 for SDIO Card Detect */
+   val = readl(0xE06EA144);
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_CRDETECT_ON_SGPIO3
+   val |= 0x08000000;
+#else
+   val &= ~0x08000000;
+#endif
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_CRLED_ON_SGPIO4
+   val |= 0x10000000;
+#else
+   val &= ~0x10000000;
+#endif
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_CRDWP_ON_SGPIO5
+   val |= 0x20000000;
+#else
+   val &= ~0x20000000;
+#endif
+   writel(val, 0xE06EA144);
+
+}
+
+static int __init apollo_sdiomc_init(void)
+{
+   /* Initialize the pin mux */
+   apollo_sdiomc_pin_mux_init();
+
+   return platform_add_devices(apollo_sdiomc_platform_devs, ARRAY_SIZE(apollo_sdiomc_platform_devs));
+}
+
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC
+arch_initcall(apollo_sdiomc_init);
+#endif
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/nx_spi_dev.c linux-2.6.34/arch/arm/mach-apollo/nx_spi_dev.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/nx_spi_dev.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/nx_spi_dev.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author: Sangeeta Mutgi <sangeeta.mutgi@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <mach/nx_spi_dev.h>
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+#include <linux/nx_dmac_1902.h>
+#endif
+
+
+/* SPI DMA slave related data */
+#ifdef CONFIG_SPI_NX_DMAC_1902
+extern struct platform_device dmac_1902_uart_spi_device;
+
+static struct  nx_dmac_1902_slave nx_spi_dmac_slv_plfdata[] = {
+ { /* TX peripheral */
+       .slave = {
+                .dma_dev = &dmac_1902_uart_spi_device.dev,
+                },
+       .src_per_num = 0, //Memory
+       .dst_per_num = 1, //TX request peripheral num
+       .src_burst = nx_dmac_1902_burst_1,
+       .dst_burst = nx_dmac_1902_burst_1,
+       .src_incr  = 1, //mem
+       .dst_incr  = 0, //Fifo
+       .flow_cntrl = nx_dmac_1902_fcntl_DMA_M_to_P,
+       .src_select = nx_dmac_1902_ahb_master_1,
+       .dst_select = nx_dmac_1902_ahb_master_2,
+       .src_width = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width = DMA_SLAVE_WIDTH_8BIT,
+  },
+  {/* RX peripheral */
+       .slave = {
+                .dma_dev = &dmac_1902_uart_spi_device.dev,
+                },
+       .src_per_num = 0,//RX request peripheral num
+       .dst_per_num = 0, //Memory
+       .src_burst = nx_dmac_1902_burst_1,
+       .dst_burst = nx_dmac_1902_burst_1,
+       .src_incr  = 0, //fifo
+       .dst_incr  = 1, //mem
+       .flow_cntrl = nx_dmac_1902_fcntl_DMA_P_to_M,
+       .src_select = nx_dmac_1902_ahb_master_2,
+       .dst_select = nx_dmac_1902_ahb_master_1,
+       .src_width = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width = DMA_SLAVE_WIDTH_8BIT,
+   }
+
+ /* Add more for other SPI units */
+};
+
+#endif
+
+static struct spi_board_info nx_spi_devices_platformdata[] = {
+{/* device info on Apollo board*/
+	.modalias   = "spidev",
+	.chip_select    = 0,
+	.max_speed_hz   = 100000,
+	.bus_num    = 0,
+	.mode = SPI_3WIRE,
+	},
+	/* Fill more devices if any*/
+};
+/* to indicate if this spi is DMA capable. prgm 0 if no-DMA*/
+static u64 spi_dmamask = ~(uint32_t)0;
+
+static struct resource spi_resources[] = {
+	[0] = {
+	.start  = NX_SPI_BASE_SPI0,
+	.end    = NX_SPI_BASE_SPI0 + SZ_4K - 1,
+	.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+	.start  = IRQ_SPI0,
+	.end    = IRQ_SPI0,
+	.flags  = IORESOURCE_IRQ,
+	},
+	/* Add if more SPI units*/
+};
+
+/* SPI Controller specific data*/
+static struct nx_spi_controller_data nx_spictrldata = {
+	.tx_int_threshold = 4,
+	.rx_int_threshold = 1,
+	.dma_tx_burst = 4,
+	.dma_rx_burst = 4,
+	.spi_ip_clk = 50000000,
+	.txchan_num = 0,
+	.rxchan_num = 1,
+};
+
+
+/* Enacapsulate both "spi_board_info" & "nx_dmac_1902_slave" here*/
+static struct nx_spi_platform_data nx_spi_platformdata[] = {
+	{ /* for a SPI unit*/
+#ifdef CONFIG_SPI_NX_DMAC_1902
+	.slave_tx = &nx_spi_dmac_slv_plfdata[0],
+	.slave_rx = &nx_spi_dmac_slv_plfdata[1],
+#else
+	.slave_tx = 0,
+	.slave_rx = 0,
+#endif
+	.spi_devices = nx_spi_devices_platformdata,
+	.plfdatasize = sizeof(nx_spi_devices_platformdata)/sizeof(nx_spi_devices_platformdata[0]),
+	},
+	/*add more for other SPI units*/
+};
+
+static struct platform_device nx_spi_device = {
+	.name       = "nx_spi",
+	.id     = 0, //bus_num
+	.dev        = {
+		.dma_mask       = &spi_dmamask,
+		.coherent_dma_mask  = ~0UL,
+		.platform_data = &nx_spi_platformdata[0],
+	},
+	.resource   = spi_resources,
+	.num_resources  = ARRAY_SIZE(spi_resources),
+};
+
+static struct platform_device* apollo_spi_platform_devs[] __initdata = {
+ &nx_spi_device
+};
+
+static int __init apollo_spi_init(void)
+{
+	dev_set_drvdata(&nx_spi_device.dev,&nx_spictrldata);
+	return platform_add_devices(apollo_spi_platform_devs, ARRAY_SIZE(apollo_spi_platform_devs));
+
+}
+arch_initcall(apollo_spi_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/pci.c linux-2.6.34/arch/arm/mach-apollo/pci.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/pci.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/pci.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,530 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <mach/pnx8492.h>
+#include <mach/memory.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/pci.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+static inline void clear_status(void)
+{
+   unsigned long pci_stat;
+
+   pci_stat = __raw_readl(PCI_GPPM_STATUS);
+   __raw_writel(pci_stat, PCI_GPPM_ICLR);
+}
+
+static inline unsigned int
+calc_cfg_addr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+   unsigned int addr;
+
+   addr = ((bus->number > 0) ? (((bus->number & 0xff) << PCI_CFG_BUS_SHIFT) | 1) : 0);
+   addr |= ((devfn & 0xff) << PCI_CFG_FUNC_SHIFT) | (where & 0xfc);
+
+   return addr;
+}
+
+static int
+config_access(unsigned int pci_cmd, struct pci_bus *bus, unsigned int devfn, 
+int where, unsigned int pci_mode, unsigned int *val)
+{
+   unsigned long ioaddr = calc_cfg_addr(bus, devfn, where);
+   long loops = 0;
+
+   /* Clear pending interrupt status */
+   if (__raw_readl(PCI_GPPM_STATUS)) {
+      clear_status();
+      while (!(__raw_readl(PCI_GPPM_STATUS) == 0)) ;
+   }
+
+   __raw_writel(ioaddr, PCI_GPPM_ADDR);
+
+   if ((pci_cmd == PCI_CMD_IOW) || (pci_cmd == PCI_CMD_CONFIG_WRITE))
+      __raw_writel(*val, PCI_GPPM_WDAT);
+
+   __raw_writel(INIT_PCI_CYCLE | pci_cmd | (pci_mode & PCI_BYTE_ENABLE_MASK),
+        PCI_GPPM_CTRL);
+
+   loops =
+       ((loops_per_jiffy *
+         PCI_IO_JIFFIES_TIMEOUT) >> (PCI_IO_JIFFIES_SHIFT));
+   while (1) {
+      if (__raw_readl(PCI_GPPM_STATUS) & GPPM_DONE) {
+         if ((pci_cmd == PCI_CMD_IOR) ||(pci_cmd == PCI_CMD_CONFIG_READ))
+            *val = __raw_readl(PCI_GPPM_RDAT);
+         clear_status();
+         return PCIBIOS_SUCCESSFUL;
+      } else if (__raw_readl(PCI_GPPM_STATUS) & GPPM_R_MABORT) {
+         break;
+      } else if (__raw_readl(PCI_GPPM_STATUS) & GPPM_R_TABORT) {
+         printk(KERN_ERR "PCI: %s: GPPM Target Abort (sta=0x%x, cmd=0x%x, addr=0x%lx).\n", 
+            __FUNCTION__, __raw_readl(PCI_GPPM_STATUS), pci_cmd, ioaddr);
+         break;
+      } else if  (__raw_readl(PCI_GPPM_STATUS) & GPPM_ERR) {
+         printk(KERN_ERR "PCI: %s: GPPM Error (sta=0x%x, cmd=0x%x, addr=0x%lx).\n", 
+            __FUNCTION__, __raw_readl(PCI_GPPM_STATUS), pci_cmd, ioaddr);
+         break;
+      }
+
+      loops--;
+      if (loops == 0) {
+         printk(KERN_ERR "PCI: %s: Arbiter Locked (sta=0x%x, cmd=0x%x, addr=0x%lx).\n", 
+            __FUNCTION__, __raw_readl(PCI_GPPM_STATUS), pci_cmd, ioaddr);
+         BUG();
+     }
+   }
+
+   clear_status();
+   if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_IOW)) {
+      printk(KERN_ERR "PCI: %s timeout (GPPM_CTRL=%X) ioaddr %X pci_cmd %X\n",
+            __FUNCTION__, __raw_readl(PCI_GPPM_CTRL), (int) ioaddr, pci_cmd);
+   }
+
+   if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_CONFIG_READ))
+      *val = 0xffffffff;
+
+   return PCIBIOS_DEVICE_NOT_FOUND;
+}
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int
+read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 * val)
+{
+   unsigned int data = 0;
+   int err;
+
+   if (bus == 0)
+      return -1;
+
+   err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(1 << (where & 3)), &data);
+   switch (where & 0x03) {
+   case 0:
+      *val = (unsigned char)(data & 0x000000ff);
+      break;
+   case 1:
+      *val = (unsigned char)((data & 0x0000ff00) >> 8);
+      break;
+   case 2:
+      *val = (unsigned char)((data & 0x00ff0000) >> 16);
+      break;
+   case 3:
+      *val = (unsigned char)((data & 0xff000000) >> 24);
+      break;
+   }
+
+   return err;
+}
+
+static int
+read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 * val)
+{
+   unsigned int data = 0;
+   int err;
+
+   if (bus == 0)
+      return -1;
+
+   if (where & 0x01)
+      return PCIBIOS_BAD_REGISTER_NUMBER;
+
+   err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(3 << (where & 3)), &data);
+   switch (where & 0x02) {
+   case 0:
+      *val = (unsigned short)(data & 0x0000ffff);
+      break;
+   case 2:
+      *val = (unsigned short)((data & 0xffff0000) >> 16);
+      break;
+   }
+
+   return err;
+}
+
+static int
+read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 *val)
+{
+   int err;
+   if (bus == 0)
+      return -1;
+
+   if (where & 0x03)
+      return PCIBIOS_BAD_REGISTER_NUMBER;
+
+   err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, 0, val);
+
+   return err;
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 val)
+{
+   unsigned int data = (unsigned int)val;
+   int err = -1;
+
+   if (bus == 0)
+      return -1;
+
+   switch (where & 0x03) {
+   case 1:
+      data = (data << 8);
+      break;
+   case 2:
+      data = (data << 16);
+      break;
+   case 3:
+      data = (data << 24);
+      break;
+   default:
+      break;
+   }
+
+   err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, ~(1 << (where & 3)), &data);
+
+   return err;
+}
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 val)
+{
+   unsigned int data = (unsigned int)val;
+   int err;
+
+   if (bus == 0)
+      return -1;
+
+   if (where & 0x01)
+      return PCIBIOS_BAD_REGISTER_NUMBER;
+
+   switch (where & 0x02) {
+   case 2:
+      data = (data << 16);
+      break;
+   default:
+      break;
+   }
+   err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, ~(3 << (where & 3)), &data);
+
+   return err;
+}
+
+static int
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
+{
+   int err;
+   if (bus == 0)
+      return -1;
+
+   if (where & 0x03)
+      return PCIBIOS_BAD_REGISTER_NUMBER;
+
+   err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, 0, &val);
+
+   return err;
+}
+
+static int config_read(struct pci_bus *bus, unsigned int devfn, int where, 
+int size, u32 * val)
+{
+   switch (size) {
+   case 1: {
+         u8 uninitialized_var(_val);
+         int rc = read_config_byte(bus, devfn, where, &_val);
+         *val = _val;
+         return rc;
+      }
+       case 2: {
+         u16 uninitialized_var(_val);
+         int rc = read_config_word(bus, devfn, where, &_val);
+         *val = _val;
+         return rc;
+      }
+   default:
+      return read_config_dword(bus, devfn, where, val);
+   }
+}
+
+static int config_write(struct pci_bus *bus, unsigned int devfn, int where, 
+int size, u32 val)
+{
+   int rc = 0;
+   switch (size) {
+   case 1:
+      rc = write_config_byte(bus, devfn, where, (u8) val);
+      break;
+   case 2:
+      rc = write_config_word(bus, devfn, where, (u16) val);
+      break;
+   default:
+      rc = write_config_dword(bus, devfn, where, val);
+      break;
+   }
+   return rc;
+}
+
+static struct pci_ops apollo_pci_ops = {
+   .read    = config_read,
+   .write   = config_write,
+};
+
+static struct resource pci_mem = {
+   .name    = "PCI memory space",
+   .start   = APOLLO_PCI_MEM_BASE_0,
+   .end     = APOLLO_PCI_MEM_BASE_0 + APOLLO_PCI_MEM_BASE_0_SIZE - 1,
+   .flags   = IORESOURCE_MEM,
+};
+
+static struct resource pci_io = {
+   .name    = "PCI I/O space",
+   .start   = APOLLO_PCI_MEM_BASE_1,
+   .end     = APOLLO_PCI_MEM_BASE_1 + APOLLO_PCI_MEM_BASE_1_SIZE - 1,
+   .flags   = IORESOURCE_IO,
+};
+
+static int __init apollo_pci_setup_resources(struct resource **resource)
+{
+   int ret = 0;
+   u32 io_len;
+   void * __iomem io_base;
+
+   ret = request_resource(&iomem_resource, &pci_mem);
+   if (ret) {
+      printk(KERN_ERR "PCI: unable to allocate "
+             "memory region (%d)\n", ret);
+      goto out;
+   }
+   ret = request_resource(&ioport_resource, &pci_io);
+   if (ret) {
+      printk(KERN_ERR "PCI: unable to allocate "
+             "IO region (%d)\n", ret);
+      goto release_pci_mem;
+   }
+
+   io_len = pci_io.end - pci_io.start + 1;
+   io_base = ioremap(pci_io.start, io_len);
+   if (io_base == NULL) {
+      printk(KERN_ERR "PCI: unable to ioremap "
+            "IO region (%d)\n", ret);
+      goto release_pci_io;
+   }
+   
+   pci_io.start = (resource_size_t) io_base;
+   pci_io.end = (resource_size_t) (io_base + io_len - 1);
+   
+   printk("PCI: Mapped I/O : 0x%08X & Memory : 0x%08X resources.\n",\
+      pci_io.start, pci_mem.start);
+
+   /*
+    * bus->resource[0] is the mem resource for this bus
+    * bus->resource[1] is the I/O resource for this bus
+    */
+   resource[0] = &pci_mem;
+   resource[1] = &pci_io;
+   resource[2] = NULL;
+
+   goto out;
+
+release_pci_io:
+   release_resource(&pci_io);
+release_pci_mem:
+   release_resource(&pci_mem);
+out:
+   return ret;
+}
+
+int __init apollo_pci_setup(int nr, struct pci_sys_data *sys)
+{
+   int ret =  0;
+
+   if (nr == 0) 
+   {
+      sys->mem_offset = 0;
+      ret = apollo_pci_setup_resources(sys->resource);
+      if (ret < 0) 
+      {
+         printk("apollo_pci_setup: resources... oops?\n");
+         goto out;
+      }
+   } 
+   else 
+   {
+      printk("apollo_pci_setup: resources... nr == 0??\n");
+      goto out;
+   }
+
+   /*
+    *  We need to discover the PCI core first to configure itself
+    *  before the main PCI probing is performed
+    */
+   printk("PCI core found: dev-id:0x%X vendor-id:0x%X \n",\
+      (__raw_readl(APOLLO_PCI_CORE_BASE + 0x40)>>16)&0xFFFF,\
+      __raw_readl(APOLLO_PCI_CORE_BASE + 0x40)&0xFFFF);
+
+   ret = 1;
+
+ out:
+   return ret;
+}
+
+struct pci_bus *apollo_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+   return pci_scan_bus(sys->busnr, &apollo_pci_ops, sys);
+}
+
+void __init apollo_pci_preinit(void)
+{
+   u32 val;
+
+   /* Bring PCI out of reset (APOLLO PRCR 902 - M1 ECO) */
+   val = __raw_readl(GLBREG_MISC1);
+   val |= (1<<31);
+   __raw_writel(val, GLBREG_MISC1);
+
+   /* Enable PCI mode in RGU */
+   val = __raw_readl(RST_CONFIG_REG);        /* Chip Config register */
+   val = val & 0xFFFEFFFF;                   /* Set PCI mode         */
+   val = val | 0x00800000;                   /* Set Host bridge mode */
+   __raw_writel(val, RST_CONFIG_REG);
+
+   /* Driving alt30_pcirgc2 and alt29_pcirg1. */
+   val = __raw_readl(ALT_PIN_MUX_REG_0);
+   val |= 0x60002000;
+   __raw_writel(val, ALT_PIN_MUX_REG_0);
+
+   /* Unlock PCI setup register */
+   __raw_writel(0xCA, PCI_UNLOCKREG);
+
+   /* Configure PCI setup register */
+   __raw_writel(0x0CCF7F83, PCI_SETUP);
+   
+   /* Configure PCI control register */
+   /* __raw_writel(0x000e3245, PCI_CTRL); */
+   val = __raw_readl(PCI_CTRL);
+   /* Enable internal system arbiter to park on itself */
+   val |= 1<<17;
+   __raw_writel(val, PCI_CTRL);
+   
+   /* Configure cache line size (in dwords) */
+   val = __raw_readl(PCI_LAT_TMR);
+   val &= ~0xFF;
+   val |= (L1_CACHE_BYTES>>2); /*8 dwords*/
+   __raw_writel(val, PCI_LAT_TMR);
+
+   /* Configure PCI slave DTL tuning */
+   val = __raw_readl(PCI_SLVTUNING);
+   val &= ~0x7;
+   val |= 0x7; 
+   __raw_writel(val, PCI_SLVTUNING);
+
+   /* Enable all GPPM interrupts */
+   __raw_writel(0xFFFFFFFF, PCI_GPPM_IMASK);
+
+   /* Clear all GPPM interrupts */
+   __raw_writel(0xFFFFFFFF, PCI_GPPM_ICLR);
+
+   /* Configure PCI base1 Lo register */
+   __raw_writel(APOLLO_PCI_MEM_BASE_0_LO, PCI_BASE_0_LO);
+
+   /* Configure PCI base1 Hi register */
+   __raw_writel(APOLLO_PCI_MEM_BASE_0_HI, PCI_BASE_0_HI);
+
+   /* Configure PCI base2 Lo register */
+   __raw_writel(APOLLO_PCI_MEM_BASE_1_LO, PCI_BASE_1_LO);
+
+   /* Configure PCI base2 Hi register */
+   __raw_writel(APOLLO_PCI_MEM_BASE_1_HI, PCI_BASE_1_HI);
+
+   /* Send PCI_BASE2 as memory transactions */
+   __raw_writel(0x00000001, PCI_IO);
+
+   /* Configure PCI base address 10 register */
+   __raw_writel(0x20000000, PCI_BASE10);
+
+   /* Configure PCI base address 14 register */
+   __raw_writel(0x00000000, PCI_BASE14);
+
+   /* Enables remapping of base 10 and base 14 */
+   __raw_writel(0x0, PCI_ADDR_REMAP_ENABLE);
+
+   __raw_writel(0x0, PCI_SUBSYS_ID);
+
+   /* Write CMD reg to enable Master and Memory Space */
+   val = __raw_readl(PCI_CFG_CMDSTAT);
+   val = val | 0x6;
+   __raw_writel(val, PCI_CFG_CMDSTAT);
+}
+
+/*
+ * map the specified device/slot/pin to an IRQ. Different backplanes may need to modify this.
+ */
+static int __init apollo_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+   int irq;
+   int devslot = PCI_SLOT(dev->devfn);
+
+   irq = IRQ_PCI_IN;
+
+   printk("PCI: map irq: slot %d, pin %d, devslot %d, irq: %d\n",
+      slot,pin,devslot,irq);
+
+   return irq;
+}
+
+static struct hw_pci apollo_pci __initdata = {
+   .swizzle          = NULL,
+   .map_irq          = apollo_map_irq,
+   .nr_controllers   = 1,
+   .setup            = apollo_pci_setup,
+   .scan             = apollo_pci_scan_bus,
+   .preinit          = apollo_pci_preinit,
+};
+
+static int __init apollo_pci_init(void)
+{
+   if (PCI_HOST_MODE_ENABLED)
+      pci_common_init(&apollo_pci);
+
+   return 0;
+}
+
+subsys_initcall(apollo_pci_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/platsmp.c linux-2.6.34/arch/arm/mach-apollo/platsmp.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/platsmp.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/platsmp.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <asm/mach-types.h>
+#include <asm/localtimer.h>
+#include <asm/unified.h>
+#include <asm/smp_scu.h>
+
+#include <mach/hardware.h>
+#include <mach/core.h>
+#include <mach/board.h>
+#include <mach/scu.h>
+#include <asm/smp_scu.h>
+
+
+extern void apollo_secondary_startup(void);
+
+/*
+ * Control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int pen_release = -1;
+
+static void __iomem *scu_base_addr(void)
+{
+	if (machine_is_apollo_up())
+		return __io_address(APOLLO_CORTEX_A9_SCU_BASE);
+	else if (machine_is_apollo_mp())
+		return __io_address(APOLLO_CORTEX_A9_SCU_BASE);
+	else
+		return (void __iomem *)0;
+}
+
+static inline unsigned int get_core_count(void)
+{
+	void __iomem *scu_base = scu_base_addr();
+	if (scu_base)
+		return scu_get_core_count(scu_base);
+	return 1;
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_cpu_init(0, gic_cpu_base_addr);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	flush_cache_all();
+	outer_clean_range(__pa(&secondary_data), __pa(&secondary_data + 1));
+	pen_release = cpu;
+	flush_cache_all();
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+
+	/*
+	 * XXX
+	 *
+	 * This is a later addition to the booting protocol: the
+	 * bootMonitor now puts secondary cores into WFI, so
+	 * poke_milo() no longer gets the cores moving; we need
+	 * to send a soft interrupt to wake the secondary core.
+	 * Use smp_cross_call() for this, since there's little
+	 * point duplicating the code here
+	 */
+	smp_cross_call(cpumask_of(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static void __init poke_milo(void)
+{
+	/* nobody is to be released from the pen yet */
+	pen_release = -1;
+
+	/*
+	 * Write the address of secondary startup into the system-wide flags
+	 * register. The BootMonitor waits for this register to become
+	 * non-zero.
+	 */
+
+#define APOLLO_SYS_FLAGSS_OFFSET 0x30
+#define APOLLO_SYS_FLAGSC_OFFSET 0x34
+	__raw_writel(BSYM(virt_to_phys(apollo_secondary_startup)),
+		     __io_address(APOLLO_SYS_BASE) +
+		     APOLLO_SYS_FLAGSS_OFFSET);
+
+	mb();
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "Apollo: strange CM count of 0? Default to 1\n");
+
+		ncores = 1;
+	}
+
+	if (ncores > NR_CPUS) {
+		printk(KERN_WARNING
+		       "Apollo: no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+
+	smp_store_cpu_info(cpu);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	/*
+	 * Initialise the SCU if there are more than one CPU and let
+	 * them know where to start. Note that, on modern versions of
+	 * MILO, the "poke" doesn't actually do anything until each
+	 * individual core is sent a soft interrupt to get it out of
+	 * WFI
+	 */
+	if (max_cpus > 1) {
+		/*
+		 * Enable the local timer or broadcast device for the
+		 * boot CPU, but only if we have more than one CPU.
+		 */
+		percpu_timer_setup();
+
+		scu_enable(scu_base_addr());
+		poke_milo();
+	}
+	else if(max_cpus == 1)
+	{
+		percpu_timer_setup();
+		scu_enable(scu_base_addr());
+	}
+}
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/pm.c linux-2.6.34/arch/arm/mach-apollo/pm.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/pm.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/pm.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,787 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 200 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/suspend.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/gic.h>
+#include <mach/irqs.h>
+#include <mach/hardware.h>
+#include <mach/pm.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/core.h>
+#include <asm/tlbflush.h>
+#include <mach/globaltimer.h>
+#include <asm/hardware/gic.h>
+
+extern int apollo_cpu_suspend(unsigned long int *, int , unsigned long *, unsigned long *);
+extern int apollo_get_restore_pointer(void);
+static void apollo_restore_table_entry(unsigned long *);
+static void apollo_restore_control_register(u32);
+
+/* NXP's Apollo uses ARM Cortex-A9 CPU and has a Cortex-M3 as the standby
+ * controller processor
+ */
+
+#define ITC_CPU_PRIMASK_REG \
+   (IO_ADDRESS(APOLLO_CORTEX_A9_INTC_BASE)+GIC_CPU_PRIMASK)
+
+#define ITC_CPU_EOI_REG \
+   (IO_ADDRESS(APOLLO_CORTEX_A9_INTC_BASE)+GIC_CPU_EOI)
+
+#define ITC_DISTR_PENDCLEAR_REG(bank)  \
+   (IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE)+(4*bank)+GIC_DIST_PENDING_CLEAR)
+
+#define ITC_DISTR_ENABLECLEAR_REG(bank)  \
+   (IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE)+(4*bank)+GIC_DIST_ENABLE_CLEAR)
+
+#define ITC_DISTR_PRI_REG(bank) \
+   (IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE)+(4*bank)+GIC_DIST_PRI)
+
+/* Addresses of IPC registers to control interrupts from other processors to
+ * Cortex-A9.
+ */
+#define INTR_CLR_ENABLE_IPC0  0xE06EAF00
+#define INTR_SET_ENABLE_IPC0  0xE06EAF04
+#define INTR_ENABLE_IPC0      0xE06EAF0C
+
+/* The following represent the bits representing each of the processors which
+ * can interrupt Cortex-A9 through IPC
+ */
+#define A9_REASON_BIT       0x00000001
+#define ADSP_REASON_BIT     0x00000002
+#define ARM926_REASON_BIT   0x00000004
+#define VDSP_REASON_BIT     0x00000008
+#define M3_REASON_BIT       0x00000010
+
+#define IPC0_REASON_MASK    (A9_REASON_BIT | ADSP_REASON_BIT |      \
+                             ARM926_REASON_BIT | VDSP_REASON_BIT |  \
+                             M3_REASON_BIT)
+
+/* Once in standby state, interrupt from standby processor will wake us up */
+#define   A9_WKUP_INTID       IRQ_IPC_CORTEXM3
+
+#define PIC_FRM_INTID(id)     ((id) / 32)
+#define INTPOS_FRM_INTID(id)  ((id) % 32)
+
+/* higher than 0xc0 which will be the new priority mask */
+#define WAKEUP_INT_PRI 0xb0
+  
+#ifdef CONFIG_PM_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_NOTICE fmt, ##args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+
+extern void __iomem *gic_cpu_base_addr;	/* used by entry-macro.S */
+/* Static function prototypes */
+static void apollo_pm_enable_wakeup_intr(void);
+static void apollo_pm_disable_wakeup_intr(void);
+static void apollo_pm_save_standby_context(void);
+static void apollo_pm_restore_standby_context(void);
+
+static int apollo_pm_valid(suspend_state_t state);
+static int apollo_pm_prepare(void);
+static int apollo_pm_enter(suspend_state_t state);
+static void apollo_pm_standby(void);
+static void apollo_pm_suspend(void);
+static void apollo_pm_finish(void);
+
+static inline int default_op(void)
+{
+	return 0;
+}
+
+static inline int default_enter(unsigned long resumeAddr)
+{
+	return 0;
+}
+
+/* Callback routine to activate standby controller */
+static struct apollo_pm_stdby_ctrlr_ops ops =
+{
+	.prepare = default_op,
+	.enter   = default_enter,
+	.exit    = default_op,
+	.finish  = default_op,
+	.recover = default_op
+};
+
+/* Context of cortex-A9 stored before going into standby state */
+typedef struct
+{
+	unsigned long  ipc0Mask;
+	unsigned long  primask;
+}apollo_standby_context_t;
+  
+static apollo_standby_context_t apollo_standby_cxt;
+  
+static void apollo_pm_disable_wakeup_intr(void)
+{
+	disable_irq(A9_WKUP_INTID);
+	__raw_writel(M3_REASON_BIT, INTR_CLR_ENABLE_IPC0);
+}
+
+static void apollo_pm_enable_wakeup_intr(void)
+{
+   /* Set the priority of standby controller interrupt to be higher than
+    * priority mask
+    */
+   unsigned long num   = (A9_WKUP_INTID / 4);
+   unsigned long pri   = __raw_readl(ITC_DISTR_PRI_REG(num));
+   unsigned long tmp   = 0;
+   unsigned int  shift = (A9_WKUP_INTID % 4) * 8;
+
+   tmp = 0xFFFFFFFF ^ (0xFF << shift);
+   pri &= tmp;
+   pri |= (WAKEUP_INT_PRI << shift);
+
+   __raw_writel(pri, ITC_DISTR_PRI_REG(num));
+
+   enable_irq(A9_WKUP_INTID);
+
+   __raw_writel(M3_REASON_BIT, INTR_CLR_ENABLE_IPC0);
+   __raw_writel(M3_REASON_BIT, INTR_SET_ENABLE_IPC0);
+}
+
+static void apollo_pm_clear_wakeup_intr(void)
+{
+   __raw_writel(M3_REASON_BIT, INTR_CLR_ENABLE_IPC0);
+
+   __raw_writel((1 << INTPOS_FRM_INTID(A9_WKUP_INTID)),
+                ITC_DISTR_ENABLECLEAR_REG(PIC_FRM_INTID(A9_WKUP_INTID)));
+
+   __raw_writel(A9_WKUP_INTID, ITC_CPU_EOI_REG);
+   
+   __raw_writel((1 << INTPOS_FRM_INTID(A9_WKUP_INTID)),
+                ITC_DISTR_PENDCLEAR_REG(PIC_FRM_INTID(A9_WKUP_INTID)));
+}
+
+/* Wakeup interrupt handler */
+static irqreturn_t apollo_wakeup_interrupt(int irq, void *dev)
+{
+   apollo_pm_clear_wakeup_intr();
+   return IRQ_HANDLED;
+}
+
+/* Wakeup interrupt configuration */
+static struct irqaction apollo_wakeup_irq = {
+   .name    = "Apollo wakeup",
+   .flags   = IRQF_DISABLED | IRQF_SHARED,
+   .handler = apollo_wakeup_interrupt
+};
+  
+/* Save the context before entering into standby state */
+static void apollo_pm_save_standby_context(void)
+{
+	apollo_pm_disable_wakeup_intr();
+
+	/* Store the existing priority mask */
+	apollo_standby_cxt.primask = __raw_readl(ITC_CPU_PRIMASK_REG);
+
+	/* change it to higher than all existing interrupts */
+	__raw_writel(0xC0, ITC_CPU_PRIMASK_REG);
+
+	/* Store the enabled IPC0 interrupts configuration */
+	apollo_standby_cxt.ipc0Mask = __raw_readl(INTR_ENABLE_IPC0);
+
+	__raw_writel(IPC0_REASON_MASK, INTR_CLR_ENABLE_IPC0);
+
+	/* Enable standby controller interrupt with priority higher than priority
+	 * mask.
+	 */
+	apollo_pm_enable_wakeup_intr();
+}
+  
+/* Restore the saved context */
+static void apollo_pm_restore_standby_context()
+{
+   /* Restore the priority mask */
+   __raw_writel(apollo_standby_cxt.primask, ITC_CPU_PRIMASK_REG);
+
+   /* Store the enabled IPC0 interrupts configuration */
+   __raw_writel(apollo_standby_cxt.ipc0Mask, INTR_CLR_ENABLE_IPC0);
+   __raw_writel(apollo_standby_cxt.ipc0Mask, INTR_SET_ENABLE_IPC0);
+}
+
+struct apollo_pm_gic_dist_save   pm_pic_save;
+
+void apollo_pm_gic_dist_save(void)
+{
+   unsigned int max_irq, i,j;
+   void *__iomem dist_base;
+   u32 cpumask = 1 << smp_processor_id();
+   dist_base = (void *__iomem) IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE);
+
+   cpumask |= cpumask << 8;
+   cpumask |= cpumask << 16;
+
+   /*
+    * Find out how many interrupts are supported.
+    */
+   max_irq = readl(dist_base + GIC_DIST_CTR) & 0x1f;
+   max_irq = (max_irq + 1) * 32;
+
+   /*
+    * The GIC only supports up to 1020 interrupt sources.
+    * Limit this to either the architected maximum, or the
+    * platform maximum.
+    */
+   if (max_irq > max(1020, NR_IRQS))
+      max_irq = max(1020, NR_IRQS);
+
+
+   /*
+    * Save Interrupt distributor enable clear.
+    * Remember this has to be toggled while restoring....
+    */
+   for (i = 0,j = 0; i < max_irq; i += 32, j++)
+   {
+      pm_pic_save.dist_enable_clear[j] = readl(dist_base + GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
+   }
+
+   /* saving distributor enable set.
+    * 
+    */
+   for (i = 0,j = 0; i < max_irq; i += 32, j++)
+   {
+      pm_pic_save.dist_enable_set[j] = readl(dist_base + GIC_DIST_ENABLE_SET + i * 4 / 32);
+   }
+
+   return;
+}
+
+void apollo_pm_gic_dist_disable(void)
+{
+   unsigned int max_irq, i, j;
+   void *__iomem dist_base;
+   dist_base = (void *__iomem) IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE);
+
+   writel(0x0, (dist_base+GIC_DIST_CTRL));
+   writel(0x0, (gic_cpu_base_addr+GIC_CPU_CTRL ));
+
+   /*
+    * Find out how many interrupts are supported.
+    */
+   max_irq = readl(dist_base + GIC_DIST_CTR) & 0x1f;
+   max_irq = (max_irq + 1) * 32;
+
+   /*
+    * The GIC only supports up to 1020 interrupt sources.
+    * Limit this to either the architected maximum, or the
+    * platform maximum.
+    */
+   if (max_irq > max(1020, NR_IRQS))
+      max_irq = max(1020, NR_IRQS);
+
+   /*
+    * Disable all interrupts.
+    */
+   for (i = 0; i < max_irq; i += 32)
+   {
+      writel(0xffffffff, dist_base + GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
+   }
+
+   /* saving distributor set-pending */
+   for (i = 0,j = 0; i < max_irq; i += 32, j++) 
+   {
+      pm_pic_save.dist_pending_set[j] = readl(dist_base + GIC_DIST_PENDING_SET + i * 4 / 32);
+   }
+
+   /* clear pending interrupts */
+   for (i = 0; i < max_irq; i += 32)
+   {
+      writel(0xffffffff, dist_base + GIC_DIST_PENDING_CLEAR + i * 4 / 32);
+   }
+
+   for (i = 0; i < max_irq; i += 32)
+   {
+      writel(0x0, dist_base + GIC_DIST_PENDING_SET + i * 4 / 32);
+   }
+
+   writel(0x1, (dist_base +GIC_DIST_CTRL));
+   writel(0xf0, (gic_cpu_base_addr+ GIC_CPU_PRIMASK));
+   writel(0x1, (gic_cpu_base_addr+GIC_CPU_CTRL ));
+
+   return;
+}
+
+void apollo_pm_gic_dist_restore(void)
+{
+   unsigned int max_irq, i,j;
+   void *__iomem dist_base;
+   u32 cpumask = 1 << smp_processor_id();
+   dist_base = (void *__iomem)IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE);
+
+   cpumask |= cpumask << 8;
+   cpumask |= cpumask << 16;
+
+   writel(0x0, (dist_base+GIC_DIST_CTRL));
+   writel(0x0, (gic_cpu_base_addr+GIC_CPU_CTRL ));
+   /*
+    * Find out how many interrupts are supported.
+    */
+   max_irq = readl(dist_base + GIC_DIST_CTR) & 0x1f;
+   max_irq = (max_irq + 1) * 32;
+
+   /*
+    * The GIC only supports up to 1020 interrupt sources.
+    * Limit this to either the architected maximum, or the
+    * platform maximum.
+    */
+   if (max_irq > max(1020, NR_IRQS))
+      max_irq = max(1020, NR_IRQS);
+
+#if 0
+   /*
+    * Set all global interrupts to be level triggered, active low.
+    */
+   for (i = 32; i < max_irq; i += 16)
+   {
+      writel(0, dist_base + GIC_DIST_CONFIG + i * 4 / 16);
+   }
+
+   /*
+    * Set all global interrupts to this CPU only.
+    */
+   for (i = 32; i < max_irq; i += 4)
+   {
+      writel(cpumask, dist_base + GIC_DIST_TARGET + i * 4 / 4);
+   }
+
+   /*
+    * Set priority on all interrupts.
+    */
+   for (i = 0; i < max_irq; i += 4)
+   {
+      writel(0xd0d0d0d0, dist_base + GIC_DIST_PRI + i * 4 / 4);
+   }
+#endif
+
+   /*
+    * Restore Interrupt distributor enable clear.
+    * Remember this has to be toggled while restoring....
+    */
+   for (i = 0,j = 0; i < max_irq; i += 32, j++)
+   {
+      writel(~(pm_pic_save.dist_enable_clear[j]),(dist_base + GIC_DIST_ENABLE_CLEAR + i * 4 / 32));
+   }
+
+   /* Restore distributor enable set.
+    * 
+    */
+   for (i = 0,j = 0; i < max_irq; i += 32, j++)
+   {
+      writel(pm_pic_save.dist_enable_set[j], (dist_base + GIC_DIST_ENABLE_SET + i * 4 / 32));
+   }
+
+   writel(0x1, (dist_base +GIC_DIST_CTRL));
+   writel(0xf0, (gic_cpu_base_addr+ GIC_CPU_PRIMASK));
+   writel(0x1, (gic_cpu_base_addr+GIC_CPU_CTRL ));
+   return;
+}
+
+static void apollo_restore_control_register(u32 val)
+{
+       __asm__ __volatile__ ("mcr p15, 0, %0, c1, c0, 0" : : "r" (val));
+}
+
+/* During the MMU restoration on the restore path from MPU OFF, the page
+ * table entry for the page consisting of the code being executed is
+ * modified to make MMU return VA=PA.
+
+ * The MMU is then enabled and the original entry is being stored in
+ * scratchpad.  This functio reads the original values stored in
+ * scratchpad, and restores them back. */
+
+static void apollo_restore_table_entry(unsigned long *restoreAddr)
+{
+       u32 previous_value, control_reg_value;
+       u32 *address;
+
+       /* Get address of entry that was modified */
+       address = (u32 *)restoreAddr[0];
+       /* Get the previous value which needs to be restored */
+       previous_value = restoreAddr[1];
+       address = __va(address);
+       *address = previous_value;
+       flush_tlb_all();
+       control_reg_value = restoreAddr[2];
+       /* This will enable caches and prediction */
+       apollo_restore_control_register(control_reg_value);
+}
+
+
+/* state change to s2ram */
+static void apollo_pm_suspend(void)
+{
+    /* Variable to tell what needs to be saved and restored
+     * in apollo_cpu_suspend */
+    /* save_state = 0 => Nothing to save and restored */
+    /* save_state = 1 => Only L1 and logic lost */
+    /* save_state = 2 => Only L2 lost */
+    /* save_state = 3 => L1, L2 and logic lost */
+    int save_state = 3;
+    /* Offset 1-20 -- r0-r12, lr 
+     * Offset 2- 64 -- Other CPU and co-processot registers */
+    unsigned long reg_save[128] = {0, };
+    /* Offset - Reg
+     * 0x0    - Page table entry location
+     * 0x4    - Previous value in page table entry location 
+     * 0x8    - Previous value of SCTLR */
+    unsigned long restore_mmu_on_regs[4] = {0, };
+    unsigned long ret_val = 0;
+
+    /*
+     * Step 1: turn off interrupts (FIXME: Already disabled??)
+     */
+    local_irq_disable();
+    local_fiq_disable();
+    DPRINTK("PM: Apollo S2RAM \n");
+    apollo_pm_gic_dist_save();
+
+    DPRINTK("PM: Apollo Suspend - Preparing standby controller.\n");
+    ret_val = ops.prepare();
+    if(ret_val != 0)
+    {
+       DPRINTK("SCD Prepare failed with reason %lu\n", ret_val);
+       goto resume;
+    }
+    {
+       DPRINTK("reg_save = [%08x] restore_mmu_on_regs = [%08x]\n", 
+               (unsigned int)reg_save, (unsigned int)restore_mmu_on_regs);
+       DPRINTK("Scratchpad = [0x70 == %08x], [0x74 == %08x] ",
+                readl(0xe06ead70),
+                readl(0xe06ead74));
+       DPRINTK("Ready to go to suspend!\n");
+    }
+    /*idle*/
+    apollo_cpu_suspend(reg_save,save_state, restore_mmu_on_regs, &ret_val);
+
+    if(ret_val == 0x5)
+    {
+       /* Call the SCD Enter API here */
+      __raw_writel(0xbb, 0xe06ead6c);
+      /* Calling the SCD Enter API here */
+      DPRINTK("PM: Apollo Suspend - Activating standby controller.\n");
+      ret_val = ops.enter(apollo_get_restore_pointer());
+      __raw_writel(0xbc, 0xe06ead6c);
+      if(ret_val != 0)
+      {
+         DPRINTK("SCD Enter failed with reason %lu\n", ret_val);
+         __raw_writel(0xbd, 0xe06ead6c);
+         ops.recover();
+         goto resume;
+      }
+      __raw_writel(0xbe, 0xe06ead6c);
+      asm("b .");
+       //while(1); /* M3 will power off the A9 waiting... */
+    }
+
+    /*reset all the ARM mode pointers*/
+resume: cpu_init();
+
+    apollo_restore_table_entry(restore_mmu_on_regs);
+
+    if(ops.exit() != 2)
+    {
+       ops.finish();
+    }
+
+    //apollo_pm_restore_context();
+    apollo_pm_gic_dist_restore();
+    //apollo_init_irq();
+    apollo_pm_timer_restore();
+
+
+    DPRINTK("PM: Apollo S2RAM -- Resumed\n");
+    local_irq_enable();
+    local_fiq_enable();
+
+    DPRINTK("PM: Apollo resuming from suspend state...\n");
+    return;
+}
+
+/* state change to standby */
+static void apollo_pm_standby(void)
+{
+   unsigned int cpipe_layer_ctl_reg[8];
+   int i;
+
+   printk("PM: Apollo entering standby state...\n");
+
+   /* Make sure the CPIPE layers are all blanked. The CPIPE RIF will
+    * continue to read memory unless the layers are off. This would
+    * cause random failures when the A9 resumes. The driver needs to
+    * manage this. This is a safe guard to avoid issues since the
+    * splash screen sets up the CPIPE outside of the CPIPE driver's
+    * scope. */
+   for ( i=0; i<8; i++)
+   {
+      if ( i < 4 )
+      {
+         cpipe_layer_ctl_reg[i] = readl(ARM_A9_HOST_MMIO_BASE
+                                        + 0x128400 + (i * 0x400)) & 0x1;
+         writel(0x0, (ARM_A9_HOST_MMIO_BASE + 0x128400 + (i * 0x400)) );
+      }
+      else
+      {
+         cpipe_layer_ctl_reg[i] = readl(ARM_A9_HOST_MMIO_BASE
+                                        + 0x124400 + ((i-4) * 0x400)) & 0x1;
+         writel(0x0, (ARM_A9_HOST_MMIO_BASE + 0x124400 + ((i-4) * 0x400)) );
+      }
+   }
+
+  /**
+    * Step 1: turn off interrupts
+    */
+   local_irq_disable();
+   local_fiq_disable();
+
+   /* Make sure ALL the interrupts are off. This is just
+    * to guarantee the registers are disabled.
+    */
+
+   /* Save any that are still on. */
+   apollo_pm_gic_dist_save();
+
+   /* Disable them */
+   apollo_pm_gic_dist_disable();
+
+   for ( i = 0; i<8; i++)
+   {
+      if ( pm_pic_save.dist_pending_set[i] )
+      {
+         printk("WARNING: You have a pending irq.\n\t\tindex: %d\n\t\tvalue: %x\n", i, pm_pic_save.dist_pending_set[i]);
+      }
+   }
+
+   /* Enable the IPC interrupt from M3 */
+   __raw_writel(0x2, 0xe0101104);
+
+   /* Save the current context */
+   apollo_pm_save_standby_context();
+
+   /* Give control to standby controller before doing WFI */
+   printk("PM: Apollo preparing standby controller.\n");
+
+   /* In case we can't activate the on-chip standby controller, bailout and
+    * fake that we are resuming.
+    */
+   if(ops.prepare() == 0)
+   {
+      printk("PM: Apollo activating standby controller.\n");
+      if(ops.enter(0) != 0)
+      {
+         /* Revert the effect of prepare */
+         ops.recover();
+         goto resume;
+      }
+   }
+   else
+   {
+      goto resume;
+   }
+
+   for(;;)
+   {
+      flush_cache_all();
+
+      /* Entering into WFI */
+      asm("dsb\n"
+          "wfi");
+
+      printk("PM: Apollo out of WFI...\n");
+
+      if(ops.exit() != 2)
+      {
+         ops.finish();
+         break;
+      }
+   }
+
+resume:
+   /* Resumed...restore the context */
+   apollo_pm_restore_standby_context();
+
+   /* Restore any of the PM saved interrupts. */
+   apollo_pm_gic_dist_restore();
+
+   local_irq_enable();
+   local_fiq_enable();
+
+   /* Restore the CPIPE layer enables */
+   for ( i=0; i<8; i++)
+   {
+      if ( i < 4 )
+      {
+         writel( cpipe_layer_ctl_reg[i],
+                 (ARM_A9_HOST_MMIO_BASE + 0x128400 + (i * 0x400)) );
+      }
+      else
+      {
+         writel( cpipe_layer_ctl_reg[i],
+                 (ARM_A9_HOST_MMIO_BASE + 0x124400 + ((i-4) * 0x400)) );
+      }
+   }
+
+   printk("PM: Apollo resuming from standby state...\n");
+}
+
+/*
+ * apollo_pm_prepare - Do preliminary suspend work.
+ *
+ */
+static int apollo_pm_prepare(void)
+{
+   int ret = 0;
+
+   printk("PM: Apollo power mgmt prepare for suspend...\n");
+
+   /* Setup interrupt from M3 through IPC0 */
+   ret = request_irq(A9_WKUP_INTID, 
+                     apollo_wakeup_irq.handler,
+                     apollo_wakeup_irq.flags,
+                     apollo_wakeup_irq.name,
+                     &apollo_wakeup_irq);
+
+   if(ret < 0)
+   {
+      printk("PM: Apollo wakeup interrupt request failed, %d\n", ret);
+      return -1;
+   }
+
+   return 0;
+}
+
+/*
+ * apollo_pm_enter - Actually enter a sleep state.
+ * @state:     State we're entering.
+ *
+ */
+static int apollo_pm_enter(suspend_state_t state)
+{
+   switch (state)
+   {
+      case PM_SUSPEND_STANDBY:
+         apollo_pm_standby();
+         break;
+      case PM_SUSPEND_MEM:
+         apollo_pm_suspend();
+         break;
+      default:
+         return -EINVAL;
+   }
+
+   return 0;
+}
+
+/**
+ * apollo_pm_finish - Finish up suspend sequence.
+ *
+ * This is called after we wake back up (or if entering the sleep state
+ * failed).
+ */
+static void apollo_pm_finish(void)
+{
+   printk("PM: Apollo power mgmt finish.\n");
+
+   disable_irq(A9_WKUP_INTID);
+   
+   free_irq(A9_WKUP_INTID, &apollo_wakeup_irq);
+
+   /* 
+    * re-enable the IPC0 interrupt so that the exiting ISRs 
+    * from other subsystems will be called. 
+    */
+   enable_irq(A9_WKUP_INTID);
+}
+
+static int apollo_pm_valid(suspend_state_t state)
+{
+   /* Currently support for standby state only */
+   switch (state)
+   {
+      case PM_SUSPEND_MEM:
+      case PM_SUSPEND_STANDBY:
+         return 1;
+   }
+
+   return 0;
+}
+
+static struct platform_suspend_ops apollo_pm_ops =
+{
+   .prepare    = apollo_pm_prepare,
+   .enter      = apollo_pm_enter,
+   .finish     = apollo_pm_finish,
+   .valid      = apollo_pm_valid
+};
+
+/* function to register routines to activate standby controller */
+int apollo_pm_register(struct apollo_pm_stdby_ctrlr_ops *pOps)
+{
+   /* enter and exit are mandatory, check to see they are valid */
+   if(!pOps->enter || !pOps->exit)
+      return -1;
+
+   ops.enter   = pOps->enter;
+   ops.exit    = pOps->exit;
+
+   /* prepare, recover and finish are optional, copy them conditionally */
+   if(pOps->prepare)
+      ops.prepare = pOps->prepare;
+   if(pOps->finish)
+      ops.finish  = pOps->finish;
+   if(pOps->recover)
+      ops.recover = pOps->recover;
+
+   return 0;
+}
+EXPORT_SYMBOL(apollo_pm_register);
+
+static int __init apollo_pm_init(void)
+{
+   printk("PM: Apollo power mgmt initialization.\n");
+
+   suspend_set_ops(&apollo_pm_ops);
+
+   return 0;
+}
+__initcall(apollo_pm_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/pnx8492.c linux-2.6.34/arch/arm/mach-apollo/pnx8492.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/pnx8492.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/pnx8492.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,601 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+ 
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+#include <linux/serial.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+
+#include <asm/hardware/arm_timer.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+
+#include <mach/pnx8492.h>
+#include <mach/globaltimer.h>
+#include <mach/hardware.h>
+#include <mach/core.h>
+#include <mach/irqs.h>
+
+#include <mach/nor.h>
+#include <mach/usbudc.h>
+
+#ifdef CONFIG_APOLLO_SPLASH
+#include <mach/splash_logo.h>
+#endif
+
+#define ATAGLIST_MAX_WORDS 192
+#define SP_GP_03_OFFSET 0x281dc
+#define CHIP_ID_SHIFT 28
+#define CHIP_REV_SHIFT 20
+
+void __iomem *gic_cpu_base_addr;	/* used by entry-macro.S */
+unsigned long uKernelAtaglist[ATAGLIST_MAX_WORDS];
+static struct meminfo pnx8493_meminfo __initdata = { 0, };
+unsigned long ChipID;
+unsigned long ChipRevID;
+
+static struct map_desc apollo_io_desc[] __initdata = {
+	{
+		.virtual =  IO_ADDRESS(ARM_A9_HOST_MMIO_BASE),
+		.pfn	 = __phys_to_pfn(ARM_A9_HOST_MMIO_BASE),
+		.length	 = HOST_ARM_MMIO_APERTURE,
+		.type	 = MT_DEVICE
+	}, {
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_SCU_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_SCU_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	}, {
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_INTC_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_INTC_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	}, {
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_GLOB_TIMER_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_GLOB_TIMER_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	}, {
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_PRIV_TIMER_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_PRIV_TIMER_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	}, {
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_DISTR_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	}, 
+#ifdef CONFIG_CACHE_L2X0
+	{
+		.virtual =  IO_ADDRESS(APOLLO_CORTEX_A9_L2CACHE_BASE),
+		.pfn	 = __phys_to_pfn(APOLLO_CORTEX_A9_L2CACHE_BASE),
+		.length	 = SZ_4K,
+		.type	 = MT_DEVICE
+	},
+#endif
+};
+
+void __init apollo_map_io(void)
+{
+	printk (KERN_INFO "Early platform io descriptors mapping...\n");
+	iotable_init(apollo_io_desc, ARRAY_SIZE(apollo_io_desc));
+}
+
+void __init apollo_init_irq(void)
+{
+	unsigned long distr_vaddr = IO_ADDRESS(APOLLO_CORTEX_A9_DISTR_BASE);
+	unsigned long distr_paddr = APOLLO_CORTEX_A9_DISTR_BASE;
+	unsigned long gic_vaddr   = IO_ADDRESS(APOLLO_CORTEX_A9_INTC_BASE);
+	unsigned long gic_paddr   = APOLLO_CORTEX_A9_INTC_BASE;
+
+	gic_cpu_base_addr = (void *)IO_ADDRESS(APOLLO_CORTEX_A9_INTC_BASE);
+
+	printk(KERN_INFO "Initializing Cortex Interrupt Distributer (DISTR) at "
+					 "Vir:0x%08X = Phy:0x%08X\n", 
+					(unsigned int)distr_vaddr,
+					(unsigned int)distr_paddr);
+
+    gic_dist_init(0, (void *)distr_vaddr, (IRQ_LOWEST_NBR + 1));
+
+	printk(KERN_INFO "Initializing Cortex Generic Interrupt Controller (GIC)"
+					 " at Vir:0x%08X = Phy:0x%08X\n", 
+					(unsigned int)gic_vaddr,
+					(unsigned int)gic_paddr);
+
+	gic_cpu_init(0, gic_cpu_base_addr);
+}
+
+static void apollo_timer_init(void)
+{
+	unsigned long vaddr = IO_ADDRESS(APOLLO_CORTEX_A9_GLOB_TIMER_BASE);
+	unsigned long paddr = APOLLO_CORTEX_A9_GLOB_TIMER_BASE;
+	unsigned long irq =   IRQ_A9_GLOB_TIMER;
+	unsigned long freq =  APOLLO_PERIPHERALS_FREQ;
+
+	printk(KERN_INFO "Initializing Cortex A9 Global Timer at Vir:0x%08X = Phy:0x%08X,"
+					 " using Irq:%i, at Freq:%i\n",
+					(unsigned int)vaddr,
+					(unsigned int)paddr,
+					(unsigned int)irq,
+					(unsigned int)freq);
+
+	apollo_global_timer_init(vaddr, irq, freq);
+}
+
+struct sys_timer apollo_timer = {
+	.init	= apollo_timer_init,
+};
+
+static u64 uart_dmamask = ~(u32)0;	/* The dmamask must be set for EHCI to work */
+
+static struct resource uart0_resources[] = {
+	{
+		.start	= IP3106_UART_PORT_0,
+		.end	= IP3106_UART_PORT_0 + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_UART_0,
+		.end	= IRQ_UART_0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart0_device = {
+		.name			= "uart-ip3106",
+		.id			= 0,
+		.dev			= {
+		.platform_data		= NULL,
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources		= ARRAY_SIZE(uart0_resources),
+	.resource		= uart0_resources,
+};
+
+#ifndef CONFIG_EXECUTE_ON_SIMULATOR
+static struct resource uart1_resources[] = {
+	{
+		.start	= IP3106_UART_PORT_1,
+		.end	= IP3106_UART_PORT_1 + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_UART_1,
+		.end	= IRQ_UART_1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart1_device = {
+		.name			= "uart-ip3106",
+		.id			= 1,
+		.dev			= {
+		.platform_data		= NULL,
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(uart1_resources),
+	.resource	= uart1_resources,
+};
+
+static struct resource uart2_resources[] = {
+	{
+		.start	= IP3106_UART_PORT_2,
+		.end	= IP3106_UART_PORT_2 + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_UART_2,
+		.end	= IRQ_UART_2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart2_device = {
+		.name			= "uart-ip3106",
+		.id			= 2,
+		.dev			= {
+		.platform_data		= NULL,
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(uart2_resources),
+	.resource	= uart2_resources,
+};
+
+static struct resource uart3_resources[] = {
+	{
+		.start	= IP3106_UART_PORT_3,
+		.end	= IP3106_UART_PORT_3 + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_UART_3,
+		.end	= IRQ_UART_3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart3_device = {
+		.name			= "uart-ip3106",
+		.id			= 3,
+		.dev			= {
+		.platform_data		= NULL,
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(uart3_resources),
+	.resource	= uart3_resources,
+};
+#endif /* #ifndef CONFIG_EXECUTE_ON_SIMULATOR */
+
+#ifdef CONFIG_USB
+
+/* USB_UDC_CHECK:
+  * We have 3 USB resources in Avalon: USB0, USB1, USB2
+  * USB0: 0xE066C000: it is USB2.0 OTG (host-device role switch)
+  * USB1: 0xE066D000: it is USB2.0 ALWAYS HOST
+  * USB2: 0xE066E000: it is USB1.1 ALWAYS HOST (doesnot exist on avalon)
+  *
+  */
+static u64 ehci_dmamask = ~(u32)0;      /* The dmamask must be set for EHCI to work */
+
+/****** USB0: 0xE066C000: USB OTG ******/
+#ifndef NOCONA_PORT// ENABLE THIS, WHEN USING FSL PORT or CI PORT... DISABLE FOR NOCONA PORT...
+//USB_UDC_CHECK use Nevis cnxt_udc0 driver for NOCONA PORT...
+static struct resource usb0_resources[] = {
+        [0] = {
+                .start  = IP9028_USB_PORT_0,            // 0xe066c000: USB OTG
+                .end            = IP9028_USB_PORT_0 + 0xfff,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = IRQ_USB_0,
+                .end            = IRQ_USB_0,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usb0_device = {
+#ifdef CONFIG_USB_GADGET_IP9028
+	#ifdef FSL_PORT
+            .name          = "ip9028_udc_udc",		/* device mode, MUST to have 14-character name */
+            //.name          = "ip9028_otg_usb",	/*  OTG dev. drv. */
+	#endif
+	#ifdef CI_PORT
+            .name          = "ci13xxx_udc_udc",		/* OTG dev. drv. */
+	#endif
+#else
+            .name          = "usb-ip9028",    /* Host only dev. drv. */
+#endif
+                .id                     = 0,
+                .dev                    = {
+                .dma_mask               = &ehci_dmamask,
+                .coherent_dma_mask      = 0xffffffff,
+        },
+        .num_resources  = ARRAY_SIZE(usb0_resources),
+        .resource       = usb0_resources,
+};
+#endif
+
+/****** USB1: 0xE066D000: USB2.0 ALWAYS HOST ******/
+static struct resource usb1_resources[] = {
+        [0] = {
+                .start  = IP9028_USB_PORT_1,            // 0xe066d000: USB2.0 Always Host
+                .end            = IP9028_USB_PORT_1 + 0xfff,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = IRQ_USB_1,
+                .end            = IRQ_USB_1,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usb1_device = {
+                .name                   = "usb-ip9028",                 /* Host only dev. drv. */
+                .id                     = 1,
+                .dev                    = {
+                .dma_mask               = &ehci_dmamask,
+                .coherent_dma_mask      = 0xffffffff,
+        },
+        .num_resources  = ARRAY_SIZE(usb1_resources),
+        .resource       = usb1_resources,
+};
+
+/****** USB2: 0xE066E000: USB1.1 ALWAYS HOST ******/
+static struct resource usb2_resources[] = {
+        [0] = {
+                .start  = IP9028_USB_PORT_2,            // 0xe066e000: USB1.1 Always Host
+                .end            = IP9028_USB_PORT_2 + 0xfff,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = IRQ_USB_2,
+                .end            = IRQ_USB_2,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device usb2_device = {
+                .name                   = "usb-ip9028",	// "ohci_hcd",                   /* Host only dev. drv. */
+                .id                     = 2,		// 0,
+                .dev                    = {
+                .dma_mask               = &ehci_dmamask,
+                .coherent_dma_mask      = 0xffffffff,
+        },
+        .num_resources  = ARRAY_SIZE(usb2_resources),
+        .resource       = usb2_resources,
+};
+#endif /* CONFIG_USB */
+
+/* *************************************************************** */
+
+static struct platform_device *platform_devs[] __initdata = {
+	&uart0_device,
+#ifndef CONFIG_EXECUTE_ON_SIMULATOR
+	&uart1_device,
+	&uart2_device,
+	&uart3_device,
+#endif
+#ifdef CONFIG_USB
+	#ifndef NOCONA_PORT
+	&usb0_device,	// ENABLE THIS, WHEN USING FSL PORT... DISABLE FOR NOCONA PORT...
+	#endif
+	&usb1_device,
+	&usb2_device,
+#endif
+};
+
+#ifdef CONFIG_CACHE_L2X0
+static int __init apollo_l2x0_init(void)
+{
+	if (machine_is_apollo()) {
+		/*
+		 * Data and Instruction prefetch, 
+		 * 128KB (16KB/way), 
+		 * 8-way associativity, 
+		 * Exclusive, 
+                 * Zero enable 
+		 * Bits:  0011 0010 0000 0010 0001 0000 0000 0001
+		 */
+		l2x0_init(__io_address(APOLLO_CORTEX_A9_L2CACHE_BASE),
+			  0x32021001, 0xffffffff);
+
+		/* Change the ACTRL register to Exlusive, Zero Enable, L1 prefetch, L2 prefetch */
+                __asm__("mrc p15, 0, r12, c1, c0, 1\n\t"
+                        "orr r12, r12, #0x8e\n\t"
+                        "mcr p15, 0, r12, c1, c0, 1"
+                : : : "r12","cc", "memory");
+	}
+	return 0;
+}
+early_initcall(apollo_l2x0_init);
+#endif
+
+/* This function is used to get the chipid and chipRevId */
+static void cnxt_get_chip_rev_id(void)
+{
+    volatile unsigned long *pFuse;
+
+    /* Init the iotable as the mapping is still not there */
+    iotable_init(apollo_io_desc, 1);
+
+    /* Read the OTP register for Package ID and Rev ID */
+    pFuse = (unsigned long *)(ARM_A9_HOST_MMIO_BASE + SP_GP_03_OFFSET);
+
+    /* If the Fuse is not programmed assume Shiner M0 */
+    if(*pFuse == 0)
+    {
+	ChipID=CHIPID_SHINER_S;
+	ChipRevID=CHIP_REV_M0;
+    }
+    else
+    {
+       /* ChipID is bit 28 to 31 */
+       ChipID=(*pFuse&0xF0000000)>>CHIP_ID_SHIFT;
+
+       /* Chip Rev is bit 20 to 23 */
+       ChipRevID=(*pFuse&0x00F00000)>>CHIP_REV_SHIFT;
+    }
+    
+    printk("ChipID=0x%lx ChipRevID=0x%lx\n",ChipID,ChipRevID);
+}
+
+unsigned int GetChipRev (void)
+{
+    return ChipRevID;
+}
+
+unsigned int GetChipID (void)
+{
+    return ChipID;
+}
+
+void __init apollo_init(void)
+{
+#ifdef CONFIG_APOLLO_SPLASH
+   apollo_splash();
+#endif
+   printk (KERN_INFO "Adding platform devices...\n");
+   platform_add_devices(platform_devs, ARRAY_SIZE(platform_devs));
+}
+
+/*
+ * fixup function
+ */
+void __init apollo_fixup( struct machine_desc *pmach,
+			struct tag *ptag,
+			char **pptr,
+			struct meminfo *pmem)
+{
+
+   /* copy the ataglist to the global variable uKernelAtaglist */
+   memcpy( uKernelAtaglist, ptag, ATAGLIST_MAX_WORDS * 4 );
+
+   for (; ptag->hdr.size; ptag = tag_next(ptag))
+       if(ptag->hdr.tag == ATAG_MEM)
+       {
+           pnx8493_meminfo.bank[pnx8493_meminfo.nr_banks].start = ptag->u.mem.start;
+           pnx8493_meminfo.bank[pnx8493_meminfo.nr_banks].size = ptag->u.mem.size;
+           pnx8493_meminfo.bank[pnx8493_meminfo.nr_banks].node = 0;
+           pnx8493_meminfo.bank[pnx8493_meminfo.nr_banks].highmem = 0;
+           pnx8493_meminfo.nr_banks++;
+       }
+
+   cnxt_get_chip_rev_id(); 
+   return;
+}
+
+u32 __initdata uARM926_start, uARM926_size;
+u32 __initdata uBIS_start, uBIS_size;
+u32 __initdata uADSP_start, uADSP_size;
+u32 __initdata uVDSP_start, uVDSP_size;
+u32 __initdata uMALONE_start, uMALONE_size;
+u32 __initdata uVRAMHD_start, uVRAMHD_size;
+u32 __initdata uVRAMSD_start, uVRAMSD_size;
+u32 __initdata uMBVPHD_start, uMBVPHD_size;
+u32 __initdata uMBVPSD_start, uMBVPSD_size;
+u32 __initdata uKALCSSGEN_start, uKALCSSGEN_size;
+u32 __initdata uKALCSSCON_start, uKALCSSCON_size;
+u32 __initdata uA9_ARM926_start, uA9_ARM926_size;
+u32 __initdata uARM926_TM_start, uARM926_TM_size;
+u32 __initdata uMBVP_stdi_start, uMBVP_stdi_size;
+
+static int __init parse_tag_memmap(const struct tag *tag)
+{
+	int i;
+
+	for(i=0;i<MAX_MEMMAP_TAGS;i++)
+	{
+        if((tag->u.memmap.pool_def[i].offset <= 0) || (tag->u.memmap.pool_def[i].offset > pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].size))
+            continue;
+
+		switch (tag->u.memmap.pool_def[i].pool_type)
+		{
+			case 0:
+				uARM926_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uARM926_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 1:
+				uBIS_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uBIS_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 2:
+				uADSP_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uADSP_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 3:
+				uVDSP_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uVDSP_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 4:
+				uMALONE_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uMALONE_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 5:
+				uVRAMHD_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uVRAMHD_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 6:
+				uVRAMSD_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uVRAMSD_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 7:
+				uMBVPHD_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);;
+				uMBVPHD_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 8:
+				uMBVPSD_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uMBVPSD_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 9:
+				uKALCSSGEN_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uKALCSSGEN_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 0xa:
+				uKALCSSCON_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uKALCSSCON_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 0xb:
+				uA9_ARM926_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uA9_ARM926_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 0xc:
+				uARM926_TM_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uARM926_TM_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			case 0xd:
+				uMBVP_stdi_start = (pnx8493_meminfo.bank[tag->u.memmap.pool_def[i].bank].start)+(tag->u.memmap.pool_def[i].offset);
+				uMBVP_stdi_size = tag->u.memmap.pool_def[i].size;
+			break;
+
+			default:
+                printk(KERN_WARNING "Unknown pool type in ATAG List!!\n");
+				break;
+
+		}
+	}
+
+    return 0;
+}
+__tagtable(ATAG_MEMMAP, parse_tag_memmap);
+
+EXPORT_SYMBOL(uKernelAtaglist);
+EXPORT_SYMBOL(ChipID);
+EXPORT_SYMBOL(ChipRevID);
+EXPORT_SYMBOL(GetChipRev);
+EXPORT_SYMBOL(GetChipID);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/rtc.c linux-2.6.34/arch/arm/mach-apollo/rtc.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/rtc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/rtc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+
+/*-------------------------------------------------------------------------*/
+
+
+static struct resource apollo_rtc_resources[] = {
+    {
+        .start          = APOLLO_RTC_BASE,
+        .end            = APOLLO_RTC_BASE + 4096,
+        .flags          = IORESOURCE_MEM,
+    },
+    {
+        .start          = IRQ_RTC0,
+        .flags          = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device apollo_rtc_device = {
+    .name           = "rtc_apollo",
+    .id             = -1,
+    .num_resources  = ARRAY_SIZE(apollo_rtc_resources),
+    .resource       = apollo_rtc_resources,
+};
+
+int __init apollo_init_rtc(void)
+{
+    return platform_device_register(&apollo_rtc_device);
+}
+
+arch_initcall(apollo_init_rtc);
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/sata.c linux-2.6.34/arch/arm/mach-apollo/sata.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/sata.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/sata.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2009 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <mach/pnx8492.h>
+#include <mach/irqs.h>
+#include <linux/delay.h>
+
+/* Level control register */
+#define SATA_HOST_RX_CTRL_REG   (MMIO_SATA_BASE + 0x508)
+
+/* Level control register */
+#define SATA_HOST_LVL_CTRL_REG   (MMIO_SATA_BASE + 0x510)
+
+/* LLC control register */
+#define SATA_HOST_LLC_CTRL_REG   (MMIO_SATA_BASE + 0x600)
+
+/* SATA host CR Port Control Register */
+#define SATA_HOST_CR_CTRL_REG    (MMIO_SATA_BASE + 0x514)
+/* SATA host CR Port Output Register */
+#define SATA_HOST_SR_DOUT_REG    (MMIO_SATA_BASE + 0x518)
+
+/* Global Controller Registers */
+#define HOST_CAP              0x00       /* Host Capabilities */
+#define HOST_PORTS_IMPL       0x0C       /* Bitmap of implemented ports */
+
+/* Host Capability Bits and Bitmaps */
+    /* HOST_CAP_NP (Number of Ports) = bits 0:4
+     *   0x00 : 1 Port
+     *   0x01 : 2 Ports
+     *   0x02 : 3 Ports
+     *   ...etc
+     * Reset Value = AHSATA_NUM_PORTS-1
+     * For Apollo, AHSATA_NUM_PORTS = 2
+     */
+#define HOST_CAP_NP(np)       ((np) << 0)    /* Number of Ports */
+#define HOST_CAP_SXS          (1 << 5)       /* Supports External SATA */
+#define HOST_CAP_EMS          (1 << 6)       /* Enclosure Management support */
+#define HOST_CAP_CCCS         (1 << 7)       /* Command Completion Coelescing Support */
+    /* HOST_CAP_NCS (Number of Command Slots) = bits 8:12
+     *   Supports 32 commands slots per Port
+     * Reset Value = 0x1F
+     */
+#define HOST_CAP_NCS(ncs)     ((ncs) << 8)   /* Number of Command Slots */
+#define HOST_CAP_PSC          (1 << 13)      /* Partial State Capable */
+#define HOST_CAP_SSC          (1 << 14)      /* Slumber State capable */
+#define HOST_CAP_PMD          (1 << 15)      /* PIO Multiple DRQ Block */
+#define HOST_CAP_PMP          (1 << 17)      /* Port Multiplier support */
+#define HOST_CAP_SAM          (1 << 18)      /* Supports AHCI Mode Only */
+#define HOST_CAP_SNZO         (1 << 19)      /* Supports Non-Zero DMA Offets */
+    /* HOST_CAP_ISS (Interface Speed Support) = bits 20:23
+     *   Supports SATA Interface speeds
+     *   1.5 Gb/s = 1
+     *   3.0 Gb/s = 2
+     *   6.0 Gb/s = 3
+     * Reset Value = 2
+     */
+#define HOST_CAP_ISS(iss)     ((iss) << 20)  /* Interface Speed Support */
+#define HOST_CAP_CLO          (1 << 24)      /* Command List Override support */
+#define HOST_CAP_SAL          (1 << 25)      /* Supports Activity LED */
+#define HOST_CAP_ALPM         (1 << 26)      /* Aggressive Link PM support */
+#define HOST_CAP_SSS          (1 << 27)      /* Supports Staggered Spin-up */
+#define HOST_CAP_SMPS         (1 << 28)      /* Supports Mechanical Presense Switch */
+#define HOST_CAP_SNTF         (1 << 29)      /* SNotification register */
+#define HOST_CAP_NCQ          (1 << 30)      /* Native Command Queueing */
+#define HOST_CAP_64           (1 << 31)      /* PCI DAC (64-bit DMA) support */
+
+/* Port Registers */
+#define PORT0_CMD             0x118          /* Port 0 Command Register */
+#define PORT1_CMD             0x198          /* Port 1 Command Register */
+
+/* Port Command Bits and Bitmaps */
+#define PORT_CMD_ESP          (1 << 21)      /* External SATA Port */
+
+/* SATA Clocks */
+#define CLK_SATA_HCLK_CTL     0x308
+#define CLK_SATA_ASIC0_CTL    0x30C
+#define CLK_SATA_ASIC1_CTL    0x310
+#define CLK_SATA_RBC0_CTL     0x314
+#define CLK_SATA_RBC1_CTL     0x318
+#define CLK_SATA_RXOOB_CTL    0x31C
+#define CLK_SATA_PMALIVE_CTL  0x320
+
+/* RGU Registers */
+#define RGU_GRESET1           0x10
+#define RGU_LOCKCMD           0x28
+#define RGU_LOCKSTAT          0x2C
+
+/* RGU LOCKSTAT Bits */
+#define RGU_LOCKSTAT_GRESET   (1 << 1)     /* Global Reset Register lock - 0 to unlock */
+
+/* RGU GRESET1 Bits */
+#define RGU_GRESET1_SATA      (1 << 8)     /* SATA Reset - Active Low */
+
+static u64 sata_dmamask = DMA_BIT_MASK(32);
+
+static struct resource sata_resources[] = {
+	{
+		.start	= MMIO_SATA_BASE,
+		.end	= MMIO_SATA_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_SATA,
+		.end	= IRQ_SATA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device sata_device = {
+	.name	= "sata-apollo",
+	.id	= 0,
+	.dev	= {
+		.platform_data		= NULL,
+		.dma_mask		= &sata_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources	= ARRAY_SIZE(sata_resources),
+	.resource	= sata_resources,
+};
+
+static int apollo_sata_phy_adjust(void)
+{
+   int status = 0;
+   unsigned rd_val = 0, wr_val = 0;
+
+   /* Refer SATA2 PHY data book version: Early Adopter Edition March 31, 2009 
+    * for SATA PHY adjustments. */
+
+   /* Apollo_SoC_PRCR 1133: 
+    * To pass OOB-01 (OOB Signal Level Threshold Level Detect) adjust 
+    * Loss of Signal Detector level los_lvl[9:5] to 10111b for SATA2x as 
+    * recommended in PHY databook section 2.3.5.1 Recommended Rx Settings. */
+   rd_val   = readl(SATA_HOST_LVL_CTRL_REG);
+   wr_val   = rd_val & ~((0x1F)<<5);
+   wr_val  |= ((0x17)<<5);
+   printk(KERN_INFO "SATA: Adjusting los_lvl (rd_val=0x%x, wr_val=0x%x)\n",
+      rd_val, wr_val);
+   writel(wr_val, SATA_HOST_LVL_CTRL_REG);
+
+   /* Apollo_SoC_PRCR 1175: 
+    * Partial/Slumber power modes only if receiver terminations are 
+    * enabled by setting rx_term_en0/1 to 1b as recommended in 
+    * PHY databook section 2.3.2.2 Rx Power Controls. */
+   rd_val   = readl(SATA_HOST_RX_CTRL_REG);
+   wr_val   = rd_val | (1<<1) | (1<<17);
+   printk(KERN_INFO "SATA: Adjusting rx_term_en0/1 (rd_val=0x%x, wr_val=0x%x)\n",
+      rd_val, wr_val);
+   writel(wr_val, SATA_HOST_RX_CTRL_REG);
+
+   return status;
+}
+
+static int __init apollo_sata_init(void)
+{
+   unsigned long capabilities = 0;
+   unsigned long lockstat = 0;
+   unsigned long greset = 0;
+   int status = 0, mask;
+
+   /* Setting up SATA clocks and taking controller out of reset. */
+
+   /* Initialise SATA clocks
+    *  Bit 0   = 0x1; Enable CLK
+    *  Bit 1:2 = 0x1; SRC Clock
+    */
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_HCLK_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_ASIC0_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_ASIC1_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_RBC0_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_RBC1_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_RXOOB_CTL));
+   writel(0x00000003,(MMIO_CLOCK_BASE + CLK_SATA_PMALIVE_CTL));
+
+   /* Unlock the RGU Lock Status register */
+   writel(0x000000F8,(MMIO_CLOCK_BASE + RGU_LOCKCMD));
+   writel(0x0000002B,(MMIO_CLOCK_BASE + RGU_LOCKCMD));
+
+   /* Unlock the Global Reset registers */
+   lockstat = readl(MMIO_CLOCK_BASE + RGU_LOCKSTAT);
+   lockstat &= ~RGU_LOCKSTAT_GRESET;
+   writel(lockstat,(MMIO_CLOCK_BASE + RGU_LOCKSTAT));
+
+   /* Bring SATA out of reset */
+   greset = readl(MMIO_RGU_BASE + RGU_GRESET1);
+   greset &= ~RGU_GRESET1_SATA;
+   writel(greset,(MMIO_RGU_BASE + RGU_GRESET1));
+
+   /* Lock the RGU Lock Status register */
+   writel(0x00000000,(MMIO_CLOCK_BASE + RGU_LOCKCMD));
+
+   /* Adjust SATA PHY */
+   status = apollo_sata_phy_adjust();
+   if (status)
+      return status;
+
+   /* Enhance performance of SATA interface by changing 
+    * the AHB transactions to be bufferable and cacheable. */
+   mask  = readl(SATA_HOST_LLC_CTRL_REG);
+   mask |= 0x40;
+   writel(mask, SATA_HOST_LLC_CTRL_REG);
+
+   /* Initialize SATA capabilities. Reset of system sets this register to 0x0. */
+   capabilities  = ( HOST_CAP_NCQ | HOST_CAP_SNTF | HOST_CAP_ALPM | 
+                     HOST_CAP_SAL | HOST_CAP_CLO  | HOST_CAP_SAM  | 
+                     HOST_CAP_PMP | HOST_CAP_PMD  | HOST_CAP_SSC  | 
+                     HOST_CAP_PSC | HOST_CAP_CCCS | HOST_CAP_SSS  |
+                     HOST_CAP_SXS | HOST_CAP_ISS(0x2) | HOST_CAP_NCS(0x1F) | 
+                     HOST_CAP_NP(0x1));
+   writel(capabilities, (MMIO_SATA_BASE + HOST_CAP));
+
+#ifdef CONFIG_EXECUTE_ON_EMULATOR
+   /* PI = use 1st port (emulator does not have a PHY on 2nd port) */
+   writel(0x00000001,(MMIO_SATA_BASE + HOST_PORTS_IMPL));
+#else
+   /* PI = use both ports */
+   writel(0x00000003,(MMIO_SATA_BASE + HOST_PORTS_IMPL));
+#endif
+   /* SATA Port 1
+    * no HPCP (18), CPD (20), or ESP (21)
+    */
+   writel(0x00000000,(MMIO_SATA_BASE + PORT0_CMD));
+
+   /* SATA Port 1 - Used for eSATA
+    * ESP (21)
+    */
+   writel(PORT_CMD_ESP,(MMIO_SATA_BASE + PORT1_CMD));
+
+   return platform_device_register(&sata_device);
+}
+
+arch_initcall(apollo_sata_init);
+
+MODULE_LICENSE("GPL");
+
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/sfc.c linux-2.6.34/arch/arm/mach-apollo/sfc.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/sfc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/sfc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <mach/sfc.h>
+#include <linux/io.h>
+
+static struct resource apollo_sfc_resources[] = {
+
+   {
+		.start		= APOLLO_SFC_CFG_BASE,
+		.end		= (APOLLO_SFC_CFG_BASE + APOLLO_SFC_CFG_LEN - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static uint64_t apollo_sfc_dma_mask = ~(uint32_t)0;
+static struct platform_device apollo_sfc_device = {
+	.name		= "nx_sfc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(apollo_sfc_resources),
+	.resource	= apollo_sfc_resources,
+	.dev = {
+		.platform_data	= NULL,
+		.dma_mask = &apollo_sfc_dma_mask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+};
+
+static int __init apollo_sfc_init(void)
+{
+   return platform_device_register (&apollo_sfc_device);
+}
+
+arch_initcall(apollo_sfc_init);
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/sleep.S linux-2.6.34/arch/arm/mach-apollo/sleep.S
--- linux-2.6.34.orig/arch/arm/mach-apollo/sleep.S	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/sleep.S	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,830 @@
+
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/memory.h>
+
+#define SCRATCHPAD_BASE_P       0xE06EAD00
+#define SCRATCHPAD_RESTORE_PC_OFFSET 0x74
+#define SCRATCHPAD_RESTORE_PC_LOC          SCRATCHPAD_BASE_P + SCRATCHPAD_RESTORE_PC_OFFSET
+#define SCRATCHPAD_CPU_CONTEXT_LOC_OFFSET 0x70
+#define SCRATCHPAD_CPU_CONTEXT_LOC     SCRATCHPAD_BASE_P + SCRATCHPAD_CPU_CONTEXT_LOC_OFFSET
+#define SCRATCHPAD_REBOOT_INDICATOR 0x6C
+#define SCRATCHPAD_REBOOT_INDICATOR_LOC    SCRATCHPAD_BASE_P + SCRATCHPAD_REBOOT_INDICATOR
+#define SCRATCHPAD_SAVE_REGS_WHEN_MMU_OFF  0x68
+#define SCRATCHPAD_SAVE_REGS_WHEN_MMU_OFF_LOC  SCRATCHPAD_BASE_P + SCRATCHPAD_SAVE_REGS_WHEN_MMU_OFF 
+#define SCRATCHPAD_DEBUG_SAVE 0x00
+#define SCRATCHPAD_DEBUG_SAVE_LOC SCRATCHPAD_BASE_P + SCRATCHPAD_DEBUG_SAVE 
+
+
+	.text
+/* Function call to get the restore pointer for resume from OFF */
+ENTRY(apollo_get_restore_pointer)
+        stmfd   sp!, {lr}     @ save registers on stack
+	adr	r0, restore
+        bic     r0, #PAGE_OFFSET
+        ldmfd   sp!, {pc}     @ restore regs and return
+ENTRY(get_restore_pointer_sz)
+        .word   . - get_restore_pointer_sz
+/*
+ * Forces Apollo into idle state
+ *
+ * apollo_cpu_suspend() - This bit of code just executes the WFI
+ * for normal idles.
+ *
+ * Note: This code get's copied to internal SRAM at boot. When the Apollo
+ *	 wakes up it continues execution at the point it went to sleep.
+ */
+ENTRY(apollo_cpu_suspend)
+	/* stmfd	sp!, {r0-r12, lr} */		@ save registers on stack
+         /* storing the address of regs_save in scratchpad */
+        stmia r0!, {r0-r3}              @ save r0, r1, r2 in offset 0 to 2
+        mov r3, r0
+        sub r0, r0, #0x10                @ get back r0 to regs_save[0] 
+        stmia r3!, {r4-r12, lr}		@ save registers in offset 3 to 19  
+
+        ldr r8, scratchpad_save_regs_mmu_off_loc
+        bic r2, #PAGE_OFFSET
+        str r2, [r8]
+        ldr r7, scratchpad_cpu_context_loc
+        bic r8, r0, #PAGE_OFFSET
+        str r8, [r7]
+#if SCRATCHPAD_SAVE_DEBUG
+         /* storing the restore entry point address in scratchpad. Microloader should jump to this loc  */
+        ldr r7, scratchpad_restore_pc_loc
+        adr r8, restore
+        bic r8, #PAGE_OFFSET
+        str r8, [r7]
+#endif
+loop:
+	/*b	loop*/	@Enable to debug by stepping through code
+	/* r0 contains restore pointer in sdram */
+	/* r1 contains information about saving context */
+
+	cmp	r1, #0x0
+	/* If context save is required, do that and execute wfi */
+	bne	save_context_wfi
+	/* Data memory barrier and Data sync barrier */
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c10, 4
+	mcr	p15, 0, r1, c7, c10, 5
+
+	wfi				@ wait for interrupt
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	ldmfd	sp!, {r0-r12, pc}		@ restore regs and return
+restore:
+	 /*b restore */	@ Enable to debug restore code
+        /* Check what was the reason for mpu reset and store the reason in r9*/
+        /* 1 - Only L1 and logic lost */
+        /* 2 - Only L2 lost - In this case, we wont be here */
+        /* 3 - Both L1 and L2 lost */
+	/*FIXME: Read and tell if we restored from OFF. Ashwin. r2 will carry 3 indicating OFF*/
+
+        setmode PSR_F_BIT | PSR_I_BIT | SVC_MODE
+ 
+	mov     r2, #0x3
+	and     r2, r2, #0x3
+	cmp     r2, #0x0	@ Check if target power state was OFF or RET
+        moveq   r9, #0x3        @ MPU OFF => L1 and L2 lost
+	movne	r9, #0x1	@ Only L1 and L2 lost => avoid L2 invalidation
+	bne	logic_l1_restore
+	/* Execute smi to invalidate L2 cache */
+	mov r12, #0x1                         @ set up to invalide L2
+/*smi:    .word 0xE1600070                @ Call SMI monitor (smieq)*/
+logic_l1_restore:
+	mov	r1, #0
+	/* Invalidate all instruction caches to PoU
+	 * and flush branch target cache */
+	mcr	p15, 0, r1, c7, c5, 0
+
+/*	ldr	r4, scratchpad_base*/
+/*	ldr	r3, [r4,#0xBC]*/
+        /* storing the address os regs_save in scratchpad */
+        /* Uncomment this below line and comment the following two lines 
+         * if u want to restore from scratchpad */
+        /* ldr r12, scratchpad_debug_save_loc */
+        ldr     r1, scratchpad_cpu_context_loc
+        ldr     r12, [r1]
+	mov	r3, r12
+        add r3, #0x78      @ 30th offset onwards 
+
+	ldmia	r3!, {r4-r6}
+	mov	sp, r4
+	msr	spsr_cxsf, r5
+	mov	lr, r6
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x0]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x4]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x8]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xac
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	ldmia	r3!, {r4-r9}
+	/* Coprocessor access Control Register */
+	mcr p15, 0, r4, c1, c0, 2
+
+
+	/* TTBR0 */
+	MCR p15, 0, r5, c2, c0, 0
+	/* TTBR1 */
+	MCR p15, 0, r6, c2, c0, 1
+	/* Translation table base control register */
+	MCR p15, 0, r7, c2, c0, 2
+	/*domain access Control Register */
+	MCR p15, 0, r8, c3, c0, 0
+	/* data fault status Register */
+	MCR p15, 0, r9, c5, c0, 0
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0xc]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x10]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x14]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x18]
+        ldr r12, scratchpad_debug_save_loc
+        str r8, [r12, #0x1c]
+        ldr r12, scratchpad_debug_save_loc
+        str r9, [r12, #0x20]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xad
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	ldmia  r3!,{r4-r8}
+	/* instruction fault status Register */
+	MCR p15, 0, r4, c5, c0, 1
+	/*Data Auxiliary Fault Status Register */
+	MCR p15, 0, r5, c5, c1, 0
+	/*Instruction Auxiliary Fault Status Register*/
+	MCR p15, 0, r6, c5, c1, 1
+	/*Data Fault Address Register */
+	MCR p15, 0, r7, c6, c0, 0
+	/*Instruction Fault Address Register*/
+	MCR p15, 0, r8, c6, c0, 2
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x24]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x28]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x2c]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x30]
+        ldr r12, scratchpad_debug_save_loc
+        str r8, [r12, #0x34]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xae
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	ldmia  r3!,{r4-r7}
+
+	/* user r/w thread and process ID */
+	MCR p15, 0, r4, c13, c0, 2
+	/* user ro thread and process ID */
+	MCR p15, 0, r5, c13, c0, 3
+	/*Privileged only thread and process ID */
+	MCR p15, 0, r6, c13, c0, 4
+	/* cache size selection */
+	MCR p15, 2, r7, c0, c0, 0
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x38]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x3c]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x40]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x44]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+	ldmia  r3!,{r4-r8}
+	/* Data TLB lockdown registers */
+	MCR p15, 0, r4, c10, c0, 0
+	/* Instruction TLB lockdown registers */
+	MCR p15, 0, r5, c10, c0, 1
+	/* Secure or Nonsecure Vector Base Address */
+	MCR p15, 0, r6, c12, c0, 0
+	/* FCSE PID */
+	MCR p15, 0, r7, c13, c0, 0
+	/* Context PID */
+	MCR p15, 0, r8, c13, c0, 1
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x48]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x4c]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x50]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x54]
+        ldr r12, scratchpad_debug_save_loc
+        str r8, [r12, #0x58]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xaf
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	ldmia  r3!,{r4-r5}
+	/* primary memory remap register */
+	MCR p15, 0, r4, c10, c2, 0
+	/*normal memory remap register */
+	MCR p15, 0, r5, c10, c2, 1
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x5c]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x60]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xb0
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	/* Restore cpsr */
+	ldmia	r3!,{r4}	/*load CPSR from SDRAM*/
+	/*msr	cpsr, r4 */	/*store cpsr */
+
+
+	/* Enabling MMU here */
+	mrc	p15, 0, r7, c2, c0, 2 /* Read TTBRControl */
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during restore << */
+	/*Original TTBR in r7 --> sc pad -- 0x64*/
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x64]
+        /* Saving in scratchpad during restore >> */
+#endif
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe0
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+
+	/* Extract N (0:2) bits and decide whether to use TTBR0 or TTBR1*/
+	and	r7, #0x7
+	cmp	r7, #0x0
+	beq	usettbr0
+ttbr_error:
+	/* More work needs to be done to support N[0:2] value other than 0
+	* So looping here so that the error can be detected
+	*/
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe1
+        str r5, [r4]
+        /* Debug >> */
+#endif
+	/* b	ttbr_error */
+        mov r5, #0
+        mcr     p15, 0, r5, c2, c0, 2
+        
+usettbr0:
+	/* b       hack_cont */
+	mrc	p15, 0, r2, c2, c0, 0
+	ldr	r5, ttbrbit_mask
+	and	r2, r5
+	mov	r4, pc
+	ldr	r5, table_index_mask
+	and	r4, r5 /* r4 = 31 to 20 bits of pc */
+	/* Extract the value to be written to table entry */
+	ldr	r1, table_entry
+	add	r1, r1, r4 /* r1 has value to be written to table entry*/
+	/* Getting the address of table entry to modify */
+	lsr	r4, #18
+	add	r2, r4 /* r2 has the location which needs to be modified */
+        ldr     r4, [r2]
+
+	/* Storing previous entry of location being modified */
+        ldr     r5, scratchpad_save_regs_mmu_off_loc
+        ldr     r6, [r5]
+        str     r4, [r6, #0x4]
+	/* Storing previous location being modified */
+        ldr     r5, scratchpad_save_regs_mmu_off_loc
+        ldr     r6, [r5]
+        str     r2, [r6, #0x0] 
+
+
+        /* Modify the table entry */
+        str     r1, [r2]
+
+
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe2
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+
+hack_cont: /*FIXME*/
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 4	@ Flush prefetch buffer
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe4
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	mcr	p15, 0, r0, c7, c5, 6	@ Invalidate branch predictor array
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe5
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	mcr	p15, 0, r0, c8, c5, 0	@ Invalidate instruction TLB
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xe6
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	mcr	p15, 0, r0, c8, c6, 0	@ Invalidate data TLB
+	/* Restore control register  but dont enable caches here*/
+	/* Caches will be enabled after restoring MMU table entry */
+	/*FIXME: removed the loading into r4 here and moved it down.*/
+
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xb1
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+	ldmia	r3!, {r4}
+	ldr	r2, cache_pred_disable_mask 
+
+        /* Storing previous SCTLR.. will be restored back after MMU is switched on */
+        ldr     r5, scratchpad_save_regs_mmu_off_loc
+        ldr     r6, [r5]
+        str     r4, [r6, #0x8] 
+
+	and	r4, r2 
+
+	mov r4, r4
+	mcr	p15, 0, r4, c1, c0, 0
+        nop
+        nop
+        nop
+        mov r0, r0
+	
+
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xb2
+        str r5, [r4]
+        /* Debug >> */
+#endif
+
+        ldr r7, scratchpad_cpu_context_loc
+        ldr r8, [r7]
+        orr r8, #PAGE_OFFSET @MMU is enabled so use VA
+        ldmia r8!, {r0-r1}
+
+#ifdef CONFIG_PM_DEBUG
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0xb3
+        str r5, [r4]
+#endif
+
+        /* Using r1 as it is not used after return. Had to do this as something like ldmia r8, {r0-r8}   
+         * has unpredictable result */
+        mov r1, r8 
+        ldmia r1!, {r2-r12, pc}
+	/* ldmfd	sp!, {r0-r12, pc} */		@ restore regs and return
+save_context_wfi:
+	/*b	save_context_wfi*/	@ enable to debug save code
+	mov	r8, r0 /* Store SDRAM address in r8 */
+        add r8, #0x78    @ 30th offset onwards 
+        /* Check what that target sleep state is:stored in r1*/
+        /* 1 - Only L1 and logic lost */
+        /* 2 - Only L2 lost */
+        /* 3 - Both L1 and L2 lost */
+	cmp	r1, #0x2 /* Only L2 lost */
+	beq	clean_l2
+	cmp	r1, #0x1 /* L2 retained */
+	/* r9 stores whether to clean L2 or not*/
+	moveq	r9, #0x0 /* Dont Clean L2 */
+	movne	r9, #0x1 /* Clean L2 */
+l1_logic_lost:
+	/*FIXME: Using r12 for saving the reg_save pointer - ashwin:*/
+	/* mov	r12, r8 */
+	/* Store sp and spsr to SDRAM */
+	mov	r4, sp
+	mrs	r5, spsr
+	mov	r6, lr
+	stmia	r8!, {r4-r6}
+        
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x0]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x4]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x8]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Save all ARM registers */
+	/* Coprocessor access control register */
+	mrc	p15, 0, r6, c1, c0, 2
+	stmia	r8!, {r6}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0xc]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+
+	/* TTBR0, TTBR1 and Translation table base control */
+	mrc	p15, 0, r4, c2, c0, 0
+	mrc	p15, 0, r5, c2, c0, 1
+	mrc	p15, 0, r6, c2, c0, 2
+	stmia	r8!, {r4-r6}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x10]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x14]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x18]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Domain access control register, data fault status register,
+	and instruction fault status register */
+	mrc	p15, 0, r4, c3, c0, 0
+	mrc	p15, 0, r5, c5, c0, 0
+	mrc	p15, 0, r6, c5, c0, 1
+	stmia	r8!, {r4-r6}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x1c]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x20]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x24]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Data aux fault status register, instruction aux fault status,
+	datat fault address register and instruction fault address register*/
+	mrc	p15, 0, r4, c5, c1, 0
+	mrc	p15, 0, r5, c5, c1, 1
+	mrc	p15, 0, r6, c6, c0, 0
+	mrc	p15, 0, r7, c6, c0, 2
+	stmia	r8!, {r4-r7}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x28]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x2c]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x30]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x34]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* user r/w thread and process ID, user r/o thread and process ID,
+	priv only thread and process ID, cache size selection */
+	mrc	p15, 0, r4, c13, c0, 2
+	mrc	p15, 0, r5, c13, c0, 3
+	mrc	p15, 0, r6, c13, c0, 4
+	mrc	p15, 2, r7, c0, c0, 0
+	stmia	r8!, {r4-r7}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x38]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x3c]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x40]
+        ldr r12, scratchpad_debug_save_loc
+        str r7, [r12, #0x44]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Data TLB lockdown, instruction TLB lockdown registers */
+	mrc	p15, 0, r5, c10, c0, 0
+	mrc	p15, 0, r6, c10, c0, 1
+	stmia	r8!, {r5-r6}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x48]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x4c]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Secure or non secure vector base address, FCSE PID, Context PID*/
+	mrc	p15, 0, r4, c12, c0, 0
+	mrc	p15, 0, r5, c13, c0, 0
+	mrc	p15, 0, r6, c13, c0, 1
+	stmia	r8!, {r4-r6}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x50]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x54]
+        ldr r12, scratchpad_debug_save_loc
+        str r6, [r12, #0x58]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Primary remap, normal remap registers */
+	mrc	p15, 0, r4, c10, c2, 0
+	mrc	p15, 0, r5, c10, c2, 1
+	stmia	r8!,{r4-r5}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r4, [r12, #0x5c]
+        ldr r12, scratchpad_debug_save_loc
+        str r5, [r12, #0x60]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	/* Store current cpsr*/
+	mrs	r2, cpsr
+	stmia	r8!, {r2}
+
+#if SCRATCHPAD_SAVE_DEBUG
+        /* Saving in scratchpad during suspend << */
+        ldr r12, scratchpad_debug_save_loc
+        str r2, [r12, #0x64]
+        /* Saving in scratchpad during suspend >> */
+#endif
+
+	mrc	p15, 0, r4, c1, c0, 0
+	/* save control register */
+	stmia	r8!, {r4}
+
+
+clean_caches:
+	/* Clean Data or unified cache to POU*/
+	/* How to invalidate only L1 cache???? - #FIX_ME# */
+	/* mcr	p15, 0, r11, c7, c11, 1 */
+	cmp	r9, #1 /* Check whether L2 inval is required or not*/
+	bne	skip_l2_inval
+clean_l2:
+	/* read clidr */
+	mrc     p15, 1, r0, c0, c0, 1
+	/* extract loc from clidr */
+	ands    r3, r0, #0x7000000
+	/* left align loc bit field */
+	mov     r3, r3, lsr #23
+	/* if loc is 0, then no need to clean */
+	beq     finished
+	/* start clean at cache level 0 */
+	mov     r10, #0
+loop1:
+	/* work out 3x current cache level */
+	add     r2, r10, r10, lsr #1
+	/* extract cache type bits from clidr*/
+	mov     r1, r0, lsr r2
+	/* mask of the bits for current cache only */
+	and     r1, r1, #7
+	/* see what cache we have at this level */
+	cmp     r1, #2
+	/* skip if no cache, or just i-cache */
+	blt     skip
+	/* select current cache level in cssr */
+	mcr     p15, 2, r10, c0, c0, 0
+	/* isb to sych the new cssr&csidr */
+	isb
+	/* read the new csidr */
+	mrc     p15, 1, r1, c0, c0, 0
+	/* extract the length of the cache lines */
+	and     r2, r1, #7
+	/* add 4 (line length offset) */
+	add     r2, r2, #4
+	ldr     r4, assoc_mask
+	/* find maximum number on the way size */
+	ands    r4, r4, r1, lsr #3
+	/* find bit position of way size increment */
+	clz     r5, r4
+	ldr     r7, numset_mask
+	/* extract max number of the index size*/
+	ands    r7, r7, r1, lsr #13
+loop2:
+	mov     r9, r4
+	/* create working copy of max way size*/
+loop3:
+	/* factor way and cache number into r11 */
+	orr     r11, r10, r9, lsl r5
+	/* factor index number into r11 */
+	orr     r11, r11, r7, lsl r2
+	/*clean & invalidate by set/way */
+        /* Ranjith -- Modified the below line */
+	/* mcr     p15, 0, r11, c7, c10, 2 */
+        mcr     p15, 0, r11, c7, c14, 2         @ clean & invalidate by set/way
+	/* decrement the way*/
+	subs    r9, r9, #1
+	bge     loop3
+	/*decrement the index */
+	subs    r7, r7, #1
+	bge     loop2
+skip:
+	add     r10, r10, #2
+	/* increment cache number */
+	cmp     r3, r10
+	bgt     loop1
+finished:
+	/*swith back to cache level 0 */
+	mov     r10, #0
+	/* select current cache level in cssr */
+	mcr     p15, 2, r10, c0, c0, 0
+        /* Ranjith -- Added the below line */
+        dsb
+	isb
+        mcr     p15, 0, r10, c7, c5, 0           @ I+BTB cache invalidate
+
+skip_l2_inval:
+	/* Data memory barrier and Data sync barrier */
+	mov     r1, #0
+	mcr     p15, 0, r1, c7, c10, 4
+	mcr     p15, 0, r1, c7, c10, 5
+
+/* 
+	wfi                             @ wait for interrupt
+*/
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+#ifdef CONFIG_PM_DEBUG
+        /* Debug << */
+        ldr r4, scratchpad_reboot_indicator_loc
+        mov r5, #0x88
+        str r5, [r4]
+        /* Debug >> */
+#endif
+	/* restore regs and return */
+        ldr r7, scratchpad_cpu_context_loc
+        ldr r8, [r7]
+        orr r8, #PAGE_OFFSET @MMU is enabled so use VA
+        ldmia r8!, {r0-r4}
+	mov r1, #0x5
+	str r1, [r3]
+        /* Using r1 as it is not used after return. Had to do this as something like ldmia r8, {r0-r8}   
+         * has unpredictable result */
+        mov r1, r8
+        /*b . */
+        ldmia r1!, {r5-r12, pc}
+
+	/* ldmfd   sp!, {r0-r11} 
+	mov r1, #0x5
+	str r1, [r3]
+	ldmfd   sp!, {r12, pc} */
+
+assoc_mask:
+	.word	0x3ff
+numset_mask:
+	.word	0x7fff
+ttbrbit_mask:
+	.word	0xFFFFC000
+table_index_mask:
+	.word	0xFFF00000
+table_entry:
+	.word	0x00000C02
+cache_pred_disable_mask:
+	.word	0xFFFFE7FB
+scratchpad_cpu_context_loc:
+        .word   SCRATCHPAD_CPU_CONTEXT_LOC 
+scratchpad_restore_pc_loc:
+        .word   SCRATCHPAD_RESTORE_PC_LOC        
+scratchpad_reboot_indicator_loc:
+        .word   SCRATCHPAD_REBOOT_INDICATOR_LOC
+scratchpad_debug_save_loc:
+        .word   SCRATCHPAD_DEBUG_SAVE_LOC 
+scratchpad_save_regs_mmu_off_loc:
+        .word   SCRATCHPAD_SAVE_REGS_WHEN_MMU_OFF_LOC  
diff -Naurp linux-2.6.34.orig/arch/arm/mach-apollo/splash_logo.c linux-2.6.34/arch/arm/mach-apollo/splash_logo.c
--- linux-2.6.34.orig/arch/arm/mach-apollo/splash_logo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/mach-apollo/splash_logo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd.
+ *
+ * All prior copyright rights in this work and the accompanying software
+ * products transferred to Trident Microsystems (Far East) Ltd. by written
+ * agreement.  All rights reserved.
+ *
+ *
+ *   name:          splash_logo.c
+ *   version:
+ *   date_modified: Jun 17, 2010
+ *   derived_by:    ddouglass
+ */
+
+#include <linux/init.h>
+#include <asm/io.h>
+#include <mach/splash_logo.h>
+#include <mach/apollo_logo.h>
+
+#define APOLLO_MMIO_BASE_ADDR (0xE0600000)
+#define APOLLO_CGU_BASE     (APOLLO_MMIO_BASE_ADDR + 0x0E7000)
+#define APOLLO_GBL_REG_BASE (APOLLO_MMIO_BASE_ADDR + 0x0EA000)
+#define APOLLO_CPIPE_BASE   (APOLLO_MMIO_BASE_ADDR + 0x120000)
+#define APOLLO_HDMI_TX_BASE (APOLLO_MMIO_BASE_ADDR + 0x179000)
+#define APOLLO_DENC_BASE    (APOLLO_MMIO_BASE_ADDR + 0x17B000)
+
+#define APOLLO_VARI_FORMAT_ARGB 0xfff7efe7
+#define APOLLO_VARI_FORMAT_ABGR 0xffe7eff7
+
+#define XRES 720
+#define YRES 480
+
+extern u32 __initdata uVRAMHD_start;
+
+void __init apollo_splash( void )
+{
+   int i, line_pixel, line;
+   u32 __iomem * pVRAMhd_base = ioremap_nocache(uVRAMHD_start, (XRES * YRES * 4));
+   u32 __iomem * pInc;
+   unsigned char pixel_data[3];
+
+   /* HD DENC programming (HD-480p raster) */
+   writel( 0x00000001, (APOLLO_DENC_BASE + 0x120)); /* DENC csc sel  - YCbCr out */
+   writel( 0x00000104, (APOLLO_DENC_BASE + 0x104)); /* DENC raster   -  eactive & 480p */
+   writel( 0x0000035a, (APOLLO_DENC_BASE + 0x108)); /* DENC Htotal */
+   writel( 0x02d0007a, (APOLLO_DENC_BASE + 0x10c)); /* DENC HActive */
+   writel( 0x01e00024, (APOLLO_DENC_BASE + 0x110)); /* DENC Vertical timing */
+   writel( 0x0000003f, (APOLLO_DENC_BASE + 0x00c)); /* DENC enable dacs - enable all the 6 DACs */
+   writel( 0x00000201, (APOLLO_DENC_BASE + 0x010)); /* DENC  {CBA} dac selection - {rpr, bpb, gy} */
+   writel( 0x00050603, (APOLLO_DENC_BASE + 0x014)); /* DENC  {FED} dac selection - all cvbs for initial validation */
+   writel( 0x00000000, (APOLLO_DENC_BASE + 0x180)); /* DENC Sync Control- don't invert Odd/even signal */
+
+   /* DENC programming (SD - 480i) */
+   writel( 0x00000110, (APOLLO_DENC_BASE + 0x304)); /* DENC raster   - enable bits eactive & 480i(NTSC) */
+   writel( 0x000006b4, (APOLLO_DENC_BASE + 0x308)); /* DENC Htotal */
+   writel( 0x05a00104, (APOLLO_DENC_BASE + 0x30c)); /* DENC HActive (orig - 0x0590010c) */
+   writel( 0x00f00013, (APOLLO_DENC_BASE + 0x310)); /* DENC Vertical timing */
+   writel( 0x007e9054, (APOLLO_DENC_BASE + 0x318)); /* DENC analog timing */
+   writel( 0x0085e574, (APOLLO_DENC_BASE + 0x324)); /* DENC amplitude */
+   writel( 0x009b86bd, (APOLLO_DENC_BASE + 0x328)); /* DENC YUV MULT */
+   writel( 0x80a4f000, (APOLLO_DENC_BASE + 0x32c)); /* DENC YALT Luma control reg */
+   writel( 0x21f07c1f, (APOLLO_DENC_BASE + 0x330)); /* DENC secam reg */
+   writel( 0x029d3000, (APOLLO_DENC_BASE + 0x380)); /* DENC Sync Control- don't invert Odd/even signal */
+
+   /* Disable SD DENC to supply syncs to HD CPIPE: */
+   writel( 0x00000000, (APOLLO_DENC_BASE + 0x008));
+   writel( 0x00000000, (APOLLO_DENC_BASE + 0x394)); /* Macrovision OFF */
+   writel( 0x00000000, (APOLLO_DENC_BASE + 0x194)); /* Macrovision OFF */
+
+   /* DAC0 Programming (Component DACs) */
+   writel( 0x0011c00e, (APOLLO_GBL_REG_BASE + 0x8fc)); /*VDAC0_CTRL0 */
+   writel( 0x52201712, (APOLLO_GBL_REG_BASE + 0x900)); /*VDAC0_CTRL1 */
+   writel( 0x00000ff0, (APOLLO_GBL_REG_BASE + 0x904)); /*VDAC0_CTRL2 */
+   writel( 0x00000124, (APOLLO_GBL_REG_BASE + 0x908)); /*VDAC0_CTRL3 source from MPEG0 PLL */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x90c)); /*VDAC0_CTRL4 71-->70-->71 */
+   writel( 0x3f000070, (APOLLO_GBL_REG_BASE + 0x90c)); /*VDAC0_CTRL4 71-->70-->71 */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x90c)); /*VDAC0_CTRL4 71-->70-->71 */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x910)); /*VDAC0_TEST_CTRL */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x914)); /*VDAC0_DTO_INCR0 */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x918)); /*VDAC0_DTO_INCR1 */
+
+   /* DAC1 Programming (SD - 480i) */
+   writel( 0x0011c00e, (APOLLO_GBL_REG_BASE + 0x920)); /*VDAC1_CTRL0 */
+   writel( 0x52201712, (APOLLO_GBL_REG_BASE + 0x924)); /*VDAC1_CTRL1 */
+   writel( 0x00000ff0, (APOLLO_GBL_REG_BASE + 0x928)); /*VDAC1_CTRL2 */
+   writel( 0x00000124, (APOLLO_GBL_REG_BASE + 0x92c)); /*VDAC1_CTRL3 source from MPEG0 PLL */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x930)); /*VDAC1_CTRL4 71-->70-->71 */
+   writel( 0x3f000070, (APOLLO_GBL_REG_BASE + 0x930)); /*VDAC1_CTRL4 71-->70-->71 */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x930)); /*VDAC1_CTRL4 71-->70-->71 */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x934)); /*VDAC1_TEST_CTRL */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x938)); /*VDAC1_DTO_INCR0 */
+   writel( 0x00000000, (APOLLO_GBL_REG_BASE + 0x93c)); /*VDAC1_DTO_INCR1 */
+
+   /******  Set up the DAC and CPIPE clocks */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x658)); /* vdac0_sel -- 74.25MHz mpg0 pll */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x65c)); /* vdac1_sel -- 74.25MHz */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x660)); /* vdac2_sel -- 74.25MHz */
+
+/* vdacs 3,4 and 5 are always Mpeg0 PLL, 74.25 MHz */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x664)); /* vdac3_sel -- 74.25MHz mpg0 pll */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x668)); /* vdac4_sel -- 74.25MHz */
+   writel( 0x00000002, (APOLLO_CGU_BASE + 0x66c)); /* vdac5_sel -- 74.25MHz */
+   writel( 0x00000005, (APOLLO_CGU_BASE + 0x640)); /* VCGEN_G1SEL -- 27MHz, MPG0 PLL */
+   writel( 0x00000004, (APOLLO_CGU_BASE + 0x644)); /* VCGEN_G2SEL -- 54MHz, MPG0 PLL */
+   writel( 0x00000006, (APOLLO_CGU_BASE + 0x648)); /* VCGEN_G3SEL -- 27MHz, MPG0 PLL */
+   writel( 0x00000005, (APOLLO_CGU_BASE + 0x64c)); /* VCGEN_G4SEL -- 13.5MHz, MPG0 PLL */
+   writel( 0x00000006, (APOLLO_CGU_BASE + 0x650)); /* VCGEN_G5SEL -- 27MHz, MPG0 PLL */
+   writel( 0x00000000, (APOLLO_CGU_BASE + 0x654)); /* VCGEN_G6SEL -- 27MHz, MPG0 PLL */
+
+   /* CPIPE Sync Timing Generator settings */
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x8000)); /* progressive */
+   writel( 0x00000f33, (APOLLO_CPIPE_BASE + 0x8040)); /* enable STG + f,h,v inputs, invert f,h,v */
+   writel( 0x0359020c, (APOLLO_CPIPE_BASE + 0x8044)); /* 858 wide, 525 tall */
+   writel( 0x03580087, (APOLLO_CPIPE_BASE + 0x8048)); /* blank from 0x34a to 0x79 */
+   writel( 0x02090028, (APOLLO_CPIPE_BASE + 0x804c)); /* blank from line 0x20a to 0x29 */
+   writel( 0x000c0021, (APOLLO_CPIPE_BASE + 0x8050)); /* hsync */
+   writel( 0x00050007, (APOLLO_CPIPE_BASE + 0x8054)); /* vsync (not used) */
+   writel( 0x00000012, (APOLLO_CPIPE_BASE + 0x8058)); /* vsync starts at (APOLLO_CPIPE_BASE + 0x horiz */
+   writel( 0x00000012, (APOLLO_CPIPE_BASE + 0x805c)); /* vsync ends at (APOLLO_CPIPE_BASE + 0x */
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x8060));
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x8064));
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x8068)); /* ext h sets hctr to 0x25, ext v sets vctr to 2 */
+   writel( 0x000e004b, (APOLLO_CPIPE_BASE + 0x8094)); /* hsync for hdmi starts at 1 ends at 0x3e */
+   writel( 0x0005000a, (APOLLO_CPIPE_BASE + 0x8098)); /* 6 lines wide hdmi vsync */
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x809c));
+   writel( 0x0000000e, (APOLLO_CPIPE_BASE + 0x80a0)); /* hdmi vsync starts at 14 horiz count */
+   writel( 0x0000000e, (APOLLO_CPIPE_BASE + 0x80a4)); /* vsync ends, ditto */
+   writel( 0x030f0002, (APOLLO_CPIPE_BASE + 0x94e0)); /* !hsync, !vsync, blank, odd/even to HD DENC */
+   writel( 0x070f0002, (APOLLO_CPIPE_BASE + 0x98e0)); /* hsync, vsync, !blank, odd/even to HDMI */
+
+   /* SD CPIPE Sync Timing Generator settings */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x4000)); /* interlaced */
+   writel( 0x00000033, (APOLLO_CPIPE_BASE + 0x4040)); /* enable STG + f input only */
+   writel( 0x03590106, (APOLLO_CPIPE_BASE + 0x4044)); /* 858 wide, 263 tall */
+   writel( 0x03590088, (APOLLO_CPIPE_BASE + 0x4048)); /* h blank */
+   writel( 0x01040013, (APOLLO_CPIPE_BASE + 0x404c)); /* v blank odd */
+   writel( 0x00070010, (APOLLO_CPIPE_BASE + 0x4050)); /* hsync from 7 to 16 */
+   writel( 0x00050007, (APOLLO_CPIPE_BASE + 0x4054)); /* vsync from 5 to 7 odd (not used) */
+   writel( 0x01ae0001, (APOLLO_CPIPE_BASE + 0x4058)); /* vsync starts at 1 horiz */
+   writel( 0x01ae0001, (APOLLO_CPIPE_BASE + 0x405c)); /* vsync ends at 1 */
+   writel( 0x01040013, (APOLLO_CPIPE_BASE + 0x4060)); /* v blank even */
+   writel( 0x00050007, (APOLLO_CPIPE_BASE + 0x4064)); /* vsync from 5 to 7 even (not used) */
+   writel( 0x00000000, (APOLLO_CPIPE_BASE + 0x4068)); /* ext f sets h and v to 0 */
+   writel( 0x02060002, (APOLLO_CPIPE_BASE + 0x54e0)); /* !hsync, blank to SD DENC */
+
+   /* Bypass SD Out CSC */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x5690)); /* Bypass DS Out CSC */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x5400)); /* cause above to take effect on next shadow reload cycle */
+
+   /* Bypass DENC CSC */
+   writel( 0x00000000, (APOLLO_DENC_BASE + 0x120)); /* Bypass DENC CSC */
+
+   /* Set up the formatting PLL - programmed thru the HDMI I/F - and the serializer PLL */
+   writel( 0x00000003, (APOLLO_CGU_BASE + 0x2fc));     /* Enable TMDS clock for HDMI */
+   writel( 0x00000020, (APOLLO_CGU_BASE + 0x11c));     /* PLL_HDMI_CON3_CTL - use MPG0 PLL for Fmt PLL Source */
+   writel( 0x80000002, (APOLLO_CGU_BASE + 0x110));     /* PLL_HDMI_CON0_CTL - use HDMI register I/F rather than direct I/F */
+   writel( 0x0102040a, (APOLLO_HDMI_TX_BASE + 0x034)); /* FMT_PLL_SETTINGS - 480i, 480p */
+   writel( 0x00000203, (APOLLO_HDMI_TX_BASE + 0x030)); /* SER_PLL_SETTINGS - 480i, 480p (27 MHz) */
+   writel( 0x00000100, (APOLLO_HDMI_TX_BASE + 0x038)); /* PHY_CTRL - apply the pll settings */
+   writel( 0x00000130, (APOLLO_HDMI_TX_BASE + 0x038)); /* PHY_CTRL */
+   writel( 0x00000100, (APOLLO_HDMI_TX_BASE + 0x038)); /* PHY_CTRL */
+
+   /* HDMI programming */
+   writel( 0x0000003f, (APOLLO_HDMI_TX_BASE + 0x038));
+   writel( 0x00012761, (APOLLO_HDMI_TX_BASE + 0x044));
+   writel( 0xffffffff, (APOLLO_HDMI_TX_BASE + 0x4d8));
+   writel( 0xffffffff, (APOLLO_HDMI_TX_BASE + 0x4e8));
+   writel( 0x00100000, (APOLLO_HDMI_TX_BASE + 0x4dc));
+   writel( 0x00100000, (APOLLO_HDMI_TX_BASE + 0x4e8));
+   writel( 0x00080000, (APOLLO_HDMI_TX_BASE + 0x4dc));
+   writel( 0x00080000, (APOLLO_HDMI_TX_BASE + 0x4e8));
+   writel( 0x00040100, (APOLLO_HDMI_TX_BASE + 0x038));
+   writel( 0x00180000, (APOLLO_HDMI_TX_BASE + 0x4d8));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x4dc));
+   writel( 0x42000510, (APOLLO_HDMI_TX_BASE + 0x000));
+   writel( 0x42000410, (APOLLO_HDMI_TX_BASE + 0x000));
+   writel( 0x31000009, (APOLLO_HDMI_TX_BASE + 0x400));
+   writel( 0x00000016, (APOLLO_HDMI_TX_BASE + 0x404));
+   writel( 0x000a0184, (APOLLO_HDMI_TX_BASE + 0x180));
+   writel( 0x00000170, (APOLLO_HDMI_TX_BASE + 0x184));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x188));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x18c));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x300));
+   writel( 0x00000004, (APOLLO_HDMI_TX_BASE + 0x304));
+   writel( 0x10006978, (APOLLO_HDMI_TX_BASE + 0x308));
+   writel( 0x00001800, (APOLLO_HDMI_TX_BASE + 0x30c));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x314));
+   writel( 0x00000001, (APOLLO_HDMI_TX_BASE + 0x0a8)); /* format 1 for 480p59 */
+   writel( 0x00080013, (APOLLO_HDMI_TX_BASE + 0x0ac)); /* ext h sets hctr to 0x13, ext v sets vctr to 8 */
+   writel( 0x00003000, (APOLLO_HDMI_TX_BASE + 0x0d4));
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x0d8));
+   writel( 0x00010800, (APOLLO_HDMI_TX_BASE + 0x0e0));
+   writel( 0x04020200, (APOLLO_HDMI_TX_BASE + 0x0e4));
+   writel( 0x00000004, (APOLLO_HDMI_TX_BASE + 0x0e8));
+   writel( 0x91c1c240, (APOLLO_HDMI_TX_BASE + 0x0ec));
+
+   /*----------------------- Calibrate VDAC's ----------------------*/
+   writel( 0x0009c00e, (APOLLO_GBL_REG_BASE + 0x8fc)); /*reset VDAC0 */
+   writel( 0x0009c00e, (APOLLO_GBL_REG_BASE + 0x920)); /*reset VDAC1 */
+   writel( 0x0019f60e, (APOLLO_GBL_REG_BASE + 0x8fc)); /*VDAC0_CTRL0 30 MHz power */
+   writel( 0x0019f60e, (APOLLO_GBL_REG_BASE + 0x920)); /*VDAC1_CTRL0 30 MHz power */
+   writel( 0x52201750, (APOLLO_GBL_REG_BASE + 0x900)); /*VDAC0_CTRL1 */
+   writel( 0x52201750, (APOLLO_GBL_REG_BASE + 0x924)); /*VDAC1_CTRL1 */
+   writel( 0x52201752, (APOLLO_GBL_REG_BASE + 0x900)); /*VDAC0_CTRL1 */
+   writel( 0x52201752, (APOLLO_GBL_REG_BASE + 0x924)); /*VDAC1_CTRL1 */
+   writel( 0x3f000070, (APOLLO_GBL_REG_BASE + 0x90c)); /*VDAC0_CTRL4 70-->71 */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x90c));
+   writel( 0x3f000070, (APOLLO_GBL_REG_BASE + 0x930)); /*VDAC1_CTRL4 70-->71 */
+   writel( 0x3f000071, (APOLLO_GBL_REG_BASE + 0x930));
+
+   /*** Put the splash screen in memory ***/
+   pInc = pVRAMhd_base;
+   /* Clear the buffer to a white background. */
+   for ( i=0; i<(XRES * YRES); i++)
+   {
+      writel( 0xffffffff, pInc);
+      pInc++;
+   }
+   /* Calculate Address to begin write. */
+   pInc = (u32 *)((u32)pVRAMhd_base + ((XRES * ( (YRES - logo_height) / 2 ) * 4 )));
+   for ( line = 0; line< logo_height; line++)
+   {
+      pInc += (XRES - logo_width) / 2;
+      for ( line_pixel = 0; line_pixel< logo_width; line_pixel++)
+      {
+         HEADER_PIXEL(header_data, pixel_data)
+         *pInc = 0xff000000 + (pixel_data[2] << 16) + (pixel_data[1] << 8) + pixel_data[0];
+         pInc++;
+      }
+      pInc += (XRES - logo_width) / 2;
+   }
+
+   /* set up RIF on GFX layer 1 */
+   writel( 0xa000001f, (APOLLO_CPIPE_BASE + 0x8c44)); /* 32 bit variable width */
+   writel( APOLLO_VARI_FORMAT_ARGB, (APOLLO_CPIPE_BASE + 0x8c48)); /* 32 bit variable width */
+   writel( 0x80500027, (APOLLO_CPIPE_BASE + 0x8c54)); /* start DMA at line 8 pixel 0x90 */
+   writel( 0x00000b3f, (APOLLO_CPIPE_BASE + 0x8c5c)); /* width is 719 pels */
+   writel( uVRAMHD_start, (APOLLO_CPIPE_BASE + 0x8c64)); /* data is located at 0xb10000 */
+   writel( 0x00000b40, (APOLLO_CPIPE_BASE + 0x8c6c)); /* stride is 720*4 */
+   writel( 0x00000b40, (APOLLO_CPIPE_BASE + 0x8c70)); /* stride is 720*4 */
+   writel( 0x00000b40, (APOLLO_CPIPE_BASE + 0x8c84)); /* stride is 720*4 */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x8d90)); /* bypass alpha multi */
+
+   /* hdmi Mixer */
+   writel( 0xffff0000, (APOLLO_CPIPE_BASE + 0x8db0)); /* alpha blend enable */
+   writel( 0x000003fc, (APOLLO_CPIPE_BASE + 0x8db8)); /* per pixel alpha */
+
+   /* denc Mixer */
+   writel( 0xffff0000, (APOLLO_CPIPE_BASE + 0x8dd0)); /* alpha blend enable */
+   writel( 0x000003fc, (APOLLO_CPIPE_BASE + 0x8dd8)); /* per pixel alpha */
+
+   /* Set up HD layer */
+   writel( 0x01e002d0, (APOLLO_CPIPE_BASE + 0x8c04)); /* width and height */
+   writel( 0x01e002d0, (APOLLO_CPIPE_BASE + 0x8c08)); /* width and height */
+   writel( 0x00880028, (APOLLO_CPIPE_BASE + 0x8c10)); /* h and v start position */
+   writel( 0x00000002, (APOLLO_CPIPE_BASE + 0x8c20)); /* enable crop */
+   writel( 0x02d001e0, (APOLLO_CPIPE_BASE + 0x8c28)); /* pix dim after crop */
+   writel( 0x00000006, (APOLLO_CPIPE_BASE + 0x8c34)); /* crop enable match STG field */
+
+   /* GFX VCBM*/
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x8e90)); /* Bypass GFX VCBM */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x8c00)); /* apply settings to layer */
+
+   /* GNSH Settings */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x94a0)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x94a4)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x94a8)); /* Turn off MSB inversion */
+   writel( 0x00000004, (APOLLO_CPIPE_BASE + 0x94b0)); /* Turn off MSB inversion */
+   writel( 0x00000007, (APOLLO_CPIPE_BASE + 0x94b4)); /* Turn off MSB inversion */
+
+   /* Set up color space conversions  RGB255 -> 601 */
+   writel( 0x00000016, (APOLLO_CPIPE_BASE + 0x9690)); /* width and height */
+   writel( 0x020e0408, (APOLLO_CPIPE_BASE + 0x9694)); /* width and height */
+   writel( 0x00c91ed0, (APOLLO_CPIPE_BASE + 0x9698)); /* width and height */
+   writel( 0x1dac0384, (APOLLO_CPIPE_BASE + 0x969c)); /* width and height */
+   writel( 0x03841d0f, (APOLLO_CPIPE_BASE + 0x96a0)); /* width and height */
+   writel( 0x1f6e0000, (APOLLO_CPIPE_BASE + 0x96a4)); /* width and height */
+   writel( 0x00400000, (APOLLO_CPIPE_BASE + 0x96a8)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x96ac)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x96b0)); /* width and height */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x9400)); /* width and height */
+
+   /* HDMI AVI Infoframe */
+   writel( 0x000d0282, (APOLLO_HDMI_TX_BASE + 0x140));
+   writel( 0x005840D5, (APOLLO_HDMI_TX_BASE + 0x144));
+   writel( 0x00000002, (APOLLO_HDMI_TX_BASE + 0x148)); /* format = 2 */
+   writel( 0x00000000, (APOLLO_HDMI_TX_BASE + 0x14c));
+   writel( 0x00001403, (APOLLO_HDMI_TX_BASE + 0x310));
+
+   /* HDMI GNSH Settings */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x98a0)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x98a4)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x98a8)); /* Turn off MSB inversion */
+   writel( 0x00000004, (APOLLO_CPIPE_BASE + 0x98b0)); /* Turn off MSB inversion */
+   writel( 0x00000007, (APOLLO_CPIPE_BASE + 0x98b4)); /* Turn off MSB inversion */
+
+   /* HDMI OUTC */
+   writel( 0x04080200, (APOLLO_CPIPE_BASE + 0x98c0));    /* For CPIPE-HDMI */
+   writel( 0x030f0002, (APOLLO_CPIPE_BASE + 0x98e0));    /* For CPIPE-HDMI RGB match */
+   writel( 0x000fff00, (APOLLO_CPIPE_BASE + 0x98e4));    /* For CPIPE-HDMI RGB match */
+   writel( 0x000fff00, (APOLLO_CPIPE_BASE + 0x98e8));    /* For CPIPE-HDMI RGB match */
+
+   /* HDMI Set up color space conversions  RGB255 -> 601 */
+   writel( 0x00000016, (APOLLO_CPIPE_BASE + 0x9a90)); /* width and height */
+   writel( 0x020e0408, (APOLLO_CPIPE_BASE + 0x9a94)); /* width and height */
+   writel( 0x00c91ed0, (APOLLO_CPIPE_BASE + 0x9a98)); /* width and height */
+   writel( 0x1dac0384, (APOLLO_CPIPE_BASE + 0x9a9c)); /* width and height */
+   writel( 0x03841d0f, (APOLLO_CPIPE_BASE + 0x9aa0)); /* width and height */
+   writel( 0x1f6e0000, (APOLLO_CPIPE_BASE + 0x9aa4)); /* width and height */
+   writel( 0x00400000, (APOLLO_CPIPE_BASE + 0x9aa8)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x9aac)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x9ab0)); /* width and height */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x9800)); /* width and height */
+
+   /* set up SD RIF for GFX */
+   writel( 0xa000001f,              (APOLLO_CPIPE_BASE + 0x4c44)); /* 32 bit variable width */
+   writel( APOLLO_VARI_FORMAT_ARGB, (APOLLO_CPIPE_BASE + 0x4c48)); /* 32 bit variable width */
+   writel( 0x80500013,              (APOLLO_CPIPE_BASE + 0x4c54)); /* start DMA at line 8 pixel 0x90 */
+   writel( 0x00000b3f,              (APOLLO_CPIPE_BASE + 0x4c5c)); /* width is 719 pels */
+   writel( uVRAMHD_start,           (APOLLO_CPIPE_BASE + 0x4c64)); /* Buffer A Address */
+   writel( uVRAMHD_start + 0xb40,   (APOLLO_CPIPE_BASE + 0x4c68)); /* Buffer B Address */
+   writel( 0x00001680,              (APOLLO_CPIPE_BASE + 0x4c6c)); /* stride is 720*4 */
+   writel( 0x00001680,              (APOLLO_CPIPE_BASE + 0x4c70)); /* stride is 720*4 */
+   writel( 0x00001680,              (APOLLO_CPIPE_BASE + 0x4c84)); /* stride is 720*4 */
+   writel( 0x00000001,              (APOLLO_CPIPE_BASE + 0x4d90)); /* bypass alpha multi */
+
+   /* Setup SD layer */
+   writel( 0x00f002d0, (APOLLO_CPIPE_BASE + 0x4c04)); /* width and height */
+   writel( 0x00f002d0, (APOLLO_CPIPE_BASE + 0x4c08)); /* width and height */
+   writel( 0x00880014, (APOLLO_CPIPE_BASE + 0x4c10)); /* h and v start position */
+   writel( 0x00000002, (APOLLO_CPIPE_BASE + 0x4c20)); /* enable crop */
+   writel( 0x02d000f0, (APOLLO_CPIPE_BASE + 0x4c28)); /* pix dim after crop */
+   writel( 0x00000006, (APOLLO_CPIPE_BASE + 0x4c34)); /* crop enable match STG field */
+
+   /* GFX VCBM */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x4e90)); /* Bypass GFX VCBM */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x4c00)); /* apply settings to layer */
+
+   /* GNSH Settings */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x54a0)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x54a4)); /* Turn off MSB inversion */
+   writel( 0x00000010, (APOLLO_CPIPE_BASE + 0x54a8)); /* Turn off MSB inversion */
+   writel( 0x00000004, (APOLLO_CPIPE_BASE + 0x54b0)); /* Turn off MSB inversion */
+   writel( 0x00000007, (APOLLO_CPIPE_BASE + 0x54b4)); /* Turn off MSB inversion */
+
+   /* Set up color space conversions  RGB255 -> 601 */
+   writel( 0x00000016, (APOLLO_CPIPE_BASE + 0x5690)); /* width and height */
+   writel( 0x020e0408, (APOLLO_CPIPE_BASE + 0x5694)); /* width and height */
+   writel( 0x00c91ed0, (APOLLO_CPIPE_BASE + 0x5698)); /* width and height */
+   writel( 0x1dac0384, (APOLLO_CPIPE_BASE + 0x569c)); /* width and height */
+   writel( 0x03841d0f, (APOLLO_CPIPE_BASE + 0x56a0)); /* width and height */
+   writel( 0x1f6e0000, (APOLLO_CPIPE_BASE + 0x56a4)); /* width and height */
+   writel( 0x00400000, (APOLLO_CPIPE_BASE + 0x56a8)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x56ac)); /* width and height */
+   writel( 0x02000000, (APOLLO_CPIPE_BASE + 0x56b0)); /* width and height */
+   writel( 0x00000001, (APOLLO_CPIPE_BASE + 0x5400)); /* width and height */
+
+   iounmap(pVRAMhd_base);
+
+   return;
+}
diff -Naurp linux-2.6.34.orig/arch/arm/Makefile linux-2.6.34/arch/arm/Makefile
--- linux-2.6.34.orig/arch/arm/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/arch/arm/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -178,6 +178,7 @@ machine-$(CONFIG_ARCH_VERSATILE)	:= vers
 machine-$(CONFIG_ARCH_W90X900)		:= w90x900
 machine-$(CONFIG_ARCH_NUC93X)		:= nuc93x
 machine-$(CONFIG_FOOTBRIDGE)		:= footbridge
+machine-$(CONFIG_ARCH_APOLLO)     	:= apollo
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff -Naurp linux-2.6.34.orig/arch/arm/mm/alignment.c linux-2.6.34/arch/arm/mm/alignment.c
--- linux-2.6.34.orig/arch/arm/mm/alignment.c	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/alignment.c	2010-09-07 22:16:40.000000000 -0500
@@ -925,7 +925,17 @@ static int __init alignment_init(void)
 	}
 
 	hook_fault_code(1, do_alignment, SIGILL, "alignment exception");
+
+	/*
+	 * ARMv6K and ARMv7 use fault status 3 (0b00011) as Access Flag section
+	 * fault, not as alignment error.
+	 *
+	 * TODO: handle ARMv6K properly. Runtime check for 'K' extension is
+	 * needed.
+	 */
+	if (cpu_architecture() <= CPU_ARCH_ARMv6) {
 	hook_fault_code(3, do_alignment, SIGILL, "alignment exception");
+	}
 
 	return 0;
 }
diff -Naurp linux-2.6.34.orig/arch/arm/mm/cache-l2x0.c linux-2.6.34/arch/arm/mm/cache-l2x0.c
--- linux-2.6.34.orig/arch/arm/mm/cache-l2x0.c	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/cache-l2x0.c	2010-09-07 22:16:40.000000000 -0500
@@ -228,6 +228,9 @@ void __init l2x0_init(void __iomem *base
 	cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
 	aux = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
 
+	aux &= aux_mask;
+	aux |= aux_val;
+
 	/* Determine the number of ways */
 	switch (cache_id & L2X0_CACHE_ID_PART_MASK) {
 	case L2X0_CACHE_ID_PART_L310:
@@ -263,12 +266,15 @@ void __init l2x0_init(void __iomem *base
 	if (!(readl_relaxed(l2x0_base + L2X0_CTRL) & 1)) {
 
 		/* l2x0 controller is disabled */
-		aux &= aux_mask;
-		aux |= aux_val;
 		writel_relaxed(aux, l2x0_base + L2X0_AUX_CTRL);
 
 		l2x0_inv_all();
 
+		/* Setup Address filtering for MCU0 region 0-512M */
+		writel_relaxed(0x20000000, l2x0_base + L2X0_ADDR_FILTERING_END);
+		/* Enable Address Filtering */
+		writel_relaxed(0x1, l2x0_base + L2X0_ADDR_FILTERING_START);
+
 		/* enable L2X0 */
 		writel_relaxed(1, l2x0_base + L2X0_CTRL);
 	}
diff -Naurp linux-2.6.34.orig/arch/arm/mm/cache-v7.S linux-2.6.34/arch/arm/mm/cache-v7.S
--- linux-2.6.34.orig/arch/arm/mm/cache-v7.S	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/cache-v7.S	2010-09-07 22:16:40.000000000 -0500
@@ -76,6 +76,63 @@ finished:
 ENDPROC(v7_flush_dcache_all)
 
 /*
+ *	v7_invalidate_dcache_all()
+ *
+ *	Invalidate the whole D-cache.
+ *
+ *	Corrupted registers: r0-r7, r9-r11 (r6 only in Thumb mode)
+ *
+ *	- mm    - mm_struct describing address space
+ */
+ENTRY(v7_invalidate_dcache_all)
+	dmb					@ ensure ordering with previous memory accesses
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	invfinished			@ if loc is 0, then no need to clean
+	mov	r10, #0				@ start clean at cache level 0
+invlooplevel:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache level
+	mov	r1, r0, lsr r2			@ extract cache type bits from clidr
+	and	r1, r1, #7			@ mask of the bits for current cache only
+	cmp	r1, #2				@ see what cache we have at this level
+	blt	invskip				@ skip if no cache, or just i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	isb					@ isb to sych the new cssr&csidr
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the way size
+	clz	r5, r4				@ find bit position of way size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the index size
+invloopset:
+	mov	r9, r4				@ create working copy of max way size
+invloopway:
+ ARM(	orr	r11, r10, r9, lsl r5	)	@ factor way and cache number into r11
+ THUMB(	lsl	r6, r9, r5		)
+ THUMB(	orr	r11, r10, r6		)	@ factor way and cache number into r11
+ ARM(	orr	r11, r11, r7, lsl r2	)	@ factor index number into r11
+ THUMB(	lsl	r6, r7, r2		)
+ THUMB(	orr	r11, r11, r6		)	@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	invloopway
+	subs	r7, r7, #1			@ decrement the index
+	bge	invloopset
+invskip:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	invlooplevel
+invfinished:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	dsb
+	isb
+	mov	pc, lr
+ENDPROC(v7_invalidate_dcache_all)
+/*
  *	v7_flush_cache_all()
  *
  *	Flush the entire cache system.
diff -Naurp linux-2.6.34.orig/arch/arm/mm/Kconfig linux-2.6.34/arch/arm/mm/Kconfig
--- linux-2.6.34.orig/arch/arm/mm/Kconfig	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -409,7 +409,7 @@ config CPU_32v6K
 
 # ARMv7
 config CPU_V7
-	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX
+	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX || MACH_APOLLO
 	select CPU_32v6K if !ARCH_OMAP2
 	select CPU_32v7
 	select CPU_ABRT_EV7
@@ -789,7 +789,7 @@ config CACHE_FEROCEON_L2_WRITETHROUGH
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller"
 	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || \
-		   REALVIEW_EB_A9MP || ARCH_MX35 || ARCH_MX31 || MACH_REALVIEW_PBX || ARCH_NOMADIK || ARCH_OMAP4
+		   REALVIEW_EB_A9MP || ARCH_MX35 || ARCH_MX31 || MACH_REALVIEW_PBX || ARCH_NOMADIK || ARCH_OMAP4 || MACH_APOLLO
 	default y
 	select OUTER_CACHE
 	select OUTER_CACHE_SYNC
diff -Naurp linux-2.6.34.orig/arch/arm/mm/mmu.c linux-2.6.34/arch/arm/mm/mmu.c
--- linux-2.6.34.orig/arch/arm/mm/mmu.c	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/mmu.c	2010-09-07 22:16:40.000000000 -0500
@@ -839,12 +839,28 @@ static inline void prepare_page_table(vo
 		pmd_clear(pmd_off_k(addr));
 }
 
+extern u32 uARM926_start, uARM926_size;
+extern u32 uBIS_start, uBIS_size;
+extern u32 uADSP_start, uADSP_size;
+extern u32 uVDSP_start, uVDSP_size;
+extern u32 uMALONE_start, uMALONE_size;
+extern u32 uVRAMHD_start, uVRAMHD_size;
+extern u32 uVRAMSD_start, uVRAMSD_size;
+extern u32 uMBVPHD_start, uMBVPHD_size;
+extern u32 uMBVPSD_start, uMBVPSD_size;
+extern u32 uKALCSSGEN_start, uKALCSSGEN_size;
+extern u32 uKALCSSCON_start, uKALCSSCON_size;
+extern u32 uA9_ARM926_start, uA9_ARM926_size;
+extern u32 uARM926_TM_start, uARM926_TM_size;
+extern u32 uMBVP_stdi_start, uMBVP_stdi_size;
+
 /*
  * Reserve the various regions of node 0
  */
 void __init reserve_node_zero(pg_data_t *pgdat)
 {
 	unsigned long res_size = 0;
+    int ret;
 
 	/*
 	 * Register the kernel text and data with bootmem.
@@ -865,6 +881,112 @@ void __init reserve_node_zero(pg_data_t 
 	reserve_bootmem_node(pgdat, __pa(swapper_pg_dir),
 			     PTRS_PER_PGD * sizeof(pgd_t), BOOTMEM_DEFAULT);
 
+	if (machine_is_apollo())
+	{
+		/* Reserving the 0th 4k page as per Cortex-A9 Errata */
+		ret = reserve_bootmem_node(pgdat, 0, 0x1000, BOOTMEM_DEFAULT);
+                        if(ret)
+                                printk("Reserving the oth 4k page failed = %d\n", ret);
+
+		if((uARM926_start >= 0) && (uARM926_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uARM926_start, uARM926_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("ARM926 ret = %d\n", ret);
+		}
+
+		if((uBIS_start >= 0) && (uBIS_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uBIS_start, uBIS_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("BIS ret = %d\n", ret);
+		}
+
+		if((uADSP_start >= 0) && (uADSP_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uADSP_start, uADSP_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("ADSP ret = %d\n", ret);
+		}
+
+		if((uVDSP_start >= 0) && (uVDSP_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uVDSP_start, uVDSP_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("VDSP ret = %d\n", ret);
+		}
+
+		if((uMALONE_start >= 0) && (uMALONE_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uMALONE_start, uMALONE_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("Malone ret = %d\n", ret);
+		}
+
+		if((uVRAMHD_start >= 0) && (uVRAMHD_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uVRAMHD_start, uVRAMHD_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("VRAMHD ret = %d\n", ret);
+		}
+
+		if((uVRAMSD_start >= 0) && (uVRAMSD_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uVRAMSD_start, uVRAMSD_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("VRAMSD ret = %d\n", ret);
+		}
+
+		if((uMBVPHD_start >= 0) && (uMBVPHD_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uMBVPHD_start, uMBVPHD_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("MBVPHD ret = %d\n", ret);
+		}
+
+		if((uMBVPSD_start >= 0) && (uMBVPSD_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uMBVPSD_start, uMBVPSD_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("MBVPSD ret = %d\n", ret);
+		}
+
+		if((uKALCSSGEN_start >= 0) && (uKALCSSGEN_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uKALCSSGEN_start, uKALCSSGEN_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("KALCSSGEN ret = %d\n", ret);
+		}
+
+		if((uKALCSSCON_start >= 0) && (uKALCSSCON_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uKALCSSCON_start, uKALCSSCON_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("KALCSSCON ret = %d\n", ret);
+		}
+
+		if((uA9_ARM926_start >= 0) && (uA9_ARM926_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uA9_ARM926_start, uA9_ARM926_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("A9_ARM926 ret = %d\n", ret);
+		}
+
+		if((uARM926_TM_start >= 0) && (uARM926_TM_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uARM926_TM_start, uARM926_TM_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("ARM926_TM ret = %d\n", ret);
+		}
+
+		if((uMBVP_stdi_start >= 0) && (uMBVP_stdi_size > 0))
+		{
+			ret = reserve_bootmem_node(pgdat, uMBVP_stdi_start, uMBVP_stdi_size, BOOTMEM_DEFAULT);
+			if(ret)
+				printk("MBVP_stdi ret = %d\n", ret);
+		}
+	}   
+
 	/*
 	 * Hmm... This should go elsewhere, but we really really need to
 	 * stop things allocating the low memory; ideally we need a better
diff -Naurp linux-2.6.34.orig/arch/arm/mm/proc-v7.S linux-2.6.34/arch/arm/mm/proc-v7.S
--- linux-2.6.34.orig/arch/arm/mm/proc-v7.S	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/mm/proc-v7.S	2010-09-07 22:16:40.000000000 -0500
@@ -198,7 +198,8 @@ __v7_setup:
 #endif
 	adr	r12, __v7_setup_stack		@ the local stack
 	stmia	r12, {r0-r5, r7, r9, r11, lr}
-	bl	v7_flush_dcache_all
+	bl	v7_invalidate_dcache_all
+	mcr     p15, 0, r0, c8, c7, 0           @ flush entire unified TLB
 	ldmia	r12, {r0-r5, r7, r9, r11, lr}
 
 	mrc	p15, 0, r0, c0, c0, 0		@ read main ID register
diff -Naurp linux-2.6.34.orig/arch/arm/vfp/vfpmodule.c linux-2.6.34/arch/arm/vfp/vfpmodule.c
--- linux-2.6.34.orig/arch/arm/vfp/vfpmodule.c	2010-09-07 21:21:47.000000000 -0500
+++ linux-2.6.34/arch/arm/vfp/vfpmodule.c	2010-09-07 22:16:40.000000000 -0500
@@ -439,8 +439,8 @@ void vfp_sync_hwstate(struct thread_info
 	if (last_VFP_context[cpu] == &thread->vfpstate) {
 		u32 fpexc = fmrx(FPEXC);
 
-	/*
-	 * Save the last VFP state on this CPU.
+		/*
+		 * Save the last VFP state on this CPU.
 		 */
 		fmxr(FPEXC, fpexc | FPEXC_EN);
 		vfp_save_state(&thread->vfpstate, fpexc | FPEXC_EN);
diff -Naurp linux-2.6.34.orig/drivers/ata/Kconfig linux-2.6.34/drivers/ata/Kconfig
--- linux-2.6.34.orig/drivers/ata/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/ata/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -63,6 +63,21 @@ config SATA_AHCI
 	help
 	  This option enables support for AHCI Serial ATA.
 
+config SATA_APOLLO
+	tristate "NXP Apollo AHCI SATA support"
+	depends on ARCH_APOLLO
+	help
+	  This option enables support for NXP Apollo AHCI Serial ATA.
+
+	  If unsure, say N.
+
+config SATA_APOLLO_BIST
+	bool "SATA BIST support"
+	default n
+	depends on SATA_APOLLO
+	help
+	  This option enables BIST support for NXP Apollo AHCI Serial ATA.
+
 	  If unsure, say N.
 
 config SATA_SIL24
diff -Naurp linux-2.6.34.orig/drivers/ata/Makefile linux-2.6.34/drivers/ata/Makefile
--- linux-2.6.34.orig/drivers/ata/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/ata/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -2,6 +2,7 @@
 obj-$(CONFIG_ATA)		+= libata.o
 
 obj-$(CONFIG_SATA_AHCI)		+= ahci.o
+obj-$(CONFIG_SATA_APOLLO)	+= sata_apollo.o
 obj-$(CONFIG_SATA_SVW)		+= sata_svw.o
 obj-$(CONFIG_ATA_PIIX)		+= ata_piix.o
 obj-$(CONFIG_SATA_PROMISE)	+= sata_promise.o
diff -Naurp linux-2.6.34.orig/drivers/ata/sata_apollo.c linux-2.6.34/drivers/ata/sata_apollo.c
--- linux-2.6.34.orig/drivers/ata/sata_apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/ata/sata_apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,3988 @@
+/*
+ *  sata_apollo.c - AHCI SATA support for NXP Apollo
+ *
+ *  Copyright 2009 NXP Semiconductors
+ *  Andrew Fedonczuk <andrew.fedonczuk@nxp.com>
+ *
+ *  Note: This driver is based havily on the original PCI ahci.c. The
+ *  PCI functionality has been retained but conditionally-compiled
+ *  out. This will hopefully make it easier to reconcile with future
+ *  versions of ahci.c - ideally ahci.c would be generic with separate
+ *  PCI and NXP Apollo lower-level drivers.
+ *
+ *  Based on:
+ *
+ *  ahci.c - AHCI SATA support
+ *
+ *  Maintained by:  Jeff Garzik <jgarzik@pobox.com>
+ *    		    Please ALWAYS copy linux-ide@vger.kernel.org
+ *		    on emails.
+ *
+ *  Copyright 2004-2005 Red Hat, Inc.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * libata documentation is available via 'make {ps|pdf}docs',
+ * as Documentation/DocBook/libata.*
+ *
+ * AHCI hardware documentation:
+ * http://www.intel.com/technology/serialata/pdf/rev1_0.pdf
+ * http://www.intel.com/technology/serialata/pdf/rev1_1.pdf
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#ifdef CONFIG_ARCH_APOLLO
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#else
+#include <linux/pci.h>
+#endif
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/dmi.h>
+#include <linux/gfp.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <linux/libata.h>
+
+#ifdef CONFIG_SATA_APOLLO_BIST
+#include <scsi/scsi_device.h>
+#include <linux/hdreg.h>
+#endif
+
+#ifdef CONFIG_ARCH_APOLLO
+#define DRV_NAME	"sata-apollo"
+#else
+#define DRV_NAME	"ahci"
+#endif
+#define DRV_VERSION	"3.0"
+
+/* Enclosure Management Control */
+#define EM_CTRL_MSG_TYPE              0x000f0000
+
+/* Enclosure Management LED Message Type */
+#define EM_MSG_LED_HBA_PORT           0x0000000f
+#define EM_MSG_LED_PMP_SLOT           0x0000ff00
+#define EM_MSG_LED_VALUE              0xffff0000
+#define EM_MSG_LED_VALUE_ACTIVITY     0x00070000
+#define EM_MSG_LED_VALUE_OFF          0xfff80000
+#define EM_MSG_LED_VALUE_ON           0x00010000
+
+static int ahci_skip_host_reset;
+static int ahci_ignore_sss;
+
+module_param_named(skip_host_reset, ahci_skip_host_reset, int, 0444);
+MODULE_PARM_DESC(skip_host_reset, "skip global host reset (0=don't skip, 1=skip)");
+
+module_param_named(ignore_sss, ahci_ignore_sss, int, 0444);
+MODULE_PARM_DESC(ignore_sss, "Ignore staggered spinup flag (0=don't ignore, 1=ignore)");
+
+static int ahci_enable_alpm(struct ata_port *ap,
+		enum link_pm policy);
+static void ahci_disable_alpm(struct ata_port *ap);
+static ssize_t ahci_led_show(struct ata_port *ap, char *buf);
+static ssize_t ahci_led_store(struct ata_port *ap, const char *buf,
+			      size_t size);
+static ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,
+					ssize_t size);
+
+enum {
+#ifndef CONFIG_ARCH_APOLLO
+	AHCI_PCI_BAR		= 5,
+#endif /* !Apollo */
+	AHCI_MAX_PORTS		= 32,
+	AHCI_MAX_SG		= 168, /* hardware max is 64K */
+	AHCI_DMA_BOUNDARY	= 0xffffffff,
+	AHCI_MAX_CMDS		= 32,
+	AHCI_CMD_SZ		= 32,
+	AHCI_CMD_SLOT_SZ	= AHCI_MAX_CMDS * AHCI_CMD_SZ,
+	AHCI_RX_FIS_SZ		= 256,
+	AHCI_CMD_TBL_CDB	= 0x40,
+	AHCI_CMD_TBL_HDR_SZ	= 0x80,
+	AHCI_CMD_TBL_SZ		= AHCI_CMD_TBL_HDR_SZ + (AHCI_MAX_SG * 16),
+	AHCI_CMD_TBL_AR_SZ	= AHCI_CMD_TBL_SZ * AHCI_MAX_CMDS,
+	AHCI_PORT_PRIV_DMA_SZ	= AHCI_CMD_SLOT_SZ + AHCI_CMD_TBL_AR_SZ +
+				  AHCI_RX_FIS_SZ,
+	AHCI_PORT_PRIV_FBS_DMA_SZ	= AHCI_CMD_SLOT_SZ +
+					  AHCI_CMD_TBL_AR_SZ +
+					  (AHCI_RX_FIS_SZ * 16),
+	AHCI_IRQ_ON_SG		= (1 << 31),
+	AHCI_CMD_ATAPI		= (1 << 5),
+	AHCI_CMD_WRITE		= (1 << 6),
+	AHCI_CMD_PREFETCH	= (1 << 7),
+	AHCI_CMD_RESET		= (1 << 8),
+	AHCI_CMD_CLR_BUSY	= (1 << 10),
+
+	RX_FIS_D2H_REG		= 0x40,	/* offset of D2H Register FIS data */
+	RX_FIS_SDB		= 0x58, /* offset of SDB FIS data */
+	RX_FIS_UNK		= 0x60, /* offset of Unknown FIS data */
+
+	board_ahci		= 0,
+	board_ahci_vt8251	= 1,
+	board_ahci_ign_iferr	= 2,
+	board_ahci_sb600	= 3,
+	board_ahci_mv		= 4,
+	board_ahci_sb700	= 5, /* for SB700 and SB800 */
+	board_ahci_mcp65	= 6,
+	board_ahci_nopmp	= 7,
+	board_ahci_yesncq	= 8,
+	board_ahci_nosntf	= 9,
+	board_ahci_apollo	= 10,
+
+	/* global controller registers */
+	HOST_CAP		= 0x00, /* host capabilities */
+	HOST_CTL		= 0x04, /* global host control */
+	HOST_IRQ_STAT		= 0x08, /* interrupt status */
+	HOST_PORTS_IMPL		= 0x0c, /* bitmap of implemented ports */
+	HOST_VERSION		= 0x10, /* AHCI spec. version compliancy */
+	HOST_EM_LOC		= 0x1c, /* Enclosure Management location */
+	HOST_EM_CTL		= 0x20, /* Enclosure Management Control */
+	HOST_CAP2		= 0x24, /* host capabilities, extended */
+
+#ifdef CONFIG_ARCH_APOLLO
+	/* Additional vendor-specific global controller registers */
+	HOST_BOHC		= 0x28, /* BIOS handoff/control */
+	HOST_BISTAFR		= 0xa0, /* BIST Activate FIS Register */
+	HOST_BISTCR		= 0xa4, /* BIST Control Register */
+	HOST_BISTFCTR		= 0xa8, /* BIST FIS Count Register */
+	HOST_BISTSR		= 0xac, /* BIST Status Register */
+	HOST_BISTDECR 		= 0xb0, /* BIST DWORD Error Count Register */
+	HOST_OOBR		= 0xbc, /* OOB Register */
+	HOST_TIMER1MS		= 0xe0, /* Timer 1-ms Register */
+	HOST_GPARAM1R		= 0xe8, /* Global Parameter 1 Register */
+	HOST_GPARAM2R		= 0xec, /* Global Parameter 2 Register */
+	HOST_PPARAMR		= 0xf0, /* Port Parameter Register */
+	HOST_TESTR		= 0xf4, /* Test Register */
+	HOST_VERSIONR		= 0xf8, /* Version Register */
+	HOST_IDR		= 0xfc, /* ID Register */
+#endif
+
+	/* HOST_CTL bits */
+	HOST_RESET		= (1 << 0),  /* reset controller; self-clear */
+	HOST_IRQ_EN		= (1 << 1),  /* global IRQ enable */
+	HOST_AHCI_EN		= (1 << 31), /* AHCI enabled */
+
+	/* HOST_CAP bits */
+	HOST_CAP_SXS		= (1 << 5),  /* Supports External SATA */
+	HOST_CAP_EMS		= (1 << 6),  /* Enclosure Management support */
+	HOST_CAP_CCC		= (1 << 7),  /* Command Completion Coalescing */
+	HOST_CAP_PART		= (1 << 13), /* Partial state capable */
+	HOST_CAP_SSC		= (1 << 14), /* Slumber state capable */
+	HOST_CAP_PIO_MULTI	= (1 << 15), /* PIO multiple DRQ support */
+	HOST_CAP_FBS		= (1 << 16), /* FIS-based switching support */
+	HOST_CAP_PMP		= (1 << 17), /* Port Multiplier support */
+	HOST_CAP_ONLY		= (1 << 18), /* Supports AHCI mode only */
+	HOST_CAP_CLO		= (1 << 24), /* Command List Override support */
+	HOST_CAP_LED		= (1 << 25), /* Supports activity LED */
+	HOST_CAP_ALPM		= (1 << 26), /* Aggressive Link PM support */
+	HOST_CAP_SSS		= (1 << 27), /* Staggered Spin-up */
+	HOST_CAP_MPS		= (1 << 28), /* Mechanical presence switch */
+	HOST_CAP_SNTF		= (1 << 29), /* SNotification register */
+	HOST_CAP_NCQ		= (1 << 30), /* Native Command Queueing */
+	HOST_CAP_64		= (1 << 31), /* PCI DAC (64-bit DMA) support */
+
+	/* HOST_CAP2 bits */
+	HOST_CAP2_BOH		= (1 << 0),  /* BIOS/OS handoff supported */
+	HOST_CAP2_NVMHCI	= (1 << 1),  /* NVMHCI supported */
+	HOST_CAP2_APST		= (1 << 2),  /* Automatic partial to slumber */
+
+	/* registers for each SATA port */
+	PORT_LST_ADDR		= 0x00, /* command list DMA addr */
+	PORT_LST_ADDR_HI	= 0x04, /* command list DMA addr hi */
+	PORT_FIS_ADDR		= 0x08, /* FIS rx buf addr */
+	PORT_FIS_ADDR_HI	= 0x0c, /* FIS rx buf addr hi */
+	PORT_IRQ_STAT		= 0x10, /* interrupt status */
+	PORT_IRQ_MASK		= 0x14, /* interrupt enable/disable mask */
+	PORT_CMD		= 0x18, /* port command */
+	PORT_TFDATA		= 0x20,	/* taskfile data */
+	PORT_SIG		= 0x24,	/* device TF signature */
+	PORT_CMD_ISSUE		= 0x38, /* command issue */
+	PORT_SCR_STAT		= 0x28, /* SATA phy register: SStatus */
+	PORT_SCR_CTL		= 0x2c, /* SATA phy register: SControl */
+	PORT_SCR_ERR		= 0x30, /* SATA phy register: SError */
+	PORT_SCR_ACT		= 0x34, /* SATA phy register: SActive */
+	PORT_SCR_NTF		= 0x3c, /* SATA phy register: SNotification */
+	PORT_FBS		    = 0x40, /* FIS-based Switching */
+
+#ifdef CONFIG_ARCH_APOLLO
+	/* Additional vendor-specific port registers */
+	PORT_DMACR		= 0x70,	/* DMA Control Register */
+	PORT_PHYCR		= 0x78, /* PHY Control Register */
+	PORT_PHYSR		= 0x7c, /* PHY Status Register */
+#endif
+
+#ifdef CONFIG_ARCH_APOLLO
+	/* Additional NXP vendor-specific registers */
+	NXP_TX_CTRL_REG		= 0x500,
+	NXP_PLL_RESET_CTRL_REG	= 0x504,
+	NXP_RX_CTRL_REG		= 0x508,
+	NXP_MPLL_CTRL_REG	= 0x50c,
+	NXP_LVL_CTRL_REG	= 0x510,
+	NXP_CR_CTRL_REG		= 0x514,
+	NXP_SR_DOUT_REG		= 0x518,
+	NXP_TXRX_STATUS_REG	= 0x51c,
+	NXP_LLC_CTRL_REG	= 0x600,
+	NXP_SATA_MODULE_ID_REG	= 0xffc,
+#endif
+
+	/* PORT_IRQ_{STAT,MASK} bits */
+	PORT_IRQ_COLD_PRES	= (1 << 31), /* cold presence detect */
+	PORT_IRQ_TF_ERR		= (1 << 30), /* task file error */
+	PORT_IRQ_HBUS_ERR	= (1 << 29), /* host bus fatal error */
+	PORT_IRQ_HBUS_DATA_ERR	= (1 << 28), /* host bus data error */
+	PORT_IRQ_IF_ERR		= (1 << 27), /* interface fatal error */
+	PORT_IRQ_IF_NONFATAL	= (1 << 26), /* interface non-fatal error */
+	PORT_IRQ_OVERFLOW	= (1 << 24), /* xfer exhausted available S/G */
+	PORT_IRQ_BAD_PMP	= (1 << 23), /* incorrect port multiplier */
+
+	PORT_IRQ_PHYRDY		= (1 << 22), /* PhyRdy changed */
+	PORT_IRQ_DEV_ILCK	= (1 << 7), /* device interlock */
+	PORT_IRQ_CONNECT	= (1 << 6), /* port connect change status */
+	PORT_IRQ_SG_DONE	= (1 << 5), /* descriptor processed */
+	PORT_IRQ_UNK_FIS	= (1 << 4), /* unknown FIS rx'd */
+	PORT_IRQ_SDB_FIS	= (1 << 3), /* Set Device Bits FIS rx'd */
+	PORT_IRQ_DMAS_FIS	= (1 << 2), /* DMA Setup FIS rx'd */
+	PORT_IRQ_PIOS_FIS	= (1 << 1), /* PIO Setup FIS rx'd */
+	PORT_IRQ_D2H_REG_FIS	= (1 << 0), /* D2H Register FIS rx'd */
+
+	PORT_IRQ_FREEZE		= PORT_IRQ_HBUS_ERR |
+				  PORT_IRQ_IF_ERR |
+				  PORT_IRQ_CONNECT |
+				  PORT_IRQ_PHYRDY |
+				  PORT_IRQ_UNK_FIS |
+				  PORT_IRQ_BAD_PMP,
+	PORT_IRQ_ERROR		= PORT_IRQ_FREEZE |
+				  PORT_IRQ_TF_ERR |
+				  PORT_IRQ_HBUS_DATA_ERR,
+	DEF_PORT_IRQ		= PORT_IRQ_ERROR | PORT_IRQ_SG_DONE |
+				  PORT_IRQ_SDB_FIS | PORT_IRQ_DMAS_FIS |
+				  PORT_IRQ_PIOS_FIS | PORT_IRQ_D2H_REG_FIS,
+
+	/* PORT_CMD bits */
+	PORT_CMD_ASP		= (1 << 27), /* Aggressive Slumber/Partial */
+	PORT_CMD_ALPE		= (1 << 26), /* Aggressive Link PM enable */
+	PORT_CMD_ATAPI		= (1 << 24), /* Device is ATAPI */
+	PORT_CMD_FBSCP		= (1 << 22), /* FBS Capable Port */
+	PORT_CMD_PMP		= (1 << 17), /* PMP attached */
+	PORT_CMD_LIST_ON	= (1 << 15), /* cmd list DMA engine running */
+	PORT_CMD_FIS_ON		= (1 << 14), /* FIS DMA engine running */
+	PORT_CMD_FIS_RX		= (1 << 4), /* Enable FIS receive DMA engine */
+	PORT_CMD_CLO		= (1 << 3), /* Command list override */
+	PORT_CMD_POWER_ON	= (1 << 2), /* Power up device */
+	PORT_CMD_SPIN_UP	= (1 << 1), /* Spin up device */
+	PORT_CMD_START		= (1 << 0), /* Enable port DMA engine */
+
+	PORT_CMD_ICC_MASK	= (0xf << 28), /* i/f ICC state mask */
+	PORT_CMD_ICC_ACTIVE	= (0x1 << 28), /* Put i/f in active state */
+	PORT_CMD_ICC_PARTIAL	= (0x2 << 28), /* Put i/f in partial state */
+	PORT_CMD_ICC_SLUMBER	= (0x6 << 28), /* Put i/f in slumber state */
+
+	PORT_FBS_DWE_OFFSET	= 16, /* FBS device with error offset */
+	PORT_FBS_ADO_OFFSET	= 12, /* FBS active dev optimization offset */
+	PORT_FBS_DEV_OFFSET	= 8,  /* FBS device to issue offset */
+	PORT_FBS_DEV_MASK	= (0xf << PORT_FBS_DEV_OFFSET),  /* FBS.DEV */
+	PORT_FBS_SDE		= (1 << 2), /* FBS single device error */
+	PORT_FBS_DEC		= (1 << 1), /* FBS device error clear */
+	PORT_FBS_EN		    = (1 << 0), /* Enable FBS */
+
+	/* hpriv->flags bits */
+	AHCI_HFLAG_NO_NCQ		= (1 << 0),
+	AHCI_HFLAG_IGN_IRQ_IF_ERR	= (1 << 1), /* ignore IRQ_IF_ERR */
+	AHCI_HFLAG_IGN_SERR_INTERNAL	= (1 << 2), /* ignore SERR_INTERNAL */
+	AHCI_HFLAG_32BIT_ONLY		= (1 << 3), /* force 32bit */
+	AHCI_HFLAG_MV_PATA		= (1 << 4), /* PATA port */
+	AHCI_HFLAG_NO_MSI		= (1 << 5), /* no PCI MSI */
+	AHCI_HFLAG_NO_PMP		= (1 << 6), /* no PMP */
+	AHCI_HFLAG_NO_HOTPLUG		= (1 << 7), /* ignore PxSERR.DIAG.N */
+	AHCI_HFLAG_SECT255		= (1 << 8), /* max 255 sectors */
+	AHCI_HFLAG_YES_NCQ		= (1 << 9), /* force NCQ cap on */
+	AHCI_HFLAG_NO_SUSPEND		= (1 << 10), /* don't suspend */
+	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE	= (1 << 11), /* treat SRST timeout as
+							link offline */
+	AHCI_HFLAG_NO_SNTF		= (1 << 12), /* no sntf */
+
+	/* ap->flags bits */
+
+	AHCI_FLAG_COMMON		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
+					  ATA_FLAG_MMIO | ATA_FLAG_PIO_DMA |
+					  ATA_FLAG_ACPI_SATA | ATA_FLAG_AN |
+					  ATA_FLAG_IPM,
+
+	ICH_MAP				= 0x90, /* ICH MAP register */
+
+	/* em constants */
+	EM_MAX_SLOTS			= 8,
+	EM_MAX_RETRY			= 5,
+
+	/* em_ctl bits */
+	EM_CTL_RST			= (1 << 9), /* Reset */
+	EM_CTL_TM			= (1 << 8), /* Transmit Message */
+	EM_CTL_ALHD			= (1 << 26), /* Activity LED */
+};
+
+#ifdef CONFIG_SATA_APOLLO_BIST
+enum 
+{
+   /* arg [0] - BIST mode */
+   SATA_BIST_EXIT       = 0xFF,/* EXIT BIST mode                           */
+   SATA_BIST_FEALB      = 0xFE,/* Far End Analog Loopback -- Not Supported */
+   SATA_BIST_NEALB      = 0xFD,/* Near-End Analog (Effectively Retimed) LB */
+   SATA_BIST_FERLB      = 0xFC,/* Far End Retimed Loopback                 */
+   SATA_BIST_FET        = 0xFB,/* Far End Transmit                         */
+   SATA_BIST_PRINT_INFO = 0xFA,/* PRINT BIST Information                   */
+
+   /* arg [1] - controls link speed */
+   SATA_BIST_SPEED_GEN1 = 1,
+   SATA_BIST_SPEED_GEN2 = 2,
+
+   /* arg [2] - controls following port link layer functions. */
+
+   /* arg[2]:Bit0 - Scrambler enable/disable */
+   SATA_BIST_SCRAM_DISABLE = 0<<0,
+   SATA_BIST_SCRAM_ENABLE = 1<<0,
+
+   /* arg[2]:Bit1 - Descrambler enable/disable */
+   SATA_BIST_DESCRAM_DISABLE = 0<<1,
+   SATA_BIST_DESCRAM_ENABLE = 1<<1,
+
+   /* arg[2]:Bit2 - Repeat primitive drop function enable/disable */
+   SATA_BIST_RPD_DISABLE = 0<<2,
+   SATA_BIST_RPD_ENABLE = 1<<2,
+
+   /* arg [3] - PHY internal errors outside the FIS boundary enable/disable */
+   SATA_BIST_ERREN_DISABLE = 0,
+   SATA_BIST_ERREN_ENABLE = 1,
+
+   /* arg [4] - Flip Disparity enable/disable */
+   SATA_BIST_FLIP_DISABLE = 0,
+   SATA_BIST_FLIP_ENABLE = 1,
+
+   /* arg [5] - Pattern Version short/long */
+   SATA_BIST_PV_SHORT = 0,
+   SATA_BIST_PV_LONG = 1,
+
+   /* arg [6] - SATA compliant patterns for far-end retimed/
+    * far-end analog/ near-end analog initiator modes, or 
+    * non-compliant patterns for transmit-only responder mode 
+    * when initiated by the software. */
+   SATA_BIST_PATTERN_SSOP  = 0x0,
+   SATA_BIST_PATTERN_HTDP  = 0x1,
+   SATA_BIST_PATTERN_LTDP  = 0x2,
+   SATA_BIST_PATTERN_LFSCP = 0x3,
+   SATA_BIST_PATTERN_COMP  = 0x4,
+   SATA_BIST_PATTERN_LBP   = 0x5,
+   SATA_BIST_PATTERN_MFTP  = 0x6,
+   SATA_BIST_PATTERN_HFTP  = 0x7,
+   SATA_BIST_PATTERN_LFTP  = 0x8,
+};
+#endif
+
+struct ahci_cmd_hdr {
+	__le32			opts;
+	__le32			status;
+	__le32			tbl_addr;
+	__le32			tbl_addr_hi;
+	__le32			reserved[4];
+};
+
+struct ahci_sg {
+	__le32			addr;
+	__le32			addr_hi;
+	__le32			reserved;
+	__le32			flags_size;
+};
+
+struct ahci_em_priv {
+	enum sw_activity blink_policy;
+	struct timer_list timer;
+	unsigned long saved_activity;
+	unsigned long activity;
+	unsigned long led_state;
+};
+
+struct ahci_host_priv {
+	unsigned int		flags;		/* AHCI_HFLAG_* */
+	u32			cap;		/* cap to use */
+	u32			cap2;		/* cap2 to use */
+	u32			port_map;	/* port map to use */
+	u32			saved_cap;	/* saved initial cap */
+	u32			saved_cap2;	/* saved initial cap2 */
+	u32			saved_port_map;	/* saved initial port_map */
+	u32 			em_loc; /* enclosure management location */
+#ifdef CONFIG_ARCH_APOLLO
+	void __iomem		*mmio;
+#endif /* Apollo */
+};
+
+struct ahci_port_priv {
+	struct ata_link		*active_link;
+	struct ahci_cmd_hdr	*cmd_slot;
+	dma_addr_t		cmd_slot_dma;
+	void			*cmd_tbl;
+	dma_addr_t		cmd_tbl_dma;
+	void			*rx_fis;
+	dma_addr_t		rx_fis_dma;
+	/* for NCQ spurious interrupt analysis */
+	unsigned int		ncq_saw_d2h:1;
+	unsigned int		ncq_saw_dmas:1;
+	unsigned int		ncq_saw_sdb:1;
+	u32 			intr_mask;	/* interrupts to enable */
+	bool			fbs_supported;	/* set iff FBS is supported */
+	bool			fbs_enabled;	/* set iff FBS is enabled */
+	int			    fbs_last_dev;	/* save FBS.DEV of last FIS */
+	/* enclosure management info per PM slot */
+	struct ahci_em_priv	em_priv[EM_MAX_SLOTS];
+};
+
+static int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);
+static int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);
+#ifdef CONFIG_ARCH_APOLLO
+static int ahci_apollo_probe(struct platform_device *pdev);
+static int ahci_apollo_remove(struct platform_device *pdev);
+#else /* PCI */
+static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
+#endif /* Apollo || PCI */
+static unsigned int ahci_qc_issue(struct ata_queued_cmd *qc);
+static bool ahci_qc_fill_rtf(struct ata_queued_cmd *qc);
+static int ahci_port_start(struct ata_port *ap);
+static void ahci_port_stop(struct ata_port *ap);
+static int ahci_pmp_qc_defer(struct ata_queued_cmd *qc);
+static void ahci_qc_prep(struct ata_queued_cmd *qc);
+static void ahci_freeze(struct ata_port *ap);
+static void ahci_thaw(struct ata_port *ap);
+static void ahci_enable_fbs(struct ata_port *ap);
+static void ahci_disable_fbs(struct ata_port *ap);
+static void ahci_pmp_attach(struct ata_port *ap);
+static void ahci_pmp_detach(struct ata_port *ap);
+static int ahci_softreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline);
+static int ahci_sb600_softreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline);
+static int ahci_hardreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline);
+static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
+				 unsigned long deadline);
+#ifndef CONFIG_ARCH_APOLLO
+static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline);
+#endif
+static void ahci_postreset(struct ata_link *link, unsigned int *class);
+static void ahci_error_handler(struct ata_port *ap);
+static void ahci_post_internal_cmd(struct ata_queued_cmd *qc);
+static int ahci_port_resume(struct ata_port *ap);
+static void ahci_dev_config(struct ata_device *dev);
+static void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
+			       u32 opts);
+#ifdef CONFIG_PM
+static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);
+#ifdef CONFIG_ARCH_APOLLO
+static int ahci_apollo_suspend(struct platform_device *pdev, pm_message_t mesg);
+static int ahci_apollo_resume(struct platform_device *pdev);
+#else /* PCI */
+static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
+static int ahci_pci_device_resume(struct pci_dev *pdev);
+#endif /* Apollo || PCI */
+#endif
+static ssize_t ahci_activity_show(struct ata_device *dev, char *buf);
+static ssize_t ahci_activity_store(struct ata_device *dev,
+				   enum sw_activity val);
+static void ahci_init_sw_activity(struct ata_link *link);
+
+static ssize_t ahci_show_host_caps(struct device *dev,
+				   struct device_attribute *attr, char *buf);
+static ssize_t ahci_show_host_cap2(struct device *dev,
+				   struct device_attribute *attr, char *buf);
+static ssize_t ahci_show_host_version(struct device *dev,
+				      struct device_attribute *attr, char *buf);
+static ssize_t ahci_show_port_cmd(struct device *dev,
+				  struct device_attribute *attr, char *buf);
+#ifdef CONFIG_SATA_APOLLO_BIST
+static int ahci_ata_scsi_ioctl(
+               struct scsi_device *scsidev, int cmd, void __user *arg);
+#endif
+
+static DEVICE_ATTR(ahci_host_caps, S_IRUGO, ahci_show_host_caps, NULL);
+static DEVICE_ATTR(ahci_host_cap2, S_IRUGO, ahci_show_host_cap2, NULL);
+static DEVICE_ATTR(ahci_host_version, S_IRUGO, ahci_show_host_version, NULL);
+static DEVICE_ATTR(ahci_port_cmd, S_IRUGO, ahci_show_port_cmd, NULL);
+
+static struct device_attribute *ahci_shost_attrs[] = {
+	&dev_attr_link_power_management_policy,
+	&dev_attr_em_message_type,
+	&dev_attr_em_message,
+	&dev_attr_ahci_host_caps,
+	&dev_attr_ahci_host_cap2,
+	&dev_attr_ahci_host_version,
+	&dev_attr_ahci_port_cmd,
+	NULL
+};
+
+static struct device_attribute *ahci_sdev_attrs[] = {
+	&dev_attr_sw_activity,
+	&dev_attr_unload_heads,
+	NULL
+};
+
+static struct scsi_host_template ahci_sht = {
+	ATA_NCQ_SHT(DRV_NAME),
+#ifdef CONFIG_SATA_APOLLO_BIST
+	.ioctl         = ahci_ata_scsi_ioctl,
+#endif
+	.can_queue		= AHCI_MAX_CMDS - 1,
+	.sg_tablesize		= AHCI_MAX_SG,
+	.dma_boundary		= AHCI_DMA_BOUNDARY,
+	.shost_attrs		= ahci_shost_attrs,
+	.sdev_attrs		= ahci_sdev_attrs,
+};
+
+static struct ata_port_operations ahci_ops = {
+	.inherits		= &sata_pmp_port_ops,
+
+	.qc_defer		= ahci_pmp_qc_defer,
+	.qc_prep		= ahci_qc_prep,
+	.qc_issue		= ahci_qc_issue,
+	.qc_fill_rtf	= ahci_qc_fill_rtf,
+
+	.freeze			= ahci_freeze,
+	.thaw			= ahci_thaw,
+	.softreset		= ahci_softreset,
+	.hardreset		= ahci_hardreset,
+	.postreset		= ahci_postreset,
+	.pmp_softreset		= ahci_softreset,
+	.error_handler		= ahci_error_handler,
+	.post_internal_cmd	= ahci_post_internal_cmd,
+	.dev_config		= ahci_dev_config,
+
+	.scr_read		= ahci_scr_read,
+	.scr_write		= ahci_scr_write,
+	.pmp_attach		= ahci_pmp_attach,
+	.pmp_detach		= ahci_pmp_detach,
+
+	.enable_pm		= ahci_enable_alpm,
+	.disable_pm		= ahci_disable_alpm,
+	.em_show		= ahci_led_show,
+	.em_store		= ahci_led_store,
+	.sw_activity_show	= ahci_activity_show,
+	.sw_activity_store	= ahci_activity_store,
+#ifdef CONFIG_PM
+	.port_suspend		= ahci_port_suspend,
+	.port_resume		= ahci_port_resume,
+#endif
+	.port_start		= ahci_port_start,
+	.port_stop		= ahci_port_stop,
+};
+
+static struct ata_port_operations ahci_vt8251_ops = {
+	.inherits		= &ahci_ops,
+	.hardreset		= ahci_vt8251_hardreset,
+};
+
+#ifndef CONFIG_ARCH_APOLLO
+static struct ata_port_operations ahci_p5wdh_ops = {
+	.inherits		= &ahci_ops,
+	.hardreset		= ahci_p5wdh_hardreset,
+};
+#endif
+
+static struct ata_port_operations ahci_sb600_ops = {
+	.inherits		= &ahci_ops,
+	.softreset		= ahci_sb600_softreset,
+	.pmp_softreset		= ahci_sb600_softreset,
+};
+
+static struct ata_port_operations ahci_apollo_ops = {
+	.inherits		= &ahci_ops,
+	.softreset		= ahci_sb600_softreset,
+	.pmp_softreset		= ahci_sb600_softreset,
+};
+
+#define AHCI_HFLAGS(flags)	.private_data	= (void *)(flags)
+
+static const struct ata_port_info ahci_port_info[] = {
+	[board_ahci] =
+	{
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_vt8251] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_NCQ | AHCI_HFLAG_NO_PMP),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_vt8251_ops,
+	},
+	[board_ahci_ign_iferr] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_IGN_IRQ_IF_ERR),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_sb600] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_IGN_SERR_INTERNAL |
+				 AHCI_HFLAG_NO_MSI | AHCI_HFLAG_SECT255 |
+				 AHCI_HFLAG_32BIT_ONLY),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_sb600_ops,
+	},
+	[board_ahci_mv] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_NCQ | AHCI_HFLAG_NO_MSI |
+				 AHCI_HFLAG_MV_PATA | AHCI_HFLAG_NO_PMP),
+		.flags		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
+				  ATA_FLAG_MMIO | ATA_FLAG_PIO_DMA,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_sb700] =	/* for SB700 and SB800 */
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_IGN_SERR_INTERNAL),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_sb600_ops,
+	},
+	[board_ahci_mcp65] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_YES_NCQ),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_nopmp] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_PMP),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_yesncq] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_YES_NCQ),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[board_ahci_nosntf] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_SNTF),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	/* board_ahci_apollo */
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_32BIT_ONLY),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_apollo_ops,
+	},
+};
+
+#ifndef CONFIG_ARCH_APOLLO
+static const struct pci_device_id ahci_pci_tbl[] = {
+	/* Intel */
+	{ PCI_VDEVICE(INTEL, 0x2652), board_ahci }, /* ICH6 */
+	{ PCI_VDEVICE(INTEL, 0x2653), board_ahci }, /* ICH6M */
+	{ PCI_VDEVICE(INTEL, 0x27c1), board_ahci }, /* ICH7 */
+	{ PCI_VDEVICE(INTEL, 0x27c5), board_ahci }, /* ICH7M */
+	{ PCI_VDEVICE(INTEL, 0x27c3), board_ahci }, /* ICH7R */
+	{ PCI_VDEVICE(AL, 0x5288), board_ahci_ign_iferr }, /* ULi M5288 */
+	{ PCI_VDEVICE(INTEL, 0x2681), board_ahci }, /* ESB2 */
+	{ PCI_VDEVICE(INTEL, 0x2682), board_ahci }, /* ESB2 */
+	{ PCI_VDEVICE(INTEL, 0x2683), board_ahci }, /* ESB2 */
+	{ PCI_VDEVICE(INTEL, 0x27c6), board_ahci }, /* ICH7-M DH */
+	{ PCI_VDEVICE(INTEL, 0x2821), board_ahci }, /* ICH8 */
+	{ PCI_VDEVICE(INTEL, 0x2822), board_ahci_nosntf }, /* ICH8 */
+	{ PCI_VDEVICE(INTEL, 0x2824), board_ahci }, /* ICH8 */
+	{ PCI_VDEVICE(INTEL, 0x2829), board_ahci }, /* ICH8M */
+	{ PCI_VDEVICE(INTEL, 0x282a), board_ahci }, /* ICH8M */
+	{ PCI_VDEVICE(INTEL, 0x2922), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x2923), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x2924), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x2925), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x2927), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x2929), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x292a), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x292b), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x292c), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x292f), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x294d), board_ahci }, /* ICH9 */
+	{ PCI_VDEVICE(INTEL, 0x294e), board_ahci }, /* ICH9M */
+	{ PCI_VDEVICE(INTEL, 0x502a), board_ahci }, /* Tolapai */
+	{ PCI_VDEVICE(INTEL, 0x502b), board_ahci }, /* Tolapai */
+	{ PCI_VDEVICE(INTEL, 0x3a05), board_ahci }, /* ICH10 */
+	{ PCI_VDEVICE(INTEL, 0x3a22), board_ahci }, /* ICH10 */
+	{ PCI_VDEVICE(INTEL, 0x3a25), board_ahci }, /* ICH10 */
+	{ PCI_VDEVICE(INTEL, 0x3b22), board_ahci }, /* PCH AHCI */
+	{ PCI_VDEVICE(INTEL, 0x3b23), board_ahci }, /* PCH AHCI */
+	{ PCI_VDEVICE(INTEL, 0x3b24), board_ahci }, /* PCH RAID */
+	{ PCI_VDEVICE(INTEL, 0x3b25), board_ahci }, /* PCH RAID */
+	{ PCI_VDEVICE(INTEL, 0x3b29), board_ahci }, /* PCH AHCI */
+	{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci }, /* PCH RAID */
+	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH RAID */
+	{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci }, /* PCH AHCI */
+	{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci }, /* CPT AHCI */
+	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT AHCI */
+	{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci }, /* CPT RAID */
+	{ PCI_VDEVICE(INTEL, 0x1c05), board_ahci }, /* CPT RAID */
+	{ PCI_VDEVICE(INTEL, 0x1c06), board_ahci }, /* CPT RAID */
+	{ PCI_VDEVICE(INTEL, 0x1c07), board_ahci }, /* CPT RAID */
+
+	/* JMicron 360/1/3/5/6, match class to avoid IDE function */
+	{ PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci_ign_iferr },
+
+	/* ATI */
+	{ PCI_VDEVICE(ATI, 0x4380), board_ahci_sb600 }, /* ATI SB600 */
+	{ PCI_VDEVICE(ATI, 0x4390), board_ahci_sb700 }, /* ATI SB700/800 */
+	{ PCI_VDEVICE(ATI, 0x4391), board_ahci_sb700 }, /* ATI SB700/800 */
+	{ PCI_VDEVICE(ATI, 0x4392), board_ahci_sb700 }, /* ATI SB700/800 */
+	{ PCI_VDEVICE(ATI, 0x4393), board_ahci_sb700 }, /* ATI SB700/800 */
+	{ PCI_VDEVICE(ATI, 0x4394), board_ahci_sb700 }, /* ATI SB700/800 */
+	{ PCI_VDEVICE(ATI, 0x4395), board_ahci_sb700 }, /* ATI SB700/800 */
+
+	/* AMD */
+	{ PCI_VDEVICE(AMD, 0x7800), board_ahci }, /* AMD Hudson-2 */
+	/* AMD is using RAID class only for ahci controllers */
+	{ PCI_VENDOR_ID_AMD, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_STORAGE_RAID << 8, 0xffffff, board_ahci },
+
+	/* VIA */
+	{ PCI_VDEVICE(VIA, 0x3349), board_ahci_vt8251 }, /* VIA VT8251 */
+	{ PCI_VDEVICE(VIA, 0x6287), board_ahci_vt8251 }, /* VIA VT8251 */
+
+	/* NVIDIA */
+	{ PCI_VDEVICE(NVIDIA, 0x044c), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x044d), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x044e), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x044f), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x045c), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x045d), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x045e), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x045f), board_ahci_mcp65 },	/* MCP65 */
+	{ PCI_VDEVICE(NVIDIA, 0x0550), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0551), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0552), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0553), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0554), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0555), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0556), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0557), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0558), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0559), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x055a), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x055b), board_ahci_yesncq },	/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x0580), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0581), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0582), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0583), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0584), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0585), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0586), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0587), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0588), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x0589), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058a), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058b), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058c), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058d), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058e), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x058f), board_ahci_yesncq },	/* Linux ID */
+	{ PCI_VDEVICE(NVIDIA, 0x07f0), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f1), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f2), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f3), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f4), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f5), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f6), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f7), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f8), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f9), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07fa), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07fb), board_ahci_yesncq },	/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad0), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad1), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad2), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad3), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad4), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad5), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad6), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad7), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad8), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad9), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ada), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0adb), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab4), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab5), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab6), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab7), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab8), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ab9), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0aba), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0abb), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0abc), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0abd), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0abe), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0abf), board_ahci },		/* MCP79 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d84), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d85), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d86), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d87), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d88), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d89), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8a), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8b), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8c), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8d), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8e), board_ahci },		/* MCP89 */
+	{ PCI_VDEVICE(NVIDIA, 0x0d8f), board_ahci },		/* MCP89 */
+
+	/* SiS */
+	{ PCI_VDEVICE(SI, 0x1184), board_ahci },		/* SiS 966 */
+	{ PCI_VDEVICE(SI, 0x1185), board_ahci },		/* SiS 968 */
+	{ PCI_VDEVICE(SI, 0x0186), board_ahci },		/* SiS 968 */
+
+	/* Marvell */
+	{ PCI_VDEVICE(MARVELL, 0x6145), board_ahci_mv },	/* 6145 */
+	{ PCI_VDEVICE(MARVELL, 0x6121), board_ahci_mv },	/* 6121 */
+
+	/* Promise */
+	{ PCI_VDEVICE(PROMISE, 0x3f20), board_ahci },	/* PDC42819 */
+
+	/* Generic, PCI class code for AHCI */
+	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
+
+	{ }	/* terminate list */
+};
+#endif /* !Apollo */
+
+#ifdef CONFIG_ARCH_APOLLO
+static struct platform_driver ahci_apollo_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.bus		= &platform_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.probe			= ahci_apollo_probe,
+	.remove			= ahci_apollo_remove,
+#ifdef CONFIG_PM
+	.suspend		= ahci_apollo_suspend,
+	.resume			= ahci_apollo_resume,
+#endif
+};
+#else /* PCI */
+static struct pci_driver ahci_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= ahci_pci_tbl,
+	.probe			= ahci_init_one,
+	.remove			= ata_pci_remove_one,
+#ifdef CONFIG_PM
+	.suspend		= ahci_pci_device_suspend,
+	.resume			= ahci_pci_device_resume,
+#endif
+};
+#endif /* Apollo || PCI */
+
+static int ahci_em_messages = 1;
+module_param(ahci_em_messages, int, 0444);
+/* add other LED protocol types when they become supported */
+MODULE_PARM_DESC(ahci_em_messages,
+	"Set AHCI Enclosure Management Message type (0 = disabled, 1 = LED");
+
+#if defined(CONFIG_PATA_MARVELL) || defined(CONFIG_PATA_MARVELL_MODULE)
+static int marvell_enable;
+#else
+static int marvell_enable = 1;
+#endif
+module_param(marvell_enable, int, 0644);
+MODULE_PARM_DESC(marvell_enable, "Marvell SATA via AHCI (1 = enabled)");
+
+
+static inline int ahci_nr_ports(u32 cap)
+{
+	return (cap & 0x1f) + 1;
+}
+
+static inline void __iomem *ahci_base(struct ata_host *host)
+{
+#ifdef CONFIG_ARCH_APOLLO
+	return ((struct ahci_host_priv *)host->private_data)->mmio;
+#else
+	return host->iomap[AHCI_PCI_BAR];
+#endif
+}
+
+static inline void __iomem *__ahci_port_base(struct ata_host *host,
+					     unsigned int port_no)
+{
+	void __iomem *mmio = ahci_base(host);
+
+	return mmio + 0x100 + (port_no * 0x80);
+}
+
+static inline void __iomem *ahci_port_base(struct ata_port *ap)
+{
+	return __ahci_port_base(ap->host, ap->port_no);
+}
+
+static void ahci_enable_ahci(void __iomem *mmio)
+{
+	int i;
+	u32 tmp;
+
+	/* turn on AHCI_EN */
+	tmp = readl(mmio + HOST_CTL);
+	if (tmp & HOST_AHCI_EN)
+		return;
+
+	/* Some controllers need AHCI_EN to be written multiple times.
+	 * Try a few times before giving up.
+	 */
+	for (i = 0; i < 5; i++) {
+		tmp |= HOST_AHCI_EN;
+		writel(tmp, mmio + HOST_CTL);
+		tmp = readl(mmio + HOST_CTL);	/* flush && sanity check */
+		if (tmp & HOST_AHCI_EN)
+			return;
+		msleep(10);
+	}
+
+	WARN_ON(1);
+}
+
+static ssize_t ahci_show_host_caps(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct ata_port *ap = ata_shost_to_port(shost);
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+
+	return sprintf(buf, "%x\n", hpriv->cap);
+}
+
+static ssize_t ahci_show_host_cap2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct ata_port *ap = ata_shost_to_port(shost);
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+
+	return sprintf(buf, "%x\n", hpriv->cap2);
+}
+
+static ssize_t ahci_show_host_version(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct ata_port *ap = ata_shost_to_port(shost);
+#ifdef CONFIG_ARCH_APOLLO
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+    void __iomem *mmio = hpriv->mmio;
+#else
+	void __iomem *mmio = ap->host->iomap[AHCI_PCI_BAR];
+#endif
+	return sprintf(buf, "%x\n", readl(mmio + HOST_VERSION));
+}
+
+static ssize_t ahci_show_port_cmd(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(dev);
+	struct ata_port *ap = ata_shost_to_port(shost);
+	void __iomem *port_mmio = ahci_port_base(ap);
+
+	return sprintf(buf, "%x\n", readl(port_mmio + PORT_CMD));
+}
+
+/**
+ *	ahci_save_initial_config - Save and fixup initial config values
+ *	@pdev: target PCI device
+ *	@hpriv: host private area to store config values
+ *
+ *	Some registers containing configuration info might be setup by
+ *	BIOS and might be cleared on reset.  This function saves the
+ *	initial values of those registers into @hpriv such that they
+ *	can be restored after controller reset.
+ *
+ *	If inconsistent, config values are fixed up by this function.
+ *
+ *	LOCKING:
+ *	None.
+ */
+static void ahci_save_initial_config(struct device *dev,
+				     struct ahci_host_priv *hpriv)
+{
+#ifdef CONFIG_ARCH_APOLLO
+	void __iomem *mmio = hpriv->mmio;
+#else
+	struct pci_dev *pdev = to_pci_dev(dev);
+	void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+	int mv;
+#endif
+	u32 cap, cap2, vers, port_map;
+	int i;
+
+	/* make sure AHCI mode is enabled before accessing CAP */
+	ahci_enable_ahci(mmio);
+
+	/* Values prefixed with saved_ are written back to host after
+	 * reset.  Values without are used for driver operation.
+	 */
+	hpriv->saved_cap = cap = readl(mmio + HOST_CAP);
+	hpriv->saved_port_map = port_map = readl(mmio + HOST_PORTS_IMPL);
+
+	/* CAP2 register is only defined for AHCI 1.2 and later */
+	vers = readl(mmio + HOST_VERSION);
+	if ((vers >> 16) > 1 ||
+	   ((vers >> 16) == 1 && (vers & 0xFFFF) >= 0x200))
+		hpriv->saved_cap2 = cap2 = readl(mmio + HOST_CAP2);
+	else
+		hpriv->saved_cap2 = cap2 = 0;
+
+	/* some chips have errata preventing 64bit use */
+	if ((cap & HOST_CAP_64) && (hpriv->flags & AHCI_HFLAG_32BIT_ONLY)) {
+		dev_printk(KERN_INFO, dev,
+			   "controller can't do 64bit DMA, forcing 32bit\n");
+		cap &= ~HOST_CAP_64;
+	}
+
+	if ((cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_NO_NCQ)) {
+		dev_printk(KERN_INFO, dev,
+			   "controller can't do NCQ, turning off CAP_NCQ\n");
+		cap &= ~HOST_CAP_NCQ;
+	}
+
+	if (!(cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_YES_NCQ)) {
+		dev_printk(KERN_INFO, dev,
+			   "controller can do NCQ, turning on CAP_NCQ\n");
+		cap |= HOST_CAP_NCQ;
+	}
+
+	if ((cap & HOST_CAP_PMP) && (hpriv->flags & AHCI_HFLAG_NO_PMP)) {
+		dev_printk(KERN_INFO, dev,
+			   "controller can't do PMP, turning off CAP_PMP\n");
+		cap &= ~HOST_CAP_PMP;
+	}
+
+	if ((cap & HOST_CAP_SNTF) && (hpriv->flags & AHCI_HFLAG_NO_SNTF)) {
+		dev_printk(KERN_INFO, dev,
+			   "controller can't do SNTF, turning off CAP_SNTF\n");
+		cap &= ~HOST_CAP_SNTF;
+	}
+
+#ifndef CONFIG_ARCH_APOLLO
+	if (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361 &&
+	    port_map != 1) {
+		dev_printk(KERN_INFO, dev,
+			   "JMB361 has only one port, port_map 0x%x -> 0x%x\n",
+			   port_map, 1);
+		port_map = 1;
+	}
+
+	/*
+	 * Temporary Marvell 6145 hack: PATA port presence
+	 * is asserted through the standard AHCI port
+	 * presence register, as bit 4 (counting from 0)
+	 */
+	if (hpriv->flags & AHCI_HFLAG_MV_PATA) {
+		if (pdev->device == 0x6121)
+			mv = 0x3;
+		else
+			mv = 0xf;
+		dev_printk(KERN_ERR, dev,
+			   "MV_AHCI HACK: port_map %x -> %x\n",
+			   port_map,
+			   port_map & mv);
+		dev_printk(KERN_ERR, dev,
+			  "Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");
+
+		port_map &= mv;
+	}
+#endif /* !Apollo */
+
+	/* cross check port_map and cap.n_ports */
+	if (port_map) {
+		int map_ports = 0;
+
+		for (i = 0; i < AHCI_MAX_PORTS; i++)
+			if (port_map & (1 << i))
+				map_ports++;
+
+		/* If PI has more ports than n_ports, whine, clear
+		 * port_map and let it be generated from n_ports.
+		 */
+		if (map_ports > ahci_nr_ports(cap)) {
+			dev_printk(KERN_WARNING, dev,
+				   "implemented port map (0x%x) contains more "
+				   "ports than nr_ports (%u), using nr_ports\n",
+				   port_map, ahci_nr_ports(cap));
+			port_map = 0;
+		}
+	}
+
+	/* fabricate port_map from cap.nr_ports */
+	if (!port_map) {
+		port_map = (1 << ahci_nr_ports(cap)) - 1;
+		dev_printk(KERN_WARNING, dev,
+			   "forcing PORTS_IMPL to 0x%x\n", port_map);
+
+		/* write the fixed up value to the PI register */
+		hpriv->saved_port_map = port_map;
+	}
+
+	/* record values to use during operation */
+	hpriv->cap = cap;
+	hpriv->cap2 = cap2;
+	hpriv->port_map = port_map;
+}
+
+/**
+ *	ahci_restore_initial_config - Restore initial config
+ *	@host: target ATA host
+ *
+ *	Restore initial config stored by ahci_save_initial_config().
+ *
+ *	LOCKING:
+ *	None.
+ */
+static void ahci_restore_initial_config(struct ata_host *host)
+{
+	struct ahci_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = ahci_base(host);
+
+	writel(hpriv->saved_cap, mmio + HOST_CAP);
+	if (hpriv->saved_cap2)
+		writel(hpriv->saved_cap2, mmio + HOST_CAP2);
+	writel(hpriv->saved_port_map, mmio + HOST_PORTS_IMPL);
+	(void) readl(mmio + HOST_PORTS_IMPL);	/* flush */
+}
+
+static unsigned ahci_scr_offset(struct ata_port *ap, unsigned int sc_reg)
+{
+	static const int offset[] = {
+		[SCR_STATUS]		= PORT_SCR_STAT,
+		[SCR_CONTROL]		= PORT_SCR_CTL,
+		[SCR_ERROR]		= PORT_SCR_ERR,
+		[SCR_ACTIVE]		= PORT_SCR_ACT,
+		[SCR_NOTIFICATION]	= PORT_SCR_NTF,
+	};
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+
+	if (sc_reg < ARRAY_SIZE(offset) &&
+	    (sc_reg != SCR_NOTIFICATION || (hpriv->cap & HOST_CAP_SNTF)))
+		return offset[sc_reg];
+	return 0;
+}
+
+static int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)
+{
+	void __iomem *port_mmio = ahci_port_base(link->ap);
+	int offset = ahci_scr_offset(link->ap, sc_reg);
+
+	if (offset) {
+		*val = readl(port_mmio + offset);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)
+{
+	void __iomem *port_mmio = ahci_port_base(link->ap);
+	int offset = ahci_scr_offset(link->ap, sc_reg);
+
+	if (offset) {
+		writel(val, port_mmio + offset);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void ahci_start_engine(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 tmp;
+
+	//wmb();
+
+	/* start DMA */
+	tmp = readl(port_mmio + PORT_CMD);
+	tmp |= PORT_CMD_START;
+	writel(tmp, port_mmio + PORT_CMD);
+	readl(port_mmio + PORT_CMD); /* flush */
+}
+
+static int ahci_stop_engine(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 tmp;
+
+	tmp = readl(port_mmio + PORT_CMD);
+
+	/* check if the HBA is idle */
+	if ((tmp & (PORT_CMD_START | PORT_CMD_LIST_ON)) == 0)
+		return 0;
+
+	/* setting HBA to idle */
+	tmp &= ~PORT_CMD_START;
+	writel(tmp, port_mmio + PORT_CMD);
+
+	/* wait for engine to stop. This could be as long as 500 msec */
+	tmp = ata_wait_register(port_mmio + PORT_CMD,
+				PORT_CMD_LIST_ON, PORT_CMD_LIST_ON, 1, 500);
+	if (tmp & PORT_CMD_LIST_ON)
+		return -EIO;
+
+	return 0;
+}
+
+static void ahci_start_fis_rx(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	struct ahci_port_priv *pp = ap->private_data;
+	u32 tmp;
+
+	/* set FIS registers */
+	if (hpriv->cap & HOST_CAP_64)
+		writel((pp->cmd_slot_dma >> 16) >> 16,
+		       port_mmio + PORT_LST_ADDR_HI);
+	writel(pp->cmd_slot_dma & 0xffffffff, port_mmio + PORT_LST_ADDR);
+
+	if (hpriv->cap & HOST_CAP_64)
+		writel((pp->rx_fis_dma >> 16) >> 16,
+		       port_mmio + PORT_FIS_ADDR_HI);
+	writel(pp->rx_fis_dma & 0xffffffff, port_mmio + PORT_FIS_ADDR);
+
+	/* enable FIS reception */
+	tmp = readl(port_mmio + PORT_CMD);
+	tmp |= PORT_CMD_FIS_RX;
+	writel(tmp, port_mmio + PORT_CMD);
+
+	/* flush */
+	readl(port_mmio + PORT_CMD);
+}
+
+static int ahci_stop_fis_rx(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 tmp;
+
+	/* disable FIS reception */
+	tmp = readl(port_mmio + PORT_CMD);
+	tmp &= ~PORT_CMD_FIS_RX;
+	writel(tmp, port_mmio + PORT_CMD);
+
+	/* wait for completion, spec says 500ms, give it 1000 */
+	tmp = ata_wait_register(port_mmio + PORT_CMD, PORT_CMD_FIS_ON,
+				PORT_CMD_FIS_ON, 10, 1000);
+	if (tmp & PORT_CMD_FIS_ON)
+		return -EBUSY;
+
+	return 0;
+}
+
+static void ahci_power_up(struct ata_port *ap)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 cmd;
+
+	cmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;
+
+	/* spin up device */
+	if (hpriv->cap & HOST_CAP_SSS) {
+		cmd |= PORT_CMD_SPIN_UP;
+		writel(cmd, port_mmio + PORT_CMD);
+	}
+
+	/* wake up link */
+	writel(cmd | PORT_CMD_ICC_ACTIVE, port_mmio + PORT_CMD);
+}
+
+static void ahci_disable_alpm(struct ata_port *ap)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 cmd;
+	struct ahci_port_priv *pp = ap->private_data;
+
+	/* IPM bits should be disabled by libata-core */
+	/* get the existing command bits */
+	cmd = readl(port_mmio + PORT_CMD);
+
+	/* disable ALPM and ASP */
+	cmd &= ~PORT_CMD_ASP;
+	cmd &= ~PORT_CMD_ALPE;
+
+	/* force the interface back to active */
+	cmd |= PORT_CMD_ICC_ACTIVE;
+
+	/* write out new cmd value */
+	writel(cmd, port_mmio + PORT_CMD);
+	cmd = readl(port_mmio + PORT_CMD);
+
+	/* wait 10ms to be sure we've come out of any low power state */
+	msleep(10);
+
+	/* clear out any PhyRdy stuff from interrupt status */
+	writel(PORT_IRQ_PHYRDY, port_mmio + PORT_IRQ_STAT);
+
+	/* go ahead and clean out PhyRdy Change from Serror too */
+	ahci_scr_write(&ap->link, SCR_ERROR, ((1 << 16) | (1 << 18)));
+
+	/*
+ 	 * Clear flag to indicate that we should ignore all PhyRdy
+ 	 * state changes
+ 	 */
+	hpriv->flags &= ~AHCI_HFLAG_NO_HOTPLUG;
+
+	/*
+ 	 * Enable interrupts on Phy Ready.
+ 	 */
+	pp->intr_mask |= PORT_IRQ_PHYRDY;
+	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
+
+	/*
+ 	 * don't change the link pm policy - we can be called
+ 	 * just to turn of link pm temporarily
+ 	 */
+}
+
+static int ahci_enable_alpm(struct ata_port *ap,
+	enum link_pm policy)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 cmd;
+	struct ahci_port_priv *pp = ap->private_data;
+	u32 asp;
+
+	/* Make sure the host is capable of link power management */
+	if (!(hpriv->cap & HOST_CAP_ALPM))
+		return -EINVAL;
+
+	switch (policy) {
+	case MAX_PERFORMANCE:
+	case NOT_AVAILABLE:
+		/*
+ 		 * if we came here with NOT_AVAILABLE,
+ 		 * it just means this is the first time we
+ 		 * have tried to enable - default to max performance,
+ 		 * and let the user go to lower power modes on request.
+ 		 */
+		ahci_disable_alpm(ap);
+		return 0;
+	case MIN_POWER:
+		/* configure HBA to enter SLUMBER */
+		asp = PORT_CMD_ASP;
+		break;
+	case MEDIUM_POWER:
+		/* configure HBA to enter PARTIAL */
+		asp = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+ 	 * Disable interrupts on Phy Ready. This keeps us from
+ 	 * getting woken up due to spurious phy ready interrupts
+	 * TBD - Hot plug should be done via polling now, is
+	 * that even supported?
+ 	 */
+	pp->intr_mask &= ~PORT_IRQ_PHYRDY;
+	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
+
+	/*
+ 	 * Set a flag to indicate that we should ignore all PhyRdy
+ 	 * state changes since these can happen now whenever we
+ 	 * change link state
+ 	 */
+	hpriv->flags |= AHCI_HFLAG_NO_HOTPLUG;
+
+	/* get the existing command bits */
+	cmd = readl(port_mmio + PORT_CMD);
+
+	/*
+ 	 * Set ASP based on Policy
+ 	 */
+	cmd |= asp;
+
+	/*
+ 	 * Setting this bit will instruct the HBA to aggressively
+ 	 * enter a lower power link state when it's appropriate and
+ 	 * based on the value set above for ASP
+ 	 */
+	cmd |= PORT_CMD_ALPE;
+
+	/* write out new cmd value */
+	writel(cmd, port_mmio + PORT_CMD);
+	cmd = readl(port_mmio + PORT_CMD);
+
+	/* IPM bits should be set by libata-core */
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static void ahci_power_down(struct ata_port *ap)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 cmd, scontrol;
+
+	if (!(hpriv->cap & HOST_CAP_SSS))
+		return;
+
+	/* put device into listen mode, first set PxSCTL.DET to 0 */
+	scontrol = readl(port_mmio + PORT_SCR_CTL);
+	scontrol &= ~0xf;
+	writel(scontrol, port_mmio + PORT_SCR_CTL);
+
+	/* then set PxCMD.SUD to 0 */
+	cmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;
+	cmd &= ~PORT_CMD_SPIN_UP;
+	writel(cmd, port_mmio + PORT_CMD);
+}
+#endif
+
+static void ahci_start_port(struct ata_port *ap)
+{
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ata_link *link;
+	struct ahci_em_priv *emp;
+	ssize_t rc;
+	int i;
+
+	/* enable FIS reception */
+	ahci_start_fis_rx(ap);
+
+	/* enable DMA */
+	ahci_start_engine(ap);
+
+	/* turn on LEDs */
+	if (ap->flags & ATA_FLAG_EM) {
+		ata_for_each_link(link, ap, EDGE) {
+			emp = &pp->em_priv[link->pmp];
+
+			/* EM Transmit bit maybe busy during init */
+			for (i = 0; i < EM_MAX_RETRY; i++) {
+				rc = ahci_transmit_led_message(ap,
+							       emp->led_state,
+							       4);
+				if (rc == -EBUSY)
+					msleep(1);
+				else
+					break;
+			}
+		}
+	}
+
+	if (ap->flags & ATA_FLAG_SW_ACTIVITY)
+		ata_for_each_link(link, ap, EDGE)
+			ahci_init_sw_activity(link);
+
+}
+
+static int ahci_deinit_port(struct ata_port *ap, const char **emsg)
+{
+	int rc;
+
+	/* disable DMA */
+	rc = ahci_stop_engine(ap);
+	if (rc) {
+		*emsg = "failed to stop engine";
+		return rc;
+	}
+
+	/* disable FIS reception */
+	rc = ahci_stop_fis_rx(ap);
+	if (rc) {
+		*emsg = "failed stop FIS RX";
+		return rc;
+	}
+
+	return 0;
+}
+
+static int ahci_reset_controller(struct ata_host *host)
+{
+#ifndef CONFIG_ARCH_APOLLO
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+#endif
+	void __iomem *mmio = ahci_base(host);
+	u32 tmp;
+
+	/* we must be in AHCI mode, before using anything
+	 * AHCI-specific, such as HOST_RESET.
+	 */
+	ahci_enable_ahci(mmio);
+
+	/* global controller reset */
+	if (!ahci_skip_host_reset) {
+		tmp = readl(mmio + HOST_CTL);
+		if ((tmp & HOST_RESET) == 0) {
+			writel(tmp | HOST_RESET, mmio + HOST_CTL);
+			readl(mmio + HOST_CTL); /* flush */
+		}
+
+		/*
+		 * to perform host reset, OS should set HOST_RESET
+		 * and poll until this bit is read to be "0".
+		 * reset must complete within 1 second, or
+		 * the hardware should be considered fried.
+		 */
+		tmp = ata_wait_register(mmio + HOST_CTL, HOST_RESET,
+					HOST_RESET, 10, 1000);
+
+		if (tmp & HOST_RESET) {
+			dev_printk(KERN_ERR, host->dev,
+				   "controller reset failed (0x%x)\n", tmp);
+			return -EIO;
+		}
+
+		/* turn on AHCI mode */
+		ahci_enable_ahci(mmio);
+
+		/* Some registers might be cleared on reset.  Restore
+		 * initial values.
+		 */
+		ahci_restore_initial_config(host);
+	} else
+		dev_printk(KERN_INFO, host->dev,
+			   "skipping global host reset\n");
+
+#ifndef CONFIG_ARCH_APOLLO
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
+		u16 tmp16;
+
+		/* configure PCS */
+		pci_read_config_word(pdev, 0x92, &tmp16);
+		if ((tmp16 & hpriv->port_map) != hpriv->port_map) {
+			tmp16 |= hpriv->port_map;
+			pci_write_config_word(pdev, 0x92, tmp16);
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static void ahci_sw_activity(struct ata_link *link)
+{
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp = &pp->em_priv[link->pmp];
+
+	if (!(link->flags & ATA_LFLAG_SW_ACTIVITY))
+		return;
+
+	emp->activity++;
+	if (!timer_pending(&emp->timer))
+		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(10));
+}
+
+static void ahci_sw_activity_blink(unsigned long arg)
+{
+	struct ata_link *link = (struct ata_link *)arg;
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp = &pp->em_priv[link->pmp];
+	unsigned long led_message = emp->led_state;
+	u32 activity_led_state;
+	unsigned long flags;
+
+	led_message &= EM_MSG_LED_VALUE;
+	led_message |= ap->port_no | (link->pmp << 8);
+
+	/* check to see if we've had activity.  If so,
+	 * toggle state of LED and reset timer.  If not,
+	 * turn LED to desired idle state.
+	 */
+	spin_lock_irqsave(ap->lock, flags);
+	if (emp->saved_activity != emp->activity) {
+		emp->saved_activity = emp->activity;
+		/* get the current LED state */
+		activity_led_state = led_message & EM_MSG_LED_VALUE_ON;
+
+		if (activity_led_state)
+			activity_led_state = 0;
+		else
+			activity_led_state = 1;
+
+		/* clear old state */
+		led_message &= ~EM_MSG_LED_VALUE_ACTIVITY;
+
+		/* toggle state */
+		led_message |= (activity_led_state << 16);
+		mod_timer(&emp->timer, jiffies + msecs_to_jiffies(100));
+	} else {
+		/* switch to idle */
+		led_message &= ~EM_MSG_LED_VALUE_ACTIVITY;
+		if (emp->blink_policy == BLINK_OFF)
+			led_message |= (1 << 16);
+	}
+	spin_unlock_irqrestore(ap->lock, flags);
+	ahci_transmit_led_message(ap, led_message, 4);
+}
+
+static void ahci_init_sw_activity(struct ata_link *link)
+{
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp = &pp->em_priv[link->pmp];
+
+	/* init activity stats, setup timer */
+	emp->saved_activity = emp->activity = 0;
+	setup_timer(&emp->timer, ahci_sw_activity_blink, (unsigned long)link);
+
+	/* check our blink policy and set flag for link if it's enabled */
+	if (emp->blink_policy)
+		link->flags |= ATA_LFLAG_SW_ACTIVITY;
+}
+
+static int ahci_reset_em(struct ata_host *host)
+{
+	void __iomem *mmio = ahci_base(host);
+	u32 em_ctl;
+
+	em_ctl = readl(mmio + HOST_EM_CTL);
+	if ((em_ctl & EM_CTL_TM) || (em_ctl & EM_CTL_RST))
+		return -EINVAL;
+
+	writel(em_ctl | EM_CTL_RST, mmio + HOST_EM_CTL);
+	return 0;
+}
+
+static ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,
+					ssize_t size)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	struct ahci_port_priv *pp = ap->private_data;
+	void __iomem *mmio = ahci_base(ap->host);
+	u32 em_ctl;
+	u32 message[] = {0, 0};
+	unsigned long flags;
+	int pmp;
+	struct ahci_em_priv *emp;
+
+	/* get the slot number from the message */
+	pmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;
+	if (pmp < EM_MAX_SLOTS)
+		emp = &pp->em_priv[pmp];
+	else
+		return -EINVAL;
+
+	spin_lock_irqsave(ap->lock, flags);
+
+	/*
+	 * if we are still busy transmitting a previous message,
+	 * do not allow
+	 */
+	em_ctl = readl(mmio + HOST_EM_CTL);
+	if (em_ctl & EM_CTL_TM) {
+		spin_unlock_irqrestore(ap->lock, flags);
+		return -EBUSY;
+	}
+
+	/*
+	 * create message header - this is all zero except for
+	 * the message size, which is 4 bytes.
+	 */
+	message[0] |= (4 << 8);
+
+	/* ignore 0:4 of byte zero, fill in port info yourself */
+	message[1] = ((state & ~EM_MSG_LED_HBA_PORT) | ap->port_no);
+
+	/* write message to EM_LOC */
+	writel(message[0], mmio + hpriv->em_loc);
+	writel(message[1], mmio + hpriv->em_loc+4);
+
+	/* save off new led state for port/slot */
+	emp->led_state = state;
+
+	/*
+	 * tell hardware to transmit the message
+	 */
+	writel(em_ctl | EM_CTL_TM, mmio + HOST_EM_CTL);
+
+	spin_unlock_irqrestore(ap->lock, flags);
+	return size;
+}
+
+static ssize_t ahci_led_show(struct ata_port *ap, char *buf)
+{
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ata_link *link;
+	struct ahci_em_priv *emp;
+	int rc = 0;
+
+	ata_for_each_link(link, ap, EDGE) {
+		emp = &pp->em_priv[link->pmp];
+		rc += sprintf(buf, "%lx\n", emp->led_state);
+	}
+	return rc;
+}
+
+static ssize_t ahci_led_store(struct ata_port *ap, const char *buf,
+				size_t size)
+{
+	int state;
+	int pmp;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp;
+
+	state = simple_strtoul(buf, NULL, 0);
+
+	/* get the slot number from the message */
+	pmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;
+	if (pmp < EM_MAX_SLOTS)
+		emp = &pp->em_priv[pmp];
+	else
+		return -EINVAL;
+
+	/* mask off the activity bits if we are in sw_activity
+	 * mode, user should turn off sw_activity before setting
+	 * activity led through em_message
+	 */
+	if (emp->blink_policy)
+		state &= ~EM_MSG_LED_VALUE_ACTIVITY;
+
+	return ahci_transmit_led_message(ap, state, size);
+}
+
+static ssize_t ahci_activity_store(struct ata_device *dev, enum sw_activity val)
+{
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp = &pp->em_priv[link->pmp];
+	u32 port_led_state = emp->led_state;
+
+	/* save the desired Activity LED behavior */
+	if (val == OFF) {
+		/* clear LFLAG */
+		link->flags &= ~(ATA_LFLAG_SW_ACTIVITY);
+
+		/* set the LED to OFF */
+		port_led_state &= EM_MSG_LED_VALUE_OFF;
+		port_led_state |= (ap->port_no | (link->pmp << 8));
+		ahci_transmit_led_message(ap, port_led_state, 4);
+	} else {
+		link->flags |= ATA_LFLAG_SW_ACTIVITY;
+		if (val == BLINK_OFF) {
+			/* set LED to ON for idle */
+			port_led_state &= EM_MSG_LED_VALUE_OFF;
+			port_led_state |= (ap->port_no | (link->pmp << 8));
+			port_led_state |= EM_MSG_LED_VALUE_ON; /* check this */
+			ahci_transmit_led_message(ap, port_led_state, 4);
+		}
+	}
+	emp->blink_policy = val;
+	return 0;
+}
+
+static ssize_t ahci_activity_show(struct ata_device *dev, char *buf)
+{
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_em_priv *emp = &pp->em_priv[link->pmp];
+
+	/* display the saved value of activity behavior for this
+	 * disk.
+	 */
+	return sprintf(buf, "%d\n", emp->blink_policy);
+}
+
+static void ahci_port_init(struct device *dev, struct ata_port *ap,
+			   int port_no, void __iomem *mmio,
+			   void __iomem *port_mmio)
+{
+#ifndef CONFIG_ARCH_APOLLO
+	struct pci_dev *pdev = to_pci_dev(dev);
+#endif
+	const char *emsg = NULL;
+	int rc;
+	u32 tmp;
+
+	/* make sure port is not active */
+	rc = ahci_deinit_port(ap, &emsg);
+	if (rc)
+		dev_printk(KERN_WARNING, dev,
+			   "%s (%d)\n", emsg, rc);
+
+	/* clear SError */
+	tmp = readl(port_mmio + PORT_SCR_ERR);
+	VPRINTK("PORT_SCR_ERR 0x%x\n", tmp);
+	writel(tmp, port_mmio + PORT_SCR_ERR);
+
+	/* clear port IRQ */
+	tmp = readl(port_mmio + PORT_IRQ_STAT);
+	VPRINTK("PORT_IRQ_STAT 0x%x\n", tmp);
+	if (tmp)
+		writel(tmp, port_mmio + PORT_IRQ_STAT);
+
+	writel(1 << port_no, mmio + HOST_IRQ_STAT);
+}
+
+static void ahci_init_controller(struct ata_host *host)
+{
+#ifndef CONFIG_ARCH_APOLLO
+	struct ahci_host_priv *hpriv = host->private_data;
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	int mv;
+#endif
+	void __iomem *mmio = ahci_base(host);
+	int i;
+	void __iomem *port_mmio;
+	u32 tmp;
+
+#ifndef CONFIG_ARCH_APOLLO
+	if (hpriv->flags & AHCI_HFLAG_MV_PATA) {
+		if (pdev->device == 0x6121)
+			mv = 2;
+		else
+			mv = 4;
+		port_mmio = __ahci_port_base(host, mv);
+
+		writel(0, port_mmio + PORT_IRQ_MASK);
+
+		/* clear port IRQ */
+		tmp = readl(port_mmio + PORT_IRQ_STAT);
+		VPRINTK("PORT_IRQ_STAT 0x%x\n", tmp);
+		if (tmp)
+			writel(tmp, port_mmio + PORT_IRQ_STAT);
+	}
+#endif
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		port_mmio = ahci_port_base(ap);
+		if (ata_port_is_dummy(ap))
+			continue;
+
+		ahci_port_init(host->dev, ap, i, mmio, port_mmio);
+	}
+
+	tmp = readl(mmio + HOST_CTL);
+	VPRINTK("HOST_CTL 0x%x\n", tmp);
+	writel(tmp | HOST_IRQ_EN, mmio + HOST_CTL);
+	tmp = readl(mmio + HOST_CTL);
+	VPRINTK("HOST_CTL 0x%x\n", tmp);
+}
+
+static void ahci_dev_config(struct ata_device *dev)
+{
+	struct ahci_host_priv *hpriv = dev->link->ap->host->private_data;
+
+	if (hpriv->flags & AHCI_HFLAG_SECT255) {
+		dev->max_sectors = 255;
+		ata_dev_printk(dev, KERN_INFO,
+			       "SB600 AHCI: limiting to 255 sectors per cmd\n");
+	}
+}
+
+static unsigned int ahci_dev_classify(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ata_taskfile tf;
+	u32 tmp;
+
+	tmp = readl(port_mmio + PORT_SIG);
+	tf.lbah		= (tmp >> 24)	& 0xff;
+	tf.lbam		= (tmp >> 16)	& 0xff;
+	tf.lbal		= (tmp >> 8)	& 0xff;
+	tf.nsect	= (tmp)		& 0xff;
+
+	return ata_dev_classify(&tf);
+}
+
+static void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
+			       u32 opts)
+{
+	dma_addr_t cmd_tbl_dma;
+
+	cmd_tbl_dma = pp->cmd_tbl_dma + tag * AHCI_CMD_TBL_SZ;
+
+	pp->cmd_slot[tag].opts = cpu_to_le32(opts);
+	pp->cmd_slot[tag].status = 0;
+	pp->cmd_slot[tag].tbl_addr = cpu_to_le32(cmd_tbl_dma & 0xffffffff);
+	pp->cmd_slot[tag].tbl_addr_hi = cpu_to_le32((cmd_tbl_dma >> 16) >> 16);
+	//wmb();
+}
+
+static int ahci_kick_engine(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	u8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;
+	u32 tmp;
+	int busy, rc;
+
+	/* stop engine */
+	rc = ahci_stop_engine(ap);
+	if (rc)
+		goto out_restart;
+
+	/* need to do CLO?
+	 * always do CLO if PMP is attached (AHCI-1.3 9.2)
+	 */
+	busy = status & (ATA_BUSY | ATA_DRQ);
+	if (!busy && !sata_pmp_attached(ap)) {
+		rc = 0;
+		goto out_restart;
+	}
+
+	if (!(hpriv->cap & HOST_CAP_CLO)) {
+		rc = -EOPNOTSUPP;
+		goto out_restart;
+	}
+
+	/* perform CLO */
+	tmp = readl(port_mmio + PORT_CMD);
+	tmp |= PORT_CMD_CLO;
+	writel(tmp, port_mmio + PORT_CMD);
+
+	rc = 0;
+	tmp = ata_wait_register(port_mmio + PORT_CMD,
+				PORT_CMD_CLO, PORT_CMD_CLO, 1, 500);
+	if (tmp & PORT_CMD_CLO)
+		rc = -EIO;
+
+	/* restart engine */
+ out_restart:
+	ahci_start_engine(ap);
+	return rc;
+}
+
+static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,
+				struct ata_taskfile *tf, int is_cmd, u16 flags,
+				unsigned long timeout_msec)
+{
+	const u32 cmd_fis_len = 5; /* five dwords */
+	struct ahci_port_priv *pp = ap->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u8 *fis = pp->cmd_tbl;
+	u32 tmp;
+
+	/* prep the command */
+	ata_tf_to_fis(tf, pmp, is_cmd, fis);
+	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp << 12));
+
+	/* issue & wait */
+	writel(1, port_mmio + PORT_CMD_ISSUE);
+
+	if (timeout_msec) {
+		tmp = ata_wait_register(port_mmio + PORT_CMD_ISSUE, 0x1, 0x1,
+					1, timeout_msec);
+		if (tmp & 0x1) {
+			ahci_kick_engine(ap);
+			return -EBUSY;
+		}
+	} else
+		readl(port_mmio + PORT_CMD_ISSUE);	/* flush */
+
+	return 0;
+}
+
+static int ahci_do_softreset(struct ata_link *link, unsigned int *class,
+			     int pmp, unsigned long deadline,
+			     int (*check_ready)(struct ata_link *link))
+{
+	struct ata_port *ap = link->ap;
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	const char *reason = NULL;
+	unsigned long now, msecs;
+	struct ata_taskfile tf;
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	/* prepare for SRST (AHCI-1.1 10.4.1) */
+	rc = ahci_kick_engine(ap);
+	if (rc && rc != -EOPNOTSUPP)
+		ata_link_printk(link, KERN_WARNING,
+				"failed to reset engine (errno=%d)\n", rc);
+
+	ata_tf_init(link->device, &tf);
+
+	/* issue the first D2H Register FIS */
+	msecs = 0;
+	now = jiffies;
+	if (time_after(now, deadline))
+		msecs = jiffies_to_msecs(deadline - now);
+
+	tf.ctl |= ATA_SRST;
+	if (ahci_exec_polled_cmd(ap, pmp, &tf, 0,
+				 AHCI_CMD_RESET | AHCI_CMD_CLR_BUSY, msecs)) {
+		rc = -EIO;
+		reason = "1st FIS failed";
+		goto fail;
+	}
+
+	/* spec says at least 5us, but be generous and sleep for 1ms */
+	msleep(1);
+
+	/* issue the second D2H Register FIS */
+	tf.ctl &= ~ATA_SRST;
+	ahci_exec_polled_cmd(ap, pmp, &tf, 0, 0, 0);
+
+	/* wait for link to become ready */
+	rc = ata_wait_after_reset(link, deadline, check_ready);
+	if (rc == -EBUSY && hpriv->flags & AHCI_HFLAG_SRST_TOUT_IS_OFFLINE) {
+		/*
+		 * Workaround for cases where link online status can't
+		 * be trusted.  Treat device readiness timeout as link
+		 * offline.
+		 */
+		ata_link_printk(link, KERN_INFO,
+				"device not ready, treating as offline\n");
+		*class = ATA_DEV_NONE;
+	} else if (rc) {
+		/* link occupied, -ENODEV too is an error */
+		reason = "device not ready";
+		goto fail;
+	} else
+		*class = ahci_dev_classify(ap);
+
+	DPRINTK("EXIT, class=%u\n", *class);
+	return 0;
+
+ fail:
+	ata_link_printk(link, KERN_ERR, "softreset failed (%s)\n", reason);
+	return rc;
+}
+
+static int ahci_check_ready(struct ata_link *link)
+{
+	void __iomem *port_mmio = ahci_port_base(link->ap);
+	u8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;
+
+	return ata_check_ready(status);
+}
+
+static int ahci_softreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline)
+{
+	int pmp = sata_srst_pmp(link);
+
+	DPRINTK("ENTER\n");
+
+	return ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);
+}
+
+static int ahci_sb600_check_ready(struct ata_link *link)
+{
+	void __iomem *port_mmio = ahci_port_base(link->ap);
+	u8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;
+	u32 irq_status = readl(port_mmio + PORT_IRQ_STAT);
+
+	/*
+	 * There is no need to check TFDATA if BAD PMP is found due to HW bug,
+	 * which can save timeout delay.
+	 */
+	if (irq_status & PORT_IRQ_BAD_PMP)
+		return -EIO;
+
+	return ata_check_ready(status);
+}
+
+static int ahci_sb600_softreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	int pmp = sata_srst_pmp(link);
+	int rc;
+	u32 irq_sts;
+
+	DPRINTK("ENTER\n");
+
+	rc = ahci_do_softreset(link, class, pmp, deadline,
+			       ahci_sb600_check_ready);
+
+	/*
+	 * Soft reset fails on Apollo and some ATI chips with IPMS set when PMP
+	 * is enabled but SATA HDD/ODD is connected to SATA port,
+	 * do soft reset again to port 0.
+	 */
+	if (rc == -EIO) {
+		irq_sts = readl(port_mmio + PORT_IRQ_STAT);
+		if (irq_sts & PORT_IRQ_BAD_PMP) {
+			ata_link_printk(link, KERN_WARNING,
+					"applying Apollo PMP SRST workaround "
+					"and retrying\n");
+			rc = ahci_do_softreset(link, class, 0, deadline,
+					       ahci_check_ready);
+		}
+	}
+
+	return rc;
+}
+
+static int ahci_hardreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline)
+{
+	const unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	u8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;
+	struct ata_taskfile tf;
+	bool online;
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	ahci_stop_engine(ap);
+
+	/* clear D2H reception area to properly wait for D2H FIS */
+	ata_tf_init(link->device, &tf);
+	tf.command = 0x80;
+	ata_tf_to_fis(&tf, 0, 0, d2h_fis);
+
+	rc = sata_link_hardreset(link, timing, deadline, &online,
+				 ahci_check_ready);
+
+	ahci_start_engine(ap);
+
+	if (online)
+		*class = ahci_dev_classify(ap);
+
+	DPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);
+	return rc;
+}
+
+static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
+				 unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	bool online;
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	ahci_stop_engine(ap);
+
+	rc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),
+				 deadline, &online, NULL);
+
+	ahci_start_engine(ap);
+
+	DPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);
+
+	/* vt8251 doesn't clear BSY on signature FIS reception,
+	 * request follow-up softreset.
+	 */
+	return online ? -EAGAIN : rc;
+}
+
+#ifndef CONFIG_ARCH_APOLLO
+static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	u8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;
+	struct ata_taskfile tf;
+	bool online;
+	int rc;
+
+	ahci_stop_engine(ap);
+
+	/* clear D2H reception area to properly wait for D2H FIS */
+	ata_tf_init(link->device, &tf);
+	tf.command = 0x80;
+	ata_tf_to_fis(&tf, 0, 0, d2h_fis);
+
+	rc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),
+				 deadline, &online, NULL);
+
+	ahci_start_engine(ap);
+
+	/* The pseudo configuration device on SIMG4726 attached to
+	 * ASUS P5W-DH Deluxe doesn't send signature FIS after
+	 * hardreset if no device is attached to the first downstream
+	 * port && the pseudo device locks up on SRST w/ PMP==0.  To
+	 * work around this, wait for !BSY only briefly.  If BSY isn't
+	 * cleared, perform CLO and proceed to IDENTIFY (achieved by
+	 * ATA_LFLAG_NO_SRST and ATA_LFLAG_ASSUME_ATA).
+	 *
+	 * Wait for two seconds.  Devices attached to downstream port
+	 * which can't process the following IDENTIFY after this will
+	 * have to be reset again.  For most cases, this should
+	 * suffice while making probing snappish enough.
+	 */
+	if (online) {
+		rc = ata_wait_after_reset(link, jiffies + 2 * HZ,
+					  ahci_check_ready);
+		if (rc)
+			ahci_kick_engine(ap);
+	}
+	return rc;
+}
+#endif
+
+static void ahci_postreset(struct ata_link *link, unsigned int *class)
+{
+	struct ata_port *ap = link->ap;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 new_tmp, tmp;
+
+	ata_std_postreset(link, class);
+
+	/* Make sure port's ATAPI bit is set appropriately */
+	new_tmp = tmp = readl(port_mmio + PORT_CMD);
+	if (*class == ATA_DEV_ATAPI)
+		new_tmp |= PORT_CMD_ATAPI;
+	else
+		new_tmp &= ~PORT_CMD_ATAPI;
+	if (new_tmp != tmp) {
+		writel(new_tmp, port_mmio + PORT_CMD);
+		readl(port_mmio + PORT_CMD); /* flush */
+	}
+}
+
+static unsigned int ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl)
+{
+	struct scatterlist *sg;
+	struct ahci_sg *ahci_sg = cmd_tbl + AHCI_CMD_TBL_HDR_SZ;
+	unsigned int si;
+
+	VPRINTK("ENTER\n");
+
+	/*
+	 * Next, the S/G list.
+	 */
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
+		dma_addr_t addr = sg_dma_address(sg);
+		u32 sg_len = sg_dma_len(sg);
+
+		ahci_sg[si].addr = cpu_to_le32(addr & 0xffffffff);
+		ahci_sg[si].addr_hi = cpu_to_le32((addr >> 16) >> 16);
+		ahci_sg[si].flags_size = cpu_to_le32(sg_len - 1);
+	}
+
+	return si;
+}
+
+static int ahci_pmp_qc_defer(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+
+	if (!sata_pmp_attached(ap) || pp->fbs_enabled)
+		return ata_std_qc_defer(qc);
+	else
+		return sata_pmp_qc_defer_cmd_switch(qc);
+}
+
+static void ahci_qc_prep(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct ahci_port_priv *pp = ap->private_data;
+	int is_atapi = ata_is_atapi(qc->tf.protocol);
+	void *cmd_tbl;
+	u32 opts;
+	const u32 cmd_fis_len = 5; /* five dwords */
+	unsigned int n_elem;
+
+	/*
+	 * Fill in command table information.  First, the header,
+	 * a SATA Register - Host to Device command FIS.
+	 */
+	cmd_tbl = pp->cmd_tbl + qc->tag * AHCI_CMD_TBL_SZ;
+
+	ata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, cmd_tbl);
+	if (is_atapi) {
+		memset(cmd_tbl + AHCI_CMD_TBL_CDB, 0, 32);
+		memcpy(cmd_tbl + AHCI_CMD_TBL_CDB, qc->cdb, qc->dev->cdb_len);
+	}
+
+	n_elem = 0;
+	if (qc->flags & ATA_QCFLAG_DMAMAP)
+		n_elem = ahci_fill_sg(qc, cmd_tbl);
+
+	/*
+	 * Fill in command slot information.
+	 */
+	opts = cmd_fis_len | n_elem << 16 | (qc->dev->link->pmp << 12);
+	if (qc->tf.flags & ATA_TFLAG_WRITE)
+		opts |= AHCI_CMD_WRITE;
+	if (is_atapi)
+		opts |= AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH;
+
+	ahci_fill_cmd_slot(pp, qc->tag, opts);
+}
+
+static void ahci_fbs_dec_intr(struct ata_port *ap)
+{
+	struct ahci_port_priv *pp = ap->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 fbs = readl(port_mmio + PORT_FBS);
+	int retries = 3;
+
+	DPRINTK("ENTER\n");
+	BUG_ON(!pp->fbs_enabled);
+
+	/* time to wait for DEC is not specified by AHCI spec,
+	 * add a retry loop for safety.
+	 */
+	writel(fbs | PORT_FBS_DEC, port_mmio + PORT_FBS);
+	fbs = readl(port_mmio + PORT_FBS);
+	while ((fbs & PORT_FBS_DEC) && retries--) {
+		udelay(1);
+		fbs = readl(port_mmio + PORT_FBS);
+	}
+
+	if (fbs & PORT_FBS_DEC)
+		dev_printk(KERN_ERR, ap->host->dev,
+			   "failed to clear device error\n");
+}
+
+static void ahci_error_intr(struct ata_port *ap, u32 irq_stat)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ata_eh_info *host_ehi = &ap->link.eh_info;
+	struct ata_link *link = NULL;
+	struct ata_queued_cmd *active_qc;
+	struct ata_eh_info *active_ehi;
+	bool fbs_need_dec = false;
+	u32 serror;
+
+	/* determine active link with error */
+	if (pp->fbs_enabled) {
+		void __iomem *port_mmio = ahci_port_base(ap);
+		u32 fbs = readl(port_mmio + PORT_FBS);
+		int pmp = fbs >> PORT_FBS_DWE_OFFSET;
+
+		if ((fbs & PORT_FBS_SDE) && (pmp < ap->nr_pmp_links) &&
+		    ata_link_online(&ap->pmp_link[pmp])) {
+			link = &ap->pmp_link[pmp];
+			fbs_need_dec = true;
+		}
+
+	} else
+	ata_for_each_link(link, ap, EDGE)
+		if (ata_link_active(link))
+			break;
+
+	if (!link)
+		link = &ap->link;
+
+	active_qc = ata_qc_from_tag(ap, link->active_tag);
+	active_ehi = &link->eh_info;
+
+	/* record irq stat */
+	ata_ehi_clear_desc(host_ehi);
+	ata_ehi_push_desc(host_ehi, "irq_stat 0x%08x", irq_stat);
+
+	/* AHCI needs SError cleared; otherwise, it might lock up */
+	ahci_scr_read(&ap->link, SCR_ERROR, &serror);
+	ahci_scr_write(&ap->link, SCR_ERROR, serror);
+	host_ehi->serror |= serror;
+
+	/* some controllers set IRQ_IF_ERR on device errors, ignore it */
+	if (hpriv->flags & AHCI_HFLAG_IGN_IRQ_IF_ERR)
+		irq_stat &= ~PORT_IRQ_IF_ERR;
+
+	if (irq_stat & PORT_IRQ_TF_ERR) {
+		/* If qc is active, charge it; otherwise, the active
+		 * link.  There's no active qc on NCQ errors.  It will
+		 * be determined by EH by reading log page 10h.
+		 */
+		if (active_qc)
+			active_qc->err_mask |= AC_ERR_DEV;
+		else
+			active_ehi->err_mask |= AC_ERR_DEV;
+
+		if (hpriv->flags & AHCI_HFLAG_IGN_SERR_INTERNAL)
+			host_ehi->serror &= ~SERR_INTERNAL;
+	}
+
+	if (irq_stat & PORT_IRQ_UNK_FIS) {
+		u32 *unk = (u32 *)(pp->rx_fis + RX_FIS_UNK);
+
+		active_ehi->err_mask |= AC_ERR_HSM;
+		active_ehi->action |= ATA_EH_RESET;
+		ata_ehi_push_desc(active_ehi,
+				  "unknown FIS %08x %08x %08x %08x" ,
+				  unk[0], unk[1], unk[2], unk[3]);
+	}
+
+	if (sata_pmp_attached(ap) && (irq_stat & PORT_IRQ_BAD_PMP)) {
+		active_ehi->err_mask |= AC_ERR_HSM;
+		active_ehi->action |= ATA_EH_RESET;
+		ata_ehi_push_desc(active_ehi, "incorrect PMP");
+	}
+
+	if (irq_stat & (PORT_IRQ_HBUS_ERR | PORT_IRQ_HBUS_DATA_ERR)) {
+		host_ehi->err_mask |= AC_ERR_HOST_BUS;
+		host_ehi->action |= ATA_EH_RESET;
+		ata_ehi_push_desc(host_ehi, "host bus error");
+	}
+
+	if (irq_stat & PORT_IRQ_IF_ERR) {
+		if (fbs_need_dec)
+			active_ehi->err_mask |= AC_ERR_DEV;
+		else {
+			host_ehi->err_mask |= AC_ERR_ATA_BUS;
+			host_ehi->action |= ATA_EH_RESET;
+		}
+
+		ata_ehi_push_desc(host_ehi, "interface fatal error");
+	}
+
+	if (irq_stat & (PORT_IRQ_CONNECT | PORT_IRQ_PHYRDY)) {
+		ata_ehi_hotplugged(host_ehi);
+		ata_ehi_push_desc(host_ehi, "%s",
+			irq_stat & PORT_IRQ_CONNECT ?
+			"connection status changed" : "PHY RDY changed");
+	}
+
+	/* okay, let's hand over to EH */
+
+	if (irq_stat & PORT_IRQ_FREEZE)
+		ata_port_freeze(ap);
+	else if (fbs_need_dec) {
+		ata_link_abort(link);
+		ahci_fbs_dec_intr(ap);
+	} else
+		ata_port_abort(ap);
+}
+
+static void ahci_port_intr(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ata_eh_info *ehi = &ap->link.eh_info;
+	struct ahci_port_priv *pp = ap->private_data;
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	int resetting = !!(ap->pflags & ATA_PFLAG_RESETTING);
+	u32 status, qc_active = 0;
+	int rc;
+
+	status = readl(port_mmio + PORT_IRQ_STAT);
+	writel(status, port_mmio + PORT_IRQ_STAT);
+
+	/* ignore BAD_PMP while resetting */
+	if (unlikely(resetting))
+		status &= ~PORT_IRQ_BAD_PMP;
+
+	/* If we are getting PhyRdy, this is
+ 	 * just a power state change, we should
+ 	 * clear out this, plus the PhyRdy/Comm
+ 	 * Wake bits from Serror
+ 	 */
+	if ((hpriv->flags & AHCI_HFLAG_NO_HOTPLUG) &&
+		(status & PORT_IRQ_PHYRDY)) {
+		status &= ~PORT_IRQ_PHYRDY;
+		ahci_scr_write(&ap->link, SCR_ERROR, ((1 << 16) | (1 << 18)));
+	}
+
+	if (unlikely(status & PORT_IRQ_ERROR)) {
+		ahci_error_intr(ap, status);
+		return;
+	}
+
+	if (status & PORT_IRQ_SDB_FIS) {
+		/* If SNotification is available, leave notification
+		 * handling to sata_async_notification().  If not,
+		 * emulate it by snooping SDB FIS RX area.
+		 *
+		 * Snooping FIS RX area is probably cheaper than
+		 * poking SNotification but some constrollers which
+		 * implement SNotification, ICH9 for example, don't
+		 * store AN SDB FIS into receive area.
+		 */
+		if (hpriv->cap & HOST_CAP_SNTF)
+			sata_async_notification(ap);
+		else {
+			/* If the 'N' bit in word 0 of the FIS is set,
+			 * we just received asynchronous notification.
+			 * Tell libata about it.
+			 *
+			 * Lack of SNotification should not appear in
+			 * ahci 1.2, so the workaround is unnecessary
+			 * when FBS is enabled.
+			 */
+			if (pp->fbs_enabled)
+				WARN_ON_ONCE(1);
+			else {
+				const __le32 *f = pp->rx_fis + RX_FIS_SDB;
+				u32 f0 = le32_to_cpu(f[0]);
+				
+				if (f0 & (1 << 15))
+					sata_async_notification(ap);
+			}
+		}
+	}
+
+	/* pp->active_link is not reliable once FBS is enabled, both
+	 * PORT_SCR_ACT and PORT_CMD_ISSUE should be checked because
+	 * NCQ and non-NCQ commands may be in flight at the same time.
+	 */
+	if (pp->fbs_enabled) {
+		if (ap->qc_active) {
+			qc_active = readl(port_mmio + PORT_SCR_ACT);
+			qc_active |= readl(port_mmio + PORT_CMD_ISSUE);
+		}
+	} else {
+		/* pp->active_link is valid iff any command is in flight */
+		if (ap->qc_active && pp->active_link->sactive)
+			qc_active = readl(port_mmio + PORT_SCR_ACT);
+		else
+			qc_active = readl(port_mmio + PORT_CMD_ISSUE);
+	}
+
+	rc = ata_qc_complete_multiple(ap, qc_active);
+
+	/* while resetting, invalid completions are expected */
+	if (unlikely(rc < 0 && !resetting)) {
+		ehi->err_mask |= AC_ERR_HSM;
+		ehi->action |= ATA_EH_RESET;
+		ata_port_freeze(ap);
+	}
+}
+
+static irqreturn_t ahci_interrupt(int irq, void *dev_instance)
+{
+	struct ata_host *host = dev_instance;
+	struct ahci_host_priv *hpriv;
+	unsigned int i, handled = 0;
+	void __iomem *mmio;
+	u32 irq_stat, irq_masked;
+
+	VPRINTK("ENTER\n");
+
+	hpriv = host->private_data;
+	mmio = ahci_base(host);
+
+	/* sigh.  0xffffffff is a valid return from h/w */
+	irq_stat = readl(mmio + HOST_IRQ_STAT);
+	if (!irq_stat)
+		return IRQ_NONE;
+
+	irq_masked = irq_stat & hpriv->port_map;
+
+	spin_lock(&host->lock);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap;
+
+		if (!(irq_masked & (1 << i)))
+			continue;
+
+		ap = host->ports[i];
+		if (ap) {
+			ahci_port_intr(ap);
+			VPRINTK("port %u\n", i);
+		} else {
+			VPRINTK("port %u (no irq)\n", i);
+			if (ata_ratelimit())
+				dev_printk(KERN_WARNING, host->dev,
+					"interrupt on disabled port %u\n", i);
+		}
+
+		handled = 1;
+	}
+
+	/* HOST_IRQ_STAT behaves as level triggered latch meaning that
+	 * it should be cleared after all the port events are cleared;
+	 * otherwise, it will raise a spurious interrupt after each
+	 * valid one.  Please read section 10.6.2 of ahci 1.1 for more
+	 * information.
+	 *
+	 * Also, use the unmasked value to clear interrupt as spurious
+	 * pending event on a dummy port might cause screaming IRQ.
+	 */
+	writel(irq_stat, mmio + HOST_IRQ_STAT);
+
+	spin_unlock(&host->lock);
+
+	VPRINTK("EXIT\n");
+
+	return IRQ_RETVAL(handled);
+}
+
+static unsigned int ahci_qc_issue(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ahci_port_priv *pp = ap->private_data;
+
+	/* Keep track of the currently active link.  It will be used
+	 * in completion path to determine whether NCQ phase is in
+	 * progress.
+	 */
+	pp->active_link = qc->dev->link;
+
+	if (qc->tf.protocol == ATA_PROT_NCQ)
+		writel(1 << qc->tag, port_mmio + PORT_SCR_ACT);
+
+	if (pp->fbs_enabled && pp->fbs_last_dev != qc->dev->link->pmp) {
+		u32 fbs = readl(port_mmio + PORT_FBS);
+		fbs &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);
+		fbs |= qc->dev->link->pmp << PORT_FBS_DEV_OFFSET;
+		writel(fbs, port_mmio + PORT_FBS);
+		pp->fbs_last_dev = qc->dev->link->pmp;
+	}
+
+	//wmb();
+	writel(1 << qc->tag, port_mmio + PORT_CMD_ISSUE);
+
+	ahci_sw_activity(qc->dev->link);
+
+	return 0;
+}
+
+static bool ahci_qc_fill_rtf(struct ata_queued_cmd *qc)
+{
+	struct ahci_port_priv *pp = qc->ap->private_data;
+	u8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;
+
+	if (pp->fbs_enabled)
+		d2h_fis += qc->dev->link->pmp * AHCI_RX_FIS_SZ;
+
+	ata_tf_from_fis(d2h_fis, &qc->result_tf);
+	return true;
+}
+
+static void ahci_freeze(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+
+	/* turn IRQ off */
+	writel(0, port_mmio + PORT_IRQ_MASK);
+}
+
+static void ahci_thaw(struct ata_port *ap)
+{
+	void __iomem *mmio = ahci_base(ap->host);
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 tmp;
+	struct ahci_port_priv *pp = ap->private_data;
+
+	/* clear IRQ */
+	tmp = readl(port_mmio + PORT_IRQ_STAT);
+	writel(tmp, port_mmio + PORT_IRQ_STAT);
+	writel(1 << ap->port_no, mmio + HOST_IRQ_STAT);
+
+	/* turn IRQ back on */
+	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
+}
+
+static void ahci_error_handler(struct ata_port *ap)
+{
+	if (!(ap->pflags & ATA_PFLAG_FROZEN)) {
+		/* restart engine */
+		ahci_stop_engine(ap);
+		ahci_start_engine(ap);
+	}
+
+	sata_pmp_error_handler(ap);
+}
+
+static void ahci_post_internal_cmd(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+
+	/* make DMA engine forget about the failed command */
+	if (qc->flags & ATA_QCFLAG_FAILED)
+		ahci_kick_engine(ap);
+}
+
+static void ahci_enable_fbs(struct ata_port *ap)
+{
+	struct ahci_port_priv *pp = ap->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 fbs;
+	int rc;
+
+	if (!pp->fbs_supported)
+		return;
+
+	fbs = readl(port_mmio + PORT_FBS);
+	if (fbs & PORT_FBS_EN) {
+		pp->fbs_enabled = true;
+		pp->fbs_last_dev = -1; /* initialization */
+		return;
+	}
+
+	rc = ahci_stop_engine(ap);
+	if (rc)
+		return;
+
+	writel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);
+	fbs = readl(port_mmio + PORT_FBS);
+	if (fbs & PORT_FBS_EN) {
+		dev_printk(KERN_INFO, ap->host->dev, "FBS is enabled.\n");
+		pp->fbs_enabled = true;
+		pp->fbs_last_dev = -1; /* initialization */
+	} else
+		dev_printk(KERN_ERR, ap->host->dev, "Failed to enable FBS\n");
+
+	ahci_start_engine(ap);
+}
+
+static void ahci_disable_fbs(struct ata_port *ap)
+{
+	struct ahci_port_priv *pp = ap->private_data;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	u32 fbs;
+	int rc;
+
+	if (!pp->fbs_supported)
+		return;
+
+	fbs = readl(port_mmio + PORT_FBS);
+	if ((fbs & PORT_FBS_EN) == 0) {
+		pp->fbs_enabled = false;
+		return;
+	}
+
+	rc = ahci_stop_engine(ap);
+	if (rc)
+		return;
+
+	writel(fbs & ~PORT_FBS_EN, port_mmio + PORT_FBS);
+	fbs = readl(port_mmio + PORT_FBS);
+	if (fbs & PORT_FBS_EN)
+		dev_printk(KERN_ERR, ap->host->dev, "Failed to disable FBS\n");
+	else {
+		dev_printk(KERN_INFO, ap->host->dev, "FBS is disabled.\n");
+		pp->fbs_enabled = false;
+	}
+
+	ahci_start_engine(ap);
+}
+
+static void ahci_pmp_attach(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ahci_port_priv *pp = ap->private_data;
+	u32 cmd;
+
+	cmd = readl(port_mmio + PORT_CMD);
+	cmd |= PORT_CMD_PMP;
+	writel(cmd, port_mmio + PORT_CMD);
+
+	ahci_enable_fbs(ap);
+
+	pp->intr_mask |= PORT_IRQ_BAD_PMP;
+	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
+}
+
+static void ahci_pmp_detach(struct ata_port *ap)
+{
+	void __iomem *port_mmio = ahci_port_base(ap);
+	struct ahci_port_priv *pp = ap->private_data;
+	u32 cmd;
+
+	ahci_disable_fbs(ap);
+
+	cmd = readl(port_mmio + PORT_CMD);
+	cmd &= ~PORT_CMD_PMP;
+	writel(cmd, port_mmio + PORT_CMD);
+
+	pp->intr_mask &= ~PORT_IRQ_BAD_PMP;
+	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
+}
+
+static int ahci_port_resume(struct ata_port *ap)
+{
+	ahci_power_up(ap);
+	ahci_start_port(ap);
+
+	if (sata_pmp_attached(ap))
+		ahci_pmp_attach(ap);
+	else
+		ahci_pmp_detach(ap);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
+{
+	const char *emsg = NULL;
+	int rc;
+
+	rc = ahci_deinit_port(ap, &emsg);
+	if (rc == 0)
+		ahci_power_down(ap);
+	else {
+		ata_port_printk(ap, KERN_ERR, "%s (%d)\n", emsg, rc);
+		ahci_start_port(ap);
+	}
+
+	return rc;
+}
+
+#ifdef CONFIG_ARCH_APOLLO
+static int ahci_apollo_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+	void __iomem *mmio = ahci_base(host);
+	u32 ctl = 0;
+
+	if (mesg.event & PM_EVENT_SLEEP) {
+		/* AHCI spec rev1.1 section 8.3.3:
+		 * Software must disable interrupts prior to requesting a
+		 * transition of the HBA to D3 state.
+		 */
+		ctl = readl(mmio + HOST_CTL);
+		ctl &= ~HOST_IRQ_EN;
+		writel(ctl, mmio + HOST_CTL);
+		readl(mmio + HOST_CTL); /* flush */
+	}
+
+	return ata_host_suspend(host, mesg);
+}
+
+static int ahci_apollo_resume(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+   int rc = 0;
+
+	if (pdev->dev.power.power_state.event & PM_EVENT_SLEEP) {
+		rc = ahci_reset_controller(host);
+		if (rc)
+			return rc;
+
+		ahci_init_controller(host);
+	}
+
+	ata_host_resume(host);
+	return 0;
+}
+
+#else /* PCI */
+
+static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+	u32 ctl;
+
+	if (mesg.event & PM_EVENT_SUSPEND &&
+	    hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "BIOS update required for suspend/resume\n");
+		return -EIO;
+	}
+
+	if (mesg.event & PM_EVENT_SLEEP) {
+		/* AHCI spec rev1.1 section 8.3.3:
+		 * Software must disable interrupts prior to requesting a
+		 * transition of the HBA to D3 state.
+		 */
+		ctl = readl(mmio + HOST_CTL);
+		ctl &= ~HOST_IRQ_EN;
+		writel(ctl, mmio + HOST_CTL);
+		readl(mmio + HOST_CTL); /* flush */
+	}
+
+	return ata_pci_device_suspend(pdev, mesg);
+}
+
+static int ahci_pci_device_resume(struct pci_dev *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	int rc;
+
+	rc = ata_pci_device_do_resume(pdev);
+	if (rc)
+		return rc;
+
+	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
+		rc = ahci_reset_controller(host);
+		if (rc)
+			return rc;
+
+		ahci_init_controller(host);
+	}
+
+	ata_host_resume(host);
+
+	return 0;
+}
+
+#endif /* Apollo || PCI */
+#endif /* PM */
+
+static int ahci_port_start(struct ata_port *ap)
+{
+	struct ahci_host_priv *hpriv = ap->host->private_data;
+	struct device *dev = ap->host->dev;
+	struct ahci_port_priv *pp;
+	void *mem;
+	dma_addr_t mem_dma;
+	size_t dma_sz, rx_fis_sz;
+
+	pp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);
+	if (!pp)
+		return -ENOMEM;
+
+	/* check FBS capability */
+	if ((hpriv->cap & HOST_CAP_FBS) && sata_pmp_supported(ap)) {
+		void __iomem *port_mmio = ahci_port_base(ap);
+		u32 cmd = readl(port_mmio + PORT_CMD);
+		if (cmd & PORT_CMD_FBSCP)
+			pp->fbs_supported = true;
+		else
+			dev_printk(KERN_WARNING, dev,
+				   "The port is not capable of FBS\n");
+	}
+
+	if (pp->fbs_supported) {
+		dma_sz = AHCI_PORT_PRIV_FBS_DMA_SZ;
+		rx_fis_sz = AHCI_RX_FIS_SZ * 16;
+	} else {
+		dma_sz = AHCI_PORT_PRIV_DMA_SZ;
+		rx_fis_sz = AHCI_RX_FIS_SZ;
+	}
+
+	mem = dmam_alloc_coherent(dev, dma_sz, &mem_dma, GFP_KERNEL);
+	if (!mem)
+		return -ENOMEM;
+	memset(mem, 0, dma_sz);
+
+	/*
+	 * First item in chunk of DMA memory: 32-slot command table,
+	 * 32 bytes each in size
+	 */
+	pp->cmd_slot = mem;
+	pp->cmd_slot_dma = mem_dma;
+
+	mem += AHCI_CMD_SLOT_SZ;
+	mem_dma += AHCI_CMD_SLOT_SZ;
+
+	/*
+	 * Second item: Received-FIS area
+	 */
+	pp->rx_fis = mem;
+	pp->rx_fis_dma = mem_dma;
+
+	mem += rx_fis_sz;
+	mem_dma += rx_fis_sz;
+
+	/*
+	 * Third item: data area for storing a single command
+	 * and its scatter-gather table
+	 */
+	pp->cmd_tbl = mem;
+	pp->cmd_tbl_dma = mem_dma;
+
+	/*
+	 * Save off initial list of interrupts to be enabled.
+	 * This could be changed later
+	 */
+	pp->intr_mask = DEF_PORT_IRQ;
+
+	ap->private_data = pp;
+
+	/* engage engines, captain */
+	return ahci_port_resume(ap);
+}
+
+static void ahci_port_stop(struct ata_port *ap)
+{
+	const char *emsg = NULL;
+	int rc;
+
+	/* de-initialize port */
+	rc = ahci_deinit_port(ap, &emsg);
+	if (rc)
+		ata_port_printk(ap, KERN_WARNING, "%s (%d)\n", emsg, rc);
+}
+
+static int ahci_configure_dma_masks(struct device *dev, int using_dac)
+{
+	int rc;
+
+#ifdef CONFIG_ARCH_APOLLO
+
+	rc = dma_set_mask(dev, DMA_BIT_MASK(32));
+	if (rc) {
+		dev_printk(KERN_ERR, dev,
+			   "32-bit DMA enable failed\n");
+		return rc;
+	}
+#else
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (using_dac &&
+	    !pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
+		rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+		if (rc) {
+			rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+			if (rc) {
+				dev_printk(KERN_ERR, &pdev->dev,
+					   "64-bit DMA enable failed\n");
+				return rc;
+			}
+		}
+	} else {
+		rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit consistent DMA enable failed\n");
+			return rc;
+		}
+	}
+#endif /* Apollo || PCI */
+
+	return 0;
+}
+
+static void ahci_print_info(struct ata_host *host)
+{
+	struct ahci_host_priv *hpriv = host->private_data;
+#ifndef CONFIG_ARCH_APOLLO
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+#endif
+	void __iomem *mmio = ahci_base(host);
+	u32 vers, cap, cap2, impl, speed;
+	const char *speed_s;
+#ifndef CONFIG_ARCH_APOLLO
+	u16 cc;
+#endif
+	const char *scc_s;
+
+	vers = readl(mmio + HOST_VERSION);
+	cap = hpriv->cap;
+	cap2 = hpriv->cap2;
+	impl = hpriv->port_map;
+
+	speed = (cap >> 20) & 0xf;
+	if (speed == 1)
+		speed_s = "1.5";
+	else if (speed == 2)
+		speed_s = "3";
+	else if (speed == 3)
+		speed_s = "6";
+	else
+		speed_s = "?";
+
+#ifdef CONFIG_ARCH_APOLLO
+	scc_s = "SATA";
+#else
+	pci_read_config_word(pdev, 0x0a, &cc);
+	if (cc == PCI_CLASS_STORAGE_IDE)
+		scc_s = "IDE";
+	else if (cc == PCI_CLASS_STORAGE_SATA)
+		scc_s = "SATA";
+	else if (cc == PCI_CLASS_STORAGE_RAID)
+		scc_s = "RAID";
+	else
+		scc_s = "unknown";
+#endif
+
+	dev_printk(KERN_INFO, host->dev,
+		"AHCI %02x%02x.%02x%02x "
+		"%u slots %u ports %s Gbps 0x%x impl %s mode\n"
+		,
+
+		(vers >> 24) & 0xff,
+		(vers >> 16) & 0xff,
+		(vers >> 8) & 0xff,
+		vers & 0xff,
+
+		((cap >> 8) & 0x1f) + 1,
+		(cap & 0x1f) + 1,
+		speed_s,
+		impl,
+		scc_s);
+
+	dev_printk(KERN_INFO, host->dev,
+		"flags: "
+		"%s%s%s%s%s%s%s"
+		"%s%s%s%s%s%s%s"
+		"%s%s%s%s%s%s\n"
+		,
+
+		cap & HOST_CAP_64 ? "64bit " : "",
+		cap & HOST_CAP_NCQ ? "ncq " : "",
+		cap & HOST_CAP_SNTF ? "sntf " : "",
+		cap & HOST_CAP_MPS ? "ilck " : "",
+		cap & HOST_CAP_SSS ? "stag " : "",
+		cap & HOST_CAP_ALPM ? "pm " : "",
+		cap & HOST_CAP_LED ? "led " : "",
+		cap & HOST_CAP_CLO ? "clo " : "",
+		cap & HOST_CAP_ONLY ? "only " : "",
+		cap & HOST_CAP_PMP ? "pmp " : "",
+		cap & HOST_CAP_FBS ? "fbs " : "",
+		cap & HOST_CAP_PIO_MULTI ? "pio " : "",
+		cap & HOST_CAP_SSC ? "slum " : "",
+		cap & HOST_CAP_PART ? "part " : "",
+		cap & HOST_CAP_CCC ? "ccc " : "",
+		cap & HOST_CAP_EMS ? "ems " : "",
+		cap & HOST_CAP_SXS ? "sxs " : "",
+		cap2 & HOST_CAP2_APST ? "apst " : "",
+		cap2 & HOST_CAP2_NVMHCI ? "nvmp " : "",
+		cap2 & HOST_CAP2_BOH ? "boh " : ""
+		);
+}
+
+#ifdef CONFIG_ARCH_APOLLO
+
+#ifdef CONFIG_SATA_APOLLO_BIST
+static int ahci_ata_scsi_ioctl(
+               struct scsi_device *scsidev, int cmd, void __user *arg)
+{
+   if (cmd == HDIO_DRIVE_TASK)
+   {
+      struct ata_port   *ap         = ata_shost_to_port(scsidev->host);
+      void __iomem      *port_mmio  = ahci_port_base(ap);
+      void __iomem      *mmio       = ahci_base(ap->host);
+      u32               mask;
+      u8                args[7];
+
+      if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+         return -EACCES;
+
+      if (arg == NULL)
+         return -EINVAL;
+
+      if (copy_from_user(args, arg, sizeof(args)))
+         return -EFAULT;
+
+      switch (args[0])
+      {
+         case SATA_BIST_EXIT:
+            printk("Exiting BIST.\n");
+
+            /* Stop the port */
+            ahci_stop_engine(ap);
+
+            /* Unselect port for BIST operation */
+            writel(0x0, mmio + HOST_TESTR);
+
+            /* Assert PHY Reset */
+            sata_scr_write(&ap->link, SCR_CONTROL, 0x1);
+
+            /* Enable PHYRDY change interrupt */
+            mask = readl(port_mmio + PORT_IRQ_MASK);
+            mask |= PORT_IRQ_PHYRDY;
+            writel(mask, port_mmio + PORT_IRQ_MASK);
+
+            /* Deassert PHY reset to generate COMRESET/COMINIT/PHYRDY interrupt 
+             * triggering standard libata SATA link initialization */
+            sata_scr_write(&ap->link, SCR_CONTROL, 0x0);
+            break;
+
+         case SATA_BIST_FEALB:
+            printk(KERN_ALERT "sata-apollo: Far End Analog Loopback not supported.\n");
+            return -EFAULT;
+
+         case SATA_BIST_NEALB:
+         case SATA_BIST_FERLB:
+         case SATA_BIST_FET:
+            /* Disable PHYRDY change interrupt */
+            mask = readl(port_mmio + PORT_IRQ_MASK);
+            mask &= ~PORT_IRQ_PHYRDY;
+            writel(mask, port_mmio + PORT_IRQ_MASK);
+            
+            /* Select link speed for BIST operation */
+            sata_scr_read(&ap->link, SCR_CONTROL, &mask);
+            mask |= (args[1] << 4);
+            sata_scr_write(&ap->link, SCR_CONTROL, 0x0);
+            
+            /* Select a port for BIST operation */
+            writel((ap->port_no)<<16, mmio + HOST_TESTR);
+
+            mask  =  args[6];    /* Pattern              */
+            mask |=  args[5]<<4; /* Pattern Version      */
+            mask |=  args[4]<<5; /* Flip Disparity       */
+            mask |=  args[3]<<6; /* Error Enable         */
+            mask |=  args[2]<<8; /* Link Layer Control   */
+            mask |=  1<<17;      /* Counter Clear        */
+
+            if (args[0] == SATA_BIST_NEALB)
+            {
+               mask |= 1<<16;    /* Near-End Analog Loopback   */
+               printk("Setting Near End Loopback BIST (mask=0x%x).\n", mask);
+            }
+            else if (args[0] == SATA_BIST_FERLB)
+            {
+               mask |= 1<<20;    /* Far-end Retimed Loopback   */
+               printk("Setting BIST-L (mask=0x%x).\n", mask);
+            }
+            else /* args[0] == SATA_BIST_FET */
+            {
+               mask |= 1<<18;    /* Transmit Only              */
+               printk("Setting BIST-T (mask=0x%x).\n", mask);
+            }
+            writel(mask, mmio + HOST_BISTCR);
+            break;
+
+         case SATA_BIST_PRINT_INFO:
+            printk(KERN_ALERT "BIST information -\n");
+            printk(KERN_ALERT "  BISTAFR  == 0x%X\n", readl(mmio + HOST_BISTAFR));
+            printk(KERN_ALERT "  BISTCR   == 0x%X\n", readl(mmio + HOST_BISTCR));
+            printk(KERN_ALERT "  BISTFCTR == 0x%X\n", readl(mmio + HOST_BISTFCTR));
+            printk(KERN_ALERT "  BISTSR   == 0x%X\n", readl(mmio + HOST_BISTSR));
+            printk(KERN_ALERT "  BISTDECR == 0x%X\n", readl(mmio + HOST_BISTDECR));
+            printk(KERN_ALERT "  TESTR    == 0x%X\n", readl(mmio + HOST_TESTR));
+            sata_scr_read(&ap->link, SCR_STATUS, &mask);
+            printk(KERN_ALERT "  P%uSSTS   == 0x%X\n", ap->port_no, mask);
+            sata_scr_read(&ap->link, SCR_CONTROL, &mask);
+            printk(KERN_ALERT "  P%uSCTL   == 0x%X\n", ap->port_no, mask);
+            sata_scr_read(&ap->link, SCR_ERROR, &mask);
+            printk(KERN_ALERT "  P%uSERR   == 0x%X\n", ap->port_no, mask);
+            break;
+
+         default:
+            return ata_scsi_ioctl (scsidev, cmd, arg);
+      }
+      return 0;
+   }
+   else
+   {
+      return ata_scsi_ioctl (scsidev, cmd, arg);
+   }
+}
+#endif
+
+static int ahci_apollo_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int              irq;
+
+	static int printed_version;
+ 	unsigned int board_id = board_ahci_apollo;
+	struct ata_port_info pi = ahci_port_info[board_id];
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct device *dev = &pdev->dev;
+	struct ahci_host_priv *hpriv;
+	struct ata_host *host;
+	int n_ports, i, rc;
+
+	VPRINTK("ENTER\n");
+
+	WARN_ON(ATA_MAX_QUEUE > AHCI_MAX_CMDS);
+
+	if (!printed_version++)
+		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
+
+	/* acquire resources */
+	irq  = platform_get_irq(pdev, 0);
+	if (irq < 0)
+	{
+		dev_err(&pdev->dev, "no IRQ specified\n");
+		return -ENXIO;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+	{
+		dev_err(&pdev->dev, "no MEM specified\n");
+		return -ENXIO;
+	}
+
+	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	/* Store register base in private data (replaces ata_host->iomap???) */
+	hpriv->mmio = devm_ioremap(&pdev->dev, res->start, (res->end - res->start) + 1);
+
+	/* save initial config */
+	ahci_save_initial_config(&pdev->dev, hpriv);
+
+	/* prepare host */
+	if (hpriv->cap & HOST_CAP_NCQ)
+		pi.flags |= ATA_FLAG_NCQ | ATA_FLAG_FPDMA_AA;
+
+	if (hpriv->cap & HOST_CAP_PMP)
+		pi.flags |= ATA_FLAG_PMP;
+
+	if (ahci_em_messages && (hpriv->cap & HOST_CAP_EMS)) {
+		u8 messages;
+		void __iomem *mmio = hpriv->mmio;
+		u32 em_loc = readl(mmio + HOST_EM_LOC);
+		u32 em_ctl = readl(mmio + HOST_EM_CTL);
+
+		messages = (em_ctl & EM_CTRL_MSG_TYPE) >> 16;
+
+		/* we only support LED message type right now */
+		if ((messages & 0x01) && (ahci_em_messages == 1)) {
+			/* store em_loc */
+			hpriv->em_loc = ((em_loc >> 16) * 4);
+			pi.flags |= ATA_FLAG_EM;
+			if (!(em_ctl & EM_CTL_ALHD))
+				pi.flags |= ATA_FLAG_SW_ACTIVITY;
+		}
+	}
+
+	/* CAP.NP sometimes indicate the index of the last enabled
+	 * port, at other times, that of the last possible port, so
+	 * determining the maximum port number requires looking at
+	 * both CAP.NP and port_map.
+	 */
+	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host)
+		return -ENOMEM;
+	host->private_data = hpriv;
+
+	if (pi.flags & ATA_FLAG_EM)
+		ahci_reset_em(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+      ata_port_desc(ap, "%s 0x%lx", "ahci", (unsigned long)hpriv->mmio);
+      ata_port_desc(ap, "%s 0x%lx", "port", (unsigned long)hpriv->mmio + 0x100 + ap->port_no * 0x80);
+
+		/* set initial link pm policy */
+		ap->pm_policy = NOT_AVAILABLE;
+
+		/* set enclosure management message type */
+		if (ap->flags & ATA_FLAG_EM)
+			ap->em_message_type = ahci_em_messages;
+
+		/* disabled/not-implemented port */
+		if (!(hpriv->port_map & (1 << i)))
+			ap->ops = &ata_dummy_port_ops;
+	}
+
+	/* initialize adapter */
+	rc = ahci_configure_dma_masks(dev, hpriv->cap & HOST_CAP_64);
+	if (rc)
+		return rc;
+
+	rc = ahci_reset_controller(host);
+	if (rc)
+		return rc;
+
+	ahci_init_controller(host);
+	ahci_print_info(host);
+
+	return ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
+				 &ahci_sht);
+}
+
+static int ahci_apollo_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_detach(host);
+
+	return 0;
+}
+
+static int __init ahci_init(void)
+{
+	return platform_driver_register(&ahci_apollo_driver);
+}
+
+static void __exit ahci_exit(void)
+{
+	platform_driver_unregister(&ahci_apollo_driver);
+}
+
+#else /* PCI */
+
+/* On ASUS P5W DH Deluxe, the second port of PCI device 00:1f.2 is
+ * hardwired to on-board SIMG 4726.  The chipset is ICH8 and doesn't
+ * support PMP and the 4726 either directly exports the device
+ * attached to the first downstream port or acts as a hardware storage
+ * controller and emulate a single ATA device (can be RAID 0/1 or some
+ * other configuration).
+ *
+ * When there's no device attached to the first downstream port of the
+ * 4726, "Config Disk" appears, which is a pseudo ATA device to
+ * configure the 4726.  However, ATA emulation of the device is very
+ * lame.  It doesn't send signature D2H Reg FIS after the initial
+ * hardreset, pukes on SRST w/ PMP==0 and has bunch of other issues.
+ *
+ * The following function works around the problem by always using
+ * hardreset on the port and not depending on receiving signature FIS
+ * afterward.  If signature FIS isn't received soon, ATA class is
+ * assumed without follow-up softreset.
+ */
+
+static void ahci_p5wdh_workaround(struct ata_host *host)
+{
+	static struct dmi_system_id sysids[] = {
+		{
+			.ident = "P5W DH Deluxe",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR,
+					  "ASUSTEK COMPUTER INC"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "P5W DH Deluxe"),
+			},
+		},
+		{ }
+	};
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+
+	if (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&
+	    dmi_check_system(sysids)) {
+		struct ata_port *ap = host->ports[1];
+
+		dev_printk(KERN_INFO, &pdev->dev, "enabling ASUS P5W DH "
+			   "Deluxe on-board SIMG4726 workaround\n");
+
+		ap->ops = &ahci_p5wdh_ops;
+		ap->link.flags |= ATA_LFLAG_NO_SRST | ATA_LFLAG_ASSUME_ATA;
+	}
+}
+
+/* only some SB600 ahci controllers can do 64bit DMA */
+static bool ahci_sb600_enable_64bit(struct pci_dev *pdev)
+{
+	static const struct dmi_system_id sysids[] = {
+		/*
+		 * The oldest version known to be broken is 0901 and
+		 * working is 1501 which was released on 2007-10-26.
+		 * Enable 64bit DMA on 1501 and anything newer.
+		 *
+		 * Please read bko#9412 for more info.
+		 */
+		{
+			.ident = "ASUS M2A-VM",
+			.matches = {
+				DMI_MATCH(DMI_BOARD_VENDOR,
+					  "ASUSTeK Computer INC."),
+				DMI_MATCH(DMI_BOARD_NAME, "M2A-VM"),
+			},
+			.driver_data = "20071026",	/* yyyymmdd */
+		},
+		/*
+		 * All BIOS versions for the MSI K9A2 Platinum (MS-7376)
+		 * support 64bit DMA.
+		 *
+		 * BIOS versions earlier than 1.5 had the Manufacturer DMI
+		 * fields as "MICRO-STAR INTERANTIONAL CO.,LTD".
+		 * This spelling mistake was fixed in BIOS version 1.5, so
+		 * 1.5 and later have the Manufacturer as
+		 * "MICRO-STAR INTERNATIONAL CO.,LTD".
+		 * So try to match on DMI_BOARD_VENDOR of "MICRO-STAR INTER".
+		 *
+		 * BIOS versions earlier than 1.9 had a Board Product Name
+		 * DMI field of "MS-7376". This was changed to be
+		 * "K9A2 Platinum (MS-7376)" in version 1.9, but we can still
+		 * match on DMI_BOARD_NAME of "MS-7376".
+		 */
+		{
+			.ident = "MSI K9A2 Platinum",
+			.matches = {
+				DMI_MATCH(DMI_BOARD_VENDOR,
+					  "MICRO-STAR INTER"),
+				DMI_MATCH(DMI_BOARD_NAME, "MS-7376"),
+			},
+		},
+		{ }
+	};
+	const struct dmi_system_id *match;
+	int year, month, date;
+	char buf[9];
+
+	match = dmi_first_match(sysids);
+	if (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||
+	    !match)
+		return false;
+
+	if (!match->driver_data)
+		goto enable_64bit;
+
+	dmi_get_date(DMI_BIOS_DATE, &year, &month, &date);
+	snprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);
+
+	if (strcmp(buf, match->driver_data) >= 0)
+		goto enable_64bit;
+	else {
+		dev_printk(KERN_WARNING, &pdev->dev, "%s: BIOS too old, "
+			   "forcing 32bit DMA, update BIOS\n", match->ident);
+		return false;
+	}
+
+enable_64bit:
+	dev_printk(KERN_WARNING, &pdev->dev, "%s: enabling 64bit DMA\n",
+		   match->ident);
+	return true;
+}
+
+static bool ahci_broken_system_poweroff(struct pci_dev *pdev)
+{
+	static const struct dmi_system_id broken_systems[] = {
+		{
+			.ident = "HP Compaq nx6310",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nx6310"),
+			},
+			/* PCI slot number of the controller */
+			.driver_data = (void *)0x1FUL,
+		},
+		{
+			.ident = "HP Compaq 6720s",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq 6720s"),
+			},
+			/* PCI slot number of the controller */
+			.driver_data = (void *)0x1FUL,
+		},
+
+		{ }	/* terminate list */
+	};
+	const struct dmi_system_id *dmi = dmi_first_match(broken_systems);
+
+	if (dmi) {
+		unsigned long slot = (unsigned long)dmi->driver_data;
+		/* apply the quirk only to on-board controllers */
+		return slot == PCI_SLOT(pdev->devfn);
+	}
+
+	return false;
+}
+
+static bool ahci_broken_suspend(struct pci_dev *pdev)
+{
+	static const struct dmi_system_id sysids[] = {
+		/*
+		 * On HP dv[4-6] and HDX18 with earlier BIOSen, link
+		 * to the harddisk doesn't become online after
+		 * resuming from STR.  Warn and fail suspend.
+		 */
+		{
+			.ident = "dv4",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME,
+					  "HP Pavilion dv4 Notebook PC"),
+			},
+			.driver_data = "20090105",	/* F.30 */
+		},
+		{
+			.ident = "dv5",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME,
+					  "HP Pavilion dv5 Notebook PC"),
+			},
+			.driver_data = "20090506",	/* F.16 */
+		},
+		{
+			.ident = "dv6",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME,
+					  "HP Pavilion dv6 Notebook PC"),
+			},
+			.driver_data = "20090423",	/* F.21 */
+		},
+		{
+			.ident = "HDX18",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME,
+					  "HP HDX18 Notebook PC"),
+			},
+			.driver_data = "20090430",	/* F.23 */
+		},
+		/*
+		 * Acer eMachines G725 has the same problem.  BIOS
+		 * V1.03 is known to be broken.  V3.04 is known to
+		 * work.  Inbetween, there are V1.06, V2.06 and V3.03
+		 * that we don't have much idea about.  For now,
+		 * blacklist anything older than V3.04.
+		 */
+		{
+			.ident = "G725",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "eMachines"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "eMachines G725"),
+			},
+			.driver_data = "20091216",	/* V3.04 */
+		},
+		{ }	/* terminate list */
+	};
+	const struct dmi_system_id *dmi = dmi_first_match(sysids);
+	int year, month, date;
+	char buf[9];
+
+	if (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))
+		return false;
+
+	dmi_get_date(DMI_BIOS_DATE, &year, &month, &date);
+	snprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);
+
+	return strcmp(buf, dmi->driver_data) < 0;
+}
+
+static bool ahci_broken_online(struct pci_dev *pdev)
+{
+#define ENCODE_BUSDEVFN(bus, slot, func)			\
+	(void *)(unsigned long)(((bus) << 8) | PCI_DEVFN((slot), (func)))
+	static const struct dmi_system_id sysids[] = {
+		/*
+		 * There are several gigabyte boards which use
+		 * SIMG5723s configured as hardware RAID.  Certain
+		 * 5723 firmware revisions shipped there keep the link
+		 * online but fail to answer properly to SRST or
+		 * IDENTIFY when no device is attached downstream
+		 * causing libata to retry quite a few times leading
+		 * to excessive detection delay.
+		 *
+		 * As these firmwares respond to the second reset try
+		 * with invalid device signature, considering unknown
+		 * sig as offline works around the problem acceptably.
+		 */
+		{
+			.ident = "EP45-DQ6",
+			.matches = {
+				DMI_MATCH(DMI_BOARD_VENDOR,
+					  "Gigabyte Technology Co., Ltd."),
+				DMI_MATCH(DMI_BOARD_NAME, "EP45-DQ6"),
+			},
+			.driver_data = ENCODE_BUSDEVFN(0x0a, 0x00, 0),
+		},
+		{
+			.ident = "EP45-DS5",
+			.matches = {
+				DMI_MATCH(DMI_BOARD_VENDOR,
+					  "Gigabyte Technology Co., Ltd."),
+				DMI_MATCH(DMI_BOARD_NAME, "EP45-DS5"),
+			},
+			.driver_data = ENCODE_BUSDEVFN(0x03, 0x00, 0),
+		},
+		{ }	/* terminate list */
+	};
+#undef ENCODE_BUSDEVFN
+	const struct dmi_system_id *dmi = dmi_first_match(sysids);
+	unsigned int val;
+
+	if (!dmi)
+		return false;
+
+	val = (unsigned long)dmi->driver_data;
+
+	return pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);
+}
+
+#ifdef CONFIG_ATA_ACPI
+static void ahci_gtf_filter_workaround(struct ata_host *host)
+{
+	static const struct dmi_system_id sysids[] = {
+		/*
+		 * Aspire 3810T issues a bunch of SATA enable commands
+		 * via _GTF including an invalid one and one which is
+		 * rejected by the device.  Among the successful ones
+		 * is FPDMA non-zero offset enable which when enabled
+		 * only on the drive side leads to NCQ command
+		 * failures.  Filter it out.
+		 */
+		{
+			.ident = "Aspire 3810T",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 3810T"),
+			},
+			.driver_data = (void *)ATA_ACPI_FILTER_FPDMA_OFFSET,
+		},
+		{ }
+	};
+	const struct dmi_system_id *dmi = dmi_first_match(sysids);
+	unsigned int filter;
+	int i;
+
+	if (!dmi)
+		return;
+
+	filter = (unsigned long)dmi->driver_data;
+	dev_printk(KERN_INFO, host->dev,
+		   "applying extra ACPI _GTF filter 0x%x for %s\n",
+		   filter, dmi->ident);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+		struct ata_link *link;
+		struct ata_device *dev;
+
+		ata_for_each_link(link, ap, EDGE)
+			ata_for_each_dev(dev, link, ALL)
+				dev->gtf_filter |= filter;
+	}
+}
+#else
+static inline void ahci_gtf_filter_workaround(struct ata_host *host)
+{}
+#endif
+
+static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	unsigned int board_id = ent->driver_data;
+	struct ata_port_info pi = ahci_port_info[board_id];
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct device *dev = &pdev->dev;
+	struct ahci_host_priv *hpriv;
+	struct ata_host *host;
+	int n_ports, i, rc;
+
+	VPRINTK("ENTER\n");
+
+	WARN_ON(ATA_MAX_QUEUE > AHCI_MAX_CMDS);
+
+	if (!printed_version++)
+		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
+
+	/* The AHCI driver can only drive the SATA ports, the PATA driver
+	   can drive them all so if both drivers are selected make sure
+	   AHCI stays out of the way */
+	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
+		return -ENODEV;
+
+	/* Promise's PDC42819 is a SAS/SATA controller that has an AHCI mode.
+	 * At the moment, we can only use the AHCI mode. Let the users know
+	 * that for SAS drives they're out of luck.
+	 */
+	if (pdev->vendor == PCI_VENDOR_ID_PROMISE)
+		dev_printk(KERN_INFO, &pdev->dev, "PDC42819 "
+			   "can only drive SATA devices with this driver\n");
+
+	/* acquire resources */
+	rc = pcim_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	/* AHCI controllers often implement SFF compatible interface.
+	 * Grab all PCI BARs just in case.
+	 */
+	rc = pcim_iomap_regions_request_all(pdev, 1 << AHCI_PCI_BAR, DRV_NAME);
+	if (rc == -EBUSY)
+		pcim_pin_device(pdev);
+	if (rc)
+		return rc;
+
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == 0x2652 || pdev->device == 0x2653)) {
+		u8 map;
+
+		/* ICH6s share the same PCI ID for both piix and ahci
+		 * modes.  Enabling ahci mode while MAP indicates
+		 * combined mode is a bad idea.  Yield to ata_piix.
+		 */
+		pci_read_config_byte(pdev, ICH_MAP, &map);
+		if (map & 0x3) {
+			dev_printk(KERN_INFO, &pdev->dev, "controller is in "
+				   "combined mode, can't enable AHCI mode\n");
+			return -ENODEV;
+		}
+	}
+
+	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	/* MCP65 revision A1 and A2 can't do MSI */
+	if (board_id == board_ahci_mcp65 &&
+	    (pdev->revision == 0xa1 || pdev->revision == 0xa2))
+		hpriv->flags |= AHCI_HFLAG_NO_MSI;
+
+	/* SB800 does NOT need the workaround to ignore SERR_INTERNAL */
+	if (board_id == board_ahci_sb700 && pdev->revision >= 0x40)
+		hpriv->flags &= ~AHCI_HFLAG_IGN_SERR_INTERNAL;
+
+	/* only some SB600s can do 64bit DMA */
+	if (ahci_sb600_enable_64bit(pdev))
+		hpriv->flags &= ~AHCI_HFLAG_32BIT_ONLY;
+
+	if ((hpriv->flags & AHCI_HFLAG_NO_MSI) || pci_enable_msi(pdev))
+		pci_intx(pdev, 1);
+
+	/* save initial config */
+	ahci_save_initial_config(pdev, hpriv);
+
+	/* prepare host */
+	if (hpriv->cap & HOST_CAP_NCQ) {
+		pi.flags |= ATA_FLAG_NCQ;
+		/* Auto-activate optimization is supposed to be supported on
+		   all AHCI controllers indicating NCQ support, but it seems
+		   to be broken at least on some NVIDIA MCP79 chipsets.
+		   Until we get info on which NVIDIA chipsets don't have this
+		   issue, if any, disable AA on all NVIDIA AHCIs. */
+		if (pdev->vendor != PCI_VENDOR_ID_NVIDIA)
+			pi.flags |= ATA_FLAG_FPDMA_AA;
+	}
+
+	if (hpriv->cap & HOST_CAP_PMP)
+		pi.flags |= ATA_FLAG_PMP;
+
+	if (ahci_em_messages && (hpriv->cap & HOST_CAP_EMS)) {
+		u8 messages;
+		void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+		u32 em_loc = readl(mmio + HOST_EM_LOC);
+		u32 em_ctl = readl(mmio + HOST_EM_CTL);
+
+		messages = (em_ctl & EM_CTRL_MSG_TYPE) >> 16;
+
+		/* we only support LED message type right now */
+		if ((messages & 0x01) && (ahci_em_messages == 1)) {
+			/* store em_loc */
+			hpriv->em_loc = ((em_loc >> 16) * 4);
+			pi.flags |= ATA_FLAG_EM;
+			if (!(em_ctl & EM_CTL_ALHD))
+				pi.flags |= ATA_FLAG_SW_ACTIVITY;
+		}
+	}
+
+	if (ahci_broken_system_poweroff(pdev)) {
+		pi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;
+		dev_info(&pdev->dev,
+			"quirky BIOS, skipping spindown on poweroff\n");
+	}
+
+	if (ahci_broken_suspend(pdev)) {
+		hpriv->flags |= AHCI_HFLAG_NO_SUSPEND;
+		dev_printk(KERN_WARNING, &pdev->dev,
+			   "BIOS update required for suspend/resume\n");
+	}
+
+	if (ahci_broken_online(pdev)) {
+		hpriv->flags |= AHCI_HFLAG_SRST_TOUT_IS_OFFLINE;
+		dev_info(&pdev->dev,
+			 "online status unreliable, applying workaround\n");
+	}
+
+	/* CAP.NP sometimes indicate the index of the last enabled
+	 * port, at other times, that of the last possible port, so
+	 * determining the maximum port number requires looking at
+	 * both CAP.NP and port_map.
+	 */
+	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host)
+		return -ENOMEM;
+	host->iomap = pcim_iomap_table(pdev);
+	host->private_data = hpriv;
+
+	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
+		host->flags |= ATA_HOST_PARALLEL_SCAN;
+	else
+		printk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");
+
+	if (pi.flags & ATA_FLAG_EM)
+		ahci_reset_em(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		ata_port_pbar_desc(ap, AHCI_PCI_BAR, -1, "abar");
+		ata_port_pbar_desc(ap, AHCI_PCI_BAR,
+				   0x100 + ap->port_no * 0x80, "port");
+
+		/* set initial link pm policy */
+		ap->pm_policy = NOT_AVAILABLE;
+
+		/* set enclosure management message type */
+		if (ap->flags & ATA_FLAG_EM)
+			ap->em_message_type = ahci_em_messages;
+
+
+		/* disabled/not-implemented port */
+		if (!(hpriv->port_map & (1 << i)))
+			ap->ops = &ata_dummy_port_ops;
+	}
+
+	/* apply workaround for ASUS P5W DH Deluxe mainboard */
+	ahci_p5wdh_workaround(host);
+
+	/* apply gtf filter quirk */
+	ahci_gtf_filter_workaround(host);
+
+	/* initialize adapter */
+	rc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);
+	if (rc)
+		return rc;
+
+	rc = ahci_reset_controller(host);
+	if (rc)
+		return rc;
+
+	ahci_init_controller(host);
+	ahci_print_info(host);
+
+	pci_set_master(pdev);
+	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
+				 &ahci_sht);
+}
+
+static int __init ahci_init(void)
+{
+	return pci_register_driver(&ahci_pci_driver);
+}
+
+static void __exit ahci_exit(void)
+{
+	pci_unregister_driver(&ahci_pci_driver);
+}
+
+#endif /* Apollo || PCI */
+
+MODULE_AUTHOR("Jeff Garzik/Nitin Garg");
+MODULE_DESCRIPTION("Trident Apollo AHCI SATA low-level driver");
+MODULE_LICENSE("GPL");
+#ifndef CONFIG_ARCH_APOLLO
+MODULE_DEVICE_TABLE(pci, ahci_pci_tbl);
+#endif
+MODULE_VERSION(DRV_VERSION);
+
+module_init(ahci_init);
+module_exit(ahci_exit);
diff -Naurp linux-2.6.34.orig/drivers/char/tty_io.c linux-2.6.34/drivers/char/tty_io.c
--- linux-2.6.34.orig/drivers/char/tty_io.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/char/tty_io.c	2010-09-07 22:16:40.000000000 -0500
@@ -143,6 +143,8 @@ ssize_t redirected_tty_write(struct file
 static unsigned int tty_poll(struct file *, poll_table *);
 static int tty_open(struct inode *, struct file *);
 long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+long tty_ioctl_simple(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
+int tty_job_control(struct tty_struct *tty);
 #ifdef CONFIG_COMPAT
 static long tty_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg);
@@ -1368,6 +1370,7 @@ release_mem_out:
 	unlock_kernel();
 	return ERR_PTR(retval);
 }
+EXPORT_SYMBOL(tty_init_dev);
 
 void tty_free_termios(struct tty_struct *tty)
 {
@@ -1722,6 +1725,213 @@ int tty_release(struct inode *inode, str
 	return 0;
 }
 
+/*
+ * Even releasing the tty structures is a tricky business.. We have
+ * to be very careful that the structures are all released at the
+ * same time, as interrupts might otherwise get the wrong pointers.
+ *
+ * WSH 09/09/97: rewritten to avoid some nasty race conditions that could
+ * lead to double frees or releasing memory still in use.
+ */
+void tty_release_tty(struct tty_struct *tty)
+{
+	struct tty_struct *o_tty;
+	int	pty_master, tty_closing, o_tty_closing, do_sleep;
+	int	devpts;
+	int	idx;
+	char	buf[64];
+
+
+#ifdef TTY_PARANOIA_CHECK
+	if (!tty) {
+		return;
+	}
+	if (tty->magic != TTY_MAGIC) {
+		return;
+	}
+#endif
+	
+#if 0
+	check_tty_count(tty, "tty_release_dev");
+#endif
+
+	idx = tty->index;
+	pty_master = (tty->driver->type == TTY_DRIVER_TYPE_PTY &&
+		      tty->driver->subtype == PTY_TYPE_MASTER);
+	devpts = (tty->driver->flags & TTY_DRIVER_DEVPTS_MEM) != 0;
+	o_tty = tty->link;
+
+#ifdef TTY_PARANOIA_CHECK
+	if (idx < 0 || idx >= tty->driver->num) {
+		printk(KERN_DEBUG "tty_release_dev: bad idx when trying to "
+				  "free (%s)\n", tty->name);
+		return;
+	}
+	if (!devpts) {
+		if (tty != tty->driver->ttys[idx]) {
+			printk(KERN_DEBUG "tty_release_dev: driver.table[%d] not tty "
+			       "for (%s)\n", idx, tty->name);
+			return;
+		}
+		if (tty->termios != tty->driver->termios[idx]) {
+			printk(KERN_DEBUG "tty_release_dev: driver.termios[%d] not termios "
+			       "for (%s)\n",
+			       idx, tty->name);
+			return;
+		}
+	}
+#endif
+
+#ifdef TTY_DEBUG_HANGUP
+	printk(KERN_DEBUG "tty_release_dev of %s (tty count=%d)...",
+	       tty_name(tty, buf), tty->count);
+#endif
+
+#ifdef TTY_PARANOIA_CHECK
+	if (tty->driver->other &&
+	     !(tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)) {
+		if (o_tty != tty->driver->other->ttys[idx]) {
+			printk(KERN_DEBUG "tty_release_dev: other->table[%d] "
+					  "not o_tty for (%s)\n",
+			       idx, tty->name);
+			return;
+		}
+		if (o_tty->termios != tty->driver->other->termios[idx]) {
+			printk(KERN_DEBUG "tty_release_dev: other->termios[%d] "
+					  "not o_termios for (%s)\n",
+			       idx, tty->name);
+			return;
+		}
+		if (o_tty->link != tty) {
+			printk(KERN_DEBUG "tty_release_dev: bad pty pointers\n");
+			return;
+		}
+	}
+#endif
+	if (tty->ops->close)
+		tty->ops->close(tty, NULL);
+
+	/*
+	 * Sanity check: if tty->count is going to zero, there shouldn't be
+	 * any waiters on tty->read_wait or tty->write_wait.  We test the
+	 * wait queues and kick everyone out _before_ actually starting to
+	 * close.  This ensures that we won't block while releasing the tty
+	 * structure.
+	 *
+	 * The test for the o_tty closing is necessary, since the master and
+	 * slave sides may close in any order.  If the slave side closes out
+	 * first, its count will be one, since the master side holds an open.
+	 * Thus this test wouldn't be triggered at the time the slave closes,
+	 * so we do it now.
+	 *
+	 * Note that it's possible for the tty to be opened again while we're
+	 * flushing out waiters.  By recalculating the closing flags before
+	 * each iteration we avoid any problems.
+	 */
+	while (1) {
+		/* Guard against races with tty->count changes elsewhere and
+		   opens on /dev/tty */
+
+		mutex_lock(&tty_mutex);
+		tty_closing = tty->count <= 1;
+		o_tty_closing = o_tty &&
+			(o_tty->count <= (pty_master ? 1 : 0));
+		do_sleep = 0;
+
+		if (tty_closing) {
+			if (waitqueue_active(&tty->read_wait)) {
+				wake_up(&tty->read_wait);
+				do_sleep++;
+			}
+			if (waitqueue_active(&tty->write_wait)) {
+				wake_up(&tty->write_wait);
+				do_sleep++;
+			}
+		}
+		if (o_tty_closing) {
+			if (waitqueue_active(&o_tty->read_wait)) {
+				wake_up(&o_tty->read_wait);
+				do_sleep++;
+			}
+			if (waitqueue_active(&o_tty->write_wait)) {
+				wake_up(&o_tty->write_wait);
+				do_sleep++;
+			}
+		}
+		if (!do_sleep)
+			break;
+
+		printk(KERN_WARNING "tty_release_dev: %s: read/write wait queue "
+				    "active!\n", tty_name(tty, buf));
+		mutex_unlock(&tty_mutex);
+		schedule();
+	}
+
+	/*
+	 * The closing flags are now consistent with the open counts on
+	 * both sides, and we've completed the last operation that could
+	 * block, so it's safe to proceed with closing.
+	 */
+	if (pty_master) {
+		if (--o_tty->count < 0) {
+			printk(KERN_WARNING "tty_release_dev: bad pty slave count "
+					    "(%d) for %s\n",
+			       o_tty->count, tty_name(o_tty, buf));
+			o_tty->count = 0;
+		}
+	}
+	if (--tty->count < 0) {
+		printk(KERN_WARNING "tty_release_dev: bad tty->count (%d) for %s\n",
+		       tty->count, tty_name(tty, buf));
+		tty->count = 0;
+	}
+
+	/*
+	 * Perform some housekeeping before deciding whether to return.
+	 *
+	 * Set the TTY_CLOSING flag if this was the last open.  In the
+	 * case of a pty we may have to wait around for the other side
+	 * to close, and TTY_CLOSING makes sure we can't be reopened.
+	 */
+	if (tty_closing)
+		set_bit(TTY_CLOSING, &tty->flags);
+	if (o_tty_closing)
+		set_bit(TTY_CLOSING, &o_tty->flags);
+
+	/*
+	 * If _either_ side is closing, make sure there aren't any
+	 * processes that still think tty or o_tty is their controlling
+	 * tty.
+	 */
+	if (tty_closing || o_tty_closing) {
+		read_lock(&tasklist_lock);
+		session_clear_tty(tty->session);
+		if (o_tty)
+			session_clear_tty(o_tty->session);
+		read_unlock(&tasklist_lock);
+	}
+
+	mutex_unlock(&tty_mutex);
+
+	/* check whether both sides are closing ... */
+	if (!tty_closing || (o_tty && !o_tty_closing))
+		return;
+
+#ifdef TTY_DEBUG_HANGUP
+	printk(KERN_DEBUG "freeing tty structure...");
+#endif
+	/*
+	 * Ask the line discipline code to release its structures
+	 */
+	tty_ldisc_release(tty, o_tty);
+	/*
+	 * The release_tty function takes care of the details of clearing
+	 * the slots and preserving the termios structure.
+	 */
+	release_tty(tty, idx);
+}
+EXPORT_SYMBOL(tty_release_tty);
+
 /**
  *	tty_open		-	open a tty device
  *	@inode: inode of device file
@@ -2435,9 +2645,14 @@ static int tty_tiocmset(struct tty_struc
 	if (tty->ops->tiocmset == NULL)
 		return -EINVAL;
 
+	if (file != NULL) {
 	retval = get_user(val, p);
 	if (retval)
 		return retval;
+	}
+	else
+		val = (unsigned int)p;
+	
 	set = clear = 0;
 	switch (cmd) {
 	case TIOCMBIS:
@@ -2602,6 +2817,157 @@ long tty_ioctl(struct file *file, unsign
 	return retval;
 }
 
+long tty_ioctl_simple(struct tty_struct *tty, unsigned int cmd, unsigned long arg)
+{
+	struct tty_struct *real_tty;
+	void *p = (void *)arg;
+	int retval;
+	struct tty_ldisc *ld;
+
+#if 0
+	struct inode *inode = file->f_dentry->d_inode;
+	tty = (struct tty_struct *)file->private_data;
+	if (tty_paranoia_check(tty, inode, "tty_ioctl"))
+		return -EINVAL;
+#endif
+
+	real_tty = tty;
+	if (tty->driver->type == TTY_DRIVER_TYPE_PTY &&
+	    tty->driver->subtype == PTY_TYPE_MASTER)
+		real_tty = tty->link;
+
+
+	/*
+	 * Factor out some common prep work
+	 */
+	switch (cmd) {
+	case TIOCSETD:
+	case TIOCSBRK:
+	case TIOCCBRK:
+	case TCSBRK:
+	case TCSBRKP:
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		if (cmd != TIOCCBRK) {
+			tty_wait_until_sent(tty, 0);
+			if (signal_pending(current))
+				return -EINTR;
+		}
+		break;
+	}
+
+	/*
+	 *	Now do the stuff.
+	 */
+	switch (cmd) {
+	case TIOCSTI:
+		return tiocsti(tty, p);
+	case TIOCGWINSZ:
+		return tiocgwinsz(real_tty, p);
+	case TIOCSWINSZ:
+		return tiocswinsz(real_tty, p);
+	case TIOCEXCL:
+		set_bit(TTY_EXCLUSIVE, &tty->flags);
+		return 0;
+	case TIOCNXCL:
+		clear_bit(TTY_EXCLUSIVE, &tty->flags);
+		return 0;
+	case TIOCNOTTY:
+		if (current->signal->tty != tty)
+			return -ENOTTY;
+		no_tty();
+		return 0;
+	case TIOCSCTTY:
+		return tiocsctty(tty, arg);
+	case TIOCGPGRP:
+		return tiocgpgrp(tty, real_tty, p);
+	case TIOCSPGRP:
+		return tiocspgrp(tty, real_tty, p);
+	case TIOCGSID:
+		return tiocgsid(tty, real_tty, p);
+	case TIOCSETD:
+		return tiocsetd(tty, p);
+	/*
+	 * Break handling
+	 */
+	case TIOCSBRK:	/* Turn break on, unconditionally */
+		if (tty->ops->break_ctl)
+			return tty->ops->break_ctl(tty, -1);
+		return 0;
+	case TIOCCBRK:	/* Turn break off, unconditionally */
+		if (tty->ops->break_ctl)
+			return tty->ops->break_ctl(tty, 0);
+		return 0;
+	case TCSBRK:   /* SVID version: non-zero arg --> no break */
+		/* non-zero arg means wait for all output data
+		 * to be sent (performed above) but don't send break.
+		 * This is used by the tcdrain() termios function.
+		 */
+		if (!arg)
+			return send_break(tty, 250);
+		return 0;
+	case TCSBRKP:	/* support for POSIX tcsendbreak() */
+		return send_break(tty, arg ? arg*100 : 250);
+
+	case TIOCMGET:
+		return tty_tiocmget(tty, NULL, p);
+	case TIOCMSET:
+	case TIOCMBIC:
+	case TIOCMBIS:
+		return tty_tiocmset(tty, NULL, cmd, p);
+	case TCFLSH:
+		switch (arg) {
+		case TCIFLUSH:
+		case TCIOFLUSH:
+		/* flush tty buffer and allow ldisc to process ioctl */
+			tty_buffer_flush(tty);
+			break;
+		}
+		break;
+	}
+	if (tty->ops->ioctl) {
+		retval = (tty->ops->ioctl)(tty, NULL, cmd, arg);
+		if (retval != -ENOIOCTLCMD)
+			return retval;
+	}
+#if 1	
+	ld = tty_ldisc_ref_wait(tty);
+	retval = -EINVAL;
+	if (ld->ops->ioctl) {
+		retval = ld->ops->ioctl(tty, NULL, cmd, arg);
+		if (retval == -ENOIOCTLCMD)
+			retval = -EINVAL;
+	}
+	tty_ldisc_deref(ld);
+#endif	
+	return retval;
+}
+EXPORT_SYMBOL(tty_ioctl_simple);
+
+int tty_job_control(struct tty_struct *tty)
+{
+	/* Job control check -- must be done at start and after
+	   every sleep (POSIX.1 7.1.1.4). */
+	/* NOTE: not yet done after every sleep pending a thorough
+	   check of the logic of this change. -- jlc */
+	/* don't stop on /dev/console */
+	if (current->signal->tty == tty) {
+		if (!tty->pgrp)
+			printk(KERN_ERR "n_tty_read: no tty->pgrp!\n");
+		else if (task_pgrp(current) != tty->pgrp) {
+			if (is_ignored(SIGTTIN) ||
+			    is_current_pgrp_orphaned())
+				return -EIO;
+			kill_pgrp(task_pgrp(current), SIGTTIN, 1);
+			set_thread_flag(TIF_SIGPENDING);
+			return -ERESTARTSYS;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tty_job_control);
+
 #ifdef CONFIG_COMPAT
 static long tty_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
@@ -3027,6 +3393,7 @@ void proc_clear_tty(struct task_struct *
 	spin_unlock_irqrestore(&p->sighand->siglock, flags);
 	tty_kref_put(tty);
 }
+EXPORT_SYMBOL(proc_clear_tty);
 
 /* Called under the sighand lock */
 
diff -Naurp linux-2.6.34.orig/drivers/char/tty_ldisc.c linux-2.6.34/drivers/char/tty_ldisc.c
--- linux-2.6.34.orig/drivers/char/tty_ldisc.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/char/tty_ldisc.c	2010-09-07 22:16:40.000000000 -0500
@@ -874,6 +874,7 @@ void tty_ldisc_release(struct tty_struct
 	/* And the memory resources remaining (buffers, termios) will be
 	   disposed of when the kref hits zero */
 }
+EXPORT_SYMBOL(tty_ldisc_release);
 
 /**
  *	tty_ldisc_init		-	ldisc setup for new tty
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/Kconfig linux-2.6.34/drivers/dcs_net/Kconfig
--- linux-2.6.34.orig/drivers/dcs_net/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,107 @@
+#
+# DCS Network driver configuration
+#
+
+menu "DCS Network driver support"
+
+config DCS_NETWORK_SUPPORT
+  tristate "Enable support for DCS Network controller"
+  depends on ARCH_APOLLO
+  help
+    The DCS Network controller should be enabled if the driver/kernel
+    wants to configure the timeout value and access rights for all the targets.
+
+config DCS_DEBUG
+  bool "Enable debugging messages to be generated by the driver"
+  depends on DCS_NETWORK_SUPPORT
+  default y
+  help
+    Set this option to enable debug prints of DCS network core APIs. It is
+    highly recommended to say 'Y' here during development/testing phase.
+
+config DCS_USE_WORKQUEUE
+  bool "Enable dcs event log printing on UART"
+  depends on DCS_DEBUG
+  default y
+  help
+    If this option is enabled, DCS Network driver will print the events to UART
+    after a small delay using a  work queue. If not selected it will print the messages
+    to dmesg buffer immidiately (From the ISR).
+
+    It is recommended to say 'Y' here.
+
+config DCS_LOG_WRAPAROUND
+  bool "Enable Buffer wrap around"
+  depends on DCS_NETWORK_SUPPORT
+  default n
+  help
+    DCS Network driver maintains a small buffer to keep the log of the events.
+    If this option is selected the new messages will overwrite the old messages
+    when the buffer is full. Say 'N' here if the old messages are critial than
+    the new ones.
+
+config MDCS_TOUT_IN_DRIVER
+  bool "Enable MDCS timeout setting from driver"
+  depends on DCS_NETWORK_SUPPORT
+  help
+    Lets the driver to set the default timeout value for MIPS DCS network.
+
+config MDCSN_DEFAULT_TOUT
+  hex "MIPS DCS timeout (Check help for possible value)"
+  depends on MDCS_TOUT_IN_DRIVER
+  default "0x0F"
+  help
+    Sets the default timeout value for MIPS DCS network controller. The following
+    are the possible valid values
+    
+        Value                   Cycles to wait
+        =====                   ==============
+        0x00                         7
+        0x03                         15
+        0x04                         31
+        0x05                         63
+        0x06                         127
+        0x07                         255
+        0x08                         511
+        0x09                         1023
+        0x0A                         2047
+        0x0B                         4095
+        0x0C                         8191
+        0x0D                         16383
+        0x0E                         32767
+        0x0F                         65535
+        0x10                       No timeout till rd/wr event completes
+
+config TDCS_TOUT_IN_DRIVER
+  bool "Enable TDCS timeout setting from driver"
+  depends on DCS_NETWORK_SUPPORT
+  help
+    Lets the driver to set the default timeout value for Tri-Media DCS network.
+
+config TDCSN_DEFAULT_TOUT
+  hex "Tri-Media DCS timeout (Check help for possible value)"
+  depends on TDCS_TOUT_IN_DRIVER
+  default "0x0F"
+  help
+    Sets the default timeout value for Tri-Media DCS network controller. The following
+    are the possible valid values
+    
+        Value                   Cycles to wait
+        =====                   ==============
+        0x00                         7
+        0x03                         15
+        0x04                         31
+        0x05                         63
+        0x06                         127
+        0x07                         255
+        0x08                         511
+        0x09                         1023
+        0x0A                         2047
+        0x0B                         4095
+        0x0C                         8191
+        0x0D                         16383
+        0x0E                         32767
+        0x0F                         65535
+        0x10                       No timeout till rd/wr event completes
+
+endmenu
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/Makefile linux-2.6.34/drivers/dcs_net/Makefile
--- linux-2.6.34.orig/drivers/dcs_net/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,26 @@
+obj-$(CONFIG_DCS_NETWORK_SUPPORT) += pnx-dcs.o
+pnx-dcs-y += pnx_dcs.o tmhwDcsNetwork/src/tmhwDcsNetwork.o tmhwDcsNetwork/cfg/tmhwDcsNetwork_DvpNoBslCfg.o
+
+nx_dcsn_flag-$(CONFIG_SOC_PNX8550) := -DTMFL_PNX_ID=8550
+nx_dcsn_flag-$(CONFIG_SOC_PNX8535) := -DTMFL_PNX_ID=8535
+nx_dcsn_flag-$(CONFIG_SOC_PNX8542) := -DTMFL_PNX_ID=8542
+nx_dcsn_flag-$(CONFIG_SOC_PNX8543) := -DTMFL_PNX_ID=8543
+nx_dcsn_flag-$(CONFIG_SOC_PNX85500) := -DTMFL_PNX_ID=85500
+nx_dcsn_flag-$(CONFIG_ARCH_APOLLO) := -DTMFL_PNX_ID=0000 \
+	-DTMHW_DCSNETWORK_TCONFIG_HWMODULE_ID=0xA06D\
+	-DTMHW_DCSNETWORK_TSECURITY_HWMODULE_ID=0xA06E	\
+	-DTMHW_DCSNETWORK_MCONFIG_HWMODULE_ID=0xA06D\
+	-DTMHW_DCSNETWORK_MSECURITY_HWMODULE_ID=0xA06E	\
+	-DTMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION=0x3\
+	-DTMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION=0x3		\
+	-DTMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION=0x3	\
+	-DTMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION=0x3	\
+	-DTMHW_DCSNETWORK_MDCS_A06E_LIST2	  \
+	-DTMHW_DCSNETWORK_TDCS_A06E_LIST2\
+	-DTMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS=5    \
+	-DTMHW_DCSNETWORK_MDCS_NO_OF_TARGETS=52   \
+	-DTMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS=3    \
+	-DTMHW_DCSNETWORK_TDCS_NO_OF_TARGETS=30 
+
+EXTRA_CFLAGS = $(nx_dcsn_flag-y) -DMIPSEL -DTMFL_CPU_IS_MIPS=1 -DMONTAVISTA_GNU -DLINUX -DTMFL_OS_IS_HPUNIX=0 -Iinclude/HwAPI \
+	-Idrivers/dcs_net/tmhwDcsNetwork/inc -Idrivers/dcs_net/tmhwDcsNetwork/cfg -Iarch/mips/include/asm
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/pnx_dcs.c linux-2.6.34/drivers/dcs_net/pnx_dcs.c
--- linux-2.6.34.orig/drivers/dcs_net/pnx_dcs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/pnx_dcs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,754 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ * DCS Network support for NXP Nexperia SoC.
+ *
+ * Revision History
+ * Version  Author             Date          Remarks
+ * 0.1.0    Sundarapandian A   03/22/2006    Proposal
+ * 1.0      Sundarapandian A   01/11/2007    Updated for new requirements
+ * 1.1      Sundarapandian A   02/22/2007    Updated for eh24#6389
+ * 1.2.0    Bangaragiri G      07/10/2007    Updated for PB5#346
+ * 1.3.0    Bangaragiri G      08/06/2007    Updates for PB5#348(oslinux 6.0)
+ * 1.4.0    Bangaragiri G      12/03/2007    Updates for PNX8543
+ * 1.5.0    Bangaragiri G      03/10/2008    Updates for EA kernel
+ * 1.6.0    Bangaragiri G      09/19/2008    Updates for VectorCAST (PB5#416)
+ * 1.7.0    Bangaragiri G      02/10/2009    Updates for 2.6.27.9
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/pnx_dcs.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <tmhwDcsNetwork.h>
+#include <tmhwDcsNetwork_CfgLocal.h>
+
+/* Define DCS_DEBUG to generate debug outputs */
+#ifdef CONFIG_DCS_DEBUG
+#define dbg_print(a...) printk(KERN_DEBUG a)
+#else
+#define dbg_print(a...)
+#endif
+
+#define DCS_LOG_BUF_SIZE   (1 << DCS_LOG_BUF_CNT)
+
+#if defined(CONFIG_PNX8543) || defined(CONFIG_PNX85500) || defined(CONFIG_ARCH_APOLLO)
+/* All warnings up to this many will be printed... */
+#define DCS_WARNING_THRESHOLD   5
+/* ... after which they will be printed at least this many jiffies apart. */
+#define DCS_WARNING_INTERVAL    (10 * HZ)
+
+#endif
+
+/**
+ * Platform specific configurations
+ **/
+#ifdef CONFIG_SOC_PNX8550
+#error PNX8550 Not yet supported!!!
+
+#elif defined(CONFIG_SOC_PNX8543) /* SOC_PNX8543 */
+/**
+ * PNX8XXX specific initializations
+ **/
+#include <mach-pnx8543/irq.h>
+
+#define DCS_NO_OF_UNITS 2
+#define DCS8XXX_UNIT_MDCS   0
+#define DCS8XXX_UNIT_TDCS   1
+
+#define PNX_DCS_NW_SIZE (1024 * 4)
+
+struct dcs_dev {
+    int unit_no;
+    __u32 *virtual_addr;
+    __u32 *security_virt_addr;
+};
+
+#ifndef CONFIG_MDCS_TOUT_IN_DRIVER
+#define CONFIG_MDCSN_DEFAULT_TOUT 0
+#endif
+#ifndef CONFIG_TDCS_TOUT_IN_DRIVER
+#define CONFIG_TDCSN_DEFAULT_TOUT 0
+#endif
+
+static unit_info dcs_info[] = {
+    { PNX8XXX_INT_MDCS, "MIPS DCS network", CONFIG_MDCSN_DEFAULT_TOUT },
+    { PNX8XXX_INT_TDCS, "Tri-Media DCS Network", CONFIG_TDCSN_DEFAULT_TOUT },
+};
+
+#define DCS_IS_VALID_UNIT(unit) \
+            ((unit) == DCS8XXX_UNIT_MDCS || (unit) == DCS8XXX_UNIT_TDCS)
+
+#elif defined(CONFIG_SOC_PNX85500) /* SOC_PNX85500 */
+/**
+ * PNX8XXX specific initializations
+ **/
+#include <mach-pnx85500/irq.h>
+
+#define DCS_NO_OF_UNITS 2
+#define DCS8XXX_UNIT_MDCS   0
+#define DCS8XXX_UNIT_TDCS   1
+
+#define PNX_DCS_NW_SIZE (1024 * 4)
+
+struct dcs_dev {
+    int unit_no;
+    __u32 *virtual_addr;
+    __u32 *security_virt_addr;
+};
+
+#ifndef CONFIG_MDCS_TOUT_IN_DRIVER
+#define CONFIG_MDCSN_DEFAULT_TOUT 0
+#endif
+#ifndef CONFIG_TDCS_TOUT_IN_DRIVER
+#define CONFIG_TDCSN_DEFAULT_TOUT 0
+#endif
+
+static unit_info dcs_info[] = {
+    { PNX8XXX_INT_MDCS, "MIPS DCS network", CONFIG_MDCSN_DEFAULT_TOUT },
+    { PNX8XXX_INT_TDCS, "Tri-Media DCS Network", CONFIG_TDCSN_DEFAULT_TOUT },
+};
+
+#define DCS_IS_VALID_UNIT(unit) \
+            ((unit) == DCS8XXX_UNIT_MDCS || (unit) == DCS8XXX_UNIT_TDCS)
+
+#elif defined(CONFIG_ARCH_APOLLO)
+
+#define DCS_NO_OF_UNITS 2
+#define DCS8XXX_UNIT_MDCS   0
+#define DCS8XXX_UNIT_TDCS   1
+
+#define PNX_DCS_NW_SIZE (1024 * 4)
+
+struct dcs_dev {
+    int unit_no;
+    __u32 *virtual_addr;
+    __u32 *security_virt_addr;
+};
+
+#ifndef CONFIG_MDCS_TOUT_IN_DRIVER
+#define CONFIG_MDCSN_DEFAULT_TOUT 0
+#endif
+#ifndef CONFIG_TDCS_TOUT_IN_DRIVER
+#define CONFIG_TDCSN_DEFAULT_TOUT 0
+#endif
+
+static unit_info dcs_info[] = {
+    { 0, "MIPS DCS network", CONFIG_MDCSN_DEFAULT_TOUT },
+    { 0, "Tri-Media DCS Network", CONFIG_TDCSN_DEFAULT_TOUT },
+};
+
+#define DCS_IS_VALID_UNIT(unit) \
+            ((unit) == DCS8XXX_UNIT_MDCS || (unit) == DCS8XXX_UNIT_TDCS)
+
+#else
+
+#error Unknown Platform
+#endif /* Error */
+
+static DECLARE_WAIT_QUEUE_HEAD(pnx_dcs_wq);
+
+wait_queue_head_t *pnx_dcs_event = &pnx_dcs_wq;
+EXPORT_SYMBOL(pnx_dcs_event);
+
+#if defined(CONFIG_PNX8543) || defined(CONFIG_PNX85500) || defined(CONFIG_ARCH_APOLLO)
+
+static int dcs_num_shown            = 0;  /* Number of MDCS events shown */
+static int dcs_num_counted          = 0;  /* Number of MDCS events counted */
+static int dcs_num_innocent         = 0;  /* Number of "innocent" MDCS events */
+static int dcs_num_warnings_printed = 0;  /* Number of warnings printed */
+static unsigned long dcs_jiffies_innocent;  /* Jiffies at last-reported "innocent" MDCS event */
+
+#else
+
+/* DCS interrupt counter */
+static unsigned int dcs_irq_sequence_number = 0;
+
+#endif
+
+static dcs_log_t dcs_log[DCS_LOG_BUF_SIZE];
+
+/**
+ * Log Buffer tracking structure
+ **/
+static struct __tag_log_ptr
+{
+    __u32 head;
+    __u32 tail;
+    __u8 full;
+    __u8 empty;
+}log_ptr = {0};
+
+/* Global configuration memory used by HwAPI */
+static tmhwDcsNetwork_Cfg_t *dcs_cfg;
+static tmhwDcsNetwork_Cfg_t *dcs_cfg_security;
+
+#ifdef CONFIG_DCS_USE_WORKQUEUE
+static struct delayed_work pnx_dcs_workqueue;
+static void pnx_dcs_wq_function(struct work_struct *wrk_q);
+#endif
+
+#if defined(CONFIG_DCS_DEBUG) || defined(CONFIG_DCS_USE_WORKQUEUE)
+/* Prototype */
+static void pnx_dcs_print(const dcs_log_t *log, const char *prefix);
+#endif
+
+/**
+ * pnx_dcs_set_target_access - Set the target access
+ * @unit     : DCS unit number
+ * @t_ctrl   : pointer to target control structure
+ * Description : Function to set target access control
+ * Return : 0 - success
+ *          -EIO - on failure (see errno.h)
+ **/
+int pnx_dcs_set_target_access (int unit, struct target_ctrl *t_ctrl)
+{
+    tmhwDcsNetwork_TargetUnit_t tgt;
+
+    if (!DCS_IS_VALID_UNIT(unit))
+        return -EINVAL;
+
+    tgt.targetId = t_ctrl->tgt->target_id;
+    tgt.unitNo = t_ctrl->tgt->unit_no;
+
+    if (tmhwDcsNetwork_SetTargetAccessControl (unit, tgt,
+              (tmhwDcsNetwork_InitiatorUnit_t *) t_ctrl->allowed_initiators,
+              t_ctrl->no_of_initiators) != TM_OK)
+        return -EIO;
+
+    return 0;
+}
+EXPORT_SYMBOL (pnx_dcs_set_target_access);
+
+/**
+ * pnx_dcs_get_target_access - Get the target access
+ * @unit     : DCS unit number
+ * @t_ctrl   : pointer to target control structure
+ * Description : Function to get target access control
+ * Return : 0 - success
+ *          -EIO - on failure (see errno.h)
+ **/
+int pnx_dcs_get_target_access (int unit, struct target_ctrl *t_ctrl)
+{
+    tmhwDcsNetwork_TargetUnit_t tgt;
+
+    if (!DCS_IS_VALID_UNIT(unit))
+        return -EINVAL;
+
+		tgt.targetId = t_ctrl->tgt->target_id;
+		tgt.unitNo = t_ctrl->tgt->unit_no;
+		
+    if (tmhwDcsNetwork_GetTargetAccessControl (unit, tgt,
+              (tmhwDcsNetwork_InitiatorUnit_t *) t_ctrl->allowed_initiators,
+              (pUInt32) &t_ctrl->no_of_initiators) != TM_OK)
+        return -EIO;
+
+    return 0;
+}
+EXPORT_SYMBOL (pnx_dcs_get_target_access);
+
+/**
+ * pnx_dcs_set_access_timeout - Set target access timeout
+ * @unit_no   : Unit number of DCS unit
+ * @timeout   : Time out value (for possible values see linux/pnx-dcs.h)
+ * Description : Function to set the target access timeout
+ * Return : 0 - success
+ *          -EIO - On Failure (see errno.h)
+ **/
+int pnx_dcs_set_access_timeout (__u32 unit_no, __u32 timeout)
+{
+    if (!DCS_IS_VALID_UNIT(unit_no))
+        return -EINVAL;
+
+    if (tmhwDcsNetwork_SetTargetAccessTimeout (
+              (tmUnitSelect_t) unit_no, 
+              (tmhwDcsNetwork_TargetAccessTimeout_t) timeout) != TM_OK)
+        return -ENODEV;
+    return 0;
+}
+EXPORT_SYMBOL (pnx_dcs_set_access_timeout);
+
+/**
+ * pnx_dcs_get_access_timeout - Get target access timeout
+ * @unit_no   : Unit number of DCS unit
+ * Description : Function to get the target access timeout
+ * Return : Timeout value - success
+ *          -EIO - On Failure (see errno.h)
+ **/
+int pnx_dcs_get_access_timeout (__u32 unit_no)
+{
+    int timeout;
+    if (!DCS_IS_VALID_UNIT(unit_no))
+        return -EINVAL;
+
+    if (tmhwDcsNetwork_GetTargetAccessTimeout (
+              (tmUnitSelect_t) unit_no, 
+              (tmhwDcsNetwork_TargetAccessTimeout_t *) &timeout) != TM_OK)
+        return -ENODEV;
+    return timeout;
+}
+EXPORT_SYMBOL (pnx_dcs_get_access_timeout);
+
+/**
+ * pnx_dcs_get_event_log - Get the log message
+ * @log   : Pointer to log data structure
+ * Description : Function to get event log data
+ * Return : 0 - success
+ *          -EAGAIN - on no log available (see errno.h)
+ **/
+int pnx_dcs_get_event_log (dcs_log_t *log)
+{
+    if (log_ptr.empty)
+        return -EAGAIN;
+
+    memcpy (log, &dcs_log[log_ptr.tail], sizeof(dcs_log_t));
+    log_ptr.tail = (log_ptr.tail + 1) & ~(-1U << DCS_LOG_BUF_CNT);
+    log_ptr.full = 0;
+
+    if (log_ptr.tail == log_ptr.head)
+        log_ptr.empty = 1;
+
+    return 0;
+}
+EXPORT_SYMBOL (pnx_dcs_get_event_log);
+
+/**
+ * pnx_dcs_uninit - Un-initialization function
+ * @units   : Number of units to be un-initialized
+ * Description : Un initialization functions used by
+ *  driver entry/exit calls.
+ * Return : 0 - success
+ **/
+static int pnx_dcs_uninit (int units)
+{
+    int i;
+
+    for (i = 0; i < units; i++){
+				if (i == DCS8XXX_UNIT_MDCS){
+        	tmhwDcsNetwork_IntDisable (i, DCS_ERROR | DCS_TIMEOUT);
+       		free_irq (dcs_info[i].irq_no, NULL);
+				}
+        iounmap ((void *) dcs_cfg_security[i].baseAddress);
+        iounmap ((void *) dcs_cfg[i].baseAddress);
+        dbg_print ("DCS%d: unregistered.\r\n", i);
+    }
+
+    return 0;
+}
+
+/**
+ * pnx_dcs_irq - ISR to handle DCS interrupts
+ * @irq_no   : Interrupting IRQ number.
+ * @dev      : NULL
+ * @dcs_regs : Register set of the processor
+ * Description : This routine will handle the interrupts
+ *   raised by DCS network on Error or Timeout
+ * Return : IRQ_HANDLED - success
+ *          IRQ_NONE - on failure (see interrupt.h)
+ **/
+static irqreturn_t pnx_dcs_irq(int irq_no, void *dev)
+{
+	int i;
+	__u32 status;
+	int unit_id = -1;
+	tmhwDcsNetwork_IntCauseInfo_t cause;
+
+	for (i = 0; i < DCS_NO_OF_UNITS; i++)
+		if (dcs_info[i].irq_no == irq_no){
+			unit_id = i;
+			break;
+		}
+
+	if (unit_id < 0){
+		/**
+		 * This cannot happen unless the interrupt is triggered by 
+		 * a serious hardware or operating system bug.
+		 **/
+		printk (KERN_DEBUG "IRQ%d cannot be handled by DCS network\r\n", irq_no);
+		return IRQ_NONE;
+	}
+
+	if (tmhwDcsNetwork_IntGetStatus (unit_id, (pUInt32) &status) != TM_OK){
+		printk (KERN_DEBUG "Error in getting interrupt status for IRQ%d\r\n", irq_no);
+		return IRQ_NONE;
+	}
+
+	status &= DCS_ERROR | DCS_TIMEOUT;
+
+#if defined(CONFIG_PNX8543) || defined(CONFIG_PNX85500) || defined(CONFIG_ARCH_APOLLO)
+	if (status) {
+		int isError;
+		dcs_category_t cat;
+		int initiator;
+		int target;
+
+		(void) tmhwDcsNetwork_GetInterruptInfo(unit_id, &cause);
+		isError = cause.errorOrTimeout;
+		initiator = cause.initiator.initiatorId;
+		target = cause.target.targetId;
+
+		/* Handle only one condition, even if both DCS_ERROR and DCS_TIMEOUT are set */
+		status = (isError ? DCS_ERROR : DCS_TIMEOUT);
+
+		/* Categorize the event */
+		if (initiator==1 && cause.isRead && isError)
+			/* Ignore JTAG read errors, e.g. DvpMon accessing unmapped MMIO addresses */
+			cat = DcsCatIgnored;
+		else if (initiator==5 && isError)
+			/* TM error: probably due to PR eh24#6049 et alii */
+			cat = DcsCatInnocent;
+		else if (dcs_num_counted==0 && !cause.isRead && !isError && initiator==2 && cause.address==0x1be47064)
+			/* Write timeout 0 at 0x1BE47064 by ini 2 to tgt 6: PR eh24#5700 */
+			cat = DcsCatInnocent;
+		else if (dcs_num_counted==1 && cause.isRead && !isError && initiator==0 && cause.address==0x2a002000)
+			/* Read timeout 1 at 0x2A002000 by ini 0 to tgt 25: PR eh25#2925 */
+			cat = DcsCatInnocent;
+		else
+			cat = DcsCatSerious;
+
+		if ((cat==DcsCatSerious)
+				|| ((cat==DcsCatInnocent) && ((dcs_num_innocent < DCS_WARNING_THRESHOLD)
+					|| (jiffies - dcs_jiffies_innocent >= DCS_WARNING_INTERVAL))))
+		{
+#if defined(CONFIG_MIPS)
+			__u32 epc = read_c0_epc();
+#elif defined(CONFIG_ARM)
+			/* 
+			 * FIXME: This is not a reliable way of getting PC 
+			 * Work out something here later
+			 */
+			register __u32 lr __asm__("lr");
+			__u32 epc = lr;
+#else
+#error	An architecture specific code must be used here to get Program Counter!!!
+#endif
+			dcs_log_t *dlog;
+
+#ifdef CONFIG_DCS_LOG_WRAPAROUND
+			if (log_ptr.full)
+				log_ptr.head = log_ptr.tail = (log_ptr.head + 1) & ~(-1U << DCS_LOG_BUF_CNT);
+			dlog = &dcs_log[log_ptr.head];
+#else
+			dcs_log_t local_log;
+			if (log_ptr.full)
+				dlog = &local_log;
+			else
+				dlog = &dcs_log[log_ptr.head];
+#endif
+
+			dlog->count_number = dcs_num_counted;
+			dlog->shown_number = dcs_num_shown;
+			dlog->cat = cat;
+			dlog->time = jiffies;
+			dlog->task_info = current;
+			dlog->epc = epc;
+			dlog->unit_no = unit_id;
+			dlog->cause.reason = isError ? DCS_REASON_ERR : DCS_REASON_TOUT;
+			dlog->cause.mask = (__u32) cause.byteMask;
+			dlog->cause.address = cause.address;
+			dlog->cause.access_type = cause.isRead ? DCS_ACCESS_RD : DCS_ACCESS_WR;
+			memcpy(&dlog->cause.initiator, &cause.initiator, sizeof(struct initiator));
+			memcpy(&dlog->cause.target, &cause.target, sizeof(struct target));
+
+			if (dlog == &dcs_log[log_ptr.head])
+			{
+				if (!log_ptr.full)
+					log_ptr.head = (log_ptr.head + 1) & ~(-1U << DCS_LOG_BUF_CNT);
+				log_ptr.empty = 0;
+				if (log_ptr.head == log_ptr.tail)
+					log_ptr.full = 1;
+			}
+
+#if defined(CONFIG_DCS_DEBUG) && !defined(CONFIG_DCS_USE_WORKQUEUE)
+			pnx_dcs_print(dlog, KERN_DEBUG);
+#endif
+			dcs_num_shown++;
+			if (cat==DcsCatInnocent) dcs_jiffies_innocent = jiffies;
+		}
+		if (cat!=DcsCatIgnored)  dcs_num_counted++;
+		if (cat==DcsCatInnocent) dcs_num_innocent++;
+	}
+	
+#else	
+	if (status) {
+		int hide;
+
+		(void) tmhwDcsNetwork_GetInterruptInfo (unit_id, &cause);
+
+		/* Handle only one condition, even if both DCS_ERROR and DCS_TIMEOUT set */
+		status = (cause.errorOrTimeout ? DCS_ERROR : DCS_TIMEOUT);
+
+		/* Hide read errors from JTAG, e.g. for DvpMon accessing unmapped MMIO addresses */
+		hide = (cause.errorOrTimeout && cause.isRead && cause.initiator.initiatorId==1);
+
+		if (!hide) {
+#ifdef CONFIG_MIPS
+			__u32 epc = read_c0_epc();
+#elif defined(CONFIG_ARM)
+			/* 
+			 * FIXME: This is not a reliable way of getting PC 
+			 * Work out something here later
+			 */
+			register __u32 lr __asm__("lr");
+			__u32 epc = lr;
+#else
+#error      An architecture specific code must be used here to get Program Counter!!!
+#endif
+			int doStore;
+
+#ifdef CONFIG_DCS_LOG_WRAPAROUND
+			if (log_ptr.full)
+				log_ptr.head = log_ptr.tail = (log_ptr.head + 1) & ~(-1U << DCS_LOG_BUF_CNT);
+			doStore = 1;
+#else
+			doStore = !log_ptr.full;
+#endif
+			if (doStore) {
+				dcs_log_t *dlog = &dcs_log[log_ptr.head];
+
+				dlog->seq_number = dcs_irq_sequence_number;
+				dlog->unit_no = unit_id;
+				dlog->time = jiffies;
+				dlog->task_info = current;
+				dlog->epc = epc;
+				dlog->cause.reason = cause.errorOrTimeout ? DCS_REASON_ERR : DCS_REASON_TOUT;
+				dlog->cause.mask = (__u32) cause.byteMask;
+				dlog->cause.address = cause.address;
+				dlog->cause.access_type = cause.isRead ? DCS_ACCESS_RD : DCS_ACCESS_WR;
+				memcpy (&dlog->cause.initiator, &cause.initiator, sizeof (struct initiator));
+				memcpy (&dlog->cause.target, &cause.target, sizeof (struct target));
+
+				if (!log_ptr.full)
+					log_ptr.head = (log_ptr.head + 1) & ~(-1U << DCS_LOG_BUF_CNT);
+				log_ptr.empty = 0;
+				if (log_ptr.head == log_ptr.tail)
+					log_ptr.full = 1;
+			}
+
+#ifndef CONFIG_DCS_USE_WORKQUEUE
+			pnx_dcs_print(dlog, KERN_DEBUG);
+#endif
+
+			dcs_irq_sequence_number++;
+		}
+	}
+#endif
+	
+	/* All the interrupts are handled */
+	tmhwDcsNetwork_IntClear (unit_id, status);
+	wake_up (pnx_dcs_event);
+#ifdef CONFIG_DCS_USE_WORKQUEUE
+	schedule_delayed_work(&pnx_dcs_workqueue, 1);
+#endif
+	return IRQ_HANDLED;
+}
+
+/**
+ * pnx_dcs_init - Driver initialization routine
+ * Description : This function will allocate all
+ *   resources required for the driver.
+ * Return : 0 - success
+ *          -ENOMEM - on failure (see errno.h)
+ **/
+static int __init pnx_dcs_init (void)
+{
+	int status, i;
+	tmhwDcsNetwork_Capabilities_t caps;
+
+	/* Initially the buffer will be empty */
+	log_ptr.empty = 1; 
+
+#ifdef CONFIG_DCS_USE_WORKQUEUE
+	INIT_DELAYED_WORK(&pnx_dcs_workqueue, pnx_dcs_wq_function);
+#endif
+
+	/* Initialize the configuration pointers */
+	dcs_cfg = tmhwDcsNetwork_ConfigCfgGet();
+	dcs_cfg_security = tmhwDcsNetwork_SecurityCfgGet();
+
+	for (i = 0; i < DCS_NO_OF_UNITS; i++){
+
+		dbg_print ("DCS%d: Found @ Physical base %#x\r\n",
+					  i, (__u32) dcs_cfg[i].baseAddress);
+
+		/* Initialize the base address for HwAPI */
+		dcs_cfg[i].baseAddress =
+		  (UInt32) ioremap(dcs_cfg[i].baseAddress, PNX_DCS_NW_SIZE);
+		if (dcs_cfg[i].baseAddress == NULL){
+			  pnx_dcs_uninit (i);
+			  return -ENOMEM;
+		}
+
+		dcs_cfg_security[i].baseAddress =
+		  (UInt32) ioremap(dcs_cfg_security[i].baseAddress, PNX_DCS_NW_SIZE);
+		if (dcs_cfg_security[i].baseAddress == NULL){
+			  iounmap ((void *) dcs_cfg_security[i].baseAddress);
+			  pnx_dcs_uninit (i);
+			  return -ENOMEM;
+		}
+	}
+	
+	/**
+	 * NOTE: We cannot include them in single loop
+	 * because capbilities expect all the base initialized.
+	 **/
+	for (i = 0; i < DCS_NO_OF_UNITS; i++){
+
+#if defined(CONFIG_MDCS_TOUT_IN_DRIVER) || defined(CONFIG_TDCS_TOUT_IN_DRIVER)
+		tmErrorCode_t err;
+#endif
+
+		if (tmhwDcsNetwork_GetCapabilities (i, &caps) != TM_OK) {
+			printk (KERN_ERR "Unable to get information of DCS Unit %d\r\n", i);
+			pnx_dcs_uninit (i);
+			return -EIO;
+		}
+
+		dbg_print ("DCS%d: No. of Targets = %d, No. of Initiators = %d\r\n",
+						i, (int) caps.noOfTargets, (int) caps.noOfInitiators);
+
+#ifdef CONFIG_MDCS_TOUT_IN_DRIVER
+		err = (i == DCS8XXX_UNIT_MDCS) ? 
+			tmhwDcsNetwork_SetTargetAccessTimeout(i, dcs_info[i].timeout) : TM_OK;
+		if (err!=TM_OK)
+			printk (KERN_ERR "DCS%d: tmhwDcsNetwork_SetTargetAccessTimeout()"
+					" returned 0x%08X", i, (__u32) err);
+#endif
+
+#ifdef CONFIG_TDCS_TOUT_IN_DRIVER
+		err = (i == DCS8XXX_UNIT_TDCS) ? 
+			tmhwDcsNetwork_SetTargetAccessTimeout(i, dcs_info[i].timeout) : TM_OK;
+		if (err!=TM_OK)
+			printk (KERN_ERR "DCS%d: tmhwDcsNetwork_SetTargetAccessTimeout()"
+					" returned 0x%08X", i, (__u32) err);
+#endif
+
+		/* Only MDCSN interrupts should be handled by the MIPS */
+		if (i != DCS8XXX_UNIT_MDCS) continue;
+
+		/* Initialize the interrupts */
+		status = request_irq (dcs_info[i].irq_no, pnx_dcs_irq,
+						IRQF_DISABLED, dcs_info[i].irq_name, NULL);
+		if (status < 0){
+			dbg_print ("DCS%d: Unable to request IRQ%d\r\n", i,
+				      (int) dcs_info[i].irq_no);
+			pnx_dcs_uninit (i);
+			return status;
+		}
+
+		/* At this point interrupts can be handled */
+		tmhwDcsNetwork_IntEnable (i, DCS_ERROR | DCS_TIMEOUT);
+		dbg_print ("DCS%d registered at virtual base address %#x and IRQ%d\r\n",
+			i, (__u32) dcs_cfg[i].baseAddress, dcs_info[i].irq_no);
+	}
+
+	return 0;
+}
+
+/**
+ * pnx_dcs_cleanup - Cleanup function of DCS driver
+ * Description : This function will deallocate all
+ *   resources allocated by the init call.
+ * Return :  None
+ **/
+static void __exit pnx_dcs_cleanup (void)
+{
+	/** 
+	 * If the work queue has not finished its task but pending
+	 * a failure to cancel can cause kernel panic
+	 **/
+#ifdef CONFIG_DCS_USE_WORKQUEUE
+	(void) cancel_delayed_work(&pnx_dcs_workqueue);
+#endif
+	pnx_dcs_uninit (DCS_NO_OF_UNITS);
+	return ;
+}
+
+#if defined(CONFIG_DCS_DEBUG) || defined(CONFIG_DCS_USE_WORKQUEUE)
+/* Report the given DCS event; prefix is KERN_DEBUG or similar */
+static void pnx_dcs_print(const dcs_log_t *log, const char *prefix)
+{
+
+#if defined(CONFIG_PNX8543) || defined(CONFIG_PNX85500) || defined(CONFIG_ARCH_APOLLO)
+	printk("%s%s[%d] MDCS %s %s %d/%d from %d to %d at %08x; EPC %08x\r\n",
+		prefix,
+		(log->cat==DcsCatInnocent ? "(Warning) " : ""),
+		log->time,
+		(log->cause.access_type==DCS_ACCESS_WR ? "write" : "read"),
+		(log->cause.reason==DCS_REASON_ERR ? "error" : "timeout"),
+		log->shown_number, log->count_number,
+		log->cause.initiator.initiator_id,
+		log->cause.target.target_id,
+		log->cause.address,
+		log->epc);
+		if (log->cat==DcsCatInnocent)
+		{
+			if (dcs_num_warnings_printed+1==DCS_WARNING_THRESHOLD)
+				printk("%s          (Additional MDCS warnings will be reported only occasionally.)\r\n",
+					prefix);
+			dcs_num_warnings_printed++;
+		}
+#else
+		printk("%sDCS%d (%d) %s %s %d at 0x%08X by ini %d to tgt %d; EPC 0x%08X\n",
+			prefix,
+			unit_id,
+			(int) jiffies,
+			(cause.isRead ? "read" : "write"),
+			(cause.errorOrTimeout ? "error" : "timeout"),
+			dcs_irq_sequence_number,
+			(unsigned) cause.address,
+			cause.initiator.initiatorId,
+			cause.target.targetId,
+			epc);
+#endif
+
+}
+#endif
+
+/**
+ * Workqueue function
+ **/
+#ifdef CONFIG_DCS_USE_WORKQUEUE
+
+static void pnx_dcs_wq_function(struct work_struct *wrk_q)
+{
+	dcs_log_t log;
+
+	while (!pnx_dcs_get_event_log(&log)) {
+		pnx_dcs_print(&log, KERN_CRIT);
+	}
+}
+
+#endif
+
+
+/* Register init & exit routines */
+module_init(pnx_dcs_init);
+module_exit(pnx_dcs_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NXP B.V.");
+MODULE_DESCRIPTION("DCS Network controller core driver");
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_CfgLocal.h linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_CfgLocal.h
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_CfgLocal.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_CfgLocal.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,128 @@
+/**********************************************************************
+*
+*	Header %name:	tmhwDcsNetwork_CfgLocal.h %
+*	Instance:		PB5_1
+*	Description:	
+*	%created_by:	tusr69 %
+*	%date_created:	Mon Feb 13 14:46:31 2006 %
+*
+**********************************************************************/
+
+
+#ifndef TMHWDCSNETWORK_CFGLOCAL_H  //---------------
+#define TMHWDCSNETWORK_CFGLOCAL_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+#include <tmNxTypes.h>
+#include <tmhwDcsNetwork_Cfg.h>
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+
+	
+//-----------------------------------------------------------------------------
+// FUNCTION   : tmhwDcsNetwork_ConfigCfgGet
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration structure array
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_Cfg_t      
+tmhwDcsNetwork_ConfigCfgGet(void); 
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION   : tmhwDcsNetwork_SecurityCfgGet
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration structure array
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+
+ptmhwDcsNetwork_Cfg_t      
+tmhwDcsNetwork_SecurityCfgGet(void); 
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_ConfigCfgGetState
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration state structure array
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_CfgState_t 
+tmhwDcsNetwork_ConfigCfgGetState(void);
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SecurityCfgGetState
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration state structure array
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_CfgState_t 
+tmhwDcsNetwork_SecurityCfgGetState(void);
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_ConfigCfgGetNumUnits
+//
+// DESCRIPTION: Returns total number of units available in DCS NETWORK hardware
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+UInt32              
+tmhwDcsNetwork_ConfigCfgGetNumUnits(void);
+
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SecurityCfgGetNumUnits
+//
+// DESCRIPTION: Returns total number of units available in DCS NETWORK  hardware
+//
+// Note       : This function will lie in the internal interface of tmhwDcsNetwork
+//              and should not be visible to clients of tmhwDcsNetwork
+//-----------------------------------------------------------------------------
+UInt32              
+tmhwDcsNetwork_SecurityCfgGetNumUnits(void);
+
+
+//-----------------------------------------------------------------------------
+// Internal Prototypes:
+//-----------------------------------------------------------------------------
+//
+void
+tmhwDcsNetwork_ConfigCfgGetModulueInfo(void);
+
+void
+tmhwDcsNetwork_SecurityCfgGetModulueInfo(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMHWDCSNETWORK_CFGLOCAL_H //---------------
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_DvpNoBslCfg.c linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_DvpNoBslCfg.c
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_DvpNoBslCfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/cfg/tmhwDcsNetwork_DvpNoBslCfg.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,187 @@
+/**********************************************************************
+*
+*	C %name:		tmhwDcsNetwork_DvpNoBslCfg.c %
+*	Instance:		PB5_1
+*	Description:	
+*	%created_by:	remmersw %
+*	%date_created:	Thu May 18 14:03:07 2006 %
+*
+**********************************************************************/
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+#if !defined(SDE4_BUILD)
+#include <tmSysCfg.h>
+#endif
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#include <tmhwDcsNetwork.h>
+#include <tmhwDcsNetwork_CfgLocal.h>
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+#define TMHW_DCSNETWORK_COMPATIBILITY_EXP   1  // DCS NETWORK Expected compatibility Number
+#define TMHW_DCSNETWORK_MAJOR_VERSION_EXP   1  // DCS NETWORK Major version compatibility Number
+
+#if     (TMHW_DCSNETWORK_COMPATIBILITY_EXP != TMHW_DCSNETWORK_COMPATIBILITY_NR)
+#error  ERROR: Expected TMHW_DCSNETWORK_COMPATIBILITY_NR mismatch detected !
+#elif   (TMHW_DCSNETWORK_MAJOR_VERSION_EXP != TMHW_DCSNETWORK_MAJOR_VERSION_NR)
+#error  ERROR: Expected TMHW_DCSNETWORK_MAJOR_VERSION_NR mismatch detected !
+#endif
+
+
+
+
+
+//-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+
+// tmhwDcsNetwork configuration structure array. This array will have size equal to 
+// number of units available in DCSNETWORK hardware. This will not be static since 
+// tmhwDcsNetwork client might want to overwrite base address.
+// 
+tmhwDcsNetwork_Cfg_t  gtmhwDcsNetwork_ConfigCfg[] =
+{
+    {
+
+       TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0,
+       TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID
+    },
+    {
+
+       TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0,
+       TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID
+    }
+};
+
+
+tmhwDcsNetwork_Cfg_t  gtmhwDcsNetwork_SecurityCfg[] =
+{
+    {
+
+       TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0,
+       TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID
+    },
+    {
+
+       TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0,
+       TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID
+    }
+};
+
+
+
+#define  TMHW_DCSNETWORK_CONFIG_CFG_NUM_UNITS  (sizeof(gtmhwDcsNetwork_ConfigCfg)/sizeof(tmhwDcsNetwork_Cfg_t))
+
+#define  TMHW_DCSNETWORK_SECURITY_CFG_NUM_UNITS  (sizeof(gtmhwDcsNetwork_SecurityCfg)/sizeof(tmhwDcsNetwork_Cfg_t))
+
+
+
+// tmhwDcsNetwork configuration state structure array. This array will have size equal to 
+// number of units available in DCSNETWORK hardware
+static tmhwDcsNetwork_CfgState_t  gDcsNetworkConfig_CfgState[TMHW_DCSNETWORK_CONFIG_CFG_NUM_UNITS] = 
+{
+   {
+      0     // Unit number 0
+   }
+};
+
+
+static tmhwDcsNetwork_CfgState_t  gDcsNetworkSecurity_CfgState[TMHW_DCSNETWORK_SECURITY_CFG_NUM_UNITS] = 
+{
+   {
+      0     // Unit number 0
+   }
+};
+
+
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_ConfigCfgGet
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration structure array
+//
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_Cfg_t       
+tmhwDcsNetwork_ConfigCfgGet(void)
+{
+    return gtmhwDcsNetwork_ConfigCfg;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SecurityCfgGet
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration structure array
+//
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_Cfg_t       
+tmhwDcsNetwork_SecurityCfgGet(void)
+{
+    return gtmhwDcsNetwork_SecurityCfg;
+}
+
+
+ 
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_ConfigCfgGetState
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration state structure array
+//
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_CfgState_t 
+tmhwDcsNetwork_ConfigCfgGetState(void)
+{
+    return gDcsNetworkConfig_CfgState;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SecurityCfgGetState
+//
+// DESCRIPTION: Returns pointer to the tmhwDcsNetwork configuration state structure array
+//
+//-----------------------------------------------------------------------------
+ptmhwDcsNetwork_CfgState_t 
+tmhwDcsNetwork_SecurityCfgGetState(void)
+{
+    return gDcsNetworkSecurity_CfgState;
+}
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_ConfigCfgGetNumUnits
+//
+// DESCRIPTION: Returns total number of units available in DCS NETWORK hardware
+//-----------------------------------------------------------------------------
+UInt32
+tmhwDcsNetwork_ConfigCfgGetNumUnits(void)
+{
+    return (TMHW_DCSNETWORK_CONFIG_CFG_NUM_UNITS);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SecurityCfgGetNumUnits
+//
+// DESCRIPTION: Returns total number of units available in DCS NETWORK hardware
+//-----------------------------------------------------------------------------
+UInt32
+tmhwDcsNetwork_SecurityCfgGetNumUnits(void)
+{
+    return (TMHW_DCSNETWORK_SECURITY_CFG_NUM_UNITS);
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork_Cfg.h linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork_Cfg.h
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork_Cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork_Cfg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,255 @@
+/**********************************************************************
+*
+*	Header %name:	tmhwDcsNetwork_Cfg.h %
+*	Instance:		PB5_1
+*	Description:	
+*	%created_by:	girig %
+*	%date_created:	Wed Nov 26 10:07:32 2008 %
+*
+**********************************************************************/
+#ifndef TMHWDCSNETWORK_CFG_H //-----------------
+#define TMHWDCSNETWORK_CFG_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+#include <tmNxTypes.h>
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*----------------------------------------------------------------------------- 
+Types and defines:
+-----------------------------------------------------------------------------*/
+#if (TMFL_PNX_ID == 5100) 	
+#define TMHW_DCSNETWORK_MAX_UNIT_COUNT      (1)   // Max number of DCS networks in the system TDCSN
+#else	
+#define TMHW_DCSNETWORK_MAX_UNIT_COUNT      (2)   // Max number of DCS networks in the system TDCSN & MDCSN
+#endif	
+#define TMHW_DCSNETWORK_NUMBER_OF_INVALID_INITIATORS (0x0)
+
+#if (TMFL_PNX_ID == 8550) 
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA048
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA059	
+#define  TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID                          0xA047
+#define  TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID                            0xA058	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x0
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x0		
+#define  TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION                            0x0	
+#define  TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION                          0x0	
+	
+#define TMHW_DCSNETWORK_MDCS_A058_LIST	    
+#define TMHW_DCSNETWORK_TDCS_A059_LIST	    
+//#undef  MDCS_A0A0_LIST	  
+//#undef  TDCS_A0A2_LIST	 
+	
+#elif (TMFL_PNX_ID == 8535)
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA0A1
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA0A2	
+#define  TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID                              0xA09F
+#define  TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID                            0xA0A0	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x1
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x1		
+#define  TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION                            0x1	
+#define  TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION                          0x1	
+
+//#undef  MDCS_A058_LIST	    
+//#undef  TDCS_A059_LIST	 
+#define TMHW_DCSNETWORK_MDCS_A0A0_LIST	  
+#define TMHW_DCSNETWORK_TDCS_A0A2_LIST	  
+	
+#elif (TMFL_PNX_ID == 8542)
+		
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA0A1
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA0A2	
+#define  TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID                              0xA09F
+#define  TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID                            0xA0A0	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x1
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x1		
+#define  TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION                            0x1	
+#define  TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION                          0x1	
+
+//#undef  MDCS_A058_LIST	    
+//#undef  TDCS_A059_LIST	 
+#define TMHW_DCSNETWORK_MDCS_A0A0_LIST1	  
+#define TMHW_DCSNETWORK_TDCS_A0A2_LIST1	  	
+
+#elif (TMFL_PNX_ID == 8543)
+		
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA0A1
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA0A2	
+#define  TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID                              0xA09F
+#define  TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID                            0xA0A0	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x3
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x3		
+#define  TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION                            0x3	
+#define  TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION                          0x3	
+
+//#undef  MDCS_A058_LIST	    
+//#undef  TDCS_A059_LIST	 
+#define TMHW_DCSNETWORK_MDCS_A0A0_LIST2	  
+#define TMHW_DCSNETWORK_TDCS_A0A2_LIST2	  
+	
+#elif (TMFL_PNX_ID == 85500)
+		
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA06D
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA06E	
+#define  TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID                              0xA06D
+#define  TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID                            0xA06E	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x3
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x3		
+#define  TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION                            0x3	
+#define  TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION                          0x3	
+
+//#undef  MDCS_A058_LIST	    
+//#undef  TDCS_A059_LIST	 
+#define TMHW_DCSNETWORK_MDCS_A06E_LIST2	  
+#define TMHW_DCSNETWORK_TDCS_A06E_LIST2	  
+
+#elif (TMFL_PNX_ID == 5100)
+#define  TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID                              0xA0A1
+#define  TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID                            0xA0A2	
+
+#define  TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION                            0x1
+#define  TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION                          0x1		
+
+//#undef  MDCS_A058_LIST	    
+//#undef  TDCS_A059_LIST	 
+#define TMHW_DCSNETWORK_TDCS_A0A2_LIST	  	
+	
+#endif
+
+/* Base addresses of DCSNETWORK Module*/
+#if (TMFL_PNX_ID == 8550) 
+#ifndef TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0       (0x1BF03000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0     (0x1BF15000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0       (0x1BE4E000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0     (0x1BE68000)	
+#endif
+	
+#elif ( (TMFL_PNX_ID == 8535) ||  (TMFL_PNX_ID == 8542) || (TMFL_PNX_ID == 8543) || (TMFL_PNX_ID == 85500))
+	
+#ifndef TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0       (0x1BF03000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0     (0x1BF15000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0       (0x1BE4E000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0     (0x1BE68000)	
+#endif
+
+#elif (TMFL_PNX_ID == 5100)
+	
+#ifndef TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TCONFIG_PHY_MMIO_ADDRESS0       (0x1BF03000) //Not known
+#endif
+	
+#ifndef TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_TSECURITY_PHY_MMIO_ADDRESS0     (0x1BF15000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MCONFIG_PHY_MMIO_ADDRESS0       (0x1BE4E000)
+#endif
+	
+#ifndef TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0
+#define TMHW_DCSNETWORK_MSECURITY_PHY_MMIO_ADDRESS0     (0x1BE68000)	
+#endif
+	
+#endif
+
+
+#if (TMFL_PNX_ID == 8550)
+
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (5)     
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (32)    
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (3)     
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (35)    
+
+#elif (TMFL_PNX_ID == 8535)
+
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (6)     
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (30)    
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (6)     
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (22)    
+
+#elif (TMFL_PNX_ID == 8542)
+/* Ref PNX8543_MMIO_Base_Addr_Map.xls & PNX8542_Architecture_specification.pdf */
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (7)    
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (31)   
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (7)    
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (26)   
+
+#elif (TMFL_PNX_ID == 8543)
+/* Ref PNX8543_Architecture_specification.pdf */
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (7)    
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (42)   
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (7)    
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (28)   
+	
+#elif (TMFL_PNX_ID == 85500)
+/* Ref PNX85500_Architecture_specification.pdf */
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (5)    
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (52)   
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (3)    
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (30) 
+	
+#elif (TMFL_PNX_ID == 5100)
+
+#define TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS   (6)    // CHECK THIS VALUE
+#define TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS      (22)   // CHECK THIS VALUE
+#define TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS   (6)    // CHECK THIS VALUE
+#define TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS      (22)   // CHECK THIS VALUE
+	
+#endif
+
+
+
+
+// tmhwDcsNetwork configuration structure	
+typedef struct tmhwDcsNetwork_Cfg
+{
+	UInt32 baseAddress;
+	UInt32 moduleID;
+}tmhwDcsNetwork_Cfg_t, *ptmhwDcsNetwork_Cfg_t;
+
+// tmhwDcsNetwork configuration state structure
+typedef struct tmhwDcsNetwork_CfgState
+{
+	UInt32 intNum;
+}tmhwDcsNetwork_CfgState_t, *ptmhwDcsNetwork_CfgState_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMHWDCSNETWORK_CFG_H //---------------
+
+
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork.h linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork.h
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/inc/tmhwDcsNetwork.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,942 @@
+/* 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ * 
+ * Copyright (C) 2007 NXP B.V. 
+ * All Rights Reserved. 
+ */ 
+//-----------------------------------------------------------------------------
+//
+// FILE NAME:    tmhwDcsNetwork.h
+//
+// DESCRIPTION:  This header file describes definitions, types, and functions
+//               exported by the DCS Network hardware API.   
+//
+// DOCUMENT REF: DVP Software Coding Guidelines specification
+//               DVP Hardware API Interface Specification
+//               DVP Software Versioning Specification
+//               DCS Network and security Design specification
+//
+// NOTES:        None
+//
+//-----------------------------------------------------------------------------
+//
+
+/*
+ * DCS (Device Control and Status) Network is used to access the control and status
+ * registers of various IP's inside pnx1500/pnx8550.   In the DCS network there
+ * are initiators and targets.  Initiators start the register access.   Initiators
+ * are usually the processor cores (like MIPS, TM, etc.)  or external PCI masters
+ * through the PCI/XIO block.  Targets are the IP blocks having control and
+ * status registers.  
+ *
+ * This component can be used enable/disable the access of an initiator to a target.
+ * Also, this component can be used to see whether an initiator access is timed out
+ * or whether an initiator is doing illegal access.
+ * 
+ * Here is the sequence of calls
+ *
+ * 1. tmhwDcsNetwork_GetSWVersion(....)
+ *     
+ *    ....Check whether the compatibility number and major version number is as 
+ *        expected
+ *
+ * 2. tmhwDcsNetwork_GetCapabilities(......)
+ *
+ *    ....Get the capabilities of the particular unit.   Can be used to find out
+ *        the number of initiators and number of targets.
+ *
+ * 3. tmhwDcsNetwork_Init(.....)
+ *
+ *    ....Initialise the required unit
+ *
+ * 4. tmhwDcsNetwork_GetTargetAccessControl(.....)
+ * 
+ *    ....To get the list of initiators that has access to the given target
+ *
+ * 5. tmhwDcsNetwork_SetTargetAccessControl(.....)
+ *
+ *    ....To modify/update the list of initiators having access to the given target.
+ *
+ * 6. Can use tmhwDcsNetwork_IntGetStatus, tmhwDcsNetwork_IntEnable, 
+ *    tmhwDcsNetwork_IntDisable, tmhwDcsNetwork_IntClear functions to enable/disable/
+ *    clear/get status of the interrupts.
+ *
+ * 7. tmhwDcsNetwork_Deinit(....)
+ *
+ *    ....Deinitialise the required unit
+ *
+ */
+ 
+
+#ifndef TMHWDCSNETWORK_H
+#define TMHWDCSNETWORK_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+
+#include <tmFlags.h>
+#include <tmNxTypes.h>                  // DVP standard types/defines
+#include <tmNxCompId.h>                 // DVP Component ID types/defines
+
+#include <tmhwDcsNetwork_Cfg.h>
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+// NOTE: The HWAPI compatibility number, major version number, and minor
+//       version number must be kept current with any HWAPI interface changes.
+//       Changes to the HWAPI interface that are not backwards compatible
+//       result in a compatibility number incremental change.  If interfaces
+//       are changed but remain backwards compatible, the compatibility number
+//       remains the same but the major version number is incremented.
+//       Software that will use the HWAPI can check these version numbers both
+//       at build time (using the C preprocessor) and at runtime by calling
+//       the tmhw<Component>_GetSwVersion function.  Refer to the DVP/Nexperia
+//       Software Versioning Specification for more details.
+//
+
+#define TMHW_DCSNETWORK_COMPATIBILITY_NR       1   // DCSNETWORK HWAPI Compatibility number
+#define TMHW_DCSNETWORK_MAJOR_VERSION_NR       1   // DCSNETWORK HWAPI Major Version number
+#define TMHW_DCSNETWORK_MINOR_VERSION_NR       0   // DCSNETWORK HWAPI Minor Version number
+
+
+//  DCSNETWORK Status/Error Codes
+#define TMHW_ERR_DCSNETWORK_BASE              ( CID_HW_DCSNETWORK )
+#define TMHW_ERR_DCSNETWORK_COMP              ( CID_HW_DCSNETWORK | TM_ERR_COMP_UNIQUE_START )
+
+//
+#define TMHW_ERR_DCSNETWORK_COMPATIBILITY                                    \
+/* !ErrorTag: Component software compatibility error in tmhwDcsNetwork   */  \
+                                    ( TMHW_ERR_DCSNETWORK_BASE +             \
+                                      TM_ERR_COMPATIBILITY )
+
+#define TMHW_ERR_DCSNETWORK_MAJOR_VERSION                                    \
+/* !ErrorTag: Component software major version error in tmhwDcsNetwork    */ \
+                                    ( TMHW_ERR_DCSNETWORK_BASE +             \
+                                      TM_ERR_MAJOR_VERSION )
+                                      
+#define TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM                                     \
+/* !ErrorTag: Invalid hardware module unit number in tmhwDcsNetwork       */ \
+                                    ( TMHW_ERR_DCSNETWORK_BASE +             \
+                                      TM_ERR_BAD_UNIT_NUMBER )
+                                      
+#define TMHW_ERR_DCSNETWORK_BAD_PARAMETER                                    \
+/* !ErrorTag: bad parameter in tmhwDcsNetwork                             */ \
+                                    ( TMHW_ERR_DCSNETWORK_BASE +             \
+                                      TM_ERR_BAD_PARAMETER )
+                                      
+#define TMHW_ERR_DCSNETWORK_NOT_SUPPORTED                                    \
+/* !ErrorTag: not supported error in tmhwDcsNetwork                       */ \
+                                    ( TMHW_ERR_DCSNETWORK_BASE +             \
+                                      TM_ERR_NOT_SUPPORTED )
+
+#define TMHW_ERR_DCSNETWORK_BAD_MODULE_ID                                    \
+/* !ErrorTag: not supported error in tmhwDcsNetwork                       */ \
+                                    ( TMHW_ERR_DCSNETWORK_COMP +             \
+                                      0x0001 )
+                                      
+#define TMHW_ERR_DCSNETWORK_BAD_TARGET                                       \
+/* !ErrorTag: not supported error in tmhwDcsNetwork                       */ \
+                                    ( TMHW_ERR_DCSNETWORK_COMP +             \
+                                      0x0002 )
+
+#define TMHW_ERR_DCSNETWORK_BAD_INITIATOR                                    \
+/* !ErrorTag: not supported error in tmhwDcsNetwork                       */ \
+                                    ( TMHW_ERR_DCSNETWORK_COMP +             \
+                                      0x0003 )
+
+#define TMHW_ERR_DCSNETWORK_NULLORERROR_TARGET             ( TMHW_ERR_DCSNETWORK_COMP +  0x0004 )
+#define TMHW_ERR_DCSNETWORK_CONTROLLER_CONFIG_ERROR        ( TMHW_ERR_DCSNETWORK_COMP +  0x0005 )
+#define TMHW_ERR_DCSNETWORK_CONTROLLER_SECURITY_APERTURE   ( TMHW_ERR_DCSNETWORK_COMP +  0x0006 )				    
+//Selected agents during timeout or error
+#define DCSNETWORK_NULLORERROR_TARGET             64
+#define DCSNETWORK_CONTROLLER_CONFIG_ERROR        65
+#define DCSNETWORK_CONTROLLER_SECURITY_APERTURE   66				    
+                                      
+// List of interrupts possible
+//
+
+#define TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_NONE      0x0
+#define TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_ERROR     0x1
+#define TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_TIMEOUT   0x2
+#define TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_ALL      \
+        (TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_ERROR | \
+         TMHW_DCSNETWORK_TARGET_ACCESS_INTERRUPT_TIMEOUT)
+
+
+
+
+
+
+
+	
+// DCS Network Capabilities structure
+//
+typedef struct    tmhwDcsNetwork_Capabilities
+{
+    UInt32 dcsNetworkUnitCount; // number of dcs networks
+    UInt32 noOfTargets;         // number of targets in the DCS network
+    UInt32 noOfInitiators;      // number of initiators in the DCS network
+} tmhwDcsNetwork_Capabilities_t, *ptmhwDcsNetwork_Capabilities_t;
+
+
+
+
+#if (defined (TMHW_DCSNETWORK_MDCS_A058_LIST) || defined (TMHW_DCSNETWORK_TDCS_A059_LIST))
+// List of Initiators
+//
+typedef enum tmhwDcsNetwork_InitiatorId
+{
+    tmhwDcsNetwork_InitiatorIdDcsNetworkBridge = 0x0,
+    tmhwDcsNetwork_InitiatorIdMips = 1,
+    tmhwDcsNetwork_InitiatorIdPci = 2,
+    tmhwDcsNetwork_InitiatorIdBoot = 3,
+    tmhwDcsNetwork_InitiatorIdEjtag = 4,
+    tmhwDcsNetwork_InitiatorIdTriMedia = 5,
+    tmhwDcsNetwork_InitiatorIdInvalid = 0xFFFF
+    
+} tmhwDcsNetwork_InitiatorId_t, *ptmhwDcsNetwork_InitiatorId_t;
+
+
+
+// List of Targets
+//
+typedef enum tmhwDcsNetwork_TargetId
+{
+    tmhwDcsNetwork_TargetIdDcsNetworkConfigMod = 0x0,
+    tmhwDcsNetwork_TargetIdDcsNetworkSecurityMod,
+    tmhwDcsNetwork_TargetIdDcs2DcsBridge,
+    tmhwDcsNetwork_TargetIdGic,
+    tmhwDcsNetwork_TargetIdPciXio,
+    tmhwDcsNetwork_TargetIdJtagDma,
+    tmhwDcsNetwork_TargetIdSmartCard,
+    tmhwDcsNetwork_TargetIdI2c,
+    tmhwDcsNetwork_TargetIdClocks,
+    tmhwDcsNetwork_TargetIdUsb,
+    tmhwDcsNetwork_TargetIdUart,
+    tmhwDcsNetwork_TargetIdGlobalRegs,
+    tmhwDcsNetwork_TargetIdD2d,
+    tmhwDcsNetwork_TargetIdReset,
+    tmhwDcsNetwork_TargetIdTmDbg,
+    tmhwDcsNetwork_TargetIdPmanArbiter,
+    tmhwDcsNetwork_TargetIdDdrController,
+    tmhwDcsNetwork_TargetIdPmanSecurity,
+    tmhwDcsNetwork_TargetIdPmanMonitor,
+    tmhwDcsNetwork_TargetIdEjtag,
+    tmhwDcsNetwork_TargetIdDmaGate,
+    tmhwDcsNetwork_TargetIdPci,
+    tmhwDcsNetwork_TargetIdXio,
+    tmhwDcsNetwork_TargetIdGpio,
+    tmhwDcsNetwork_TargetIdVmpg,
+    tmhwDcsNetwork_TargetIdVip,
+    tmhwDcsNetwork_TargetIdVld,
+    tmhwDcsNetwork_TargetIdSpdo,
+    tmhwDcsNetwork_TargetIdSpdi,
+    tmhwDcsNetwork_TargetIdDvdd,
+    tmhwDcsNetwork_TargetIdMbs,
+    tmhwDcsNetwork_TargetIdQtnr,
+    tmhwDcsNetwork_TargetIdQvcp,
+    tmhwDcsNetwork_TargetIdAo,
+    tmhwDcsNetwork_TargetIdAi,
+    tmhwDcsNetwork_TargetIdEdma,
+    tmhwDcsNetwork_TargetIdTsdma,
+    tmhwDcsNetwork_TargetIdDenc,
+    tmhwDcsNetwork_TargetIdMsp,
+    tmhwDcsNetwork_TargetIdTm3260,
+    tmhwDcsNetwork_TargetIdVpk,
+    tmhwDcsNetwork_TargetIdTunnel,
+    tmhwDcsNetwork_TargetIdTunnelMmio
+        
+} tmhwDcsNetwork_TargetId_t, *ptmhwDcsNetwork_TargetId_t;
+
+
+
+#elif (defined(TMHW_DCSNETWORK_MDCS_A0A0_LIST) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST))
+// List of Initiators
+//
+typedef enum tmhwDcsNetwork_InitiatorId
+{
+    tmhwDcsNetwork_InitiatorId0 = 0x0,
+    tmhwDcsNetwork_InitiatorId1 = 1,
+    tmhwDcsNetwork_InitiatorId2 = 2,
+    tmhwDcsNetwork_InitiatorId3 = 3,
+    tmhwDcsNetwork_InitiatorId4 = 4,
+    tmhwDcsNetwork_InitiatorId5 = 5,
+    tmhwDcsNetwork_InitiatorIdInvalid = 0xFFFF
+    
+} tmhwDcsNetwork_InitiatorId_t, *ptmhwDcsNetwork_InitiatorId_t;
+
+
+// List of Targets
+//
+typedef enum tmhwDcsNetwork_TargetId
+{
+    tmhwDcsNetwork_TargetId0 = 0x0,
+    tmhwDcsNetwork_TargetId1,
+    tmhwDcsNetwork_TargetId2,
+    tmhwDcsNetwork_TargetId3,
+    tmhwDcsNetwork_TargetId4,
+    tmhwDcsNetwork_TargetId5,
+    tmhwDcsNetwork_TargetId6,
+    tmhwDcsNetwork_TargetId7,
+    tmhwDcsNetwork_TargetId8,
+    tmhwDcsNetwork_TargetId9,
+    tmhwDcsNetwork_TargetId10,
+    tmhwDcsNetwork_TargetId11,
+    tmhwDcsNetwork_TargetId12,
+    tmhwDcsNetwork_TargetId13,
+    tmhwDcsNetwork_TargetId14,
+    tmhwDcsNetwork_TargetId15,
+    tmhwDcsNetwork_TargetId16,
+    tmhwDcsNetwork_TargetId17,
+    tmhwDcsNetwork_TargetId18,
+    tmhwDcsNetwork_TargetId19,
+    tmhwDcsNetwork_TargetId20,
+    tmhwDcsNetwork_TargetId21,
+    tmhwDcsNetwork_TargetId22,
+    tmhwDcsNetwork_TargetId23,
+    tmhwDcsNetwork_TargetId24,
+    tmhwDcsNetwork_TargetId25,
+    tmhwDcsNetwork_TargetId26,
+    tmhwDcsNetwork_TargetId27,
+    tmhwDcsNetwork_TargetId28,
+    tmhwDcsNetwork_TargetId29
+           
+} tmhwDcsNetwork_TargetId_t, *ptmhwDcsNetwork_TargetId_t;
+
+
+#elif (defined(TMHW_DCSNETWORK_MDCS_A0A0_LIST1) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST1))
+// List of Initiators
+//
+typedef enum tmhwDcsNetwork_InitiatorId
+{
+    tmhwDcsNetwork_InitiatorIdMips = 0x0,
+    tmhwDcsNetwork_InitiatorIdPci = 1,
+    tmhwDcsNetwork_InitiatorIdReset = 2,
+    tmhwDcsNetwork_InitiatorIdEjtag = 3,
+    tmhwDcsNetwork_InitiatorIdIICSlave = 4,
+    tmhwDcsNetwork_InitiatorIdTriMedia = 5,
+    tmhwDcsNetwork_InitiatorIdMSVDCPU = 6,
+    tmhwDcsNetwork_InitiatorIdInvalid = 0xFFFF
+    
+} tmhwDcsNetwork_InitiatorId_t, *ptmhwDcsNetwork_InitiatorId_t;
+
+// List of Targets
+//
+typedef enum tmhwDcsNetwork_TargetId
+{
+    tmhwDcsNetwork_TargetId0 = 0x0,
+    tmhwDcsNetwork_TargetId1,
+    tmhwDcsNetwork_TargetId2,
+    tmhwDcsNetwork_TargetId3,
+    tmhwDcsNetwork_TargetId4,
+    tmhwDcsNetwork_TargetId5,
+    tmhwDcsNetwork_TargetId6,
+    tmhwDcsNetwork_TargetId7,
+    tmhwDcsNetwork_TargetId8,
+    tmhwDcsNetwork_TargetId9,
+    tmhwDcsNetwork_TargetId10,
+    tmhwDcsNetwork_TargetId11,
+    tmhwDcsNetwork_TargetId12,
+    tmhwDcsNetwork_TargetId13,
+    tmhwDcsNetwork_TargetId14,
+    tmhwDcsNetwork_TargetId15,
+    tmhwDcsNetwork_TargetId16,
+    tmhwDcsNetwork_TargetId17,
+    tmhwDcsNetwork_TargetId18,
+    tmhwDcsNetwork_TargetId19,
+    tmhwDcsNetwork_TargetId20,
+    tmhwDcsNetwork_TargetId21,
+    tmhwDcsNetwork_TargetId22,
+    tmhwDcsNetwork_TargetId23,
+    tmhwDcsNetwork_TargetId24,
+    tmhwDcsNetwork_TargetId25,
+    tmhwDcsNetwork_TargetId26,
+    tmhwDcsNetwork_TargetId27,
+    tmhwDcsNetwork_TargetId28,
+    tmhwDcsNetwork_TargetId29,
+    tmhwDcsNetwork_TargetId30
+           
+} tmhwDcsNetwork_TargetId_t, *ptmhwDcsNetwork_TargetId_t;
+
+#elif (defined(TMHW_DCSNETWORK_MDCS_A0A0_LIST2) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST2))
+// List of Initiators
+//
+typedef enum tmhwDcsNetwork_InitiatorId
+{
+    tmhwDcsNetwork_InitiatorIdMips = 0x0,
+    tmhwDcsNetwork_InitiatorIdPci = 1,
+    tmhwDcsNetwork_InitiatorIdReset = 2,
+    tmhwDcsNetwork_InitiatorIdEjtag = 3,
+    tmhwDcsNetwork_InitiatorIdIICSlave = 4,
+    tmhwDcsNetwork_InitiatorIdTriMedia = 5,
+    tmhwDcsNetwork_InitiatorIdMSVDCPU = 6,
+    tmhwDcsNetwork_InitiatorIdInvalid = 0xFFFF
+    
+} tmhwDcsNetwork_InitiatorId_t, *ptmhwDcsNetwork_InitiatorId_t;
+
+// List of Targets
+//
+typedef enum tmhwDcsNetwork_TargetId
+{
+    tmhwDcsNetwork_TargetId0 = 0x0,
+    tmhwDcsNetwork_TargetId1,
+    tmhwDcsNetwork_TargetId2,
+    tmhwDcsNetwork_TargetId3,
+    tmhwDcsNetwork_TargetId4,
+    tmhwDcsNetwork_TargetId5,
+    tmhwDcsNetwork_TargetId6,
+    tmhwDcsNetwork_TargetId7,
+    tmhwDcsNetwork_TargetId8,
+    tmhwDcsNetwork_TargetId9,
+    tmhwDcsNetwork_TargetId10,
+    tmhwDcsNetwork_TargetId11,
+    tmhwDcsNetwork_TargetId12,
+    tmhwDcsNetwork_TargetId13,
+    tmhwDcsNetwork_TargetId14,
+    tmhwDcsNetwork_TargetId15,
+    tmhwDcsNetwork_TargetId16,
+    tmhwDcsNetwork_TargetId17,
+    tmhwDcsNetwork_TargetId18,
+    tmhwDcsNetwork_TargetId19,
+    tmhwDcsNetwork_TargetId20,
+    tmhwDcsNetwork_TargetId21,
+    tmhwDcsNetwork_TargetId22,
+    tmhwDcsNetwork_TargetId23,
+    tmhwDcsNetwork_TargetId24,
+    tmhwDcsNetwork_TargetId25,
+    tmhwDcsNetwork_TargetId26,
+    tmhwDcsNetwork_TargetId27,
+    tmhwDcsNetwork_TargetId28,
+    tmhwDcsNetwork_TargetId29,
+    tmhwDcsNetwork_TargetId30,
+    tmhwDcsNetwork_TargetId31,
+    tmhwDcsNetwork_TargetId32,
+    tmhwDcsNetwork_TargetId33,
+    tmhwDcsNetwork_TargetId34,
+    tmhwDcsNetwork_TargetId35,
+    tmhwDcsNetwork_TargetId36,
+    tmhwDcsNetwork_TargetId37,
+    tmhwDcsNetwork_TargetId38,
+    tmhwDcsNetwork_TargetId39,
+    tmhwDcsNetwork_TargetId40,
+    tmhwDcsNetwork_TargetId41
+               
+} tmhwDcsNetwork_TargetId_t, *ptmhwDcsNetwork_TargetId_t;
+
+#elif (defined(TMHW_DCSNETWORK_MDCS_A06E_LIST2) || defined (TMHW_DCSNETWORK_TDCS_A06E_LIST2))
+// List of Initiators
+//
+typedef enum tmhwDcsNetwork_InitiatorId
+{
+    tmhwDcsNetwork_InitiatorIdMips = 0,
+    tmhwDcsNetwork_InitiatorIdPci = 1,
+    tmhwDcsNetwork_InitiatorIdBoot = 2,
+    tmhwDcsNetwork_InitiatorIdEjtag = 3,
+    tmhwDcsNetwork_InitiatorIdI2c1Debug = 4,
+    tmhwDcsNetwork_InitiatorIdUnused = 5,
+    tmhwDcsNetwork_InitiatorIdAvdsp = 6,
+    tmhwDcsNetwork_InitiatorIdNmdsp1 = 7,
+    tmhwDcsNetwork_InitiatorIdNmdsp2 = 8,
+    tmhwDcsNetwork_InitiatorIdInvalid = 0xFFFF
+    
+} tmhwDcsNetwork_InitiatorId_t, *ptmhwDcsNetwork_InitiatorId_t;
+
+// List of Targets
+//
+typedef enum tmhwDcsNetwork_TargetId
+{
+    tmhwDcsNetwork_TargetId0 = 0x0,
+    tmhwDcsNetwork_TargetId1,
+    tmhwDcsNetwork_TargetId2,
+    tmhwDcsNetwork_TargetId3,
+    tmhwDcsNetwork_TargetId4,
+    tmhwDcsNetwork_TargetId5,
+    tmhwDcsNetwork_TargetId6,
+    tmhwDcsNetwork_TargetId7,
+    tmhwDcsNetwork_TargetId8,
+    tmhwDcsNetwork_TargetId9,
+    tmhwDcsNetwork_TargetId10,
+    tmhwDcsNetwork_TargetId11,
+    tmhwDcsNetwork_TargetId12,
+    tmhwDcsNetwork_TargetId13,
+    tmhwDcsNetwork_TargetId14,
+    tmhwDcsNetwork_TargetId15,
+    tmhwDcsNetwork_TargetId16,
+    tmhwDcsNetwork_TargetId17,
+    tmhwDcsNetwork_TargetId18,
+    tmhwDcsNetwork_TargetId19,
+    tmhwDcsNetwork_TargetId20,
+    tmhwDcsNetwork_TargetId21,
+    tmhwDcsNetwork_TargetId22,
+    tmhwDcsNetwork_TargetId23,
+    tmhwDcsNetwork_TargetId24,
+    tmhwDcsNetwork_TargetId25,
+    tmhwDcsNetwork_TargetId26,
+    tmhwDcsNetwork_TargetId27,
+    tmhwDcsNetwork_TargetId28,
+    tmhwDcsNetwork_TargetId29,
+    tmhwDcsNetwork_TargetId30,
+    tmhwDcsNetwork_TargetId31,
+    tmhwDcsNetwork_TargetId32,
+    tmhwDcsNetwork_TargetId33,
+    tmhwDcsNetwork_TargetId34,
+    tmhwDcsNetwork_TargetId35,
+    tmhwDcsNetwork_TargetId36,
+    tmhwDcsNetwork_TargetId37,
+    tmhwDcsNetwork_TargetId38,
+    tmhwDcsNetwork_TargetId39,
+    tmhwDcsNetwork_TargetId40,
+    tmhwDcsNetwork_TargetId41,
+    tmhwDcsNetwork_TargetId42,
+	tmhwDcsNetwork_TargetId43,
+	tmhwDcsNetwork_TargetId44,
+	tmhwDcsNetwork_TargetId45,
+	tmhwDcsNetwork_TargetId46,
+	tmhwDcsNetwork_TargetId47,
+	tmhwDcsNetwork_TargetId48,
+	tmhwDcsNetwork_TargetId49,
+	tmhwDcsNetwork_TargetId50,
+	tmhwDcsNetwork_TargetId51
+           
+} tmhwDcsNetwork_TargetId_t, *ptmhwDcsNetwork_TargetId_t;
+
+#endif
+
+// Structure to represent exact initiator unit
+//
+typedef struct    tmhwDcsNetwork_InitiatorUnit
+{
+    tmhwDcsNetwork_InitiatorId_t   initiatorId;  // Id of the initiator
+    tmUnitSelect_t                 unitNo;       // Unit number of the initiator.
+    
+} tmhwDcsNetwork_InitiatorUnit_t, *ptmhwDcsNetwork_InitiatorUnit_t;
+
+
+
+
+// Structure to represent exact target unit
+//
+typedef struct    tmhwDcsNetwork_TargetUnit
+{
+    tmhwDcsNetwork_TargetId_t   targetId;     // Id of the target.
+    tmUnitSelect_t              unitNo;       // Unit number of the target.
+    
+} tmhwDcsNetwork_TargetUnit_t, *ptmhwDcsNetwork_TargetUnit_t;
+
+
+
+// List of Target access timeout settings possible
+//
+typedef enum tmhwDcsNetwork_TargetAccessTimeout
+{
+    tmhwDcsNetwork_TargetAccessTimeout_7WaitCycles = 0x0,
+    tmhwDcsNetwork_TargetAccessTimeout_15WaitCycles = 0x3,
+    tmhwDcsNetwork_TargetAccessTimeout_31WaitCycles = 0x4,
+    tmhwDcsNetwork_TargetAccessTimeout_63WaitCycles = 0x5,
+    tmhwDcsNetwork_TargetAccessTimeout_127WaitCycles = 0x6,
+    tmhwDcsNetwork_TargetAccessTimeout_255WaitCycles = 0x7,
+    tmhwDcsNetwork_TargetAccessTimeout_511WaitCycles = 0x8,
+    tmhwDcsNetwork_TargetAccessTimeout_1023WaitCycles = 0x9,
+    tmhwDcsNetwork_TargetAccessTimeout_2047WaitCycles = 0xA,
+    tmhwDcsNetwork_TargetAccessTimeout_4095WaitCycles = 0xB,
+    tmhwDcsNetwork_TargetAccessTimeout_8191WaitCycles = 0xC,
+    tmhwDcsNetwork_TargetAccessTimeout_16383WaitCycles = 0xD,
+    tmhwDcsNetwork_TargetAccessTimeout_32767WaitCycles = 0xE,
+    tmhwDcsNetwork_TargetAccessTimeout_65535WaitCycles = 0xF,
+    tmhwDcsNetwork_TargetAccessTimeout_Disabled = 0x10
+        
+} tmhwDcsNetwork_TargetAccessTimeout_t, *ptmhwDcsNetwork_TargetAccessTimeout_t;
+
+
+
+
+
+// Structure for accessing the complete information about the interrupt cause
+//
+typedef struct tmhwDcsNetwork_IntCauseInfo
+{
+    UInt32                          errorOrTimeout;    // Interrupt can be either because of
+                                                       //  error or timeout.
+    UInt32                          byteMask;          // Value of the byte mask when the interrupt
+                                                       //  occurred.  Gives information on which were
+                                                       //  being accessed.
+    UInt32                          address;           // Address which caused error or timeout in
+                                                       //  the dcs network.                                                       
+    Bool                            isRead;            // Is it a read? or Write?
+                                                       //  True : Read
+                                                       //  False : Write
+    tmhwDcsNetwork_TargetUnit_t     target;            // Target that was being addressed    
+    tmhwDcsNetwork_InitiatorUnit_t  initiator;         // Initiator of the transaction
+    
+} tmhwDcsNetwork_IntCauseInfo_t, *ptmhwDcsNetwork_IntCauseInfo_t;
+
+
+#if (defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST1) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST1) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST2) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST2) || defined(TMHW_DCSNETWORK_MDCS_A06E_LIST2) || defined(TMHW_DCSNETWORK_TDCS_A06E_LIST2))   
+// Structure for accessing the complete information about the Feature register
+//
+typedef struct ptmhwDcsNetwork_FeaturesInfo
+{
+    UInt32                          uinqueID;    //This field may be used by software if more than one controller is present with 
+                                                 //the same number of initiators and targets.
+                                                      
+    Bool                            security;      //    Indicates whether the DCS Controller has been compiled with Security features. 
+                                                 //If so then a security aperture exists, and controls access to all targets,
+						 // including the DCS Configuration and DCS Security Apertures.
+						 
+    UInt32                          numBaseRegs;           // Number of Base Registers Defined for the DCS Controller                                                   
+    UInt32                          numOfTargets;            // Number of DCS Targets attached to the DCS Controller
+    
+    UInt32                          numOfInitators;            // Number of DCS Initiators attached to the DCS Controller 
+    
+} tmhwDcsNetwork_FeaturesInfo_t, *ptmhwDcsNetwork_FeaturesInfo_t;
+#endif
+
+typedef struct 
+{
+    tmhwDcsNetwork_TargetId_t    targetId;
+    tmUnitSelect_t               unitNo;
+    UInt32                       offset;
+} targetInfo;
+
+typedef struct
+{
+    tmhwDcsNetwork_InitiatorId_t initiatorId;
+    tmUnitSelect_t               unitNo;
+    UInt32                       initiatorMask;
+} initiatorInfo;
+
+
+//-----------------------------------------------------------------------------
+// External function/data references:
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_Init:
+//
+// DESCRIPTION: - Initialise the DCS network configuration and security feature 
+//                related structures/hardware.
+//              - Obtain the MMIO base address for the given DCS network 
+//              - The device is set to tmPowerOn.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_Init (
+    tmUnitSelect_t    dcsNetworkUnitId           //  I: Unit number of DCS network
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_Deinit:
+//
+// DESCRIPTION: Deinitialize the DCS network configuration and security related 
+//              structures.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_Deinit (
+    tmUnitSelect_t    dcsNetworkUnitId          //  I: Unit number of DCS network
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetSWVersion:
+//
+// DESCRIPTION: Returns SW version of the implementation of this interface
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetSWVersion (
+    ptmSWVersion_t      pVersion    //  O: ptr to structure to obtain version
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetCapabilities:
+//
+// DESCRIPTION: Get the capabilities of the given DCS network unit.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetCapabilities (
+    tmUnitSelect_t                 dcsNetworkUnitId,   //  I: Unit number of DCS network
+    ptmhwDcsNetwork_Capabilities_t pDevCaps            //  O: DCS network capabilities struct 
+                                                       //     ptr
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetPowerState:
+//
+// DESCRIPTION: Sets Current Power state of specified unit ID
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetPowerState (
+    tmUnitSelect_t      dcsNetworkUnitId,  //  I: Unit number of DCS network
+    tmPowerState_t      powerState         //  I: Power state to be set
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetPowerState:
+//
+// DESCRIPTION: Gets Current Power state of specified unit ID
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetPowerState (
+    tmUnitSelect_t       dcsNetworkUnitId,   //  I: Unit number of DCS network
+    ptmPowerState_t      pPowerState         //  O: Power state of the given DCS network
+    );
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetTargetAccessControl:
+//
+// DESCRIPTION: Sets up the access control for the given target.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetTargetAccessControl (
+    tmUnitSelect_t                  dcsNetworkUnitId,    //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetUnit_t     target,              //  I: Target for which the access control
+                                                         //     is being set.                                                 
+    tmhwDcsNetwork_InitiatorUnit_t  allowedInitiators[], //  I: Initiators that needs access to                                                
+                                                         //      to the given target
+    UInt32                          noOfInitiators       //  I: Number of initiators that have access
+                                                         //      to the given target                                                         
+    );
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetTargetAccessControl:
+//
+// DESCRIPTION: Returns the list of initiators that have access to the given target.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetTargetAccessControl (
+    tmUnitSelect_t                  dcsNetworkUnitId,    //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetUnit_t     target,              //  I: Target for which the access control
+                                                         //     is being set.
+    tmhwDcsNetwork_InitiatorUnit_t  allowedInitiators[], //  O: Initiators that needs access to                                                
+                                                         //      to the given target
+    pUInt32                         pNoOfInitiators      //  O: Number of initiators that have access to the
+                                                         //      given target                                                        
+    );
+    
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetTargetAccessTimeout:
+//
+// DESCRIPTION: Sets the target access timeout for any target access in DCS network
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetTargetAccessTimeout (
+    tmUnitSelect_t                        dcsNetworkUnitId,   //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetAccessTimeout_t  accessTimeout       //  I: Target access timeout to be set
+    );
+    
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetTargetAccessTimeout:
+//
+// DESCRIPTION: Gets the current target access timeout
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetTargetAccessTimeout (
+    tmUnitSelect_t                        dcsNetworkUnitId,   //  I: Unit number of DCS network
+    ptmhwDcsNetwork_TargetAccessTimeout_t pAccessTimeout      //  O: Target access timeout to be set
+    );
+
+
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntGetStatus:
+//
+// DESCRIPTION: Returns interrupt status.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntGetStatus (
+    tmUnitSelect_t                dcsNetworkUnitId,  //  I: Unit number of DCS network
+    pUInt32                       pIntStatus         //  O: Interrupt status of the given DCS
+                                                     //     network controller
+    );
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntEnable:
+//
+// DESCRIPTION: Enables the interrupts specified
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntEnable (
+    tmUnitSelect_t                 dcsNetworkUnitId,    //  I: Unit number of DCS network
+    UInt32                         intsToEnable         //  I: List of interrupts to enable
+    );
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntDisable:
+//
+// DESCRIPTION: Disables the interrupts specified
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntDisable (
+    tmUnitSelect_t                 dcsNetworkUnitId,     //  I: Unit number of DCS network
+    UInt32                         intsToDisable         //  I: List of interrupts to disable
+    );
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntClear:
+//
+// DESCRIPTION: Clear the interrupt pending bits specified by the mask.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntClear (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    UInt32                         intsToClear        //  I: List of interrupts to clear
+    );
+
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_GetInterruptInfo:
+//
+// DESCRIPTION: Returns complete information on the interrupt cause than 
+//               tmhwDcsNetwork_IntGetStatus 
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetInterruptInfo (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    ptmhwDcsNetwork_IntCauseInfo_t pIntCauseInfo      //  O: Detailed information on the cause
+                                                      //     of the interrupt.  Buffer for the
+                                                      //     structure has to be allocated by
+                                                      //     the caller.
+    );
+
+#if (defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST1) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST1) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST2) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST2) || defined(TMHW_DCSNETWORK_MDCS_A06E_LIST2) || defined(TMHW_DCSNETWORK_TDCS_A06E_LIST2))   
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_GetFeaturesInfo:
+//
+// DESCRIPTION: Returns complete information of Feature register 
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       This register is present only in pnx8535
+//
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmhwDcsNetwork_GetFeaturesInfo (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    ptmhwDcsNetwork_FeaturesInfo_t pFeatureInfo      //  O: Feature Register information
+    );
+
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMHWDCSNETWORK_H
+
+
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmhwDcsNetwork.c linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmhwDcsNetwork.c
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmhwDcsNetwork.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmhwDcsNetwork.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,3921 @@
+/* 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ * 
+ * Copyright (C) 2007 NXP B.V. 
+ * All Rights Reserved. 
+ * 
+ * *---------------------------------------------------------------------------
+ * %filename:     tmhwDcsNetwork.c %
+ * %pid_version:              PB5#18 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  This file implements the tmhwDcsNetwork interface for pnx8550
+ *
+ * DOCUMENT REF: DVP Software Coding Guidelines specification
+ *               DVP Hardware API Interface Specification
+ *               DVP Software Versioning Specification
+ *               Viper2 RevB specification.
+ */
+ 
+
+
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef BSL_DEPENDENT
+#include <tmbslCore.h>
+#endif
+#include <tmhwDcsNetwork_CfgLocal.h>
+#include <tmhwDcsNetwork.h>
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+#include "tmvhDcsNetworkSecurityModule_reg.h"    // DCS network security registers
+#include "tmvhDcsNetworkConfigModule_reg.h"      // DCS network configuration registers
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+#define TMBSL_MGR_COMPATIBILITY_EXP     (1)   // BSL Mgr Compatibility expected
+#define TMBSL_MGR_MAJOR_VERSION_EXP     (1)   // BSL Mgr Major Version expected
+
+
+
+
+
+
+
+//-----------------------------------------------------------------------------
+// Global data:
+//-----------------------------------------------------------------------------
+//
+
+// It is assumed that there will be only one DCS network config/security module 
+//  in a system with the given module Id.
+#ifdef TMHW_DCSNETWORK_MDCS_A058_LIST
+static initiatorInfo mdcsInitiatorInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdDcsNetworkBridge,
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdMips,
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdPci,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdBoot,
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdEjtag,
+        tmUnit0,
+        0x10
+    }
+    
+};
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2) 
+static targetInfo mdcsTargetInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetIdDcsNetworkConfigMod,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetIdDcsNetworkSecurityMod,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetIdDcs2DcsBridge,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit1,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetIdPciXio,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetIdJtagDma,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetIdSmartCard,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetIdSmartCard,
+        tmUnit1,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetIdI2c,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetIdI2c,
+        tmUnit1,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetIdClocks,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetIdUsb,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetIdUart,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetIdUart,
+        tmUnit1,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetIdI2c,
+        tmUnit3,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetIdGlobalRegs,
+        tmUnit1,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetIdD2d,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetIdReset,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetIdTmDbg,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetIdTmDbg,
+        tmUnit1,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetIdGlobalRegs,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetIdPmanArbiter,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetIdDdrController,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetIdPmanSecurity,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetIdPmanMonitor,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetIdI2c,
+        tmUnit2,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetIdEjtag,
+        tmUnit0,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetIdDmaGate,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetIdPci,
+        tmUnit0,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetIdPci,
+        tmUnit1,
+        0x270
+    },
+    {
+        tmhwDcsNetwork_TargetIdXio,
+        tmUnit0,
+        0x274
+    }
+};
+#endif
+#endif
+
+#ifdef TMHW_DCSNETWORK_TDCS_A059_LIST
+
+static initiatorInfo tdcsInitiatorInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdDcsNetworkBridge,
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia,
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia,
+        tmUnit1,
+        0x4
+    }
+};
+
+static targetInfo tdcsTargetInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetIdDcsNetworkConfigMod,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetIdDcsNetworkSecurityMod,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetIdDcs2DcsBridge,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetIdGpio,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetIdVmpg,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetIdVip,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetIdVip,
+        tmUnit1,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetIdVld,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetIdSpdo,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetIdSpdi,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetIdDvdd,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetIdMbs,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetIdQtnr,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetIdQvcp,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetIdQvcp,
+        tmUnit1,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetIdAo,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetIdAi,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetIdAo,
+        tmUnit1,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetIdAi,
+        tmUnit1,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetIdEdma,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetIdTsdma,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetIdDenc,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetIdMsp,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetIdMsp,
+        tmUnit1,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetIdTm3260,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetIdTm3260,
+        tmUnit1,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit1,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit2,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetIdGic,
+        tmUnit3,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetIdVpk,
+        tmUnit0,
+        0x270
+    },
+    {
+        tmhwDcsNetwork_TargetIdMbs,
+        tmUnit1,
+        0x274
+    },
+    {
+        tmhwDcsNetwork_TargetIdSpdi,
+        tmUnit1,
+        0x278
+    },
+    {
+        tmhwDcsNetwork_TargetIdTunnelMmio,
+        tmUnit0,
+        0x27C
+    },
+    {
+        tmhwDcsNetwork_TargetIdTunnel,
+        tmUnit0,
+        0x280
+    }    
+};
+
+#endif
+
+#ifdef TMHW_DCSNETWORK_MDCS_A0A0_LIST
+
+static initiatorInfo mdcsInitiatorInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorId0,
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorId1,
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorId2,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorId3,
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorId4,
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorId5,
+        tmUnit0,
+        0x20
+    }
+
+};
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)
+static targetInfo mdcsTargetInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetId28,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetId29,
+        tmUnit0,
+        0x26C
+    }   
+};
+#endif
+#endif
+
+#ifdef TMHW_DCSNETWORK_TDCS_A0A2_LIST
+static initiatorInfo tdcsInitiatorInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorId0,
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorId1,
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorId2,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorId3,
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorId4,
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorId5,
+        tmUnit0,
+        0x20
+    }
+
+};
+
+static targetInfo tdcsTargetInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    }    
+};
+
+#endif	
+
+#ifdef TMHW_DCSNETWORK_TDCS_A0A2_LIST1
+static initiatorInfo tdcsInitiatorInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdMips, //MIPS
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdPci, //PCI
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdReset, //Reset
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdEjtag, //EJTAG
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdIICSlave, //I2C_SLAVE
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia, //AVDSP
+        tmUnit0,
+        0x20
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdMSVDCPU, //MSVD
+        tmUnit0,
+        0x40
+    }
+};
+
+static targetInfo tdcsTargetInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x25C
+    }        
+};
+
+#endif	
+
+
+
+#ifdef TMHW_DCSNETWORK_MDCS_A0A0_LIST1
+
+static initiatorInfo mdcsInitiatorInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS ] = {
+   {
+        tmhwDcsNetwork_InitiatorIdMips, //MIPS
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdPci, //PCI
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdReset, //Reset
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdEjtag, //EJTAG
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdIICSlave, //I2C_SLAVE
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia, //AVDSP
+        tmUnit0,
+        0x20
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdMSVDCPU, //MSVD
+        tmUnit0,
+        0x40
+    }
+};
+
+static targetInfo mdcsTargetInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7, //IIC3
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8, //IIC3
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetId28,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetId29,
+        tmUnit0,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetId30,
+        tmUnit0,
+        0x270
+    }
+};
+
+#endif
+
+#ifdef TMHW_DCSNETWORK_TDCS_A0A2_LIST2
+static initiatorInfo tdcsInitiatorInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdMips, //MIPS
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdPci, //PCI
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdReset, //Reset
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdEjtag, //EJTAG
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdIICSlave, //I2C_SLAVE
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia, //AVDSP
+        tmUnit0,
+        0x20
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdMSVDCPU, //MSVD
+        tmUnit0,
+        0x40
+    }
+};
+
+static targetInfo tdcsTargetInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x00
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x04
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x25C
+    },
+   {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x264
+    }            
+};
+
+#endif	
+
+
+
+#ifdef TMHW_DCSNETWORK_MDCS_A0A0_LIST2
+
+static initiatorInfo mdcsInitiatorInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdMips, //MIPS
+        tmUnit0,
+        0x1
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdPci, //PCI
+        tmUnit0,
+        0x2
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdReset, //Reset
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdEjtag, //EJTAG
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdIICSlave, //I2C_SLAVE
+        tmUnit0,
+        0x10
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdTriMedia, //AVDSP
+        tmUnit0,
+        0x20
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdMSVDCPU, //MSVD
+        tmUnit0,
+        0x40
+    }
+};
+
+static targetInfo mdcsTargetInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x0
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x4
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId7, 
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId8, 
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetId28,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetId29,
+        tmUnit0,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetId30,
+        tmUnit0,
+        0x270
+    },
+    {
+        tmhwDcsNetwork_TargetId31,
+        tmUnit0,
+        0x274
+    },
+    {
+        tmhwDcsNetwork_TargetId32,
+        tmUnit0,
+        0x278
+    },
+    {
+        tmhwDcsNetwork_TargetId33,
+        tmUnit0,
+        0x27C
+    },
+    {
+        tmhwDcsNetwork_TargetId34,
+        tmUnit0,
+        0x280
+    },
+    {
+        tmhwDcsNetwork_TargetId35,
+        tmUnit0,
+        0x284
+    },
+    {
+        tmhwDcsNetwork_TargetId36,
+        tmUnit0,
+        0x288
+    },
+    {
+        tmhwDcsNetwork_TargetId37,
+        tmUnit0,
+        0x28C
+    },
+    {
+        tmhwDcsNetwork_TargetId38,
+        tmUnit0,
+        0x290
+    },
+    {
+        tmhwDcsNetwork_TargetId39,
+        tmUnit0,
+        0x294
+    },
+    {
+        tmhwDcsNetwork_TargetId40,
+        tmUnit0,
+        0x298
+    },    
+    {
+        tmhwDcsNetwork_TargetId41,
+        tmUnit0,
+        0x29C
+    }
+};
+
+#endif
+
+#ifdef TMHW_DCSNETWORK_TDCS_A06E_LIST2
+static initiatorInfo tdcsInitiatorInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdAvdsp, //TM32CONFIG1
+        tmUnit0,
+        0x40
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdNmdsp1, //TM3282
+        tmUnit0,
+        0x80
+    },
+ 	{
+        tmhwDcsNetwork_InitiatorIdNmdsp2, //TM3282
+        tmUnit1,
+        0x100
+    }
+};
+
+static targetInfo tdcsTargetInfo[ TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId7,
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId8,
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x264
+    },
+   {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetId28,
+        tmUnit0,
+        0x270
+    },
+    {
+        tmhwDcsNetwork_TargetId29,
+        tmUnit0,
+        0x274
+    }            
+};
+
+#endif	
+
+
+
+#ifdef TMHW_DCSNETWORK_MDCS_A06E_LIST2
+
+static initiatorInfo mdcsInitiatorInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS ] = {
+    {
+        tmhwDcsNetwork_InitiatorIdMips,
+        tmUnit0,
+        0x1
+    },
+    {
+    	tmhwDcsNetwork_InitiatorIdPci,
+    	tmUnit0,
+        0x2
+    },
+    {
+       	tmhwDcsNetwork_InitiatorIdBoot,
+        tmUnit0,
+        0x4
+    },
+    {
+       	tmhwDcsNetwork_InitiatorIdEjtag,
+        tmUnit0,
+        0x8
+    },
+    {
+        tmhwDcsNetwork_InitiatorIdI2c1Debug,
+        tmUnit0,
+        0x10
+    },
+};
+
+static targetInfo mdcsTargetInfo[ TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS ] = {
+    {
+        tmhwDcsNetwork_TargetId0,
+        tmUnit0,
+        0x200
+    },
+    {
+        tmhwDcsNetwork_TargetId1,
+        tmUnit0,
+        0x204
+    },
+    {
+        tmhwDcsNetwork_TargetId2,
+        tmUnit0,
+        0x208
+    },
+    {
+        tmhwDcsNetwork_TargetId3,
+        tmUnit0,
+        0x20C
+    },
+    {
+        tmhwDcsNetwork_TargetId4,
+        tmUnit0,
+        0x210
+    },
+    {
+        tmhwDcsNetwork_TargetId5,
+        tmUnit0,
+        0x214
+    },
+    {
+        tmhwDcsNetwork_TargetId6,
+        tmUnit0,
+        0x218
+    },
+    {
+        tmhwDcsNetwork_TargetId7, //IIC3
+        tmUnit0,
+        0x21C
+    },
+    {
+        tmhwDcsNetwork_TargetId8, //IIC3
+        tmUnit0,
+        0x220
+    },
+    {
+        tmhwDcsNetwork_TargetId9,
+        tmUnit0,
+        0x224
+    },
+    {
+        tmhwDcsNetwork_TargetId10,
+        tmUnit0,
+        0x228
+    },
+    {
+        tmhwDcsNetwork_TargetId11,
+        tmUnit0,
+        0x22C
+    },
+    {
+        tmhwDcsNetwork_TargetId12,
+        tmUnit0,
+        0x230
+    },
+    {
+        tmhwDcsNetwork_TargetId13,
+        tmUnit0,
+        0x234
+    },
+    {
+        tmhwDcsNetwork_TargetId14,
+        tmUnit0,
+        0x238
+    },
+    {
+        tmhwDcsNetwork_TargetId15,
+        tmUnit0,
+        0x23C
+    },
+    {
+        tmhwDcsNetwork_TargetId16,
+        tmUnit0,
+        0x240
+    },
+    {
+        tmhwDcsNetwork_TargetId17,
+        tmUnit0,
+        0x244
+    },
+    {
+        tmhwDcsNetwork_TargetId18,
+        tmUnit0,
+        0x248
+    },
+    {
+        tmhwDcsNetwork_TargetId19,
+        tmUnit0,
+        0x24C
+    },
+    {
+        tmhwDcsNetwork_TargetId20,
+        tmUnit0,
+        0x250
+    },
+    {
+        tmhwDcsNetwork_TargetId21,
+        tmUnit0,
+        0x254
+    },
+    {
+        tmhwDcsNetwork_TargetId22,
+        tmUnit0,
+        0x258
+    },
+    {
+        tmhwDcsNetwork_TargetId23,
+        tmUnit0,
+        0x25C
+    },
+    {
+        tmhwDcsNetwork_TargetId24,
+        tmUnit0,
+        0x260
+    },
+    {
+        tmhwDcsNetwork_TargetId25,
+        tmUnit0,
+        0x264
+    },
+    {
+        tmhwDcsNetwork_TargetId26,
+        tmUnit0,
+        0x268
+    },
+    {
+        tmhwDcsNetwork_TargetId27,
+        tmUnit0,
+        0x26C
+    },
+    {
+        tmhwDcsNetwork_TargetId28,
+        tmUnit0,
+        0x270
+    },
+    {
+        tmhwDcsNetwork_TargetId29,
+        tmUnit0,
+        0x274
+    },
+    {
+        tmhwDcsNetwork_TargetId30,
+        tmUnit0,
+        0x278
+    },
+    {
+        tmhwDcsNetwork_TargetId31,
+        tmUnit0,
+        0x27C
+    },
+    {
+        tmhwDcsNetwork_TargetId32,
+        tmUnit0,
+        0x280
+    },
+    {
+        tmhwDcsNetwork_TargetId33,
+        tmUnit0,
+        0x284
+    },
+    {
+        tmhwDcsNetwork_TargetId34,
+        tmUnit0,
+        0x288
+    },
+    {
+        tmhwDcsNetwork_TargetId35,
+        tmUnit0,
+        0x28C
+    },
+    {
+        tmhwDcsNetwork_TargetId36,
+        tmUnit0,
+        0x290
+    },
+    {
+        tmhwDcsNetwork_TargetId37,
+        tmUnit0,
+        0x294
+    },    
+    {
+        tmhwDcsNetwork_TargetId38,
+        tmUnit0,
+        0x298
+    },
+    {
+        tmhwDcsNetwork_TargetId39,
+        tmUnit0,
+        0x29C
+    },
+    {
+        tmhwDcsNetwork_TargetId40,
+        tmUnit0,
+        0x2A0
+    },
+    {
+        tmhwDcsNetwork_TargetId41,
+        tmUnit0,
+        0x2A4
+    },
+    {
+        tmhwDcsNetwork_TargetId42,
+        tmUnit0,
+        0x2A8
+    },
+    {
+        tmhwDcsNetwork_TargetId43,
+        tmUnit0,
+        0x2AC
+    },
+    {
+        tmhwDcsNetwork_TargetId44,
+        tmUnit0,
+        0x2B0
+    },
+    {
+        tmhwDcsNetwork_TargetId45,
+        tmUnit0,
+        0x2B4
+    },
+    {
+        tmhwDcsNetwork_TargetId46,
+        tmUnit0,
+        0x2B8
+    },
+    {
+        tmhwDcsNetwork_TargetId47,
+        tmUnit0,
+        0x2BC
+    },
+    {
+        tmhwDcsNetwork_TargetId48,
+        tmUnit0,
+        0x2C0
+    },
+    {
+        tmhwDcsNetwork_TargetId49,
+        tmUnit0,
+        0x2C4
+    },
+    {
+        tmhwDcsNetwork_TargetId50,
+        tmUnit0,
+        0x2C8
+    },
+    {
+        tmhwDcsNetwork_TargetId51,
+        tmUnit0,
+        0x2CC
+    }
+};
+
+#endif
+
+static const  UInt32 gModIdsOfDcsNwSecurityModules[]    = { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	
+	TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID, 
+#endif	
+	TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID };
+
+
+
+static UInt32 gDcsNwConfigRegs  [ TMHW_DCSNETWORK_MAX_UNIT_COUNT ] = 
+                                         { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)						 
+					 0, 
+#endif					 
+					 0 };
+                                         
+static UInt32 gDcsNwSecurityRegs [ TMHW_DCSNETWORK_MAX_UNIT_COUNT ] =
+                                         { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)						 
+					 0, 
+#endif					 
+					 0 };
+
+
+static UInt32                        gDcsNetworkUnitCount;
+static Bool                          gIsInitialised = False;
+
+//-----------------------------------------------------------------------------
+// Internal Prototypes:
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+DcsNetworkCapabilitiesInit (
+    void
+    );
+    
+static UInt32
+DcsNetWorkUnitNumberToIndex(
+    tmUnitSelect_t unitNo
+    );
+    
+/* In PNX85500, the TDCS & MDCS have same module IDs. Hence it is not possible to identify
+   by using module IDs. These will be identified by unit IDs
+*/     
+#if (TMFL_PNX_ID==85500)    
+
+static tmErrorCode_t
+DcsNetworkConvertTarget2TargetIdAndUnit(
+    UInt32                     target,
+    ptmhwDcsNetwork_TargetId_t pTargetId,
+    ptmUnitSelect_t            pUnitNo,
+    tmUnitSelect_t             dcsNetworkUnitId
+);        
+
+
+static tmErrorCode_t
+DcsNetworkConvertInitiator2InitiatorIdAndUnit(
+    UInt32                        initiatorMask,
+    ptmhwDcsNetwork_InitiatorId_t pInitiatorId,
+    ptmUnitSelect_t               pUnitNo,
+	tmUnitSelect_t                 dcsNetworkUnitId
+);        
+
+static tmErrorCode_t
+DcsNetworkConvertTargetIdAndUnit2Target(
+    tmhwDcsNetwork_TargetId_t targetId,
+    tmUnitSelect_t            unitNo,
+	tmUnitSelect_t            dcsNetworkUnitId,
+    pUInt32                   pTarget,
+    pUInt32                   pMmioOffset
+);        
+
+
+static tmErrorCode_t
+DcsNetworkConvertInitiatorIdAndUnit2Initiator(
+    tmhwDcsNetwork_InitiatorId_t initiatorId,
+    tmUnitSelect_t               unitNo,
+	tmUnitSelect_t               dcsNetworkUnitId,
+    pUInt32                      pInitiatorMask
+);
+
+#else
+
+static tmErrorCode_t
+DcsNetworkConvertTarget2TargetIdAndUnit(
+    UInt32                     target,
+    ptmhwDcsNetwork_TargetId_t pTargetId,
+    ptmUnitSelect_t            pUnitNo,
+    UInt32                     moduleId
+);        
+
+
+static tmErrorCode_t
+DcsNetworkConvertInitiator2InitiatorIdAndUnit(
+    UInt32                        initiatorMask,
+    ptmhwDcsNetwork_InitiatorId_t pInitiatorId,
+    ptmUnitSelect_t               pUnitNo,
+    UInt32                        moduleId
+);        
+
+static tmErrorCode_t
+DcsNetworkConvertTargetIdAndUnit2Target(
+    tmhwDcsNetwork_TargetId_t targetId,
+    tmUnitSelect_t            unitNo,
+    UInt32                    moduleId,
+    pUInt32                   pTarget,
+    pUInt32                   pMmioOffset
+);        
+
+
+static tmErrorCode_t
+DcsNetworkConvertInitiatorIdAndUnit2Initiator(
+    tmhwDcsNetwork_InitiatorId_t initiatorId,
+    tmUnitSelect_t               unitNo,
+    UInt32                       moduleId,
+    pUInt32                      pInitiatorMask
+);        
+
+#endif        
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetCapabilities:
+//
+// DESCRIPTION: Get the capabilities of the given DCS network unit.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetCapabilities (
+    tmUnitSelect_t                 dcsNetworkUnitId, //  I: Unit number of DCS network
+    ptmhwDcsNetwork_Capabilities_t pDevCaps          //  O: Pointer to structure to receive
+                                                     //     capabilities structure.
+    )
+{
+    tmErrorCode_t   status = TM_OK;
+
+    if( 0 == gDcsNetworkUnitCount )         
+    {
+        status = DcsNetworkCapabilitiesInit ();
+    }
+
+    if( status == TM_OK )
+    {
+        if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+        {
+        
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+        	
+        	switch(dcsNetworkUnitId)
+            {
+                case tmUnit0: 
+                		pDevCaps->noOfInitiators = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS - TMHW_DCSNETWORK_NUMBER_OF_INVALID_INITIATORS;
+                        pDevCaps->noOfTargets = TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS;
+                        pDevCaps->dcsNetworkUnitCount = gDcsNetworkUnitCount;
+                        break;
+
+                case tmUnit1: 
+                		pDevCaps->noOfInitiators = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS - TMHW_DCSNETWORK_NUMBER_OF_INVALID_INITIATORS;
+                        pDevCaps->noOfTargets = TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS;
+                        pDevCaps->dcsNetworkUnitCount = gDcsNetworkUnitCount;
+                        break;
+                            
+                default : 
+                		status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+                        break;
+            }
+        
+#else        
+            UInt32 index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+
+	    switch( gModIdsOfDcsNwSecurityModules[ index ] )
+            {
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)			    
+                case TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID : 
+                										pDevCaps->noOfInitiators = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS - TMHW_DCSNETWORK_NUMBER_OF_INVALID_INITIATORS;
+                                                        pDevCaps->noOfTargets = TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS;
+                                                        pDevCaps->dcsNetworkUnitCount = gDcsNetworkUnitCount;
+                                                        break;
+#endif                
+                case TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID : 
+                									pDevCaps->noOfInitiators = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS - TMHW_DCSNETWORK_NUMBER_OF_INVALID_INITIATORS;
+                             		                pDevCaps->noOfTargets = TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS;
+                                                        pDevCaps->dcsNetworkUnitCount = gDcsNetworkUnitCount;
+                                                        break;
+                            
+                default : status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+                          break;
+            }
+#endif            
+          
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+        }
+    }
+
+    return( status );
+
+} 
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_Init:
+//
+// DESCRIPTION: - Initialise the DCS network configuration and security feature 
+//                related structures/hardware.
+//              - Obtain the MMIO base address for the given DCS network 
+//              - The device is set to tmPowerOn.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_Init (
+    tmUnitSelect_t  dcsNetworkUnitId           //  I: Unit number of DCS network
+    )
+{    
+    UInt32 index = 0;
+    tmErrorCode_t status = TM_OK;
+    if( False == gIsInitialised )
+    {
+        if( 0 == gDcsNetworkUnitCount )
+        {
+            status = DcsNetworkCapabilitiesInit ();
+        }
+    
+        if( status == TM_OK )
+        {
+            if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+            {
+                index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+		    // Disable interrupts
+       		    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_ENABLE_OFFSET), 0x3);	
+        
+	               // Clear interrupts
+		    TMVH_GEN_WRITE((gDcsNwSecurityRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_OFFSET), 0x3);	
+        
+	            // Disable timeout
+		    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), 0x1);	    
+		    
+              }
+            else
+            {
+                status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+            }
+        }
+            
+        gIsInitialised = True;
+    }
+    return( status );
+
+} // tmhwDcsNetwork_Init()
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_Deinit:
+//
+// DESCRIPTION: Deinitialize the DCS network configuration and security related 
+//              structures.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_Deinit (
+    tmUnitSelect_t    dcsNetworkUnitId          //  I: Unit number of DCS network
+    )
+{
+    tmErrorCode_t status = TM_OK;
+    UInt32        index = 0;
+    if( True == gIsInitialised )
+    {
+        if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+        {
+            index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+        
+            // Disable interrupts
+       	    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_ENABLE_OFFSET), 0x3);	
+        
+            // Clear interrupts
+	    TMVH_GEN_WRITE((gDcsNwSecurityRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_OFFSET), 0x3);	
+        
+            // Disable timeout
+	    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), 0x1);	            
+
+	   
+            gDcsNwConfigRegs[ index ] = 0;
+            gDcsNwSecurityRegs[ index ] = 0;
+            
+            gIsInitialised = False;
+	    gDcsNetworkUnitCount = 0;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+        }
+    }
+    
+    return( status );    
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetSWVersion:
+//
+// DESCRIPTION: Returns SW version of the implementation of this interface
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetSWVersion (
+    ptmSWVersion_t      pVersion    //  O: ptr to structure to obtain version
+    )
+{
+    tmErrorCode_t   status = TM_OK;
+    
+    if( 0 == gDcsNetworkUnitCount )
+    {
+        status = DcsNetworkCapabilitiesInit ();
+    }
+    
+    if( TM_OK == status )
+    {
+        if( Null == pVersion )
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+        }
+        else
+        {
+            pVersion->compatibilityNr = TMHW_DCSNETWORK_COMPATIBILITY_NR;
+            pVersion->majorVersionNr  = TMHW_DCSNETWORK_MAJOR_VERSION_NR;
+            pVersion->minorVersionNr  = TMHW_DCSNETWORK_MINOR_VERSION_NR;
+        }
+        
+    }
+    
+    return( status );
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetPowerState:
+//
+// DESCRIPTION: Sets Current Power state of specified unit ID
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetPowerState (
+    tmUnitSelect_t      dcsNetworkUnitId,  //  I: Unit number of DCS network
+    tmPowerState_t      powerState         //  I: Power state to be set
+    )
+{
+#if (TMFL_PNX_ID==85500)
+	UInt32          index= 0;
+	UInt32          ctrl = 0x0; 
+	tmErrorCode_t   status = TM_OK;
+	
+	if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+		index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+	
+		TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+		ctrl &= ~(TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_MSK);
+		ctrl |= (UInt32)(( (powerState  & TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_MSK) << TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_POS));
+		TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+   	}
+	else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    } 
+	return status;
+#else
+    (void) dcsNetworkUnitId;
+    (void) powerState;
+    
+    return( TMHW_ERR_DCSNETWORK_NOT_SUPPORTED );
+#endif    
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetPowerState:
+//
+// DESCRIPTION: Gets Current Power state of specified unit ID
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetPowerState (
+    tmUnitSelect_t       dcsNetworkUnitId,   //  I: Unit number of DCS network
+    ptmPowerState_t      pPowerState         //  O: Power state of the given DCS network
+    )
+{
+	
+#if (TMFL_PNX_ID==85500)
+	UInt32          index= 0;
+	UInt32          ctrl = 0x0; 
+	tmErrorCode_t   status = TM_OK;
+	
+	if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+		index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+		
+		TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+		*pPowerState = (tmPowerState_t) (ctrl & TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_MSK) >> TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_POS;
+	}
+	else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    } 
+	return status;
+#else
+    (void) dcsNetworkUnitId;
+    (void) pPowerState;
+
+    return( TMHW_ERR_DCSNETWORK_NOT_SUPPORTED );
+#endif    
+}
+
+                        
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetTargetAccessControl:
+//
+// DESCRIPTION: Sets up the access control for the given target.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetTargetAccessControl (
+    tmUnitSelect_t                  dcsNetworkUnitId,    //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetUnit_t     target,              //  I: Target for which the access control
+                                                         //     is being set.                                                 
+    tmhwDcsNetwork_InitiatorUnit_t  allowedInitiators[], //  I: Initiators that needs access to                                                
+                                                         //      to the given target
+    UInt32                          noOfInitiators       //  I: Number of initiators that have access
+                                                         //      to the given target                                                         
+    )
+{
+    tmErrorCode_t   status = TM_OK;
+    UInt32          index= 0;
+    UInt32          tmpTargetNo = 0;
+    UInt32          tmpMmioOffset = 0x0;
+    UInt32          tmpInitiatorMask= 0x0;
+    UInt32          allowedInitiatorsMask = 0x0;
+    
+    
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+
+	 	status = DcsNetworkConvertTargetIdAndUnit2Target( target.targetId,
+                                                          target.unitNo,
+                                                          dcsNetworkUnitId,
+                                                          &tmpTargetNo,
+                                                          &tmpMmioOffset
+                                                        );
+
+
+#else
+
+        status = DcsNetworkConvertTargetIdAndUnit2Target( target.targetId,
+                                                          target.unitNo,
+                                                          gModIdsOfDcsNwSecurityModules[ index ],
+                                                          &tmpTargetNo,
+                                                          &tmpMmioOffset
+                                                        );                                                       
+#endif                                                       
+        if( TM_OK == status )
+        {
+            UInt32 loopIndex;
+            
+            for( loopIndex = 0; loopIndex < noOfInitiators; loopIndex++ )
+            {
+            
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same            
+
+		        status = DcsNetworkConvertInitiatorIdAndUnit2Initiator( allowedInitiators[ loopIndex ].initiatorId,
+                                                                        allowedInitiators[ loopIndex ].unitNo,
+                                                                        dcsNetworkUnitId,
+                                                                        &tmpInitiatorMask
+                                                                      );
+
+#else
+
+                status = DcsNetworkConvertInitiatorIdAndUnit2Initiator( allowedInitiators[ loopIndex ].initiatorId,
+                                                                        allowedInitiators[ loopIndex ].unitNo,
+                                                                        gModIdsOfDcsNwSecurityModules[ index ],
+                                                                        &tmpInitiatorMask
+                                                                      );
+#endif                                                                      
+                                                                      
+                if( TM_OK == status )
+                {
+                    allowedInitiatorsMask = allowedInitiatorsMask | tmpInitiatorMask;
+                }
+                else
+                {
+                    break;
+                }
+            }
+        }
+        
+        if( TM_OK == status )
+        {
+            // Write the initiator mask for that target
+	    TMVH_GEN_WRITE((gDcsNwSecurityRegs[ index ] + TMVH_DCSNETWORKSECUIRITY_TARGET_ACCESS_CNTRL_OFFSET + tmpMmioOffset), allowedInitiatorsMask);	   
+
+        }
+            
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }  
+    return( status );
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetTargetAccessControl:
+//
+// DESCRIPTION: Returns the list of initiators that have access to the given target.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetTargetAccessControl (
+    tmUnitSelect_t                  dcsNetworkUnitId,    //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetUnit_t     target,              //  I: Target for which the access control
+                                                         //     is being set.
+    tmhwDcsNetwork_InitiatorUnit_t  allowedInitiators[], //  O: Initiators that needs access to                                                
+                                                         //      to the given target
+    pUInt32                         pNoOfInitiators      //  O: Number of initiators that have access to the
+                                                         //      given target                                                        
+    )
+{
+    tmErrorCode_t   status = TM_OK;
+    UInt32          index = 0x0;
+    UInt32          tmpTargetNo = 0;
+    UInt32          tmpMmioOffset = 0x0;
+    UInt32          actualAllowedInitiators = 0x0;
+    UInt32          tmpNoOfInitiators = 0x0;
+    
+    
+    if( pNoOfInitiators  == Null )
+    {
+	status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+    }
+   else
+   {	   
+		
+        *pNoOfInitiators = 0x0;
+	
+        if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+        {
+            index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+
+	        status = DcsNetworkConvertTargetIdAndUnit2Target( target.targetId,
+                                                              target.unitNo,
+                                                              dcsNetworkUnitId,
+                                                              &tmpTargetNo,
+                                                              &tmpMmioOffset
+                                                            );
+
+#else
+
+            status = DcsNetworkConvertTargetIdAndUnit2Target( target.targetId,
+                                                              target.unitNo,
+                                                              gModIdsOfDcsNwSecurityModules[ index ],
+                                                              &tmpTargetNo,
+                                                              &tmpMmioOffset
+                                                            );
+#endif
+                                                            
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+        }
+                                                   
+    if( TM_OK == status )
+    {        
+    
+      	TMVH_GEN_READ ((gDcsNwSecurityRegs[ index ] + TMVH_DCSNETWORKSECUIRITY_TARGET_ACCESS_CNTRL_OFFSET + tmpMmioOffset  ), actualAllowedInitiators);	            
+      	
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)		
+        if( dcsNetworkUnitId == tmUnit0)
+        {
+            tmpNoOfInitiators = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+        }
+        else 
+#endif		
+		if( dcsNetworkUnitId == tmUnit1 )
+        {
+            tmpNoOfInitiators = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+        }
+
+#else
+      		            
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)		
+        if( TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID == gModIdsOfDcsNwSecurityModules[ index ] )
+        {
+            tmpNoOfInitiators = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+        }
+        else 
+#endif		
+	if( TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID == gModIdsOfDcsNwSecurityModules[ index ] )
+        {
+            tmpNoOfInitiators = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+        }
+#endif        
+
+    }
+    
+    if( TM_OK == status )
+    {
+        UInt32 loopIndex;
+        UInt32 tmpInitiatorMask = 0x1;
+        tmhwDcsNetwork_InitiatorId_t  tmpInitiatorId;
+        tmUnitSelect_t                tmpUnitNo;
+     
+        for( loopIndex = 0; loopIndex < tmpNoOfInitiators; loopIndex++ )
+        {
+            if( (actualAllowedInitiators & tmpInitiatorMask ) != 0)
+            {
+            
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same            
+			    status = DcsNetworkConvertInitiator2InitiatorIdAndUnit( tmpInitiatorMask,
+            		                                                    &tmpInitiatorId,
+                                                                        &tmpUnitNo,
+                                                                        dcsNetworkUnitId
+                                                                      );
+
+#else
+
+                status = DcsNetworkConvertInitiator2InitiatorIdAndUnit( tmpInitiatorMask,
+                                                                        &tmpInitiatorId,
+                                                                        &tmpUnitNo,
+                                                                        gModIdsOfDcsNwSecurityModules[ index ]
+                                                                      );
+#endif
+                                                                                      
+                if( TM_OK == status )
+                {
+/*                    if( tmpInitiatorId == tmhwDcsNetwork_InitiatorIdInvalid )
+                    {
+                        tmpInitiatorMask = tmpInitiatorMask << 1;
+                        
+                        continue;
+                    }
+                    
+                    allowedInitiators[*pNoOfInitiators].initiatorId = tmpInitiatorId;
+                    allowedInitiators[(*pNoOfInitiators)++].unitNo  = tmpUnitNo;
+*/		  		
+	            if( tmpInitiatorId != tmhwDcsNetwork_InitiatorIdInvalid )
+		    {	      
+		       allowedInitiators[*pNoOfInitiators].initiatorId = tmpInitiatorId;
+                       allowedInitiators[(*pNoOfInitiators)++].unitNo  = tmpUnitNo;      
+		    }
+  		
+                }
+                else
+                {
+                    break;
+                }
+          }
+            
+            tmpInitiatorMask = tmpInitiatorMask << 1;
+        }
+    }
+ }
+    return( status );           
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_SetTargetAccessTimeout:
+//
+// DESCRIPTION: Sets the target access timeout for any target access in DCS network
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_SetTargetAccessTimeout (
+    tmUnitSelect_t                        dcsNetworkUnitId,   //  I: Unit number of DCS network
+    tmhwDcsNetwork_TargetAccessTimeout_t  accessTimeout       //  I: Target access timeout to be set
+    )
+{
+    tmErrorCode_t        status = TM_OK;
+    UInt32               index = 0;
+    //union _dcsconfigCtrl ctrl;
+    UInt32      ctrl = 0x0;       
+
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+        
+        if( tmhwDcsNetwork_TargetAccessTimeout_Disabled == accessTimeout )
+        {
+       	    TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+	    ctrl |= (0x1 << TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_POS);
+	    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+	    
+        }
+        else
+        {
+	    TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+            ctrl &= ~(TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_MSK);
+	    ctrl |= (UInt32)(accessTimeout << TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_POS);
+	    ctrl &= ~(0x1UL << TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_POS);
+	    TMVH_GEN_WRITE((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+	    
+        }
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }
+    
+    return( status );
+}
+    
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwDcsNetwork_GetTargetAccessTimeout:
+//
+// DESCRIPTION: Gets the current target access timeout
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetTargetAccessTimeout (
+    tmUnitSelect_t                        dcsNetworkUnitId,   //  I: Unit number of DCS network
+    ptmhwDcsNetwork_TargetAccessTimeout_t pAccessTimeout      //  O: Target access timeout to be set
+    )
+{
+    tmErrorCode_t        status = TM_OK;
+    UInt32               index = 0;
+    //union _dcsconfigCtrl ctrl;       
+    UInt32      ctrl = 0x0;
+
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+
+       TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET), ctrl);
+       
+       if( 0x1 == (( ctrl & TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_MSK) >> TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_POS))
+        {
+            *pAccessTimeout = tmhwDcsNetwork_TargetAccessTimeout_Disabled;
+        }
+        else
+        {
+           *pAccessTimeout = (tmhwDcsNetwork_TargetAccessTimeout_t) ((ctrl & TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_MSK) >> TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_POS);
+        }
+
+       
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }
+  
+    return( status );
+}
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntGetStatus:
+//
+// DESCRIPTION: Returns interrupt status.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntGetStatus (
+    tmUnitSelect_t                dcsNetworkUnitId,  //  I: Unit number of DCS network
+    pUInt32                       pIntStatus         //  O: Interrupt status of the given DCS
+                                                     //     network controller
+    )
+{
+    tmErrorCode_t             status = TM_OK;
+    UInt32                    index = 0;
+    UInt32                    interruptStatus = 0x0;
+    
+    if( Null == pIntStatus )
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+    }
+    else
+    {	    
+        if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+        {
+            index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+            
+  
+            TMVH_GEN_READ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_STATUS_OFFSET), interruptStatus);	
+	    *pIntStatus = (interruptStatus & (TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_MSK | TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_MSK));    
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+        }
+    }
+    
+    
+    return( status );
+
+}    
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntEnable:
+//
+// DESCRIPTION: Enables the interrupts specified
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntEnable (
+    tmUnitSelect_t                 dcsNetworkUnitId,    //  I: Unit number of DCS network
+    UInt32                         intsToEnable         //  I: List of interrupts to enable
+    )
+{
+    tmErrorCode_t                    status = TM_OK;
+    UInt32                           index = 0;
+    
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+        TMVH_GEN_WRITE ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_SET_ENABLE_OFFSET), (intsToEnable & (TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_MSK | TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_MSK)));		
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }
+    
+    return( status );
+
+}    
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntDisable:
+//
+// DESCRIPTION: Disables the interrupts specified
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntDisable (
+    tmUnitSelect_t                 dcsNetworkUnitId,     //  I: Unit number of DCS network
+    UInt32                         intsToDisable         //  I: List of interrupts to disable
+    )
+{
+    tmErrorCode_t                      status = TM_OK;
+    UInt32                             index = 0;
+    
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+       TMVH_GEN_WRITE ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_ENABLE_OFFSET), (intsToDisable & (TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_MSK | TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_MSK)));		
+       
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }
+    
+    return( status );
+}
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_IntClear:
+//
+// DESCRIPTION: Clear the interrupt pending bits specified by the mask.
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_IntClear (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    UInt32                         intsToClear        //  I: List of interrupts to clear
+    )
+{
+    tmErrorCode_t                      status = TM_OK;
+    UInt32                             index = 0;
+
+    if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+    {
+        index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+      TMVH_GEN_WRITE ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_INT_CLR_OFFSET), (intsToClear & (TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_MSK | TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_MSK)));	
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;
+    }
+    
+    return( status );
+}
+
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_GetInterruptInfo:
+//
+// DESCRIPTION: Returns complete information on the interrupt cause than 
+//               tmhwDcsNetwork_IntGetStatus 
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       None
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetInterruptInfo (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    ptmhwDcsNetwork_IntCauseInfo_t pIntCauseInfo      //  O: Detailed information on the cause
+                                                      //     of the interrupt.  Buffer for the
+                                                      //     structure has to be allocated by
+                                                      //     the caller.
+    )
+{
+    tmErrorCode_t                      status = TM_OK;
+    UInt32                             index = 0;
+    UInt32                             errToutAddress= 0x0;
+    UInt32                              intCauseRegister = 0x0;
+    
+    if( Null == pIntCauseInfo )
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+    }
+    else
+    {
+        if( dcsNetworkUnitId < (tmUnitSelect_t) gDcsNetworkUnitCount )
+        {
+            tmhwDcsNetwork_TargetId_t     tmpTargetId = (tmhwDcsNetwork_TargetId_t) 0x0;
+            tmUnitSelect_t                tmpUnitNo;
+            UInt32                        initiatorID;
+            UInt32                        targetID;
+	    
+            tmhwDcsNetwork_InitiatorId_t  tmpInitiatorId = (tmhwDcsNetwork_InitiatorId_t)0x0;
+            
+            index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+
+	     TMVH_GEN_READ ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_ADDR_OFFSET), errToutAddress);
+	     TMVH_GEN_READ ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_STAT_OFFSET), intCauseRegister);
+	     pIntCauseInfo->address           = (errToutAddress &  TMVH_DCSNETWORKCONFIG_BC_ADDR_ERR_TOUT_ADDR_MSK );
+	    pIntCauseInfo->errorOrTimeout    = (intCauseRegister & TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_ACK_MSK) >> TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_ACK_POS;
+            pIntCauseInfo->byteMask          = (intCauseRegister & TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_MASK_MSK) >> TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_MASK_POS;
+            pIntCauseInfo->isRead            = (intCauseRegister & TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_READ_MSK) >> TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_READ_POS;
+
+            targetID = (intCauseRegister & TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_SEL_MSK) >> TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_SEL_POS;
+            
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+			status = DcsNetworkConvertTarget2TargetIdAndUnit( targetID,
+                                                              &tmpTargetId,
+                                                              &tmpUnitNo,
+                                                              dcsNetworkUnitId
+                                                            );
+			
+#else            
+            status = DcsNetworkConvertTarget2TargetIdAndUnit( targetID,
+                                                              &tmpTargetId,
+                                                              &tmpUnitNo,
+                                                              gModIdsOfDcsNwSecurityModules[ index ]
+                                                            );
+#endif                                                            
+  
+            if( TM_OK != status )
+            {
+                tmpTargetId = (tmhwDcsNetwork_TargetId_t) targetID;
+                tmpUnitNo   = 0;
+            }
+           
+                pIntCauseInfo->target.targetId       = tmpTargetId;
+                pIntCauseInfo->target.unitNo         = tmpUnitNo;
+                initiatorID = (intCauseRegister & TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_GNT_MSK) >> TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_GNT_POS;
+	   if( TM_OK == status )
+            {  	
+            	
+#if (TMFL_PNX_ID==85500) // 85500 Module IDs are same
+					status = DcsNetworkConvertInitiator2InitiatorIdAndUnit( (0x1UL << initiatorID),
+                                                                        &tmpInitiatorId,
+                                                                        &tmpUnitNo,
+                                                                        dcsNetworkUnitId
+                                                                      );
+
+#else
+            	  	
+                status = DcsNetworkConvertInitiator2InitiatorIdAndUnit( (0x1UL << initiatorID),
+                                                                        &tmpInitiatorId,
+                                                                        &tmpUnitNo,
+                                                                        gModIdsOfDcsNwSecurityModules[ index ]
+                                                                      );
+#endif
+            }
+            
+           if( TM_OK != status )
+            {
+                tmpInitiatorId = (tmhwDcsNetwork_InitiatorId_t) initiatorID;
+                tmpUnitNo      = 0;
+            }
+           
+                pIntCauseInfo->initiator.initiatorId = tmpInitiatorId;
+                pIntCauseInfo->initiator.unitNo      = tmpUnitNo;
+            }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_UNIT_NUM;        
+        }
+    }         
+        
+    return( status );
+}    
+                      
+//-----------------------------------------------------------------------------
+// Internal Prototypes:
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+DcsNetworkCapabilitiesInit (
+    void
+    )
+{
+    tmErrorCode_t                       status = TM_OK;         // DVP function return status
+#ifdef BSL_DEPENDENT    
+    tmSWVersion_t                       bslSwVersion;   // DVP software version info struct
+#endif    
+    UInt32                              index = 0;
+    static UInt32                       ptmhwDcsNetworkConfigRegs= 0x0;
+    static UInt32                       ptmhwDcsNetworkSecurityRegs = 0x0;
+    UInt32                              blockId = 0x0;
+  //  ptmhwDcsNetwork_Cfg_t               pCfg = Null;
+    ptmhwDcsNetwork_Cfg_t               pDcsNetworkConfig_Cfg = Null;
+    ptmhwDcsNetwork_Cfg_t               pDcsNetworkSecurity_Cfg = Null;
+    
+    const  UInt32 modIdsOfDcsNwConfigModules[]      = { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)		    
+	    TMHW_DCSNETWORK_MCONFIG_HWMODULE_ID, 
+#endif	    
+         TMHW_DCSNETWORK_TCONFIG_HWMODULE_ID };
+    const  UInt32 majorVerOfDcsNwConfigModules[]    = { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)		    
+	    TMHW_DCSNETWORK_MCONFIG_MAJOR_VERSION, 
+#endif	    
+	    TMHW_DCSNETWORK_TCONFIG_MAJOR_VERSION };
+    const  UInt32 majorVerOfDcsNwSecurityModules[]  = { 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)		    
+	    TMHW_DCSNETWORK_MSECURITY_MAJOR_VERSION,
+#endif	    
+	    TMHW_DCSNETWORK_TSECURITY_MAJOR_VERSION };
+#ifdef BSL_DEPENDENT        
+    status = tmbslMgrGetSWVersion (&bslSwVersion);
+    if( TM_OK == status )
+    {
+        if (bslSwVersion.compatibilityNr != TMBSL_MGR_COMPATIBILITY_EXP)
+        {
+            status = TMHW_ERR_DCSNETWORK_COMPATIBILITY;
+        }
+        else if (bslSwVersion.majorVersionNr < TMBSL_MGR_MAJOR_VERSION_EXP)
+        {
+            status = TMHW_ERR_DCSNETWORK_MAJOR_VERSION;
+        }
+	else
+	{
+		; /*MISRA 14.10*/
+	}
+    }
+#endif    
+    // It is assumed that there will be only one DCS network config/security module 
+    //  in a system with the given module Id.
+    
+    // Also it is assumed that there each DCS network config module will have 
+    //  DCS network security module corresponding to it.
+    //  
+    
+    pDcsNetworkConfig_Cfg = tmhwDcsNetwork_ConfigCfgGet();
+    pDcsNetworkSecurity_Cfg = tmhwDcsNetwork_SecurityCfgGet();
+    
+    if( TM_OK == status )
+    {
+        for( index = 0; index < sizeof(modIdsOfDcsNwConfigModules) / sizeof(UInt32);
+             index++ )
+        {
+	    
+            gDcsNwConfigRegs[ index ]   = 0;   
+            gDcsNwSecurityRegs[ index ] = 0;
+
+	    //pCfg = &pDcsNetworkConfig_Cfg[index];
+            ptmhwDcsNetworkConfigRegs = pDcsNetworkConfig_Cfg[index].baseAddress;
+
+            //pCfg = &pDcsNetworkSecurity_Cfg[index];
+            ptmhwDcsNetworkSecurityRegs = pDcsNetworkSecurity_Cfg[index].baseAddress;
+      	    /*if( TM_OK == status )
+            {*/
+                        
+             TMVH_GEN_READ((ptmhwDcsNetworkConfigRegs + TMVH_DCSNETWORKCONFIG_BC_MODULE_ID_OFFSET),  blockId);
+
+		if( ((blockId & TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MID_MSK) >> TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MID_POS) != modIdsOfDcsNwConfigModules[ index ] )
+                {
+                    status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+                }
+                else if( ((blockId & TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MAJOR_RID_MSK) >> TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MAJOR_RID_POS)  != majorVerOfDcsNwConfigModules[ index ] )
+                {
+                    status = TMHW_ERR_DCSNETWORK_COMPATIBILITY;
+                }                
+		else
+		{
+			;/*MISRA 14.10*/
+		}
+                                        
+                if( TM_OK == status )
+                { 
+                                
+		    TMVH_GEN_READ((ptmhwDcsNetworkSecurityRegs + TMVH_DCSNETWORKSECUIRITY_BCSEC_MODULE_ID_OFFSET),  blockId);
+		    
+                    if( ((blockId & TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MID_MSK) >> TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MID_POS)  != gModIdsOfDcsNwSecurityModules[ index ] ) 
+                    {
+                        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+                        
+                    }
+                    else if( ((blockId & TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MAJOR_RID_MSK) >> TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MAJOR_RID_POS) != majorVerOfDcsNwSecurityModules[ index ] )
+                    {
+                        status = TMHW_ERR_DCSNETWORK_COMPATIBILITY;
+                    }
+		    else
+		    {
+			;/*MISRA 14.10*/
+		    }
+                
+               /* }
+                else
+                     break;                                                   
+		     */
+                    
+
+                if( TM_OK == status )
+                {
+                    gDcsNwConfigRegs[ index ] = ptmhwDcsNetworkConfigRegs;   
+                    gDcsNwSecurityRegs[ index ] = ptmhwDcsNetworkSecurityRegs;
+                    
+                    gDcsNetworkUnitCount++;
+                }
+                else
+		{
+                     break;                                                   
+		}
+        /*    }
+            else
+            {
+                status = TM_OK;
+                continue;
+            }*/
+	}
+       }
+    }    
+    
+    return( status );
+}    
+
+
+static UInt32
+DcsNetWorkUnitNumberToIndex(
+    tmUnitSelect_t unitNo
+    )
+{
+    UInt32 index = 0;
+    UInt32 noOfUnitsPresent = 0;
+    
+    for( index = 0; index < TMHW_DCSNETWORK_MAX_UNIT_COUNT; index++ )
+    {
+        if( gDcsNwConfigRegs[ index ] != 0 )
+        {
+	   
+            if( (noOfUnitsPresent) == (UInt32)unitNo )
+            {
+                break;
+            }
+  	    noOfUnitsPresent++;
+	    
+        }
+    } 
+    return ( noOfUnitsPresent );
+}
+
+
+/* In PNX85500, the TDCS & MDCS have same module IDs. Hence it is not possible to identify
+   by using module IDs. These will be identified by unit IDs
+*/     
+#if (TMFL_PNX_ID==85500)    
+
+static tmErrorCode_t
+DcsNetworkConvertTarget2TargetIdAndUnit(
+    UInt32                     target,
+    ptmhwDcsNetwork_TargetId_t pTargetId,
+    ptmUnitSelect_t            pUnitNo,
+    tmUnitSelect_t             dcsNetworkUnitId
+)
+{
+    tmErrorCode_t     status = TM_OK;
+    
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( dcsNetworkUnitId == 0 )
+    {
+        if( target < TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS )
+        {         
+            *pTargetId = mdcsTargetInfo[ target ].targetId;
+            *pUnitNo   = mdcsTargetInfo[ target ].unitNo;
+        }
+        else if (target == DCSNETWORK_NULLORERROR_TARGET) 
+        {
+            status = TMHW_ERR_DCSNETWORK_NULLORERROR_TARGET;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_CONFIG_ERROR) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_CONFIG_ERROR;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_SECURITY_APERTURE) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_SECURITY_APERTURE;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+        }
+        
+    }
+    else 
+#endif
+    if( dcsNetworkUnitId == 1 )
+    {
+        if( target < TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS )
+        {         
+            *pTargetId = tdcsTargetInfo[ target ].targetId;
+            *pUnitNo   = tdcsTargetInfo[ target ].unitNo;
+        }
+         else if (target == DCSNETWORK_NULLORERROR_TARGET) 
+        {
+            status = TMHW_ERR_DCSNETWORK_NULLORERROR_TARGET;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_CONFIG_ERROR) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_CONFIG_ERROR;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_SECURITY_APERTURE) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_SECURITY_APERTURE;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+        }
+    }  
+ 	else
+   	{
+		;/*MISRA 14.10*/
+   	}
+                 
+
+    return( status );
+}
+
+static tmErrorCode_t
+DcsNetworkConvertInitiator2InitiatorIdAndUnit(
+    UInt32                        initiatorMask,
+    ptmhwDcsNetwork_InitiatorId_t pInitiatorId,
+    ptmUnitSelect_t               pUnitNo,
+    tmUnitSelect_t             	  dcsNetworkUnitId
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    initiatorInfo * pTmpInitiatorInfo = Null;
+    UInt32          initiatorsCount = 0x0;
+    UInt32          loopIndex =0x0;
+     
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	   
+    if( dcsNetworkUnitId == 0 )
+    {
+        pTmpInitiatorInfo = mdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+    }
+    else 
+#endif	    
+   	if( dcsNetworkUnitId == 1 )
+    {
+        pTmpInitiatorInfo = tdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+    
+    if (pTmpInitiatorInfo != Null)
+    {		 
+      	if( TM_OK == status )
+      	{      
+           for( loopIndex = 0; loopIndex < initiatorsCount; loopIndex++ )
+           {
+              if( pTmpInitiatorInfo[ loopIndex ].initiatorMask == initiatorMask )
+                { 
+                  break;
+                }
+           }
+        
+           if( loopIndex == initiatorsCount )
+           {
+              status = TMHW_ERR_DCSNETWORK_BAD_INITIATOR;
+           }
+       	}
+     	if( TM_OK == status )
+     	{
+        	*pInitiatorId = pTmpInitiatorInfo[ loopIndex ].initiatorId;
+        	*pUnitNo      = pTmpInitiatorInfo[ loopIndex ].unitNo;
+     	}
+   }
+   else
+   {
+    status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;	   
+   }
+   
+   return( status );    
+}
+    
+static tmErrorCode_t
+DcsNetworkConvertTargetIdAndUnit2Target(
+    tmhwDcsNetwork_TargetId_t targetId,
+    tmUnitSelect_t            unitNo,
+    tmUnitSelect_t            dcsNetworkUnitId,
+    pUInt32                   pTarget,
+    pUInt32                   pMmioOffset
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    targetInfo    *pTmpTargetInfo = Null;
+    UInt32          tmpNoOfTargets = 0x0;
+    UInt32          loopIndex = 0x0;
+   
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( dcsNetworkUnitId == 0 )
+    {
+        pTmpTargetInfo = mdcsTargetInfo;
+        tmpNoOfTargets = TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS;
+    }
+    else 
+#endif	    
+    if( dcsNetworkUnitId == 1 )
+    {
+        pTmpTargetInfo = tdcsTargetInfo;
+        tmpNoOfTargets = TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+    
+    if (pTmpTargetInfo != Null)
+    {
+       if( TM_OK == status )
+       {
+          for( loopIndex = 0; loopIndex < tmpNoOfTargets; loopIndex++ )
+          {
+             if( ( pTmpTargetInfo[ loopIndex ].targetId == targetId ) &&
+                 ( pTmpTargetInfo[ loopIndex ].unitNo == unitNo )
+               )
+             {
+                *pTarget     = loopIndex;
+                *pMmioOffset = pTmpTargetInfo[ loopIndex ].offset;
+                
+                break;
+            }
+          }
+       if( loopIndex == tmpNoOfTargets )
+       {
+          status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+       }
+      }
+   }
+   else
+   {
+   
+   		status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+   }   
+	    
+    return( status );
+}     
+    
+
+static tmErrorCode_t
+DcsNetworkConvertInitiatorIdAndUnit2Initiator(
+    tmhwDcsNetwork_InitiatorId_t initiatorId,
+    tmUnitSelect_t               unitNo,
+    tmUnitSelect_t            	 dcsNetworkUnitId,
+    pUInt32                      pInitiatorMask
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    initiatorInfo * pTmpInitiatorInfo = Null;
+    UInt32          initiatorsCount = 0x0;
+    UInt32          loopIndex = 0x0; 
+   
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( dcsNetworkUnitId == 0 )
+    {
+        pTmpInitiatorInfo = mdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+    }
+    else 
+#endif	    
+    if( dcsNetworkUnitId == 1 )
+    {
+        pTmpInitiatorInfo = tdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+
+   if(pTmpInitiatorInfo != Null)
+   {
+      if( TM_OK == status )
+      {        
+        for( loopIndex = 0; loopIndex < initiatorsCount; loopIndex++ )
+        {
+            if( ( pTmpInitiatorInfo[ loopIndex ].initiatorId == initiatorId ) &&
+                ( pTmpInitiatorInfo[ loopIndex ].unitNo == unitNo )
+              )
+            {
+                *pInitiatorMask = pTmpInitiatorInfo[ loopIndex ].initiatorMask;
+
+                break;
+            }
+        }        
+     if( loopIndex == initiatorsCount )
+     {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+        
+     }
+    }
+   }
+   else
+   {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+   }   
+    return( status );
+}
+
+
+#else
+
+static tmErrorCode_t
+DcsNetworkConvertTarget2TargetIdAndUnit(
+    UInt32                     target,
+    ptmhwDcsNetwork_TargetId_t pTargetId,
+    ptmUnitSelect_t            pUnitNo,
+    UInt32                     moduleId
+)
+{
+    tmErrorCode_t     status = TM_OK;
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID == moduleId )
+    {
+        if( target < TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS )
+        {         
+            *pTargetId = mdcsTargetInfo[ target ].targetId;
+            *pUnitNo   = mdcsTargetInfo[ target ].unitNo;
+        }
+        else if (target == DCSNETWORK_NULLORERROR_TARGET) 
+        {
+            status = TMHW_ERR_DCSNETWORK_NULLORERROR_TARGET;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_CONFIG_ERROR) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_CONFIG_ERROR;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_SECURITY_APERTURE) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_SECURITY_APERTURE;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+        }
+        
+    }
+    else 
+#endif
+    if( TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID == moduleId )
+    {
+        if( target < TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS )
+        {         
+            *pTargetId = tdcsTargetInfo[ target ].targetId;
+            *pUnitNo   = tdcsTargetInfo[ target ].unitNo;
+        }
+         else if (target == DCSNETWORK_NULLORERROR_TARGET) 
+        {
+            status = TMHW_ERR_DCSNETWORK_NULLORERROR_TARGET;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_CONFIG_ERROR) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_CONFIG_ERROR;
+        }
+        else if (target == DCSNETWORK_CONTROLLER_SECURITY_APERTURE) 
+        {
+            status = TMHW_ERR_DCSNETWORK_CONTROLLER_SECURITY_APERTURE;
+        }
+        else
+        {
+            status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+        }
+    }  
+   else
+   {
+	;/*MISRA 14.10*/
+   }
+                 
+
+    return( status );
+}
+
+
+
+static tmErrorCode_t
+DcsNetworkConvertInitiator2InitiatorIdAndUnit(
+    UInt32                        initiatorMask,
+    ptmhwDcsNetwork_InitiatorId_t pInitiatorId,
+    ptmUnitSelect_t               pUnitNo,
+    UInt32                        moduleId
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    initiatorInfo * pTmpInitiatorInfo = Null;
+    UInt32          initiatorsCount = 0x0;
+    UInt32          loopIndex =0x0; 
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	   
+    if( TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpInitiatorInfo = mdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+    }
+    else 
+#endif	    
+   if( TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpInitiatorInfo = tdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+    
+    if (pTmpInitiatorInfo != Null)
+    {		 
+      if( TM_OK == status )
+        {      
+           for( loopIndex = 0; loopIndex < initiatorsCount; loopIndex++ )
+           {
+              if( pTmpInitiatorInfo[ loopIndex ].initiatorMask == initiatorMask )
+                { 
+                  break;
+                }
+            }
+        
+           if( loopIndex == initiatorsCount )
+           {
+              status = TMHW_ERR_DCSNETWORK_BAD_INITIATOR;
+           }
+        }
+     if( TM_OK == status )
+     {
+        *pInitiatorId = pTmpInitiatorInfo[ loopIndex ].initiatorId;
+        *pUnitNo      = pTmpInitiatorInfo[ loopIndex ].unitNo;
+     }
+   }
+   else
+   {
+    status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;	   
+   }
+    return( status );    
+}
+    
+static tmErrorCode_t
+DcsNetworkConvertTargetIdAndUnit2Target(
+    tmhwDcsNetwork_TargetId_t targetId,
+    tmUnitSelect_t            unitNo,
+    UInt32                    moduleId,
+    pUInt32                   pTarget,
+    pUInt32                   pMmioOffset
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    targetInfo    *pTmpTargetInfo = Null;
+    UInt32          tmpNoOfTargets = 0x0;
+    UInt32          loopIndex = 0x0;
+   
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpTargetInfo = mdcsTargetInfo;
+        tmpNoOfTargets = TMHW_DCSNETWORK_MDCS_NO_OF_TARGETS;
+    }
+    else 
+#endif	    
+    if( TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpTargetInfo = tdcsTargetInfo;
+        tmpNoOfTargets = TMHW_DCSNETWORK_TDCS_NO_OF_TARGETS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+    
+    if (pTmpTargetInfo != Null)
+    {
+       if( TM_OK == status )
+       {
+          for( loopIndex = 0; loopIndex < tmpNoOfTargets; loopIndex++ )
+          {
+             if( ( pTmpTargetInfo[ loopIndex ].targetId == targetId ) &&
+                 ( pTmpTargetInfo[ loopIndex ].unitNo == unitNo )
+               )
+             {
+                *pTarget     = loopIndex;
+                *pMmioOffset = pTmpTargetInfo[ loopIndex ].offset;
+                
+                break;
+            }
+          }
+       if( loopIndex == tmpNoOfTargets )
+       {
+          status = TMHW_ERR_DCSNETWORK_BAD_TARGET;
+       }
+      }
+   }
+   else
+   {
+   status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+   }   
+	    
+    return( status );
+}     
+    
+
+static tmErrorCode_t
+DcsNetworkConvertInitiatorIdAndUnit2Initiator(
+    tmhwDcsNetwork_InitiatorId_t initiatorId,
+    tmUnitSelect_t               unitNo,
+    UInt32                       moduleId,
+    pUInt32                      pInitiatorMask
+)
+{
+    tmErrorCode_t   status = TM_OK;
+    initiatorInfo * pTmpInitiatorInfo = Null;
+    UInt32          initiatorsCount = 0x0;
+    UInt32          loopIndex = 0x0; 
+   
+
+#if (TMHW_DCSNETWORK_MAX_UNIT_COUNT == 2)	    
+    if( TMHW_DCSNETWORK_MSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpInitiatorInfo = mdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_MDCS_NO_OF_INITIATORS;
+    }
+    else 
+#endif	    
+     if( TMHW_DCSNETWORK_TSECURITY_HWMODULE_ID == moduleId )
+    {
+        pTmpInitiatorInfo = tdcsInitiatorInfo;
+        initiatorsCount    = TMHW_DCSNETWORK_TDCS_NO_OF_INITIATORS;
+    }
+    else
+    {
+        status = TMHW_ERR_DCSNETWORK_BAD_MODULE_ID;
+    }
+
+   if(pTmpInitiatorInfo != Null)
+   {
+      if( TM_OK == status )
+      {        
+        for( loopIndex = 0; loopIndex < initiatorsCount; loopIndex++ )
+        {
+            if( ( pTmpInitiatorInfo[ loopIndex ].initiatorId == initiatorId ) &&
+                ( pTmpInitiatorInfo[ loopIndex ].unitNo == unitNo )
+              )
+            {
+                *pInitiatorMask = pTmpInitiatorInfo[ loopIndex ].initiatorMask;
+
+                break;
+            }
+        }        
+     if( loopIndex == initiatorsCount )
+     {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;
+     }
+    }
+   }
+   else
+   {
+        status = TMHW_ERR_DCSNETWORK_BAD_PARAMETER;	   
+   }   
+    return( status );
+}
+
+#endif
+        
+#if (defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST1) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST1) || defined (TMHW_DCSNETWORK_TDCS_A0A2_LIST2) || defined (TMHW_DCSNETWORK_MDCS_A0A0_LIST2) || defined(TMHW_DCSNETWORK_MDCS_A06E_LIST2) || defined(TMHW_DCSNETWORK_TDCS_A06E_LIST2))   
+
+//-----------------------------------------------------------------------------
+//
+// FUNCTION:    tmhwDcsNetwork_GetFeaturesInfo:
+//
+// DESCRIPTION: Returns complete information of Feature register 
+//
+// RETURN:      tmErrorCode_t: Status of operation (TM_OK = PASS)
+//
+// NOTES:       This register is present only in pnx8535
+//
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmhwDcsNetwork_GetFeaturesInfo (
+    tmUnitSelect_t                 dcsNetworkUnitId,  //  I: Unit number of DCS network
+    ptmhwDcsNetwork_FeaturesInfo_t pFeatureInfo      //  O: Detailed information on the cause
+                                                      //     of the interrupt.  Buffer for the
+                                                      //     structure has to be allocated by
+                                                      //     the caller.
+    )
+
+
+{
+        UInt32                             index = 0 ;
+        UInt32                             featureRegister = 0x0; 
+
+    if( Null == pFeatureInfo )
+    {
+        return (TMHW_ERR_DCSNETWORK_BAD_PARAMETER);
+    }
+    
+    index = DcsNetWorkUnitNumberToIndex( dcsNetworkUnitId );
+    TMVH_GEN_READ ((gDcsNwConfigRegs[ index ] + TMVH_DCSNETWORKCONFIG_BC_FEATURES_OFFSET), featureRegister);
+     
+    pFeatureInfo->uinqueID = ( featureRegister & TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_UID_MSK) >> TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_UID_POS;
+
+    pFeatureInfo->security = ( featureRegister & TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_SECURITY_MSK) >> TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_SECURITY_POS;
+
+    pFeatureInfo->numBaseRegs = ( featureRegister & TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_BASE_MSK) >> TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_BASE_POS;
+
+    pFeatureInfo->numOfTargets = ( featureRegister & TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_TARGETS_MSK) >> TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_TARGETS_POS;	
+
+    pFeatureInfo->numOfInitators = ( featureRegister & TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_INITATORS_MSK) >> TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_INITATORS_POS;
+        
+     return (TM_OK);	
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkConfigModule_reg.h linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkConfigModule_reg.h
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkConfigModule_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkConfigModule_reg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,150 @@
+/**********************************************************************
+*
+*	Header %name:	tmvhDcsNetworkConfigModule_reg.h %
+*	Instance:		PB5_1
+*	Description:	
+*	%created_by:	tusr69 %
+*	%date_created:	Thu May 18 10:34:35 2006 %
+*
+**********************************************************************/
+#ifndef TMVHDCSNETWORKCONFIGMODULE_REG_H
+#define TMVHDCSNETWORKCONFIGMODULE_REG_H
+
+/* -----------------------------------------------------------------------------
+*  Include files
+*  ---------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+/* --------------------------------------------------------------------------
+*  Register offsets from base address
+*  --------------------------------------------------------------------------*/
+
+	
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_OFFSET                      0x0000
+#define TMVH_DCSNETWORKCONFIG_BC_ADDR_OFFSET                       0x000c
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_OFFSET                       0x0010
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_OFFSET                   0x0040	
+#define TMVH_DCSNETWORKCONFIG_BC_INT_CLR_ENABLE_OFFSET             0x0FD8
+#define TMVH_DCSNETWORKCONFIG_BC_INT_SET_ENABLE_OFFSET             0x0FDC
+#define TMVH_DCSNETWORKCONFIG_BC_INT_STATUS_OFFSET                 0x0FE0
+#define TMVH_DCSNETWORKCONFIG_BC_INT_ENABLE_OFFSET                 0x0FE4	
+#define TMVH_DCSNETWORKCONFIG_BC_INT_CLR_OFFSET                    0x0FE8
+#define TMVH_DCSNETWORKCONFIG_BC_INT_SET_OFFSET                    0x0FEC	
+#define TMVH_DCSNETWORKCONFIG_BC_MODULE_ID_OFFSET                  0x0FFC
+
+
+/* --------------------------------------------------------------------------
+*  Control Register
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_POS            1	
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_SEL_MSK            0x0000001EUL	
+
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_POS            0	
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_TOUT_OFF_MSK            0x00000001UL		
+
+/* Only for PNX85500 */
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_POS           5	
+#define TMVH_DCSNETWORKCONFIG_BC_CNTRL_REG_PWR_MGMNT_MSK           0x00000020UL	
+
+
+/* --------------------------------------------------------------------------
+* Address Register
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_BC_ADDR_ERR_TOUT_ADDR_POS            2	
+#define TMVH_DCSNETWORKCONFIG_BC_ADDR_ERR_TOUT_ADDR_MSK            0xFFFFFFFCUL	
+
+
+/* --------------------------------------------------------------------------
+* Status Register
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_GNT_POS            24	
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_GNT_MSK            0x1F000000
+
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_SEL_POS            10	
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_SEL_MSK            0x0001FC00
+
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_READ_POS           8	
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_READ_MSK           0x00000100	
+
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_MASK_POS           4	
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_TOUT_MASK_MSK           0x000000F0
+
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_ACK_POS                 1	
+#define TMVH_DCSNETWORKCONFIG_BC_STAT_ERR_ACK_MSK                 0x00000002	
+	
+
+/* --------------------------------------------------------------------------
+*  Feature Register (pnx8535 only)
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_UID_POS            16	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_UID_MSK            0x00070000	
+
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_SECURITY_POS       14	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_SECURITY_MSK       0x00004000	
+	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_BASE_POS       11	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_BASE_MSK       0x00001800
+
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_TARGETS_POS    5	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_TARGETS_MSK    0x000007E0
+
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_INITATORS_POS    0	
+#define TMVH_DCSNETWORKCONFIG_BC_FEATURES_REG_NUM_INITATORS_MSK    0x0000001F
+	
+	
+
+/* ----------------------------------------------------------------------------
+* Interrupt Clear Enable, Interrupt Set Enable, Interrupt Status, 
+* Interrupt Enable, Interrupt Clear, Interrupt Set Registers Have Similar Bits.
+* -----------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_POS                     1	
+#define TMVH_DCSNETWORKCONFIG_BC_INT_TOUT_MSK                     0x00000002
+
+#define TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_POS                    0	
+#define TMVH_DCSNETWORKCONFIG_BC_INT_ERROR_MSK                    0x00000001
+
+
+
+	
+	
+
+	
+/* --------------------------------------------------------------------------
+*  Module ID Register
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MID_POS            16 	
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MID_MSK            0xFFFF0000UL 
+
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MAJOR_RID_POS      12                       
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MAJOR_RID_MSK      0x0000F000	
+	
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MINOR_RID_POS      8                       
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_MINOR_RID_MSK      0x00000F00	
+
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_APERTURE_SIZE_POS  0                       
+#define TMVH_DCSNETWORKCONFIG_MODULE_ID_REG_APERTURE_SIZE_MSK  0x000000FF	
+
+
+
+
+/* Register Read Write Macro's  */
+#define TMVH_GEN_READ(address,result)                                          \
+            ((result) = *(volatile UInt32 *)(address))
+
+
+
+#define TMVH_GEN_WRITE(address,value)                                          \
+           *(volatile UInt32 *)(address) = (value)
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMVHDCSNETWORKCONFIGMODULE_REG_H */
+	
+
diff -Naurp linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkSecurityModule_reg.h linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkSecurityModule_reg.h
--- linux-2.6.34.orig/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkSecurityModule_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dcs_net/tmhwDcsNetwork/src/tmvhDcsNetworkSecurityModule_reg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,69 @@
+/**********************************************************************
+*
+*	Header %name:	tmvhDcsNetworkSecurityModule_reg.h %
+*	Instance:		PB5_1
+*	Description:	
+*	%created_by:	tusr69 %
+*	%date_created:	Mon Feb 13 16:15:08 2006 %
+*
+**********************************************************************/
+
+
+#ifndef TMVHDCSNETWORKSECURITYMODULE_REG_H
+#define TMVHDCSNETWORKSECURITYMODULE_REG_H
+
+/* -----------------------------------------------------------------------------
+*  Include files
+*  ---------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+/* --------------------------------------------------------------------------
+*  Register offsets from base address
+*  --------------------------------------------------------------------------*/
+
+	
+#define TMVH_DCSNETWORKSECUIRITY_TARGET_ACCESS_CNTRL_OFFSET       0x0000
+#define TMVH_DCSNETWORKSECUIRITY_BCSEC_MODULE_ID_OFFSET           0x0FFC
+
+
+
+/* --------------------------------------------------------------------------
+*  Module ID Register
+* --------------------------------------------------------------------------*/
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MID_POS            16 	
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MID_MSK            0xFFFF0000UL 
+
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MAJOR_RID_POS      12                       
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MAJOR_RID_MSK      0x0000F000	
+	
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MINOR_RID_POS      8                       
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_MINOR_RID_MSK      0x00000F00	
+
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_APERTURE_SIZE_POS  0                       
+#define TMVH_DCSNETWORKSECUIRITY_MODULE_ID_REG_APERTURE_SIZE_MSK  0x000000FF	
+
+
+
+
+/* Register Read Write Macro's  */
+#define TMVH_GEN_READ(address,result)                                          \
+            ((result) = *(volatile UInt32 *)(address))
+
+
+
+#define TMVH_GEN_WRITE(address,value)                                          \
+           *(volatile UInt32 *)(address) = (value)
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMVHDCSNETWORKSECURITYMODULE_REG_H */
+	
+	
+
diff -Naurp linux-2.6.34.orig/drivers/dma/amba-pl08x.c linux-2.6.34/drivers/dma/amba-pl08x.c
--- linux-2.6.34.orig/drivers/dma/amba-pl08x.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dma/amba-pl08x.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,2025 @@
+/*
+ * Copyright (c) 2006 ARM Ltd.
+ * Copyright (c) 2010 ST-Ericsson SA
+ *
+ * Author: Peter Pearse <peter.pearse@arm.com>
+ * Author: Linus Walleij <linus.walleij@stericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is iin this distribution in the
+ * file called COPYING.
+ *
+ * Documentation: ARM DDI 0196G == PL080
+ * Documentation: ARM DDI 0218E	== PL081
+ *
+ * PL080 & PL081 both have 16 sets of DMA signals that can be routed to
+ * any channel.
+ *
+ * The PL080 has 8 channels available for simultaneous use, and the PL081
+ * has only two channels. So on these DMA controllers the number of channels
+ * and the number of incoming DMA signals are two totally different things.
+ * It is usually not possible to theoretically handle all physical signals,
+ * so a multiplexing scheme with possible denial of use is necessary.
+ *
+ * The PL080 has a dual bus master, PL081 has a single master.
+ *
+ * Memory to peripheral transfer may be visualized as
+ *	Get data from memory to DMAC
+ *	Until no data left
+ *		On burst request from peripheral
+ *			Destination burst from DMAC to peripheral
+ *			Clear burst request
+ *	Raise terminal count interrupt
+ *
+ * For peripherals with a FIFO:
+ * Source      burst size == half the depth of the peripheral FIFO
+ * Destination burst size == the depth of the peripheral FIFO
+ *
+ * (Bursts are irrelevant for mem to mem transfers - there are no burst
+ * signals, the DMA controller will simply facilitate its AHB master.)
+ *
+ * ASSUMES default (little) endianness for DMA transfers
+ *
+ * Only DMAC flow control is implemented
+ *
+ * Global TODO:
+ * - Break out common code from arch/arm/mach-s3c64xx and share
+ */
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/dmapool.h>
+#include <linux/amba/bus.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/pl08x.h>
+#include <linux/clk.h>
+
+#include <asm/hardware/pl080.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+#include <asm/atomic.h>
+#include <asm/processor.h>
+#include <asm/cacheflush.h>
+
+#define DRIVER_NAME	"pl08xdmac"
+
+/**
+ * struct vendor_data - vendor-specific config parameters
+ * for PL08x derivates
+ * @name: the name of this specific variant
+ * @channels: the number of channels available in this variant
+ * @dualmaster: whether this version supports dual AHB masters
+ * or not.
+ */
+struct vendor_data {
+	char *name;
+	u8 channels;
+	bool dualmaster;
+};
+
+/*
+ * PL08X private data structures
+ * An LLI struct - see pl08x TRM
+ * Note that next uses bit[0] as a bus bit,
+ * start & end do not - their bus bit info
+ * is in cctl
+ */
+struct lli {
+	dma_addr_t src;
+	dma_addr_t dst;
+	dma_addr_t next;
+	u32 cctl;
+};
+
+/**
+ * struct pl08x_driver_data - the local state holder for the PL08x
+ * @base: virtual memory base (remapped) for the PL08x
+ * @adev: the corresponding AMBA (PrimeCell) bus entry
+ * @vd: vendor data for this PL08x variant
+ * @pd: platform data passed in from the platform/machine
+ * @clk: a clock to be enabled for this device to run
+ * @phy_chans: array of data for the physical channels
+ * @pool: a pool for the LLI descriptors
+ * @pool_ctr: counter of LLIs in the pool
+ * @lock: a spinlock for this struct
+ */
+struct pl08x_driver_data {
+	void __iomem *base;
+	struct amba_device *adev;
+	struct vendor_data *vd;
+	struct pl08x_platform_data *pd;
+	struct clk *clk;
+	struct pl08x_phy_chan *phy_chans;
+	struct dma_pool *pool;
+	int pool_ctr;
+	spinlock_t lock;
+};
+
+#ifdef MODULE
+
+# error "AMBA PL08X DMA CANNOT BE COMPILED AS A LOADABLE MODULE AT PRESENT"
+
+/*
+	a) Some devices might make use of DMA during boot
+	   (esp true for DMAENGINE implementation)
+	b) Memory allocation will need much more attention
+	   before load/unload can be supported
+ */
+#endif
+
+/*
+ * PL08X specific defines
+ */
+
+/*
+ * Memory boundaries: the manual for PL08x says that the controller
+ * cannot read past a 1KiB boundary, so these defines are used to
+ * create transfer LLIs that do not cross such boundaries.
+ */
+#define PL08X_BOUNDARY_SHIFT		(10)	/* 1KB 0x400 */
+#define PL08X_BOUNDARY_SIZE		(1 << PL08X_BOUNDARY_SHIFT)
+
+/* Minimum period between work queue runs */
+#define PL08X_WQ_PERIODMIN	20
+
+/* Size (bytes) of each LLI buffer allocated for one transfer */
+# define PL08X_LLI_TSFR_SIZE	0x2000
+
+/* Maximimum times we call dma_pool_alloc on this pool without freeing */
+#define PL08X_MAX_ALLOCS	0x40
+#define MAX_NUM_TSFR_LLIS	(PL08X_LLI_TSFR_SIZE/sizeof(struct lli))
+#define PL08X_ALIGN		8
+
+static inline struct pl08x_dma_chan *to_pl08x_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct pl08x_dma_chan, chan);
+}
+
+/*
+ * Physical channel handling
+ */
+
+/* Whether a certain channel is busy or not */
+static int pl08x_phy_channel_busy(struct pl08x_phy_chan *ch)
+{
+	unsigned int val;
+
+	val = readl(ch->base + PL080_CH_CONFIG);
+	return val & PL080_CONFIG_ACTIVE;
+}
+
+/*
+ * Set the initial DMA register values i.e. those for the first LLI
+ * The next lli pointer and the configuration interrupt bit have
+ * been set when the LLIs were constructed
+ */
+static void pl08x_set_cregs(struct pl08x_driver_data *pl08x,
+			    struct pl08x_phy_chan *ch)
+{
+	/* Wait for channel inactive */
+	while (pl08x_phy_channel_busy(ch))
+		;
+
+	dev_vdbg(&pl08x->adev->dev,
+		"WRITE channel %d: csrc=%08x, cdst=%08x, "
+		 "cctl=%08x, clli=%08x, ccfg=%08x\n",
+		ch->id,
+		ch->csrc,
+		ch->cdst,
+		ch->cctl,
+		ch->clli,
+		ch->ccfg);
+
+	writel(ch->csrc, ch->base + PL080_CH_SRC_ADDR);
+	writel(ch->cdst, ch->base + PL080_CH_DST_ADDR);
+	writel(ch->clli, ch->base + PL080_CH_LLI);
+	writel(ch->cctl, ch->base + PL080_CH_CONTROL);
+	writel(ch->ccfg, ch->base + PL080_CH_CONFIG);
+}
+
+static inline void pl08x_config_phychan_for_txd(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_channel_data *cd = plchan->cd;
+	struct pl08x_phy_chan *phychan = plchan->phychan;
+	struct pl08x_txd *txd = plchan->at;
+
+	/* Copy the basic control register calculated at transfer config */
+	phychan->csrc = txd->csrc;
+	phychan->cdst = txd->cdst;
+	phychan->clli = txd->clli;
+	phychan->cctl = txd->cctl;
+
+	/* Assign the signal to the proper control registers */
+	phychan->ccfg = cd->ccfg;
+	phychan->ccfg &= ~PL080_CONFIG_SRC_SEL_MASK;
+	phychan->ccfg &= ~PL080_CONFIG_DST_SEL_MASK;
+	/* If it wasn't set from AMBA, ignore it */
+	if (txd->direction == DMA_TO_DEVICE)
+		/* Select signal as destination */
+		phychan->ccfg |=
+			(phychan->signal << PL080_CONFIG_DST_SEL_SHIFT);
+	else if (txd->direction == DMA_FROM_DEVICE)
+		/* Select signal as source */
+		phychan->ccfg |=
+			(phychan->signal << PL080_CONFIG_SRC_SEL_SHIFT);
+	/* Always enable error interrupts */
+	phychan->ccfg |= PL080_CONFIG_ERR_IRQ_MASK;
+	/* Always enable terminal interrupts */
+	phychan->ccfg |= PL080_CONFIG_TC_IRQ_MASK;
+}
+
+/*
+ * Enable the DMA channel
+ * Assumes all other configuration bits have been set
+ * as desired before this code is called
+ */
+static void pl08x_enable_phy_chan(struct pl08x_driver_data *pl08x,
+				  struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	/*
+	 * Do not access config register until channel shows as disabled
+	 */
+	while (readl(pl08x->base + PL080_EN_CHAN) & (1 << ch->id))
+		;
+
+	/*
+	 * Do not access config register until channel shows as inactive
+	 */
+	val = readl(ch->base + PL080_CH_CONFIG);
+	while ((val & PL080_CONFIG_ACTIVE) || (val & PL080_CONFIG_ENABLE))
+		val = readl(ch->base + PL080_CH_CONFIG);
+
+	writel(val | PL080_CONFIG_ENABLE, ch->base + PL080_CH_CONFIG);
+}
+
+/*
+ * Overall DMAC remains enabled always.
+ *
+ * Disabling individual channels could lose data.
+ *
+ * Disable the peripheral DMA after disabling the DMAC
+ * in order to allow the DMAC FIFO to drain, and
+ * hence allow the channel to show inactive
+ *
+ */
+static void pl08x_pause_phy_chan(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	/* Set the HALT bit and wait for the FIFO to drain */
+	val = readl(ch->base + PL080_CH_CONFIG);
+	val |= PL080_CONFIG_HALT;
+	writel(val, ch->base + PL080_CH_CONFIG);
+
+	/* Wait for channel inactive */
+	while (pl08x_phy_channel_busy(ch))
+		;
+}
+
+static void pl08x_resume_phy_chan(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	/* Clear the HALT bit */
+	val = readl(ch->base + PL080_CH_CONFIG);
+	val &= ~PL080_CONFIG_HALT;
+	writel(val, ch->base + PL080_CH_CONFIG);
+}
+
+
+/* Stops the channel */
+static void pl08x_stop_phy_chan(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	pl08x_pause_phy_chan(ch);
+
+	/* Disable channel */
+	val = readl(ch->base + PL080_CH_CONFIG);
+	val &= ~PL080_CONFIG_ENABLE;
+	writel(val, ch->base + PL080_CH_CONFIG);
+}
+
+static inline u32 get_bytes_in_cctl(u32 cctl)
+{
+	/* The source width defines the number of bytes */
+	u32 bytes = cctl & PL080_CONTROL_TRANSFER_SIZE_MASK;
+
+	switch (cctl >> PL080_CONTROL_SWIDTH_SHIFT) {
+	case PL080_WIDTH_8BIT:
+		break;
+	case PL080_WIDTH_16BIT:
+		bytes *= 2;
+		break;
+	case PL080_WIDTH_32BIT:
+		bytes *= 4;
+		break;
+	}
+	return bytes;
+}
+
+/* The channel should be paused when calling this */
+static u32 pl08x_getbytes_chan(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_phy_chan *ch;
+	struct pl08x_txd *txdi = NULL;
+	struct pl08x_txd *txd;
+	unsigned long flags;
+	u32 bytes = 0;
+
+	spin_lock_irqsave(&plchan->lock, flags);
+
+	ch = plchan->phychan;
+	txd = plchan->at;
+
+	/*
+	 * Next follow the LLIs to get the number of pending bytes in the
+	 * currently active transaction.
+	 */
+	if (ch && txd) {
+		struct lli *llis_va = txd->llis_va;
+		struct lli *llis_bus = (struct lli *) txd->llis_bus;
+		u32 clli = readl(ch->base + PL080_CH_LLI);
+
+		/* First get the bytes in the current active LLI */
+		bytes = get_bytes_in_cctl(readl(ch->base + PL080_CH_CONTROL));
+
+		if (clli) {
+			int i = 0;
+
+			/* Forward to the LLI pointed to by clli */
+			while ((clli != (u32) &(llis_bus[i])) &&
+			       (i < MAX_NUM_TSFR_LLIS))
+				i++;
+
+			while (clli) {
+				bytes += get_bytes_in_cctl(llis_va[i].cctl);
+				/*
+				 * A clli of 0x00000000 will terminate the
+				 * LLI list
+				 */
+				clli = llis_va[i].next;
+				i++;
+			}
+		}
+	}
+
+	/* Sum up all queued transactions */
+	if (!list_empty(&plchan->desc_list)) {
+		list_for_each_entry(txdi, &plchan->desc_list, node) {
+			bytes += txdi->len;
+		}
+
+	}
+
+	spin_unlock_irqrestore(&plchan->lock, flags);
+
+	return bytes;
+}
+
+/*
+ * Allocate a physical channel for a virtual channel
+ */
+static struct pl08x_phy_chan *
+pl08x_get_phy_channel(struct pl08x_driver_data *pl08x,
+		      struct pl08x_dma_chan *virt_chan)
+{
+	struct pl08x_phy_chan *ch = NULL;
+	unsigned long flags;
+	int i;
+
+	/*
+	 * Try to locate a physical channel to be used for
+	 * this transfer. If all are taken return NULL and
+	 * the requester will have to cope by using some fallback
+	 * PIO mode or retrying later.
+	 */
+	for (i = 0; i < pl08x->vd->channels; i++) {
+		ch = &pl08x->phy_chans[i];
+
+		spin_lock_irqsave(&ch->lock, flags);
+
+		if (!ch->serving) {
+			ch->serving = virt_chan;
+			ch->signal = -1;
+			spin_unlock_irqrestore(&ch->lock, flags);
+			break;
+		}
+
+		spin_unlock_irqrestore(&ch->lock, flags);
+	}
+
+	if (i == pl08x->vd->channels) {
+		/* No physical channel available, cope with it */
+		return NULL;
+	}
+
+	return ch;
+}
+
+static inline void pl08x_put_phy_channel(struct pl08x_driver_data *pl08x,
+					 struct pl08x_phy_chan *ch)
+{
+	unsigned long flags;
+
+	/* Stop the channel and clear its interrupts */
+	pl08x_stop_phy_chan(ch);
+	writel((1 << ch->id), pl08x->base + PL080_ERR_CLEAR);
+	writel((1 << ch->id), pl08x->base + PL080_TC_CLEAR);
+
+	/* Mark it as free */
+	spin_lock_irqsave(&ch->lock, flags);
+	ch->serving = NULL;
+	ch->signal = -1;
+	spin_unlock_irqrestore(&ch->lock, flags);
+}
+
+/*
+ * LLI handling
+ */
+
+static inline unsigned int pl08x_get_bytes_for_cctl(unsigned int coded)
+{
+	switch (coded) {
+	case PL080_WIDTH_8BIT:
+		return 1;
+	case PL080_WIDTH_16BIT:
+		return 2;
+	case PL080_WIDTH_32BIT:
+		return 4;
+	default:
+		break;
+	}
+	BUG();
+	return 0;
+}
+
+static inline u32 pl08x_cctl_bits(u32 cctl, u8 srcwidth, u8 dstwidth,
+				  u32 tsize)
+{
+	u32 retbits = cctl;
+
+	/* Remove all src, dst and transfersize bits */
+	retbits &= ~PL080_CONTROL_DWIDTH_MASK;
+	retbits &= ~PL080_CONTROL_SWIDTH_MASK;
+	retbits &= ~PL080_CONTROL_TRANSFER_SIZE_MASK;
+
+	/* Then set the bits according to the parameters */
+	switch (srcwidth) {
+	case 1:
+		retbits |= PL080_WIDTH_8BIT << PL080_CONTROL_SWIDTH_SHIFT;
+		break;
+	case 2:
+		retbits |= PL080_WIDTH_16BIT << PL080_CONTROL_SWIDTH_SHIFT;
+		break;
+	case 4:
+		retbits |= PL080_WIDTH_32BIT << PL080_CONTROL_SWIDTH_SHIFT;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	switch (dstwidth) {
+	case 1:
+		retbits |= PL080_WIDTH_8BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	case 2:
+		retbits |= PL080_WIDTH_16BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	case 4:
+		retbits |= PL080_WIDTH_32BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	retbits |= tsize << PL080_CONTROL_TRANSFER_SIZE_SHIFT;
+	return retbits;
+}
+
+/*
+ * Autoselect a master bus to use for the transfer
+ * this prefers the destination bus if both available
+ * if fixed address on one bus the other will be chosen
+ */
+void pl08x_choose_master_bus(struct pl08x_bus_data *src_bus,
+	struct pl08x_bus_data *dst_bus, struct pl08x_bus_data **mbus,
+	struct pl08x_bus_data **sbus, u32 cctl)
+{
+	if (!(cctl & PL080_CONTROL_DST_INCR)) {
+		*mbus = src_bus;
+		*sbus = dst_bus;
+	} else if (!(cctl & PL080_CONTROL_SRC_INCR)) {
+		*mbus = dst_bus;
+		*sbus = src_bus;
+	} else {
+		if (dst_bus->buswidth == 4) {
+			*mbus = dst_bus;
+			*sbus = src_bus;
+		} else if (src_bus->buswidth == 4) {
+			*mbus = src_bus;
+			*sbus = dst_bus;
+		} else if (dst_bus->buswidth == 2) {
+			*mbus = dst_bus;
+			*sbus = src_bus;
+		} else if (src_bus->buswidth == 2) {
+			*mbus = src_bus;
+			*sbus = dst_bus;
+		} else {
+			/* src_bus->buswidth == 1 */
+			*mbus = dst_bus;
+			*sbus = src_bus;
+		}
+	}
+}
+
+/*
+ * Fills in one LLI for a certain transfer descriptor
+ * and advance the counter
+ */
+int pl08x_fill_lli_for_desc(struct pl08x_driver_data *pl08x,
+			    struct pl08x_txd *txd, int num_llis, int len,
+			    u32 cctl, u32 *remainder)
+{
+	struct lli *llis_va = txd->llis_va;
+	struct lli *llis_bus = (struct lli *) txd->llis_bus;
+
+	BUG_ON(num_llis >= MAX_NUM_TSFR_LLIS);
+
+	llis_va[num_llis].cctl		= cctl;
+	llis_va[num_llis].src		= txd->srcbus.addr;
+	llis_va[num_llis].dst		= txd->dstbus.addr;
+
+	/*
+	 * On versions with dual masters, you can optionally AND on
+	 * PL080_LLI_LM_AHB2 to the LLI to tell the hardware to read
+	 * in new LLIs with that controller, but we always try to
+	 * choose AHB1 to point into memory. The idea is to have AHB2
+	 * fixed on the peripheral and AHB1 messing around in the
+	 * memory. So we don't manipulate this bit currently.
+	 */
+
+	llis_va[num_llis].next =
+		(dma_addr_t)((u32) &(llis_bus[num_llis + 1]));
+
+	if (cctl & PL080_CONTROL_SRC_INCR)
+		txd->srcbus.addr += len;
+	if (cctl & PL080_CONTROL_DST_INCR)
+		txd->dstbus.addr += len;
+
+	*remainder -= len;
+
+	return num_llis + 1;
+}
+
+/*
+ * Return number of bytes to fill to boundary, or len
+ */
+static inline u32 pl08x_pre_boundary(u32 addr, u32 len)
+{
+	u32 boundary;
+
+	boundary = ((addr >> PL08X_BOUNDARY_SHIFT) + 1)
+		<< PL08X_BOUNDARY_SHIFT;
+
+	if (boundary < addr + len)
+		return boundary - addr;
+	else
+		return len;
+}
+
+/*
+ * This fills in the table of LLIs for the transfer descriptor
+ * Note that we assume we never have to change the burst sizes
+ * Return 0 for error
+ */
+static int pl08x_fill_llis_for_desc(struct pl08x_driver_data *pl08x,
+			      struct pl08x_txd *txd)
+{
+	struct pl08x_channel_data *cd = txd->cd;
+	struct pl08x_bus_data *mbus, *sbus;
+	u32 remainder;
+	int num_llis = 0;
+	u32 cctl;
+	int max_bytes_per_lli;
+	int total_bytes = 0;
+	struct lli *llis_va;
+	struct lli *llis_bus;
+
+	if (!txd) {
+		dev_err(&pl08x->adev->dev, "%s no descriptor\n", __func__);
+		return 0;
+	}
+
+	txd->llis_va = dma_pool_alloc(pl08x->pool, GFP_KERNEL,
+				      &txd->llis_bus);
+	if (!txd->llis_va) {
+		dev_err(&pl08x->adev->dev, "%s no memory for llis\n", __func__);
+		return 0;
+	}
+
+	pl08x->pool_ctr++;
+
+	/*
+	 * Initialize bus values for this transfer
+	 * from the passed optimal values
+	 */
+	if (!cd) {
+		dev_err(&pl08x->adev->dev, "%s no channel data\n", __func__);
+		return 0;
+	}
+
+	/* Get the default CCTL from the platform data */
+	cctl = cd->cctl;
+
+	/*
+	 * On the PL080 we have two bus masters and we
+	 * should select one for source and one for
+	 * destination. We try to use AHB2 for the
+	 * bus which does not increment (typically the
+	 * peripheral) else we just choose something.
+	 */
+	cctl &= ~(PL080_CONTROL_DST_AHB2 | PL080_CONTROL_SRC_AHB2);
+	if (pl08x->vd->dualmaster) {
+		if (cctl & PL080_CONTROL_SRC_INCR)
+			/* Source increments, use AHB2 for destination */
+			cctl |= PL080_CONTROL_DST_AHB2;
+		else if (cctl & PL080_CONTROL_DST_INCR)
+			/* Destination increments, use AHB2 for source */
+			cctl |= PL080_CONTROL_SRC_AHB2;
+		else
+			/* Just pick something, source AHB1 dest AHB2 */
+			cctl |= PL080_CONTROL_DST_AHB2;
+	}
+
+	/* Find maximum width of the source bus */
+	txd->srcbus.maxwidth =
+		pl08x_get_bytes_for_cctl((cctl & PL080_CONTROL_SWIDTH_MASK) >>
+				       PL080_CONTROL_SWIDTH_SHIFT);
+
+	/* Find maximum width of the destination bus */
+	txd->dstbus.maxwidth =
+		pl08x_get_bytes_for_cctl((cctl & PL080_CONTROL_DWIDTH_MASK) >>
+				       PL080_CONTROL_DWIDTH_SHIFT);
+
+	/* Set up the bus widths to the maximum */
+	txd->srcbus.buswidth = txd->srcbus.maxwidth;
+	txd->dstbus.buswidth = txd->dstbus.maxwidth;
+	dev_vdbg(&pl08x->adev->dev,
+		 "%s source bus is %d bytes wide, dest bus is %d bytes wide\n",
+		 __func__, txd->srcbus.buswidth, txd->dstbus.buswidth);
+
+
+	/*
+	 * Bytes transferred == tsize * MIN(buswidths), not max(buswidths)
+	 */
+	max_bytes_per_lli = min(txd->srcbus.buswidth, txd->dstbus.buswidth) *
+		PL080_CONTROL_TRANSFER_SIZE_MASK;
+	dev_vdbg(&pl08x->adev->dev,
+		 "%s max bytes per lli = %d\n",
+		 __func__, max_bytes_per_lli);
+
+	/* We need to count this down to zero */
+	remainder = txd->len;
+	dev_vdbg(&pl08x->adev->dev,
+		 "%s remainder = %d\n",
+		 __func__, remainder);
+
+	/*
+	 * Choose bus to align to
+	 * - prefers destination bus if both available
+	 * - if fixed address on one bus chooses other
+	 * - modifies cctl to choose an apropriate master
+	 */
+	pl08x_choose_master_bus(&txd->srcbus, &txd->dstbus,
+				&mbus, &sbus, cctl);
+
+
+	/*
+	 * The lowest bit of the LLI register
+	 * is also used to indicate which master to
+	 * use for reading the LLIs.
+	 */
+
+	if (txd->len < mbus->buswidth) {
+		/*
+		 * Less than a bus width available
+		 * - send as single bytes
+		 */
+		while (remainder) {
+			dev_vdbg(&pl08x->adev->dev,
+				 "%s single byte LLIs for a transfer of "
+				 "less than a bus width (remain %08x)\n",
+				 __func__, remainder);
+			cctl = pl08x_cctl_bits(cctl, 1, 1, 1);
+			num_llis =
+				pl08x_fill_lli_for_desc(pl08x, txd, num_llis, 1,
+					cctl, &remainder);
+			total_bytes++;
+		}
+	} else {
+		/*
+		 *  Make one byte LLIs until master bus is aligned
+		 *  - slave will then be aligned also
+		 */
+		while ((mbus->addr) % (mbus->buswidth)) {
+			dev_vdbg(&pl08x->adev->dev,
+				"%s adjustment lli for less than bus width "
+				 "(remain %08x)\n",
+				 __func__, remainder);
+			cctl = pl08x_cctl_bits(cctl, 1, 1, 1);
+			num_llis = pl08x_fill_lli_for_desc
+				(pl08x, txd, num_llis, 1, cctl, &remainder);
+			total_bytes++;
+		}
+
+		/*
+		 *  Master now aligned
+		 * - if slave is not then we must set its width down
+		 */
+		if (sbus->addr % sbus->buswidth) {
+			dev_dbg(&pl08x->adev->dev,
+				"%s set down bus width to one byte\n",
+				 __func__);
+
+			sbus->buswidth = 1;
+		}
+
+		/*
+		 * Make largest possible LLIs until less than one bus
+		 * width left
+		 */
+		while (remainder > (mbus->buswidth - 1)) {
+			int lli_len, target_len;
+			int tsize;
+			int odd_bytes;
+
+			/*
+			 * If enough left try to send max possible,
+			 * otherwise try to send the remainder
+			 */
+			target_len = remainder;
+			if (remainder > max_bytes_per_lli)
+				target_len = max_bytes_per_lli;
+
+			/*
+			 * Set bus lengths for incrementing busses
+			 * to number of bytes which fill to next memory
+			 * boundary
+			 */
+			if (cctl & PL080_CONTROL_SRC_INCR)
+				txd->srcbus.fill_bytes =
+					pl08x_pre_boundary(
+						txd->srcbus.addr,
+						remainder);
+			else
+				txd->srcbus.fill_bytes =
+					max_bytes_per_lli;
+
+			if (cctl & PL080_CONTROL_DST_INCR)
+				txd->dstbus.fill_bytes =
+					pl08x_pre_boundary(
+						txd->dstbus.addr,
+						remainder);
+			else
+				txd->dstbus.fill_bytes =
+						max_bytes_per_lli;
+
+			/*
+			 *  Find the nearest
+			 */
+			lli_len	= min(txd->srcbus.fill_bytes,
+				txd->dstbus.fill_bytes);
+
+			BUG_ON(lli_len > remainder);
+
+			if (lli_len <= 0) {
+				dev_err(&pl08x->adev->dev,
+					"%s lli_len is %d, <= 0\n",
+						__func__, lli_len);
+				return 0;
+			}
+
+			if (lli_len == target_len) {
+				/*
+				 * Can send what we wanted
+				 */
+				/*
+				 *  Maintain alignment
+				 */
+				lli_len	= (lli_len/mbus->buswidth) *
+							mbus->buswidth;
+				odd_bytes = 0;
+			} else {
+				/*
+				 * So now we know how many bytes to transfer
+				 * to get to the nearest boundary
+				 * The next lli will past the boundary
+				 * - however we may be working to a boundary
+				 *   on the slave bus
+				 *   We need to ensure the master stays aligned
+				 */
+				odd_bytes = lli_len % mbus->buswidth;
+				/*
+				 * - and that we are working in multiples
+				 *   of the bus widths
+				 */
+				lli_len -= odd_bytes;
+
+			}
+
+			if (lli_len) {
+				/*
+				 * Check against minimum bus alignment:
+				 * Calculate actual transfer size in relation
+				 * to bus width an get a maximum remainder of
+				 * the smallest bus width - 1
+				 */
+				/* FIXME: use round_down()? */
+				tsize = lli_len / min(mbus->buswidth,
+						      sbus->buswidth);
+				lli_len	= tsize * min(mbus->buswidth,
+						      sbus->buswidth);
+
+				if (target_len != lli_len) {
+					dev_vdbg(&pl08x->adev->dev,
+					"%s can't send what we want. Desired %08x, lli of %08x bytes in txd of %08x\n",
+					__func__, target_len, lli_len, txd->len);
+				}
+
+				cctl = pl08x_cctl_bits(cctl,
+						       txd->srcbus.buswidth,
+						       txd->dstbus.buswidth,
+						       tsize);
+
+				dev_vdbg(&pl08x->adev->dev,
+					"%s fill lli with single lli chunk of size %08x (remainder %08x)\n",
+					__func__, lli_len, remainder);
+				num_llis = pl08x_fill_lli_for_desc(pl08x, txd,
+						num_llis, lli_len, cctl,
+						&remainder);
+				total_bytes += lli_len;
+			}
+
+
+			if (odd_bytes) {
+				/*
+				 * Creep past the boundary,
+				 * maintaining master alignment
+				 */
+				int j;
+				for (j = 0; (j < mbus->buswidth)
+						&& (remainder); j++) {
+					cctl = pl08x_cctl_bits(cctl, 1, 1, 1);
+					dev_vdbg(&pl08x->adev->dev,
+						"%s align with boundardy, single byte (remain %08x)\n",
+						__func__, remainder);
+					num_llis =
+						pl08x_fill_lli_for_desc(pl08x,
+							txd, num_llis, 1,
+							cctl, &remainder);
+					total_bytes++;
+				}
+			}
+		}
+
+		/*
+		 * Send any odd bytes
+		 */
+		if (remainder < 0) {
+			dev_err(&pl08x->adev->dev, "%s remainder not fitted 0x%08x bytes\n",
+					__func__, remainder);
+			return 0;
+		}
+
+		while (remainder) {
+			cctl = pl08x_cctl_bits(cctl, 1, 1, 1);
+			dev_vdbg(&pl08x->adev->dev,
+				"%s align with boundardy, single odd byte (remain %d)\n",
+				__func__, remainder);
+			num_llis = pl08x_fill_lli_for_desc(pl08x, txd, num_llis,
+					1, cctl, &remainder);
+			total_bytes++;
+		}
+	}
+	if (total_bytes != txd->len) {
+		dev_err(&pl08x->adev->dev,
+			"%s size of encoded lli:s don't match total txd, transferred 0x%08x from size 0x%08x\n",
+			__func__, total_bytes, txd->len);
+		return 0;
+	}
+
+	if (num_llis >= MAX_NUM_TSFR_LLIS) {
+		dev_err(&pl08x->adev->dev,
+			"%s need to increase MAX_NUM_TSFR_LLIS from 0x%08x\n",
+			__func__, (u32) MAX_NUM_TSFR_LLIS);
+		return 0;
+	}
+	/*
+	 * Decide whether this is a loop or a terminated transfer
+	 */
+	llis_va = txd->llis_va;
+	llis_bus = (struct lli *) txd->llis_bus;
+
+	if (cd->circular_buffer) {
+		/*
+		 * Loop the circular buffer so that the next element
+		 * points back to the beginning of the LLI.
+		 */
+		llis_va[num_llis - 1].next =
+			(dma_addr_t)((unsigned int)&(llis_bus[0]));
+	} else {
+		/*
+		 * On non-circular buffers, the final LLI terminates
+		 * the LLI.
+		 */
+		llis_va[num_llis - 1].next = 0;
+		/*
+		 * The final LLI element shall also fire an interrupt
+		 */
+		llis_va[num_llis - 1].cctl |= PL080_CONTROL_TC_IRQ_EN;
+	}
+
+	/* Now store the channel register values */
+	txd->csrc = llis_va[0].src;
+	txd->cdst = llis_va[0].dst;
+	if (num_llis > 1)
+		txd->clli = llis_va[0].next;
+	else
+		txd->clli = 0;
+
+	txd->cctl = llis_va[0].cctl;
+	/* ccfg will be set at physical channel allocation time */
+
+#ifdef VERBOSE_DEBUG
+	{
+		int i;
+
+		for (i = 0; i < num_llis; i++) {
+			dev_vdbg(&pl08x->adev->dev,
+				 "lli %d @%p: csrc=%08x, cdst=%08x, cctl=%08x, clli=%08x\n",
+				 i,
+				 &llis_va[i],
+				 llis_va[i].src,
+				 llis_va[i].dst,
+				 llis_va[i].cctl,
+				 llis_va[i].next
+				);
+		}
+	}
+#endif
+
+	return num_llis;
+}
+
+/* You should call this with the struct pl08x lock held */
+static void pl08x_free_txd(struct pl08x_driver_data *pl08x,
+			   struct pl08x_txd *txd)
+{
+	if (!txd)
+		dev_err(&pl08x->adev->dev,
+			"%s no descriptor to free\n",
+			__func__);
+
+	/* Free the LLI */
+	dma_pool_free(pl08x->pool, txd->llis_va,
+		      txd->llis_bus);
+
+	pl08x->pool_ctr--;
+
+	kfree(txd);
+}
+
+static void pl08x_free_txd_list(struct pl08x_driver_data *pl08x,
+				struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_txd *txdi = NULL;
+	struct pl08x_txd *next;
+
+	if (!list_empty(&plchan->desc_list)) {
+		list_for_each_entry_safe(txdi,
+					 next, &plchan->desc_list, node) {
+			list_del(&txdi->node);
+			pl08x_free_txd(pl08x, txdi);
+		}
+
+	}
+}
+
+static void pl08x_tasklet(unsigned long data)
+{
+	struct pl08x_dma_chan *plchan = (struct pl08x_dma_chan *) data;
+	struct pl08x_phy_chan *phychan = plchan->phychan;
+	struct pl08x_driver_data *pl08x = plchan->host;
+	unsigned long flags;
+
+	if (!plchan)
+		BUG();
+
+	spin_lock_irqsave(&plchan->lock, flags);
+
+	if (plchan->at) {
+		dma_async_tx_callback callback =
+			plchan->at->tx.callback;
+		void *callback_param =
+			plchan->at->tx.callback_param;
+
+		/*
+		 * Update last completed
+		 */
+		plchan->lc =
+			(plchan->at->tx.cookie);
+
+		/*
+		 * Callback to signal completion
+		 */
+		if (callback)
+			callback(callback_param);
+
+		/*
+		 * Device callbacks should NOT clear
+		 * the current transaction on the channel
+		 * Linus: sometimes they should?
+		 */
+		if (!plchan->at)
+			BUG();
+
+		/*
+		 * Free the descriptor if it's not for a device
+		 * using a circular buffer
+		 */
+		if (!plchan->at->cd->circular_buffer) {
+			pl08x_free_txd(pl08x, plchan->at);
+			plchan->at = NULL;
+		}
+		/*
+		 * else descriptor for circular
+		 * buffers only freed when
+		 * client has disabled dma
+		 */
+	}
+	/*
+	 * If a new descriptor is queued, set it up
+	 * plchan->at is NULL here
+	 */
+	if (!list_empty(&plchan->desc_list)) {
+		struct pl08x_txd *next;
+
+		next = list_first_entry(&plchan->desc_list,
+					struct pl08x_txd,
+					node);
+		list_del(&next->node);
+		plchan->at = next;
+		/* Configure the physical channel for the next txd */
+		pl08x_config_phychan_for_txd(plchan);
+		pl08x_set_cregs(pl08x, plchan->phychan);
+		pl08x_enable_phy_chan(pl08x, plchan->phychan);
+	} else {
+		/*
+		 * No more jobs, so free up the physical channel
+		 * Free any allocated signal on slave transfers too
+		 */
+		if ((phychan->signal >= 0) && pl08x->pd->put_signal)
+			pl08x->pd->put_signal(plchan);
+		pl08x_put_phy_channel(pl08x, phychan);
+		plchan->phychan = NULL;
+	}
+
+	spin_unlock_irqrestore(&plchan->lock, flags);
+}
+
+static irqreturn_t pl08x_irq(int irq, void *dev)
+{
+	struct pl08x_driver_data *pl08x = dev;
+	u32 mask = 0;
+	u32 val;
+	int i;
+
+	val = readl(pl08x->base + PL080_ERR_STATUS);
+	if (val) {
+		/*
+		 * An error interrupt (on one or more channels)
+		 */
+		dev_err(&pl08x->adev->dev,
+			"%s error interrupt, register value 0x%08x\n",
+				__func__, val);
+		/*
+		 * Simply clear ALL PL08X error interrupts,
+		 * regardless of channel and cause
+		 * FIXME: should be 0x00000003 on PL081 really.
+		 */
+		writel(0x000000FF, pl08x->base + PL080_ERR_CLEAR);
+	}
+	val = readl(pl08x->base + PL080_INT_STATUS);
+	for (i = 0; i < pl08x->vd->channels; i++) {
+		if ((1 << i) & val) {
+			/* Locate physical channel */
+			struct pl08x_phy_chan *phychan = &pl08x->phy_chans[i];
+			struct pl08x_dma_chan *plchan = phychan->serving;
+
+			/* Schedule tasklet on this channel */
+			tasklet_schedule(&plchan->tasklet);
+
+			mask |= (1 << i);
+		}
+	}
+	/*
+	 * Clear only the terminal interrupts on channels we processed
+	 */
+	writel(mask, pl08x->base + PL080_TC_CLEAR);
+
+	return mask ? IRQ_HANDLED : IRQ_NONE;
+}
+
+
+/*
+ * The DMA ENGINE API
+ */
+static int pl08x_alloc_chan_resources(struct dma_chan *chan)
+{
+	return 0;
+}
+
+static void pl08x_free_chan_resources(struct dma_chan *chan)
+{
+}
+
+/*
+ * This should be called with the channel plchan->lock held
+ */
+static int prep_phy_channel(struct pl08x_dma_chan *plchan,
+			    struct pl08x_txd *txd)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_phy_chan *ch;
+	int ret;
+
+	/* Check if we already have a channel */
+	if (plchan->phychan)
+		return 0;
+
+	ch = pl08x_get_phy_channel(pl08x, plchan);
+	if (!ch) {
+		/* No physical channel available, cope with it */
+		dev_dbg(&pl08x->adev->dev, "no physical channel available for xfer on %s\n", plchan->name);
+		return -EBUSY;
+	}
+
+	/*
+	 * OK we have a physical channel: for memcpy() this is all we
+	 * need, but for slaves the physical siglals may be muxed!
+	 * Can the platform allow us to use this channel?
+	 */
+	if ((txd->direction == DMA_FROM_DEVICE ||
+	     txd->direction == DMA_TO_DEVICE) &&
+	    pl08x->pd->get_signal) {
+		ret = pl08x->pd->get_signal(plchan);
+		if (ret < 0) {
+			dev_dbg(&pl08x->adev->dev,
+				"unable to use physical channel %d for transfer on %s due to platform restrictions\n",
+				ch->id, plchan->name);
+			/* Release physical channel & return */
+			pl08x_put_phy_channel(pl08x, ch);
+			return -EBUSY;
+		}
+		ch->signal = ret;
+	}
+
+	dev_dbg(&pl08x->adev->dev, "allocated physical channel %d and signal %d for xfer on %s\n",
+		 ch->id,
+		 ch->signal,
+		 plchan->name);
+
+	plchan->phychan = ch;
+
+	return 0;
+}
+
+/*
+ * First make the LLIs (could/should we do this earlier??)
+ * slave (m/p) - no queued transactions allowed at present
+ *	TODO allow queued transactions for non circular buffers
+ * Set up the channel active txd as inactive
+ * m2m	- transactions may be queued
+ * If no active txd on channel
+ *	set it up as inactive
+ *	- issue_pending() will set active & start
+ * else
+ *	queue it
+ * Lock channel since there may be (at least for m2m) multiple calls
+ *
+ * Return < 0 for error
+ */
+
+static dma_cookie_t pl08x_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	int num_llis;
+	unsigned long flags;
+	struct pl08x_txd *txd = container_of(tx, struct pl08x_txd, tx);
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(tx->chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	int ret;
+
+	num_llis = pl08x_fill_llis_for_desc(pl08x, txd);
+
+	if (!num_llis)
+		return -EINVAL;
+
+	spin_lock_irqsave(&plchan->lock, flags);
+
+	atomic_inc(&plchan->last_issued);
+	tx->cookie = atomic_read(&plchan->last_issued);
+
+	/*
+	 * If this device is not using a circular buffer then
+	 * queue this new descriptor for transfer.
+	 * The descriptor for a circular buffer continues
+	 * to be used until the channel is freed.
+	 */
+	if (txd->cd->circular_buffer)
+		dev_err(&pl08x->adev->dev,
+			"%s attempting to queue a circular buffer\n",
+			__func__);
+	else
+		list_add_tail(&txd->node,
+			      &plchan->desc_list);
+
+	/*
+	 * See if we already have a physical channel allocated,
+	 * else this is the time to try to get one.
+	 */
+	ret = prep_phy_channel(plchan, txd);
+	if (ret) {
+		/* No physical channel available, cope with it */
+		spin_unlock_irqrestore(&plchan->lock, flags);
+		return -EBUSY;
+	}
+
+	spin_unlock_irqrestore(&plchan->lock, flags);
+
+	return tx->cookie;
+}
+
+static struct dma_async_tx_descriptor *pl08x_prep_dma_interrupt(
+		struct dma_chan *chan, unsigned long flags)
+{
+	struct dma_async_tx_descriptor *retval = NULL;
+
+	return retval;
+}
+
+/*
+ * Code accessing dma_async_is_complete() in a tight loop
+ * may give problems - could schedule where indicated.
+ * If slaves are relying on interrupts to signal completion this
+ * function must not be called with interrupts disabled
+ */
+static enum dma_status
+pl08x_dma_tx_status(struct dma_chan *chan,
+		    dma_cookie_t cookie,
+		    struct dma_tx_state *txstate)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	dma_cookie_t last_used;
+	dma_cookie_t last_complete;
+	enum dma_status ret;
+	u32 bytesleft = 0;
+
+	last_used = atomic_read(&plchan->last_issued);
+	last_complete = plchan->lc;
+
+	ret = dma_async_is_complete(cookie, last_complete, last_used);
+	if (ret == DMA_SUCCESS) {
+		dma_set_tx_state(txstate, last_complete, last_used, 0);
+		return ret;
+	}
+
+	/*
+	 * schedule(); could be inserted here
+	 */
+
+	/*
+	 * This cookie not complete yet
+	 */
+	last_used = atomic_read(&plchan->last_issued);
+	last_complete = plchan->lc;
+
+	/* Get number of bytes left in the active transactions and queue */
+	bytesleft = pl08x_getbytes_chan(plchan);
+
+	dma_set_tx_state(txstate, last_complete, last_used,
+			 bytesleft);
+
+	if (plchan->paused)
+		return DMA_PAUSED;
+
+	return DMA_IN_PROGRESS;
+}
+
+/* PrimeCell DMA extension */
+struct burst_table {
+	int burstwords;
+	u32 reg;
+};
+
+static const struct burst_table burst_sizes[] = {
+	{
+		.burstwords = 256,
+		.reg = (PL080_BSIZE_256 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_256 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 128,
+		.reg = (PL080_BSIZE_128 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_128 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 64,
+		.reg = (PL080_BSIZE_64 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_64 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 32,
+		.reg = (PL080_BSIZE_32 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_32 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 16,
+		.reg = (PL080_BSIZE_16 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_16 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 8,
+		.reg = (PL080_BSIZE_8 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_8 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 4,
+		.reg = (PL080_BSIZE_4 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_4 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+	{
+		.burstwords = 1,
+		.reg = (PL080_BSIZE_1 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_1 << PL080_CONTROL_DB_SIZE_SHIFT),
+	},
+};
+
+static void dma_set_runtime_config(struct dma_chan *chan,
+			       struct dma_slave_config *config)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_channel_data *cd = plchan->cd;
+	enum dma_slave_buswidth addr_width;
+	u32 maxburst;
+	u32 cctl = 0;
+	/* Mask out all except src and dst channel */
+	u32 ccfg = cd->ccfg & 0x000003DEU;
+	int i = 0;
+
+	/* Transfer direction */
+	plchan->runtime_direction = config->direction;
+	if (config->direction == DMA_TO_DEVICE) {
+		plchan->runtime_addr = config->dst_addr;
+		cctl |= PL080_CONTROL_SRC_INCR;
+		ccfg |= PL080_FLOW_MEM2PER << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+		addr_width = config->dst_addr_width;
+		maxburst = config->dst_maxburst;
+	} else if (config->direction == DMA_FROM_DEVICE) {
+		plchan->runtime_addr = config->src_addr;
+		cctl |= PL080_CONTROL_DST_INCR;
+		ccfg |= PL080_FLOW_PER2MEM << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+		addr_width = config->src_addr_width;
+		maxburst = config->src_maxburst;
+	} else {
+		dev_err(&pl08x->adev->dev,
+			"bad runtime_config: alien transfer direction\n");
+		return;
+	}
+
+	switch (addr_width) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		cctl |= (PL080_WIDTH_8BIT << PL080_CONTROL_SWIDTH_SHIFT) |
+			(PL080_WIDTH_8BIT << PL080_CONTROL_DWIDTH_SHIFT);
+		break;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		cctl |= (PL080_WIDTH_16BIT << PL080_CONTROL_SWIDTH_SHIFT) |
+			(PL080_WIDTH_16BIT << PL080_CONTROL_DWIDTH_SHIFT);
+		break;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		cctl |= (PL080_WIDTH_32BIT << PL080_CONTROL_SWIDTH_SHIFT) |
+			(PL080_WIDTH_32BIT << PL080_CONTROL_DWIDTH_SHIFT);
+		break;
+	default:
+		dev_err(&pl08x->adev->dev,
+			"bad runtime_config: alien address width\n");
+		return;
+	}
+
+	/*
+	 * Now decide on a maxburst:
+	 * If this channel will only request single transfers, set
+	 * this down to ONE element.
+	 */
+	if (plchan->cd->single) {
+		cctl |= (PL080_BSIZE_1 << PL080_CONTROL_SB_SIZE_SHIFT) |
+			(PL080_BSIZE_1 << PL080_CONTROL_DB_SIZE_SHIFT);
+	} else {
+		while (i < ARRAY_SIZE(burst_sizes)) {
+			if (burst_sizes[i].burstwords <= maxburst)
+				break;
+			i++;
+		}
+		cctl |= burst_sizes[i].reg;
+	}
+
+	/* Access the cell in privileged mode, non-bufferable, non-cacheable */
+	cctl &= ~PL080_CONTROL_PROT_MASK;
+	cctl |= PL080_CONTROL_PROT_SYS;
+
+	/* Modify the default channel data to fit PrimeCell request */
+	cd->cctl = cctl;
+	cd->ccfg = ccfg;
+
+	dev_dbg(&pl08x->adev->dev,
+		"configured channel %s (%s) for %s, data width %d, "
+		"maxburst %d words, LE, CCTL=%08x, CCFG=%08x\n",
+		dma_chan_name(chan), plchan->name,
+		(config->direction == DMA_FROM_DEVICE) ? "RX" : "TX",
+		addr_width,
+		maxburst,
+		cctl, ccfg);
+}
+
+/*
+ * Slave transactions callback to the slave device to allow
+ * synchronization of slave DMA signals with the DMAC enable
+ */
+static void pl08x_issue_pending(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	unsigned long flags;
+
+
+	spin_lock_irqsave(&plchan->lock, flags);
+	/* Something is already active */
+	if (plchan->at) {
+			spin_unlock_irqrestore(&plchan->lock, flags);
+			return;
+	}
+
+	/* Take the first element in the queue and execute it */
+	if (!list_empty(&plchan->desc_list)) {
+		struct pl08x_txd *next;
+
+		next = list_first_entry(&plchan->desc_list,
+					struct pl08x_txd,
+					node);
+		list_del(&next->node);
+		plchan->at = next;
+
+		/* Configure the physical channel for the active txd */
+		pl08x_config_phychan_for_txd(plchan);
+		pl08x_set_cregs(pl08x, plchan->phychan);
+		pl08x_enable_phy_chan(pl08x, plchan->phychan);
+	}
+
+	spin_unlock_irqrestore(&plchan->lock, flags);
+}
+
+/*
+ * Initialize a descriptor to be used by memcpy submit
+ */
+static struct dma_async_tx_descriptor *pl08x_prep_dma_memcpy(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+
+	txd = kzalloc(sizeof(struct pl08x_txd), GFP_KERNEL);
+	if (!txd) {
+		dev_err(&pl08x->adev->dev,
+			"%s no memory for descriptor\n", __func__);
+		return NULL;
+	}
+
+	dma_async_tx_descriptor_init(&txd->tx, chan);
+	txd->direction = DMA_NONE;
+	txd->srcbus.addr = src;
+	txd->dstbus.addr = dest;
+
+	/* Set platform data for m2m */
+	txd->cd = &pl08x->pd->memcpy_channel;
+	/* Both to be incremented or the code will break */
+	txd->cd->cctl |= PL080_CONTROL_SRC_INCR | PL080_CONTROL_DST_INCR;
+	txd->tx.tx_submit = pl08x_tx_submit;
+	txd->tx.callback = NULL;
+	txd->tx.callback_param = NULL;
+	txd->len = len;
+
+	INIT_LIST_HEAD(&txd->node);
+
+	return &txd->tx;
+}
+
+struct dma_async_tx_descriptor *pl08x_prep_slave_sg(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_data_direction direction,
+		unsigned long flags)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+
+	/*
+	 * Current implementation ASSUMES only one sg
+	 */
+	if (sg_len != 1) {
+		dev_err(&pl08x->adev->dev, "%s prepared too long sglist\n",
+			__func__);
+		BUG();
+	}
+
+	dev_dbg(&pl08x->adev->dev, "%s prepare transaction of %d bytes from %s\n",
+		__func__, sgl->length, plchan->name);
+
+	txd = kzalloc(sizeof(struct pl08x_txd), GFP_KERNEL);
+	if (!txd) {
+		dev_err(&pl08x->adev->dev, "%s no txd\n", __func__);
+		return NULL;
+	}
+
+	dma_async_tx_descriptor_init(&txd->tx, chan);
+
+	if (direction != plchan->runtime_direction)
+		dev_err(&pl08x->adev->dev, "%s DMA setup does not match "
+			"the direction configured for the PrimeCell\n",
+			__func__);
+
+	/*
+	 * Set up addresses, the PrimeCell configured address
+	 * will take precedence since this may configure the
+	 * channel target address dynamically at runtime.
+	 */
+	txd->direction = direction;
+	if (direction == DMA_TO_DEVICE) {
+		txd->srcbus.addr = sgl->dma_address;
+		if (plchan->runtime_addr)
+			txd->dstbus.addr = plchan->runtime_addr;
+		else
+			txd->dstbus.addr = plchan->cd->addr;
+	} else if (direction == DMA_FROM_DEVICE) {
+		if (plchan->runtime_addr)
+			txd->srcbus.addr = plchan->runtime_addr;
+		else
+			txd->srcbus.addr = plchan->cd->addr;
+		txd->dstbus.addr = sgl->dma_address;
+	} else {
+		dev_err(&pl08x->adev->dev,
+			"%s direction unsupported\n", __func__);
+		return NULL;
+	}
+	txd->cd = plchan->cd;
+	txd->tx.tx_submit = pl08x_tx_submit;
+	txd->tx.callback = NULL;
+	txd->tx.callback_param = NULL;
+	txd->len = sgl->length;
+	INIT_LIST_HEAD(&txd->node);
+
+	return &txd->tx;
+}
+
+static int pl08x_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			 unsigned long arg)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	unsigned long flags;
+	int ret = 0;
+
+	/* Controls applicable to inactive channels */
+	if (cmd == DMA_SLAVE_CONFIG) {
+		dma_set_runtime_config(chan,
+				       (struct dma_slave_config *)
+				       arg);
+		return 0;
+	}
+
+	/*
+	 * Anything succeeds on channels with no physical allocation and
+	 * no queued transfers.
+	 */
+	spin_lock_irqsave(&plchan->lock, flags);
+	if (!plchan->phychan && !plchan->at) {
+		spin_unlock_irqrestore(&plchan->lock, flags);
+		return 0;
+	}
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		plchan->paused = false;
+
+		if (plchan->phychan) {
+			pl08x_stop_phy_chan(plchan->phychan);
+
+			/*
+			 * Mark physical channel as free and free any slave
+			 * signal
+			 */
+			if ((plchan->phychan->signal >= 0) &&
+			    pl08x->pd->put_signal)
+				pl08x->pd->put_signal(plchan);
+			pl08x_put_phy_channel(pl08x, plchan->phychan);
+			plchan->phychan = NULL;
+		}
+
+		/* Dequeue jobs and free LLIs */
+		if (plchan->at) {
+			pl08x_free_txd(pl08x, plchan->at);
+			pl08x_free_txd_list(pl08x, plchan);
+			plchan->at = NULL;
+		}
+		break;
+	case DMA_PAUSE:
+		pl08x_pause_phy_chan(plchan->phychan);
+		plchan->paused = true;
+		break;
+	case DMA_RESUME:
+		pl08x_resume_phy_chan(plchan->phychan);
+		plchan->paused = false;
+		break;
+	default:
+		/* Unknown command */
+		ret = -ENXIO;
+		break;
+	}
+
+	spin_unlock_irqrestore(&plchan->lock, flags);
+
+	return ret;
+}
+
+bool pl08x_filter_id(struct dma_chan *chan, void *chan_id)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	char *name = chan_id;
+
+	/* Check that the channel is not taken! */
+	if (!strcmp(plchan->name, name))
+		return true;
+
+	return false;
+}
+
+static struct dma_device dmac_memcpy = {
+	.device_alloc_chan_resources	= pl08x_alloc_chan_resources,
+	.device_free_chan_resources	= pl08x_free_chan_resources,
+	.device_prep_dma_memcpy		= pl08x_prep_dma_memcpy,
+	.device_prep_dma_xor		= NULL,
+	.device_prep_dma_memset		= NULL,
+	.device_prep_dma_interrupt	= pl08x_prep_dma_interrupt,
+	.device_tx_status		= pl08x_dma_tx_status,
+	.device_issue_pending		= pl08x_issue_pending,
+	.device_control			= pl08x_control,
+	/*
+	 * Align to 4-byte boundary
+	 * This makes the DMAtests fail with grace on PB1176
+	 * broken DMA hardware instead of locking everything
+	 * up.
+	 */
+	/* .copy_align			= 2, */
+};
+
+static struct dma_device dmac_slave = {
+	.device_alloc_chan_resources	= pl08x_alloc_chan_resources,
+	.device_free_chan_resources	= pl08x_free_chan_resources,
+	.device_prep_dma_xor		= NULL,
+	.device_prep_dma_memset		= NULL,
+	.device_prep_dma_interrupt	= pl08x_prep_dma_interrupt,
+	.device_tx_status		= pl08x_dma_tx_status,
+	.device_issue_pending		= pl08x_issue_pending,
+	.device_prep_slave_sg		= pl08x_prep_slave_sg,
+	.device_control			= pl08x_control,
+};
+
+
+/*
+ * Just check that the device is there and active
+ * TODO: turn this bit on/off depending on the number of
+ * physical channels actually used, if it is zero... well
+ * shut it off. That will save some power. Cut the clock
+ * at the same time.
+ */
+static void pl08x_ensure_on(struct pl08x_driver_data *pl08x)
+{
+	u32 val;
+
+	val = readl(pl08x->base + PL080_CONFIG);
+	val &= ~(PL080_CONFIG_M2_BE | PL080_CONFIG_M1_BE | PL080_CONFIG_ENABLE);
+	/* We implictly clear bit 1 and that means little-endian mode */
+	val |= PL080_CONFIG_ENABLE;
+	writel(val, pl08x->base + PL080_CONFIG);
+}
+
+/*
+ * Initialise the DMAC memcpy/slave channels.
+ * Make a local wrapper to hold required data
+ */
+static int pl08x_dma_init_virtual_channels(struct pl08x_driver_data *pl08x,
+					   struct dma_device *dmadev,
+					   unsigned int channels,
+					   bool slave)
+{
+	struct pl08x_dma_chan *chan;
+	int i;
+
+	INIT_LIST_HEAD(&dmadev->channels);
+	/*
+	 * Register as many many memcpy as we have physical channels,
+	 * we won't always be able to use all but the code will have
+	 * to cope with that situation.
+	 */
+	for (i = 0; i < channels; i++) {
+		chan = kzalloc(sizeof(struct pl08x_dma_chan), GFP_KERNEL);
+		if (!chan) {
+			dev_err(&pl08x->adev->dev,
+				"%s no memory for channel\n", __func__);
+			return -ENOMEM;
+		}
+
+		chan->host = pl08x;
+
+		if (slave) {
+			chan->name = pl08x->pd->slave_channels[i].bus_id;
+			chan->cd = &pl08x->pd->slave_channels[i];
+		} else {
+			chan->cd = &pl08x->pd->memcpy_channel;
+			chan->name = kasprintf(GFP_KERNEL, "memcpy%d", i);
+			if (!chan->name) {
+				kfree(chan);
+				return -ENOMEM;
+			}
+		}
+		dev_info(&pl08x->adev->dev,
+			 "initialize virtual channel \"%s\"\n",
+			 chan->name);
+
+		chan->chan.device = dmadev;
+		atomic_set(&chan->last_issued, 0);
+		chan->lc = atomic_read(&chan->last_issued);
+
+		spin_lock_init(&chan->lock);
+		INIT_LIST_HEAD(&chan->desc_list);
+		tasklet_init(&chan->tasklet, pl08x_tasklet,
+			     (unsigned long) chan);
+
+		list_add_tail(&chan->chan.device_node, &dmadev->channels);
+	}
+	dev_info(&pl08x->adev->dev, "initialized %d virtual %s channels\n",
+		 i, slave ? "slave" : "memcpy");
+	return i;
+}
+
+static int pl08x_probe(struct amba_device *adev, struct amba_id *id)
+{
+	struct pl08x_driver_data *pl08x;
+	struct vendor_data *vd = id->data;
+	int ret = 0;
+	int i;
+
+	ret = amba_request_regions(adev, NULL);
+	if (ret)
+		return ret;
+
+	/* Create the driver state holder */
+	pl08x = kzalloc(sizeof(struct pl08x_driver_data), GFP_KERNEL);
+	if (!pl08x) {
+		ret = -ENOMEM;
+		goto out_no_pl08x;
+	}
+
+	/* Assign useful pointers to the driver state */
+	pl08x->adev = adev;
+	pl08x->vd = vd;
+
+	pl08x->clk = clk_get(&adev->dev, NULL);
+	if (IS_ERR(pl08x->clk)) {
+		ret = PTR_ERR(pl08x->clk);
+		if (ret == -ENOENT) {
+			dev_info(&adev->dev, "no clock supplied, assume always on\n");
+			pl08x->clk = NULL;
+		} else
+			goto out_no_clk;
+	}
+	/* Constantly enabled for now, we can control this dynamically */
+	if (pl08x->clk)
+		clk_enable(pl08x->clk);
+
+	/* A DMA memory pool for LLIs, align on 1-byte boundary */
+	pl08x->pool = dma_pool_create(DRIVER_NAME, &pl08x->adev->dev,
+			PL08X_LLI_TSFR_SIZE, PL08X_ALIGN, 0);
+	if (!pl08x->pool) {
+		ret = -ENOMEM;
+		goto out_no_lli_pool;
+	}
+
+	spin_lock_init(&pl08x->lock);
+
+	pl08x->base = ioremap(adev->res.start, resource_size(&adev->res));
+	if (!pl08x->base) {
+		ret = -ENOMEM;
+		goto out_no_ioremap;
+	}
+
+	/* Turn on the PL08x */
+	pl08x_ensure_on(pl08x);
+
+	/*
+	 * Attach the interrupt handler
+	 */
+	writel(0x000000FF, pl08x->base + PL080_ERR_CLEAR);
+	writel(0x000000FF, pl08x->base + PL080_TC_CLEAR);
+
+	ret = request_irq(adev->irq[0], pl08x_irq, IRQF_DISABLED,
+			  vd->name, pl08x);
+	if (ret) {
+		dev_err(&adev->dev, "%s failed to request interrupt %d\n",
+			__func__, adev->irq[0]);
+		goto out_no_irq;
+	}
+
+	/* Initialize physical channels */
+	pl08x->phy_chans = kmalloc((vd->channels * sizeof(struct pl08x_phy_chan)),
+			GFP_KERNEL);
+	if (!pl08x->phy_chans) {
+		dev_err(&adev->dev, "%s failed to allocate "
+			"physical channel holders\n",
+			__func__);
+		goto out_no_phychans;
+	}
+
+	for (i = 0; i < vd->channels; i++) {
+		struct pl08x_phy_chan *ch = &pl08x->phy_chans[i];
+
+		ch->id = i;
+		ch->base = pl08x->base + PL080_Cx_BASE(i);
+		spin_lock_init(&ch->lock);
+		ch->serving = NULL;
+		ch->signal = -1;
+		dev_info(&adev->dev,
+			 "physical channel %d is %s\n", i,
+			 pl08x_phy_channel_busy(ch) ? "BUSY" : "FREE");
+	}
+
+	/* Get the platform data */
+	pl08x->pd = dev_get_platdata(&adev->dev);
+
+	/* Set caps */
+	dma_cap_set(DMA_MEMCPY, dmac_memcpy.cap_mask);
+	dma_cap_set(DMA_SLAVE, dmac_slave.cap_mask);
+	dmac_memcpy.dev = &adev->dev;
+	dmac_slave.dev = &adev->dev;
+
+	/* Register as many memcpy channels as there are physical channels */
+	ret = pl08x_dma_init_virtual_channels(pl08x, &dmac_memcpy,
+					      pl08x->vd->channels, false);
+	if (ret <= 0) {
+		dev_warn(&pl08x->adev->dev,
+			 "%s failed to enumerate memcpy channels - %d\n",
+			 __func__, ret);
+		goto out_no_memcpy;
+	}
+	dmac_memcpy.chancnt = ret;
+
+	/* Register slave channels */
+	ret = pl08x_dma_init_virtual_channels(pl08x, &dmac_slave,
+					      pl08x->pd->num_slave_channels,
+					      true);
+	if (ret <= 0) {
+		dev_warn(&pl08x->adev->dev,
+			"%s failed to enumerate slave channels - %d\n",
+				__func__, ret);
+		goto out_no_slave;
+	}
+	dmac_slave.chancnt = ret;
+
+	ret = dma_async_device_register(&dmac_memcpy);
+	if (ret) {
+		dev_warn(&pl08x->adev->dev,
+			"%s failed to register memcpy as an async device - %d\n",
+			__func__, ret);
+		goto out_no_memcpy_reg;
+	}
+
+	ret = dma_async_device_register(&dmac_slave);
+	if (ret) {
+		dev_warn(&pl08x->adev->dev,
+			"%s failed to register slave as an async device - %d\n",
+			__func__, ret);
+		goto out_no_slave_reg;
+	}
+
+	amba_set_drvdata(adev, pl08x);
+	dev_info(&pl08x->adev->dev, "ARM(R) %s DMA block initialized @%08x\n",
+		vd->name, adev->res.start);
+	return 0;
+
+out_no_slave_reg:
+	dma_async_device_unregister(&dmac_memcpy);
+out_no_memcpy_reg:
+	/* FIXME: free slave channels */
+out_no_slave:
+	/* FIXME: free memcpy channels */
+out_no_memcpy:
+	kfree(pl08x->phy_chans);
+out_no_phychans:
+	free_irq(adev->irq[0], pl08x);
+out_no_irq:
+	iounmap(pl08x->base);
+out_no_ioremap:
+	dma_pool_destroy(pl08x->pool);
+out_no_lli_pool:
+	clk_put(pl08x->clk);
+out_no_clk:
+	kfree(pl08x);
+out_no_pl08x:
+	amba_release_regions(adev);
+	return ret;
+}
+
+/* PL080 has 8 channels and the PL080 have just 2 */
+static struct vendor_data vendor_pl080 = {
+	.name = "PL080",
+	.channels = 8,
+	.dualmaster = true,
+};
+
+static struct vendor_data vendor_pl081 = {
+	.name = "PL081",
+	.channels = 2,
+	.dualmaster = false,
+};
+
+static struct amba_id pl08x_ids[] = {
+	/* PL080 */
+	{
+		.id	= 0x00041080,
+		.mask	= 0x000fffff,
+		.data	= &vendor_pl080,
+	},
+	/* PL081 */
+	{
+		.id	= 0x00041081,
+		.mask	= 0x000fffff,
+		.data	= &vendor_pl081,
+	},
+	/* Nomadik 8815 PL080 variant */
+	{
+		.id	= 0x00280880,
+		.mask	= 0x00ffffff,
+		.data	= &vendor_pl080,
+	},
+	{ 0, 0 },
+};
+
+static struct amba_driver pl08x_amba_driver = {
+	.drv.name	= DRIVER_NAME,
+	.id_table	= pl08x_ids,
+	.probe		= pl08x_probe,
+};
+
+static int __init pl08x_init(void)
+{
+	int retval;
+	retval = amba_driver_register(&pl08x_amba_driver);
+	if (retval)
+		printk(KERN_WARNING DRIVER_NAME
+		       "failed to register as an amba device (%d)\n",
+		       retval);
+	return retval;
+}
+subsys_initcall(pl08x_init);
diff -Naurp linux-2.6.34.orig/drivers/dma/dmatest.c linux-2.6.34/drivers/dma/dmatest.c
--- linux-2.6.34.orig/drivers/dma/dmatest.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/dma/dmatest.c	2010-09-07 22:16:40.000000000 -0500
@@ -285,7 +285,7 @@ static int dmatest_func(void *data)
 
 	set_user_nice(current, 10);
 
-	flags = DMA_CTRL_ACK | DMA_COMPL_SKIP_DEST_UNMAP | DMA_PREP_INTERRUPT;
+	flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT; //DMA_COMPL_SKIP_DEST_UNMAP removed by Nitin
 
 	while (!kthread_should_stop()
 	       && !(iterations && total_tests >= iterations)) {
diff -Naurp linux-2.6.34.orig/drivers/dma/Kconfig linux-2.6.34/drivers/dma/Kconfig
--- linux-2.6.34.orig/drivers/dma/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/dma/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -36,6 +36,14 @@ comment "DMA Devices"
 config ASYNC_TX_DISABLE_CHANNEL_SWITCH
 	bool
 
+config AMBA_PL08X
+	bool "ARM PrimeCell PL080 or PL081 support"
+	depends on ARM_AMBA && EXPERIMENTAL
+	select DMA_ENGINE
+	help
+	  Platform has a PL08x DMAC device
+	  which can provide DMA engine support
+
 config INTEL_IOATDMA
 	tristate "Intel I/OAT DMA support"
 	depends on PCI && X86
@@ -99,6 +107,19 @@ config MV_XOR
 	---help---
 	  Enable support for the Marvell XOR engine.
 
+config NX_DMAC_1902
+  bool "NXP DMA Controller IP_1902 support"
+  depends on ARCH_APOLLO
+  select DMA_ENGINE
+  help
+    This enables the NXP DMA Controller IP_1902 support.
+
+
+config NX_DMAC_NR_OF_DESCS
+        int "Number of DMAC descriptor per channel"
+        depends on NX_DMAC_1902
+        default "1025"
+
 config MX3_IPU
 	bool "MX3x Image Processing Unit support"
 	depends on ARCH_MX3
@@ -152,6 +173,15 @@ config AMCC_PPC440SPE_ADMA
 config ARCH_HAS_ASYNC_TX_FIND_CHANNEL
 	bool
 
+config PL330_DMA
+	tristate "DMA API Driver for PL330"
+	select DMA_ENGINE
+	depends on PL330
+	help
+	  Select if your platform has one or more PL330 DMACs.
+	  You need to provide platform specific settings via
+	  platform_data for a dma-pl330 device.
+
 config DMA_ENGINE
 	bool
 
diff -Naurp linux-2.6.34.orig/drivers/dma/Makefile linux-2.6.34/drivers/dma/Makefile
--- linux-2.6.34.orig/drivers/dma/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/dma/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -8,6 +8,7 @@ endif
 obj-$(CONFIG_DMA_ENGINE) += dmaengine.o
 obj-$(CONFIG_NET_DMA) += iovlock.o
 obj-$(CONFIG_DMATEST) += dmatest.o
+obj-$(CONFIG_NX_DMAC_1902)  += nx_dmac_1902.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_FSL_DMA) += fsldma.o
@@ -20,3 +21,5 @@ obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
 obj-$(CONFIG_SH_DMAE) += shdma.o
 obj-$(CONFIG_COH901318) += coh901318.o coh901318_lli.o
 obj-$(CONFIG_AMCC_PPC440SPE_ADMA) += ppc4xx/
+obj-$(CONFIG_PL330_DMA) += pl330.o
+obj-$(CONFIG_AMBA_PL08X) += amba-pl08x.o
diff -Naurp linux-2.6.34.orig/drivers/dma/nx_dmac_1902.c linux-2.6.34/drivers/dma/nx_dmac_1902.c
--- linux-2.6.34.orig/drivers/dma/nx_dmac_1902.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dma/nx_dmac_1902.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1626 @@
+/*
+ * Linux kernel DMA framework based controller driver for NXP DMA Controller 
+ * IP_1902
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090528     Draft-Initial version
+ *
+ */
+/*
+ * Driver for the Synopsys DesignWare DMA Controller (aka DMACA on
+ * AVR32 systems.)
+ *
+ * Copyright (C) 2007-2008 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+
+#include "nx_dmac_1902_private.h"
+
+#define DRIVER_NAME          "nx_dmac_1902"
+#define NR_DESCS_PER_CHANNEL  CONFIG_NX_DMAC_NR_OF_DESCS
+
+/* Global declartion of gAsyncCallBackFunct(callback) function */
+dma_async_tx_callback gAsyncCallBackFunct = NULL;
+
+/*Global*/
+struct platform_device *nativePdev;
+
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+static struct device *chan2parent(struct dma_chan *chan)
+{
+	return chan->dev->device.parent;
+}
+
+static struct nx_dmac_1902_desc *nx_dmac_1902_first_active(struct nx_dmac_1902_chan *nxc)
+{
+  return list_entry(nxc->active_list.next, struct nx_dmac_1902_desc, desc_node);
+}
+
+static struct nx_dmac_1902_desc *nx_dmac_1902_first_queued(struct nx_dmac_1902_chan *nxc)
+{
+  return list_entry(nxc->queue.next, struct nx_dmac_1902_desc, desc_node);
+}
+
+static struct nx_dmac_1902_desc *nx_dmac_1902_get_desc(struct nx_dmac_1902_chan *nxc)
+{
+  struct nx_dmac_1902_desc *desc, *_desc;
+  struct nx_dmac_1902_desc *ret = NULL;
+  unsigned int i = 0;
+
+  spin_lock_bh(&(nxc->lock));
+  list_for_each_entry_safe(desc, _desc, &nxc->free_list, desc_node) {
+    if (async_tx_test_ack(&desc->txd)) {
+      list_del(&desc->desc_node);
+      ret = desc;
+      break;
+    }
+    dev_dbg(chan2dev(&nxc->chan), "get_desc: desc %p not ACKed\n", desc);
+    i++;
+  }
+  spin_unlock_bh(&nxc->lock);
+
+  dev_vdbg(chan2dev(&nxc->chan), "get_desc: scanned %u descriptors on freelist\n", i);
+
+  return ret;
+}
+
+static bool is_chan_enabled(struct nx_dmac_1902 *nxd, int chan_num)
+{
+  u32 reg_val;
+
+  reg_val = readl(nxd->regs+NX_DMAC_1902_REG_ENABLED_CHANS);
+  if( (reg_val & ( 1 << chan_num)) )
+    return 1;
+  else
+    return 0;
+}
+
+static void nx_dmac_1902_channel_disable( struct nx_dmac_1902 *nxd, int channel_num)
+{
+  u32 status;
+
+  /*
+   * just do a abrupt disable instead of clean disable. Because, even if the
+   * channel is enabled and has some error with transfer and if caller calls
+   * terminate_all, where it is expected to terminate the transfers which are
+   * in whatever condition it is. So, do not go for a clean disable
+   */
+
+  /* check whether the channel is enabled or not */
+  status = readl(nxd->regs+NX_DMAC_1902_REG_ENABLED_CHANS);
+
+  if( ( status & ( 0x01 << channel_num) ) ) {
+    /* do a clean disable */
+    status = readl(nxd->regs+NX_DMAC_1902_REG_CHAN_BASE(channel_num)+NX_DMAC_1902_REG_CHAN_CONFIG);
+    status &= ~NX_DMAC_1902_DMAC_CHAN_ENABLE;
+    writel(status,(nxd->regs+NX_DMAC_1902_REG_CHAN_BASE(channel_num)+NX_DMAC_1902_REG_CHAN_CONFIG));
+
+    /* wait till the channel is not active */
+    do {
+      status = readl(nxd->regs+NX_DMAC_1902_REG_CHAN_BASE(channel_num)+NX_DMAC_1902_REG_CHAN_CONFIG);
+    } while( ( status & NX_DMAC_1902_DMAC_CHAN_ACTIVE ) > 0);
+  }
+
+  return;
+}
+
+/*nx_disable_wrapper function is supporte for disabling the channel*/
+int nx_disable_wrapper(struct dma_chan *chan)
+{
+  unsigned long flags;
+  struct nx_dmac_1902_chan *nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902	*nxd = to_nx_dmac_1902(nxc->chan.device);
+ 
+   spin_lock_irqsave(&nxc->lock, flags);
+
+   /* just call the nx_dmac_1902_channel_disable for adrupt disable of chan, 
+   clean disable support will be avilable in next version of implemetation */
+   nx_dmac_1902_channel_disable(nxd,chan->chan_id);
+   spin_unlock_irqrestore(&nxc->lock, flags);
+
+   return 0;
+}
+EXPORT_SYMBOL(nx_disable_wrapper);
+
+static void nx_dmac_1902_sync_desc_for_cpu(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_desc *desc)
+{
+  struct nx_dmac_1902_desc	*child;
+
+  list_for_each_entry(child, &desc->tx_list, desc_node)
+    dma_sync_single_for_cpu(chan2parent(&nxc->chan),
+        child->txd.phys, sizeof(child->lli),
+        DMA_TO_DEVICE);
+  dma_sync_single_for_cpu(chan2parent(&nxc->chan),
+      desc->txd.phys, sizeof(desc->lli),
+      DMA_TO_DEVICE);
+}
+
+/*
+ * Move a descriptor, including any children, to the free list.
+ * `desc' must not be on any lists.
+ */
+static void nx_dmac_1902_desc_move_to_freelist(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_desc *desc)
+{
+
+  if (desc) {
+    struct nx_dmac_1902_desc *child;
+    
+    nx_dmac_1902_sync_desc_for_cpu(nxc, desc);
+
+    spin_lock_bh(&nxc->lock);
+    list_for_each_entry(child, &desc->tx_list, desc_node)
+      dev_vdbg(chan2dev(&nxc->chan),
+          "move_to_freelist: moving child desc %p to freelist\n",
+          child);
+    list_splice_init(&desc->tx_list, &nxc->free_list);
+    dev_vdbg(chan2dev(&nxc->chan), "move_to_freelist: moving desc %p to freelist\n", desc);
+    list_add(&desc->desc_node, &nxc->free_list);
+    spin_unlock_bh(&nxc->lock);
+  }
+}
+
+/* Called with nxc->lock held and bh disabled */
+  static dma_cookie_t
+nx_dmac_1902_assign_cookie(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_desc *desc)
+{
+  dma_cookie_t cookie = nxc->chan.cookie;
+
+  if (++cookie < 0)
+    cookie = 1;
+
+  nxc->chan.cookie = cookie;
+  desc->txd.cookie = cookie;
+
+  return cookie;
+}
+
+static void nx_dmac_1902_clear_int_status(struct nx_dmac_1902_chan *nxc)
+{
+  writel((0x01<<nxc->chan_num), nxc->ch_regs+NX_DMAC_1902_REG_INT_ERR_CLEAR); /* clear the error interrupt status */
+  writel((0x01<<nxc->chan_num), nxc->ch_regs+NX_DMAC_1902_REG_INT_TC_CLEAR); /* clear the tc interrupt status */
+  return;
+}
+
+/* Called with nxc->lock held and bh disabled */
+static void nx_dmac_1902_start_xfer(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_desc *first)
+{
+  struct nx_dmac_1902	*nxd = to_nx_dmac_1902(nxc->chan.device);
+
+  /* ASSERT:  channel is idle */
+  if (is_chan_enabled(nxd, nxc->chan_num)) {
+    dev_err(chan2dev(&nxc->chan),
+        "BUG: Attempted to start non-idle channel\n");
+    dev_err(chan2dev(&nxc->chan),
+        "  SAR: 0x%x DAR: 0x%x LLP: 0x%x CTL: 0x%08x CFG:0x%08x\n",
+        readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_SRC_ADDR),
+        readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_DST_ADDR),
+        readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_LLI_ADDR),
+        readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONTROL),
+        readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONFIG));
+    return;
+  }
+
+  dev_vdbg(chan2dev(&nxc->chan),
+      "start_xfer: SAR: 0x%x DAR: 0x%x LLP: 0x%x CTL: 0x%08x CFG:0x%08x\n",
+      first->lli.src_addr, first->lli.dst_addr, first->lli.llp, first->lli.control, first->lli.config);
+
+  nx_dmac_1902_clear_int_status(nxc);
+  writel(first->lli.src_addr, nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_SRC_ADDR);
+  writel(first->lli.dst_addr, nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_DST_ADDR);
+  writel(first->lli.llp, nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_LLI_ADDR);
+  writel(first->lli.control, nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONTROL);
+  writel((first->lli.config | NX_DMAC_1902_DMAC_CHAN_ENABLE), nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONFIG);
+
+  return;
+}
+
+
+int nx_chan_enable_wrapper(struct dma_chan *chan)
+{
+   struct nx_dmac_1902_chan *nxc = to_nx_dmac_1902_chan(chan);
+   unsigned long flags;
+
+   spin_lock_irqsave(&nxc->lock, flags);
+
+   /* check the active queue if its not empty call the queued transfer first */
+   if(!list_empty(&nxc->active_list))
+   {
+      nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_active(nxc));
+   }
+   /* check the queue if its not empty call the queued transfer first */
+   else if (!list_empty(&nxc->queue))
+   {
+      nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_queued(nxc));
+      list_splice_init(&nxc->queue, &nxc->active_list);
+   }
+
+   spin_unlock_irqrestore(&nxc->lock, flags);
+
+   return 0;
+}
+EXPORT_SYMBOL(nx_chan_enable_wrapper);
+
+
+int nx_dmac_1902_async_memcpy_buf_available(
+    struct dma_chan *chan,
+    size_t len)
+{
+  struct nx_dmac_1902_desc *desc, *_desc;
+  unsigned long flags;
+  struct nx_dmac_1902_chan  *nxc = to_nx_dmac_1902_chan(chan);
+  size_t max_size_by_width = (NX_DMAC_1902_MAX_XFER_SIZE * (1<<DMA_SLAVE_WIDTH_32BIT)); 
+  size_t buf_available = 0;
+  int retval = -1;
+
+  spin_lock_irqsave(&(nxc->lock), flags);
+  list_for_each_entry_safe(desc, _desc, &nxc->free_list, desc_node) {
+    if (async_tx_test_ack(&desc->txd)) {
+      buf_available += max_size_by_width;
+      if (buf_available >= len) {
+        retval = 0;
+        break;
+      }
+    }
+  }
+  spin_unlock_irqrestore(&nxc->lock, flags);
+
+  return retval;
+}
+EXPORT_SYMBOL(nx_dmac_1902_async_memcpy_buf_available);
+
+static void nx_dmac_1902_desc_complete(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_desc *desc, NX_DMAC_EVENT event)
+{
+  dma_async_tx_callback		callback;
+  void				*param;
+  struct dma_async_tx_descriptor	*txd = &desc->txd;
+  struct callback_data callbackData;
+
+  dev_vdbg(chan2dev(&nxc->chan), "descriptor %u complete\n", txd->cookie);
+
+  nxc->completed = txd->cookie;
+  callback = txd->callback;
+  param = txd->callback_param;
+
+  nx_dmac_1902_sync_desc_for_cpu(nxc, desc);
+  list_splice_init(&desc->tx_list, &nxc->free_list);
+  list_move(&desc->desc_node, &nxc->free_list);
+
+  if (!nxc->chan.private) {
+     struct device *parent = chan2parent(&nxc->chan);
+     if (!(txd->flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
+        if (txd->flags & DMA_COMPL_DEST_UNMAP_SINGLE)
+           dma_unmap_single(parent, desc->lli.dst_addr, desc->len, DMA_FROM_DEVICE);
+        else
+           dma_unmap_page(parent, desc->lli.dst_addr, desc->len, DMA_FROM_DEVICE);
+     }
+     if (!(txd->flags & DMA_COMPL_SKIP_SRC_UNMAP)) {
+        if (txd->flags & DMA_COMPL_SRC_UNMAP_SINGLE)
+           dma_unmap_single(parent, desc->lli.src_addr, desc->len, DMA_TO_DEVICE);
+        else
+           dma_unmap_page(parent, desc->lli.src_addr, desc->len, DMA_TO_DEVICE);
+     }
+  }
+
+  /*
+   * The API requires that no submissions are done from a
+   * callback, so we don't need to drop the lock here
+   */
+  if (callback)
+  {
+    if(param)
+    {
+        callback(param);
+    }
+    else
+    {        
+        if(event != EVENT_NONE)
+        {
+            callbackData.chanNo = (unsigned int)nxc->chan_num;
+            callbackData.event = event;
+            callbackData.length = desc->len;
+            callbackData.async = desc->cbd.async;
+            callbackData.unit_instance = (void *)desc->cbd.unit_instance;
+            callbackData.pTag = (void *)desc->cbd.pTag;
+            callback(&callbackData);
+        }
+    }
+  }
+
+}
+
+static void nx_dmac_1902_scan_descriptors(struct nx_dmac_1902 *nxd, struct nx_dmac_1902_chan *nxc)
+{
+  dma_addr_t llp;
+  struct nx_dmac_1902_desc *desc, *_desc;
+  struct nx_dmac_1902_desc *child;
+  NX_DMAC_EVENT event;
+
+  /* get the current lli present in the DMAC hardware */
+  llp = readl(nxd->regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_LLI_ADDR);
+  dev_vdbg(chan2dev(&nxc->chan), "scan_descriptors: llp=0x%x\n", llp);
+
+  list_for_each_entry_safe(desc, _desc, &nxc->active_list, desc_node) {
+    if (desc->lli.llp == llp)
+      /* This one is currently in progress */
+      return;
+
+    list_for_each_entry(child, &desc->tx_list, desc_node)
+      if (child->lli.llp == llp)
+        /* Currently in progress */
+        return;
+
+    /* post the event none if no descriptor is found */
+    event = EVENT_NONE;
+
+    /*
+     * No descriptors so far seem to be in progress, i.e.
+     * this one must be done.
+     */
+    nx_dmac_1902_desc_complete(nxc, desc,event);
+  }
+
+  /* 
+   * since if a transfer is already complete, the channel is disabled. 
+   * just start the new transfer if it is queued 
+   * */
+  if (!list_empty(&nxc->queue)) {
+    nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_queued(nxc));
+    list_splice_init(&nxc->queue, &nxc->active_list);
+  }
+}
+
+static void nx_dmac_1902_dump_lli(struct nx_dmac_1902_chan *nxc, struct nx_dmac_1902_lli *lli)
+{
+  dev_crit(chan2dev(&nxc->chan),
+      "  desc: src_addr=0x%08x dst_addr=0x%08x llp=0x%08x control=0x%08x config=0x%08X\n",
+      lli->src_addr, lli->dst_addr, lli->llp, lli->control, lli->config);
+  return;
+}
+
+static void nx_dmac_1902_handle_error(struct nx_dmac_1902 *nxd, struct nx_dmac_1902_chan *nxc)
+{
+  struct nx_dmac_1902_desc *desc, *child;
+  NX_DMAC_EVENT event;
+
+  dev_vdbg(chan2dev(&nxc->chan), "handle_failure: for channel %d\n", nxc->chan_num );
+
+  /* 
+   * here in this, just free up the descriptor and queue the next 
+   * one for trasnfer if it exists 
+   */
+  BUG_ON(list_empty(&nxc->active_list));
+
+  desc = nx_dmac_1902_first_active(nxc);
+  list_del_init(&desc->desc_node);
+
+  /* 
+   * the channel will be automatically disabled, no need to disable 
+   * channel explicitly 
+   */
+
+  nxc->xfer_status = nx_dmac_1902_xfer_status_nothing;
+
+  list_splice_init(&nxc->queue, nxc->active_list.prev); 
+  if (!list_empty(&nxc->queue))
+    nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_queued(nxc));
+
+  /* here just bark about the lli */
+  dev_printk(KERN_CRIT, chan2dev(&nxc->chan), "Bad descriptor submitted for DMA!\n");
+  dev_printk(KERN_CRIT, chan2dev(&nxc->chan), "  cookie: %d\n", desc->txd.cookie);
+  nx_dmac_1902_dump_lli(nxc, &desc->lli);
+  list_for_each_entry(child, &desc->tx_list, desc_node)
+    nx_dmac_1902_dump_lli(nxc, &child->lli);
+
+  /*Post the error event */
+  event = EVENT_ERROR;
+
+  /* call the callback */
+  nx_dmac_1902_desc_complete(nxc, desc,event);
+
+}  
+
+
+static void nx_dmac_1902_handle_success(struct nx_dmac_1902 *nxd, struct nx_dmac_1902_chan *nxc)
+{
+  struct nx_dmac_1902_desc *desc;
+  
+  NX_DMAC_EVENT event;
+
+  dev_vdbg(chan2dev(&nxc->chan), "handle_success: for channel %d\n", nxc->chan_num );
+
+  if( list_empty(&nxc->queue) ) {
+    dev_vdbg(chan2dev(&nxc->chan), "handle_success: begin: queue is EMPTY\n");
+  }
+  else {
+    dev_vdbg(chan2dev(&nxc->chan), "handle_success: begin: queue is NOT EMPTY\n");
+  }
+
+  /* 
+   * here in this, just free up the descriptor and queue the next one for 
+   * trasnfer if it exists 
+   */
+  BUG_ON(list_empty(&nxc->active_list));
+
+  desc = nx_dmac_1902_first_active(nxc);
+  list_del_init(&desc->desc_node);
+
+  nxc->xfer_status = nx_dmac_1902_xfer_status_nothing;
+
+  /* the channel is already disabled, as transfer is succefully completed */
+
+
+  /* 
+   * we are starting another DMA transfer that is queued before calling the
+   * previous transfer callback() 
+   */
+  if (list_empty(&nxc->active_list))
+  {
+  if (!list_empty(&nxc->queue)) {
+    dev_vdbg(chan2dev(&nxc->chan), "handle_success: queue is not empty. Starting that transfer\n");
+    list_splice_init(&nxc->queue, &nxc->active_list);
+  }
+  else {
+    dev_vdbg(chan2dev(&nxc->chan), "handle_success: Queue is EMPTY!!!\n");
+  }
+  }
+
+  if (!list_empty(&nxc->active_list)) {
+       nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_active(nxc));
+  }
+
+  /* Post the event complete */
+  event = EVENT_COMPLETE;
+
+  /* call the callback */
+  nx_dmac_1902_desc_complete(nxc, desc,event);
+}  
+
+
+static void nx_dmac_1902_tasklet(unsigned long data)
+{
+  struct nx_dmac_1902 *nxd = (struct nx_dmac_1902 *)data;
+  struct nx_dmac_1902_chan *nxc;
+  int i;
+
+  for (i = 0; i < nxd->num_channels; i++) {
+    nxc = &nxd->chan[i];
+
+    spin_lock(&nxc->lock);
+    if((nxc->xfer_status == nx_dmac_1902_xfer_status_failed )) {
+      dev_vdbg(chan2dev(&nxc->chan), "tasklet: xfer_failed for channel %d\n", nxc->chan_num );
+      nx_dmac_1902_handle_error(nxd, nxc);
+    }
+    else if((nxc->xfer_status == nx_dmac_1902_xfer_status_completed )) {
+      dev_vdbg(chan2dev(&nxc->chan), "tasklet: xfer_completed for channel %d\n", nxc->chan_num );
+      nx_dmac_1902_handle_success(nxd, nxc);
+    }
+    else {
+      /* this should not come here at all */
+    }
+    spin_unlock(&nxc->lock);
+  }
+  return;   
+}
+
+static irqreturn_t nx_dmac_1902_isr(int irq, void *dev_id)
+{
+  /*
+   * here we will clear the interrupt TC status and interrupt ERR status and 
+   * then schedule a tasklet which will take care of going through the RAW 
+   * interrupt status and call the callbacks of those descriptors which 
+   * is complete
+   *
+   * The lli, src addr, dst addr etc are still be present in the channel register
+   */
+  struct nx_dmac_1902 *nxd = (struct nx_dmac_1902 *) dev_id;
+  struct nx_dmac_1902_chan *nxc = &nxd->chan[0];
+  u32 int_status;
+  u32 int_tc_status;
+  u32 int_err_status;
+  u32 int_raw_tc_status;
+  u32 int_raw_err_status;
+  int i;
+
+  dev_vdbg(nxd->dma.dev, "nx_dmac_1902_isr: got interrupt\n");
+
+  int_status = readl(nxd->regs);
+  if( !(int_status & 0xFF )) {
+    /* spurious interrupt. just return with IRQ_HANDLED */
+    return IRQ_HANDLED;
+  }
+
+  int_tc_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_TC_STATUS);
+  int_err_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_ERR_STATUS);
+  int_raw_tc_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_RAW_TC_STATUS);
+  int_raw_err_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_RAW_ERR_STATUS);
+
+  dev_vdbg(nxd->dma.dev, "  tc_status      = 0x%08x\n", int_tc_status);
+  dev_vdbg(nxd->dma.dev, "  err_status     = 0x%08x\n", int_err_status);
+  dev_vdbg(nxd->dma.dev, "  raw_tc_status  = 0x%08x\n", int_raw_tc_status);
+  dev_vdbg(nxd->dma.dev, "  raw_err_status = 0x%08x\n", int_raw_err_status);
+
+  /**
+   * Here just read the interrupt status and then post the same status onto the
+   * channel specific structure, indicating that the interrupt has occured and
+   * transfser completion/failure status is set.
+   */
+  for(i=0; i < nxd->num_channels; i++) {
+    nxc = &nxd->chan[i];
+    if(int_tc_status & (0x01 << i)) {
+      nxc->xfer_status = nx_dmac_1902_xfer_status_completed;
+    }
+    else if(int_err_status & (0x01 << i)) {
+      nxc->xfer_status = nx_dmac_1902_xfer_status_failed;
+    }
+    else {
+      /* this condition will not arise at all */
+    }
+  }
+
+  /* clear the interrupts */
+  writel(int_tc_status, nxd->regs+NX_DMAC_1902_REG_INT_TC_CLEAR);
+  writel(int_err_status, nxd->regs+NX_DMAC_1902_REG_INT_ERR_CLEAR);
+
+  tasklet_schedule(&nxd->tasklet);
+
+  return IRQ_HANDLED;
+}
+
+void nx_dmac_1902_set_async_tx_callback_funct(dma_async_tx_callback funct)
+{
+    gAsyncCallBackFunct = funct;
+}
+EXPORT_SYMBOL(nx_dmac_1902_set_async_tx_callback_funct);
+
+void nx_dmac_1902_set_async_tx_callback_param(struct dma_chan *chan, void *param)
+{
+   struct nx_dmac_1902_chan *nxc = to_nx_dmac_1902_chan(chan);
+
+   memcpy(&nxc->cbd, param, sizeof(struct callback_data));
+}
+EXPORT_SYMBOL(nx_dmac_1902_set_async_tx_callback_param);
+
+void nx_dmac_1902_async_tx_callback(void *dma_async_param) 
+{
+    if(!gAsyncCallBackFunct)
+        gAsyncCallBackFunct(dma_async_param);
+}
+
+static dma_cookie_t nx_dmac_1902_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+  struct nx_dmac_1902_desc	*desc = txd_to_nx_dmac_1902_desc(tx);
+  struct nx_dmac_1902_chan	*nxc = to_nx_dmac_1902_chan(tx->chan);
+  dma_cookie_t	cookie;
+
+  dev_vdbg(chan2dev(tx->chan), "tx_submit: chan: %d\n", nxc->chan_num);
+
+  if(!tx->callback)
+      tx->callback = nx_dmac_1902_async_tx_callback; 
+
+  spin_lock_bh(&nxc->lock);
+  cookie = nx_dmac_1902_assign_cookie(nxc, desc);
+
+  if (list_empty(&nxc->active_list)) {
+    dev_vdbg(chan2dev(tx->chan), "tx_submit: chan: %d started %u\n",
+        nxc->chan_num, desc->txd.cookie);
+    nx_dmac_1902_start_xfer(nxc, desc);    
+    list_add_tail(&desc->desc_node, &nxc->active_list);
+  } else {
+    dev_vdbg(chan2dev(tx->chan), "tx_submit: chan: %d queued %u\n",
+        nxc->chan_num, desc->txd.cookie);
+    list_add_tail(&desc->desc_node, &nxc->queue);
+
+    if(list_empty(&nxc->queue)){
+      dev_vdbg(chan2dev(tx->chan), "tx_submit: queue is empty !! which is just queued???\n");
+    }
+    else {
+      dev_vdbg(chan2dev(tx->chan), "tx_submit: queue is not empty !!thats great\n");
+    }
+  }
+  spin_unlock_bh(&nxc->lock);
+
+  return cookie;
+}
+
+static struct dma_async_tx_descriptor * nx_dmac_1902_prep_dma_memcpy( 
+    struct dma_chan *chan, 
+    dma_addr_t dest, 
+    dma_addr_t src,	
+    size_t len, 
+    unsigned long flags)
+{
+  struct nx_dmac_1902_chan  *nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902_desc  *desc;
+  struct nx_dmac_1902_desc  *first;
+  struct nx_dmac_1902_desc  *prev;
+  size_t                     xfer_count;
+  size_t                     offset;
+  u32                        control;
+  unsigned int		           src_width;
+  unsigned int		           dst_width;
+  size_t                     max_size_by_width;
+
+  dev_dbg(chan2dev(chan), "memcpy d0x%x s0x%x l0x%zx f0x%lx\n", dest, src, len, flags);
+
+  if (unlikely(!len)) {
+    dev_err(chan2dev(chan), "  memcpy: length is zero!\n");
+    return NULL;
+  }
+
+  /* 
+   * the information about the slave is specified in the nx_dmac_1902_chan structure. 
+   * So get the following information:
+   nx_dmac_1902_chan->src_per_num; --> always 0
+   nx_dmac_1902_chan->dst_per_num; --> always 0
+   nx_dmac_1902_chan->src_burst; --> caller has to fill it
+   nx_dmac_1902_chan->dst_burst; --> caller has to fill it.
+   nx_dmac_1902_chan->src_incr; --> always 1
+   nx_dmac_1902_chan->dst_incr; --> always 1
+   nx_dmac_1902_chan->flow_cntrl; --> always nx_dmac_1902_fcntl_DMA_M_to_M to be enabled in tx_submit()
+   nx_dmac_1902_chan->src_select; --> caller has to fill it
+   nx_dmac_1902_chan->dst_select; --> caller has to fill it
+   dma_slave->reg_width; --> caller has to fill it 
+   */
+
+  /*
+   * always handled only source_width=dest_width
+   */
+#if 0
+  dev_vdbg(chan2dev(chan), "  memcpy: src_burst:   %d\n", nxs->src_burst);
+  dev_vdbg(chan2dev(chan), "  memcpy: dst_burst:   %d\n", nxs->dst_burst);
+  dev_vdbg(chan2dev(chan), "  memcpy: src_select:  %d\n", nxs->src_select);
+  dev_vdbg(chan2dev(chan), "  memcpy: dst_select:  %d\n", nxs->dst_select);
+  dev_vdbg(chan2dev(chan), "  memcpy: width:       %d\n", nxs->reg_width);
+#endif
+	/*
+	 * We can be a lot more clever here, but this should take care
+	 * of the most common optimization.
+	 */
+	if (!((src | dest  | len) & 3))
+		src_width = dst_width = DMA_SLAVE_WIDTH_32BIT;
+	else if (!((src | dest | len) & 1))
+		src_width = dst_width = DMA_SLAVE_WIDTH_16BIT;
+	else
+		src_width = dst_width = DMA_SLAVE_WIDTH_8BIT;
+
+  max_size_by_width = (NX_DMAC_1902_MAX_XFER_SIZE * (1<<src_width));
+
+  prev = first = NULL;
+  for (offset = 0; offset < len; ) {
+    xfer_count = min_t(size_t, (len - offset), max_size_by_width);
+    desc = nx_dmac_1902_get_desc(nxc);
+    if(!desc)
+      goto _err_get_desc;
+
+    /* got the LLI, just fill it */
+    desc->lli.src_addr = src + offset;
+    desc->lli.dst_addr = dest + offset;
+    control = 0;
+
+    control |= NX_DMAC_1902_CHAN_CNTRL_HPROT(NX_DMAC_1902_HPROT_PRIVILEGE_MODE);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_INCR(1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(dst_width);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(src_width);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_BURST(nx_dmac_1902_burst_256);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(nx_dmac_1902_burst_256);
+    control |= (xfer_count/(1<<src_width));
+
+    /* 
+     * the length will always be aligned with reg_width and is always 
+     * divisible by reg_width
+     */
+    desc->lli.control = control;
+
+    desc->lli.config = NX_DMAC_1902_UNMASK_INT; /* memory to mem transfer */
+
+    if (!first) {
+      first = desc;
+    } else {
+      prev->lli.llp = desc->txd.phys;
+      dma_sync_single_for_device(chan2parent(chan),
+          prev->txd.phys, sizeof(prev->lli),
+          DMA_TO_DEVICE);
+      list_add_tail(&desc->desc_node,
+          &first->tx_list);
+    }
+    prev = desc;
+    offset += xfer_count;
+
+#if 0
+    dev_err(chan2dev(&nxc->chan),
+        "  desc: src_addr=0x%08x dst_addr=0x%08x control=0x%08x config=0x%08X xfer_count=%d\n",
+        desc->lli.src_addr, desc->lli.dst_addr, desc->lli.control, desc->lli.config, xfer_count);
+#endif
+  }
+
+  /* 
+   * since the caller (dma_async_memcpy_*) functions do not pass 
+   * DMA_PREP_INTERRUPT flag, by default we are enabling the int for 
+   * tc and err
+   */
+  prev->lli.control |= NX_DMAC_1902_INT_ENABLE;
+  prev->lli.llp = 0;
+  dma_sync_single_for_device(chan2parent(chan),
+      prev->txd.phys, sizeof(prev->lli),
+      DMA_TO_DEVICE);
+
+  first->txd.flags = flags;
+  first->len = len;
+  memcpy(&(first->cbd), &(nxc->cbd), sizeof(struct callback_data));
+
+  return &first->txd;
+
+_err_get_desc:
+  dev_dbg(chan2dev(&nxc->chan), "  memcpy: All descriptors are exhausted for channel %d\n", nxc->chan_num);
+  nx_dmac_1902_desc_move_to_freelist(nxc, first);
+  return NULL;
+}
+
+static struct dma_async_tx_descriptor * nx_dmac_1902_prep_dma_memset(
+    struct dma_chan *chan,
+    dma_addr_t dest,
+    int value,
+    size_t len,
+    unsigned long flags)
+{
+  struct nx_dmac_1902_chan  *nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902_desc  *desc;
+  struct nx_dmac_1902_desc  *first;
+  struct nx_dmac_1902_desc  *prev;
+  size_t                     xfer_count;
+  size_t                     offset;
+  u32                        control;
+  unsigned int		           dst_width;  
+  size_t                     max_size_by_width;
+
+  dev_vdbg( chan2dev(chan), "memset d0x%x l0x%zx f0x%lx v0x%X\n", dest, len, flags, value);
+
+  if (unlikely(!len)) {
+    dev_dbg(chan2dev(chan), "  memset: length is zero!\n");
+    return NULL;
+  }
+
+  /* 
+   * the information about the slave is specified in the nx_dmac_1902_chan 
+   * structure. So get the following information:
+   nx_dmac_1902_chan->src_per_num; --> always 0
+   nx_dmac_1902_chan->dst_per_num; --> always 0
+   nx_dmac_1902_chan->src_burst; --> caller has to fill it
+   nx_dmac_1902_chan->dst_burst; --> caller has to fill it.
+   nx_dmac_1902_chan->src_incr; --> always 0
+   nx_dmac_1902_chan->dst_incr; --> always 1
+   nx_dmac_1902_chan->flow_cntrl; --> always nx_dmac_1902_fcntl_DMA_M_to_M to be enabled in tx_submit()
+   nx_dmac_1902_chan->src_select; --> caller has to fill it
+   nx_dmac_1902_chan->dst_select; --> caller has to fill it
+   dma_slave->reg_width; --> caller has to fill it
+
+*/
+
+  /*
+   * always handled only source_width=dest_width
+   */
+#if 0
+  dev_vdbg(chan2dev(chan), "  memset: src_burst:   %d\n", nxs->src_burst);
+  dev_vdbg(chan2dev(chan), "  memset: dst_burst:   %d\n", nxs->dst_burst);
+  dev_vdbg(chan2dev(chan), "  memset: src_select:  %d\n", nxs->src_select);
+  dev_vdbg(chan2dev(chan), "  memset: dst_select:  %d\n", nxs->dst_select);
+  dev_vdbg(chan2dev(chan), "  memset: width:       %d\n", nxs->reg_width);
+#endif
+
+	/*
+	 * We can be a lot more clever here, but this should take care
+	 * of the most common optimization.
+	 */
+	if (!((dest  | len) & 3))
+		dst_width = DMA_SLAVE_WIDTH_32BIT;
+	else if (!((dest | len) & 1))
+		dst_width = DMA_SLAVE_WIDTH_16BIT;
+	else
+		dst_width = DMA_SLAVE_WIDTH_8BIT;
+
+  max_size_by_width = (NX_DMAC_1902_MAX_XFER_SIZE * (1<<dst_width));
+
+  prev = first = NULL;
+  for (offset = 0; offset < len; ) {
+    xfer_count = min_t(size_t, (len - offset), max_size_by_width);
+    desc = nx_dmac_1902_get_desc(nxc);
+    if(!desc)
+      goto _err_get_desc;
+
+
+    /* got the LLI, just fill it */
+    desc->lli.src_addr = desc->p_addr_memset;
+    desc->lli.val_memset = value;
+    desc->lli.dst_addr = dest + offset;
+    control = 0;
+
+    control |= NX_DMAC_1902_CHAN_CNTRL_HPROT(NX_DMAC_1902_HPROT_PRIVILEGE_MODE);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_INCR(1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(0);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(dst_width);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(dst_width);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_BURST(nx_dmac_1902_burst_256);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(nx_dmac_1902_burst_256);
+    control |= (xfer_count/(1<<dst_width));
+
+    desc->lli.control = control;
+    desc->lli.config = NX_DMAC_1902_UNMASK_INT; /* memory to mem transfer */
+
+    if (!first) {
+      first = desc;
+    } else {
+      prev->lli.llp = desc->txd.phys;
+      dma_sync_single_for_device(chan2parent(chan),
+          prev->txd.phys, sizeof(prev->lli),
+          DMA_TO_DEVICE);
+      list_add_tail(&desc->desc_node,
+          &first->tx_list);
+    }
+    prev = desc;
+    offset += xfer_count;
+#if 0
+    dev_vdbg(chan2dev(&nxc->chan),
+        "  desc: src_addr=0x%08x dst_addr=0x%08x control=0x%08x config=0x%08X xfer_count=%d\n",
+        desc->lli.src_addr, desc->lli.dst_addr, desc->lli.control, desc->lli.config, xfer_count);
+#endif
+  }
+
+  /* 
+   * similar to dma_async_memcpy_* functions, we will by default enabling 
+   * the int for tc and err 
+   */
+
+  prev->lli.control |= NX_DMAC_1902_INT_ENABLE;
+  prev->lli.llp = 0;
+  dma_sync_single_for_device(chan2parent(chan),
+      prev->txd.phys, sizeof(prev->lli),
+      DMA_TO_DEVICE);
+
+  first->txd.flags = flags;
+  first->len = len;
+
+  return &first->txd;
+
+_err_get_desc:
+  dev_dbg(chan2dev(&nxc->chan), "  memset: All descriptors are exhausted for channel %d\n", nxc->chan_num);
+  nx_dmac_1902_desc_move_to_freelist(nxc, first);
+  return NULL;
+
+}
+
+static struct dma_async_tx_descriptor * nx_dmac_1902_prep_slave_sg(
+    struct dma_chan *chan, 
+    struct scatterlist *sgl,
+    unsigned int sg_len, 
+    enum dma_data_direction direction,
+    unsigned long flags)
+{
+  struct nx_dmac_1902_chan  *nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902_slave *nxs = chan->private;
+  struct nx_dmac_1902_desc  *first;
+  struct nx_dmac_1902_desc  *prev;
+  size_t                     xfer_count;
+  size_t                     offset;
+  u32                        control;
+  u32                        l_control;
+  unsigned int	             i;
+  dma_addr_t		             reg;
+  struct scatterlist	      *sg;
+  size_t                     max_size_by_width;
+  u32 len=0;
+  u32 mem=0;
+
+  /*
+   * the information about the slave is specified in the nx_dmac_1902_chan 
+   * structure. So get the following information:
+   nx_dmac_1902_chan->src_per_num; --> caller has to fill it
+   nx_dmac_1902_chan->dst_per_num; --> caller has to fill it
+   nx_dmac_1902_chan->src_burst; --> caller has to fill it
+   nx_dmac_1902_chan->dst_burst; --> caller has to fill it.
+   nx_dmac_1902_chan->src_incr; --> caller has to fill it
+   nx_dmac_1902_chan->dst_incr; --> caller has to fill it
+   nx_dmac_1902_chan->flow_cntrl; --> caller has to fill it
+   nx_dmac_1902_chan->src_select; --> caller has to fill it
+   nx_dmac_1902_chan->dst_select; --> caller has to fill it
+   nx_dmac_1902_chan->src_width; --> caller has to fill it
+   nx_dmac_1902_chan->dst_width; --> caller has to fill it
+   dma_slave->tx_reg --> caller has to fill it
+   dma_slave->rx_reg --> caller has to fill it
+   */
+
+  if (unlikely(!nxs || !sg_len)) {
+    dev_dbg(chan2dev(chan), "  slave_sg: dma_slave structure is NULL or sg_len is zero!\n");
+    return NULL;
+  }
+
+  BUG_ON(nxs->flow_cntrl==nx_dmac_1902_fcntl_DMA_M_to_M);
+
+  prev = first = NULL;
+
+#if 0
+  dev_vdbg(&chan->dev, "  slave_sg: src_per_num: %d\n", nxs->src_per_num);
+  dev_vdbg(&chan->dev, "  slave_sg: dst_per_num: %d\n", nxs->dst_per_num);
+  dev_vdbg(&chan->dev, "  slave_sg: src_burst:   %d\n", nxs->src_burst);
+  dev_vdbg(&chan->dev, "  slave_sg: dst_burst:   %d\n", nxs->dst_burst);
+  dev_vdbg(&chan->dev, "  slave_sg: src_incr:    %d\n", nxs->src_incr);
+  dev_vdbg(&chan->dev, "  slave_sg: dst_incr:    %d\n", nxs->dst_incr);
+  dev_vdbg(&chan->dev, "  slave_sg: flow_cntrl:  %d\n", nxs->flow_cntrl);
+  dev_vdbg(&chan->dev, "  slave_sg: src_select:  %d\n", nxs->src_select);
+  dev_vdbg(&chan->dev, "  slave_sg: dst_select:  %d\n", nxs->dst_select);
+  dev_vdbg(&chan->dev, "  slave_sg: src_width:   %d\n", nxs->src_width);
+  dev_vdbg(&chan->dev, "  slave_sg: dst_width:   %d\n", nxs->dst_width);
+#endif
+
+#if 0
+  sg_len = dma_map_sg(chan2parent(chan), sgl, sg_len, direction);
+  if(sg_len == 0) {
+    dev_err(chan2dev(chan), "  slave_sg: dma_map_sg is failed\n");
+    return NULL;
+  }
+#endif
+
+  control = 0;
+  control |= NX_DMAC_1902_CHAN_CNTRL_HPROT(NX_DMAC_1902_HPROT_PRIVILEGE_MODE | NX_DMAC_1902_HPROT_CACHEABLE);
+  control |= NX_DMAC_1902_CHAN_CNTRL_DST_INCR(nxs->dst_incr);
+  control |= NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(nxs->src_incr);
+  control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nxs->dst_select);
+  control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nxs->src_select);
+  control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(nxs->dst_width);
+  control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(nxs->src_width);
+  control |= NX_DMAC_1902_CHAN_CNTRL_DST_BURST(nxs->dst_burst);
+  control |= NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(nxs->src_burst);
+
+  /* 
+   * the size of data transfer depends upon the width of the source only.
+   * This is what I understand
+   * and this is applicable only if the DMAC act as flow controller
+   */
+  max_size_by_width = (NX_DMAC_1902_MAX_XFER_SIZE * (1<<nxs->src_width));
+
+  switch (direction) {
+    case DMA_TO_DEVICE:
+
+      BUG_ON(!((nxs->flow_cntrl==nx_dmac_1902_fcntl_DMA_M_to_P) ||( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_M_to_P)) );
+      reg = nxs->tx_reg;
+
+      for_each_sg(sgl, sg, sg_len, i) {
+        struct nx_dmac_1902_desc  *desc;
+
+    	mem = sg_phys(sg);
+		len = sg_dma_len(sg);
+        
+        if( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_M_to_P) {
+          /*
+           * peripheral is the flow controller, hence DMAC does not have 
+           * control over transfer count. making len=1 just to allocate one 
+           * descriptor and break from switch 
+           */
+          len = 1;
+        }
+
+        for (offset = 0; offset < len; ) {
+          xfer_count = min_t(size_t, (len - offset), max_size_by_width);
+
+          desc = nx_dmac_1902_get_desc(nxc);
+          if(!desc)
+            goto _err_get_desc;
+
+          /* got the LLI, just fill it */
+          desc->lli.src_addr = mem + offset;
+          desc->lli.dst_addr = reg;
+          l_control = control;
+          desc->lli.config = 0;
+
+          if( nxs->flow_cntrl == nx_dmac_1902_fcntl_DMA_M_to_P) {
+            l_control |= (xfer_count/(1<<nxs->src_width));
+            desc->lli.config = NX_DMAC_1902_UNMASK_INT; /* this is valid only if the flow controller is DMAC */
+          }
+          else if( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_M_to_P) {
+            /* 
+             * peripheral is the flow controller, hence DMAC does not have 
+             * control over transfer count 
+             */
+          }
+          else {
+            /* this type of transfer is not supported. ?????? */
+          }
+          desc->lli.control = l_control;
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_FLOWCNTRL(nxs->flow_cntrl);
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_SRC_PER(0);
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_DST_PER(nxs->dst_per_num);
+
+          if (!first) {
+            first = desc;
+          } else {
+            prev->lli.llp = desc->txd.phys;
+            dma_sync_single_for_device(chan2parent(chan),
+                prev->txd.phys,
+                sizeof(prev->lli),
+                DMA_TO_DEVICE);
+            list_add_tail(&desc->desc_node,
+                &first->tx_list);
+          }
+          prev = desc;
+          offset += xfer_count;
+#if 0
+          dev_vdbg(chan2dev(&nxc->chan),
+              "  desc: src_addr=0x%08x dst_addr=0x%08x control=0x%08x config=0x%08X xfer_count=%d\n",
+              desc->lli.src_addr, desc->lli.dst_addr, desc->lli.control, desc->lli.config, xfer_count);
+#endif
+        }
+      }
+      break;
+
+    case DMA_FROM_DEVICE:
+
+      BUG_ON(!((nxs->flow_cntrl==nx_dmac_1902_fcntl_DMA_P_to_M) ||( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_P_to_M)) );
+
+      reg = nxs->rx_reg;
+
+      for_each_sg(sgl, sg, sg_len, i) {
+        struct nx_dmac_1902_desc  *desc;
+
+        mem = sg_phys(sg);
+        len = sg_dma_len(sg);
+
+        if( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_P_to_M) {
+          /* 
+           * peripheral is the flow controller, hence DMAC does not have 
+           * control over transfer count. making len=1 just to allocate one 
+           * descriptor and break from switch 
+           */
+          len = 1;
+        }
+
+        for (offset = 0; offset < len; ) {
+          xfer_count = min_t(size_t, (len - offset), max_size_by_width);
+
+          desc = nx_dmac_1902_get_desc(nxc);
+          if(!desc)
+            goto _err_get_desc;
+
+          /* got the LLI, just fill it */
+          desc->lli.src_addr = reg;
+          desc->lli.dst_addr = mem + offset;
+          l_control = control;
+          desc->lli.config = 0;
+
+          if( nxs->flow_cntrl == nx_dmac_1902_fcntl_DMA_P_to_M) {
+            l_control |= (xfer_count/(1<<nxs->src_width));
+            desc->lli.config = NX_DMAC_1902_UNMASK_INT; /* this is valid only if the flow controller is DMAC */
+          }
+          else if( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_P_to_M) {
+            /* 
+             * peripheral is the flow controller, hence DMAC does not have 
+             * control over transfer count 
+             */
+          }
+          else {
+            /* this type of transfer is not supported. ?????? */
+          }
+          desc->lli.control = l_control;
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_FLOWCNTRL(nxs->flow_cntrl);
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_SRC_PER(nxs->src_per_num);
+          desc->lli.config |= NX_DMAC_1902_CHAN_CONFIG_DST_PER(0);
+
+          if (!first) {
+            first = desc;
+          } else {
+            prev->lli.llp = desc->txd.phys;
+            dma_sync_single_for_device(chan2parent(chan),
+                prev->txd.phys,
+                sizeof(prev->lli),
+                DMA_TO_DEVICE);
+            list_add_tail(&desc->desc_node,
+                &first->tx_list);
+          }
+          prev = desc;
+          offset += xfer_count;
+#if 0          
+          dev_vdbg(chan2dev(&nxc->chan),
+              "  desc: src_addr=0x%08x dst_addr=0x%08x control=0x%08x config=0x%08X xfer_count=%d\n",
+              desc->lli.src_addr, desc->lli.dst_addr, desc->lli.control, desc->lli.config, xfer_count);
+#endif
+
+        }
+      }
+      break;
+
+    default:
+      return NULL;
+  }
+
+  if (flags & DMA_PREP_INTERRUPT)
+    /* Trigger interrupt after last block */
+    prev->lli.control |= NX_DMAC_1902_INT_ENABLE;
+
+  prev->lli.llp = 0;
+  dma_sync_single_for_device(chan2parent(chan),
+      prev->txd.phys, sizeof(prev->lli),
+      DMA_TO_DEVICE);
+
+  first->txd.flags = flags;
+  first->len = len;
+
+  return &first->txd;
+
+_err_get_desc:
+  dev_dbg(chan2dev(&nxc->chan), "  slave_sg: All descriptors are exhausted for channel %d\n", nxc->chan_num);
+  nx_dmac_1902_desc_move_to_freelist(nxc, first);
+  return NULL;
+}
+
+
+static void nx_dmac_1902_terminate_all(
+    struct dma_chan *chan)
+{
+  struct nx_dmac_1902_chan	*nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902		*nxd = to_nx_dmac_1902(chan->device);
+  struct nx_dmac_1902_desc		*desc, *_desc;
+  NX_DMAC_EVENT event;
+  LIST_HEAD(list);
+
+  /*
+   * This is only called when something went wrong elsewhere, so
+   * we don't really care about the data. Just disable the
+   * channel. We still have to poll the channel enable bit due
+   * to AHB/HSB limitations.
+   */
+  spin_lock_bh(&nxc->lock);
+
+  dev_vdbg(chan2dev(chan),"nx_dmac_1902_terminate_all for channel %d\n", nxc->chan_num);
+
+  /* just forcefully disable the channel. */
+  nx_dmac_1902_channel_disable( nxd, nxc->chan_num);
+
+  /* active_list entries will end up before queued entries */
+  list_splice_init(&nxc->queue, &list);
+  list_splice_init(&nxc->active_list, &list);
+
+  spin_unlock_bh(&nxc->lock);
+
+  /* post the event term */
+   event = EVENT_TERM;
+
+  /* Flush all pending and queued descriptors */
+  list_for_each_entry_safe(desc, _desc, &list, desc_node)
+    nx_dmac_1902_desc_complete(nxc, desc,event);
+
+  return;
+}
+
+static enum dma_status nx_dmac_1902_is_tx_complete(
+    struct dma_chan *chan,
+    dma_cookie_t cookie, 
+    dma_cookie_t *last,
+    dma_cookie_t *used)
+{
+  struct nx_dmac_1902_chan	*nxc = to_nx_dmac_1902_chan(chan);
+  dma_cookie_t		last_used;
+  dma_cookie_t		last_complete;
+  int			ret;
+
+#if 0
+  u32 int_tc_status;
+  u32 int_err_status;
+  u32 int_raw_tc_status;
+  u32 int_raw_err_status;
+  struct nx_dmac_1902		*nxd = to_nx_dmac_1902(chan->device);
+#endif
+
+  last_complete = nxc->completed;
+  last_used = chan->cookie;
+
+#if 0
+
+  int_tc_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_TC_STATUS);
+  int_err_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_ERR_STATUS);
+  int_raw_tc_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_RAW_TC_STATUS);
+  int_raw_err_status = readl(nxd->regs+NX_DMAC_1902_REG_INT_RAW_ERR_STATUS);
+
+
+  dev_err(nxd->dma.dev, "tx_complete:  tc_status      = 0x%08x\n", int_tc_status);
+  dev_err(nxd->dma.dev, "tx_complete:  err_status     = 0x%08x\n", int_err_status);
+  dev_err(nxd->dma.dev, "tx_complete:  raw_tc_status  = 0x%08x\n", int_raw_tc_status);
+  dev_err(nxd->dma.dev, "tx_complete:  raw_err_status = 0x%08x\n", int_raw_err_status);
+
+  dev_err(chan2dev(&nxc->chan),
+      "tx_complete:  SAR: 0x%x DAR: 0x%x LLP: 0x%x CTL: 0x%08x CFG:0x%08x\n",
+      readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_SRC_ADDR),
+      readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_DST_ADDR),
+      readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_LLI_ADDR),
+      readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONTROL),
+      readl(nxc->ch_regs+NX_DMAC_1902_REG_CHAN_BASE(nxc->chan_num)+NX_DMAC_1902_REG_CHAN_CONFIG));
+#endif
+
+  ret = dma_async_is_complete(cookie, last_complete, last_used);
+  if (ret != DMA_SUCCESS) {
+    nx_dmac_1902_scan_descriptors(to_nx_dmac_1902(chan->device), nxc);
+
+    last_complete = nxc->completed;
+    last_used = chan->cookie;
+
+    ret = dma_async_is_complete(cookie, last_complete, last_used);
+  }
+
+  if (last)
+    *last = last_complete;
+  if (used)
+    *used = last_used;
+
+  return ret;
+}
+
+static void nx_dmac_1902_issue_pending(
+    struct dma_chan *chan)
+{
+  struct nx_dmac_1902_chan	*nxc = to_nx_dmac_1902_chan(chan);
+
+  spin_lock_bh(&nxc->lock);
+
+  /* if the active list is empty, then issue the tx list */
+  if (!list_empty(&nxc->queue) && list_empty(&nxc->active_list)) {
+    nx_dmac_1902_start_xfer(nxc, nx_dmac_1902_first_queued(nxc));
+    list_splice_init(&nxc->queue, nxc->active_list.prev); 
+  }
+  else {
+
+#if 0
+    if(list_empty(&nxc->queue))
+      dev_vdbg(chan2dev(chan),"nx_dmac_1902_issue_pending: queue list is empty\n");
+    else
+      dev_vdbg(chan2dev(chan),"nx_dmac_1902_issue_pending: active list contains a transfer\n");
+#endif
+  }
+
+  spin_unlock_bh(&nxc->lock);
+
+  return;
+}
+
+static int nx_dmac_1902_alloc_chan_resources(struct dma_chan *chan)
+{
+  struct nx_dmac_1902_chan	*nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902		*nxd = to_nx_dmac_1902(chan->device);
+  struct nx_dmac_1902_desc	*desc;
+  struct nx_dmac_1902_slave	*nxs;
+  int			i;
+
+  dev_vdbg(chan2dev(chan), "alloc_chan_resources\n");
+
+  /* ASSERT:  channel is idle */
+  if( is_chan_enabled(nxd, nxc->chan_num)) {
+    dev_err(chan2dev(chan), "  DMA channel is already enabled\n");
+    return -EIO;
+  }
+
+  nxc->completed = chan->cookie = 1;
+
+  nxs = chan->private;
+  if (nxs) {
+    /*
+     * We need controller-specific data to set up slave
+     * transfers.
+     */
+    BUG_ON(!nxs->dma_dev || nxs->dma_dev != nxd->dma.dev);
+  }
+
+  spin_lock_bh(&nxc->lock);
+  i = nxc->descs_allocated;
+  while (nxc->descs_allocated < NR_DESCS_PER_CHANNEL) {
+    spin_unlock_bh(&nxc->lock);
+
+    desc = kzalloc(sizeof(struct nx_dmac_1902_desc), GFP_KERNEL);
+    if (!desc) {
+      dev_info(chan2dev(chan), "  only allocated %d descriptors\n", i);
+      spin_lock_bh(&nxc->lock);
+      break;
+    }
+
+    INIT_LIST_HEAD(&desc->tx_list);
+    dma_async_tx_descriptor_init(&desc->txd, chan);
+    desc->txd.tx_submit = nx_dmac_1902_tx_submit;
+    desc->txd.flags = DMA_CTRL_ACK;
+    desc->txd.callback = nx_dmac_1902_async_tx_callback; 
+    desc->txd.phys = dma_map_single(chan2parent(chan), &desc->lli,
+        sizeof(desc->lli), DMA_TO_DEVICE);
+    desc->p_addr_memset = (desc->txd.phys + sizeof(struct nx_dmac_1902_lli)-4);
+    dev_vdbg(chan2dev(chan), "  Allocated descriptor (virt)=0x%08X lli(v)=0x%08X lli(p)=0x%08X\n", (u32)desc, (u32)&desc->lli, desc->txd.phys);
+
+    nx_dmac_1902_desc_move_to_freelist(nxc, desc);
+
+    spin_lock_bh(&nxc->lock);
+    i = ++nxc->descs_allocated;
+  }
+  spin_unlock_bh(&nxc->lock);
+
+  dev_dbg(chan2dev(chan), "  alloc_chan_resources allocated %d descriptors\n", i);
+  return i;
+
+}
+
+static void nx_dmac_1902_free_chan_resources(
+    struct dma_chan *chan)
+{
+  struct nx_dmac_1902_chan *nxc = to_nx_dmac_1902_chan(chan);
+  struct nx_dmac_1902		   *nxd = to_nx_dmac_1902(chan->device);
+  struct nx_dmac_1902_desc *desc, *_desc;
+  LIST_HEAD(list);
+
+  dev_dbg(chan2dev(chan), "free_chan_resources (descs allocated=%u)\n",
+      nxc->descs_allocated);
+
+  /* ASSERT:  if transfers are active */ 
+  BUG_ON(!list_empty(&nxc->active_list));
+  BUG_ON(!list_empty(&nxc->queue));
+  BUG_ON(is_chan_enabled(nxd, chan->chan_id));
+
+
+  spin_lock_bh(&nxc->lock);
+  list_splice_init(&nxc->free_list, &list);
+  nxc->descs_allocated = 0;
+
+  spin_unlock_bh(&nxc->lock);
+
+  list_for_each_entry_safe(desc, _desc, &list, desc_node) {
+    dev_vdbg(chan2dev(chan), "  freeing descriptor %p\n", desc);
+    dma_unmap_single(chan2parent(chan), desc->txd.phys,
+        sizeof(desc->lli), DMA_TO_DEVICE);
+    kfree(desc);
+  }
+
+	dev_vdbg(chan2dev(chan), "free_chan_resources done\n");
+}
+
+static int __init nx_dmac_1902_probe(struct platform_device *pdev)
+{
+  struct nx_dmac_1902 *nxd;
+  struct resource *res_reg;
+  void __iomem *ioaddr;
+  int irq;
+  int i, ret = 0;
+  u32 rev, rev0, rev1, rev2, rev3;
+  u32 num_channels, num_masters, num_perreqs;
+
+  res_reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  irq = platform_get_irq(pdev, 0);
+
+  if (res_reg == NULL || irq < 0)
+    return -ENXIO;
+
+  ioaddr = devm_ioremap( &pdev->dev, res_reg->start, (res_reg->end - res_reg->start + 1 ));
+  if( !ioaddr )
+    return -ENXIO;
+
+  /*
+   * Now detect the IP whether it contains proper vendor id or not
+   */
+  rev0 = readl(ioaddr + NX_DMAC_1902_REG_PERID_0);
+  rev1 = readl(ioaddr + NX_DMAC_1902_REG_PERID_1);
+  rev2 = readl(ioaddr + NX_DMAC_1902_REG_PERID_2);
+  rev3 = readl(ioaddr + NX_DMAC_1902_REG_PERID_3);
+
+  rev = ((rev0 & 0xFF) | ((rev1&0xFF)<<8) | ((rev2&0x0F)<<16) );
+
+  if( ( rev != NX_DMAC_1902_MOD_ID ) && ( rev != NX_DMAC_1903_MOD_ID ) ) {
+    ret = -ENODEV;
+    goto _unmap;
+  }
+
+  num_channels = (2<<(rev3 & 0x07));
+  num_masters = ((rev3 & 0x08) ? 2:1);
+  num_perreqs = ((rev3 & 0x80) ? 32:16);
+
+  dev_vdbg(&pdev->dev,"nx_dmac_1902_probe: num_channels = %d num_masters= %d num_perreqa= %d\n", num_channels, num_masters, num_perreqs);
+
+  nxd = kzalloc( (sizeof(struct nx_dmac_1902) + sizeof(struct nx_dmac_1902_chan) * num_channels ), GFP_KERNEL);
+  if( nxd == NULL ) {
+    ret = -ENOMEM;
+    goto _unmap;
+  }
+
+  nxd->regs = ioaddr;
+  nxd->num_channels = num_channels;
+  nxd->num_masters = num_masters;
+  nxd->num_perreqs = num_perreqs;
+
+  ret = request_irq(irq, nx_dmac_1902_isr, 0x00, "nx_1902_dma_irq", nxd);
+  if(ret) {
+    ret = -ENXIO;
+    goto _free_mem;
+  }
+
+  tasklet_init(&nxd->tasklet, nx_dmac_1902_tasklet, (unsigned long)nxd);
+
+  platform_set_drvdata(pdev, nxd);
+
+  writel(NX_DMAC_1902_DMAC_DISABLE,ioaddr+NX_DMAC_1902_REG_DMAC_CONFIG); /* disable the DMA controller */
+
+  INIT_LIST_HEAD(&nxd->dma.channels);
+  for (i = 0; i < num_channels; i++, nxd->dma.chancnt++) {
+    struct nx_dmac_1902_chan	*nxc = &nxd->chan[i];
+
+    nxc->chan.device = &nxd->dma;
+    nxc->chan.cookie = 1;
+    nxc->chan.chan_id = i;
+    list_add_tail(&nxc->chan.device_node, &nxd->dma.channels);
+
+    nxc->ch_regs = ioaddr;
+    nxc->chan_num = i;
+    spin_lock_init(&nxc->lock);
+    INIT_LIST_HEAD(&nxc->active_list);
+    INIT_LIST_HEAD(&nxc->queue);
+    INIT_LIST_HEAD(&nxc->free_list);
+
+    writel(0x00, ioaddr+NX_DMAC_1902_REG_CHAN_BASE(i)); /* disable the DMA channel */
+  }
+
+  writel(((0x01<<num_channels)-1), ioaddr+NX_DMAC_1902_REG_INT_ERR_CLEAR); /* clear the error interrupt status */
+  writel(( (0x01<<num_channels)-1), ioaddr+NX_DMAC_1902_REG_INT_TC_CLEAR); /* clear the tc interrupt status */
+
+  dma_cap_set(DMA_MEMCPY, nxd->dma.cap_mask);
+  dma_cap_set(DMA_MEMSET, nxd->dma.cap_mask);
+  dma_cap_set(DMA_SLAVE, nxd->dma.cap_mask);
+  nxd->dma.dev = &pdev->dev;
+
+  nxd->dma.device_alloc_chan_resources = nx_dmac_1902_alloc_chan_resources;
+  nxd->dma.device_free_chan_resources = nx_dmac_1902_free_chan_resources;
+  nxd->dma.device_prep_dma_memcpy = nx_dmac_1902_prep_dma_memcpy;
+  nxd->dma.device_prep_dma_memset = nx_dmac_1902_prep_dma_memset;
+  nxd->dma.device_prep_slave_sg = nx_dmac_1902_prep_slave_sg;
+  nxd->dma.device_terminate_all = nx_dmac_1902_terminate_all;
+  nxd->dma.device_is_tx_complete = nx_dmac_1902_is_tx_complete;
+  nxd->dma.device_issue_pending = nx_dmac_1902_issue_pending;
+
+  writel(NX_DMAC_1902_DMAC_ENABLE, ioaddr+NX_DMAC_1902_REG_DMAC_CONFIG); /* enable the DMA controller */
+
+  if(dma_async_device_register(&nxd->dma)) {
+    writel(NX_DMAC_1902_DMAC_DISABLE, ioaddr+NX_DMAC_1902_REG_DMAC_CONFIG); /* disable the DMA controller */
+    ret = -ENXIO;
+    goto _free_mem;
+  }
+
+  dev_info(&pdev->dev, "NXP DMA Controller %s found @ [%08x] (rev %x), %d channels\n",
+      ((rev == NX_DMAC_1902_MOD_ID) ? "IP_1902" : "IP_1903"),
+      (int)ioaddr, (int)rev, num_channels);
+
+  /* save some golobal varible for use of native wrapper */
+  nativePdev = pdev;
+  return 0;
+
+_free_mem:
+  if(nxd) kfree(nxd);
+  platform_set_drvdata(pdev, NULL);
+_unmap:
+  devm_iounmap( &pdev->dev, ioaddr );
+  return ret;
+}
+
+EXPORT_SYMBOL(nativePdev);
+static int nx_dmac_1902_remove(struct platform_device *pdev)
+{
+  struct nx_dmac_1902 *nxd = platform_get_drvdata(pdev);
+  struct nx_dmac_1902_chan *nxc, *_nxc;
+
+  dma_async_device_unregister(&nxd->dma);
+  free_irq(nxd->irq_num, nxd);
+  tasklet_kill(&nxd->tasklet);
+
+  list_for_each_entry_safe(nxc, _nxc, &nxd->dma.channels,
+      chan.device_node) {
+    list_del(&nxc->chan.device_node);
+    nx_dmac_1902_channel_disable(nxd, nxc->chan_num);
+  }
+  writel(NX_DMAC_1902_DMAC_DISABLE, nxd->regs+NX_DMAC_1902_REG_DMAC_CONFIG); /* disable the DMA controller */
+
+  devm_iounmap(&pdev->dev, nxd->regs);
+  nxd->regs = NULL;
+
+  kfree(nxd);
+
+  return 0;
+}
+
+
+/*!
+ * Through this variable, the Linux DMA framework based controller driver for
+ * IP_1902 publishes the routines that will be called by the Linux kernel to 
+ * probe the device present, remove the device, suspend the operation of the 
+ * device and resume the operation of device.
+ *
+ * This structure will be registered with platform in \a nx_dmac_1902_init()
+ * routine.
+ *
+ */
+struct platform_driver nx_dmac_1902_driver = {
+  .probe		= nx_dmac_1902_probe,
+  .remove		= nx_dmac_1902_remove,
+  .suspend	= NULL,
+  .resume		= NULL,
+  .driver		= {
+    .name	= DRIVER_NAME,
+    .owner	= THIS_MODULE,
+  },
+};
+
+/*!\fn  int __init nx_dmac_1902_init(void);
+ *        This routine will be called when the driver is loaded onto memory or
+ *        during the loading of the modules by the kernel during startup.
+ *
+ * \return Value returned by \a platform_driver_register() routine.
+ * 
+ * - PseudoCode:
+ * - Call \a platform_driver_register() with \a nx_dmac_1902_driver 
+ *   variable address.
+ * - Return the value returned by \a platform_driver_register() function.
+ *        
+ */
+int __init nx_dmac_1902_init(void)
+{
+  return platform_driver_register(&nx_dmac_1902_driver);
+}
+
+/*!\fn  void __exit nx_dmac_1902_exit(void);
+ *        This routine will be called when the driver is being unloaded from 
+ *        the memory by kernel.
+ *
+ * - PseudoCode:
+ * - Call \a platform_driver_unregister() with \a nx_dmac_1902_driver 
+ *   variable address.
+ * - Return from the function.
+ *        
+ */
+void __exit nx_dmac_1902_exit(void)
+{
+  platform_driver_unregister(&nx_dmac_1902_driver);
+}
+
+module_init(nx_dmac_1902_init);
+module_exit(nx_dmac_1902_exit);
+
+MODULE_DESCRIPTION("NXP DMA Controller IP_1902 driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NXP B.V.");
+
diff -Naurp linux-2.6.34.orig/drivers/dma/nx_dmac_1902_private.h linux-2.6.34/drivers/dma/nx_dmac_1902_private.h
--- linux-2.6.34.orig/drivers/dma/nx_dmac_1902_private.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dma/nx_dmac_1902_private.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,203 @@
+/*
+ * DMA framework based controller driver IP_1902
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090528     Draft-Initial version
+ *
+ */
+
+
+#ifndef _NX_DMAC_1902_PRIVATE_H
+#define _NX_DMAC_1902_PRIVATE_H
+
+#include <linux/nx_dmac_1902.h>
+
+#define MAX_NX_DMAC_1902_CHANNELS (8)
+#define NX_DMAC_1902_MOD_ID (0x00041080)
+#define NX_DMAC_1903_MOD_ID (0x00041081)
+
+/* register offset macros */
+#define NX_DMAC_1902_REG_INT_STATUS         (0x000)
+#define NX_DMAC_1902_REG_INT_TC_STATUS      (0x004)
+#define NX_DMAC_1902_REG_INT_TC_CLEAR       (0x008)
+#define NX_DMAC_1902_REG_INT_ERR_STATUS     (0x00C)
+#define NX_DMAC_1902_REG_INT_ERR_CLEAR      (0x010)
+#define NX_DMAC_1902_REG_INT_RAW_TC_STATUS  (0x014)
+#define NX_DMAC_1902_REG_INT_RAW_ERR_STATUS (0x018)
+#define NX_DMAC_1902_REG_ENABLED_CHANS      (0x01C)
+
+#define NX_DMAC_1902_REG_DMAC_CONFIG        (0x030)
+#define NX_DMAC_1902_REG_DMAC_SYNC          (0x034)
+
+/* channel specific register */
+#define NX_DMAC_1902_REG_CHAN_BASE(x) (0x100+((x)*0x20))
+#define NX_DMAC_1902_REG_CHAN_SRC_ADDR      (0x000)
+#define NX_DMAC_1902_REG_CHAN_DST_ADDR      (0x004)
+#define NX_DMAC_1902_REG_CHAN_LLI_ADDR      (0x008)
+#define NX_DMAC_1902_REG_CHAN_CONTROL       (0x00C)
+#define NX_DMAC_1902_REG_CHAN_CONFIG        (0x010)
+
+#define NX_DMAC_1902_REG_PERID_0            (0xFE0)
+#define NX_DMAC_1902_REG_PERID_1            (0xFE4)
+#define NX_DMAC_1902_REG_PERID_2            (0xFE8)
+#define NX_DMAC_1902_REG_PERID_3            (0xFEC)
+
+#define NX_DMAC_1902_REG_CELLID_0           (0xFF0)
+#define NX_DMAC_1902_REG_CELLID_1           (0xFF4)
+#define NX_DMAC_1902_REG_CELLID_2           (0xFF8)
+#define NX_DMAC_1902_REG_CELLID_3           (0xFFC)
+
+#define NX_DMAC_1902_DMAC_ENABLE            (0x00000001)
+#define NX_DMAC_1902_DMAC_DISABLE           (0x00000000)
+
+
+#define NX_DMAC_1902_CHAN_CNTRL_DST_INCR(x) ((x)<<27)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(x) ((x)<<26)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_AHB(x) ((x)<<25)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(x) ((x)<<24)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(x) ((x)<<21)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(x) ((x)<<18)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_BURST(x) ((x)<<15)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(x) ((x)<<12)
+
+#define NX_DMAC_1902_CHAN_CNTRL_HPROT(x) ((x)<<28)
+
+#define NX_DMAC_1902_HPROT_PRIVILEGE_MODE (0x01)
+#define NX_DMAC_1902_HPROT_BUFFERABLE (0x02)
+#define NX_DMAC_1902_HPROT_CACHEABLE (0x04)
+
+
+#define NX_DMAC_1902_INT_ENABLE             (0x80000000UL)
+
+#define NX_DMAC_1902_UNMASK_INT             (0x0000C000UL)
+#define NX_DMAC_1902_CHAN_CONFIG_FLOWCNTRL(x) ((x) << 11)
+#define NX_DMAC_1902_CHAN_CONFIG_SRC_PER(x) ((x) << 6)
+#define NX_DMAC_1902_CHAN_CONFIG_DST_PER(x) ((x) << 1)
+
+#define NX_DMAC_1902_DMAC_CHAN_ENABLE       (0x00000001)
+#define NX_DMAC_1902_DMAC_CHAN_DISABLE      (0x00000000)
+
+#define NX_DMAC_1902_DMAC_CHAN_HALT         (0x00040000)
+#define NX_DMAC_1902_DMAC_CHAN_ACTIVE       (0x00020000)
+
+/* max number of elements to be transferred at a single dma descriptor node */
+#define NX_DMAC_1902_MAX_XFER_SIZE          (0xFFF)
+
+enum nx_dmac_1902_xfer_status {
+  nx_dmac_1902_xfer_status_nothing=0,
+  nx_dmac_1902_xfer_status_completed,
+  nx_dmac_1902_xfer_status_failed
+};
+
+/* Notifications for native driver */
+typedef enum nx_dmac_event{
+   EVENT_COMPLETE = 1,
+   EVENT_ERROR = 2,
+   EVENT_TERM = 3,
+   EVENT_NONE = 4,
+}NX_DMAC_EVENT;
+
+/* callback data */
+struct callback_data
+{
+  unsigned int  chanNo;
+  unsigned int  length;
+  NX_DMAC_EVENT  event;
+  unsigned int   async;
+  void           *unit_instance;
+  void           *pTag;
+};
+
+/* lli as in hardware */
+struct nx_dmac_1902_lli {
+  dma_addr_t src_addr;  /* source address */
+  dma_addr_t dst_addr;  /* destination address */
+  dma_addr_t llp;       /* link to next descriptor */
+  u32        control;   /* control word for the IP_1902 channel */
+  u32        config;    /* channel_config */
+  u32        val_memset; /* value to be set during memset operation */
+};
+
+/* DMA descriptor */
+struct nx_dmac_1902_desc {
+  struct nx_dmac_1902_lli        lli;
+
+  /* for driver housekeeping */
+  struct list_head               desc_node;
+  struct list_head		         tx_list;
+  struct dma_async_tx_descriptor txd;
+  dma_addr_t                     p_addr_memset; /* physical memory address for lli.val_memset */
+  size_t                         len;
+  struct callback_data          cbd;               /* Callback data */
+};
+
+/* channel specific structure */
+struct nx_dmac_1902_chan {
+  struct dma_chan		           chan;
+  void __iomem *               ch_regs;           /* this will be same as that of device regs */
+  u8                           chan_num;          /* channel number */
+  spinlock_t                   lock;
+  u8                           chan_free;         /* to indicate the channel is free or is allocated */
+  struct nx_dmac_1902_slave   *nxs;               /* pointer to the slave specific config such as burst size, width size, etc.. */       
+  dma_cookie_t                 completed;         /* indicates whether the transfer is completed or not. depending upon this, the tasklet will invoke the desc->callback */
+  struct device                *dev;
+  enum nx_dmac_1902_xfer_status xfer_status;      /* this indicates the xfer status of the channel */
+  /* lists */
+  struct list_head              active_list;       /* contains the descriptors which are currently active or to be programmed into the hardware */
+  struct list_head              queue;             /* contains the next nodes which needs to be made active */
+  struct list_head              free_list;         /* contains the descriptors which are free */
+
+  unsigned int                  descs_allocated;   /* number of descriptors allocated */
+  struct callback_data          cbd;               /* Callback data */
+};
+
+/* driver private structure */
+struct nx_dmac_1902 {
+  struct dma_device        dma;
+  void __iomem *           regs;                /* points to the DMA IP register base address virtual address */
+
+  struct tasklet_struct    tasklet;             /* tasklet to indicate success/failure of DMA transfer */
+  /** DMA IP configuration */
+  int                      irq_num;             /* irq number for DMAC */
+  int                      num_channels;        /* number of channels supported by the IP */
+  int                      num_masters;         /* number of AHB masters configured in the IP */
+  int                      num_perreqs;         /* number of peripheral requests */
+  struct nx_dmac_1902_chan chan[0];             /* channel specific data */
+};
+
+
+static inline struct nx_dmac_1902_chan *to_nx_dmac_1902_chan(struct dma_chan *chan)
+{
+  return container_of(chan, struct nx_dmac_1902_chan, chan);
+}
+
+static inline struct nx_dmac_1902 *to_nx_dmac_1902(struct dma_device *ddev)
+{
+  return container_of(ddev, struct nx_dmac_1902, dma);
+}
+
+static inline struct nx_dmac_1902_desc *txd_to_nx_dmac_1902_desc(struct dma_async_tx_descriptor *txd)
+{
+  return container_of(txd, struct nx_dmac_1902_desc, txd);
+}
+
+#endif /* NX_DMAC_1902_PRIVATE_H */
+
diff -Naurp linux-2.6.34.orig/drivers/dma/pl330.c linux-2.6.34/drivers/dma/pl330.c
--- linux-2.6.34.orig/drivers/dma/pl330.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/dma/pl330.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,866 @@
+/* linux/drivers/dma/pl330.c
+ *
+ * Copyright (C) 2010 Samsung Electronics Co. Ltd.
+ *	Jaswinder Singh <jassi.brar@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/pl330.h>
+
+#define NR_DEFAULT_DESC	16
+
+enum desc_status {
+	/* In the DMAC pool */
+	FREE,
+	/*
+	 * Allocted to some channel during prep_xxx
+	 * Also may be sitting on the work_list.
+	 */
+	PREP,
+	/*
+	 * Sitting on the work_list and already submitted
+	 * to the PL330 core. Not more than two descriptors
+	 * of a channel can be BUSY at any time.
+	 */
+	BUSY,
+	/*
+	 * Sitting on the channel work_list but xfer done
+	 * by PL330 core
+	 */
+	DONE,
+};
+
+struct dma_pl330_chan {
+	/* Schedule desc completion */
+	struct tasklet_struct task;
+
+	/* DMA-Engine Channel */
+	struct dma_chan chan;
+
+	/* Last completed cookie */
+	dma_cookie_t completed;
+
+	/* List of to be xfered descriptors */
+	struct list_head work_list;
+
+	/* Pointer to the DMAC that manages this channel,
+	 * NULL if the channel is available to be acquired.
+	 * As the parent, this DMAC also provides descriptors
+	 * to the channel.
+	 */
+	struct dma_pl330_dmac *dmac;
+
+	/* To protect channel manipulation */
+	spinlock_t lock;
+
+	/* Token of a hardware channel thread of PL330 DMAC
+	 * NULL if the channel is available to be acquired.
+	 */
+	void *pl330_chid;
+};
+
+struct dma_pl330_dmac {
+	struct pl330_info pif;
+
+	/* DMA-Engine Device */
+	struct dma_device ddma;
+
+	/* Pool of descriptors available for the DMAC's channels */
+	struct list_head desc_pool;
+	/* To protect desc_pool manipulation */
+	spinlock_t pool_lock;
+
+	/* Peripheral channels connected to this DMAC */
+	struct dma_pl330_chan peripherals[0]; /* keep at end */
+};
+
+struct dma_pl330_desc {
+	/* To attach to a queue as child */
+	struct list_head node;
+
+	/* Descriptor for the DMA Engine API */
+	struct dma_async_tx_descriptor txd;
+
+	/* Xfer for PL330 core */
+	struct pl330_xfer px;
+
+	struct pl330_reqcfg rqcfg;
+	struct pl330_req req;
+
+	enum desc_status status;
+
+	/* The channel which currently holds this desc */
+	struct dma_pl330_chan *pchan;
+};
+
+static inline struct dma_pl330_chan *
+to_pchan(struct dma_chan *ch)
+{
+	if (!ch)
+		return NULL;
+
+	return container_of(ch, struct dma_pl330_chan, chan);
+}
+
+static inline struct dma_pl330_desc *
+to_desc(struct dma_async_tx_descriptor *tx)
+{
+	return container_of(tx, struct dma_pl330_desc, txd);
+}
+
+static inline void free_desc_list(struct list_head *list)
+{
+	struct dma_pl330_dmac *pdmac;
+	struct dma_pl330_desc *desc;
+	struct dma_pl330_chan *pch;
+	unsigned long flags;
+
+	if (list_empty(list))
+		return;
+
+	/* Finish off the work list */
+	list_for_each_entry(desc, list, node) {
+		dma_async_tx_callback callback;
+		void *param;
+
+		/* All desc in a list belong to same channel */
+		pch = desc->pchan;
+		callback = desc->txd.callback;
+		param = desc->txd.callback_param;
+
+		if (callback)
+			callback(param);
+
+		desc->pchan = NULL;
+	}
+
+	pdmac = pch->dmac;
+
+	spin_lock_irqsave(&pdmac->pool_lock, flags);
+	list_splice_tail_init(list, &pdmac->desc_pool);
+	spin_unlock_irqrestore(&pdmac->pool_lock, flags);
+}
+
+static inline void fill_queue(struct dma_pl330_chan *pch)
+{
+	struct dma_pl330_desc *desc;
+	int ret;
+
+	list_for_each_entry(desc, &pch->work_list, node) {
+
+		/* If already submitted */
+		if (desc->status == BUSY)
+			break;
+
+		ret = pl330_submit_req(pch->pl330_chid,
+						&desc->req);
+		if (!ret) {
+			desc->status = BUSY;
+			break;
+		} else if (ret == -EAGAIN) {
+			/* QFull or DMAC Dying */
+			break;
+		} else {
+			/* Unacceptable request */
+			desc->status = DONE;
+			dev_err(pch->dmac->pif.dev, "%s:%d Bad Desc(%d)\n",
+					__func__, __LINE__, desc->txd.cookie);
+			tasklet_schedule(&pch->task);
+		}
+	}
+}
+
+static void pl330_tasklet(unsigned long data)
+{
+	struct dma_pl330_chan *pch = (struct dma_pl330_chan *)data;
+	struct dma_pl330_desc *desc, *_dt;
+	unsigned long flags;
+	LIST_HEAD(list);
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	/* Pick up ripe tomatoes */
+	list_for_each_entry_safe(desc, _dt, &pch->work_list, node)
+		if (desc->status == DONE) {
+			pch->completed = desc->txd.cookie;
+			list_move_tail(&desc->node, &list);
+		}
+
+	/* Try to submit a req imm. next to the last completed cookie */
+	fill_queue(pch);
+
+	/* Make sure the PL330 Channel thread is active */
+	pl330_chan_ctrl(pch->pl330_chid, PL330_OP_START);
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	free_desc_list(&list);
+}
+
+static void dma_pl330_rqcb(void *token, enum pl330_op_err err)
+{
+	struct dma_pl330_desc *desc = token;
+	struct dma_pl330_chan *pch = desc->pchan;
+	unsigned long flags;
+
+	/* If desc aborted */
+	if (!pch)
+		return;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	desc->status = DONE;
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	tasklet_schedule(&pch->task);
+}
+
+static int pl330_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct dma_pl330_dmac *pdmac = pch->dmac;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	pch->completed = chan->cookie = 1;
+
+	pch->pl330_chid = pl330_request_channel(&pdmac->pif);
+	if (!pch->pl330_chid) {
+		spin_unlock_irqrestore(&pch->lock, flags);
+		return 0;
+	}
+
+	tasklet_init(&pch->task, pl330_tasklet, (unsigned long) pch);
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	return 1;
+}
+
+static int pl330_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd, unsigned long arg)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct dma_pl330_desc *desc;
+	unsigned long flags;
+
+	/* Only supports DMA_TERMINATE_ALL */
+	if (cmd != DMA_TERMINATE_ALL)
+		return -ENXIO;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	/* FLUSH the PL330 Channel thread */
+	pl330_chan_ctrl(pch->pl330_chid, PL330_OP_FLUSH);
+
+	/* Mark all desc done */
+	list_for_each_entry(desc, &pch->work_list, node)
+		desc->status = DONE;
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	pl330_tasklet((unsigned long) pch);
+
+	return 0;
+}
+
+static void pl330_free_chan_resources(struct dma_chan *chan)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	tasklet_kill(&pch->task);
+
+	pl330_release_channel(pch->pl330_chid);
+	pch->pl330_chid = NULL;
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+}
+
+static enum dma_status
+pl330_tx_status(struct dma_chan *chan, dma_cookie_t cookie,
+		 struct dma_tx_state *txstate)
+{
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	dma_cookie_t last_done, last_used;
+	int ret;
+
+	last_done = pch->completed;
+	last_used = chan->cookie;
+
+	ret = dma_async_is_complete(cookie, last_done, last_used);
+
+	dma_set_tx_state(txstate, last_done, last_used, 0);
+
+	return ret;
+}
+
+static void pl330_issue_pending(struct dma_chan *chan)
+{
+	pl330_tasklet((unsigned long) to_pchan(chan));
+}
+
+/*
+ * We returned the last one of the circular list of descriptor(s)
+ * from prep_xxx, so the argument to submit corresponds to the last
+ * descriptor of the list.
+ */
+static dma_cookie_t pl330_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_pl330_desc *desc, *last = to_desc(tx);
+	struct dma_pl330_chan *pch = to_pchan(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pch->lock, flags);
+
+	/* Assign cookies to all nodes */
+	cookie = tx->chan->cookie;
+
+	while (!list_empty(&last->node)) {
+		desc = list_entry(last->node.next, struct dma_pl330_desc, node);
+
+		if (++cookie < 0)
+			cookie = 1;
+		desc->txd.cookie = cookie;
+
+		list_move_tail(&desc->node, &pch->work_list);
+	}
+
+	if (++cookie < 0)
+		cookie = 1;
+	last->txd.cookie = cookie;
+
+	list_add_tail(&last->node, &pch->work_list);
+
+	tx->chan->cookie = cookie;
+
+	spin_unlock_irqrestore(&pch->lock, flags);
+
+	return cookie;
+}
+
+static inline void _init_desc(struct dma_pl330_desc *desc)
+{
+	desc->pchan = NULL;
+	desc->req.x = &desc->px;
+	desc->req.token = desc;
+	desc->rqcfg.swap = SWAP_NO;
+	desc->rqcfg.privileged = 0;
+	desc->rqcfg.insnaccess = 0;
+	desc->rqcfg.scctl = SCCTRL0;
+	desc->rqcfg.dcctl = DCCTRL0;
+	desc->req.cfg = &desc->rqcfg;
+	desc->req.xfer_cb = dma_pl330_rqcb;
+	desc->txd.tx_submit = pl330_tx_submit;
+
+	INIT_LIST_HEAD(&desc->node);
+}
+
+/* Returns the number of descriptors added to the DMAC pool */
+int add_desc(struct dma_pl330_dmac *pdmac, gfp_t flg, int count)
+{
+	struct dma_pl330_desc *desc;
+	unsigned long flags;
+	int i;
+
+	if (!pdmac)
+		return 0;
+
+	desc = kmalloc(count * sizeof(*desc), flg);
+	if (!desc)
+		return 0;
+
+	spin_lock_irqsave(&pdmac->pool_lock, flags);
+
+	for (i = 0; i < count; i++) {
+		_init_desc(&desc[i]);
+		list_add_tail(&desc[i].node, &pdmac->desc_pool);
+	}
+
+	spin_unlock_irqrestore(&pdmac->pool_lock, flags);
+
+	return count;
+}
+
+static struct dma_pl330_desc *
+pluck_desc(struct dma_pl330_dmac *pdmac)
+{
+	struct dma_pl330_desc *desc = NULL;
+	unsigned long flags;
+
+	if (!pdmac)
+		return NULL;
+
+	spin_lock_irqsave(&pdmac->pool_lock, flags);
+
+	if (!list_empty(&pdmac->desc_pool)) {
+		desc = list_entry(pdmac->desc_pool.next,
+				struct dma_pl330_desc, node);
+
+		list_del_init(&desc->node);
+
+		desc->status = PREP;
+		desc->txd.callback = NULL;
+	}
+
+	spin_unlock_irqrestore(&pdmac->pool_lock, flags);
+
+	return desc;
+}
+
+static struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)
+{
+	struct dma_pl330_dmac *pdmac = pch->dmac;
+	struct dma_pl330_peri *peri = pch->chan.private;
+	struct dma_pl330_desc *desc;
+
+	/* Pluck one desc from the pool of DMAC */
+	desc = pluck_desc(pdmac);
+
+	/* If the DMAC pool is empty, alloc new */
+	if (!desc) {
+		if (!add_desc(pdmac, GFP_ATOMIC, 1))
+			return NULL;
+
+		/* Try again */
+		desc = pluck_desc(pdmac);
+		if (!desc) {
+			dev_err(pch->dmac->pif.dev,
+				"%s:%d ALERT!\n", __func__, __LINE__);
+			return NULL;
+		}
+	}
+
+	/* Initialize the descriptor */
+	desc->pchan = pch;
+	desc->txd.cookie = 0;
+	async_tx_ack(&desc->txd);
+
+	desc->req.rqtype = peri->rqtype;
+	desc->req.peri = peri->peri_id;
+
+	dma_async_tx_descriptor_init(&desc->txd, &pch->chan);
+
+	return desc;
+}
+
+static inline void fill_px(struct pl330_xfer *px,
+		dma_addr_t dst, dma_addr_t src, size_t len)
+{
+	px->next = NULL;
+	px->bytes = len;
+	px->dst_addr = dst;
+	px->src_addr = src;
+}
+
+static struct dma_pl330_desc *
+__pl330_prep_dma_memcpy(struct dma_pl330_chan *pch, dma_addr_t dst,
+		dma_addr_t src, size_t len)
+{
+	struct dma_pl330_desc *desc = pl330_get_desc(pch);
+
+	if (!desc) {
+		dev_err(pch->dmac->pif.dev, "%s:%d Unable to fetch desc\n",
+			__func__, __LINE__);
+		return NULL;
+	}
+
+	/*
+	 * Ideally we should lookout for reqs bigger than
+	 * those that can be programmed with 256 bytes of
+	 * MC buffer, but considering a req size is seldom
+	 * going to be word-unaligned and more than 200MB,
+	 * we take it easy.
+	 * Also, should the limit is reached we'd rather
+	 * have the platform increase MC buffer size than
+	 * complicating this API driver.
+	 */
+	fill_px(&desc->px, dst, src, len);
+
+	return desc;
+}
+
+/* Call after fixing burst size */
+static inline int get_burst_len(struct dma_pl330_desc *desc, size_t len)
+{
+	struct dma_pl330_chan *pch = desc->pchan;
+	struct pl330_info *pi = &pch->dmac->pif;
+	int burst_len;
+
+	burst_len = pi->pcfg.data_bus_width / 8;
+	burst_len *= pi->pcfg.data_buf_dep;
+	burst_len >>= desc->rqcfg.brst_size;
+
+	/* src/dst_burst_len can't be more than 16 */
+	if (burst_len > 16)
+		burst_len = 16;
+
+	while (burst_len > 1) {
+		if (!(len % (burst_len << desc->rqcfg.brst_size)))
+			break;
+		burst_len--;
+	}
+
+	return burst_len;
+}
+
+static struct dma_async_tx_descriptor *
+pl330_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst,
+		dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct dma_pl330_desc *desc;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct dma_pl330_peri *peri = chan->private;
+	struct pl330_info *pi;
+	int burst;
+
+	if (unlikely(!pch || !len || !peri))
+		return NULL;
+
+	if (peri->rqtype != MEMTOMEM)
+		return NULL;
+
+	pi = &pch->dmac->pif;
+
+	desc = __pl330_prep_dma_memcpy(pch, dst, src, len);
+	if (!desc)
+		return NULL;
+
+	desc->rqcfg.src_inc = 1;
+	desc->rqcfg.dst_inc = 1;
+
+	/* Select max possible burst size */
+	burst = pi->pcfg.data_bus_width / 8;
+
+	while (burst > 1) {
+		if (!(len % burst))
+			break;
+		burst /= 2;
+	}
+
+	desc->rqcfg.brst_size = 0;
+	while (burst != (1 << desc->rqcfg.brst_size))
+		desc->rqcfg.brst_size++;
+
+	desc->rqcfg.brst_len = get_burst_len(desc, len);
+
+	desc->txd.flags = flags;
+
+	return &desc->txd;
+}
+
+static struct dma_async_tx_descriptor *
+pl330_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_data_direction direction,
+		unsigned long flg)
+{
+	struct dma_pl330_desc *first, *desc = NULL;
+	struct dma_pl330_chan *pch = to_pchan(chan);
+	struct dma_pl330_peri *peri = chan->private;
+	struct scatterlist *sg;
+	unsigned long flags;
+	int i, burst_size;
+	dma_addr_t addr;
+
+	if (unlikely(!pch || !sgl || !sg_len))
+		return NULL;
+
+	/* Make sure the direction is consistent */
+	if ((direction == DMA_TO_DEVICE &&
+				peri->rqtype != MEMTODEV) ||
+			(direction == DMA_FROM_DEVICE &&
+				peri->rqtype != DEVTOMEM)) {
+		dev_err(pch->dmac->pif.dev, "%s:%d Invalid Direction\n",
+				__func__, __LINE__);
+		return NULL;
+	}
+
+	addr = peri->fifo_addr;
+	burst_size = peri->burst_sz;
+
+	first = NULL;
+
+	for_each_sg(sgl, sg, sg_len, i) {
+
+		desc = pl330_get_desc(pch);
+		if (!desc) {
+			struct dma_pl330_dmac *pdmac = pch->dmac;
+
+			dev_err(pch->dmac->pif.dev,
+				"%s:%d Unable to fetch desc\n",
+				__func__, __LINE__);
+			if (!first)
+				return NULL;
+
+			spin_lock_irqsave(&pdmac->pool_lock, flags);
+
+			while (!list_empty(&first->node)) {
+				desc = list_entry(first->node.next,
+						struct dma_pl330_desc, node);
+				list_move_tail(&desc->node, &pdmac->desc_pool);
+			}
+
+			list_move_tail(&first->node, &pdmac->desc_pool);
+
+			spin_unlock_irqrestore(&pdmac->pool_lock, flags);
+
+			return NULL;
+		}
+
+		if (!first)
+			first = desc;
+		else
+			list_add_tail(&desc->node, &first->node);
+
+		if (direction == DMA_TO_DEVICE) {
+			desc->rqcfg.src_inc = 1;
+			desc->rqcfg.dst_inc = 0;
+			fill_px(&desc->px,
+				addr, sg_dma_address(sg), sg_dma_len(sg));
+		} else {
+			desc->rqcfg.src_inc = 0;
+			desc->rqcfg.dst_inc = 1;
+			fill_px(&desc->px,
+				sg_dma_address(sg), addr, sg_dma_len(sg));
+		}
+
+		desc->rqcfg.brst_size = burst_size;
+		desc->rqcfg.brst_len = 1;
+	}
+
+	/* Return the last desc in the chain */
+	desc->txd.flags = flg;
+	return &desc->txd;
+}
+
+static irqreturn_t pl330_irq_handler(int irq, void *data)
+{
+	if (pl330_update(data))
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static int __devinit
+pl330_probe(struct amba_device *adev, struct amba_id *id)
+{
+	struct dma_pl330_platdata *pdat;
+	struct dma_pl330_dmac *pdmac;
+	struct dma_pl330_chan *pch;
+	struct pl330_info *pi;
+	struct dma_device *pd;
+	struct resource *res;
+	int i, ret, irq;
+
+	pdat = adev->dev.platform_data;
+
+	if (!pdat || !pdat->nr_valid_peri) {
+		dev_err(&adev->dev, "platform data missing\n");
+		return -ENODEV;
+	}
+
+	/* Allocate a new DMAC and its Channels */
+	pdmac = kzalloc(pdat->nr_valid_peri * sizeof(*pch)
+				+ sizeof(*pdmac), GFP_KERNEL);
+	if (!pdmac) {
+		dev_err(&adev->dev, "unable to allocate mem\n");
+		return -ENOMEM;
+	}
+
+	pi = &pdmac->pif;
+	pi->dev = &adev->dev;
+	pi->pl330_data = NULL;
+	pi->mcbufsz = pdat->mcbuf_sz;
+
+	res = &adev->res;
+	request_mem_region(res->start, resource_size(res), "dma-pl330");
+
+	pi->base = ioremap(res->start, resource_size(res));
+	if (!pi->base) {
+		ret = -ENXIO;
+		goto probe_err1;
+	}
+
+	irq = adev->irq[0];
+	ret = request_irq(irq, pl330_irq_handler, 0,
+			dev_name(&adev->dev), pi);
+	if (ret)
+		goto probe_err2;
+
+	ret = pl330_add(pi);
+	if (ret)
+		goto probe_err3;
+
+	INIT_LIST_HEAD(&pdmac->desc_pool);
+	spin_lock_init(&pdmac->pool_lock);
+
+	/* Create a descriptor pool of default size */
+	if (!add_desc(pdmac, GFP_KERNEL, NR_DEFAULT_DESC))
+		dev_warn(&adev->dev, "unable to allocate desc\n");
+
+	pd = &pdmac->ddma;
+	INIT_LIST_HEAD(&pd->channels);
+
+	/* Initialize channel parameters */
+	for (i = 0; i < pdat->nr_valid_peri; i++) {
+		struct dma_pl330_peri *peri = &pdat->peri[i];
+		pch = &pdmac->peripherals[i];
+
+		switch (peri->rqtype) {
+		case MEMTOMEM:
+			dma_cap_set(DMA_MEMCPY, pd->cap_mask);
+			break;
+		case MEMTODEV:
+		case DEVTOMEM:
+			dma_cap_set(DMA_SLAVE, pd->cap_mask);
+			break;
+		default:
+			dev_err(&adev->dev, "DEVTODEV Not Supported\n");
+			continue;
+		}
+
+		INIT_LIST_HEAD(&pch->work_list);
+		spin_lock_init(&pch->lock);
+		pch->pl330_chid = NULL;
+		pch->chan.private = peri;
+		pch->chan.device = pd;
+		pch->chan.chan_id = i;
+		pch->dmac = pdmac;
+
+		/* Add the channel to the DMAC list */
+		pd->chancnt++;
+		list_add_tail(&pch->chan.device_node, &pd->channels);
+	}
+
+	pd->dev = &adev->dev;
+
+	pd->device_alloc_chan_resources = pl330_alloc_chan_resources;
+	pd->device_free_chan_resources = pl330_free_chan_resources;
+	pd->device_prep_dma_memcpy = pl330_prep_dma_memcpy;
+	pd->device_tx_status = pl330_tx_status;
+	pd->device_prep_slave_sg = pl330_prep_slave_sg;
+	pd->device_control = pl330_control;
+	pd->device_issue_pending = pl330_issue_pending;
+
+	ret = dma_async_device_register(pd);
+	if (ret) {
+		dev_err(&adev->dev, "unable to register DMAC\n");
+		goto probe_err4;
+	}
+
+	amba_set_drvdata(adev, pdmac);
+
+	dev_info(&adev->dev,
+		"Loaded driver for PL330 DMAC-%d\n", adev->periphid);
+	dev_info(&adev->dev,
+		"\tDBUFF-%ux%ubytes Num_Chans-%u Num_Peri-%u Num_Events-%u\n",
+		pi->pcfg.data_buf_dep,
+		pi->pcfg.data_bus_width / 8, pi->pcfg.num_chan,
+		pi->pcfg.num_peri, pi->pcfg.num_events);
+
+	return 0;
+
+probe_err4:
+	pl330_del(pi);
+probe_err3:
+	free_irq(irq, pi);
+probe_err2:
+	iounmap(pi->base);
+probe_err1:
+	release_mem_region(res->start, resource_size(res));
+	kfree(pdmac);
+
+	return ret;
+}
+
+static int __devexit pl330_remove(struct amba_device *adev)
+{
+	struct dma_pl330_dmac *pdmac = amba_get_drvdata(adev);
+	struct dma_pl330_chan *pch, *_p;
+	struct pl330_info *pi;
+	struct resource *res;
+	int irq;
+
+	if (!pdmac)
+		return 0;
+
+	amba_set_drvdata(adev, NULL);
+
+	/* Idle the DMAC */
+	list_for_each_entry_safe(pch, _p, &pdmac->ddma.channels,
+			chan.device_node) {
+
+		/* Remove the channel */
+		list_del(&pch->chan.device_node);
+
+		/* Flush the channel */
+		pl330_control(&pch->chan, DMA_TERMINATE_ALL, 0);
+		pl330_free_chan_resources(&pch->chan);
+	}
+
+	pi = &pdmac->pif;
+
+	pl330_del(pi);
+
+	irq = adev->irq[0];
+	free_irq(irq, pi);
+
+	iounmap(pi->base);
+
+	res = &adev->res;
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(pdmac);
+
+	return 0;
+}
+
+static struct amba_id pl330_ids[] = {
+	{
+		.id	= 0x00041330,
+		.mask	= 0x000fffff,
+	},
+	{ 0, 0 },
+};
+
+static struct amba_driver pl330_driver = {
+	.drv = {
+		.owner = THIS_MODULE,
+		.name = "dma-pl330",
+	},
+	.id_table = pl330_ids,
+	.probe = pl330_probe,
+	.remove = pl330_remove,
+};
+
+static int __init pl330_init(void)
+{
+	return amba_driver_register(&pl330_driver);
+}
+module_init(pl330_init);
+
+static void __exit pl330_exit(void)
+{
+	amba_driver_unregister(&pl330_driver);
+	return;
+}
+module_exit(pl330_exit);
+
+MODULE_AUTHOR("Jaswinder Singh <jassi.brar@samsung.com>");
+MODULE_DESCRIPTION("API Driver for PL330 DMAC");
+MODULE_LICENSE("GPL");
diff -Naurp linux-2.6.34.orig/drivers/gcs_dmac/gcs_dmac.c linux-2.6.34/drivers/gcs_dmac/gcs_dmac.c
--- linux-2.6.34.orig/drivers/gcs_dmac/gcs_dmac.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/gcs_dmac/gcs_dmac.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,487 @@
+/*
+ * Device driver for DMAC IP_1902.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 0.0.1		Bangaragiri G			20080402		Draft-Initial version
+ * 0.1.0		Bangaragiri G			20080804		Proposal-After self review
+ * 0.2.0		Bangaragiri G			20080925		Proposal-After including review comments
+ * 1.0.0		Bangaragiri G			20090305		Accepted-After testing on TV550M0 board
+ * 1.1.0		Bangaragiri G			20090313		Accepted-OneNAND updates
+ */
+/*----------------------------------------------------------------------
+ * Standard include files
+ *---------------------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <linux/nx_dmac.h>
+
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+
+volatile bool nor_dma_done = false;
+volatile bool nor_dma_error = false;
+
+/* DMAC device structure */
+static struct nx_dmac_t	*nx_dmac=NULL;
+
+/*----------------------------------------------------------------------
+ * Internal function prototypes 
+ *---------------------------------------------------------------------*/
+static irqreturn_t nx_dmac_isr(int irq_no ATTRIBUTE_UNUSED, void *dev_id);
+
+/**
+* nx_dmac_probe - DMAC probe function
+* @pdev: Platform device structure
+*
+* Probes the DMAC device & do the initialisation
+*/
+static int nx_dmac_probe(struct platform_device *pdev)
+{
+	struct resource *res1, *res2;
+	int	i, ret = 0;
+	uint32_t	per_id3;
+	int	num_chans;
+	struct nx_dmac_chan_t *chan;
+	uint8_t *lli_ptr;
+	dma_addr_t lli_phy;
+	
+	/* Allocate memory for nand control structure */
+	nx_dmac = kzalloc(sizeof(struct nx_dmac_t), GFP_KERNEL);
+	if (!nx_dmac) {
+		printk(KERN_ERR "nx_dmac: DMAC dev memory alloc \r\n");
+		return -ENOMEM;
+	}
+
+	/* Get the resource */
+	res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res1) {
+		printk(KERN_ERR "nx_dmac: DMAC get res failure \r\n");	
+		ret = -EBUSY;
+		goto out1_free;
+	}
+
+	/* IO remap controller base */
+	nx_dmac->dmac_base = devm_ioremap(&pdev->dev, 
+								res1->start, res1->end - res1->start + 1);
+	if (!nx_dmac->dmac_base) {
+		printk(KERN_ERR "nx_dmac: DMAC base devm_ioremap failure \r\n");	
+		ret = -ENOMEM;
+		goto out1_free;
+	}
+	
+	/* Get interrupt resource */
+	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if(!res2) {
+		printk(KERN_ERR "nx_dmac: DMAC wrong irq resource \r\n");	
+		ret = -EBUSY;
+		goto out1_free;
+	}
+
+	/* Alocate interrupt */
+	ret = devm_request_irq (&pdev->dev, res2->start, 
+			nx_dmac_isr, IRQF_DISABLED, "gcs_nx_1902_dma", nx_dmac);
+	if (ret < 0) {
+		printk(KERN_ERR "nx_dmac: DMAC irq alloc failure \r\n");	
+		goto out1_free;
+	}
+	
+	/* Store in dev struct */
+	dev_set_drvdata(&pdev->dev, nx_dmac);
+
+	/* Get HW info */
+	per_id3 = readl(nx_dmac->dmac_base + NX_DMAC_PERI_ID3);
+
+	/* # of channels */
+	num_chans = per_id3 & 0x7;
+	nx_dmac->num_chans = (0x2 << num_chans);
+	
+	/* # of AHB masters */
+	if(per_id3 & 0x4) {
+		nx_dmac->num_ahb_mas = 2;
+	}
+	else {
+		nx_dmac->num_ahb_mas = 1;
+	}
+	
+	/* # of requestors */
+	if(per_id3 & 0x80) {
+		nx_dmac->num_reqs = 32;
+	}
+	else {
+		nx_dmac->num_reqs = 16;
+	}
+
+	mutex_init(&nx_dmac->dmac_lock);
+	
+	/* Allocate memory for channels */
+	nx_dmac->chans = kzalloc(sizeof(struct nx_dmac_chan_t) * 
+			nx_dmac->num_chans, GFP_KERNEL);
+	if(!nx_dmac->chans) {
+		printk(KERN_ERR "nx_dmac: DMAC chan mem alloc failure \r\n");	
+		ret = -ENOMEM;
+		goto out1_free;
+	}
+
+	lli_ptr = dmam_alloc_coherent(&pdev->dev, 
+			sizeof(struct nx_dmac_lli_t) * nx_dmac->num_chans * NR_DESCRIPTORS,
+			&lli_phy, GFP_KERNEL);
+
+	if (lli_ptr == NULL) {
+			dev_err(&pdev->dev, "Unable to allocate DMA descriptors\r\n");
+			kfree (nx_dmac);
+			return -ENOMEM;
+	}
+
+	/*Initialise channel */
+	for(i=0; i < nx_dmac->num_chans; i++) {
+		chan = &nx_dmac->chans[i];
+		chan->chanid = i;
+		chan->busy = false;
+		chan->lli_ptr = (void *)(lli_ptr + (i * sizeof(struct nx_dmac_lli_t) * NR_DESCRIPTORS));
+		chan->lli_phy = lli_phy + (i * sizeof(struct nx_dmac_lli_t) * NR_DESCRIPTORS);
+		mutex_init(&chan->chan_lock);
+		chan->chan_status = 0;
+		init_waitqueue_head(&chan->chan_queue);
+	}
+
+	/* Enable DMA HW, AHB mast1, AHB mast2 to little endian */
+	writel(0x1, nx_dmac->dmac_base + NX_DMAC_CONFIG);
+
+	printk(KERN_INFO "nx_dmac: Registered with %d channels \r\n", nx_dmac->num_chans);
+
+	return 0;
+
+out1_free:	
+	kfree(nx_dmac);
+
+	return ret;
+}
+
+/**
+* nx_dmac_remove - DMAC remove function 
+* @pdev: Platform device structure
+*
+* Deinitialise the device
+*/
+static int nx_dmac_remove(struct platform_device *pdev)
+{
+	struct nx_dmac_t *nxdmac = dev_get_drvdata(&pdev->dev);
+	
+	/* Disable DMAC HW */
+	writel(0x0, nxdmac->dmac_base + NX_DMAC_CONFIG);
+
+	/* Free channel alloc */
+	kfree(nxdmac->chans);
+	
+	/* Free DMAC control */
+	kfree(nxdmac);
+
+	return 0;
+}
+
+/**
+* nx_dmac_tfr - DMAC transfer function 
+* @tfr: DMAC transfer request structure
+*
+* Start the DMAC transfers
+*/
+int	nx_dmac_tfr(nx_dmac_tfr_t *tfr)
+{
+	int i, j, chanid;
+	uint32_t	ctrl_wrd, chan_config;
+	struct nx_dmac_chan_t *chan;
+	void __iomem	*chan_start;
+	
+	if (tfr->num_reqs > NR_DESCRIPTORS) {
+			printk(KERN_ERR "Too many transfer requests.\r\n");
+			return -EAGAIN;
+	}
+
+	/* Acquire DMAC lock */
+	mutex_lock(&nx_dmac->dmac_lock);
+
+	/* Get free channel */
+	i=0;
+	while(i < nx_dmac->num_chans) { 
+		if(!(nx_dmac->chans[i].busy)) {
+			nx_dmac->chans[i].busy = true;
+			break;
+		}
+		i++;
+	}
+
+	/* Release DMAC lock */
+	mutex_unlock(&nx_dmac->dmac_lock);
+	
+	/* Return if channel not free */
+	if(i >= nx_dmac->num_chans) {
+		printk(KERN_ERR "nx_dmac: DMAC no free chan \r\n");	
+		return -EBUSY;	
+	}
+
+	/* Acquire channel */
+	chan = &nx_dmac->chans[i];
+	chanid = chan->chanid;
+	mutex_lock(&chan->chan_lock);
+	
+#if 0
+	/* Allocate DMAC LLI array */
+	chan->lli_ptr = kmalloc(sizeof(struct nx_dmac_lli_t) * 
+			tfr->num_reqs, GFP_DMA | GFP_KERNEL);
+	if(!chan->lli_ptr) {
+		printk(KERN_ERR "nx_dmac: DMAC LLI mem failure \r\n");	
+		mutex_unlock(&chan->chan_lock);
+		return -ENOMEM;		
+	}
+#endif
+
+	/* Initialise lli array */
+	for(j=0; j < tfr->num_reqs; j++) {
+		chan->lli_ptr[j].src_addr = tfr->req[j].src_addr;
+		chan->lli_ptr[j].dst_addr = tfr->req[j].dst_addr;
+		
+		ctrl_wrd = 0;
+		if(j == (tfr->num_reqs - 1)) {
+			chan->lli_ptr[j].next_lli = (uint32_t) NULL;
+			ctrl_wrd |= (1 << 31);										/* Enable TC interrupt */
+		}
+		else {
+			chan->lli_ptr[j].next_lli = chan->lli_phy + ((j+1) * sizeof(struct nx_dmac_lli_t));
+		}
+	
+		/* Control */
+		ctrl_wrd |= tfr->req[j].tfr_size & 0xFFF; /* Transfer size */
+		ctrl_wrd |= (tfr->req[j].src_brst << 12); /* Source burst size */
+		ctrl_wrd |= (tfr->req[j].dst_brst << 15); /* Destination burst size */
+		ctrl_wrd |= (tfr->req[j].src_width << 18); /* Source width - 32 bit */
+		ctrl_wrd |= (tfr->req[j].dst_width << 21); /* Destination width - 32 bit */
+		ctrl_wrd |= (tfr->req[j].src_inc << 26);	/* Source increment */
+		ctrl_wrd |= (tfr->req[j].dst_inc << 27);	/* Destination increment */
+		ctrl_wrd |= (tfr->req[j].src_ahb << 24); 	/* Source AHB */
+		ctrl_wrd |= (tfr->req[j].dst_ahb << 25); 	/* Destination AHB */
+		chan->lli_ptr[j].ctrl = ctrl_wrd;
+	}
+
+	/* Enable DMA HW, AHB mast1, AHB mast2 to little endian */
+	//writel(0x1, nx_dmac->dmac_base + NX_DMAC_CONFIG);
+	
+	/* Write the first LLI to HW */
+	chan_start = nx_dmac->dmac_base + (NX_DMAC_CHAN0_SRC + (NX_DMAC_CHAN_OFF * chanid));
+	writel(chan->lli_ptr[0].src_addr, chan_start);
+	writel(chan->lli_ptr[0].dst_addr, chan_start+0x4);
+	writel(chan->lli_ptr[0].next_lli, chan_start+0x8);
+	writel(chan->lli_ptr[0].ctrl, chan_start+0xC);
+
+	/* Clear the interrupts */
+	writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_TC_CLR);
+	writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_ERR_CLR);
+
+	/* Configure the channel */
+	chan_config = 0;
+	chan_config |= (tfr->req[0].src_per << 1);	/* Source peripheral number */
+	chan_config |= (tfr->req[0].dst_per << 6);	/* Destination peripheral number */
+	chan_config |= (tfr->req[0].flowctl << 11);	/* Flow control */
+	chan_config |= (1 << 15);			/* Unmask TC interrupt */
+	chan_config |= (1 << 14);			/* Unmask Error interrupt */
+	chan_config |= 0x1;				/* Enable channel */
+
+	chan->chan_status = 0xABCD;
+
+	/* Write chan config to HW */
+	writel(chan_config, chan_start + 0x10);
+	
+	/* Release the mutex */
+	mutex_unlock(&chan->chan_lock);
+
+	return chan->chanid;
+}
+
+/**
+* nx_dmac_complete - DMAC transfer complete function 
+* @chanid: Channel id
+*
+* Complete the DMAC transfers
+*/
+int	nx_dmac_tfr_comp(int chanid)
+{
+	int res;
+	struct nx_dmac_chan_t *chan;
+	void __iomem	*chan_start;
+	
+	/* Acquire DMAC lock */
+	mutex_lock(&nx_dmac->dmac_lock);
+	
+	/* Get the free channel */
+	chan = &nx_dmac->chans[chanid];
+	if(!(chan->busy)) {
+		printk(KERN_ERR "nx_dmac: DMAC tfr complete \r\n");
+		mutex_unlock(&nx_dmac->dmac_lock);
+		return -EIO;
+	}
+	
+	/* Release DMAC lock */
+	mutex_unlock(&nx_dmac->dmac_lock);
+
+	/* Acquire channel */
+	mutex_lock(&chan->chan_lock);
+	
+	/* Get the channel start */
+	chan_start = nx_dmac->dmac_base + (NX_DMAC_CHAN0_SRC + (NX_DMAC_CHAN_OFF * chanid));
+	
+	/* Wait for completion */
+	wait_event(chan->chan_queue, (((volatile __u32)chan->chan_status) != 0xABCD));
+	
+	/* status */
+	res = chan->chan_status;
+	
+	/* Disable channel */
+	writel(0x0, chan_start + 0x10);
+	
+	/* Disable DMA HW, AHB mast1, AHB mast2 to little endian */
+	//writel(0x0, nx_dmac->dmac_base + NX_DMAC_CONFIG);
+
+	/* Free memory */
+	//kfree(chan->lli_ptr);
+
+	/* Free channel */
+	chan->busy = false;
+	
+	/* Release channel */
+	mutex_unlock(&chan->chan_lock);
+
+	return res;
+}
+
+/**
+* nx_dmac_isr - DMAC ISR function 
+* @irq_no: IRQ number
+* @dev_id: Device ID
+*
+* Handles the DMAC interrupt events
+*/
+static irqreturn_t nx_dmac_isr(int irq_no ATTRIBUTE_UNUSED, void *dev_id)
+{
+	int	chanid;
+	uint32_t	int_stat, tc_stat, err_stat;
+	struct nx_dmac_chan_t *chan;
+	struct nx_dmac_t	*dmac=(struct nx_dmac_t *)dev_id;
+	
+	/* Read the interrupt status & chan ID */
+	int_stat = readl(dmac->dmac_base + NX_DMAC_INT_STATUS);
+	
+	chanid=0;
+	while(chanid < nx_dmac->num_chans) { 
+		if(int_stat & (1 << chanid)) {
+			/* Check TC interrupt */
+			chan = &dmac->chans[chanid];
+			tc_stat = readl(dmac->dmac_base + NX_DMAC_INT_TC_STATUS);
+			if(tc_stat & (1<<chanid)) {
+				chan->chan_status = 0;
+				writel((1<<chanid), dmac->dmac_base + NX_DMAC_INT_TC_CLR);
+				if (chanid==NX_DMAC_NOR_DMA_CHANNEL_ID)
+				{
+					nor_dma_done = true;
+				}
+				else
+				{
+					wake_up(&chan->chan_queue);
+				}
+			}
+				
+			/* Check Error interrupt */
+			err_stat = readl(dmac->dmac_base + NX_DMAC_INT_ERR_STATUS);
+			if(err_stat & (1<<chanid)) {
+				chan->chan_status = -EIO;
+				writel((1<<chanid), dmac->dmac_base + NX_DMAC_INT_ERR_CLR);
+				if (chanid==NX_DMAC_NOR_DMA_CHANNEL_ID)
+				{
+					nor_dma_error = true;
+					nor_dma_done = true;
+				}
+				else
+				{
+					wake_up(&chan->chan_queue);
+				}
+			}
+		}
+		chanid++;
+	}
+	
+	return IRQ_HANDLED;
+}
+
+/**
+* DMAC device registration
+*/
+static struct platform_driver nx_dmac_driver = {
+  .probe    = nx_dmac_probe,
+  .remove   = nx_dmac_remove,
+  .driver   = {
+    .name = "gcs_dma",
+    .owner  = THIS_MODULE,
+  },
+};
+
+/**
+* DMAC module init function
+*
+* Register the DMAC driver 
+*/
+static int __init nx_dmac_init(void)
+{
+	return platform_driver_register(&nx_dmac_driver);
+}
+
+/**
+* DMAC module exit function
+*
+* Unregister the DMAC driver
+*/
+static void __exit nx_dmac_exit(void)
+{
+	platform_driver_unregister(&nx_dmac_driver);
+}
+
+
+EXPORT_SYMBOL(nx_dmac_tfr);
+EXPORT_SYMBOL(nx_dmac_tfr_comp);
+
+module_init(nx_dmac_init);
+module_exit(nx_dmac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NXP B.V.");
+MODULE_DESCRIPTION("Linux DMAC IP_1902 driver");
diff -Naurp linux-2.6.34.orig/drivers/gcs_dmac/Kconfig linux-2.6.34/drivers/gcs_dmac/Kconfig
--- linux-2.6.34.orig/drivers/gcs_dmac/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/gcs_dmac/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,8 @@
+menu "GCS DMAC IP_1902 support"
+
+config MTD_NX_NAND_DMAC
+  tristate "GCS DMAC IP_1902 support"
+  help
+    Support for the GCS DMAC IP_1902 block in Apollo
+
+endmenu
diff -Naurp linux-2.6.34.orig/drivers/gcs_dmac/Makefile linux-2.6.34/drivers/gcs_dmac/Makefile
--- linux-2.6.34.orig/drivers/gcs_dmac/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/gcs_dmac/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,7 @@
+#Makefile for DMAC driver
+
+DMAC_EXTRA_FLAGS-$(CONFIG_ARCH_APOLLO) := -DMIPSEL
+
+EXTRA_CFLAGS   := $(DMAC_EXTRA_FLAGS-y)
+
+obj-$(CONFIG_MTD_NX_NAND_DMAC) += gcs_dmac.o
diff -Naurp linux-2.6.34.orig/drivers/gpio/apollo_gpio.c linux-2.6.34/drivers/gpio/apollo_gpio.c
--- linux-2.6.34.orig/drivers/gpio/apollo_gpio.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/gpio/apollo_gpio.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,455 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <mach/gpio.h>
+#include "apollo_gpio.h"
+
+/**
+ * Functions to Support interrupt functionality
+ **/
+static int apollo_gpio_int_set_type(unsigned irq, unsigned trigger)
+{
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	uint32_t val = 0;
+
+	if ( !(trigger & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH))) 
+		return -EINVAL;
+
+	if (trigger & IRQ_TYPE_EDGE_RISING) 
+		val |= 0x2;
+	if (trigger & IRQ_TYPE_EDGE_FALLING)
+		val |= 0x1;
+
+        if (trigger & IRQ_TYPE_LEVEL_HIGH)
+        {
+           val = 0;
+           set_irq_handler(irq, handle_level_irq);
+        }
+
+	gpset_type(ach->base, irq - ach->irq_base, val);
+
+	return 0;
+}
+
+static void apollo_gpio_int_mask(unsigned int irq)
+{
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	gpset_int_enable(ach->base, irq - ach->irq_base, 0);
+}
+
+static void apollo_gpio_int_unmask(unsigned int irq)
+{
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	gpset_int_enable(ach->base, irq - ach->irq_base, 1);
+}
+static void apollo_gpio_int_ack(unsigned int irq)
+{
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	gpclear_int(ach->base, irq - ach->irq_base);
+}
+
+
+
+
+
+static int apget_pending_irq(struct apollo_gpio_chip *ach)
+{
+	unsigned long flags;
+	int stray = ach->chip.ngpio & 0xF;
+	int i, cnt = (ach->chip.ngpio >> 4) + (stray != 0);
+	int ret;
+
+	local_irq_save(flags);
+	local_irq_disable();
+	for (i = 0; i < cnt; i ++) {
+		unsigned long val;
+		val = gpget_masked_int_status(ach->base, i);
+		if (!val) continue;
+		ret = find_first_bit(&val, sizeof(uint32_t) * BITS_PER_BYTE);
+                ret &= 0xF; /*To take care of the interrupt overrun status case in which the last 16bit contains the set status bit*/
+		break;
+	}
+
+	local_irq_restore(flags);
+	if (i >= cnt) return 0;
+	if (unlikely(ret >= 16)) {
+		dev_warn(ach->chip.dev, "Interrupt overflow at IRQ %d, GPIO %d\n",
+				ach->irq_base + (ret - 16) + (i << 4),
+				ach->chip.base + (ret - 16) + (i << 4));
+		return 0;
+	}
+
+        /*printk("apget_pending_irq--> i=%d ret=%d returnval=%d\n",i,ret,ret + (i << 4) + 1);*/
+
+	return ret + (i << 4) + 1;
+}
+
+static void handle_apollo_gpio_irq(unsigned irq, struct irq_desc *desc)
+{
+	struct apollo_gpio_chip * ach = get_irq_data(irq);
+	int pend, hcnt = 0;
+
+        desc->chip->ack(irq);
+
+	/* Let us dispatch all the IRQs in one shot */
+	while((pend = apget_pending_irq(ach))) {
+		generic_handle_irq(ach->irq_base + pend - 1);
+		hcnt ++;
+	}
+	if (unlikely(!hcnt)) {
+		dev_err(ach->chip.dev, "GPIO:: Spurious interrupt @ IRQ %d\n", irq);
+	}
+
+       desc->chip->unmask(irq);
+}
+
+static struct irq_chip apollo_gpio_irq_chip = {
+	.name		= "apollo_gpio",
+	.mask		= apollo_gpio_int_mask,
+	.unmask		= apollo_gpio_int_unmask,
+	.set_type	= apollo_gpio_int_set_type,
+	.ack        = apollo_gpio_int_ack,
+};
+
+static int apollo_gpio_int_init(struct apollo_gpio_chip *ach)
+{
+	int ret = 0, i;
+
+	for (i = 0; i < ach->chip.ngpio; i++) {
+		int irq;
+		irq = ach->irq_base + i;
+
+		set_irq_chip_and_handler(irq, &apollo_gpio_irq_chip,
+				handle_edge_irq);
+		set_irq_chip_data(irq, ach);
+		activate_irq(irq);
+	}
+
+	/* replace generic PIH handler (handle_simple_irq) */
+	set_irq_data(ach->irq, ach);
+	set_irq_chained_handler(ach->irq, handle_apollo_gpio_irq);
+
+	return ret;
+}
+
+
+
+void gpio_set_mode(unsigned int piono, unsigned int pinmode)
+{
+	unsigned int irq = gpio_to_irq(piono); 	/*unsigned int irq = GPIO0_IRQ_BASE + piono;*/
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	gpset_mode(ach->base, irq - ach->irq_base, pinmode);
+}
+EXPORT_SYMBOL(gpio_set_mode);
+
+int gpio_get_mode(unsigned int piono)
+{
+	unsigned int irq = gpio_to_irq(piono); 	/*unsigned int irq = GPIO0_IRQ_BASE + piono;*/
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	return gpget_mode(ach->base, irq - ach->irq_base);
+}
+EXPORT_SYMBOL(gpio_get_mode);
+
+#if 1 //remove only for test
+void apollo_gpio_set_interrupt(unsigned int piono)
+{
+	     unsigned int irq = gpio_to_irq(piono); 	/*unsigned int irq = GPIO0_IRQ_BASE + piono;*/
+            struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+            gpset_int_enable(ach->base, irq - ach->irq_base, 1);
+}
+EXPORT_SYMBOL(apollo_gpio_set_interrupt);
+#endif
+
+int gpio_interrupt_set_type(unsigned piono, unsigned trigger)
+{
+	unsigned int irq = gpio_to_irq(piono); 	/*unsigned int irq = GPIO0_IRQ_BASE + piono;*/
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	uint32_t val = 0;
+
+	if ( !(trigger & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH)))
+		return -EINVAL;
+
+	if (trigger & IRQ_TYPE_EDGE_RISING)
+		val |= 0x2;
+	if (trigger & IRQ_TYPE_EDGE_FALLING)
+		val |= 0x1;
+
+        /*FIXME::CHECK If this handle_level_irq assignment is the correct way and do we need this */
+	if (trigger & IRQ_TYPE_LEVEL_HIGH)
+        {
+           val = 0;
+           set_irq_chip_and_handler(irq, &apollo_gpio_irq_chip, handle_level_irq);
+	}
+
+	gpset_type(ach->base, irq - ach->irq_base, val);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_interrupt_set_type);
+
+
+/* For testing purpose */
+int gpio_interrupt_get_type(unsigned piono)
+{
+	unsigned int irq = gpio_to_irq(piono); 	
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+
+	return gpget_type(ach->base, irq - ach->irq_base);
+}
+EXPORT_SYMBOL(gpio_interrupt_get_type);
+
+
+void gpio_interrupt_clear(unsigned int piono)
+{
+	unsigned int irq = gpio_to_irq(piono); 	
+        apollo_gpio_int_ack(irq);
+}
+EXPORT_SYMBOL(gpio_interrupt_clear);
+
+
+int gpio_is_interrupt_enabled(unsigned int piono)
+{
+        int isirqenabled = 0;
+	unsigned int irq = gpio_to_irq(piono); 	
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+
+	isirqenabled = gpget_int_enable(ach->base, irq - ach->irq_base);
+
+        return isirqenabled;
+}
+EXPORT_SYMBOL(gpio_is_interrupt_enabled);
+
+int gpio_is_interrupt_pending(unsigned int piono)
+{
+        int isirqpending = 0;
+        unsigned long val=0;
+        unsigned int pioregindex = 0;
+        unsigned int piobitno = 0;
+	unsigned int irq = gpio_to_irq(piono); 	
+	   
+	struct apollo_gpio_chip *ach = get_irq_chip_data(irq);
+	
+        pioregindex = (irq - ach->irq_base) >> 4;
+        piobitno = (irq - ach->irq_base) & 0xF; 
+        val = gpget_masked_int_status(ach->base,pioregindex);
+        if ( (1 << piobitno) & val)
+        {
+            isirqpending = 1;
+        }
+	
+        return isirqpending;
+}
+EXPORT_SYMBOL(gpio_is_interrupt_pending);
+
+/**
+ * Functions to support pins functionality
+ * of GPIO. Must be used with gpiolib :)
+ **/
+static int apollo_gpio_direction_in(struct gpio_chip *chip,
+						unsigned offset)
+{
+	struct apollo_gpio_chip *ach = to_ach(chip);
+
+	BUG_ON(offset >= chip->ngpio);
+
+	/* Set mode to GPIO */
+	gpset_mode(ach->base, offset, GPIO_MODE_IO);
+	gpset_dir(ach->base, offset, GPIO_DIR_IN);
+	return 0;
+}
+
+static int apollo_gpio_direction_out (struct gpio_chip *chip,
+						unsigned offset, int value)
+{
+	struct apollo_gpio_chip *ach = to_ach(chip);
+
+	BUG_ON(offset >= chip->ngpio);
+	/* Set mode to GPIO */
+	gpset_dir(ach->base, offset, 
+			(value & 1) ? GPIO_DIR_OUT_HI : GPIO_DIR_OUT_LO);
+	gpset_mode(ach->base, offset, GPIO_MODE_IO);
+	return 0;
+}
+
+static void apollo_gpio_set(struct gpio_chip *chip,
+						unsigned offset, int value)
+{
+	struct apollo_gpio_chip *ach = to_ach(chip);
+
+	BUG_ON(offset >= chip->ngpio);
+	gpset_dir(ach->base, offset, 
+			(value & 1) ? GPIO_DIR_OUT_HI : GPIO_DIR_OUT_LO);
+}
+
+static int apollo_gpio_get(struct gpio_chip *chip,
+						unsigned offset)
+{
+	struct apollo_gpio_chip *ach = to_ach(chip);
+
+	BUG_ON(offset >= chip->ngpio);
+
+	return gpget_value(ach->base, offset);
+}
+
+static int apollo_gpio_to_irq(struct gpio_chip *chip,
+						unsigned offset)
+{
+	struct apollo_gpio_chip *ach = to_ach(chip);
+
+	BUG_ON(offset >= chip->ngpio);
+
+	return ach->irq_base + offset;
+}
+
+static void apgpio_init_chip(struct apollo_gpio_chip *ach)
+{
+	ach->chip.label			= "gpio_apollo";
+	ach->chip.owner			= THIS_MODULE;
+	ach->chip.can_sleep		= 1;
+
+	/**
+	 * All the functions are called with spin locked
+	 * So, we don't have to bother about SMP race.
+	 **/
+#if 0
+	/**
+	 * TODO: May be useful later
+	 **/
+	ach->chip.request           = apollo_gpio_request;
+	ach->chip.free              = apollo_gpio_free;
+#endif
+	ach->chip.direction_input   = apollo_gpio_direction_in;
+	ach->chip.get               = apollo_gpio_get;
+	ach->chip.direction_output	= apollo_gpio_direction_out;
+	ach->chip.set               = apollo_gpio_set;
+	ach->chip.to_irq            = apollo_gpio_to_irq;
+}
+
+/**
+ * Platform driver init and exit functions
+ **/
+static int __devinit gpio_apollo_probe(struct platform_device *pdev)
+{
+	struct apollo_gpio_platform_data *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	struct apollo_gpio_chip *ach;
+	struct resource *res;
+	int i;
+
+	if (unlikely(pdata == NULL || pdata->nr_gpio <= 0)) {
+		dev_err(&pdev->dev, "GPIO parameters invalid\n");
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (unlikely(res == NULL)) {
+		dev_err(&pdev->dev, "No Memory resource found\n");
+		return -ENXIO;
+	}
+
+	ach = kzalloc(sizeof *ach, GFP_KERNEL);
+	if (unlikely(ach == NULL)) {
+		dev_err(&pdev->dev, "Unable to allocate chip memory\n");
+		return -ENOMEM;
+	}
+
+	ach->irq = platform_get_irq(pdev, 0);
+	if (unlikely(!ach->irq)) {
+		dev_err(&pdev->dev, "No IRQ resource found\n");
+		ach->no_irq = 1;
+	} else if (is_module()) {
+		dev_warn(&pdev->dev, "Interrupt cannot be dispatched "
+				"from a module!\n");
+		ach->no_irq = 1;
+	} else if (unlikely(!pdata->irq_base)) 
+		ach->no_irq = 1;
+
+	ach->irq_base = pdata->irq_base;
+	ach->chip.dev = &pdev->dev;
+	ach->chip.base = pdata->first_pin;
+	ach->chip.ngpio = pdata->nr_gpio;
+	apgpio_init_chip(ach);
+
+	ach->base = devm_ioremap(&pdev->dev, res->start, 
+			res->end - res->start + 1);
+
+	if (unlikely(ach->base == NULL)) {
+		dev_err(&pdev->dev, "Unable to ioremap the address range\n");
+		kfree(ach);
+		return -ENOMEM;
+	}
+
+	if (!apgpio_check_moduleid(ach->base)) {
+		dev_err (&pdev->dev, "No GPIO device found @ %p\n",
+				(void __iomem *) res->start);
+		kfree(ach);
+		return -ENODEV;
+	}
+
+	/* Disable and clear all interrupts at this point */
+	for (i = 0; i < (pdata->nr_gpio >> 4) + ((pdata->nr_gpio & 0x0F) != 0); i ++) {
+		writel(0, ach->base + GPIO_CTRL_REG + (i * 4));
+		writel(0xFFFF, ach->base + GPIO_INT_CLEAR + (i * 4));
+		writel(0, ach->base + GPIO_INT_ENABLE + (i * 4));
+	}
+	ret = gpiochip_add(&ach->chip);
+	
+	if (ret < 0) {
+		dev_err (&pdev->dev, "Unable to register GPIO Chip\n");
+		kfree(ach);
+		return ret;
+	}
+
+	if(!ach->no_irq)
+		apollo_gpio_int_init(ach);
+	else
+		dev_warn(&pdev->dev, "No Interrupt controller "
+				"functionality will be available\n");
+
+	return ret;
+}
+
+static int __devexit gpio_apollo_remove(struct platform_device *pdev)
+{
+	/**
+	 * We only have to free our device structure
+	 * everything else is removed by devm layer.
+	 * If we are here we had definitely skipped
+	 * interrupt part in probe :)
+	 **/
+	kfree(platform_get_drvdata(pdev));
+	return 0;
+}
+
+static struct platform_driver gpio_apollo_driver = {
+	.driver.name	= "gpio_apollo",
+	.driver.owner	= THIS_MODULE,
+	.probe		= gpio_apollo_probe,
+	/*.remove		= __devexit_p(gpio_apollo_remove),*/
+};
+
+/**
+ * This call must be under subsys_initcall as
+ * Some of the GPIOs are used as interrupt pins
+ * So, before any init call of driver is made
+ * GPIO must be set up and ready
+ */
+static int __init gpio_apollo_init(void)
+{
+	return platform_driver_register(&gpio_apollo_driver);
+}
+subsys_initcall(gpio_apollo_init);
+
+static void __exit gpio_apollo_exit(void)
+{
+	platform_driver_unregister(&gpio_apollo_driver);
+}
+module_exit(gpio_apollo_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sundarapandian A <sundarapandian.andithevar@nxp.com");
+MODULE_DESCRIPTION("Apollo GPIO device driver");
diff -Naurp linux-2.6.34.orig/drivers/gpio/apollo_gpio.h linux-2.6.34/drivers/gpio/apollo_gpio.h
--- linux-2.6.34.orig/drivers/gpio/apollo_gpio.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/gpio/apollo_gpio.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,201 @@
+#ifndef __APOLLO_GPIO_H
+#define __APOLLO_GPIO_H
+
+#ifdef __KERNEL__
+#include <linux/gpio.h>
+struct apollo_gpio_chip
+{
+	struct gpio_chip chip;
+	int irq_base;
+	int irq;
+	struct mutex mutex;
+	spinlock_t lock;
+	uint32_t usage;
+	void __iomem * base;
+	unsigned int no_irq:1;
+};
+
+#define GET_OFFSET(off)      (off >> 4)
+#define GET_OFFSET_WORD(off) (off >> 5)
+
+#define GPIO_MODE_CTRL       0x000
+#define GPIO_MASK_IODATA     0x038
+#define GPIO_CTRL_REG        0x070
+#define GPIO_INT_STATUS      0x0A8
+#define GPIO_INT_ENABLE      0x0E0
+#define GPIO_INT_CLEAR       0x0FC
+#define GPIO_INT_SET         0x118
+#define GPIO_POWER_DOWN      0xFF4
+#define GPIO_MODULE_REG      0xFFC
+
+#define GPIO_MODULE_ID       41108 /* FIXME: to be done */
+
+
+#define GPIO_MODE_PRIMARY    0x01UL
+#define GPIO_MODE_IO         0x02UL
+#define GPIO_MODE_OPENDRAIN  0x03UL
+
+#define GPIO_DIR_IN          0x01UL
+#define GPIO_DIR_OUT_LO      0x02UL
+#define GPIO_DIR_OUT_HI      0x03UL
+
+static inline void gpset_mode(void __iomem * base, int offset, int mode)
+{
+       uint32_t regoffset = GPIO_MODE_CTRL + (GET_OFFSET(offset)*sizeof(uint32_t*));
+
+       uint32_t pinvalue = ((mode & 0x03) << ((offset & 0xF) * 2));
+       uint32_t regvalue = readl(base + regoffset);
+       regvalue &=(~(3 << ((offset & 0xF) * 2)));
+       regvalue |= pinvalue;
+
+       writel(regvalue, base + regoffset);
+}
+
+static inline int gpget_mode(void __iomem * base, int offset)
+{
+       return readl(base + GPIO_MODE_CTRL + (GET_OFFSET(offset)*sizeof(uint32_t*)));
+}
+
+
+static inline void gpset_dir(void __iomem * base, int offset, int mode)
+{
+       uint32_t regoffset = GPIO_MASK_IODATA + (GET_OFFSET(offset)*sizeof(uint32_t*));
+	uint32_t off = offset & 0xF;
+       uint32_t pinvalue = ((mode & 1) << off) | ((mode & 2) << (15 + off));
+       uint32_t regvalue = readl(base + regoffset);
+       regvalue &=(~(0x10001 << off));
+       regvalue |= pinvalue;
+
+       writel(regvalue, base + regoffset);
+}
+
+static inline int gpget_dir(void __iomem * base, int offset)
+{
+       return readl(base + GPIO_MASK_IODATA + (GET_OFFSET(offset)*sizeof(uint32_t*)));
+}
+
+
+static inline int gpget_value(void __iomem * base, int offset)
+{
+	return (readl(base + GPIO_MASK_IODATA + (GET_OFFSET(offset)*sizeof(uint32_t*))) 
+			& BIT(offset & 0xF)) != 0;
+}
+
+static inline void gpset_type(void __iomem * base, int offset, int type)
+{
+       uint32_t regoffset = GPIO_CTRL_REG + (GET_OFFSET(offset)*sizeof(uint32_t*));
+
+	uint32_t val = readl(base + regoffset);
+	int off = (offset & 0x0F) << 1;
+
+	val = (val & ~(3UL << off)) | (type << off);
+
+	writel(val, base + regoffset);
+}
+
+static inline int gpget_type(void __iomem * base, int offset)
+{
+	return readl(base + GPIO_CTRL_REG + GET_OFFSET(offset));
+}
+
+static inline uint32_t gpget_masked_int_status(void __iomem * base, int offset)
+{
+       uint32_t intstatusval;
+       uint32_t regoffsetintenb = GPIO_INT_ENABLE + ((offset/2) * sizeof(uint32_t*));
+       uint32_t regoffsetintstatus = GPIO_INT_STATUS + ((offset) * sizeof(uint32_t*));
+       uint32_t intenbaleval = readl(base + regoffsetintenb);
+
+       if (0 == (offset % 2)) /*1st 16 bit*/
+       {
+           intenbaleval &= 0xFFFFUL;
+           intenbaleval |= (intenbaleval << 16);
+       }
+       else
+       {
+           intenbaleval &= 0xFFFF0000UL;
+           intenbaleval |= (intenbaleval >> 16);
+       }
+
+       intstatusval = readl(base + regoffsetintstatus);
+
+       /*printk("gpget_masked_int_status::intenbaleval=%x intstatusval=%x\n",intenbaleval,intstatusval);*/
+
+      return (intenbaleval & intstatusval);
+}
+
+static inline struct apollo_gpio_chip *to_ach(struct gpio_chip *chip)
+{
+	return container_of(chip, struct apollo_gpio_chip, chip);
+}
+
+static inline void gpset_int_enable(void __iomem * base, int offset, int en)
+{
+	uint32_t val;
+       uint32_t regoffsetintenb = GPIO_INT_ENABLE + (GET_OFFSET_WORD(offset)*sizeof(uint32_t));
+	val = readl(base + regoffsetintenb);
+	val &= ~BIT(offset & 0x1F);
+	val |= en << (offset & 0x1F);
+	writel(val, base + regoffsetintenb);
+}
+
+static inline uint32_t gpget_int_enable(void __iomem * base, int offset)
+{
+        uint32_t val;
+       uint32_t regoffsetintenb = GPIO_INT_ENABLE + (GET_OFFSET_WORD(offset)*sizeof(uint32_t));
+        val = readl(base + regoffsetintenb);
+        val &= BIT(offset & 0x1F);
+        val = (val >> (offset & 0x1F));
+        return val ;
+}
+
+
+static inline uint32_t gpget_powermode(void __iomem * base)
+{
+	uint32_t powermode = readl(base + GPIO_POWER_DOWN);
+	powermode &= BIT(31); /*31th bit of power down register describes the power mode*/
+	powermode = (powermode >> 31);
+	return powermode;
+}
+
+static inline void gpset_powermode(void __iomem * base, int mode)
+{
+	uint32_t powermode = readl(base + GPIO_POWER_DOWN);
+	powermode &= ~(BIT(31)); /*31th bit of power down register describes the power mode*/
+	powermode |= (mode&0x1) << 31;  /*TODO*/
+
+	writel(powermode, base + GPIO_POWER_DOWN);
+}
+
+
+static inline void gpclear_int(void __iomem * base, int offset)
+{
+	writel(BIT(offset & 0x1F), base + GPIO_INT_CLEAR + (GET_OFFSET_WORD(offset)*sizeof(uint32_t)));
+}
+
+static inline int apgpio_check_moduleid(void __iomem * base)
+{
+	return (readl(base + GPIO_MODULE_REG) >> 16) == GPIO_MODULE_ID;
+}
+
+/* genirq interfaces are not available to modules */
+#ifdef MODULE
+#define is_module()	true
+#else
+#define is_module()	false
+#endif
+#endif /* __KERNEL__ */
+
+static inline void activate_irq(int irq)
+{
+#ifdef CONFIG_ARM
+	/* ARM requires an extra step to clear IRQ_NOREQUEST, which it
+	 * sets on behalf of every irq_chip.  Also sets IRQ_NOPROBE.
+	 */
+	set_irq_flags(irq, IRQF_VALID);
+#else
+	/* same effect on other architectures */
+	set_irq_noprobe(irq);
+#endif
+}
+
+#endif /* __APOLLO_GPIO_H */
diff -Naurp linux-2.6.34.orig/drivers/gpio/Kconfig linux-2.6.34/drivers/gpio/Kconfig
--- linux-2.6.34.orig/drivers/gpio/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/gpio/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -94,6 +94,16 @@ config GPIO_VR41XX
 	help
 	  Say yes here to support the NEC VR4100 series General-purpose I/O Uint
 
+config GPIO_APOLLO
+	tristate "APOLLO GPIO support"
+	depends on ARCH_APOLLO
+	help
+	  Say Y here if you want to enable GPIO support for APOLLO
+	  SoC on STB boards. Some of the GPIOs may be used as interrupts
+	  and in that case you must say 'Y' here or else the board might not
+	  boot at all. Say 'M' here if you want to compile it as module.
+	  Never say M or N unless you are very sure about what you are doing.
+
 config GPIO_SCH
 	tristate "Intel SCH GPIO"
 	depends on GPIOLIB && PCI
diff -Naurp linux-2.6.34.orig/drivers/gpio/Makefile linux-2.6.34/drivers/gpio/Makefile
--- linux-2.6.34.orig/drivers/gpio/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/gpio/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -27,4 +27,5 @@ obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
 obj-$(CONFIG_GPIO_WM8350)	+= wm8350-gpiolib.o
 obj-$(CONFIG_GPIO_WM8994)	+= wm8994-gpio.o
+obj-$(CONFIG_GPIO_APOLLO)       += apollo_gpio.o
 obj-$(CONFIG_GPIO_SCH)		+= sch_gpio.o
\ No newline at end of file
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm.c linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm.c
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1561 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ * Revision History
+ * Version  Author             Date          Remarks
+ * 0.1    Sangeeta Mutgi      12/08/2005    Proposal
+ * 0.5    Sangeeta Mutgi      01/25/2006    Review comments
+ * 0.11   Sangeeta Mutgi      17/02/2006    Accepted after testing
+ * 0.12   Sangeeta Mutgi      17/03/2006    Speed setting interface.
+ * 0.13   Sangeeta Mutgi      27/03/2006    GDB support PR solution
+ * 0.14   Sangeeta Mutgi      18/05/2006    Removal of Kfree(comments Denis)
+ * 0.15   Sangeeta Mutgi      13/07/2006    Removal of spin_lock
+ * 0.16   Sangeeta Mutgi      10/08/2006    Hotboot support
+ * 0.17   Sangeeta Mutgi      16/11/2006    bus error PR
+ * 0.18   Sangeeta Mutgi      20/11/2006    Timeout for Master Transfer
+ * 0.19   Sangeeta Mutgi      28/11/2006    added Deinit and init in bus error
+ * 0.20   Sangeeta Mutgi      18/12/2006    SoftReset interface added
+ * 0.21   Sangeeta Mutgi      02/01/2007    General call CR
+ * 0.22   Sangeeta Mutgi      13/02/2007    Replace local_irq_disable/enable
+ * 0.23   Sangeeta Mutgi      20/02/2007    Error handling for timeout cases
+ * 0.24   Sangeeta Mutgi      13/04/2007    Timeout in milliseconds. Min is 500ms
+ * 0.25   Sangeeta Mutgi      27/04/2007    Zero byte slave transfer support
+ * 0.26   Sangeeta Mutgi      07/08/2007    Oslinux 6.0 update
+ * 0.27   Sangeeta Mutgi      25/06/2008    Diagnostics code added
+ * 0.28   Sangeeta Mutgi      14/07/2008    Workaround for Missing Master states
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+
+#ifdef CONFIG_PNX8XXX_HOTBOOT
+#include <linux/notifier.h>
+#include <hotboot.h>
+#endif
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c_phlm.h>
+#include <linux/mm.h>
+
+#include "i2c_phlm_cfg.h"
+#include "tmhwI2c.h"
+
+
+
+#ifdef CONFIG_I2C_DEBUG
+#define dbg_print(str...) printk(str)
+#else
+#define dbg_print(str...)
+#endif
+
+#ifdef CONFIG_I2C_DEBUG
+extern void I2c_Error_Trigger( void );
+#endif
+
+/*************************************
+*data structures
+**************************************/
+
+typedef struct
+{
+    __u64 int_pin;                       /* interrupt line for I2c unit*/
+    __u32 unit_num;                    /* i2c unit number */
+    wait_queue_head_t i2c_wait_master; /* for synchronous master */
+    wait_queue_head_t i2c_wait_slave;
+    int  mst_status;                   /* status of the  message.
+                                For Master: num of messages transferred*/
+    int  slv_status;                   /*For Slave :Trasnmit Done or Read Done
+                                event */
+    __u8 *dma_buf;                      /* Virtual pointer to Dma buffer */
+    __u32 dma_addr_phy;            /* dma buffer physical address */
+    __u32 num_of_msgs;                /* total number of msgs submitted 1, 2..
+                                   Valid for Master. Ignore this value for  Slave*/
+    __u32 msg_index;                 /* Num of messages transferred
+                                  Valid for Master. Ignore this value for Slave*/
+    __u32 mst_timeout;             /* Timeout for master transfer*/
+        __u32 slv_timeout;              /* Timeout for slave transfer*/
+    struct i2c_msg *i2c_mst_messages;
+                              /* chain of Master messages requested for transfer.*/
+    i2c_slave_data i2c_slave_message;
+    i2c_ph_xferspeed i2c_speedkhz;
+    volatile __u8   slave_enabled;    /* True :slave is enabled for this unit*/
+    volatile __u8   done;             /* True : master transfer done.*/
+    volatile __u8   slvdone;          /* True : slave transfer done */
+    volatile __u8   slvstarted;       /* True : slave request event occured*/
+    volatile __u8   bus_busy;         /* True : unit/bus is busy */
+    volatile __u8   master_active;    /* True : master transfer set by user */
+    volatile __u8   master_start;     /* True : master has obtained the bus */
+    volatile __u8   master_lost;      /* True : master arbitration lost occured*/
+    volatile __u8   set_slave_disable;
+
+}i2c_phlm_bus_t;
+
+
+
+/*********************************************************
+Globals
+**********************************************************/
+
+static i2c_phlm_bus_t *i2c_phlm_busobjects;
+static struct i2c_algorithm *i2c_phlm_algorithms;
+
+static unsigned int i2c_phlm_units;
+
+static int* i2c_phlmno_adapterno_map;   /*Added for I2C Wrapper Driver interface*/
+
+#ifdef CONFIG_PNX8XXX_HOTBOOT
+struct notifier_block hotboot_notify;
+#endif
+/*********************************************************
+Local functions
+**********************************************************/
+
+
+static void i2c_mst_request(__u32 i2c_unit,
+                    i2c_phlm_bus_t * busobject,
+                    __u32 event);
+
+static void i2c_mst_done(__u32 i2c_unit,
+                 i2c_phlm_bus_t * busobject,
+                 __u32 event);
+
+static void i2c_slv_request(__u32 i2c_unit,
+                    i2c_phlm_bus_t * busobject,
+                    __u32 event,
+                    tmhwI2cDirection_t dir);
+
+static void i2c_slv_done(__u32 i2c_unit,
+                 i2c_phlm_bus_t * busobject,
+                 __u32 event, tmhwI2cDirection_t dir);
+
+
+static void i2c_slave_mst_control( __u32 i2c_unit,
+                              i2c_phlm_bus_t * busobject);
+
+static int i2c_algo_transfer(struct i2c_adapter *i2c_adap,
+                     struct i2c_msg msgs[],
+                     int num_msgs);
+
+static int i2c_algo_control(struct i2c_adapter *adapter,
+                    unsigned int cmd,
+                    unsigned long arg);
+
+static int  i2c_slave_enable(struct i2c_adapter *adapter,
+                     unsigned long data_length);
+
+
+static int i2c_slave_disable(struct i2c_adapter *adapter);
+
+static void i2c_slave_cleanup(i2c_phlm_bus_t *busobject);
+
+static int i2c_add_bus(int device, struct i2c_adapter *adap);
+static int i2c_delete_bus(struct i2c_adapter *adap);
+
+#ifdef CONFIG_PNX8XXX_HOTBOOT
+static int i2c_hotboot(struct notifier_block * self, unsigned long val, void * data);
+#endif
+
+static int i2c_softReset(unsigned int i2c_unit);
+static int i2c_master_timeout(i2c_phlm_bus_t *busobject);
+
+/*
+ * i2c_isr - interrupt service routine
+ * Returns : IRQ_HANDLED
+ * Descn.  : handles the interrupts.
+ */
+static irqreturn_t i2c_isr(int irq, void *dev_id)
+{
+    // get the BusObject
+    i2c_phlm_bus_t * busobject = (i2c_phlm_bus_t *)dev_id;
+    __u32  event;
+    __u32 i2c_unit = busobject->unit_num;
+    tmhwI2cStatusType_t intr_status_type;
+    __u8 slave_monitor;
+
+    /* When the current message has been finished, the device returns to
+    addressed slave mode if slave_monitor = True. */
+    slave_monitor = False;
+
+    if ( busobject->slave_enabled == True){
+    slave_monitor = True;
+    }
+
+    tmhwI2cIntGetStatus(i2c_unit, &intr_status_type);
+
+    if (intr_status_type == tmhwI2cNoInterrupt){
+    return IRQ_HANDLED;
+    }
+
+    busobject->bus_busy = True;
+
+    /* Invoke the tmHwI2cEvent . Interrupt event*/
+    event= tmhwI2cEvent(i2c_unit, tmhwI2cEventInterrupt, slave_monitor);
+    switch(event)
+    {
+    case TMHW_ERR_I2C_BUSY:
+    /* nointerrupt, probably polling */
+    return IRQ_HANDLED;
+
+
+    case TM_OK:
+    break;
+
+    case TMHW_ERR_I2C_EVENT_MST_REQ:
+    case TMHW_ERR_I2C_EVENT_MST_TRX_REQ:
+    case TMHW_ERR_I2C_EVENT_MST_REC_REQ:
+
+    /* Invoke i2c_mst_request */
+    i2c_mst_request(i2c_unit, busobject, event);
+    tmhwI2cEvent(i2c_unit,tmhwI2cEventProceed,slave_monitor);
+    break;
+
+    case TMHW_ERR_I2C_EVENT_MST_LOST:
+
+    busobject->msg_index = 0; /* retry the whole message */
+    busobject->bus_busy = False;
+    busobject->master_lost = True;
+    busobject->master_start = False;
+    break;
+
+    case TMHW_ERR_I2C_EVENT_MST_TRX_DONE:
+    case TMHW_ERR_I2C_EVENT_MST_TRX_ABORT :
+    case TMHW_ERR_I2C_EVENT_MST_ABORT:
+    case TMHW_ERR_I2C_EVENT_MST_REC_DONE:
+    case TMHW_ERR_I2C_EVENT_MST_REC_ABORT:
+    if ( busobject->master_active == True )
+    {/* PR : Workaround
+      * Missing Master states 0x08,0x40.So, master_active is not set
+      * This will cause a NULL ptr in mst_msgs. Hence this workaround */
+         i2c_mst_done(i2c_unit, busobject, event);
+    }
+    /* else do nothing ignore this state */
+    break;
+
+    case TMHW_ERR_I2C_EVENT_SLV_REC_REQ_MST_LOST:
+    case TMHW_ERR_I2C_EVENT_SLV_GC_REQ_MST_LOST:
+    busobject->msg_index = 0; /* retry the whole message */
+    busobject->master_start = False;
+    busobject->master_lost = True;
+            /* ignoremaster lost */
+    case TMHW_ERR_I2C_EVENT_SLV_GC_REQ:
+    case TMHW_ERR_I2C_EVENT_SLV_REC_REQ:
+    i2c_slv_request(i2c_unit, busobject, event, tmhwI2cReceive);
+    tmhwI2cEvent(i2c_unit,tmhwI2cEventProceed,slave_monitor);
+    break;
+
+    case TMHW_ERR_I2C_EVENT_SLV_REC_DONE:
+    case TMHW_ERR_I2C_EVENT_SLV_REC_ABORT:
+    i2c_slv_done(i2c_unit, busobject, event, tmhwI2cReceive);
+    break;
+
+    case TMHW_ERR_I2C_EVENT_SLV_TRX_REQ_MST_LOST:
+    busobject->msg_index = 0; /* retry the whole message */
+    busobject->master_start = False;
+    busobject->master_lost = True;
+
+    case TMHW_ERR_I2C_EVENT_SLV_TRX_REQ:
+
+    i2c_slv_request(i2c_unit, busobject, event, tmhwI2cTransmit);
+    tmhwI2cEvent(i2c_unit,tmhwI2cEventProceed,slave_monitor);
+    break;
+
+    case TMHW_ERR_I2C_EVENT_SLV_TRX_DONE:
+    case TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT:
+    i2c_slv_done(i2c_unit, busobject, event, tmhwI2cTransmit);
+    break;
+
+     /* buserror */
+    case (TMHW_ERR_I2C_EVENT_BUS_ERROR):
+    if ( busobject->master_active == True ){
+        i2c_mst_done( i2c_unit, busobject, event);
+    }
+    else if ( busobject->slave_enabled == True ){
+        i2c_slv_done(i2c_unit, busobject, event, tmhwI2cTransmit);
+    }
+    break;
+
+    default :
+    dbg_print("ERROR in state machine\n ");
+    dbg_print( "Assertion failed! %s,%s,line=%d\n",\
+                __FILE__,__FUNCTION__,__LINE__);
+    break;
+    }
+    i2c_slave_mst_control(i2c_unit, busobject);
+
+    return IRQ_HANDLED;
+
+}
+
+/*
+ * i2c_slave_mst_control
+ * Returns : None
+ * Pre condn : Bus idle
+ * Descn.  : Starts Master and Slave if required after the isr completes.
+ */
+
+static void i2c_slave_mst_control( __u32 i2c_unit, i2c_phlm_bus_t *
+                                                 busobject)
+{
+
+ __u32 slave_addr;
+ tmhwI2cDirection_t direction;
+
+ if ( busobject->bus_busy == False ){
+
+     /* Check if Slave mode is enabled */
+     if  (busobject->slave_enabled == True){
+        /* Enable general call only if set to true */
+        if ( busobject->i2c_slave_message.general_call == True )
+        {
+            tmhwI2cEnableGeneralCall(busobject->unit_num);
+        }
+
+        tmhwI2cSetSlaveAddr(busobject->unit_num,
+                busobject->i2c_slave_message.slave_addr);
+        tmhwI2cStartSlave(i2c_unit);
+     }
+     else{
+    tmhwI2cStopSlave( i2c_unit);
+     }
+
+     /* Check if the master is active and messages pending */
+     if (   busobject->master_active == True ){
+
+       slave_addr = busobject->i2c_mst_messages[0].addr;
+    if (busobject->i2c_mst_messages[0].flags & I2C_M_RD ){
+          direction =  tmhwI2cReceive;
+    }
+    else{
+         direction = tmhwI2cTransmit;
+    }
+
+    /* Start the Master. Transfer starts from first message*/
+    tmhwI2cStartMaster( i2c_unit, slave_addr, direction);
+     }
+ }
+}
+
+/*
+ * i2c_slv_request
+ * Returns : None
+ * Pre condn : None.
+ * Descn.  : Handles Slave Request interrupt.
+ */
+static void i2c_slv_request(__u32 i2c_unit,
+                    i2c_phlm_bus_t *busobject,
+                    __u32 event, tmhwI2cDirection_t direction)
+{
+    tmhwI2cData_t data;
+    i2c_slave_data *slvmsg = &(busobject->i2c_slave_message);
+
+    data.direction = direction;
+
+    if  (direction ==tmhwI2cTransmit ){
+    data.pAddress =  slvmsg->tx_buf;
+    data.counter =   slvmsg->tx_data_length;
+    data.length =    slvmsg->tx_data_length;
+
+    }
+    else{
+    data.pAddress =  slvmsg->rx_buf;
+    data.counter = slvmsg->rx_data_length;
+    data.length =  slvmsg->rx_data_length;
+    }
+    data.attach = tmhwI2cStop;
+
+    tmhwI2cSetData(i2c_unit, &data);
+
+    busobject->slvstarted = True;
+      /* Slave has been addressed. Now put the slave wait
+      with timeout */
+    wake_up_interruptible(&(busobject->i2c_wait_slave));
+
+}
+
+/*
+ * i2c_slv_done
+ * Returns : None
+ * Pre condn : None.
+ * Descn.  : Handles Slave Done interrupt.
+ */
+static void i2c_slv_done(__u32 i2c_unit,
+                 i2c_phlm_bus_t * busobject,
+                 __u32 event, tmhwI2cDirection_t direction)
+{
+    tmhwI2cData_t data;
+    i2c_slave_data *slvmsg = &(busobject->i2c_slave_message);
+
+    tmhwI2cGetData(i2c_unit, &data);
+
+    if ( event == TMHW_ERR_I2C_EVENT_BUS_ERROR){
+        busobject->slv_status = I2C_SLAVE_BUS_ERROR;
+    }
+    else{
+        if ( direction == tmhwI2cReceive ){
+            busobject->slv_status = I2C_SLAVE_RD_DONE;
+        }
+        else{
+            busobject->slv_status = I2C_SLAVE_WR_DONE;
+        }
+    }
+
+    slvmsg->rx_tx_bytecount = data.length - data.counter;
+
+    busobject->slvdone = True;
+
+    /* Disable the unit till the task is serviced */
+    tmhwI2cIntDisable(i2c_unit);
+
+    wake_up(&(busobject->i2c_wait_slave));
+
+
+}
+
+/*
+ * i2c_mst_request
+ * Returns : None
+ * Pre condn : None.
+ * Descn.  : Handles Master Request interrupt.
+ */
+static void i2c_mst_request(__u32 i2c_unit,
+                    i2c_phlm_bus_t * busobject, __u32 event)
+{
+    tmhwI2cData_t data;
+    struct i2c_msg *mst_msg =
+            &(busobject->i2c_mst_messages[busobject->msg_index]);
+
+    /* Set the flag master_start = True */
+    busobject->master_start = True;
+    busobject->master_lost = False;
+
+    /* Set the data */
+    data.length =  mst_msg->len;
+    data.counter = mst_msg->len;
+    data.pAddress = mst_msg->buf;
+    data.slaveAddress = mst_msg->addr;
+
+    if ( mst_msg->flags & I2C_M_RD )
+       data.direction = tmhwI2cReceive;
+    else
+        data.direction = tmhwI2cTransmit;
+
+
+    if ( busobject->num_of_msgs == (busobject->msg_index+1) ){
+        data.attach = tmhwI2cStop;
+    }
+
+    else{
+        struct i2c_msg *mst_msg_next =
+        &(busobject->i2c_mst_messages[busobject->msg_index + 1]);
+
+        if ( mst_msg_next->flags & I2C_M_RD ){ /* Receive */
+            if ( data.direction == tmhwI2cReceive ){
+                if ((mst_msg->flags  & I2C_M_NOSTART) == I2C_M_NOSTART )
+                    data.attach = tmhwI2cChain;
+                else
+                    data.attach = tmhwI2cRestart;
+                }
+
+            else
+                data.attach = tmhwI2cRestart;
+        }/*Receive*/
+        else{ /* transmit */
+            if ( data.direction == tmhwI2cReceive )
+                data.attach = tmhwI2cRestart;
+            else{
+                if (mst_msg->flags   == I2C_M_NOSTART )
+                         data.attach = tmhwI2cChain;
+                else
+                        data.attach = tmhwI2cRestart;
+            }
+        }/*transmit*/
+    }
+
+    busobject->msg_index += 1;
+
+    if ( busobject->msg_index == 1 )
+    {
+        data.bHS = busobject->i2c_speedkhz.hs;
+        tmhwI2cSetSpeed(i2c_unit, busobject->i2c_speedkhz.fskhz,
+                                busobject->i2c_speedkhz.hskhz);
+    }
+    tmhwI2cSetData(i2c_unit, &data);
+
+}
+
+/*
+ * i2c_mst_done
+ * Returns : None
+ * Pre condn : None.
+ * Descn.  : Handles Master Done interrupt.
+ */
+static void i2c_mst_done(__u32 i2c_unit,
+                 i2c_phlm_bus_t *busobject,
+                 __u32 event)
+{
+    tmhwI2cData_t data;
+    struct i2c_msg *mst_msg =
+    &(busobject->i2c_mst_messages[busobject->msg_index-1]);
+
+    tmhwI2cGetData(i2c_unit, &data);
+    mst_msg->len = data.length - data.counter;
+
+    if ( event == TMHW_ERR_I2C_EVENT_BUS_ERROR){
+        /* I2C-bus error.
+         * Workaround for STOP bit reset in INTROG register*/
+        tmhwI2cDeinit(i2c_unit);
+        tmhwI2cInit(i2c_unit);
+        busobject->mst_status= -EIO;
+    }
+    else if (event == TMHW_ERR_I2C_EVENT_MST_ABORT){
+    /*slave not available*/
+        busobject->mst_status = -ENODEV;
+    }
+    else if (event == TMHW_ERR_I2C_EVENT_MST_TRX_ABORT ||
+        event == TMHW_ERR_I2C_EVENT_MST_REC_ABORT){
+    /* preminary abort of I2C communication */
+    /* update the status = number of messages transferred */
+        busobject->mst_status = busobject->msg_index -1;
+    }
+    else{
+    /* success */
+    /* Transfer is over */
+    /* update the status = number of messages transferred */
+        busobject->mst_status = busobject->msg_index;
+    }
+
+    busobject->done = True;
+
+    wake_up( &(busobject->i2c_wait_master));
+
+    /* Reset all the variables here !!*/
+    busobject->bus_busy = False;
+    busobject->msg_index = 0;
+    busobject->num_of_msgs = 0;
+    busobject->master_active = False;
+    busobject->master_start = False;
+    busobject->master_lost = False;
+    busobject->i2c_mst_messages = Null;
+}
+
+/*
+ * i2c_algo_transfer
+ * Returns : status of Master Transfer. Num of messages transferred
+ * Pre condn : None.
+ * Descn.  : Initiates Master transfer.
+ */
+static int i2c_algo_transfer(struct i2c_adapter *i2c_adap,
+                     struct i2c_msg msgs[],
+                     int num_msgs)
+{
+     i2c_phlm_bus_t *busobject = ( i2c_phlm_bus_t *)i2c_adap->algo_data;
+     struct i2c_msg *pmsg;
+     int i;
+     tmhwI2cDirection_t direction;
+     int status;
+     unsigned long flags;
+
+    for ( i = 0; i < num_msgs;  i++ ){
+        pmsg = &msgs[i];
+            /* For 7bit address only for the moment */
+        if (pmsg->flags & I2C_M_TEN)    /* addr = 10 bit addr, not supported */
+            return -ENODEV;
+        else{
+            /* addr = 7 bit addr*/
+            pmsg->addr &= 0x7f;
+        }
+    }
+
+    if ( msgs[0].flags & I2C_M_RD )
+      direction = tmhwI2cReceive;
+    else
+      direction = tmhwI2cTransmit;
+
+    /* !!DISABLE PREEMPTION */
+    local_irq_save(flags);
+
+    busobject->i2c_mst_messages = msgs;
+
+    busobject->msg_index = 0;
+    busobject->num_of_msgs = num_msgs;
+
+
+    busobject->done = False;
+
+    busobject->master_active = True;
+
+    if ( busobject->bus_busy != True ){
+        tmhwI2cStartMaster(busobject->unit_num,
+                  busobject->i2c_mst_messages[0].addr,
+                  direction );
+    }
+
+    local_irq_restore(flags);
+    /* Pre-emption enabled */
+
+    /* Suspend current task till the event flag is set */
+    /* Wait for IIC transfer until the condition becomes true or
+        timeout(in secs) expires.Result of action is written in i2c_phlm_bus_t
+     */
+     status = wait_event_timeout( (busobject->i2c_wait_master),
+                              (busobject->done == True),
+                              (busobject->mst_timeout));
+
+     if ( busobject->done != True){
+       dbg_print("Master transfer timeout on unit %d\n\n\n",busobject->unit_num);
+#ifdef CONFIG_I2C_DEBUG
+        I2c_Error_Trigger();
+#endif
+       /* check for the error code and reset the unit */
+       status = i2c_master_timeout(busobject);
+       return status;
+    }
+
+    status = busobject->mst_status;
+
+    /* gives number of msgs succesfully transferred
+    */
+     return status;
+
+
+}
+
+static int  i2c_slave_get_slv_info(i2c_phlm_bus_t *busobject,
+                            i2c_slave_data *userdata)
+{
+
+    int bytecount;
+    i2c_slave_data  *slvmsg;
+    int status;
+    unsigned long flags;
+
+     status = wait_event_interruptible( (busobject->i2c_wait_slave),
+                         (busobject->slvstarted == True) );
+
+    if ( status != 0 ){
+        return -EINTR;
+    }
+    else if (busobject->slv_status != I2C_SET_SLAVE_DISABLE)
+    {/* slave is addressed . Now put the slave with a wait timeout*/
+        status = wait_event_timeout( (busobject->i2c_wait_slave),
+                              (busobject->slvdone == True),
+                              (busobject->slv_timeout));
+        if (busobject->slvdone != True)
+        {
+           /* Reset the slave unit*/
+           dbg_print("Slave transfer timeout on unit %d\n\n\n",busobject->unit_num);
+           local_irq_save(flags);
+
+           i2c_softReset(busobject->unit_num);
+
+           local_irq_restore(flags);
+
+           return -ESLAVE_TIMEOUT;
+        }
+    }
+
+    busobject->slvdone = False;
+    busobject->slvstarted = False;
+
+    slvmsg = &(busobject->i2c_slave_message);
+    bytecount = slvmsg->rx_tx_bytecount;
+    userdata->rx_tx_bytecount = bytecount;
+    userdata->slave_addr = slvmsg->slave_addr;
+
+    userdata->slave_event =  busobject->slv_status;
+
+        /* Disable the slave
+        */
+    if (busobject->slv_status == I2C_SET_SLAVE_DISABLE){
+            /* Invoke slave cleanup */
+            i2c_slave_cleanup(busobject);
+            return 0;
+    }
+
+    if ( busobject->slv_status == I2C_SLAVE_RD_DONE ){
+           /* slave write done !*/;
+          if ( (bytecount == 0) && (slvmsg->rx_data_length != 0))
+             return -ENODATA;
+
+          if ( bytecount != 0 ){
+              if (copy_to_user(userdata->rx_buf,
+                        slvmsg->rx_buf,
+                        bytecount) )
+                return -EFAULT;
+          }
+
+    }
+    else if (busobject->slv_status == I2C_SLAVE_WR_DONE){
+          /* slave read done !*/;
+          if ( (bytecount == 0) && (slvmsg->tx_data_length != 0))
+             return -ENODATA;
+    }
+    return 0;
+
+}
+/*
+ * i2c_algo_control
+ * Returns : 0 : success, Error otherwise.
+ * Pre condn : None.
+ * Descn.  : Handles ioctl calls for Maser and Slave
+ */
+static int i2c_algo_control(struct i2c_adapter *adapter, unsigned int cmd,
+                    unsigned long arg)
+{
+
+    i2c_phlm_bus_t *busobject =  ( i2c_phlm_bus_t *)adapter->algo_data;
+    int ret=0;
+
+     switch (cmd)
+     {
+    case I2C_SET_SLAVE_ENABLE:
+
+        ret = i2c_slave_enable( adapter, arg);
+        break;
+
+    case I2C_SET_SLAVE_DISABLE:
+
+        ret =  i2c_slave_disable( adapter );
+        break;
+
+    case I2C_GET_SLAVE_INFO:
+        {
+        i2c_slave_data *userdata = (i2c_slave_data*)arg;
+        ret = i2c_slave_get_slv_info(busobject, userdata);
+        }
+        break;
+    case I2C_SET_SPEED:
+        {
+        i2c_ph_xferspeed *speed = (i2c_ph_xferspeed *)arg;
+        busobject->i2c_speedkhz.fskhz = speed->fskhz;
+        busobject->i2c_speedkhz.hskhz = (speed->hskhz * speed->hs);
+        busobject->i2c_speedkhz.hs = (speed->hs & (speed->hskhz !=0));
+        }
+        break;
+    case I2C_SET_MASTER_TIMEOUT:
+        {
+        unsigned int timeout = (unsigned int)arg;
+        if ( timeout >= 500 ) {
+            busobject->mst_timeout = (timeout*HZ)/1000;
+        }
+        else{
+            ret = -EINVAL;/* invalid timeout value*/
+        }
+        }
+        break;
+    case I2C_SET_SLAVE_TIMEOUT:
+        {
+        unsigned int timeout = (unsigned int)arg;
+        if ( timeout >= 500 ) {
+            busobject->slv_timeout = (timeout*HZ)/1000;
+        }
+        else{
+            ret = -EINVAL;/* invalid timeout value*/
+        }
+        }
+        break;
+    case I2C_SOFT_RESET:
+        {
+        unsigned int i2c_unit = (unsigned int)arg;
+        i2c_softReset(i2c_unit);
+        }
+        break;
+    case I2C_SUSPEND:
+		  {
+		     (void)tmhwI2cSetIntEnable(busobject->unit_num, FALSE);
+		     (void)tmhwI2cSetPowerState(busobject->unit_num,tmPowerOff);
+		  }
+		  break;
+    case I2C_RESUME:
+		  {
+		     (void)tmhwI2cSetPowerState(busobject->unit_num,tmPowerOn);
+		     (void)tmhwI2cSetIntEnable(busobject->unit_num, TRUE);
+		  }
+		  break;
+    default:
+        ret = -ENOTTY;/* no such commamd*/
+        break;
+    }
+    return ret;
+}
+
+/*
+ * i2c_slave_enable
+ * Returns : 0 : success, Error otherwise.
+ * Pre condn : None.
+ * Descn.  : Enables the slave.
+ */
+
+int  i2c_slave_enable(struct i2c_adapter *adapter, unsigned long arg)
+{
+    i2c_phlm_bus_t *busobject
+            =  ( i2c_phlm_bus_t *)adapter->algo_data;
+    i2c_slave_data *slvmsg;
+    i2c_slave_data *userdata = (i2c_slave_data*)arg;
+
+    int rxlen, txlen;
+    unsigned long flags;
+
+    slvmsg = &busobject->i2c_slave_message;
+    rxlen =  userdata->rx_data_length;
+    txlen =  userdata->tx_data_length;
+
+    if (busobject->slave_enabled != True ){
+
+        slvmsg->rx_data_length = rxlen;
+        slvmsg->tx_data_length = txlen;
+
+        /* Copy message for slave read */
+        if ( (rxlen != 0) && (userdata->rx_buf == NULL) ){
+          return -EFAULT;
+        }
+        if ( rxlen != 0 ){
+            slvmsg->rx_buf = (unsigned char*)kmalloc(rxlen, GFP_KERNEL);
+            if (slvmsg->rx_buf == NULL)
+                return -ENOMEM;
+        }
+
+        if ( (txlen != 0) && (userdata->tx_buf == NULL) ){
+            if (slvmsg->rx_buf != NULL)
+                kfree(slvmsg->rx_buf);
+            return -EFAULT;
+        }
+
+        if ( txlen != 0 ){
+            slvmsg->tx_buf = (unsigned char*)kmalloc(txlen, GFP_KERNEL);
+            if (slvmsg->tx_buf == NULL){
+               if ( slvmsg->rx_buf != NULL )
+                  kfree(slvmsg->rx_buf);
+            return -ENOMEM;
+            }
+            if( copy_from_user( slvmsg->tx_buf,
+                  userdata->tx_buf, txlen ) ){
+                if ( slvmsg->rx_buf != NULL )
+                    kfree(slvmsg->rx_buf);
+                kfree(slvmsg->tx_buf);
+                return -EFAULT;
+            }
+        }
+
+        slvmsg->slave_addr = userdata->slave_addr;
+
+        local_irq_save(flags);
+
+        busobject->slave_enabled = True;
+        busobject->slvdone = False;
+        busobject->slvstarted = False;
+        busobject->slv_status = I2C_SET_SLAVE_ENABLE;
+
+        slvmsg->general_call = userdata->general_call;
+
+        if ( busobject->bus_busy == False ){
+            /* Enable general call only if set to true */
+            if ( userdata->general_call == True )
+            {
+                tmhwI2cEnableGeneralCall(busobject->unit_num);
+            }
+            tmhwI2cSetSlaveAddr(busobject->unit_num, slvmsg->slave_addr);
+            tmhwI2cStartSlave(busobject->unit_num);
+        }
+
+        local_irq_restore(flags);
+
+    }
+    else{/*just renable the interrupt and
+        copy any transmit data from user*/
+                /* Make this preempt safe */
+
+    if ( busobject->set_slave_disable == True ){
+
+        local_irq_save(flags);
+
+        busobject->bus_busy = False;
+
+        i2c_slave_disable(adapter);
+        local_irq_restore(flags);
+        return 0;
+
+    }
+
+
+    if( txlen != 0){
+        if ( userdata->tx_buf == NULL )
+            return -EFAULT;
+
+        if (copy_from_user( slvmsg->tx_buf,
+                       userdata->tx_buf, txlen )) {
+            return -EFAULT;
+         }
+    }
+
+    local_irq_save(flags);
+
+    busobject->slave_enabled = True;
+    busobject->slvdone = False;
+    busobject->slvstarted = False;
+    busobject->slv_status = I2C_SET_SLAVE_ENABLE;
+
+    tmhwI2cIntEnable(busobject->unit_num);
+
+    busobject->bus_busy = False;
+
+    /* Restart the slave or master on this unit */
+    i2c_slave_mst_control(busobject->unit_num, busobject);
+
+    local_irq_restore(flags);
+
+    }
+
+    return 0;
+}
+
+/*
+ * i2c_slave_disable
+ * Returns : 0 : success, Error otherwise.
+ * Pre condn : Slave  enabled
+ * Descn.  : Disables the slave.
+ */
+
+int i2c_slave_disable(struct i2c_adapter *adapter)
+{
+     i2c_phlm_bus_t * busobject =  ( i2c_phlm_bus_t *)adapter->algo_data;
+     i2c_slave_data  *slvmsg;
+     unsigned long flags;
+
+     if (busobject->slave_enabled == False )
+     return 0;
+
+     slvmsg = &(busobject->i2c_slave_message);
+
+     busobject->set_slave_disable = True;
+
+     /* Make it preempt safe and check if the bus is not busy
+     before stopping the slave */
+     local_irq_save(flags);
+
+     if ( busobject->bus_busy == False ){
+      /* reset the slave */
+     busobject->set_slave_disable = False;
+     busobject->slv_status = I2C_SET_SLAVE_DISABLE;
+     busobject->slave_enabled = False;
+
+       if ( busobject->slvstarted == False )
+       {/* check if slave hasnot been addressed yet*/
+          busobject->slvstarted = True;
+          wake_up_interruptible(&(busobject->i2c_wait_slave));
+       }
+       else
+           {/* slave is addressed*/
+          busobject->slvdone = True;
+          wake_up(&(busobject->i2c_wait_slave));
+       }
+     }
+     local_irq_restore(flags);
+     return 0;
+}
+
+/*
+ * i2c_slave_cleanup
+ * Returns : None
+ * Pre condn : None
+ * Descn.  : Stops the Slave unit and cleans up the memory
+ *          Called when I2C_SLAVE_DISABLE ioctl is invoked
+ *          or is called from i2c_exit function.
+ */
+
+static void i2c_slave_cleanup(i2c_phlm_bus_t *busobject)
+{
+    unsigned long flags;
+    i2c_slave_data  *slvmsg = &(busobject->i2c_slave_message);
+
+    busobject->slave_enabled = False;
+
+    local_irq_save(flags);
+        tmhwI2cIntEnable(busobject->unit_num);
+        tmhwI2cStopSlave(busobject->unit_num);
+    local_irq_restore(flags);
+
+    slvmsg->rx_tx_bytecount = 0;
+    slvmsg->tx_data_length = slvmsg->rx_data_length = 0;
+    slvmsg->slave_addr = 0;
+
+    if (NULL != slvmsg->rx_buf){
+        kfree(slvmsg->rx_buf);  // kfree returns void, no check needed
+        slvmsg->rx_buf = NULL;
+    }
+
+    if (NULL != slvmsg->tx_buf){
+        kfree(slvmsg->tx_buf);  // kfree returns void, no check needed
+        slvmsg->tx_buf = NULL;
+    }
+
+}
+
+
+/*
+ * i2c_bus_init
+ * Returns : -EFAULT error
+ * Pre condn :
+ * Descn.  : Initializes the i2c busses.
+ */
+
+static int i2c_bus_init(int device)
+{
+    i2c_phlm_bus_t *busobject;
+    tmhwI2cMmFunc_t     funcStruct;
+
+    busobject              = &(i2c_phlm_busobjects[device]);
+    busobject->int_pin     = i2c_phlm_cfg_intpins[device];
+
+    busobject->unit_num     = device;
+    busobject->num_of_msgs  = 0;
+    busobject->msg_index    = 0;
+    busobject->slave_enabled= False;
+
+    busobject->done = False;
+    busobject->slvdone = False;
+    busobject->slvstarted = False;
+    busobject->bus_busy = False;
+    busobject->master_active = False;
+    busobject->master_start = False;
+    busobject->master_lost = False;
+    busobject->set_slave_disable = False;
+                busobject->slv_status = I2C_SET_SLAVE_DISABLE;
+
+    busobject->i2c_speedkhz.fskhz = 100;
+    busobject->i2c_speedkhz.hskhz = 100;
+    busobject->i2c_speedkhz.hs = False;
+
+    busobject->mst_timeout = (I2C_PHCFG_TIMEOUT*HZ)/1000;
+    busobject->slv_timeout = (I2C_PHCFG_SLV_TIMEOUT*HZ)/1000;
+
+     /* The remaining elements of the struct are initialized when i2c write,read
+     functions are called */
+
+    busobject->dma_buf =
+         dma_alloc_coherent(  NULL,
+                              PAGE_SIZE,
+                              (dma_addr_t*)(&busobject->dma_addr_phy),
+                               GFP_KERNEL );
+
+    if (busobject->dma_buf == NULL){
+        printk (KERN_ERR "i2c_phlm: Unable allocate DMA memory.\r\n");
+        return -ENOMEM;
+    }
+
+    init_waitqueue_head( &(busobject->i2c_wait_master) );
+    init_waitqueue_head( &(busobject->i2c_wait_slave) );
+
+
+    /* store the Buffer Pointer in the funcStruct structure */
+    funcStruct.pI2cVirtToPhys = Null;
+    funcStruct.pI2cCacheFlush = Null;
+    funcStruct.pI2cCacheInvalidate = Null;
+    funcStruct.pI2cDynamicMemPtr = busobject->dma_buf;
+    funcStruct.i2cDynamicMemLength = PAGE_SIZE;
+    funcStruct.phyAddr =     busobject->dma_addr_phy;
+    tmhwI2cRegisterMmFunc(busobject->unit_num, &funcStruct);
+
+    /* Install interrupt handler. */
+    if (0 != request_irq( busobject->int_pin, (i2c_isr),
+                  IRQF_DISABLED,
+                  "i2c", (void *)busobject)){
+        dbg_print("install interrupt handler error for %d unit\n",busobject->unit_num);
+        return -EFAULT;
+     }
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int i2c_phlm_suspend(struct device *dev)
+{
+   int ret = 0;
+   struct i2c_adapter *adap = to_i2c_adapter(dev);
+    
+   if (adap->algo)
+   {
+      if (adap->algo->algo_control != NULL)
+         ret = adap->algo->algo_control(adap, I2C_SUSPEND,0 );
+   }
+
+   return ret;
+}
+
+static int i2c_phlm_resume(struct device *dev)
+{
+   int ret = 0;
+   struct i2c_adapter *adap = to_i2c_adapter(dev);
+    
+   if (adap->algo)
+   {
+      if (adap->algo->algo_control != NULL)
+         ret = adap->algo->algo_control(adap, I2C_RESUME,0 );
+   }
+
+   return ret;
+}
+
+/* Power management functions for IP3203 I2C controller */
+static struct dev_pm_ops i2c_phlm_dev_pm_ops = {
+    .suspend  = i2c_phlm_suspend,
+    .resume   = i2c_phlm_resume,
+};
+
+static struct device_type i2c_phlm_dev_type = {
+    .name     = "i2c_phlm_dev_type",
+    .pm       = &i2c_phlm_dev_pm_ops,
+};
+#endif
+
+/*
+ * i2c_add_bus
+ * Returns : 0 success
+ * Pre condn :
+ * Descn.  : registering functions to load algorithms at runtime
+ */
+
+static int i2c_add_bus(int device, struct i2c_adapter *adap)
+{
+    int res;
+
+    dbg_print("i2c-phlm.o: routines for %s registered.\n",
+    adap->name);
+
+    dbg_print("Initialise device %d\n", device);
+
+    /* register new adapter to i2c module... */
+    adap->algo = &(i2c_phlm_algorithms[device]);
+//    adap->id |= adap->algo->id;
+    adap->timeout = I2C_PHCFG_TIMEOUT;
+    adap->retries = I2C_PHCFG_NUM_RETIRES;
+
+    res = i2c_bus_init(device);
+     if ( res != 0){
+        dbg_print("initialization failed for device %d\n",device);
+     return -EFAULT;
+     }
+
+#ifdef CONFIG_PM
+    adap->dev.type = &i2c_phlm_dev_type;
+#endif
+    res = i2c_add_adapter(adap);
+
+    if (res != 0 ){
+    dbg_print("add adapter %d returned %x\n", device, res);
+    return -EFAULT;
+    }
+
+    i2c_phlmno_adapterno_map[device] = adap->nr; /*Added for I2C Wrapper Driver interface*/
+
+    tmhwI2cInit(device);
+
+    return 0;
+}
+
+/*
+ * i2c_delete_bus
+ * Returns : None
+ * Pre condn :
+ * Descn.  : ungistering functions to load algorithms at runtime
+ */
+
+static int i2c_delete_bus(struct i2c_adapter *adap)
+{
+    int res;
+    if ((res = i2c_del_adapter(adap)) < 0)
+        return res;
+    dbg_print("i2c-phlm.o: adapter unregistered: %s\n",adap->name);
+
+    return 0;
+}
+
+int i2c_get_adapterno(int deviceno)
+{
+    int adapterno = -ENODEV;
+
+    if (deviceno < i2c_phlm_units)
+    {
+        adapterno = i2c_phlmno_adapterno_map[deviceno];
+    }
+
+    return adapterno;
+}
+
+EXPORT_SYMBOL(i2c_get_adapterno);
+
+int i2c_get_timeoutval(int deviceno, unsigned int* timeoutval)
+{
+    int retVal = -ENODEV;
+
+    i2c_phlm_bus_t *busobject = NULL;
+
+    if (deviceno < i2c_phlm_units)
+    {
+        busobject = &(i2c_phlm_busobjects[deviceno]);
+
+        *timeoutval = (busobject->mst_timeout * 1000) /HZ;
+
+	retVal = 0;
+    }
+
+    return retVal;
+}
+
+EXPORT_SYMBOL(i2c_get_timeoutval);
+
+
+int i2c_set_timeoutval(int deviceno, unsigned int timeoutval)
+{
+    int retVal = -ENODEV;
+
+    i2c_phlm_bus_t *busobject = NULL;
+
+    if (deviceno < i2c_phlm_units)
+    {
+        busobject = &(i2c_phlm_busobjects[deviceno]);
+
+        if ( timeoutval >= 500 )
+	{
+            busobject->mst_timeout = (timeoutval*HZ)/1000;
+	    retVal = 0;
+       }
+    }
+
+    return retVal;
+}
+
+EXPORT_SYMBOL(i2c_set_timeoutval);
+
+
+int i2c_get_busspeed(int deviceno, i2c_ph_xferspeed* busspeed)
+{
+    int retVal = -ENODEV;
+
+    i2c_phlm_bus_t *busobject = NULL;
+
+    if (deviceno < i2c_phlm_units)
+    {
+        busobject = &(i2c_phlm_busobjects[deviceno]);
+
+        busspeed->fskhz = busobject->i2c_speedkhz.fskhz;
+        busspeed->hskhz = busobject->i2c_speedkhz.hskhz;
+        busspeed->hs = busobject->i2c_speedkhz.hs;
+
+        retVal = 0;
+    }
+
+    return retVal;
+}
+
+EXPORT_SYMBOL(i2c_get_busspeed);
+
+
+int i2c_set_busspeed(int deviceno, i2c_ph_xferspeed* busspeed)
+{
+    int retVal = -ENODEV;
+
+    i2c_phlm_bus_t *busobject = NULL;
+
+    if (deviceno < i2c_phlm_units)
+    {
+        busobject = &(i2c_phlm_busobjects[deviceno]);
+
+        busobject->i2c_speedkhz.fskhz = busspeed->fskhz;
+        busobject->i2c_speedkhz.hskhz = (busspeed->hskhz * busspeed->hs);
+        busobject->i2c_speedkhz.hs = (busspeed->hs & (busspeed->hskhz !=0));
+
+        retVal = 0;
+    }
+
+    return retVal;
+}
+
+EXPORT_SYMBOL(i2c_set_busspeed);
+
+
+
+#ifdef CONFIG_PNX8XXX_HOTBOOT
+/*
+ *i2c_hotboot
+ *Returns : None
+ *Pre cond : Hotboot reset event has occured
+ *Descn : Terminates the ongoing transfers and performs hw deinit
+ */
+static int i2c_hotboot(struct notifier_block *self, unsigned long val, void * data)
+{
+    tmhwI2cCapabilities_t unit_capb;
+    int device;
+
+    tmhwI2cGetCapabilities ( 0, &unit_capb );
+    i2c_phlm_units = unit_capb.i2cUnitCount;
+
+    for (device=0;device<i2c_phlm_units;device++)
+    {
+        tmhwI2cHotBoot(device);
+    }
+
+    return 0;
+}
+#endif
+
+/*
+ *i2c_softreset
+ *Returns : None
+ *Pre cond : Fatal error on the bus.
+ *Descn : Resets the hardware registers of the i2c unit.
+ */
+ static int i2c_softReset(unsigned int i2c_unit)
+ {
+
+
+    /* Do a hard reset of the i2c unit */
+    tmhwI2cSoftReset(i2c_unit);
+
+    /* Reset the state of the i2c unit without resetting setup values
+        like speed, timeout*/
+    i2c_phlm_busobjects[i2c_unit].bus_busy = False;
+    i2c_phlm_busobjects[i2c_unit].msg_index = 0;
+    i2c_phlm_busobjects[i2c_unit].num_of_msgs = 0;
+    i2c_phlm_busobjects[i2c_unit].master_active = False;
+    i2c_phlm_busobjects[i2c_unit].master_lost = False;
+    i2c_phlm_busobjects[i2c_unit].master_start = False;
+    i2c_phlm_busobjects[i2c_unit].i2c_mst_messages = Null;
+
+    i2c_phlm_busobjects[i2c_unit].slvstarted = False;
+    i2c_phlm_busobjects[i2c_unit].slv_status = I2C_SET_SLAVE_ENABLE;
+    i2c_phlm_busobjects[i2c_unit].slave_enabled = False;
+    i2c_phlm_busobjects[i2c_unit].slvdone = False;
+
+    /* send a wakeupsignal for slave.*/
+    wake_up_interruptible(&(i2c_phlm_busobjects[i2c_unit].i2c_wait_slave));
+
+    /* Reset all the hwapi registers */
+    tmhwI2cDeinit(i2c_unit);
+    tmhwI2cInit(i2c_unit);
+
+    return 0;
+ }
+
+ static int i2c_master_timeout(i2c_phlm_bus_t *busobject)
+    {
+        unsigned long flags;
+        int status=0;
+
+        local_irq_save(flags);
+
+            if ( busobject->master_start == False )
+            {
+                    /* Check for START TIMEOUT. No Start was put on the bus*/
+                    if ( busobject->master_lost == False )
+                    {
+                        status = -ESTART_TIMEOUT;
+                    }
+                    else
+                    {   /*  MASTER LOST TIMEOUT. No start on the bus & previously master
+                                        was lost*/
+                        status = -EMASTERLOST_TIMEOUT;
+                    }
+            }
+            else
+            {/*   TRANSITT TIMEOUT. Start was put on the bus, but transfer could not complete */
+                status = -ETRANSIT_TIMEOUT;
+            }
+
+        /* Reset the unit . Does not reset the setup values - timeout & speed*/
+        i2c_softReset(busobject->unit_num);
+
+        local_irq_restore(flags);
+
+        return status;
+    }
+
+
+
+static u32 i2c_algo_func(struct i2c_adapter *adap)
+{
+        return (I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL); /*FIXME:: Check if I2C_FUNC_SMBUS_EMUL needed*/
+}
+
+
+/*
+ * i2c_phlm_init
+ * Returns : None
+ * Pre condn :
+ * Descn.  : Initializes the i2c busses.
+ */
+
+ int __init i2c_phlm_init (void)
+{
+    int device;
+    tmhwI2cCapabilities_t unit_capb;
+
+
+    tmhwI2cGetCapabilities ( 0, &unit_capb );
+
+    i2c_phlm_units = unit_capb.i2cUnitCount;
+
+    i2c_phlm_busobjects =
+           (i2c_phlm_bus_t*) kzalloc( (i2c_phlm_units *
+                                   sizeof (i2c_phlm_bus_t)),
+                                   GFP_KERNEL);
+
+    if (i2c_phlm_busobjects == NULL)
+	 {
+        dbg_print (KERN_ERR "I2C_PHLM: Memory allocation failed\r\n");
+        return -ENOMEM;
+    }
+
+    memset(i2c_phlm_busobjects, 0, (i2c_phlm_units *
+                                   sizeof (i2c_phlm_bus_t)));
+
+    i2c_phlm_algorithms =
+           (struct i2c_algorithm*) kzalloc( (i2c_phlm_units *
+                                   sizeof (struct i2c_algorithm)),
+                                   GFP_KERNEL
+                                   );
+    if (i2c_phlm_algorithms == NULL)
+	 {
+        dbg_print (KERN_ERR "I2C_PHLM: Memory allocation failed\r\n");
+		  kfree(i2c_phlm_busobjects);
+        return -ENOMEM;
+    }
+
+
+    i2c_phlmno_adapterno_map = (int*) kzalloc((i2c_phlm_units *
+                                   sizeof (int)),
+                                   GFP_KERNEL
+                                   );
+    if (i2c_phlmno_adapterno_map == NULL)
+	 {
+        dbg_print (KERN_ERR "I2C_PHLM: Memory allocation failed for adapterno"
+								    " table\r\n");
+		  kfree(i2c_phlm_algorithms);
+		  kfree(i2c_phlm_busobjects);
+        return -ENOMEM;
+    }
+
+    #ifdef CONFIG_PNX8XXX_HOTBOOT
+    /* register for hotboot*/
+    hotboot_notify.notifier_call = i2c_hotboot;
+    hotboot_notify.next = NULL;
+    pnx8xxx_hotboot_hook_register(&hotboot_notify);
+    #endif
+
+    for (device = 0; device < i2c_phlm_units; device++){
+
+        tmhwI2cGetCapabilities ( device, &unit_capb );
+
+        strcpy(i2c_phlm_cfg_adapters[device].name, "i2c-adap");
+        i2c_phlm_cfg_adapters[device].id = device;
+        i2c_phlm_cfg_adapters[device].algo_data
+            = &i2c_phlm_busobjects[device];
+
+        i2c_phlm_cfg_adapters[device].algo = &i2c_phlm_algorithms[device];
+        
+        i2c_phlm_algorithms[device].master_xfer = i2c_algo_transfer;
+        i2c_phlm_algorithms[device].algo_control = i2c_algo_control;
+        i2c_phlm_algorithms[device].functionality = i2c_algo_func;
+
+        i2c_phlmno_adapterno_map[device] = -1;
+
+        if (i2c_add_bus(device, &i2c_phlm_cfg_adapters[device]) < 0)
+        {
+            dbg_print("i2c-device%d: Unable to register with I2C\n",
+            device);
+            kfree(i2c_phlm_busobjects);
+            kfree(i2c_phlm_algorithms);
+            kfree(i2c_phlmno_adapterno_map);
+            return -ENODEV;
+        }
+    }
+
+    return 0;
+}
+
+/*
+ * i2c_phlm_exit
+ * Returns : None
+ * Pre condn :
+ * Descn.  : Deinitializes the i2c busses.
+ */
+
+void __exit i2c_phlm_exit(void)
+{
+   i2c_phlm_bus_t *busobject;
+   int device;
+
+
+   #ifdef CONFIG_PNX8XXX_HOTBOOT
+   /* register for hotboot*/
+   hotboot_notify.notifier_call = i2c_hotboot;
+   hotboot_notify.next = NULL;
+   pnx8xxx_hotboot_hook_unregister(&hotboot_notify);
+   #endif
+
+   for( device = 0; device < i2c_phlm_units; device++ )
+	{
+      dbg_print("exit bus %x\n", device);
+      busobject = &i2c_phlm_busobjects[device];
+
+      i2c_slave_disable(&i2c_phlm_cfg_adapters[device]);
+
+      /* disable the i2c_unit using HWAPI */
+      tmhwI2cDeinit(device);
+
+      free_irq(busobject->int_pin,(void*)busobject);
+
+      dma_free_coherent (
+                    NULL,
+                    PAGE_SIZE,
+                    (void*)busobject->dma_buf,
+                    (dma_addr_t)( busobject->dma_addr_phy)
+                               );
+
+      busobject->dma_buf = NULL;
+
+      i2c_delete_bus(&i2c_phlm_cfg_adapters[device]);
+   }
+
+   kfree(i2c_phlm_busobjects);
+   kfree(i2c_phlm_algorithms);
+   kfree(i2c_phlmno_adapterno_map);
+}
+
+
+MODULE_AUTHOR("NXP B.V.");
+MODULE_DESCRIPTION("I2C-Bus adapter routines");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_phlm_init);
+module_exit(i2c_phlm_exit);
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.c linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.c
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,112 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ * %name:    i2c_phlm_cfg.c %
+ * %version: 2 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  configuration file
+ *
+ *
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+
+#include <linux/i2c.h>
+
+#if (TMFL_PNX_ID == 8550 )
+    #include <asm/mach-pnx8550/int.h>
+#elif (TMFL_PNX_ID == 85500)
+    #if defined (CONFIG_ARCH_APOLLO)
+        #include <linux/irq.h>
+    #else
+        #include <asm/mach-pnx85500/irq.h>
+    #endif
+#else
+    #include <asm/mach-pnx8543/irq.h>
+#endif
+
+#include "i2c_phlm_cfg.h"
+#include "tmhwI2c.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+
+/* ***********************************************
+*  The device register bases
+*  *********************************************** */
+
+#if (TMFL_PNX_ID == 8550 )
+
+/* Interrupt lines on the board pnx8550 for i2c units 1,2...*/
+unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+{ PNX8550_INT_I2C1, PNX8550_INT_I2C2, PNX8550_INT_I2C3, PNX8550_INT_I2C4, 0 };
+
+
+
+#elif (TMFL_PNX_ID == 8535 )
+
+/* Interrupt lines on the board pnx8535 for i2c units 1,2...*/
+unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+{ PNX8XXX_INT_I2C1, PNX8XXX_INT_I2C2 };
+
+#elif (TMFL_PNX_ID == 8542 )
+
+/* Interrupt lines on the board pnx8542 for i2c units 1,2...*/
+unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+{ PNX8XXX_INT_I2C1, PNX8XXX_INT_I2C2 };
+
+#elif (TMFL_PNX_ID == 8543 )
+
+/* Interrupt lines on the board pnx8543 for i2c units 1,2,3...*/
+unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+{ PNX8XXX_INT_I2C1, PNX8XXX_INT_I2C2, PNX8XXX_INT_IIC4_DMA };
+
+#elif (TMFL_PNX_ID == 85500 )
+#if defined CONFIG_ARCH_APOLLO
+    unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+    { 55, 56, 57 ,149};
+#else
+    /* Interrupt lines on the board pnx85500 for i2c units 1,2,3,4...*/
+    unsigned long i2c_phlm_cfg_intpins[TMHW_I2C_UNIT_MAX] =
+    { PNX8XXX_INT_I2C1, PNX8XXX_INT_I2C2, PNX8XXX_INT_I2C4,PNX8XXX_INT_I2C5 };
+#endif
+
+
+#endif
+
+struct i2c_adapter i2c_phlm_cfg_adapters[TMHW_I2C_UNIT_MAX];
+
+
+void i2c_phlm_cfg_init(unsigned int num_units)
+{
+
+    return;
+}
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/i2c_phlm_cfg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,56 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ * %name:    i2c_phlm_cfg.h %
+ * %version: 1 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  configuration file
+ *
+ *
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+#ifndef I2CPHCFG_H
+#define I2CPHCFG_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define I2C_PHCFG_DEBUG
+
+#define I2C_PHCFG_TIMEOUT         500 /* min 500millisecs for master transfer timeout*/
+#define I2C_PHCFG_SLV_TIMEOUT     500 /* min 500millisecs for slave transfer timeout*/
+#define I2C_PHCFG_NUM_RETIRES     3
+
+/* Interrupt lines on the board for i2c units 1,2...*/
+extern unsigned long i2c_phlm_cfg_intpins[];
+extern struct i2c_adapter i2c_phlm_cfg_adapters[];
+
+
+void i2c_phlm_cfg_init(unsigned int num_units);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/ItmhwI2c/inc/tmhwI2c.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/ItmhwI2c/inc/tmhwI2c.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/ItmhwI2c/inc/tmhwI2c.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/ItmhwI2c/inc/tmhwI2c.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,468 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwI2c.h %
+ * %pid_version:             %
+ *---------------------------------------------------------------------------
+ * describtion     : I2C HwAPI
+ *
+ *---------------------------------------------------------------------------
+ * created         : first: dijkenbd
+ *                 %derived_by: sangeeta %
+ *                 %date_modified: Thu Dec  5 09:42:32 2002 %
+ *                 %version: PB5#18 %
+ *                 PS - RGD - PID
+ *---------------------------------------------------------------------------
+*/
+
+#ifndef TMHW_I2C_H
+#define TMHW_I2C_H
+
+/*
+===============================================================================
+Standard include files:
+===============================================================================
+*/
+#ifdef LINUX_BUILD
+
+#include <HwAPI/tmNxTypes.h>
+#include <HwAPI/tmNxCompId.h>
+
+#else
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+
+#endif
+/*
+===============================================================================
+Project include files:
+===============================================================================
+*/
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+/*
+===============================================================================
+Types and defines:
+===============================================================================
+*/
+/*  compatibility and version numbers */
+#define TMHW_I2C_COMPATIBILITY_NR       1       /* Module software version */
+#define TMHW_I2C_MAJOR_VERSION_NR       1
+#define TMHW_I2C_MINOR_VERSION_NR       0
+#define TMHW_I2C_INTERFACE_VERSION      1
+
+/* I2c HWAPI Status/Error Codes */
+#define TMHW_ERR_I2C_BASE                           (CID_COMP_IIC | CID_LAYER_HWAPI)
+#define TMHW_ERR_I2C_COMP                           (TMHW_ERR_I2C_BASE | TM_ERR_COMP_UNIQUE_START)
+
+/* I2c HWAPI Standard Status Codes */
+#define TMHW_ERR_I2C_BUSY                                                     \
+/* !ErrorTag: busy in tmhwI2c                                              */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0000)
+#define TMHW_ERR_I2C_INVALID_REQUEST                                          \
+/* !ErrorTag: invalid request error in tmhwI2c                             */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0001)
+#define TMHW_ERR_I2C_BAD_UNIT_ID                                              \
+/* !ErrorTag: bad unit id in tmhwI2c                                       */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0002)
+#define TMHW_ERR_I2C_EVENT_MST_REQ                                            \
+/* !ErrorTag: mst req event in tmhwI2c                                     */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0003)
+#define TMHW_ERR_I2C_EVENT_MST_LOST                                           \
+/* !ErrorTag: mst lost event in tmhwI2c                                    */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0004)
+#define TMHW_ERR_I2C_EVENT_MST_ABORT                                          \
+/* !ErrorTag: mst abort event in tmhwI2c                                   */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0005)
+#define TMHW_ERR_I2C_EVENT_MST_TRX_REQ                                        \
+/* !ErrorTag: mst trx req event in tmhwI2c                                 */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0006)
+#define TMHW_ERR_I2C_EVENT_MST_TRX_DONE                                       \
+/* !ErrorTag: mst trx done event in tmhwI2c                                */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0007)
+#define TMHW_ERR_I2C_EVENT_MST_TRX_ABORT                                      \
+/* !ErrorTag: mst trx abort event in tmhwI2c                               */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0008)
+#define TMHW_ERR_I2C_EVENT_MST_REC_REQ                                        \
+/* !ErrorTag: mst rec req event in tmhwI2c                                 */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0009)
+#define TMHW_ERR_I2C_EVENT_MST_REC_DONE                                       \
+/* !ErrorTag: mst rec done event in tmhwI2c                                */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000a)
+#define TMHW_ERR_I2C_EVENT_MST_REC_ABORT                                      \
+/* !ErrorTag: mst rec abort event in tmhwI2c                               */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000b)
+#define TMHW_ERR_I2C_EVENT_SLV_REC_REQ_MST_LOST                               \
+/* !ErrorTag: slv rec req mst lost event in tmhwI2c                        */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000c)
+#define TMHW_ERR_I2C_EVENT_SLV_REC_REQ                                        \
+/* !ErrorTag: slv rec req event in tmhwI2c                                 */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000d)
+#define TMHW_ERR_I2C_EVENT_SLV_GC_REQ_MST_LOST                                \
+/* !ErrorTag: slv gc req mst lost event in tmhwI2c                         */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000e)
+#define TMHW_ERR_I2C_EVENT_SLV_GC_REQ                                         \
+/* !ErrorTag: slv gc req event in tmhwI2c                                  */ \
+                                                    (TMHW_ERR_I2C_COMP+0x000f)
+#define TMHW_ERR_I2C_EVENT_SLV_REC_DONE                                       \
+/* !ErrorTag: slv rec done event in tmhwI2c                                */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0010)
+#define TMHW_ERR_I2C_EVENT_SLV_REC_ABORT                                      \
+/* !ErrorTag: slv rec abort event in tmhwI2c                               */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0011)
+#define TMHW_ERR_I2C_EVENT_SLV_TRX_REQ                                        \
+/* !ErrorTag: slv trx req event in tmhwI2c                                 */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0012)
+#define TMHW_ERR_I2C_EVENT_SLV_TRX_REQ_MST_LOST                               \
+/* !ErrorTag: slv trx req mst lost event in tmhwI2c                        */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0013)
+#define TMHW_ERR_I2C_EVENT_SLV_TRX_DONE                                       \
+/* !ErrorTag: slv trx done event in tmhwI2c                                */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0014)
+#define TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT                                      \
+/* !ErrorTag: slv trx abort event in tmhwI2c                               */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0015)
+#define TMHW_ERR_I2C_EVENT_BUS_ERROR                                          \
+/* !ErrorTag: bus error event in tmhwI2c                                   */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0016)
+#define TMHW_ERR_I2C_TIMEOUT                                                 \
+/* !ErrorTag: no respons on I2C-bus                                   */     \
+                                                    (TMHW_ERR_I2C_COMP+0x0017)
+
+#define TMHW_ERR_I2C_EVENT_A0                                                 \
+/* !ErrorTag: bus error event in tmhwI2c                                   */ \
+                                                    (TMHW_ERR_I2C_COMP+0x0018)
+
+/* device */
+/* the maximum numbers of I2c hardware units that can be configured */
+#define TMHW_I2C_UNIT_MAX               (5)
+
+/* i2c */
+#define TMHW_I2C_MAX_SS_SPEED           100     /* max speed in SS mode (kHz) */
+#define TMHW_I2C_MAX_FS_SPEED           400     /* max speed in FS mode (kHz) */
+#define TMHW_I2C_MAX_HS_SPEED           3400    /* max speed in HS mode (kHz) */
+
+#define TMHW_I2C_DATA_DUMMY             0xff
+#define TMHW_I2C_NO_MEANING             (-1)
+
+typedef enum
+{
+    tmhwI2cChain                = 0,
+    tmhwI2cRestart              = 1,            /* for master only */
+    tmhwI2cStop                 = 2
+} tmhwI2cAttach_t, *ptmhwI2cAttach_t;
+
+typedef enum
+{
+    tmhwI2cTransmit             = 0,
+    tmhwI2cReceive              = 1,
+    tmhwI2cNoMeaning            = -1
+} tmhwI2cDirection_t, *ptmhwI2cDirection_t; /* for master only */
+
+typedef enum
+{
+    tmhwI2cEventInterrupt,
+    tmhwI2cEventProceed
+} tmhwI2cRequest_t, *ptmhwI2cRequest_t;
+
+typedef enum
+{
+    tmhwI2cMaster = 0,
+    tmhwI2cSlave,
+    tmhwI2cBusError,
+    tmhwI2cNoInterrupt,
+    tmhwI2cBusBusy,
+    tmhwI2cBusFree
+}
+tmhwI2cStatusType_t, *ptmhwI2cStatusType_t;
+
+typedef struct _tmhwI2cCapabilities_t
+{
+    UInt32        i2cModuleID;              /* I2c hardware module ID */
+    UInt32        i2cUnitCount;             /* Total I2c unit count supported */
+    UInt32        i2cMaxSpeedKHZ;           /* I2c unit maximum transfer speed */
+    UInt32        i2cMaxHsSpeedKHZ;         /* I2c unit maximum transfer speed */
+} tmhwI2cCapabilities_t, *ptmhwI2cCapabilities_t;
+
+typedef struct _tmhwI2cData_t
+{
+    pUInt8                  pAddress;       /* data base address */
+    UInt32                  length;         /* length of message(w) or buffer(r) */
+    UInt32                  counter;        /* num of bytes left to transceive + */
+    tmhwI2cAttach_t         attach;         /* how to finish */
+    UInt8                   slaveAddress;   /* I2c slave address of slave being
+                                               addressed (master only!!!) */
+    tmhwI2cDirection_t      direction;      /* i2c communication direction
+                                               (master mode only!!!) */
+    Bool                    bHS;            /* if True: data will be transferred
+                                               in HS, otherwise FS/SS
+                                               (master only!!!) */
+} tmhwI2cData_t, *ptmhwI2cData_t;
+
+
+typedef Void (*ptmhwI2cVirtToPhys_t) (pVoid pVirt, pVoid *ppPhys);
+typedef tmErrorCode_t (*ptmhwI2cCacheFlush_t) (pVoid pVirt, UInt32 length);
+typedef tmErrorCode_t (*ptmhwI2cCacheInvalidate_t) (pVoid pVirt, UInt32 length);
+
+typedef struct tmhwI2cMmFunc_t
+{
+    ptmhwI2cVirtToPhys_t        pI2cVirtToPhys;
+    ptmhwI2cCacheFlush_t        pI2cCacheFlush;
+    ptmhwI2cCacheInvalidate_t   pI2cCacheInvalidate;
+    pUInt8                          pI2cDynamicMemPtr;
+#ifdef DMA_MOD
+    UInt32                          phyAddr;
+#endif
+    UInt32                          i2cDynamicMemLength;
+} tmhwI2cMmFunc_t, *ptmhwI2cMmFunc_t;
+
+typedef struct tmhwI2cDoRequest
+{
+    UInt8         address;               /* iic 7-bit address of slave dev */
+    UInt32        numWriteBytes;         /* numbers of bytes */
+    UInt32        numReadBytes;          /* numbers of bytes */
+    pUInt8        pWriteData;            /* pointer to Write data */
+    pUInt8        pReadData;             /* pointer to Read data */
+} tmhwI2cDoRequest_t, *ptmhwI2cDoRequest_t;
+
+
+/*
+===============================================================================
+External function/data references:
+===============================================================================
+*/
+
+/*
+===============================================================================
+Exported functions:
+===============================================================================
+*/
+
+tmErrorCode_t
+tmhwI2cRegisterMmFunc (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cMmFunc_t        pFuncStruct
+    );
+
+tmErrorCode_t
+tmhwI2cGetSWVersion (
+    ptmSWVersion_t          pI2cVersion
+    );
+
+tmErrorCode_t
+tmhwI2cGetCapabilities (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cCapabilities_t  pI2cCaps
+    );
+
+tmErrorCode_t
+tmhwI2cGetBlockId(
+    tmUnitSelect_t          i2cUnit,
+    pUInt32                 pBlockId
+    );
+
+tmErrorCode_t
+tmhwI2cInit (
+    tmUnitSelect_t          i2cUnit
+    );
+
+tmErrorCode_t
+tmhwI2cDeinit (
+    tmUnitSelect_t          i2cUnit
+    );
+
+tmErrorCode_t
+tmhwI2cGetPowerState (
+    tmUnitSelect_t          i2cUnit,
+    ptmPowerState_t         pPowerState
+    );
+
+tmErrorCode_t
+tmhwI2cSetPowerState (
+    tmUnitSelect_t          i2cUnit,
+    tmPowerState_t          powerState
+    );
+
+tmErrorCode_t
+tmhwI2cSetIntEnable (
+    tmUnitSelect_t          i2cUnit,
+    bool                    enable
+    );
+
+Void
+tmhwI2cEnableGeneralCall (
+    tmUnitSelect_t          i2cUnit
+    );
+
+Void
+tmhwI2cDisableGeneralCall (
+    tmUnitSelect_t          i2cUnit
+    );
+
+Void
+tmhwI2cSetSlaveAddr (
+    tmUnitSelect_t          i2cUnit,
+    UInt8                   moduleSlaveAddr
+    );
+
+Void
+tmhwI2cSetSpeed (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  fsSpeed,        /* I: FSspeed, */
+    UInt32                  hsSpeed         /* I: HSspeed, 0: if no HS */
+    );
+
+Void
+tmhwI2cGetSpeed (
+    tmUnitSelect_t          i2cUnit,
+    pUInt32                 pFsSpeed,       /* I: pFSspeed, */
+    pUInt32                 pHsSpeed        /* I: pHSspeed, 0: if no HS */
+    );
+
+Void
+tmhwI2cConvertSpeed (
+    tmUnitSelect_t          i2cUnit,
+    pUInt32                 pFsSpeed,
+    pUInt32                 pHsSpeed        /*0: if no HS */
+    );
+
+Void
+tmhwI2cGetBusStatus (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cStatusType_t    pStatusType
+    );
+
+
+Void
+tmhwI2cIntGetStatus (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cStatusType_t    pStatusType
+    );
+
+tmErrorCode_t
+tmhwI2cIntEnable (
+    tmUnitSelect_t          i2cUnit
+    );
+
+tmErrorCode_t
+tmhwI2cIntDisable (
+    tmUnitSelect_t          i2cUnit
+    );
+
+tmErrorCode_t
+tmhwI2cIntClear (
+    tmUnitSelect_t          i2cUnit
+    );
+
+Void
+tmhwI2cSetData (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cData_t          pData
+    );
+
+Void
+tmhwI2cGetData (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cData_t          pdata
+    );
+
+Void
+tmhwI2cStartMaster (
+    tmUnitSelect_t          i2cUnit,
+    UInt8                   slaveAddress,   /* I2c slave address of slave being */
+    tmhwI2cDirection_t      direction       /* i2c communication direction */
+    );
+
+Void
+tmhwI2cStartSlave (
+    tmUnitSelect_t          i2cUnit
+    );
+
+Void
+tmhwI2cStopSlave (
+    tmUnitSelect_t          i2cUnit
+    );
+
+tmErrorCode_t
+tmhwI2cEventHandle0xa0(
+    tmUnitSelect_t          i2cUnit,
+    Bool                    bSlaveMonitor
+    );
+
+tmErrorCode_t
+tmhwI2cEvent (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cRequest_t        request,
+    Bool                    bSlaveMonitor
+    );
+
+tmErrorCode_t
+tmhwI2cEventHandle0xa0(
+    tmUnitSelect_t i2cUnit,
+    Bool bSlaveMonitor
+    );
+
+Void
+tmhwI2cHotBoot (
+    tmUnitSelect_t              i2cUnit
+    );
+
+#ifdef LINUX_BUILD
+
+Void
+tmhwI2cSoftReset (
+    tmUnitSelect_t              i2cUnit
+    );
+#endif
+
+/* fit to need I2C function intended for system start-up
+ * it does not use any OS or memory management instructions
+ * As a consequence, this function does not use DMA
+
+ * The driver supports two hardware peripherals: IP_3203 and IP_0105
+ * Some boards contain both peripherals, some only one
+ * the unit numbers are assigned as follows:
+ * {tmUnit0 - tmUnit<A-1>=> IP_3203, tmUnit<A> - tmUnit<A+B>=> IP_0105}
+ * When no IP_3203 devices are available in the system, tmUnit0 corresponds with the first IP_0105 deice.
+ */
+#ifndef DMA_MOD
+tmErrorCode_t
+tmhwI2cDoRequest(
+    tmUnitSelect_t        unitID,           // I: iic unit
+    ptmhwI2cDoRequest_t  pHwReq     // I: data for sequenceing state machine
+);
+#endif
+
+
+#ifdef LINUX_BUILD
+void debugSMU(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* TMHW_I2C_H */
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/Makefile linux-2.6.34/drivers/i2c/algos/i2c_phlm/Makefile
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,29 @@
+#
+# Makefile for the i2c algorithms
+#
+
+HWAPI_FLAGS-y := -Iinclude/HwAPI
+
+HWAPI_FLAGS-y += -Idrivers/i2c/algos/i2c_phlm/tmhwI2c/inc \
+                 -Idrivers/i2c/algos/i2c_phlm/tmhwI2c/src \
+                -Idrivers/i2c/algos/i2c_phlm/ItmhwI2c/inc \
+                -Idrivers/i2c/algos/i2c_phlm/tmhwI2c/cfg
+                
+nx_i2c_flags-$(CONFIG_SOC_PNX8550) := -DTMFL_PNX_ID=8550
+nx_i2c_flags-$(CONFIG_SOC_PNX8535) := -DTMFL_PNX_ID=8535 -DMINUS_SPEED_PATCH
+nx_i2c_flags-$(CONFIG_SOC_PNX8542) := -DTMFL_PNX_ID=8542 -DMINUS_SPEED_PATCH
+nx_i2c_flags-$(CONFIG_SOC_PNX8543) := -DTMFL_PNX_ID=8543 -DMINUS_SPEED_PATCH
+nx_i2c_flags-$(CONFIG_SOC_PNX85500) := -DTMFL_PNX_ID=85500 -DMINUS_SPEED_PATCH
+nx_i2c_flags-$(CONFIG_ARCH_APOLLO) := -DTMFL_PNX_ID=85500 -DMINUS_SPEED_PATCH
+
+EXTRA_CFLAGS-$(CONFIG_I2C_ALGO3203) := $(HWAPI_FLAGS-y) -DTMFL_CPU_IS_MIPS=1 \
+			$(nx_i2c_flags-y) -DTMHWI2C_BSL_INDEPENDANT -DTMFL_OS_IS_HPUNIX=0 \
+			-DMIPSEL -DDMA_MOD -DLINUX_BUILD -DLINUX -DMONTAVISTA_GNU
+
+EXTRA_CFLAGS = $(EXTRA_CFLAGS-y) $(EXTRA_CFLAGS-m)
+obj-$(CONFIG_I2C_ALGO3203)  += i2c-phlm.o
+i2c-phlm-y := tmhwI2c/cfg/tmhwI2c_DvpNoBslCfg.o tmhwI2c/src/tmhwI2c.o i2c_phlm.o i2c_phlm_cfg.o
+
+ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_DvpNoBslCfg.c linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_DvpNoBslCfg.c
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_DvpNoBslCfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_DvpNoBslCfg.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,540 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *
+ *
+ *  C %name:        tmhwI2c_DvpNoBslCfg.c %
+ *  Instance:       PB5_1
+ *  Description:    I2C Hardware API configuration file
+ *  %created_by:    sangeeta %
+ *  %date_created:  Mon Sep 15 15:08:10 2008 %
+ *  Notes:          This configuration file will not have BSL dependency.
+ *                   Can be used in Linux context.
+ **********************************************************************/
+
+
+/*----------------------------------------------------------------------------
+ * Standard include files:
+ *----------------------------------------------------------------------------
+ */
+
+#if !defined(SDE4_BUILD)
+#include <HwAPI/tmSysCfg.h>
+#endif
+
+#include <HwAPI/tmNxTypes.h>
+#include <asm/io.h>
+
+/*----------------------------------------------------------------------------
+ * Project include files:
+ *----------------------------------------------------------------------------
+ */
+#include <tmhwI2c.h>
+#include <tmhwI2c_Cfg.h>
+
+
+
+/*----------------------------------------------------------------------------
+ * Types and defines:
+ *----------------------------------------------------------------------------
+ */
+
+#if ((TMFL_PNX_ID  == 1500) || (TMFL_PNX_ID  == 1700))
+/* PNX1500 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 4
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09,0x0a,0x08}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_SS_SPEED,  TMHW_I2C_MAX_SS_SPEED, TMHW_I2C_MAX_SS_SPEED, TMHW_I2C_MAX_SS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { False, False, False, False }
+#endif
+
+#elif ((TMFL_PNX_ID == 8550) || (TMFL_PNX_ID == 8520) )
+
+/* PNX8550 and PNX8520 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 4
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09,0x0a,0x08}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_SS_SPEED, TMHW_I2C_MAX_SS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True, False, False }
+#endif
+
+#elif (TMFL_PNX_ID == 8535)
+
+/* PNX8535 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 2
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {48000, 48000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True }
+#endif
+
+#elif (TMFL_PNX_ID == 5100)
+
+/* PNX5100 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 2
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True }
+#endif
+
+
+#elif (TMFL_PNX_ID == 8542)
+
+/* PNX8542 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 2
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True }
+#endif
+
+#elif (TMFL_PNX_ID == 8543)
+
+/* PNX8543 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 3
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09, 0x0A}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True, True}
+#endif
+
+#elif (TMFL_PNX_ID == 85500)
+
+#if defined CONFIG_ARCH_APOLLO
+
+/* Apollo */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 4
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000, 24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False, False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09, 0x0A, 0x0B} /*FIXME::CHECK If this is indeed 0x0B*/
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True, True, False}
+#endif
+
+#else
+
+/* PNX85500 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 3
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000,24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False,False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09, 0x0A,0x08}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED,TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED,TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True, True, True}
+#endif
+
+#endif /* CONFIG_ARCH_APOLLO */
+
+#elif (TMFL_PNX_ID == 8493)
+
+/* PNX85500 */
+#undef TMHW_I2C_UNIT_MAX
+#define TMHW_I2C_UNIT_MAX 3
+
+#ifndef TMHW_I2C_PCFKHZ
+#define TMHW_I2C_PCFKHZ {24000, 24000, 24000,24000}
+#endif
+#ifndef TMHW_I2C_HS
+#define TMHW_I2C_HS {False, False, False,False}
+#endif
+#ifndef TMHW_I2C_HSMCODE
+#define TMHW_I2C_HSMCODE {0x08,0x09, 0x0A,0x08}
+#endif
+#ifndef TMHW_I2C_MAXFSSPEEDKHZ
+#define TMHW_I2C_MAXFSSPEEDKHZ {TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED, TMHW_I2C_MAX_FS_SPEED,TMHW_I2C_MAX_FS_SPEED}
+#endif
+
+#ifndef TMHW_I2C_MAXHSSPEEDKHZ
+#define TMHW_I2C_MAXHSSPEEDKHZ {TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED, TMHW_I2C_MAX_HS_SPEED,TMHW_I2C_MAX_HS_SPEED}
+#endif
+#ifndef TMHW_I2C_DMA
+#define TMHW_I2C_DMA { True, True, True, True}
+#endif
+
+
+#endif
+
+
+
+
+/* The peripheral clock frequency among others determines how the speed
+ *  registers must be set to obtain a certain i2c-bus speed.
+ */
+static const UInt32 i2cPeripheralClockFrequencyKHz[TMHW_I2C_UNIT_MAX] = TMHW_I2C_PCFKHZ;
+
+/* All units have high speed mode disabled */
+static const Bool i2cHS[TMHW_I2C_UNIT_MAX] =TMHW_I2C_HS ;
+
+/* the master code must be unique over the i2c-bus where the particular
+ * master is connected to.
+ */
+static const UInt8 i2cHsMasterCode[TMHW_I2C_UNIT_MAX] = TMHW_I2C_HSMCODE;
+
+static const UInt32 i2cMaxFSSpeedKhz[TMHW_I2C_UNIT_MAX] = TMHW_I2C_MAXFSSPEEDKHZ ;
+
+static const UInt32 i2cMaxHsSpeedKhz[TMHW_I2C_UNIT_MAX] = TMHW_I2C_MAXHSSPEEDKHZ;
+
+static const Bool i2cDma[TMHW_I2C_UNIT_MAX] = TMHW_I2C_DMA;
+
+/* Timeout for the data transmitt */
+#ifndef TMHW_I2C_TIMEOUT
+#define TMHW_I2C_TIMEOUT  1000
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * Global data:
+ *----------------------------------------------------------------------------
+ */
+
+#define I2C_MEM_SIZE        (4*1024)
+
+extern tmUnitSelect_t       gI2cIP3203UnitCount;
+extern tmUnitSelect_t       gI2cIP0105UnitCount;
+
+#define  TMHW_I2C_CFG_NUM_UNITS     TMHW_I2C_UNIT_MAX
+
+/* tmhwI2c configuration structure array. This array will have size equal to */
+/* number of units available in I2c hardware. */
+static tmhwI2c_Cfg_t  gI2c_Cfg[TMHW_I2C_CFG_NUM_UNITS];
+static Bool gbI2c_CfgInit = False;  /* Flag to know if configuration been initialized */
+
+static UInt32 tmhwI2c_Cfg_numunits = ~0L;
+
+
+#if defined CONFIG_ARCH_APOLLO
+UInt32 tmhwI2c_CfgPhyAddr[TMHW_I2C_CFG_UNIT_COUNT] =
+    {
+          TMHW_I2C_CFG_REG_START + 0x0C5000, // I2c unit 0
+          TMHW_I2C_CFG_REG_START + 0x0C6000, // I2c unit 1
+          TMHW_I2C_CFG_REG_START + 0x0C7000, // I2c unit 2
+          TMHW_I2C_CFG_REG_START + 0x0C8000, // I2c unit 3
+    };
+
+#else
+/* The rigister offset addresses in PNX */
+UInt32 tmhwI2c_CfgPhyAddr[TMHW_I2C_CFG_UNIT_COUNT] =
+    {
+          TMHW_I2C_CFG_REG_START + 0x45000, // I2c unit 0
+          TMHW_I2C_CFG_REG_START + 0x46000, // I2c unit 1
+#if ((TMFL_PNX_ID == 8543) || (TMFL_PNX_ID == 85500))
+          TMHW_I2C_CFG_REG_START + 0x48000, // I2c unit 2
+#else
+          TMHW_I2C_CFG_REG_START + 0x69000, // I2c unit 2
+#endif
+#if (TMFL_PNX_ID == 85500)
+          TMHW_I2C_CFG_REG_START + 0x49000  // I2C unit 3
+#else
+          TMHW_I2C_CFG_REG_START + 0x4C000  // I2C unit 3
+#endif
+    };
+
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * Internal Prototypes:
+ *----------------------------------------------------------------------------
+ */
+void
+i2c_CfgGetModulueInfo(void);
+
+/*----------------------------------------------------------------------------
+ * tmhwI2c configuration structure array. This array will have size equal to
+ * number of units available in I2c hardware.
+ *-----------------------------------------------------------------------------
+ * FUNCTION:    i2c_CfgGetModulueInfo
+ *
+ * DESCRIPTION: Retrieves base addresses of the I2c units using ioremap function.
+ *
+ * RETURN:      None
+ *
+ * NOTES:
+ *
+ *-----------------------------------------------------------------------------
+ */
+void
+i2c_CfgGetModulueInfo(void)
+{
+    tmUnitSelect_t          unit = 0;
+
+
+    /* pnx8550 */
+    if( gbI2c_CfgInit == False)
+    {
+
+        #if ((TMFL_PNX_ID == 8550) || (TMFL_PNX_ID == 8520) )
+
+        for(unit=0; unit < TMHW_I2C_UNIT_MAX; unit++ )
+        {
+
+            gI2c_Cfg[unit].baseAddress = (volatile UInt32)ioremap(tmhwI2c_CfgPhyAddr[unit], I2C_MEM_SIZE );
+            gI2c_Cfg[unit].moduleID    = (unit > 1 )?IIC_IP0105_HWMODULE_ID : I2C_IP3203_HWMODULE_ID;
+        }
+        gI2cIP0105UnitCount = 2;
+        gI2cIP3203UnitCount = 2;
+
+
+        #else
+
+        for(unit=0; unit < TMHW_I2C_UNIT_MAX; unit++ )
+        {
+            gI2c_Cfg[unit].baseAddress = (volatile UInt32)ioremap(tmhwI2c_CfgPhyAddr[unit], I2C_MEM_SIZE );
+            gI2c_Cfg[unit].moduleID    = I2C_IP3203_HWMODULE_ID;
+        }
+        gI2cIP3203UnitCount = 2;
+
+        gI2cIP0105UnitCount = 0;
+        #endif
+
+        tmhwI2c_Cfg_numunits = TMHW_I2C_UNIT_MAX;
+
+        gbI2c_CfgInit = True;
+    }
+
+
+}
+
+
+/* tmhwI2c configuration state structure array. This array will have size equal to
+ * number of units available in I2c hardware. At this stage of the development
+ * process the contents and purpose of state structure has not been decided yet.
+ */
+static tmhwI2c_CfgState_t  gI2c_CfgState[TMHW_I2C_CFG_NUM_UNITS] =
+{
+   {
+      0     /* Unit number 0 */
+   }
+};
+
+
+/*----------------------------------------------------------------------------
+ * Exported functions:
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cCfgInit:
+ *
+ * DESCRIPTION: Run time intialisation for unit i2cUnit
+ *
+ * RETURN:      -
+ *
+ * NOTES:       -
+ *----------------------------------------------------------------------------
+ */
+Void tmhwI2cCfgInit(tmUnitSelect_t i2cUnit, ptmhwI2cCfg_t gpI2cCfg)
+{
+    /* define the peripheral clock frequency */
+    gpI2cCfg->clockFreqKHz  = i2cPeripheralClockFrequencyKHz[i2cUnit];
+
+    /* define whether HS of the indicated unit is available and enabled */
+    gpI2cCfg->bHS           = i2cHS[i2cUnit];
+
+    /* define the master code of the indicated unit */
+    gpI2cCfg->hsMasterCode  = i2cHsMasterCode[i2cUnit];
+
+    /* define the maximumn i2c communication speed when in FS (max 400) */
+    gpI2cCfg->maxFSSpeedKhz = i2cMaxFSSpeedKhz[i2cUnit];
+
+    /* define the maximumn i2c communication speed when in HS (max 3400) */
+    gpI2cCfg->maxHsSpeedKhz = i2cMaxHsSpeedKhz[i2cUnit];
+
+        gpI2cCfg->bDma          = i2cDma[ i2cUnit ];
+
+        /* Timeout for the transmitt */
+        gpI2cCfg->timeout = TMHW_I2C_TIMEOUT;
+}/* tmhwI2cCfgInit */
+
+
+
+/*-----------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2c_CfgGet
+ *
+ * DESCRIPTION: Initializes the tmhwI2c configuration structure array and returns
+ *              it's pointer
+ *-----------------------------------------------------------------------------
+ */
+ptmhwI2c_Cfg_t
+tmhwI2c_CfgGet(void)
+{
+
+    i2c_CfgGetModulueInfo();
+
+    return gI2c_Cfg;
+}
+
+
+/*----------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2c_CfgGetState
+ *
+ * DESCRIPTION: Returns pointer to the tmhwI2c configuration state structure array
+ *
+ *----------------------------------------------------------------------------
+ */
+ptmhwI2c_CfgState_t
+tmhwI2c_CfgGetState(void)
+{
+    return gI2c_CfgState;
+}
+
+
+/*----------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2c_CfgGetNumUnits
+ *
+ * DESCRIPTION: Returns total number of units available in I2c hardware.
+ *
+ * NOTE       : IMPORTANT: tmhwI2c_CfgGet() must have been run atleast once
+ *              before running tmhwI2c_CfgGetNumUnits(). If not default value -1
+ *              is returned.
+ *----------------------------------------------------------------------------
+ */
+UInt32
+tmhwI2c_CfgGetNumUnits(void)
+{
+    return (tmhwI2c_Cfg_numunits);
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_LocalCfg.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_LocalCfg.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_LocalCfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/cfg/tmhwI2c_LocalCfg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,108 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *  Header %name:   tmhwI2c_LocalCfg.h %
+ *  Instance:       PB5_1
+ *  Description:    I2c Hardware API configuration local header file
+ *  %created_by:    tusr343 %
+ *  %date_created:  Mon Nov 12 18:05:19 2007 %
+ *
+ **********************************************************************/
+
+#ifndef TMHW_I2C_CFGLOCAL_H
+#define TMHW_I2C_CFGLOCAL_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+
+#ifdef LINUX_BUILD
+#include <HwAPI/tmNxTypes.h>
+#else
+#include <tmNxTypes.h>
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#if ((TMFL_PNX_ID  == 1500) || (TMFL_PNX_ID  == 1700))
+
+#define I2C_CFG_DMA_BLOCK_LENGTH 32
+
+#elif ((TMFL_PNX_ID == 8550) || (TMFL_PNX_ID == 8520) )
+#define I2C_CFG_DMA_BLOCK_LENGTH 128
+
+#elif (TMFL_PNX_ID == 8535)
+#define I2C_CFG_DMA_BLOCK_LENGTH 32
+
+#elif ((TMFL_PNX_ID == 5100) || (TMFL_PNX_ID == 8542) || (TMFL_PNX_ID == 8543) || (TMFL_PNX_ID == 85500))
+#define I2C_CFG_DMA_BLOCK_LENGTH 1024
+
+#endif
+
+
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION   : tmhwI2c_CfgGet
+//
+// DESCRIPTION: Returns pointer to the tmhwI2c configuration structure array
+//
+// Note       : This function will lie in the internal interface of tmhwI2c
+//              and should not be visible to clients of tmhwI2c
+//-----------------------------------------------------------------------------
+ptmhwI2c_Cfg_t
+tmhwI2c_CfgGet(void);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwI2c_CfgGetState
+//
+// DESCRIPTION: Returns pointer to the tmhwI2c configuration state structure array
+//
+// Note       : This function will lie in the internal interface of tmhwI2c
+//              and should not be visible to clients of tmhwI2c
+//-----------------------------------------------------------------------------
+ptmhwI2c_CfgState_t
+tmhwI2c_CfgGetState(void);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmhwI2c_CfgGetNumUnits
+//
+// DESCRIPTION: Returns total number of units available in I2C hardware
+//
+// Note       : This function will lie in the internal interface of tmhwI2c
+//              and should not be visible to clients of tmhwI2c
+//-----------------------------------------------------------------------------
+UInt32
+tmhwI2c_CfgGetNumUnits(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMHW_I2C_CFGLOCAL_H
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/inc/tmhwI2c_Cfg.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/inc/tmhwI2c_Cfg.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/inc/tmhwI2c_Cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/inc/tmhwI2c_Cfg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,148 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *
+ *   Header %name:   tmhwI2c_Cfg.h %
+ *   Instance:       PB5_1
+ *   Description:    tmhwI2c Configuration header file
+ *   %created_by:    sangeeta %
+ *   %date_created:  Tue Mar 13 15:51:43 2007 %
+ *
+ **********************************************************************/
+
+
+#ifndef TMHW_I2C_CFG_H
+#define TMHW_I2C_CFG_H
+
+/*----------------------------------------------------------------------------
+ * Standard include files:
+ *----------------------------------------------------------------------------
+ */
+#ifdef LINUX_BUILD
+#include <HwAPI/tmNxTypes.h>
+#else
+#include <tmNxTypes.h>
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * Project include files:
+ *----------------------------------------------------------------------------
+ */
+#include "tmhwI2c.h"
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/*----------------------------------------------------------------------------
+ * Types and defines:
+ *----------------------------------------------------------------------------
+ */
+#define I2C_IP3203_HWMODULE_ID          0X00003203
+#define IIC_IP0105_HWMODULE_ID          0X00000105
+
+/*----------------------------------------------------------------------------
+ *  The device register bases for Linux
+ *----------------------------------------------------------------------------
+ */
+
+#ifdef LINUX_BUILD
+
+#if defined CONFIG_ARCH_APOLLO
+#define TMHW_I2C_CFG_UNIT_COUNT         4           /* Number of I2C hardware unit */
+#define TMHW_I2C_CFG_REG_START          0xE0600000  /* I2C base register offset in system */
+#else
+
+#define TMHW_I2C_CFG_UNIT_COUNT         4           /* Number of I2C hardware unit */
+#define TMHW_I2C_CFG_REG_START          0x1BE00000  /* I2C base register offset in system */
+
+#endif
+
+extern UInt32 tmhwI2c_CfgPhyAddr[TMHW_I2C_CFG_UNIT_COUNT];
+#endif
+
+/* Standard configuration structures */
+
+typedef struct tmhwI2c_Cfg
+{
+    UInt32 baseAddress;
+    UInt32 moduleID;
+}tmhwI2c_Cfg_t, *ptmhwI2c_Cfg_t;
+
+
+/* tmhwI2c configuration state structure. At this stage of development, the contents of this structure
+ * have not been finalised.
+ */
+typedef struct tmhwI2c_CfgState
+{
+    UInt32 intNum;
+}tmhwI2c_CfgState_t, *ptmhwI2c_CfgState_t;
+
+
+/* Pre-existing Configuration structure. TO DO: Might be merged with standard configuration
+ * "state" strucure
+ */
+typedef struct _tmhwI2cCfg_t
+{
+    UInt32      clockFreqKHz;
+    Bool        bHS;
+    UInt8       hsMasterCode;
+    UInt32      maxFSSpeedKhz;
+    UInt32      maxHsSpeedKhz;      /* preferably 400 <= maxHsSpeedKhz <= 3400 */
+    Bool        bDma;
+    UInt32      timeout;            /* Timeout in ms for the data transction.
+                                     * This timeout should be grater than time required to
+                                     * transmit largest possible message.
+                                     * 0 means Infinite wait */
+} tmhwI2cCfg_t, *ptmhwI2cCfg_t;
+
+/*----------------------------------------------------------------------------
+ * Exported references:
+ *----------------------------------------------------------------------------
+ */
+extern tmUnitSelect_t      gI2cIP3203UnitCount;
+extern tmUnitSelect_t      gI2cIP0105UnitCount;
+
+
+/*----------------------------------------------------------------------------
+ * Exported functions:
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cCfgInit:
+ *
+ * DESCRIPTION: Run time intialisation for unit i2cUnit
+ *
+ * RETURN:      -
+ *
+ * NOTES:       None
+ *----------------------------------------------------------------------------
+ */
+Void tmhwI2cCfgInit(tmUnitSelect_t i2cUnit, ptmhwI2cCfg_t gpI2cCfg);
+
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+
+#endif /* TMHW_I2C_CFG_H */
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmhwI2c.c linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmhwI2c.c
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmhwI2c.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmhwI2c.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,4217 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwI2c.c %
+ * %pid_version:                           PB5#67 %
+ *---------------------------------------------------------------------------
+ * description    : This file contains the I2C HwAPI implementation for
+ *                IP_3203 and IP_0105.
+ *
+ *-------------------------------------------------------------------------------
+ * orginal:             : B.D. Dijken (tmhwI2cIP3203)
+ * created              : first: doeke
+ * ticket PE_01#10      : B.D. Dijken 20041012
+ * ticket PB5#173       : Sripathi Nayak
+ * CR PB5#396           : Sangeeta Mutgi
+ * ticket 96591 & 95737 : Sangeeta Mutgi
+ *-------------------------------------------------------------------------------
+ */
+
+/* ---------------------------------------------------------------------------
+ * Standard include files:
+ * ---------------------------------------------------------------------------
+ */
+#ifndef LINUX_BUILD
+
+#include <tmNxTypes.h>
+#include <tmNxModId.h>
+#include <tmFlags.h>
+
+#else
+
+#include <HwAPI/tmNxTypes.h>
+#include <HwAPI/tmNxModId.h>
+#include <HwAPI/tmFlags.h>
+
+#endif
+
+#ifndef TMHWI2C_BSL_INDEPENDANT
+#include <tmbslCore.h>
+#endif
+
+
+/* ---------------------------------------------------------------------------
+ * Project include files:
+ * ---------------------------------------------------------------------------
+ */
+#include "tmvhI2c3203_Reg.h"
+#include "tmvhIic0105_Reg.h"
+#include <tmhwI2c_Cfg.h>
+#include <tmhwI2c.h>
+#include <tmhwI2c_LocalCfg.h>
+
+
+#ifdef LINUX_BUILD
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#else
+
+#include <tmhwI2cIP3203.h>
+
+#endif
+
+#ifdef I2C_PRINTK
+#include <asm/io.h>
+#endif
+
+/* ---------------------------------------------------------------------------
+ * Types and defines:
+ * ---------------------------------------------------------------------------
+ */
+
+/* version */
+#define TMFL_I2C_INTERFACE_VERSION      1
+#define TMFL_I2C_COMPATIBILITY_EXP      1
+#define TMFL_I2C_MAJOR_VERSION_EXP      1
+
+/* TIMEOUT should be wait period of 100ms i.e  100KHz
+ * Not cosidering DMA full bandwidth.
+ * with MIPS it is 325mips. Approximately 10 instructions per timeout loop
+ */
+//#define HWI2C_RESET_TIMEOUT 0x32DCD5
+
+#ifdef LINUX_BUILD
+
+/* i2cWaitForInt will have a delay(udelay) in the loop of 100us and execute
+the 10 instructions(which read i2c event) and
+the loop for 1000 times. This will give 100ms in theory.
+In practice, this could be little more than
+100ms( considering Kernel swapping, scheduling )
+but certainly not more than 200ms.*/
+
+#define HWI2C_RESET_TIMEOUT 1000
+
+#else
+/* For 1ms delay, on 333 Mips
+ * i.e (333 * 1000,000) * 1ms = 333000 instructions
+ * 10 instructions per loop : gives 33300 loops = 0x8214
+*/
+#define HWI2C_RESET_TIMEOUT 0x8214
+#endif
+
+#if (TMFL_I2C_INTERFACE_VERSION != TMHW_I2C_INTERFACE_VERSION)
+#error Wrong header file version is included
+#endif /* TMFL_I2C_INTERFACE_VERSION */
+
+#if (TMFL_I2C_COMPATIBILITY_EXP != TMHW_I2C_COMPATIBILITY_NR)
+#error ERROR: Invalid I2C HWAPI compatibility number!
+#endif /* TMFL_I2C_COMPATIBILITY_EXP */
+
+#if (TMFL_I2C_MAJOR_VERSION_EXP > TMHW_I2C_MAJOR_VERSION_NR)
+#error ERROR: Invalid I2C HWAPI major number!
+#endif /* TMFL_I2C_MAJOR_VERSION_EXP */
+
+/* error: */
+#define I2C_BUFFER_EMPTY                  (TMHW_ERR_I2C_COMP+0x000a)
+#define I2C_LAST_BYTE                     (TMHW_ERR_I2C_COMP+0x000b)
+#define I2C_DMA_NOT_SUCCESSFUL            (TMHW_ERR_I2C_COMP+0x000c)
+
+
+/* initialization value for variables */
+#define I2C_DATA_INVALID             -1
+
+
+/* Register Read Write Macro's  */
+#ifdef LINUX_BUILD
+    #ifdef CONFIG_I2C_DEBUG
+    // log all read and writes to registers in local buffer,
+    // so we dump it on the console in case of errors
+    #define LOG_SIZE 64
+    static UInt32 G_logI2c[LOG_SIZE];
+    static UInt32 G_logI2cIndex = 0;
+
+    #define I2C_READ(address,result) do {                                   \
+            (result) = *(volatile UInt32 *)(address);                       \
+            if ( (result) == 0xDEADABBA ) {                                 \
+                printk( KERN_EMERG "I2C READ -- 0xDEADABBA line=%d a=0x%08x\n", __LINE__, (unsigned int)address); \
+                (result) = *(volatile UInt32 *)(address);                   \
+            }                                                               \
+            G_logI2c[G_logI2cIndex++]= (0x0000ffff & ((unsigned int) (address))); \
+            G_logI2c[G_logI2cIndex++]= (result);                            \
+            G_logI2cIndex %= LOG_SIZE;                                      \
+        } while(0)
+
+    #define I2C_WRITE(address,value) do {                                   \
+            *(volatile UInt32 *)(address) = (value);                        \
+            {                                                               \
+                G_logI2c[G_logI2cIndex++] = (0x80000000 | (0x0000ffff & (unsigned int) (address))); \
+                G_logI2c[G_logI2cIndex++] = (value);                        \
+                G_logI2cIndex %= LOG_SIZE;                                  \
+            }                                                               \
+        } while( 0 )
+    #else
+
+    #define I2C_READ(address,result) (result) = *(volatile UInt32 *)(address)
+    #define I2C_WRITE(address,value) *(volatile UInt32 *)(address) = (value)
+    #endif
+
+    #ifdef NOT_NOW_PLEASE_NO_NO
+
+    #define I2C_READ(address,result) do {                                                \
+            (result) = *(volatile UInt32 *)(address);                                    \
+            if( 0 )                                                                      \
+                printk( KERN_EMERG "I2C_READ a=0x%08x, r=0x%08x\n", (unsigned int)address, (unsigned int)result); \
+            if ((result)==0xDEADABBA) {                                                  \
+                printk( KERN_EMERG "I2C READ -- 0xDEADABBA line=%d a=0x%08x\n", __LINE__, (unsigned int)address); \
+                (result) = *(volatile UInt32 *)(address);                                \
+            }                                                                            \
+        } while (0)
+
+    #define I2C_WRITE(address,value) do {                                   \
+            *(volatile UInt32 *)(address) = (value);                        \
+            if( 0 ) printk("I2C_WRITE a=0x%08x, v=0x%08x\n",(unsigned int)address, (unsigned int)value); \
+        } while( 0 )
+    #endif /*CONFIG_I2C_DEBUG*/
+#else
+#define I2C_READ(address,result) (result) = *(volatile UInt32 *)(address)
+#define I2C_WRITE(address,value) *(volatile UInt32 *)(address) = (value)
+#endif /* LINUX_BUILD*/
+
+/* #define I2C_DMA_WORD_ALINED */
+
+typedef enum
+{
+    I2cIP0105 = 0,
+    I2cIP3203
+} I2cModuleType_t;
+
+typedef struct _I2cModuleDesc
+{
+    I2cModuleType_t  I2cType;
+    UInt32           pRegBase;
+} I2cModuleDesc_t;
+
+typedef struct _I2cRegisterMmFunc
+{
+    /* memory management functions for DMA use */
+    ptmhwI2cVirtToPhys_t        gpVirtToPhys;
+    ptmhwI2cCacheFlush_t        gpCacheFlush;
+    ptmhwI2cCacheInvalidate_t   gpCacheInvalidate;
+    /* intermediate DMA buffer */
+    pUInt8                      bufferPtr;
+#ifdef LINUX_BUILD
+    UInt32                      phyAddr;
+#endif
+    UInt32                      length;
+} I2cRegisterMmFunc_t, *pI2cRegisterMmFunc_t;
+
+typedef enum
+{
+    tmhwI2cControlNone          = 0,
+    tmhwI2cAcknowledge          = 1 << TMVH_I2C3203_I2CCON_AA_POS,
+    tmhwI2cStopCond             = 1 << TMVH_I2C3203_I2CCON_SETSTOP_POS,
+    tmhwI2cStartCond            = 1 << TMVH_I2C3203_I2CCON_START_POS,
+    tmhwI2cEnable               = 1 << TMVH_I2C3203_I2CCON_EN_I2C_POS
+} tmhwI2cControl_t, *ptmhwI2cControl_t;
+
+typedef enum
+{
+    tmhwI2cDmaNone              = 0,
+    tmhwI2cDmaMasterTransmit    = 1 << TMVH_I2C3203_DMA_CONTROL_MASTER_TX_POS,
+    tmhwI2cDmaMasterReceive     = 1 << TMVH_I2C3203_DMA_CONTROL_MASTER_RX_POS,
+    tmhwI2cDmaSlaveReceive      = 1 << TMVH_I2C3203_DMA_CONTROL_SLAVE_RX_POS,
+    tmhwI2cDmaSlaveTransmit     = 1 << TMVH_I2C3203_DMA_CONTROL_SLAVE_TX_POS
+} tmhwI2cDmaControl_t, *ptmhwI2cDmaControl_t;
+
+
+/* i2c device states */
+typedef enum
+{
+    tmhwI2cEvent0x00            = 0x00,     /* Bus Error */
+    tmhwI2cEvent0x08            = 0x08,     /* A START Condition has been transmitted */
+    tmhwI2cEvent0x10            = 0x10,     /* A Repeated START condition has been transmitted */
+    tmhwI2cEvent0x18            = 0x18,     /* SLA.W has been transmitted, ACK has been received */
+    tmhwI2cEvent0x20            = 0x20,     /* SLA.W or master code has been transmitted: NOT ACK has been received */
+    tmhwI2cEvent0x28            = 0x28,     /* Data byte in I2CDAT has been transmitted, ACK received */
+    tmhwI2cEvent0x30            = 0x30,     /* Data byte in I2CDAT has been transmitted, NOT ACK received */
+    tmhwI2cEvent0x38            = 0x38,     /* Arbitration lost in SLA, R/W or in Data byte or in NOT ACK bit or in master code */
+    tmhwI2cEvent0x40            = 0x40,     /* SLA.R has been transmitted, ACK received */
+    tmhwI2cEvent0x48            = 0x48,     /* SLA.R or Master code has been transmitted, NOT ACK received */
+    tmhwI2cEvent0x50            = 0x50,     /* Data byte has been received, ACK has been returned */
+    tmhwI2cEvent0x58            = 0x58,     /* Data byte has been recieved; NOT ACK has been returned */
+    tmhwI2cEvent0x60            = 0x60,     /* Own SLA.W has been rceived, ACK has been returned */
+    tmhwI2cEvent0x68            = 0x68,     /* Arbitration lost in SLA.R/W as master and own SLA.W has received, ACK returned */
+    tmhwI2cEvent0x70            = 0x70,     /* Generall call address (0x00) has been received, ACK returned */
+    tmhwI2cEvent0x78            = 0x78,     /* Arbitration lost in SLA.R/W or in Master code ... ACK returned*/
+    tmhwI2cEvent0x80            = 0x80,     /* Previously addressed with own SLA.W; Data byte has been received ACK returned */
+    tmhwI2cEvent0x88            = 0x88,     /* Previously addressed with own SLA.W; Data byte received, NOT ACK returned */
+    tmhwI2cEvent0x90            = 0x90,     /* Previously addressed with generall call; Data byte recieved; ACK returned */
+    tmhwI2cEvent0x98            = 0x98,     /* Previously addressed with generall call; Data byte recieved; NOT ACK returned */
+    tmhwI2cEvent0xa0            = 0xa0,     /* A STOP condition or repeated START condition has been received ... */
+    tmhwI2cEvent0xa8            = 0xa8,     /* Own SLA.R is been received; ACK returned */
+    tmhwI2cEvent0xb0            = 0xb0,     /* Arbitration lost in SLA.R/W as master and own SLA.R received, ACK sent */
+    tmhwI2cEvent0xb8            = 0xb8,     /* Data byte in I2CDAT has been transmitted; ACK sent */
+    tmhwI2cEvent0xc0            = 0xc0,     /* Data bytes in I2CDAT transmitted, NOT ACK is received */
+    tmhwI2cEvent0xc8            = 0xc8,     /* Last data byte in I2CDAT has sent ACK received ... */
+    tmhwI2cEvent0xf8            = 0xf8      /* No Information available, SI flag is '0' */
+} tmhwI2cEvent_t, *ptmhwI2cEvent_t;
+
+
+/* number of I2c units found */
+static tmUnitSelect_t   gI2cUnitCount       = I2C_DATA_INVALID;
+/* which one do we need? three vars hold redundancy ! */
+tmUnitSelect_t      gI2cIP3203UnitCount = I2C_DATA_INVALID;
+tmUnitSelect_t      gI2cIP0105UnitCount = I2C_DATA_INVALID;
+
+/* The I2cDriverInit is implemented in a way that the IP_3203 units
+ * always preceed the IP_0105 units, with possibly gI2cIP3203UnitCount=0
+ */
+/* Array of Module Descriptors */
+static volatile I2cModuleDesc_t gI2cModule[TMHW_I2C_UNIT_MAX];
+
+/* Devider values for the serial clock rate of the 0105 */
+static const UInt32 gDivFact0105[] = {60, 80, 120, 160, 240, 320, 480, 960};
+
+/* configuration data */
+static tmhwI2cCfg_t gI2cCfg[TMHW_I2C_UNIT_MAX];
+
+#ifndef TMHWI2C_BSL_INDEPENDANT
+static UInt32 gTimeTicks20us; /* for STOP HW issue on 0105 */
+#endif
+
+/* ---------------------------------------------------------------------------
+ * Global (protected) data for ISR layer:
+ * ---------------------------------------------------------------------------
+ */
+static I2cRegisterMmFunc_t  gI2cRegisterMmFunc[TMHW_I2C_UNIT_MAX];
+static tmhwI2cData_t        gI2cData[TMHW_I2C_UNIT_MAX];
+static Bool                 gI2cDma[TMHW_I2C_UNIT_MAX];    /* = {False} */
+static Bool                 gI2cByteWise[TMHW_I2C_UNIT_MAX]; /* = {False} */
+
+
+/* ---------------------------------------------------------------------------
+ * Internal Prototypes
+ * ---------------------------------------------------------------------------
+ */
+#ifdef LINUX_BUILD
+/* tmhwI2cIP3203SetDMA() is declared in tmhwI2cIP3203.h. However, this file is
+ * not included for Linux build. Hence declare the function here, for Linux build
+ */
+Void
+tmhwI2cIP3203SetDMA (tmUnitSelect_t  i2cUnit);
+
+#ifdef CONFIG_I2C_DEBUG
+/* Meant for debugging purposes */
+void I2c_Error_Trigger( void );
+static const char* RegToName( unsigned long offset);
+static void DumpI2c( void );
+#endif
+
+#endif
+
+/* ---------------------------------------------------------------------------
+ * Internal Prototypes (protected) for Driver initialization:
+ * ---------------------------------------------------------------------------
+ */
+static Void i2cDriverInit( Void );
+
+/* ---------------------------------------------------------------------------
+ * Internal Prototypes for Register abstraction:
+ * ---------------------------------------------------------------------------
+ */
+/* speed */
+static Void
+i2cConvertSpeedToReg (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  fsSpeed,
+    UInt32                  hsSpeed,
+    pUInt32                 pFSBIR,
+    pUInt32                 pHSBIR
+    );
+
+static Void
+i2cConvertSpeedToActual (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  FSBIR,
+    UInt32                  HSBIR,
+    pUInt32                 pFsSpeed,
+    pUInt32                 pHsSpeed
+    );
+
+static Void
+i2cIP0105SetSpeed (
+    tmUnitSelect_t          i2cUnit
+    );
+
+/* control */
+#ifdef LINUX_BUILD
+Void
+#else
+static Void
+#endif
+i2cControl (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cControl_t        control
+    );
+
+static Void
+i2cSetDmaControl (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cDmaControl_t     dmaControl
+    );
+
+static Void
+i2cGetStatus (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cEvent_t         pI2cEvent
+    );
+
+/* ---------------------------------------------------------------------------
+ * Internal Prototypes for ISR layer:
+ * ---------------------------------------------------------------------------
+ * remark:
+ * In a multi processor environment, functions in the ISR layer may not be
+ * used outside the scope of the user process where the ISR runs!!! This is
+ * secured.
+ * ---------------------------------------------------------------------------
+ */
+/* DMA */
+static Void
+i2cPrepareDma (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cDmaControl_t     dmaControl
+    );
+
+static tmErrorCode_t
+i2cCheckDma (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cRequest_t        request
+    );
+
+/* Byte transfer */
+static Void
+i2cWriteDat (
+    tmUnitSelect_t          i2cUnit,
+    UInt8                   dat
+    );
+
+static Void
+i2cTransmitByte (
+    tmUnitSelect_t          i2cUnit
+    );
+
+static Void
+i2cReceiveByte (
+    tmUnitSelect_t          i2cUnit
+    );
+
+/* Block transfer */
+static tmErrorCode_t
+i2cTransceiveData (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cDmaControl_t     dmaControl
+    );
+
+/* Communication aids */
+static Void
+i2cSendSlaveAddress (
+    tmUnitSelect_t          i2cUnit
+    );
+
+static Bool
+i2cIncludeLastByte (
+    tmUnitSelect_t          i2cUnit,
+    tmhwI2cDmaControl_t     dmaControl
+    );
+
+static Void
+i2cWaitForInt(
+    tmUnitSelect_t              i2cUnit
+);
+
+static Void
+i2cWaitForSTO(
+    tmUnitSelect_t              i2cUnit
+);
+
+
+#if( defined(LINUX_BUILD) && defined(I2C_PRINTK) )
+
+Void debugSMU (Void)
+{
+    UInt32 i2cUnit;
+    tmhwI2cEvent_t  eventLocal;
+    UInt32 reg_value;
+
+    for ( i2cUnit = 0; i2cUnit < 2; i2cUnit++)
+    {
+        printk("unit num %d\n",i2cUnit);
+
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+        printk( "slave address register %x \n",reg_value);
+
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_ENABLE_OFFSET, reg_value);
+        printk("int enable %x\n",reg_value);
+
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, reg_value);
+        printk("control register %x\n",reg_value);
+
+        i2cGetStatus(i2cUnit, &eventLocal);
+        printk("status = %x\n",eventLocal);
+    }
+} /* debugSMU */
+
+#endif
+
+
+/* ---------------------------------------------------------------------------
+ * Exported functions register abstraction layer:
+ * ---------------------------------------------------------------------------
+ */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cRegisterMmFunc
+ *
+ * DESCRIPTION: Register functions for memory management (only required when
+ *              DMA is enabled).
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         None
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cRegisterMmFunc (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cMmFunc_t        pFuncStruct
+    )
+{
+
+#ifndef LINUX_BUILD
+    if (gI2cUnitCount == I2C_DATA_INVALID)
+    {
+        i2cDriverInit();
+    }
+#endif
+    gI2cRegisterMmFunc[i2cUnit].gpVirtToPhys       = pFuncStruct->pI2cVirtToPhys;
+    gI2cRegisterMmFunc[i2cUnit].gpCacheFlush       = pFuncStruct->pI2cCacheFlush;
+    gI2cRegisterMmFunc[i2cUnit].gpCacheInvalidate  = pFuncStruct->pI2cCacheInvalidate;
+    gI2cRegisterMmFunc[i2cUnit].bufferPtr = pFuncStruct->pI2cDynamicMemPtr;
+#ifdef LINUX_BUILD
+    gI2cRegisterMmFunc[i2cUnit].phyAddr   = pFuncStruct->phyAddr;
+#endif
+    gI2cRegisterMmFunc[i2cUnit].length = pFuncStruct->i2cDynamicMemLength;
+    if(gI2cRegisterMmFunc[i2cUnit].length > I2C_CFG_DMA_BLOCK_LENGTH)
+    {
+        gI2cRegisterMmFunc[i2cUnit].length = I2C_CFG_DMA_BLOCK_LENGTH;
+    }
+    tmhwI2cIP3203SetDMA(i2cUnit);
+
+    return TM_OK;
+} /* tmhwI2cRegisterMmFunc */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetSWVersion
+ *
+ * DESCRIPTION: Get the I2c HWAPI interface compatibility number, major
+ *              version and minor version.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         None
+ *
+ * NOTES:       re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cGetSWVersion (
+    ptmSWVersion_t          pI2cVersion
+    )
+{
+    /* provide the requested information */
+    pI2cVersion->compatibilityNr    = TMHW_I2C_COMPATIBILITY_NR;
+    pI2cVersion->majorVersionNr     = TMHW_I2C_MAJOR_VERSION_NR;
+    pI2cVersion->minorVersionNr     = TMHW_I2C_MINOR_VERSION_NR;
+
+    return TM_OK;
+} /* tmhwI2cGetSWVersion */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetCapabilities:
+ *
+ * DESCRIPTION: This function returns the I2c HWAPI capabilities.
+ *
+ * RETURN:      TMHW_ERR_I2C_BAD_UNIT_ID or TM_OK
+ *
+ * PRE:         None
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwI2cGetCapabilities (
+                        tmUnitSelect_t      i2cUnit,
+                        ptmhwI2cCapabilities_t  pI2cCaps
+                        )
+{
+    UInt32 FSSpeed, HsSpeed;
+    tmErrorCode_t   status = TM_OK;
+    if (gI2cUnitCount == I2C_DATA_INVALID)
+    {
+        i2cDriverInit();
+    }
+
+    if (i2cUnit >= gI2cUnitCount)
+    {
+        status = TMHW_ERR_I2C_BAD_UNIT_ID;
+    }
+    else
+    {
+        pI2cCaps->i2cUnitCount = (UInt32) gI2cUnitCount;
+
+        if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+        {
+            pI2cCaps->i2cModuleID = I2C_IP3203_HWMODULE_ID;
+
+            FSSpeed = TMHW_I2C_MAX_FS_SPEED;
+            HsSpeed = TMHW_I2C_MAX_HS_SPEED;
+            tmhwI2cConvertSpeed ( i2cUnit, &FSSpeed, &HsSpeed );
+
+            pI2cCaps->i2cMaxSpeedKHZ    = FSSpeed;
+            pI2cCaps->i2cMaxHsSpeedKHZ  = HsSpeed;
+        }
+        else
+        {
+            pI2cCaps->i2cModuleID = IIC_IP0105_HWMODULE_ID;
+
+            FSSpeed = TMHW_I2C_MAX_FS_SPEED;
+            HsSpeed = 0;
+            tmhwI2cConvertSpeed ( i2cUnit, &FSSpeed, &HsSpeed );
+
+            pI2cCaps->i2cMaxSpeedKHZ    = FSSpeed;
+            pI2cCaps->i2cMaxHsSpeedKHZ  = HsSpeed;
+        }
+    }
+    return  status;
+} /* tmhwI2cGetCapabilities */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetBlockId:
+ *
+ * DESCRIPTION: This function returns the specified I2c HW Module Block ID
+ *
+ * RETURN:      TMHW_ERR_I2C_BAD_UNIT_ID, TM_OK
+ *
+ * PRE:         None
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cGetBlockId(
+    tmUnitSelect_t  i2cUnit,
+    pUInt32     pBlockId
+    )
+{
+    tmErrorCode_t   status = TM_OK;
+
+    if (gI2cUnitCount == I2C_DATA_INVALID)
+    {
+        i2cDriverInit();
+    }
+
+    if (i2cUnit >= gI2cUnitCount)
+    {
+        status = TMHW_ERR_I2C_BAD_UNIT_ID;
+    }
+    else
+    {
+        if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+        {
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_MODULE_ID_OFFSET, *pBlockId);
+        }
+        else
+        {
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_MODULE_ID_OFFSET, *pBlockId);
+        }
+    }
+    return status;
+} /* tmhwI2cGetBlockId */
+
+#ifdef LINUX_BUILD
+#ifdef CONFIG_I2C_TM_DOWNLOAD
+//
+// The early TM program downloads the Channel decoder
+// using the I2c IP block.
+//
+// We want to ensure that this one is finished before
+// proceeding here with claiming the I2c bus.
+//
+#define DSP_TM32_INI_BASE   0x1BF40000
+#define DSP_TM32_PC         0x004C
+#define DSP_TM32_START      0x0048
+#define DSP_WINDOW_SIZE     0x0100
+#define MAX_DELAY_MSEC      100
+static unsigned long earlytm_addr;
+
+static void Await_Early_Download( void );
+static void TriggerPin( int pinNr, int state);
+
+static int __init earlytm_setup(char *str)
+{
+     earlytm_addr = simple_strtoul(str,NULL,0);
+     printk(KERN_INFO "earlytm_addr = %x\n",earlytm_addr);
+     return 1;
+}
+
+__setup("earlytm=", earlytm_setup);
+
+void TriggerPin( int pinNr, int state)
+{
+    volatile unsigned long* p1 = (volatile unsigned long*) 0xbbf4c000;
+    volatile unsigned long* p2 = (volatile unsigned long*) 0xbbf4c010;
+
+    if( pinNr == 0 )
+        {
+            if( state )
+                {
+                    *p1 = 0x00000002;
+                    *p2 = 0x00010001;
+                }
+            else
+                {
+                    *p1 = 0x00000002;
+                    *p2 = 0x00010000;
+                }
+        }
+    else if ( pinNr == 3 )
+        {
+            if( state )
+                {
+                    *p1 = 0x00000080;
+                    *p2 = 0x00080008;
+                }
+            else
+                {
+                    *p1 = 0x00000080;
+                    *p2 = 0x00080000;
+                }
+        }
+    else
+        {
+            printk( "unsupported pin %d\n", pinNr );
+        }
+}
+
+static void Await_Early_Download( void )
+{
+    static int initDone = 0;
+
+    if( initDone )
+    {
+        // nothing to be done
+    }
+    else
+    {
+        unsigned int pTM;
+        initDone = 1;
+
+#ifdef CONFIG_I2C_DEBUG
+        TriggerPin( 3, 0);
+#endif
+
+        pTM = (unsigned int) ioremap( DSP_TM32_INI_BASE, DSP_WINDOW_SIZE );
+
+        if( pTM )
+        {
+            volatile unsigned int * pTM_PC       = (volatile unsigned int* ) (pTM + DSP_TM32_PC    );
+            volatile unsigned int * pTM_START    = (volatile unsigned int* ) (pTM + DSP_TM32_START );
+            unsigned int            prev_PC      = 0;   // previous value for PC
+            unsigned int            cur_PC       = 0;   // current  value of PC
+            int                     identicalCnt = 0;   // number of consecutive identical PC
+            int                     iteration    = 0;   // total iteration count, just for debugging
+            unsigned long           end_time;
+            unsigned long cur_TM_START;
+
+            cur_TM_START = *pTM_START;
+
+            // early TM start address a kernel bootcmdline option
+            if( cur_TM_START == earlytm_addr )
+            {
+#ifdef CONFIG_I2C_DEBUG
+                printk(KERN_EMERG "checking early TM status\n");
+                printk(KERN_EMERG "earlytm_addr = %x\n",earlytm_addr);
+#endif
+
+                end_time = jiffies + (MAX_DELAY_MSEC * HZ / 1000 );
+                do {
+                    iteration++;
+                    cur_PC = *pTM_PC;
+                    if( cur_PC == prev_PC )
+                    {
+                        identicalCnt++;
+                    }
+                    else
+                    {
+                        identicalCnt = 0;
+                    }
+                    prev_PC = cur_PC;
+                    schedule();
+                } while (  ( identicalCnt < 5 )
+                        && ( time_before( jiffies, end_time) ) );
+
+                if( identicalCnt < 5 )
+                {
+                    printk(KERN_EMERG "ERROR: early TM wait loop gives up after %d msec (and %d iterations)\n", MAX_DELAY_MSEC, iteration );
+                    printk(KERN_EMERG "IdenticalCnt= %d, cur_PC= 0x%08x, prev_PC= 0x%08x\n", identicalCnt, cur_PC, prev_PC );
+                }
+                else
+                {
+#ifdef CONFIG_I2C_DEBUG
+                    printk(KERN_EMERG "early TM wait ok after %lu msec (and %d iterations)\n", jiffies + (MAX_DELAY_MSEC * HZ / 1000) - end_time, iteration );
+#endif
+                }
+            }
+            else
+            {
+#ifdef CONFIG_I2C_DEBUG
+                printk(KERN_EMERG "skipp early TM status check (looks like hotboot ?)\n" );
+                printk(KERN_EMERG "TM_START = 0x%08x\n", *pTM_START );
+#endif
+            }
+        }
+        else
+        {
+            printk(KERN_EMERG "ERROR: Could not map TM registers into memory, so can't check early TM download stuff\n" );
+        }
+
+#ifdef CONFIG_I2C_DEBUG
+        TriggerPin( 3, 1);
+#endif
+    }
+}
+
+#endif /*CONFIG_I2C_TM_DOWNLOAD*/
+#endif /* LINUX_BUILD*/
+
+/* -------------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cInit:
+ *
+ * DESCRIPTION: Initializes the indicated I2c device. The device will be
+ *              initialized with the following defaults:
+ *              - SS speed = TMHW_I2C_MAX_SS_SPEED,
+ *              - HS speed = 0
+ *              - enable I2c module interface (EN is set),
+ *              - disable and clear I2c interrupt.
+ *
+ *              The I2c MMIO base address is obtained from configuration files
+ *              and used by the subsequent I2c functions to access I2c MMIO
+ *              registers.
+ *
+ * RETURN:      TMHW_ERR_I2C_BAD_UNIT_ID or TM_OK
+ *
+ * PRE:         state = idle
+ *
+ * POST         state = initialized
+ *
+ * NOTES:       re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cInit (
+    tmUnitSelect_t   i2cUnit
+    )
+{
+    tmErrorCode_t   retVal = TM_OK;
+
+#ifdef LINUX_BUILD
+#ifdef CONFIG_I2C_TM_DOWNLOAD
+/* Ensuring TM has finished using the I2C bus*/
+    Await_Early_Download();
+#endif
+#endif
+
+    if (gI2cUnitCount == I2C_DATA_INVALID)
+    {
+        i2cDriverInit();
+    }
+    if (i2cUnit >= gI2cUnitCount)
+    {
+        retVal = TMHW_ERR_I2C_BAD_UNIT_ID;
+    }
+    else
+    {
+        /* Make sure I2c is not in the power down mode */
+        retVal = tmhwI2cSetPowerState(i2cUnit, tmPowerOn);
+
+        /* Reset I2c module */
+        i2cControl(i2cUnit, tmhwI2cControlNone);
+        i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+        retVal = tmhwI2cIntClear(i2cUnit);
+
+        /* disable slave addresses */
+        tmhwI2cSetSlaveAddr(i2cUnit, 0);
+        tmhwI2cDisableGeneralCall(i2cUnit);
+
+        /* Set the default speed to 100KHz (maximum Standard Speed mode)
+        * Disable High Speed
+        * Device IP3203 requires that the speed must be set before using Slave mode.
+        * this requirement now is fulfilled then.
+        */
+        if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+        {
+#if 0 /* TODO */
+            /* program SDA_HOLD register */
+            /* Multiply by 2 if the PCFClk is 24Mhz to get appr 14 value in
+            the SDA HOLD register*/
+            UInt32 multiplyFactor = 48000/gI2cCfg[i2cUnit].clockFreqKHz;
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_SDA_HOLD,
+                                (gI2cCfg[i2cUnit].clockFreqKHz/10000) * 3 * (multiplyFactor));
+            tmhwI2cSetSpeed(i2cUnit, TMHW_I2C_MAX_SS_SPEED, TMHW_I2C_MAX_SS_SPEED);
+#endif     
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_SDA_HOLD,0x2D);
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_FSBIR_OFFSET, 0x3E);
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_HSBIR_OFFSET, 0x0);
+        }
+        else
+        {
+            i2cIP0105SetSpeed(i2cUnit);
+        }
+
+        /* Enable I2c module */
+        retVal = tmhwI2cIntEnable(i2cUnit);
+        i2cControl(i2cUnit,tmhwI2cEnable);
+    }
+    return retVal;
+} /* tmhwI2cInit */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cDeinit:
+ *
+ * DESCRIPTION: Deinitialize the specified I2c device to known state and disable
+ *              the interrupt. Al activities are aborted.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         state != idle
+ *
+ * POST         state = idle
+ *
+ * NOTES:       re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cDeinit (
+    tmUnitSelect_t       i2cUnit
+    )
+{
+    tmErrorCode_t   retVal;
+    /* Disable I2c module and make sure Ack and Start are off.
+     * When the module is in DMA mode, all registers are blocked.
+     * So first be sure that DMA is disabled.
+     */
+    i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+
+    /* Disable I2c module */
+    i2cControl(i2cUnit, tmhwI2cControlNone);
+    retVal = tmhwI2cIntDisable(i2cUnit);
+    retVal = tmhwI2cIntClear(i2cUnit);
+
+    /* Turn off the power for I2c unit */
+    retVal = tmhwI2cSetPowerState(i2cUnit, tmPowerOff);
+
+    return retVal;
+} /* tmhwI2cDeinit */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetPowerState:
+ *
+ * DESCRIPTION: Get the current device power state.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cGetPowerState (
+    tmUnitSelect_t      i2cUnit,
+    ptmPowerState_t     pPowerState
+    )
+{
+    UInt32 reg_value = 0;
+    tmErrorCode_t   status = TM_OK;
+
+    if (gI2cUnitCount == I2C_DATA_INVALID)
+    {
+        i2cDriverInit();
+    }
+
+    if (i2cUnit >= gI2cUnitCount)
+    {
+        status = TMHW_ERR_I2C_BAD_UNIT_ID;
+    }
+    else if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_POWERDOWN_OFFSET, reg_value);
+        if(reg_value & TMVH_I2C3203_POWERDOWN_PWR_DOWN_MSK)
+        {
+            *pPowerState = tmPowerOff;
+        }
+        else
+        {
+            *pPowerState = tmPowerOn;
+        }
+    } else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_POWERDOWN_OFFSET, reg_value);
+        if(reg_value & TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_MSK)
+        {
+            *pPowerState = tmPowerOff;
+        }
+        else
+        {
+            *pPowerState = tmPowerOn;
+        }
+    }
+    return status;
+} /* tmhwI2cGetPowerState */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSetPowerState:
+ *
+ * DESCRIPTION: Set the device current power state.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         state = initialized
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cSetPowerState (
+    tmUnitSelect_t          i2cUnit,
+    tmPowerState_t          powerState
+    )
+{
+    UInt32 powerdown = 0;
+    UInt32 reg_value = 0;
+
+    if (powerState == tmPowerOff)
+    {
+        powerdown = 1;
+    }
+    else
+    {
+        powerdown = 0;
+    }
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_POWERDOWN_OFFSET, reg_value);
+        reg_value &= ~TMVH_I2C3203_POWERDOWN_PWR_DOWN_MSK;
+        reg_value |= ((powerdown << TMVH_I2C3203_POWERDOWN_PWR_DOWN_POS) & TMVH_I2C3203_POWERDOWN_PWR_DOWN_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_POWERDOWN_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_POWERDOWN_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_MSK;
+        reg_value |= ((powerdown << TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_POS) & TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_POWERDOWN_OFFSET, reg_value);
+    }
+    return TM_OK;
+} /* tmhwI2cSetPowerState */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSetPowerState:
+ *
+ * DESCRIPTION: Set the device current power state.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         state = initialized
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cSetIntEnable (
+    tmUnitSelect_t          i2cUnit,
+    bool                    enable
+    )
+{
+    if (enable)
+    {
+       I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_ENABLE_OFFSET, 0x1);
+    }
+    else
+    {
+       I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_ENABLE_OFFSET, 0);
+    }
+
+    return TM_OK;
+} /* tmhwI2cSetIntEnable */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cEnableGeneralCall:
+ *
+ * DESCRIPTION: monitor the I2C-bus for the general call. An interrupt
+ *              is generated if the general call address is detected.
+ *              General call address is the 7-bit slave address = 0 and R/W
+ *              bit = 0.
+ *
+ * RETURN:      -
+ *
+ * PRE:         idle
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cEnableGeneralCall (
+    tmUnitSelect_t          i2cUnit
+    )
+{
+    UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+        reg_value |= TMVH_I2C3203_I2CSLA_WATCH_GC_MSK; /* Set the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+        reg_value |= TMVH_IIC0105_I2C_ADDR_WATCH_GC_MSK; /* Set the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+    }
+} /* tmhwI2cEnableGeneralCall */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cDisableGeneralCall:
+ *
+ * DESCRIPTION: Ignore the general call address on the I2c bus.
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cDisableGeneralCall (
+    tmUnitSelect_t          i2cUnit
+    )
+{
+    UInt32 reg_value;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+        reg_value &= ~TMVH_I2C3203_I2CSLA_WATCH_GC_MSK; /* Reset(clear) the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2C_ADDR_WATCH_GC_MSK; /* Reset(clear) the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+    }
+} /* tmhwI2cDisableGeneralCall */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSetSlaveAddr:
+ *
+ * DESCRIPTION: When the slave monitors the I2C-bus,
+ *              it answeres the here specified slave address
+ *
+ * RETURN:      -
+ *
+ * PRE:         state !=idle
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cSetSlaveAddr (
+    tmUnitSelect_t          i2cUnit,        /*  I:  I2c Unit ID number */
+    UInt8                   moduleSlaveAddr /*  I:  7-bit I2c slave address while the I2c
+                                              module is in the slave mode. */
+    )
+{
+    UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+        reg_value &= ~TMVH_I2C3203_I2CSLA_SLAVE_ADDR_MSK;
+        reg_value |= ((moduleSlaveAddr << TMVH_I2C3203_I2CSLA_SLAVE_ADDR_POS) & TMVH_I2C3203_I2CSLA_SLAVE_ADDR_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CSLA_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2C_ADDR_SLAVE_ADDR_MSK;
+        reg_value |= ((moduleSlaveAddr << TMVH_IIC0105_I2C_ADDR_SLAVE_ADDR_POS) & TMVH_IIC0105_I2C_ADDR_SLAVE_ADDR_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_ADDR_OFFSET, reg_value);
+    }
+
+} /* tmhwI2cSetSlaveAddr */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSetSpeed:
+ *
+ * DESCRIPTION: Determines the I2C-bus speed when the device controls the bus
+ *              (master mode)
+ *
+ * RETURN:      -
+ *
+ * PRE:         state = initialized
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cSetSpeed (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  fsSpeed,
+    UInt32                  hsSpeed
+    )
+{
+    UInt32 fsbir, hsbir;
+
+    i2cConvertSpeedToReg(i2cUnit, fsSpeed, hsSpeed, &fsbir, &hsbir);
+    /* conversion intelligence is in i2cConvertSpeed , unit is also passed */
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_FSBIR_OFFSET, fsbir);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_HSBIR_OFFSET, hsbir);
+    }
+    else
+    {
+        /* HwApi 0105 says to stop the module first!
+         * Speed for 0105 modules is done at Initialisation only, according
+         * to the speed set in tmhwI2cCfg.c
+         */
+    }
+} /* tmhwI2cSetSpeed */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetSpeed:
+ *
+ * DESCRIPTION: Gets the speed that the I2C-bus will have when the indicated
+ *              device controls the bus (master mode)
+ *
+ * RETURN:      -
+ *
+ * PRE:         state!= idle
+ *
+ * NOTES:       non re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cGetSpeed (
+    tmUnitSelect_t          i2cUnit,
+    pUInt32                 pFsSpeed,
+    pUInt32                 pHsSpeed        /* 0: if no HS */
+    )
+{
+    UInt32 fsbir, hsbir;
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_FSBIR_OFFSET, fsbir);
+        fsbir = ((fsbir & TMVH_I2C3203_FSBIR_BITRATE_MSK) >> TMVH_I2C3203_FSBIR_BITRATE_POS);
+
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_HSBIR_OFFSET, hsbir);
+        hsbir = ((hsbir & TMVH_I2C3203_HSBIR_BITRATE_MSK) >> TMVH_I2C3203_HSBIR_BITRATE_POS);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, fsbir);
+        fsbir = ((fsbir & TMVH_IIC0105_I2CCONTROL_CR2_MSK) >> TMVH_IIC0105_I2CCONTROL_CR2_POS);
+        hsbir = 0;
+    }
+    /* intelligence goes to i2cConvertSpeedToActual */
+    i2cConvertSpeedToActual(i2cUnit, fsbir, hsbir, pFsSpeed, pHsSpeed);
+
+} /* tmhwI2cGetSpeed */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cConvertSpeed:
+ *
+ * DESCRIPTION: This function derives the actual speed at which the specific
+ *              master will communicate when it controls the I2C-bus from the
+ *              intended speed
+ *
+ * RETURN:      -
+ *
+ * PRE:         -
+ *
+ * NOTES:       non Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cConvertSpeed (
+    tmUnitSelect_t          i2cUnit,
+    pUInt32                 pFsSpeed,
+    pUInt32                 pHsSpeed
+    )
+{
+    UInt32 fsbir, hsbir;
+
+    i2cConvertSpeedToReg(i2cUnit, *pFsSpeed, *pHsSpeed, &fsbir, &hsbir);
+    i2cConvertSpeedToActual(i2cUnit, fsbir, hsbir, pFsSpeed, pHsSpeed);
+} /* tmhwI2cConvertSpeed */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetBusStatus:
+ *
+ * DESCRIPTION: This function indicates if the bus is free or busy by qeurying
+ *              the INTROG register in IP3203 and the I2C BUS OBSERVATION
+ *              register in the IP0105. This API shall be used to ensure a
+ *              safe close of the driver.
+ * RETURN:      -
+ *
+ * PRE:         -
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void tmhwI2cGetBusStatus(
+        tmUnitSelect_t          i2cUnit,
+        ptmhwI2cStatusType_t    pStatusType
+        )
+{
+    UInt32 status;
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INTROG_OFFSET, status);
+        if ( (status & TMVH_I2C3203_INTROG_INTRO_BB_MSK)
+                    == TMVH_I2C3203_INTROG_INTRO_BB_MSK )
+        {
+            *pStatusType = tmhwI2cBusBusy;
+        }
+        else
+        {
+            *pStatusType = tmhwI2cBusFree;
+        }
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_OBS_PINS_OFFSET, status);
+        if ( ((status & TMVH_IIC0105_I2C_OBS_PINS_OBS_SCL_MSK)
+                == TMVH_IIC0105_I2C_OBS_PINS_OBS_SCL_MSK) &&
+              ((status & TMVH_IIC0105_I2C_OBS_PINS_OBS_SDA_MSK)
+                == TMVH_IIC0105_I2C_OBS_PINS_OBS_SDA_MSK) )
+        { /* bus is fre if both lines are released*/
+            *pStatusType = tmhwI2cBusFree;
+        }
+        else
+        {
+            *pStatusType = tmhwI2cBusBusy;
+        }
+    }
+
+}
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIntGetStatus:
+ *
+ * DESCRIPTION: Get the current HwAPI state
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle
+ *
+ * NOTES:       non Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cIntGetStatus (
+      tmUnitSelect_t        i2cUnit,
+    ptmhwI2cStatusType_t    pStatusType
+    )
+{
+    tmhwI2cEvent_t  eventLocal;
+
+    i2cGetStatus(i2cUnit, &eventLocal);
+    if (eventLocal == tmhwI2cEvent0xf8)          /* no interrupt, state = 0xf8 */
+    {
+        *pStatusType = tmhwI2cNoInterrupt;
+    }
+    else if (eventLocal == tmhwI2cEvent0x00)     /* bus error */
+    {
+        *pStatusType = tmhwI2cBusError;
+    }
+    else if (eventLocal < tmhwI2cEvent0x60)      /* master mode */
+    {
+        *pStatusType = tmhwI2cMaster;
+    }
+    else                                    /* slave mode */
+    {
+        *pStatusType = tmhwI2cSlave;
+    }
+
+} /* tmhwI2cIntGetStatus */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIntEnable:
+ *
+ * DESCRIPTION: Enables the interrupt of the specified I2C device.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         state != idle
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cIntEnable (
+    tmUnitSelect_t          i2cUnit
+    )
+{
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_ENABLE_OFFSET, TMVH_I2C3203_INT_ENABLE_EN_MODE_MSK);
+    }
+    else
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_ENABLE_OFFSET, TMVH_IIC0105_INT_ENABLE_EN_MSK);
+    }
+
+    return TM_OK;
+} /* tmhwI2cIntEnable */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIntDisable:
+ *
+ * DESCRIPTION: Disables the interrupt for the specified I2C device.
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cIntDisable (
+    tmUnitSelect_t  i2cUnit
+    )
+{
+      UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        reg_value &= ~TMVH_I2C3203_INT_ENABLE_EN_MODE_MSK; /* Reset the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_ENABLE_OFFSET, reg_value);
+    }
+    else
+    {
+        reg_value &= ~TMVH_IIC0105_INT_ENABLE_EN_MSK; /* Reset the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_ENABLE_OFFSET, reg_value);
+    }
+
+    return TM_OK;
+} /* tmhwI2cIntDisable */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIntClear:
+ *
+ * DESCRIPTION: Clears the interrupt for the specific I2c device.
+ *
+ * RETURN:      TM_OK
+ *
+ * PRE:         state != idle
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cIntClear (
+    tmUnitSelect_t          i2cUnit
+    )
+{
+    UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_CLEAR_OFFSET, TMVH_I2C3203_INT_CLEAR_INTCLR_MSK);
+        /* wait for peripheral to be sure that the interrupt has been cleared: Do dummy read */
+        //I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_CLEAR_OFFSET, reg_value);
+      I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_STATUS_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_CLEAR_OFFSET, TMVH_IIC0105_INT_CLEAR_CLR_MSK);
+        /* wait for peripheral to be sure that the interrupt has been cleared: Do dummy read */
+        //I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_CLEAR_OFFSET, reg_value);
+      I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_STATUS_OFFSET, reg_value);
+    }
+
+    (Void)reg_value;    /* To avoid compile time remark variable not used */
+
+    return TM_OK;
+} /* tmhwI2cIntClear */
+
+
+
+/* ---------------------------------------------------------------------------
+ * External functions for ISR layer:
+ * ---------------------------------------------------------------------------
+ */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSetData:
+ *
+ * DESCRIPTION: Fills the HwAPI data buffer
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle & (module is monitorring | waiting for request)
+ *              tmhwI2cEvent has returned TMHW_ERR_I2C_REQUEST while interrupt
+ *              is not yet cleared,
+ *              or module is not communicating
+ *
+ * POST:        gI2cIP3203Data.counter = gI2cIP3203Data.length
+ *
+ * NOTES:       Not re-entrant.
+ *
+ *              gI2cIP3203Data[i2cUnit].attach -> tmhwI2cRestart is for master
+ *                                                  only
+ *              gI2cIP3203Data[i2cUnit].slaveAddress    -> for master only
+ *              gI2cIP3203Data[i2cUnit].direction       -> for master only
+ *
+ *              In a multi processor environment this function
+ *              must not be used outside the scope of the user process where
+ *              the ISR runs!!!
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cSetData (
+    tmUnitSelect_t      i2cUnit,
+    ptmhwI2cData_t      pData
+    )
+{
+    gI2cData[i2cUnit].pAddress      = pData->pAddress;
+    gI2cData[i2cUnit].length        = pData->length;
+    gI2cData[i2cUnit].counter       = pData->length;
+    gI2cData[i2cUnit].attach        = pData->attach;        /* tmhwI2cRestart is for master only */
+    gI2cData[i2cUnit].slaveAddress  = pData->slaveAddress;  /* for master only */
+    gI2cData[i2cUnit].direction     = pData->direction;     /* for master only */
+    gI2cData[i2cUnit].bHS           = pData->bHS;           /* for master only */
+    if (gI2cCfg[i2cUnit].bHS == False)
+    {
+        gI2cData[i2cUnit].bHS = False;
+    }
+
+} /* tmhwI2cSetData */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cGetData:
+ *
+ * DESCRIPTION: Gets the content of the HwAPI data buffer
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle,
+ *
+ * NOTES:       Not re-entrant.
+ *
+ *              In a multi processor environment this function
+ *              must not be used outside the scope of the user process where
+ *              the ISR runs!!!
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cGetData (
+    tmUnitSelect_t          i2cUnit,
+    ptmhwI2cData_t          pdata
+    )
+{
+    pdata->pAddress         = gI2cData[i2cUnit].pAddress;
+    pdata->length           = gI2cData[i2cUnit].length;
+    pdata->counter          = gI2cData[i2cUnit].counter;
+    pdata->attach           = gI2cData[i2cUnit].attach;
+    pdata->slaveAddress     = TMHW_I2C_DATA_DUMMY;                          /* in slave mode, no meaning */
+    pdata->direction        = tmhwI2cNoMeaning;                             /* in slave mode, no meaning */
+    pdata->bHS              = TMHW_I2C_DATA_DUMMY;                          /* in slave: mode no meaning */
+} /* tmhwI2cGetData */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cStartMaster:
+ *
+ * DESCRIPTION: Puts the module into Master mode if it is monitorring the bus.
+ *              (the slave is not addressed) Otherwise, no action
+ *
+ * RETURN:      -
+ *
+ * PRE:         state = initialized
+ *
+ * POST:        not controlling master mode
+ *
+ * NOTES:       the module can be in master state and in slave state
+ *              simultaneously
+ *
+ *              When the master is aborted for some reason, the caller is
+ *              responsible to restart the request. The content of
+ *              tmhwI2cData[i2cUnit] indicates the transceived data.
+ *
+ *              Arguments direction is for compatibility
+ *              reasons only and are not needed here.
+ *
+ *              Re-entrant against shared variables.
+ *              not Re-entrant against multi tasks.
+ *----------------------------------------------------------------------------
+ */
+Void
+tmhwI2cStartMaster (
+    tmUnitSelect_t          i2cUnit,
+    UInt8                   slaveAddress,   /* I2c slave address of slave being */
+    tmhwI2cDirection_t      direction       /* i2c communication direction */
+    )
+{
+    (Void) direction;                /* parameter not used, hide warning */
+
+    i2cControl( i2cUnit,
+                (tmhwI2cControl_t) (tmhwI2cEnable | tmhwI2cStartCond |
+                                   (slaveAddress ? tmhwI2cAcknowledge : tmhwI2cControlNone)) );
+
+} /* tmhwI2cStartMaster */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cStartSlave:
+ *
+ * DESCRIPTION: starts the module being in slave mode.
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != idle
+ *
+ * POST:        not addressed slave mode
+ *
+ * NOTES:       the module can be in master state and in slave state
+ *              simultaneously
+ *
+ *              Re-entrant against shared variables.
+ *              not Re-entrant against multi tasks.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cStartSlave (
+    tmUnitSelect_t          i2cUnit
+    )
+{
+    UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, reg_value);
+        /* Set the bits correctly to ensure SDA_CTRL, SCL_CTRL, INT_CLEAR bits are set to 0
+        This solves the illegal STOP ticket 82910 PE9#681
+        & Ticket 95737 SETSTO shall be masked for slave.
+        Otherwise it will result in Slave pulling the line low and aborting the
+        transfer*/
+        /* patch to ticket 82910
+            pre1: read != 0xDEADABBA
+              read update write with redundant Enable bit and bit 0,1,3 forced to 0
+            pre2: read = 0xDEADABBA
+              read value is incorrect,
+              enable forced to 1
+              scl, sda and int_clr bits forced to 0
+              written value does not stall device and will be
+              overwritten in ISR before INT_CLEAR
+            pre 3: Write is unsuccessful
+               written value does not have influence and will be
+               rewritten in ISR mode before INT_CLEAR
+        */
+#if (TMFL_PNX_ID == 5100)
+        reg_value = ((reg_value | ( TMVH_I2C3203_I2CCON_AA_MSK
+                                    |  TMVH_I2C3203_I2CCON_EN_I2C_MSK)) & 0xE4);   /* Set the bit field */
+#else
+        reg_value = ((reg_value | ( TMVH_I2C3203_I2CCON_AA_MSK
+                                    |  TMVH_I2C3203_I2CCON_EN_I2C_MSK)) & 0xF4);   /* Set the bit field */
+#endif
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+        reg_value |= TMVH_IIC0105_I2CCONTROL_AA_MSK; /* Set the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+    }
+} /* tmhwI2cStartSlave */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cStopSlave:
+ *
+ * DESCRIPTION: stops the module being in slave mode
+ *
+ * RETURN:      -
+ *
+ * PRE:         state != monitorring
+ *
+ * NOTES:       the module can be in master state and in slave state
+ *              simultaneously
+ *
+ *              Re-entrant against shared variables.
+ *              not Re-entrant against multi tasks.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cStopSlave (
+    tmUnitSelect_t  i2cUnit
+    )
+{
+    UInt32 reg_value = 0;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, reg_value);
+        /* Set/Reset the bits correctly to ensure SDA_CTRL, SCL_CTRL, INT_CLEAR bits are set to 0
+        This solves the illegal STOP ticket 82910 PE9#681
+        & Ticket 95737 SETSTO shall be masked for slave.
+        Otherwise it will result in Slave pulling the line low and aborting the
+        transfer*/
+#if (TMFL_PNX_ID == 5100)
+        reg_value = ((reg_value & ~TMVH_I2C3203_I2CCON_AA_MSK) & 0xEC) | TMVH_I2C3203_I2CCON_EN_I2C_MSK;      /* Reset the bit field */
+#else
+        reg_value = ((reg_value & ~TMVH_I2C3203_I2CCON_AA_MSK) & 0xFC) | TMVH_I2C3203_I2CCON_EN_I2C_MSK;      /* Reset the bit field */
+#endif
+
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2CCONTROL_AA_MSK; /* Reset the bit field */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+    }
+} /* tmhwI2cStopSlave */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cEvent
+ *
+ * DESCRIPTION: handles an I2c event
+ *
+ * RETURN:      TM_OK
+ *              TMHW_ERR_I2C_EVENT_MST_REQ
+ *              TMHW_ERR_I2C_EVENT_MST_LOST
+ *              TMHW_ERR_I2C_EVENT_MST_ABORT
+ *              TMHW_ERR_I2C_EVENT_MST_TRX_REQ
+ *              TMHW_ERR_I2C_EVENT_MST_TRX_DONE
+ *              TMHW_ERR_I2C_EVENT_MST_TRX_ABORT
+ *              TMHW_ERR_I2C_EVENT_MST_REC_REQ
+ *              TMHW_ERR_I2C_EVENT_MST_REC_DONE
+ *              TMHW_ERR_I2C_EVENT_MST_REC_ABORT
+ *              TMHW_ERR_I2C_EVENT_SLV_REC_REQ_MST_LOST
+ *              TMHW_ERR_I2C_EVENT_SLV_REC_REQ
+ *              TMHW_ERR_I2C_EVENT_SLV_GC_REQ_MST_LOST
+ *              TMHW_ERR_I2C_EVENT_SLV_GC_REQ
+ *              TMHW_ERR_I2C_EVENT_SLV_REC_DONE
+ *              TMHW_ERR_I2C_EVENT_SLV_REC_ABORT
+ *              TMHW_ERR_I2C_EVENT_SLV_TRX_REQ
+ *              TMHW_ERR_I2C_EVENT_SLV_TRX_REQ_MST_LOST
+ *              TMHW_ERR_I2C_EVENT_SLV_TRX_DONE
+ *              TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT
+ *              TMHW_ERR_I2C_EVENT_BUS_ERROR
+ *
+ * PRE:         (state = controlling master | state = addressed slave)
+ *              I2c Device is in interrupt status. Then its status
+ *              is ->not<- tmhwI2cEvent0xf8
+ *              The driver is protected against improper use of this
+ *              latter pre-condition.
+ *
+ * POST:        returns TM_OK
+ *              - the I2c device interrupt has been cleared
+ *              returns TMHW_ERR_I2C_INVALID_REQUEST
+ *              - wrong argument
+ *              othersise
+ *              - a higher level event has been occured
+ *              when return var = TMHW_ERR_I2C_EVENT_*REQ, a second call to
+ *              this function is required with request = tmhwI2cEventProceed.
+ *              in between these function calls, data must be set available
+ *              and/or retreived.
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t tmhwI2cEvent (
+    tmUnitSelect_t  i2cUnit,
+    tmhwI2cRequest_t    request,
+    Bool            bSlaveMonitor
+    )
+{
+    tmErrorCode_t               status = TM_OK, stat;
+    static tmErrorCode_t        nextStatus[TMHW_I2C_UNIT_MAX];
+    static tmhwI2cAttach_t      attachReminder[TMHW_I2C_UNIT_MAX];
+    static tmhwI2cDirection_t   gI2cDirection[TMHW_I2C_UNIT_MAX]; /* reminder for slave */
+    static tmhwI2cEvent_t       event;
+    tmhwI2cControl_t            slaveMonitor;
+    static UInt32               i2cLastState[TMHW_I2C_UNIT_MAX];
+    static UInt32               i2cRsCount;
+
+    i2cGetStatus(i2cUnit, &event);
+    if (event == tmhwI2cEvent0xf8)
+    {/* nothing to handle */
+        return TMHW_ERR_I2C_BUSY;
+    }
+    if (bSlaveMonitor == True)
+    {
+        slaveMonitor = tmhwI2cAcknowledge;
+    }
+    else
+    {
+        slaveMonitor = tmhwI2cControlNone;
+    }
+
+    /* check whether to adapt the data due to incomplete DMA transfer */
+#ifdef I2C_PRINTK
+    if (request == tmhwI2cEventInterrupt)
+    {
+        printk("Event : %x\n", event);
+    }
+#endif /* I2C_PRINTK */
+    (Void)i2cCheckDma(i2cUnit, request);
+
+    switch (event)
+    {
+    case (tmhwI2cEvent0x00):        /* Bus Error */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            if ((gI2cData[i2cUnit].direction == tmhwI2cTransmit) &&
+                (gI2cCfg[i2cUnit].bDma == False))
+            {/* last byte has not arrived at receiver. correct it. */
+                (gI2cData[i2cUnit].counter)++;
+            }
+            /* asynchronous caller event */
+            status = TMHW_ERR_I2C_EVENT_BUS_ERROR;
+            /* STOP bit shall not be set.. Ticket # 96591, PB5#434*/
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        default :
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x08):        /* A START Condition has been transmitted */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* synchronous caller event */
+            i2cRsCount=0;
+            return TMHW_ERR_I2C_EVENT_MST_REQ;
+
+        case tmhwI2cEventProceed:
+            if (gI2cData[i2cUnit].bHS == True)
+            {/* send HS master code */
+                i2cWriteDat(i2cUnit, gI2cCfg[i2cUnit].hsMasterCode);
+            }
+            else
+            {/* send slave-r/w */
+                i2cSendSlaveAddress(i2cUnit);
+                /* includes i2cPrepareDma */
+                /* but in read mode, DMA will not start */
+            }
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x10):        /* A Repeated START condition has been transmitted */
+        switch(request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* the request has already been passed. HS is not an issue here. */
+            i2cSendSlaveAddress(i2cUnit);
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            i2cRsCount++;
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x18):        /* SLA.W has been transmitted, ACK has been received */
+        switch(request)
+        {
+        case tmhwI2cEventInterrupt:
+            i2cRsCount=0;
+            if (i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterTransmit)
+                == I2C_BUFFER_EMPTY)
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    status = TMHW_ERR_I2C_EVENT_MST_TRX_DONE;
+                }
+                else
+                {
+                    status = TMHW_ERR_I2C_EVENT_MST_TRX_ABORT;
+                }
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case(tmhwI2cEvent0x20):     /* SLA.W or master code has been transmitted: NOT ACK has been received */
+        switch(request)
+        {
+        case tmhwI2cEventInterrupt:
+            if ((gI2cData[i2cUnit].bHS == True) && (gI2cData[i2cUnit].counter > 0))
+            {/* HS */
+                gI2cData[i2cUnit].bHS = False;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cStartCond | slaveMonitor));
+            }
+            /*
+             * PB5#682 S/w Workaround for unexpected NACK. Ensure exactly 1 restart from Master
+             * to compensate for slow Slave side interrupt  servicing at 0xa0 state
+             * required for read mode, not sure if also required here for write mode.
+             * still to find out
+             * it does not harm though
+             */
+            else if(i2cRsCount == 1 && (gI2cData[i2cUnit].counter > 0))
+            {/* received unexpected Nack after reStart; reStart again (one retry max)*/
+                status = TM_OK;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStartCond|slaveMonitor));
+            }
+            else
+            {/* no HS */
+                /* asynchronous caller event */
+                status = TMHW_ERR_I2C_EVENT_MST_ABORT;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x28):        /* Data byte in I2CDAT has been transmitted, ACK received */
+        switch(request)
+        {
+        case tmhwI2cEventInterrupt:
+            if (i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterTransmit) ==
+                I2C_BUFFER_EMPTY)
+            {/* buffer empty */
+                if (gI2cData[i2cUnit].length == 0)
+                {/* empty buffer, stop communication */
+                    /* asynchronous caller event */
+                    status = TMHW_ERR_I2C_EVENT_MST_TRX_ABORT;
+                    i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+                }
+                if (gI2cData[i2cUnit].attach == tmhwI2cChain)
+                {/* counter = 0 */
+                    /* synchronous caller event */
+                    attachReminder[i2cUnit] = tmhwI2cChain;
+                    return TMHW_ERR_I2C_EVENT_MST_TRX_REQ;
+                }
+                else if (gI2cData[i2cUnit].attach == tmhwI2cRestart)
+                {/* counter = 0 */
+                    /* synchronous caller event */
+                    attachReminder[i2cUnit] = tmhwI2cRestart;
+                    return TMHW_ERR_I2C_EVENT_MST_REQ;
+                }
+                else
+                {/* tmhwI2cStopCond, counter = 0 */
+                    /* asynchronous caller event */
+                    status = TMHW_ERR_I2C_EVENT_MST_TRX_DONE;
+                    i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+                }
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            break;
+
+        case tmhwI2cEventProceed:
+            /* tmhwI2cChain | tmhwI2cRestart, buffer counter def>0 */
+            if (attachReminder[i2cUnit] == tmhwI2cChain)
+            {
+                if (i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterTransmit) ==
+                    I2C_BUFFER_EMPTY)
+                {
+                    return TM_OK;
+                }
+                else
+                {
+                    i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+                }
+            }
+            else
+            {/* tmhwI2cRestart */
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cStartCond|slaveMonitor));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x30):        /* Data byte in I2CDAT has been transmitted, NOT ACK received */
+        switch(request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* Master application informed about transfer abort irrespective of
+            whether the following request is Restart or a Chain.*/
+            status = TMHW_ERR_I2C_EVENT_MST_TRX_ABORT;
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x38):        /* Arbitration lost in SLA, R/W or in Data byte or in NOT ACK bit or in master code */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+
+            /* asynchronous caller event */
+            status = TMHW_ERR_I2C_EVENT_MST_LOST;
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            /* the start condition will be given by the caller. */
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x40):    /* SLA.R has been transmitted, ACK received */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* synchronous caller event */
+            i2cRsCount=0;
+            nextStatus[i2cUnit] = TM_OK;
+            gI2cByteWise[i2cUnit] = False;
+            stat = i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterReceive);
+            if ( stat == I2C_BUFFER_EMPTY )
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_MST_REC_DONE;
+                }
+                else
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_MST_REC_ABORT;
+                }
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else if ( stat == I2C_LAST_BYTE )
+            {
+               i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+               i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x48):    /* SLA.R or Master code has been transmitted, NOT ACK received */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            if ((gI2cData[i2cUnit].bHS == True) && (gI2cData[i2cUnit].counter > 0))
+            {/* HS */
+                gI2cData[i2cUnit].bHS = False;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStartCond|slaveMonitor));
+            }
+            /* PB5#682 S/w Workaround for unexpected NACK. Ensure exactly 1 restart from Master
+             * to compensate for slow Slave side interrupt  servicing at 0xa0 state
+             This probably is redundant.This is inserted for safety. It does not harm.*/
+            else if(i2cRsCount == 1 && (gI2cData[i2cUnit].counter > 0))
+            {   /* received unexpected Nack after reStart; reStart again (one retry max)*/
+                status = TM_OK;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStartCond|slaveMonitor));
+            }
+            else
+            {/* no HS */
+                /* asynchronous caller event */
+                status = TMHW_ERR_I2C_EVENT_MST_ABORT;
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x50):    /* Data byte has been received, ACK has been returned */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            stat = i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterReceive);
+            if ( stat == I2C_BUFFER_EMPTY )
+            {/* gI2cIP3203Data[i2cUnit].attach == tmhwI2cChain */
+                /* synchronous caller event */
+                return TMHW_ERR_I2C_EVENT_MST_REC_REQ;
+            }
+            else if ( stat == I2C_LAST_BYTE )
+            {/* (gI2cData[i2cUnit].attach == tmhwI2cRestart |
+                gI2cData[i2cUnit].attach == tmhwI2cStop)
+               tmhwI2cRestart | tmhwI2cStop, counter = 1, send NACK, */
+                i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cAcknowledge));
+            }
+            break;
+
+        case tmhwI2cEventProceed:
+            /* tmhwI2cChain, counter def>0 */
+            stat = i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterReceive);
+            if (stat == I2C_BUFFER_EMPTY)
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_MST_REC_DONE;
+                }
+                else
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_MST_REC_ABORT;
+                }
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else if (stat == I2C_LAST_BYTE)
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x58):    /* Data byte has been recieved; NOT ACK has been returned */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            if (nextStatus[i2cUnit] == TM_OK)
+            {/* counter == 0 */
+                /* read last byte in case of byte by byte transfer */
+                status = i2cTransceiveData(i2cUnit, tmhwI2cDmaMasterReceive);
+                /* i2cTransceiveData returned I2C_LAST_BYTE */
+                if (gI2cData[i2cUnit].attach == tmhwI2cRestart)
+                {
+                    /* synchronous caller event */
+                    return TMHW_ERR_I2C_EVENT_MST_REQ;
+                }
+                else
+                {/* tmhwI2cStop */
+                    /* asynchronous caller event */
+                    status = TMHW_ERR_I2C_EVENT_MST_REC_DONE;
+                    i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+                }
+            }
+            else
+            {
+                status = nextStatus[i2cUnit];
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond|slaveMonitor));
+            }
+            break;
+
+        case tmhwI2cEventProceed:
+            /* restart */
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cStartCond|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x60):    /* Own SLA.W has been rceived, ACK has been returned */
+    case (tmhwI2cEvent0x68):    /* Arbitration lost in SLA.R/W as master and own SLA.W has received, ACK returned */
+    case (tmhwI2cEvent0x70):    /* Generall call address (0x00) has been received, ACK returned */
+    case (tmhwI2cEvent0x78):    /* Arbitration lost in SLA.R/W or in Master code ... ACK returned*/
+        gI2cDirection[i2cUnit] = tmhwI2cReceive;
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* PR eh04#2776.Missing 0xc0 state.*/
+            if ( i2cLastState[i2cUnit] == 0xa8 )
+            {
+                /* Invoke Slave Transmit Done */
+                i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+                if (gI2cData[i2cUnit].counter == 0)
+                {
+                    status = TMHW_ERR_I2C_EVENT_SLV_TRX_DONE;
+                }
+                else
+                {
+                    status = TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+                }
+                i2cLastState [i2cUnit] = 0x60;
+                return status;
+            }
+            i2cLastState [i2cUnit] = 0x60;
+
+            nextStatus[i2cUnit] = TM_OK;
+            /* synchronous caller event */
+            if ((event == tmhwI2cEvent0x60) || (event == tmhwI2cEvent0x68))
+            {
+                if (event == tmhwI2cEvent0x68)
+                {
+                    return TMHW_ERR_I2C_EVENT_SLV_REC_REQ_MST_LOST;
+                }
+                else
+                {
+                    return TMHW_ERR_I2C_EVENT_SLV_REC_REQ;
+                }
+            }
+            else
+            {/* event == tmhwI2cEvent0x70 || event == tmhwI2cEvent0x78 */
+                if (event == tmhwI2cEvent0x78)
+                {
+                    return TMHW_ERR_I2C_EVENT_SLV_GC_REQ_MST_LOST;
+                }
+                else
+                {
+                    return TMHW_ERR_I2C_EVENT_SLV_GC_REQ;
+                }
+            }
+            /* break; */   /* not reachable ! */
+
+        case tmhwI2cEventProceed:
+            stat = i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveReceive);
+            if ( stat == I2C_BUFFER_EMPTY )
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_REC_DONE;
+                }
+                else
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_REC_ABORT;
+                }
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x80):    /* Previously addressed with own SLA.W; Data byte has been received ACK returned */
+    case (tmhwI2cEvent0x90):    /* Previously addressed with generall call; Data byte recieved; ACK returned */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* patch on hw ticket 68117 : Missing 0x60 state*/
+            if (i2cLastState [i2cUnit] == 0xa0)
+            {
+                 if (event == tmhwI2cEvent0x80)
+                 {
+                     return TMHW_ERR_I2C_EVENT_SLV_REC_REQ;
+                 }
+                 else
+                 {/*event = tmhwI2cEvent0x90*/
+                     return TMHW_ERR_I2C_EVENT_SLV_GC_REQ;
+                 }
+            }
+
+           if ( i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveReceive) ==
+                I2C_BUFFER_EMPTY )
+            {/* buffer empty */
+                if (gI2cData[i2cUnit].attach == tmhwI2cChain)
+                {/* counter = 0 */
+                    /* synchronous caller event */
+                    return TMHW_ERR_I2C_EVENT_SLV_REC_REQ;
+                }
+                else
+                {/* tmhwI2cStop, counter = 0, send NACK, byte has already been read
+                     asynchronous caller event */
+                    nextStatus[i2cUnit]=TMHW_ERR_I2C_EVENT_SLV_REC_DONE;
+                    /* data read, however slave needs one more state to finish */
+                    i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+                }
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cAcknowledge));
+            }
+            break;
+
+        case tmhwI2cEventProceed:
+            /* patch on hw ticket 68117*/
+            if (i2cLastState [i2cUnit] == 0xa0)
+            {
+                    i2cReceiveByte(i2cUnit);
+                    i2cLastState [i2cUnit] = 0x80;
+            }
+            /* tmhwI2cChain, buffer counter def>0 */
+            if (i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveReceive) ==
+                I2C_BUFFER_EMPTY)
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_REC_DONE;
+                }
+                else
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_REC_ABORT;
+                }
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0x88):    /* Previously addressed with own SLA.W; Data byte received, NOT ACK returned */
+    case (tmhwI2cEvent0x98):    /* Previously addressed with generall call; Data byte recieved; NOT ACK returned */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            if (i2cLastState [i2cUnit] == 0xa0)
+            {
+                i2cLastState [i2cUnit] = 0x88;
+                status = TM_OK;
+            }
+            else
+            {
+                /* all data has already been received.
+                * master has sent one byte too much.
+                */
+                status = TMHW_ERR_I2C_EVENT_SLV_REC_ABORT;
+            }
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0xa0):    /* A STOP condition or repeated START condition has been received ... */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* patch on hw ticket 68117*/
+            if ( (i2cLastState [i2cUnit] == 0xa0) && (gI2cDirection[i2cUnit] == tmhwI2cReceive))
+            { /* zero byte transfer workaround
+                 Missing 0x60 state*/
+                i2cLastState [i2cUnit] = 0xa1;
+                return TMHW_ERR_I2C_EVENT_SLV_REC_REQ;
+            }
+
+            i2cLastState [i2cUnit] = 0xa0;
+
+            status = nextStatus[i2cUnit];
+            if (gI2cDirection[i2cUnit] == tmhwI2cReceive)
+            {
+                if ((gI2cData[i2cUnit].counter == 0) && (status == TM_OK))
+                {
+                    status = TMHW_ERR_I2C_EVENT_SLV_REC_DONE;
+                }
+                else
+                {
+                    if (status == TM_OK)
+                    {
+                        status = TMHW_ERR_I2C_EVENT_SLV_REC_ABORT;
+                    }
+                }
+            }
+            else
+            {   /* transmit */
+                if ((gI2cData[i2cUnit].counter == 0) && (status == TM_OK))
+                {
+                    status = TMHW_ERR_I2C_EVENT_SLV_TRX_DONE;
+                }
+                else
+                {
+                    if (gI2cByteWise[i2cUnit] == True)
+                    {/* transmit, bytewise
+                         last written byte was invalid. Correct it. */
+                        (gI2cData[i2cUnit].counter)++;
+                    }
+
+                    if (status == TM_OK)
+                    {
+                        status = TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+                    }
+                }
+            }
+            i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        case tmhwI2cEventProceed:
+            /* workaround h/w ticket 68117:
+             * return without clearing the interrupt. This will ensure
+             * a DONE event is returned to the Slave*/
+            return TM_OK;
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0xa8):    /* Own SLA.R is been received; ACK returned */
+    case (tmhwI2cEvent0xb0):    /* Arbitration lost in SLA.R/W as master and own SLA.R received, ACK sent */
+        i2cLastState [i2cUnit] = 0xa8;
+        gI2cDirection[i2cUnit] = tmhwI2cTransmit;
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            nextStatus[i2cUnit] = TM_OK;
+            if (event == tmhwI2cEvent0xb0)
+            {
+                return TMHW_ERR_I2C_EVENT_SLV_TRX_REQ_MST_LOST;
+            }
+
+            /* synchronous caller event */
+            return TMHW_ERR_I2C_EVENT_SLV_TRX_REQ;
+
+        case tmhwI2cEventProceed:
+            /* tmhwI2cChain */
+            if (gI2cData[i2cUnit].counter == 0)
+            {
+                nextStatus[i2cUnit] =  TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+                i2cWriteDat(i2cUnit, TMHW_I2C_DATA_DUMMY);
+                i2cControl(i2cUnit, (tmhwI2cControl_t)tmhwI2cEnable);
+            }
+            else
+            {/* counter > 0 */
+                (Void) i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveTransmit);
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0xb8):    /* Data byte in I2CDAT has been transmitted; ACK sent */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+                        i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+            if ( i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveTransmit) ==
+                I2C_BUFFER_EMPTY )
+            {/* buffer empty, counter = 0 */
+                if (gI2cData[i2cUnit].attach == tmhwI2cChain)
+                {
+                    /* synchronous caller event */
+                    return TMHW_ERR_I2C_EVENT_SLV_TRX_REQ;
+                }
+                else
+                {/* tmhwI2cStop */
+                    /*  asynchronous caller event */
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_TRX_DONE;
+                    /* indicate that when next state is tmhwI2cEvent0xa0,
+                     * all data have already been sent
+                     */
+
+                    /* Send dummy */
+                    i2cWriteDat(i2cUnit, TMHW_I2C_DATA_DUMMY);
+                    i2cControl(i2cUnit, tmhwI2cEnable);
+                }
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cAcknowledge));
+            }
+            break;
+
+        case tmhwI2cEventProceed:
+            /* tmhwI2cChain */
+            if (i2cTransceiveData(i2cUnit, tmhwI2cDmaSlaveTransmit) ==
+                I2C_BUFFER_EMPTY)
+            {
+                if (gI2cData[i2cUnit].length == 0)
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_TRX_DONE;
+                }
+                else
+                {
+                    nextStatus[i2cUnit] = TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+                }
+                i2cControl(i2cUnit, tmhwI2cEnable);
+            }
+            else
+            {
+                i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable | tmhwI2cAcknowledge));
+            }
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0xc0):    /* Data bytes in I2CDAT transmitted, NOT ACK is received */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* PR eh04#2776.Missing 0xc0 state. Missing 0xC0 state in SlvTrx*/
+            if ( (i2cLastState [i2cUnit] == 0xc0) )
+            { /* zero byte transfer workaround
+                 Missing 0xa8 state*/
+                i2cLastState [i2cUnit] = 0xc1;
+                return TMHW_ERR_I2C_EVENT_SLV_TRX_REQ;
+            }
+
+            i2cLastState [i2cUnit] = 0xc0;
+
+            i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+            if (gI2cData[i2cUnit].counter == 0)
+            {
+                status = TMHW_ERR_I2C_EVENT_SLV_TRX_DONE;
+            }
+            else
+            {
+                status = TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+            }
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+        break;
+
+    case (tmhwI2cEvent0xc8):    /* Last data byte in I2CDAT has sent ACK received ... */
+        switch (request)
+        {
+        case tmhwI2cEventInterrupt:
+            /* slave has sent dummy while master requires more data
+                error in master, nack had been expected after last byte */
+            status = TMHW_ERR_I2C_EVENT_SLV_TRX_ABORT;
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable|slaveMonitor));
+            break;
+
+        default:
+            break;
+        }
+    default:
+        break;
+    }
+
+    (Void) tmhwI2cIntClear(i2cUnit);
+    return status;
+} /* tmhwI2cEvent */
+
+
+/* ---------------------------------------------------------------------------
+ * Internal functions for Driver initialization
+ * ---------------------------------------------------------------------------
+ */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cDriverInit:
+ *
+ * DESCRIPTION: Initializes the I2c HwAPI driver.
+ *
+ * RETURN:      -
+ *
+ * PRE:         state = not initialised
+ *
+ * POST:        initialised
+ *
+ * NOTES:       must be called immediately after the first call to a
+ *              HwApi function
+ *              Re-entrant.
+ * ---------------------------------------------------------------------------
+*/
+static Void
+i2cDriverInit(Void)
+{
+    ptmhwI2c_Cfg_t      pCfg = Null;
+    UInt32              unit = 0;
+    ptmhwI2c_Cfg_t      gpI2c_Cfg = Null;
+    UInt32              I2c_CfgNumUnits = 0;
+
+#ifndef TMHWI2C_BSL_INDEPENDANT
+    (Void) tmbslCoreGetTicksPerSec(&gTimeTicks20us);
+    gTimeTicks20us /= 50000; /* For 0105 STOP HW issue check */
+#endif
+
+    gpI2c_Cfg = tmhwI2c_CfgGet();   /*  retrieve configuration structure */
+    I2c_CfgNumUnits = tmhwI2c_CfgGetNumUnits();
+    gI2cUnitCount = (tmUnitSelect_t)I2c_CfgNumUnits;
+                                                                 /* throughout the code. */
+    while (unit < I2c_CfgNumUnits)
+    {
+        pCfg = &gpI2c_Cfg[unit];
+
+        if(pCfg->moduleID == I2C_IP3203_HWMODULE_ID)
+        {
+            gI2cModule[unit].I2cType = I2cIP3203;
+            /* configure unit */
+            tmhwI2cCfgInit( (tmUnitSelect_t)unit, &(gI2cCfg[unit]) );
+
+            if (
+#ifndef LINUX_BUILD
+                (gI2cRegisterMmFunc[unit].gpVirtToPhys == Null) ||
+                (gI2cRegisterMmFunc[unit].gpCacheFlush == Null) ||
+                (gI2cRegisterMmFunc[unit].gpCacheInvalidate == Null) ||
+#endif
+                (gI2cRegisterMmFunc[unit].length <= 1) ||
+                (gI2cRegisterMmFunc[unit].bufferPtr == Null))
+            {
+                gI2cCfg[unit].bDma = False;
+            }
+       }
+       else if(pCfg->moduleID == IIC_IP0105_HWMODULE_ID)
+       {
+           gI2cModule[unit].I2cType = I2cIP0105;
+           /* configure unit */
+            tmhwI2cCfgInit( (tmUnitSelect_t)unit, &(gI2cCfg[unit]) );
+            gI2cCfg[unit].bDma = False;
+       }
+       else
+       {
+           /* Only 2 IP numbers we support now */
+       }
+       gI2cModule[unit].pRegBase = pCfg->baseAddress;
+       unit++;
+    }
+
+} /* i2cDriverInit */
+
+
+/* ---------------------------------------------------------------------------
+ * Internal functions for ISR layer:
+ * ---------------------------------------------------------------------------
+ */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cConvertSpeedToReg:
+ *
+ * DESCRIPTION: This function derives the peripheral register values, given
+ *              the requested actual speed at which the specific master will
+ *              communicate when it controls the I2C-bus.
+ *              For the 0105 return the value to be written in ctrl_cr[2:0] in
+ *              *pFSBIR is returned.
+ *
+ * RETURN:      SFMode
+ *
+ * PRE:         -
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cConvertSpeedToReg (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  fsSpeed,
+    UInt32                  hsSpeed,
+    pUInt32                 pFSBIR,
+    pUInt32                 pHSBIR
+    )
+{
+    UInt32 fsBitRate, hsBitRate, fsbir = 0, hsbir = 0;
+    UInt32 uiClockFreqKHz;
+    UInt32 divfact, divider=0;
+
+
+    /* limit upper boundary of frequency range
+           SS/FS */
+    if (fsSpeed > TMHW_I2C_MAX_FS_SPEED)
+    {
+        fsSpeed=TMHW_I2C_MAX_FS_SPEED;
+    }
+
+    if (fsSpeed > gI2cCfg[i2cUnit].maxFSSpeedKhz)
+    {
+        fsSpeed = gI2cCfg[i2cUnit].maxFSSpeedKhz;
+    }
+
+    uiClockFreqKHz = gI2cCfg[i2cUnit].clockFreqKHz;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        /* HS */
+        if (hsSpeed > TMHW_I2C_MAX_HS_SPEED)
+        {
+            hsSpeed = TMHW_I2C_MAX_HS_SPEED;
+        }
+
+        if (hsSpeed > gI2cCfg[i2cUnit].maxHsSpeedKhz)
+        {
+            hsSpeed = gI2cCfg[i2cUnit].maxHsSpeedKhz;
+        }
+
+        /* prevent devide by zero. */
+        if (fsSpeed == 0)
+        {
+            fsSpeed = 1;
+        }/* this will not influence the result of the total calculation */
+
+        if (hsSpeed == 0)
+        {
+            hsSpeed = 1;
+        }/* this will not influence the result of the total calculation */
+
+        /* calculate register values */
+        fsBitRate = (uiClockFreqKHz/(8*fsSpeed)) - 1;
+        if ((uiClockFreqKHz%(8*fsSpeed)) != 0)
+        {
+            fsBitRate++;
+        }
+
+        hsBitRate = (uiClockFreqKHz/(3*hsSpeed)) - 1;
+        if ((uiClockFreqKHz%(3*hsSpeed)) != 0)
+        {
+            hsBitRate++;
+        }
+
+        /* limit upper boundary of register value = lower limit of speed */
+        if (fsBitRate > 127)
+        {
+            fsBitRate = 127;
+        }
+
+        if (hsBitRate > 31)
+        {
+            hsBitRate = 31;
+        }
+
+        fsbir = ((fsBitRate << TMVH_I2C3203_FSBIR_BITRATE_POS) & TMVH_I2C3203_FSBIR_BITRATE_MSK);
+        hsbir = ((hsBitRate << TMVH_I2C3203_HSBIR_BITRATE_POS) & TMVH_I2C3203_HSBIR_BITRATE_MSK);
+
+
+        if (fsSpeed > TMHW_I2C_MAX_SS_SPEED)
+        {/* SFMode = FS mode */
+            /* i2cFSBIR.bits.SFMode = I2C_FS_MODE; */
+            fsbir &= ~TMVH_I2C3203_FSBIR_MODE_MSK;
+            fsbir |= ((I2C_FS_MODE << TMVH_I2C3203_FSBIR_MODE_POS) & TMVH_I2C3203_FSBIR_MODE_MSK);
+        }
+        else
+        {/* SFMode = SS mode */
+            /* i2cFSBIR.bits.SFMode = I2C_SS_MODE; */
+            fsbir &= ~TMVH_I2C3203_FSBIR_MODE_MSK;
+            fsbir |= ((I2C_SS_MODE << TMVH_I2C3203_FSBIR_MODE_POS) & TMVH_I2C3203_FSBIR_MODE_MSK);
+        }
+
+        #ifndef MINUS_SPEED_PATCH
+            /* IP3203 version 2.c and 2.d patch */
+            switch (fsbir)
+            {
+            case (0x00):
+                fsbir++;
+                break;
+            case (0x02):
+                fsbir = 0x04;
+                break;
+            case (0x03):
+                fsbir++;
+                break;
+            case (0x08):
+                fsbir =0xa;
+                break;
+            case (0x09):
+                fsbir++;
+                break;
+            case (0x0b):
+                fsbir++;
+                break;
+            case (0x0e):
+                fsbir++;
+                break;
+            case (0x28):
+                fsbir++;
+                break;
+            case (0x4f):
+                fsbir++;
+                break;
+            case (0x80):
+                fsbir++;
+                break;
+            case (0x83):
+                fsbir = 0x85;
+                break;
+            case (0x84):
+                fsbir++;
+                break;
+            case (0x87):
+                fsbir = 0x8a;
+                break;
+            case (0x88):
+                fsbir = 0x8a;
+                break;
+            case (0x89):
+                fsbir++;
+                break;
+            default:
+                if (fsbir >= 0xaa)
+                {
+                    fsbir = 0xa9;
+                }
+            break;
+            }
+
+            switch (hsbir)
+            {
+            case (0x00):
+                hsbir++;
+                break;
+            case (0x0c):
+                hsbir++;
+                break;
+            default:
+                break;
+            }
+            /* end IP3203 version 2.c and 2.d patch */
+    #endif /* if MINUS_SPEED_PATCH */
+
+        *pFSBIR = fsbir;
+        *pHSBIR = hsbir;
+    }
+    else /* for the 0105 return the value to be written in ctrl_cr[2:0] */
+    {
+        divfact = uiClockFreqKHz/fsSpeed;
+        for (divider = 0; (divfact > gDivFact0105[divider]) && (divider < 7); divider++)
+        {
+        }
+        *pFSBIR=divider;
+        *pHSBIR = 0;
+    }
+} /* i2cConvertSpeedToReg */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cConvertSpeedToActual:
+ *
+ * DESCRIPTION: This function derives the actual speed at which the specific
+ *              master will communicate when it controls the I2C-bus, given
+ *              the peripheral register values.
+ *              In case of the 0105 FSBIR should contain the 3 bitvalue to be
+ *              written to  ctrl_cr[2:0].
+ *
+ * RETURN:      -
+ *
+ * PRE:         -
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cConvertSpeedToActual (
+    tmUnitSelect_t          i2cUnit,
+    UInt32                  FSBIR,
+    UInt32                  HSBIR,
+    pUInt32                 pFsSpeed,
+    pUInt32                 pHsSpeed
+    )
+{
+    UInt32 uiClockFreqKHz, fsBitRate, hsBitRate;
+
+    uiClockFreqKHz = gI2cCfg[i2cUnit].clockFreqKHz;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        fsBitRate = ((FSBIR & TMVH_I2C3203_FSBIR_BITRATE_MSK) >> TMVH_I2C3203_FSBIR_BITRATE_POS);
+        hsBitRate = ((HSBIR & TMVH_I2C3203_HSBIR_BITRATE_MSK) >> TMVH_I2C3203_HSBIR_BITRATE_POS);
+
+        *pFsSpeed = uiClockFreqKHz / (8 * (fsBitRate + 1) );
+        if ( ( uiClockFreqKHz%(8*(fsBitRate+1)) ) != 0 )
+        {
+            (*pFsSpeed)++;
+        }
+
+        *pHsSpeed = uiClockFreqKHz / (3 * (hsBitRate + 1) );
+        if ( ( uiClockFreqKHz%(3*(hsBitRate+1)) ) != 0)
+        {
+            (*pHsSpeed)++;
+        }
+
+        if (gI2cCfg[i2cUnit].bHS == False)
+        {/* indicate not to use HS */
+            *pHsSpeed = 0;
+        }
+    }
+    else
+    {
+        *pFsSpeed = uiClockFreqKHz / gDivFact0105[FSBIR];
+        *pHsSpeed = 0;
+    }
+} /* i2cConvertSpeedToActual */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cIP0105SetSpeed:
+ *
+ * DESCRIPTION: This function sets the speed of a 0105 module and should only
+ *              be called from the initialisation function.
+ *              The 0105 requires the module to be stopped before any
+ *              adjustment to the speed can be done.
+ *              The speed is set to the value according to tmhwI2cCfg.c.
+ *
+ * RETURN:      -
+ *
+ * PRE:         -
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cIP0105SetSpeed (
+    tmUnitSelect_t i2cUnit
+    )
+{
+    UInt32 speed, dummy;
+    UInt32 reg_value;
+
+    i2cConvertSpeedToReg ( i2cUnit,
+                            gI2cCfg[i2cUnit].maxFSSpeedKhz,
+                            0,
+                            &speed,
+                            &dummy );
+    I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_STOP_OFFSET, 1);
+
+    I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+    reg_value &= ~TMVH_IIC0105_I2CCONTROL_CR2_MSK;
+    reg_value |= ( (speed << TMVH_IIC0105_I2CCONTROL_CR2_POS) & TMVH_IIC0105_I2CCONTROL_CR2_MSK);
+    I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+} /* i2cIP0105SetSpeed */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:        i2cControl:
+ *
+ * DESCRIPTION:     The control bits that are set to 1 (all or'ed control bits) will
+ *                  be set. All other control bits will be reset.
+ *                  For the 0105 the clockrate is unaffected.
+ *
+ * RETURN:          -
+ *
+ * PRE:             state != idle
+ *
+ * POST:            state change possible
+ *
+ * NOTES:           re-entrant
+ * -------------------------------------------------------------------------------
+ */
+#ifdef LINUX_BUILD
+Void
+#else
+static Void
+#endif
+i2cControl (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cControl_t    control
+    )
+{
+#ifndef TMHWI2C_BSL_INDEPENDANT
+    static UInt32 gTimeStopIssue;
+    UInt32 wait20us;
+#endif
+    UInt32 reg_value, temp;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CCON_OFFSET, (control & 0xf4));
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+
+        temp = (UInt32)((control & TMVH_I2C3203_I2CCON_START_MSK) >> TMVH_I2C3203_I2CCON_START_POS);
+        reg_value &= ~TMVH_IIC0105_I2CCONTROL_START_MSK;
+        reg_value |= ((temp << TMVH_IIC0105_I2CCONTROL_START_POS) & TMVH_IIC0105_I2CCONTROL_START_MSK);
+
+        if(reg_value & TMVH_IIC0105_I2CCONTROL_START_MSK)  /* Start cycle bit field set ? */
+        { /* look if STOP was at least 20 us ago */
+#ifndef TMHWI2C_BSL_INDEPENDANT
+            do
+            {
+                (Void) tmbslCoreGetTickCount(&wait20us);
+            }
+            while ((wait20us - gTimeStopIssue) < gTimeTicks20us);
+#endif
+        }
+        temp = (UInt32)((control & TMVH_I2C3203_I2CCON_EN_I2C_MSK) >> TMVH_I2C3203_I2CCON_EN_I2C_POS);
+        reg_value &= ~TMVH_IIC0105_I2CCONTROL_EN_I2C_MSK;
+        reg_value |= ((temp << TMVH_IIC0105_I2CCONTROL_EN_I2C_POS) & TMVH_IIC0105_I2CCONTROL_EN_I2C_MSK);
+
+        temp = (UInt32)(((UInt32)control & TMVH_I2C3203_I2CCON_AA_MSK) >> TMVH_I2C3203_I2CCON_AA_POS);
+        reg_value &= ~TMVH_IIC0105_I2CCONTROL_AA_MSK;
+        reg_value |= ((temp << TMVH_IIC0105_I2CCONTROL_AA_POS) & TMVH_IIC0105_I2CCONTROL_AA_MSK);
+
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CCONTROL_OFFSET, reg_value);
+
+        if ( ((control & TMVH_I2C3203_I2CCON_SETSTOP_MSK) >> TMVH_I2C3203_I2CCON_SETSTOP_POS)
+              == 1)
+        {
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2C_STOP_OFFSET, 1);
+#ifndef TMHWI2C_BSL_INDEPENDANT
+            (Void) tmbslCoreGetTickCount(&gTimeStopIssue);
+#endif
+        }
+    }
+} /* i2cIP3203Control */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cSetDmaControl:
+ *
+ * DESCRIPTION: Sets the specified DMA control bits.
+ *
+ * RETURN:      -
+ *
+ * PRE:
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cSetDmaControl (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cDmaControl_t     dmaControl
+    )
+{
+    if (gI2cModule[i2cUnit].I2cType != I2cIP0105)
+    {
+        if (dmaControl == tmhwI2cDmaNone)
+        {
+            gI2cDma[i2cUnit] = False;
+        }
+        else
+        {
+            gI2cDma[i2cUnit] = True;
+        }
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_CONTROL_OFFSET, dmaControl);
+    }
+} /* i2cSetDmaControl */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cGetStatus:
+ *
+ * DESCRIPTION: Gets the current I2c module interrupt state.
+ *
+ * RETURN:      TMHW_ERR_I2C_BUSY, TM_OK
+ *
+ * PRE:      state != idle
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cGetStatus (
+    tmUnitSelect_t  i2cUnit,
+    ptmhwI2cEvent_t pI2cEvent
+    )
+{
+    UInt32 reg_value, iicstatus;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INT_STATUS_OFFSET, reg_value);
+
+        if ( ((reg_value & TMVH_I2C3203_INT_STATUS_STA0_MSK) >> TMVH_I2C3203_INT_STATUS_STA0_POS)
+              == True)
+        {
+            *pI2cEvent = (tmhwI2cEvent_t)
+                         ((reg_value & TMVH_I2C3203_INT_STATUS_CODE_MSK) >> TMVH_I2C3203_INT_STATUS_CODE_POS);
+        }
+        else
+        {
+            *pI2cEvent = tmhwI2cEvent0xf8;
+        }
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_INT_STATUS_OFFSET, reg_value);
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CSTATUS_OFFSET, iicstatus);
+
+        if ( ((reg_value & TMVH_IIC0105_INT_STATUS_STA_MSK) >> TMVH_IIC0105_INT_STATUS_STA_POS)
+              == True)
+        {
+            *pI2cEvent = (tmhwI2cEvent_t)
+            ((iicstatus & TMVH_IIC0105_I2CSTATUS_STATUS_CODE_MSK) >>TMVH_IIC0105_I2CSTATUS_STATUS_CODE_POS);
+        }
+        else
+        {
+            *pI2cEvent = tmhwI2cEvent0xf8;
+        }
+    }
+} /* i2cGetStatus */
+
+
+/* DMA */
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cPrepareDma:
+ *
+ * DESCRIPTION: Starts data communication using DMA
+ *              Checks whether to include the last byte.
+ *              If buffer is empty or one byte left while last byte needs
+ *              not be included, returns I2C_BUFFER_EMPTY.
+ *              I2cDMA_CONTROL is loaded.
+ *              I2cI2CON register is ->not<- loaded.
+ *
+ * RETURN:      an indication whether DMA is started successfully, is of no
+ *              interrest. No further action is needed anyhow.
+ *              When this function is used, no byte-wise action is needed.
+ *              Otherwise the function i2cTransceiveData() should be used
+ *
+ * PRE:         buffer != empty
+ *
+ * POST:        a block of data is retreived from buffer
+ *              DMA is initialised
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cPrepareDma (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cDmaControl_t dmaControl
+    )
+{
+    Bool        bIncludeLastByte;
+    pUInt8      pAddressLocal;
+#ifndef LINUX_BUILD
+    pUInt8      pPhysical;
+#endif
+    pUInt8      pDmaBuffer;
+    UInt32      i, uiCounter;
+
+
+    if (gI2cModule[i2cUnit].I2cType != I2cIP0105)
+    {
+
+        bIncludeLastByte = (i2cIncludeLastByte(i2cUnit, dmaControl))
+            && ((Bool)(gI2cData[i2cUnit].counter > 0));
+
+        if (!bIncludeLastByte)
+        {/* act as if the buffer is one byte shorter */
+            gI2cData[i2cUnit].length--;
+            gI2cData[i2cUnit].counter--;
+        }
+
+        if ( (gI2cCfg[i2cUnit].bDma == True) &&
+            (gI2cData[i2cUnit].counter > 0) )
+        {/* DMA, counter > 0 */
+            uiCounter = gI2cData[i2cUnit].counter;
+            if(uiCounter > gI2cRegisterMmFunc[i2cUnit].length  )
+            {/* limit number of bytes to buffer size */
+                uiCounter = gI2cRegisterMmFunc[i2cUnit].length;
+            }
+
+            if ( (dmaControl == tmhwI2cDmaMasterTransmit) ||
+                (dmaControl == tmhwI2cDmaSlaveTransmit) )
+            {
+                pDmaBuffer = gI2cRegisterMmFunc[i2cUnit].bufferPtr;
+                pAddressLocal = gI2cData[i2cUnit].pAddress +
+                    (gI2cData[i2cUnit].length -
+                        gI2cData[i2cUnit].counter);
+                for(i = 0; i < uiCounter; i++)
+                {
+                    *pDmaBuffer = *pAddressLocal;
+                    pDmaBuffer++;
+                    pAddressLocal++;
+                }
+            }
+
+#ifndef LINUX_BUILD
+
+            gI2cRegisterMmFunc[i2cUnit].gpVirtToPhys((gI2cRegisterMmFunc[i2cUnit].bufferPtr), (pVoid *)(&pPhysical));
+#ifdef I2C_DMA_WORD_ALINED
+            if ((UInt32) pPhysical % 4 == 0)
+            {/* word alined only */
+#endif /* I2C_DMA_WORD_ALINED */
+                I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_ADDR_OFFSET, (UInt32) pPhysical);
+
+                I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_LEN_OFFSET, (UInt32) uiCounter);
+
+                gI2cData[i2cUnit].counter = gI2cData[i2cUnit].counter - uiCounter;
+                i2cSetDmaControl(i2cUnit, dmaControl);
+
+                if ( (dmaControl == tmhwI2cDmaMasterTransmit) ||
+                    (dmaControl == tmhwI2cDmaSlaveTransmit ))
+                {
+                    /* flush memory before DMA */
+                    gI2cRegisterMmFunc[i2cUnit].gpCacheFlush(gI2cRegisterMmFunc[i2cUnit].bufferPtr, uiCounter);
+                }
+#ifdef I2C_DMA_WORD_ALINED
+            }/* word alined only */
+#endif /* I2C_DMA_WORD_ALINED */
+
+#else /* LINUX_BUILD */
+
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_ADDR_OFFSET,
+                    (UInt32)( gI2cRegisterMmFunc[ i2cUnit ].phyAddr));
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_LEN_OFFSET,
+                    (UInt32) uiCounter);
+            gI2cData[i2cUnit].counter = gI2cData[i2cUnit].counter - uiCounter;
+            i2cSetDmaControl(i2cUnit, dmaControl);
+
+#endif /* LINUX_BUILD */
+        }
+
+        if (!bIncludeLastByte)
+        {/* actually, the buffer is one byte longer */
+            (gI2cData[i2cUnit].length)++;
+            (gI2cData[i2cUnit].counter)++;
+        }
+    }   /* if(gI2cModule[i2cUnit].I2cType != I2cIP0105 */
+} /* i2cPrepareDma */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cCheckDma:
+ *
+ * DESCRIPTION: Check's if DMA transfer was successfull and if not, corrects
+ *              the value gI2cData[i2cUnit].counter
+ *
+ * RETURN:      TM_OK if transaction was successfull
+ *
+ * PRE:
+ *
+ * POST:
+ *
+ * NOTES:       re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static tmErrorCode_t
+i2cCheckDma (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cRequest_t    request
+    )
+{
+    tmErrorCode_t       status = TM_OK;
+    pUInt8              pDmaBuffer, pAddressLocal;
+    UInt32              i;
+
+    /* accelerator: indirection pass */
+    UInt32          dmaCounter, dmaLength, dmaControl;
+
+    if (request == tmhwI2cEventInterrupt)
+    {
+        if (gI2cDma[i2cUnit] == True)
+        {
+            status = TM_OK;
+            gI2cByteWise[i2cUnit] = False;
+
+            /* flush memory after DMA */
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_COUNTER_OFFSET, dmaCounter);
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_CONTROL_OFFSET, dmaControl);
+
+            if ((dmaControl == tmhwI2cDmaMasterReceive) ||
+                (dmaControl == tmhwI2cDmaSlaveReceive))
+            {
+
+                pDmaBuffer = gI2cRegisterMmFunc[i2cUnit].bufferPtr;
+                I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_LEN_OFFSET, dmaLength);
+
+
+                pAddressLocal  = ((gI2cData[i2cUnit].pAddress +
+                            gI2cData[i2cUnit].length) -
+                            gI2cData[i2cUnit].counter) -
+                            dmaLength;
+#ifndef LINUX_BUILD
+                gI2cRegisterMmFunc[i2cUnit].gpCacheInvalidate (pDmaBuffer, dmaLength - dmaCounter);
+#endif
+                for(i=0; i < (dmaLength - dmaCounter); i++)
+                {
+                    *pAddressLocal = *pDmaBuffer;
+                    pAddressLocal++;
+                    pDmaBuffer++;
+                }
+
+            }
+
+            /* correct gI2cData[i2cUnit].counter value */
+            if (dmaCounter != 0)
+            {
+                gI2cData[i2cUnit].counter += dmaCounter;
+                status = I2C_DMA_NOT_SUCCESSFUL;
+
+        /* switch off DMA mode */
+        i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+           }
+        }
+        else
+        {/* gI2cDma[i2cUnit] = False */
+            gI2cByteWise[i2cUnit] = True;
+        }
+    }
+    else
+    {/* request != tmhwI2cEventInterrupt */
+        gI2cByteWise[i2cUnit] = False;
+    }
+
+    /* switch off DMA mode */
+    if ( gI2cData[i2cUnit].counter == 0 )
+    {
+        i2cSetDmaControl(i2cUnit, tmhwI2cDmaNone);
+    }
+
+    return status;
+} /* i2cCheckDma */
+
+
+/* byte transfer */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:        i2cWriteDat:
+ *
+ * DESCRIPTION:     Loads the value dat into the data register
+ *
+ * RETURN:          -
+ *
+ * NOTES:           Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cWriteDat (
+    tmUnitSelect_t          i2cUnit,
+    UInt8                   dat
+    )
+{
+    UInt32 reg_value;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CDAT_OFFSET, reg_value);
+        reg_value &= ~TMVH_I2C3203_I2CDAT_DATA_MSK;
+        reg_value |= (UInt32)((dat << TMVH_I2C3203_I2CDAT_DATA_POS) & TMVH_I2C3203_I2CDAT_DATA_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CDAT_OFFSET, reg_value);
+    }
+    else
+    {
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CDAT_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2CDAT_DATA_MSK;
+        reg_value |= (UInt32)((dat << TMVH_IIC0105_I2CDAT_DATA_POS) & TMVH_IIC0105_I2CDAT_DATA_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CDAT_OFFSET, reg_value);
+    }
+} /* i2cWriteDat */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cTransmitByte:
+ *
+ * DESCRIPTION: Retreives a byte from buffer and loads it into the data
+ *              register
+ *
+ * RETURN:      -
+ *
+ * PRE:         gI2cData[i2cUnit].counter>0
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cTransmitByte (
+    tmUnitSelect_t  i2cUnit
+    )
+{
+      UInt32 reg_value, dat;
+
+    if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+    {
+        dat = *( gI2cData[i2cUnit].pAddress +
+               (gI2cData[i2cUnit].length - gI2cData[i2cUnit].counter) );
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CDAT_OFFSET, reg_value);
+        reg_value &= ~TMVH_I2C3203_I2CDAT_DATA_MSK;
+        reg_value |= ((dat << TMVH_I2C3203_I2CDAT_DATA_POS) & TMVH_I2C3203_I2CDAT_DATA_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CDAT_OFFSET, reg_value);
+    }
+    else
+    {
+        dat = *( gI2cData[i2cUnit].pAddress +
+               (gI2cData[i2cUnit].length - gI2cData[i2cUnit].counter) );
+        I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CDAT_OFFSET, reg_value);
+        reg_value &= ~TMVH_IIC0105_I2CDAT_DATA_MSK;
+        reg_value |= ((dat << TMVH_IIC0105_I2CDAT_DATA_POS) & TMVH_IIC0105_I2CDAT_DATA_MSK);
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CDAT_OFFSET, reg_value);
+    }
+
+#ifdef I2C_PRINTK
+    printk("\twrite: \t\t0x%x\n", *( gI2cData[i2cUnit].pAddress +
+        (gI2cData[i2cUnit].length - gI2cData[i2cUnit].counter) ));
+#endif /* I2C_PRINTK */
+
+    gI2cData[i2cUnit].counter--;
+} /* i2cTransmitByte */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cReceiveByte:
+ *
+ * DESCRIPTION: retreives a byte from the data register and stores it into
+ *              the data buffer
+ *
+ * RETURN:      -
+ *
+ * PRE:         gI2cData[i2cUnit].counter>0
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cReceiveByte (
+    tmUnitSelect_t      i2cUnit
+    )
+{
+    UInt32 reg_value;
+    if (gI2cData[i2cUnit].counter > 0)
+    {
+
+        if (gI2cModule[i2cUnit].I2cType == I2cIP3203)
+        {
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_I2CDAT_OFFSET, reg_value);
+            reg_value = ((reg_value & TMVH_I2C3203_I2CDAT_DATA_MSK) >> TMVH_I2C3203_I2CDAT_DATA_POS);
+            *( gI2cData[i2cUnit].pAddress + (gI2cData[i2cUnit].length -
+               gI2cData[i2cUnit].counter) ) = (UInt8)reg_value;
+        }
+        else
+        {
+            I2C_READ( gI2cModule[i2cUnit].pRegBase + TMVH_IIC0105_I2CDAT_OFFSET, reg_value);
+            reg_value = ((reg_value & TMVH_IIC0105_I2CDAT_DATA_MSK) >> TMVH_IIC0105_I2CDAT_DATA_POS);
+            *( gI2cData[i2cUnit].pAddress + (gI2cData[i2cUnit].length -
+               gI2cData[i2cUnit].counter) ) = (UInt8)reg_value;
+        }
+
+    #ifdef I2C_PRINTK
+        printk("\tread: \t0x%x\n", *( gI2cData[i2cUnit].pAddress +
+            (gI2cData[i2cUnit].length - gI2cData[i2cUnit].counter) ));
+    #endif /* I2C_PRINTK */
+
+        gI2cData[i2cUnit].counter--;
+    }
+} /* i2cReceiveByte */
+
+
+/* Block transfer */
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cTransceiveData:
+ *
+ * DESCRIPTION: starts data communication, transmit or receive. Automatically
+ *              chooses between DMA or byte-wise,
+ *              checks whether to include the last byte,
+ *              if buffer is empty or one byte is left while last byte need
+ *              not be included, returns I2C_IP3203_BUFFER_EMPTY,
+ *              if one byte is left while last byte need not be included,
+ *              retreives last byte to or from data register
+ *              I2cDMA_CONTROL is loaded,
+ *              I2cI2CON register is ->not<- loaded.
+ *
+ * RETURN:      I2C_IP3203_BUFFER_EMPTY, TM_OK
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static tmErrorCode_t
+i2cTransceiveData (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cDmaControl_t dmaControl
+    )
+{
+
+    Bool            bIncludeLastByte;
+    pUInt8          pAddressLocal;
+#ifndef LINUX_BUILD
+    pUInt8          pPhysical;
+#endif
+    pUInt8          pDmaBuffer;
+    UInt32          i, uiCounter;
+
+    if ( ((gI2cByteWise[i2cUnit] == True) &&
+         ((dmaControl == tmhwI2cDmaMasterReceive) ||
+          (dmaControl == tmhwI2cDmaSlaveReceive)) )&&
+         (gI2cData[i2cUnit].length != 0) )
+    {
+        i2cReceiveByte(i2cUnit);
+    }
+
+    if (gI2cData[i2cUnit].counter == 0)
+    {
+        return I2C_BUFFER_EMPTY;
+    }
+
+    bIncludeLastByte = (Bool)((i2cIncludeLastByte(i2cUnit, dmaControl)) &&
+        (gI2cData[i2cUnit].counter > 0));
+    if (!bIncludeLastByte)
+    {
+        gI2cData[i2cUnit].length--;
+        gI2cData[i2cUnit].counter--;
+    }
+
+    if (gI2cData[i2cUnit].counter == 0)
+    {/* one byte left - return MasterReceive: return Nack */
+        (gI2cData[i2cUnit].length)++;
+        (gI2cData[i2cUnit].counter)++;
+        return I2C_LAST_BYTE;
+    }
+    if (( (dmaControl == tmhwI2cDmaMasterTransmit) && (gI2cDma[i2cUnit] == False) ) ||
+         (dmaControl == tmhwI2cDmaSlaveTransmit) )
+    {
+        i2cTransmitByte(i2cUnit);
+    }
+
+    if ( (gI2cCfg[i2cUnit].bDma == True) &&
+         (gI2cData[i2cUnit].counter > 0) )
+    {/* DMA, counter > 0 */
+        uiCounter = gI2cData[i2cUnit].counter;
+        if(uiCounter > gI2cRegisterMmFunc[i2cUnit].length  )
+        {/* limit number of bytes to buffer size */
+            uiCounter = gI2cRegisterMmFunc[i2cUnit].length;
+        }
+
+        if ( (dmaControl == tmhwI2cDmaMasterTransmit) ||
+             (dmaControl == tmhwI2cDmaSlaveTransmit) )
+        {
+            pDmaBuffer = gI2cRegisterMmFunc[i2cUnit].bufferPtr;
+            pAddressLocal = gI2cData[i2cUnit].pAddress +
+                   (gI2cData[i2cUnit].length -
+                    gI2cData[i2cUnit].counter);
+            for(i=0; i< uiCounter; i++)
+            {
+                *pDmaBuffer = *pAddressLocal;
+                pDmaBuffer++;
+                pAddressLocal++;
+            }
+        }
+
+#ifndef LINUX_BUILD
+
+        gI2cRegisterMmFunc[i2cUnit].gpVirtToPhys(gI2cRegisterMmFunc[i2cUnit].bufferPtr, (pVoid *)(&pPhysical));
+#ifdef I2C_DMA_WORD_ALINED
+        if ((UInt32) pPhysical % 4 == 0)
+        {/* word alined only */
+#endif /* I2C_DMA_WORD_ALINED */
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_ADDR_OFFSET, (UInt32) pPhysical);
+            I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_LEN_OFFSET, (UInt32) uiCounter);
+
+            gI2cData[i2cUnit].counter = gI2cData[i2cUnit].counter - uiCounter;
+            i2cSetDmaControl(i2cUnit, dmaControl);
+
+            if ( (dmaControl == tmhwI2cDmaMasterTransmit) ||
+                 (dmaControl == tmhwI2cDmaSlaveTransmit) )
+            {
+                /* flush memory before DMA */
+                gI2cRegisterMmFunc[i2cUnit].gpCacheFlush(gI2cRegisterMmFunc[i2cUnit].bufferPtr, uiCounter);
+            }
+
+#ifdef I2C_DMA_WORD_ALINED
+        }/* word alined only */
+#endif /* I2C_DMA_WORD_ALINED */
+
+#else /* LINUX_BUILD */
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_ADDR_OFFSET,
+                   (UInt32)( gI2cRegisterMmFunc[ i2cUnit ].phyAddr));
+
+        I2C_WRITE( gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_DMA_LEN_OFFSET,
+                  (UInt32) uiCounter);
+
+        gI2cData[i2cUnit].counter = gI2cData[i2cUnit].counter - uiCounter;
+        i2cSetDmaControl(i2cUnit, dmaControl);
+
+#endif /* LINUX_BUILD */
+
+    }
+
+    if (!bIncludeLastByte)
+    {/* actually, the buffer is one byte longer */
+        (gI2cData[i2cUnit].length)++;
+        (gI2cData[i2cUnit].counter)++;
+    }
+
+    return TM_OK;
+} /* i2cTransceiveData */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cSendSlaveAddress:
+ *
+ * DESCRIPTION: sends slave address + r/w
+ *              initializes DMA when possible
+ *              I2cDMA_CONTROL is loaded.
+ *              I2cI2CON register is ->not<- loaded.
+ *
+ * RETURN:      -
+ *
+ * PRE:
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void i2cSendSlaveAddress (
+    tmUnitSelect_t              i2cUnit
+    )
+{
+    /* the request has already been passed
+        the data have already been loaded into the registers
+        so, just continue! */
+    i2cWriteDat(i2cUnit, (UInt8)(gI2cData[i2cUnit].direction) |
+        (gI2cData[i2cUnit].slaveAddress << 1) );
+
+    /* prepare DMA any way. When DMA does not start here,
+        it will correct itself. */
+    if (gI2cData[i2cUnit].counter > 0)
+    {
+        if (gI2cData[i2cUnit].direction == tmhwI2cTransmit)
+        {/* transmit */
+            i2cPrepareDma(i2cUnit, tmhwI2cDmaMasterTransmit);
+        }
+        /* for receive, wait until state 0x40 */
+    }
+} /* i2cSendSlaveAddress */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cIncludeLastByte:
+ *
+ * DESCRIPTION: determines whether last byte must be included in block data
+ *              transfer. A last must be excluded e.g. when a Nack must be
+ *              returned when last data byte is received, while other bytes
+ *              are returned with an Ack.
+ *
+ * RETURN:      True if last byte must be included
+ *              False: otherwise
+ *
+ * NOTES:       Re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Bool
+i2cIncludeLastByte (
+    tmUnitSelect_t      i2cUnit,
+    tmhwI2cDmaControl_t dmaControl
+    )
+{
+    Bool bIncludeLastByte = True;
+
+    if ( (dmaControl == tmhwI2cDmaMasterReceive) &&
+            (gI2cData[i2cUnit].attach != tmhwI2cChain) )
+    {/* tmhwI2cStop || tmhwI2cRestart */
+        bIncludeLastByte = False;
+    }
+
+    return bIncludeLastByte;
+} /* i2cIncludeLastByte */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIP3202SetByteWise:
+ *
+ * DESCRIPTION: After calling this function, I2C data transfer will be done
+ *              byte by byte.
+ *              (undocumented feaure)
+ *
+ * RETURN:      -
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cIP3203SetByteWise (
+    tmUnitSelect_t              i2cUnit
+    )
+{
+
+    gI2cCfg[i2cUnit].bDma = False;
+
+} /* tmhwI2cIP3203SetByteWise */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cIP3203SetDMA:
+ *
+ * DESCRIPTION: After calling this function, I2C data transfer will be
+ *              done through DMA in case of the IP3203 module, for the IP0105
+ *              calling this function has no effect.
+ *              (undocumented feature)
+ *
+ * RETURN:      -
+ *
+ * NOTES:       Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cIP3203SetDMA (
+    tmUnitSelect_t              i2cUnit
+    )
+{
+    tmhwI2cCfg_t    i2cCfg;
+
+    if(
+#ifndef LINUX_BUILD
+        (gI2cRegisterMmFunc[i2cUnit].gpVirtToPhys != Null) &&
+        (gI2cRegisterMmFunc[i2cUnit].gpCacheFlush != Null) &&
+        (gI2cRegisterMmFunc[i2cUnit].gpCacheInvalidate != Null) &&
+#endif
+        (gI2cRegisterMmFunc[i2cUnit].length > 1) &&
+        (gI2cRegisterMmFunc[i2cUnit].bufferPtr != Null))
+
+    {
+        tmhwI2cCfgInit( i2cUnit, &i2cCfg );
+        gI2cCfg[i2cUnit].bDma = i2cCfg.bDma;
+    }
+    else
+    {
+        gI2cCfg[i2cUnit].bDma = False;
+    }
+
+} /* tmhwI2cIP3203SetDMA */
+
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cHotBoot
+ *
+ * DESCRIPTION: Terminates any ongoing transfers and STOPs the MASTER
+ *          Puts the slave to non-addressed mode.
+ *          De-inits the hw unit.
+ *
+ * RETURN:      -
+ *
+ * NOTES:      Only for IP3203. re-entrant.
+ *          If DMA tansaction is ongoing, no register write commands can be issued.
+ *          Register Readcan be issued only to DMA STATUS and INT STATUS registers.
+ *          Other register reads will result in DEADABBA. Bus busy or Free
+ *          Status cannot be determined. Hence waitforInt until timeout unconditionally.
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cHotBoot (
+    tmUnitSelect_t  i2cUnit
+    )
+{
+
+    tmhwI2cEvent_t event;
+    tmhwI2cDirection_t direction = tmhwI2cTransmit;
+    UInt8 slaveaddress = 0xEE;/* dummy slave*/
+
+    /* wait for an interrupt */
+    i2cWaitForInt(i2cUnit);
+    i2cGetStatus(i2cUnit, &event);
+
+    switch(event)
+    {
+    case tmhwI2cEvent0x08 :
+    case tmhwI2cEvent0x10 : /* Master mode, Send a dummy slave address*/
+            i2cWriteDat(i2cUnit, (UInt8)(direction | (slaveaddress << 1)) );
+            (Void) tmhwI2cIntClear(i2cUnit);
+            break;
+    case tmhwI2cEvent0x40 :
+    case tmhwI2cEvent0x50 : /* MASTER mode, NACK will be programmed*/
+            i2cControl(i2cUnit, (tmhwI2cControl_t)(tmhwI2cEnable));
+            (Void) tmhwI2cIntClear(i2cUnit);
+            break;
+    case tmhwI2cEvent0xf8 :
+            /* no interrupt may be due to clock stretching by Slave*/
+            /* Stop the slave & Geenrate STOP condition*/
+            tmhwI2cStopSlave(i2cUnit);
+            i2cControl(i2cUnit,
+                    (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond));
+            (Void) tmhwI2cIntClear(i2cUnit);
+            /* WAIT for STOP to be set*/
+            i2cWaitForSTO(i2cUnit);
+            break;
+    default : /* for other states just generate a STOP condition.*/
+        break;
+    }
+    i2cWaitForInt(i2cUnit);
+    tmhwI2cStopSlave(i2cUnit);
+    /* Generate STOP condition*/
+     i2cControl(i2cUnit,
+             (tmhwI2cControl_t)(tmhwI2cEnable|tmhwI2cStopCond));
+     (Void) tmhwI2cIntClear(i2cUnit);
+
+    /* WAIT for STOP to be set*/
+    i2cWaitForSTO(i2cUnit);
+
+    (Void) tmhwI2cDeinit(i2cUnit);
+}
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cWaitForInt
+ *
+ * DESCRIPTION: waits for an interrupt
+ *
+ * RETURN:      -
+ *
+ * NOTES:      Only for IP3203. re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cWaitForInt(
+    tmUnitSelect_t i2cUnit
+)
+{
+    tmhwI2cStatusType_t  intstatus;
+    int timeout = HWI2C_RESET_TIMEOUT;
+    while(timeout > 0)
+    {
+        #ifdef LINUX_BUILD
+          udelay(100); /* sleep 100us*/
+        #endif
+        timeout--;
+        tmhwI2cIntGetStatus(i2cUnit,  &intstatus);
+        if ( intstatus != tmhwI2cNoInterrupt )
+            break;
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    i2cWaitForSTO
+ *
+ * DESCRIPTION: waits for STO bit to be set
+ *
+ * RETURN:      -
+ *
+ * NOTES:      Only for IP3203. re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+static Void
+i2cWaitForSTO(
+    tmUnitSelect_t  i2cUnit
+)
+{
+    UInt32 reg_value;
+    int timeout = HWI2C_RESET_TIMEOUT;
+    while(timeout > 0)
+    {
+       #ifdef LINUX_BUILD
+          udelay(100); /* sleep 100us*/
+       #endif
+       timeout--;
+        I2C_READ( (gI2cModule[i2cUnit].pRegBase + TMVH_I2C3203_INTROG_OFFSET),
+                       reg_value);
+        if ( (reg_value & TMVH_I2C3203_INTROG_INTRO_STO_MSK)
+                    == TMVH_I2C3203_INTROG_INTRO_STO_MSK )
+            break;
+    }
+}
+
+
+#ifdef LINUX_BUILD
+
+/* Reset unit definitions. Only for pnx8535*/
+#define RESET_UNIT_BASE     0x00060000
+#define RESET_I2C_UNIT0     10
+#define RESET_I2C_UNIT1     11
+#define RESET_CONTROL_REG   0x100
+
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cSoftReset
+ *
+ * DESCRIPTION: Resets the i2c hardware unit using reset generation unit
+ *
+ * RETURN:      -
+ *
+ * NOTES:
+ * ---------------------------------------------------------------------------
+ */
+Void
+tmhwI2cSoftReset (
+    tmUnitSelect_t              i2cUnit
+    )
+{
+    /* Do a hard reset of the i2c unit */
+    volatile unsigned char *pResetUnitBase;
+    unsigned int reset_read;
+    unsigned int reset_i2c_unit[] = {RESET_I2C_UNIT0,RESET_I2C_UNIT1};
+
+    pResetUnitBase= (volatile unsigned char*)ioremap((TMHW_I2C_CFG_REG_START+RESET_UNIT_BASE), 4096);
+
+    /* Read the reset_active register*/
+    reset_read = (0x01 << reset_i2c_unit[i2cUnit]);
+
+    /* Write into the reset control register*/
+    *((unsigned int*)(pResetUnitBase + RESET_CONTROL_REG)) = reset_read;
+}
+#endif
+
+
+#ifndef LINUX_BUILD
+/* ---------------------------------------------------------------------------
+ * FUNCTION:    tmhwI2cDoRequest:
+ *
+ * DESCRIPTION: Sequence master IIC machine states for both polled and
+ *              interrupt mode.
+ *
+ * RETURN:      TMHW_ERR_IIC_BAD_UNIT_ID
+ *              TMHW_ERR_IIC_BAD_PARAMETER
+ *              TMHW_ERR_IIC_MASTER_WRITE
+ *              TMHW_ERR_IIC_MASTER_READ
+ *              TMHW_ERR_IIC_NO_SLA_ACK
+ *              TMHW_ERR_IIC_NO_DATA_ACK
+ *              TMHW_ERR_IIC_ARB_LOST
+ *              TM_OK
+ *
+ * PRE:         Master only can call the function
+ *
+ * NOTES:       For either polled or interrupt mode, caller should set
+ *              bStart to TRUE when calling the function the first time.
+ *
+ *              For either mode, caller should set pFinished variable to
+ *              FALSE.
+ *
+ *              - For polled mode, pFinished is always TRUE when
+ *                function returns to caller.
+ *
+ *              - For interrupt mode, pFinished is only TRUE when all
+ *                states of one IIC transfer are completed.
+ *
+ *              Not re-entrant.
+ * ---------------------------------------------------------------------------
+ */
+tmErrorCode_t
+tmhwI2cLIBDoRequest(
+    tmUnitSelect_t        unitID,     /* I: iic unit */
+    Bool                  bStart,     /* I: True if 1st call */
+    Bool                  bDoPoll,    /* I: IGNORED */
+    ptmhwI2cLIBRequest_t  pHwReq,     /* I: data for sequenceing state machine */
+    Bool                  *pFinished  /* O: set to True if this step finished */
+                                      /*    a transaction */
+)
+{
+    (void) bStart;     /* Why are these not used ? */
+    (void) bDoPoll;
+    (void) pFinished;
+
+    return tmhwI2cDoRequest(unitID, (ptmhwI2cDoRequest_t)pHwReq);
+}
+
+
+
+tmErrorCode_t
+tmhwI2cDoRequest(
+    tmUnitSelect_t        unitID,       /* I: iic unit */
+    ptmhwI2cDoRequest_t  pHwReq         /* I: data for sequenceing state machine */
+)
+{
+    UInt32       numReq = 1;
+    tmhwI2cData_t masterData1, masterData2;
+    Bool done = False;
+    tmErrorCode_t status;
+    UInt32       uiTimeout;
+    UInt32       ticksPerSec;
+    UInt32       ticksPer1ms;
+    UInt32       ticksPerTimeout;
+    UInt32       currTicks;
+    UInt32       entryTicks;
+    UInt32       timediff;
+    UInt8        switchVar =0;
+
+    masterData1.bHS = False;
+    masterData2.bHS = False;
+    masterData1.slaveAddress = pHwReq->address;
+    masterData2.slaveAddress = pHwReq->address;
+    if (gI2cModule[unitID].I2cType == I2cIP3203)
+    {
+        tmhwI2cIP3203SetByteWise(unitID);
+    }
+    status = tmhwI2cIntDisable(unitID);
+
+    if ((pHwReq->pWriteData == Null) && (pHwReq->pReadData == Null))
+    {
+        return (TMHW_ERR_I2C_INVALID_REQUEST);
+    }
+
+    if(pHwReq->numReadBytes !=0)
+    {
+        switchVar |= (1<<3);
+    }
+    if(pHwReq->numWriteBytes !=0)
+    {
+        switchVar |= (1<<2);
+    }
+    if(pHwReq->pReadData != Null)
+    {
+        switchVar |= (1<<1);
+    }
+    if(pHwReq->pWriteData != Null)
+    {
+        switchVar |= 0x1;
+    }
+    switch(switchVar)
+    {
+        case 0x00:
+        case 0x04:
+        case 0x08:
+        case 0x0c:
+        /*  Error */
+            return (TMHW_ERR_I2C_INVALID_REQUEST);
+            /* break; */
+
+        case 0x01:
+        case 0x03:
+        case 0x05:
+        case 0x07:
+        case 0x09:
+        case 0x0d:
+         /* Write */
+            masterData1.attach = tmhwI2cStop;
+            masterData1.direction = tmhwI2cTransmit;
+            masterData1.pAddress = pHwReq->pWriteData;
+            masterData1.length = pHwReq->numWriteBytes;
+            break;
+
+        case 0x02:
+        case 0x06:
+        case 0x0a:
+        case 0x0b:
+        case 0x0e:
+        /* Read */
+            masterData1.attach = tmhwI2cStop;
+            masterData1.direction = tmhwI2cReceive;
+            masterData1.length = pHwReq->numReadBytes;
+            masterData1.pAddress = pHwReq->pReadData;
+            break;
+
+        case 0x0f:
+        /* Write + Read */
+        /* read + subaddressing */
+            masterData1.attach = tmhwI2cRestart;
+            masterData1.direction = tmhwI2cTransmit;
+            masterData1.pAddress = pHwReq->pWriteData;
+            masterData1.length = pHwReq->numWriteBytes;
+
+            masterData2.attach = tmhwI2cStop;
+            masterData2.direction = tmhwI2cReceive;
+            masterData2.length = pHwReq->numReadBytes;
+            masterData2.pAddress = pHwReq->pReadData;
+            break;
+
+        default :
+        return (TMHW_ERR_I2C_INVALID_REQUEST);
+    }
+
+    uiTimeout = gI2cCfg[unitID].timeout;
+    status = tmbslCoreGetTicksPerSec(&ticksPerSec);
+    ticksPer1ms = (ticksPerSec/1000);
+    ticksPerTimeout = (uiTimeout * ticksPer1ms); /* timeout is in milisecond */
+
+    /* start master */
+    tmhwI2cStartMaster(unitID, 0, (tmhwI2cDirection_t)0);
+
+    /* poll until done when timeout == 0 , otherwise wait for timeout */
+    timediff = 0;
+    status = tmbslCoreGetTickCount(&entryTicks);
+    do
+    {
+        status = tmhwI2cEvent (unitID, tmhwI2cEventInterrupt, False);
+        if ((status == TMHW_ERR_I2C_EVENT_MST_REQ) && (numReq == 1))
+        { /* first part of subaddressing or simple transfer */
+            tmhwI2cSetData(unitID, &masterData1);
+            status = tmhwI2cEvent (unitID, tmhwI2cEventProceed, False);
+            numReq = 2;
+        }
+        if ((status == TMHW_ERR_I2C_EVENT_MST_TRX_REQ) ||
+            (status == TMHW_ERR_I2C_EVENT_MST_REC_REQ) ||
+            ((status == TMHW_ERR_I2C_EVENT_MST_REQ) && (numReq == 2)))
+        {/* second part of subaddressing */
+            tmhwI2cSetData(unitID, &masterData2);
+            status = tmhwI2cEvent (unitID, tmhwI2cEventProceed, False);
+        }
+        if ((status == TMHW_ERR_I2C_EVENT_MST_TRX_DONE) ||
+            (status == TMHW_ERR_I2C_EVENT_MST_REC_DONE))
+        {
+            done = True;
+            status = TM_OK;
+        }
+        if(status == TMHW_ERR_I2C_EVENT_MST_LOST)
+        {
+        /* start master once again*/
+            tmhwI2cStartMaster(unitID, 0, (tmhwI2cDirection_t)0);
+        }
+        if ((status == TMHW_ERR_I2C_EVENT_MST_TRX_ABORT) ||
+            (status == TMHW_ERR_I2C_EVENT_MST_REC_ABORT) ||
+            (status == TMHW_ERR_I2C_EVENT_MST_ABORT)     ||
+            (status == TMHW_ERR_I2C_EVENT_BUS_ERROR) )
+        {
+            done = True;
+        }
+        if(uiTimeout != 0)
+        {
+            (Void) tmbslCoreGetTickCount(&currTicks);
+            timediff = (currTicks - entryTicks);
+        }
+    }while( (done != True ) && (timediff <= ticksPerTimeout));
+
+    (Void) tmhwI2cIntEnable(unitID);
+    tmhwI2cIP3203SetDMA(unitID);
+    if(done != True)
+    {
+        return TMHW_ERR_I2C_TIMEOUT;
+    }
+
+    return status;
+} /* tmhwI2cDoRequest */
+#endif /* LINUX_BUILD */
+
+
+#ifdef LINUX_BUILD
+#ifdef CONFIG_I2C_DEBUG
+
+void I2c_Error_Trigger( void )
+{
+    printk( KERN_EMERG "I2c error \n" );
+    DumpI2c();
+    printk( KERN_EMERG"I2c error - done\n");
+}
+
+static void DumpI2c( void )
+{
+    int i, j;
+    unsigned int data, address;
+
+    j = G_logI2cIndex - 1;
+    for( i = 0; i < LOG_SIZE; i++ )
+    {
+        if( j < 0 )
+            j = LOG_SIZE - 1;
+
+        data    = G_logI2c[j--];
+        address = G_logI2c[j--];
+        if( address & 0x80000000 )
+        {
+            address &= 0x7fffffff;
+            printk(KERN_EMERG "I2c WRITE 0x%08x @ 0x%08x (%s)\n", data, address, RegToName(address));
+        }
+        else
+        {
+            printk(KERN_EMERG "I2c read  0x%08x @ 0x%08x (%s)\n", data, address, RegToName(address));
+        }
+    }
+}
+
+static const char*
+RegToName( unsigned long offset)
+{
+    struct name_number {
+        const char* pRegName;
+        unsigned long regOffset;
+    } NameNumberTable[] =
+            {
+                { "I2CCON     ",    0x0000},
+                { "I2CSTAT    ",    0x0004},
+                { "I2CDAT     ",    0x0008},
+                { "I2CSLA     ",    0x000C},
+                { "HSBIR      ",    0x0010},
+                { "FSBIR      ",    0x0014},
+                { "INTROG     ",    0x0018},
+                { "DMA_ADDR   ",    0x0020},
+                { "DMA_LEN    ",    0x0024},
+                { "DMA_COUNTER",    0x0028},
+                { "DMA_CONTROL",    0x002C},
+                { "DMA_STATUS ",    0x0030},
+                { "INT_STATUS ",    0x0FE0},
+                { "INT_ENABLE ",    0x0FE4},
+                { "INT_CLEAR  ",    0x0FE8},
+                { "INT_SET    ",    0x0FEC},
+                { "POWERDOWN  ",    0x0FF4},
+                { "MODULE_ID  ",    0x0FFC }
+            };
+    int i;
+
+    offset &= 0xfff;  // only look at offset part
+
+    for( i = 0;
+             i < (sizeof(NameNumberTable)/sizeof(NameNumberTable[0]) );
+             i++)
+        {
+            if( NameNumberTable[i].regOffset == offset )
+                {
+                    return NameNumberTable[i].pRegName;
+                }
+        }
+    return "unknown register";
+}
+
+#endif /* CONFIG_I2C_DEBUG*/
+#endif /* LINUX_BUILD*/
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhI2c3203_Reg.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhI2c3203_Reg.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhI2c3203_Reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhI2c3203_Reg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,299 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ * %filename    : tmvhI2c3203_Reg.h %
+ * %pid_version : PB5#2 %
+ *----------------------------------------------------------------------------
+ * DESCRIPTION  : vHAL file for I2c module IP 3203
+ *
+ *
+ * NOTES        :
+ *----------------------------------------------------------------------------
+ */
+
+#ifndef TMHWI2C3203_VHIP_H
+#define TMHWI2C3203_VHIP_H
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+/* ---------------------------------------------------------------------------
+ *  Register offsets from base address
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_I2CCON_OFFSET              0x0000
+#define TMVH_I2C3203_I2CSTAT_OFFSET             0x0004
+#define TMVH_I2C3203_I2CDAT_OFFSET              0x0008
+#define TMVH_I2C3203_I2CSLA_OFFSET              0x000C
+#define TMVH_I2C3203_HSBIR_OFFSET               0x0010
+#define TMVH_I2C3203_FSBIR_OFFSET               0x0014
+#define TMVH_I2C3203_INTROG_OFFSET              0x0018
+#define TMVH_I2C3203_DMA_ADDR_OFFSET            0x0020
+#define TMVH_I2C3203_DMA_LEN_OFFSET             0x0024
+#define TMVH_I2C3203_DMA_COUNTER_OFFSET         0x0028
+#define TMVH_I2C3203_DMA_CONTROL_OFFSET         0x002C
+#define TMVH_I2C3203_DMA_STATUS_OFFSET          0x0030
+#define TMVH_I2C3203_INT_STATUS_OFFSET          0x0FE0
+#define TMVH_I2C3203_INT_ENABLE_OFFSET          0x0FE4
+#define TMVH_I2C3203_INT_CLEAR_OFFSET           0x0FE8
+#define TMVH_I2C3203_INT_SET_OFFSET             0x0FEC
+#define TMVH_I2C3203_POWERDOWN_OFFSET           0x0FF4
+#define TMVH_I2C3203_MODULE_ID_OFFSET           0x0FFC
+
+#define TMVH_I2C3203_SDA_HOLD                   0x0001c
+
+
+/* ---------------------------------------------------------------------------
+ *  Control register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_I2CCON_EN_I2C_POS                 6
+#define TMVH_I2C3203_I2CCON_EN_I2C_MSK                 0x00000040
+
+#define TMVH_I2C3203_I2CCON_START_POS                  5
+#define TMVH_I2C3203_I2CCON_START_MSK                  0x00000020
+
+#define TMVH_I2C3203_I2CCON_SETSTOP_POS                4
+#define TMVH_I2C3203_I2CCON_SETSTOP_MSK                0x00000010
+
+#define TMVH_I2C3203_I2CCON_AA_POS                     2
+#define TMVH_I2C3203_I2CCON_AA_MSK                     0x00000004u
+
+#if (TMFL_PNX_ID == 5100)
+#define TMVH_I2C3203_I2CCON_INT_EN_POS                 7                 
+#define TMVH_I2C3203_I2CCON_INT_EN_MSK                 0x00000080
+
+#define TMVH_I2C3203_I2CCON_INT_CLR_POS                3                 
+#define TMVH_I2C3203_I2CCON_INT_CLR_MSK                0x00000008
+
+#define TMVH_I2C3203_I2CCON_SDA_POS                    1                 
+#define TMVH_I2C3203_I2CCON_SDA_MSK                    0x00000002
+
+#define TMVH_I2C3203_I2CCON_SCL_POS                    0                 
+#define TMVH_I2C3203_I2CCON_SCL_MSK                    0x00000001
+
+
+#endif
+
+
+/* ---------------------------------------------------------------------------
+ *  Status register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_I2CSTAT_STATUS_CODE_POS           0
+#define TMVH_I2C3203_I2CSTAT_STATUS_CODE_MSK           0x000000FF
+
+
+/* ---------------------------------------------------------------------------
+ *  Data register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_I2CDAT_DATA_POS                   0
+#define TMVH_I2C3203_I2CDAT_DATA_MSK                   0x000000FFu
+
+
+/* ---------------------------------------------------------------------------
+ *  Slave address register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_I2CSLA_SLAVE_ADDR_POS             1
+#define TMVH_I2C3203_I2CSLA_SLAVE_ADDR_MSK             0x000000FEu
+
+#define TMVH_I2C3203_I2CSLA_WATCH_GC_POS               0
+#define TMVH_I2C3203_I2CSLA_WATCH_GC_MSK               0x00000001u
+
+
+/* ---------------------------------------------------------------------------
+ *  High speed mode bit rate register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_HSBIR_BITRATE_POS                 0
+#define TMVH_I2C3203_HSBIR_BITRATE_MSK                 0x0000001F
+
+
+/* ---------------------------------------------------------------------------
+ *  Fast/Standard mode bit rate register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_FSBIR_MODE_POS                    7
+#define TMVH_I2C3203_FSBIR_MODE_MSK                    0x00000080u
+
+#define I2C_SS_MODE                                    0
+#define I2C_FS_MODE                                    1
+
+#define TMVH_I2C3203_FSBIR_BITRATE_POS                 0
+#define TMVH_I2C3203_FSBIR_BITRATE_MSK                 0x0000007Fu
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrogate register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_INTROG_INTRO_MST_POS              7
+#define TMVH_I2C3203_INTROG_INTRO_MST_MSK              0x00000080
+
+#define TMVH_I2C3203_INTROG_INTRO_TRX_POS              6
+#define TMVH_I2C3203_INTROG_INTRO_TRX_MSK              0x00000040
+
+#define TMVH_I2C3203_INTROG_INTRO_HS_POS               5
+#define TMVH_I2C3203_INTROG_INTRO_HS_MSK               0x00000020
+
+#define TMVH_I2C3203_INTROG_INTRO_STO_POS              4
+#define TMVH_I2C3203_INTROG_INTRO_STO_MSK              0x00000010
+
+#define TMVH_I2C3203_INTROG_INTRO_SI_POS               3
+#define TMVH_I2C3203_INTROG_INTRO_SI_MSK               0x00000008
+
+#define TMVH_I2C3203_INTROG_INTRO_BB_POS               2
+#define TMVH_I2C3203_INTROG_INTRO_BB_MSK               0x00000004
+
+#define TMVH_I2C3203_INTROG_INTRO_SEL_POS              1
+#define TMVH_I2C3203_INTROG_INTRO_SEL_MSK              0x00000002
+
+#define TMVH_I2C3203_INTROG_INTRO_ACK_POS              0
+#define TMVH_I2C3203_INTROG_INTRO_ACK_MSK              0x00000001
+
+
+
+/* ---------------------------------------------------------------------------
+ *  DMA Length register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_DMA_LEN_SIZE_POS                  0
+#define TMVH_I2C3203_DMA_LEN_SIZE_MSK                  0x0000FFFF
+
+
+/* ---------------------------------------------------------------------------
+ *  DMA Counter register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_DMA_COUNTER_LEN_POS               0
+#define TMVH_I2C3203_DMA_COUNTER_LEN_MSK               0x0000FFFF
+
+
+/* ---------------------------------------------------------------------------
+ *  DMA Control register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_DMA_CONTROL_SLAVE_TX_POS          3
+#define TMVH_I2C3203_DMA_CONTROL_SLAVE_TX_MSK          0x00000008
+
+#define TMVH_I2C3203_DMA_CONTROL_SLAVE_RX_POS          2
+#define TMVH_I2C3203_DMA_CONTROL_SLAVE_RX_MSK          0x00000004
+
+#define TMVH_I2C3203_DMA_CONTROL_MASTER_RX_POS         1
+#define TMVH_I2C3203_DMA_CONTROL_MASTER_RX_MSK         0x00000002
+
+#define TMVH_I2C3203_DMA_CONTROL_MASTER_TX_POS         0
+#define TMVH_I2C3203_DMA_CONTROL_MASTER_TX_MSK         0x00000001
+
+
+
+/* ---------------------------------------------------------------------------
+ *  DMA Status register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_DMA_STATUS_DMACOUNT_ZERO_POS      1
+#define TMVH_I2C3203_DMA_STATUS_DMACOUNT_ZERO_MSK      0x00000002
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Status register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_INT_STATUS_CODE_POS               24
+#define TMVH_I2C3203_INT_STATUS_CODE_MSK               0xFF000000u
+
+#define TMVH_I2C3203_INT_STATUS_STA0_POS               0
+#define TMVH_I2C3203_INT_STATUS_STA0_MSK               0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Enable register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_INT_ENABLE_EN_MODE_POS            0
+#define TMVH_I2C3203_INT_ENABLE_EN_MODE_MSK            0x00000001u
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Clear register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_INT_CLEAR_INTCLR_POS              0
+#define TMVH_I2C3203_INT_CLEAR_INTCLR_MSK              0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Set register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_INT_SET_SET0_POS                  0
+#define TMVH_I2C3203_INT_SET_SET0_MSK                  0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  Power Setting register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_POWERDOWN_PWR_DOWN_POS            31
+#define TMVH_I2C3203_POWERDOWN_PWR_DOWN_MSK            0x80000000u
+
+
+/* ---------------------------------------------------------------------------
+ *  Module ID register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_I2C3203_MODULE_ID_MODID_POS               16
+#define TMVH_I2C3203_MODULE_ID_MODID_MSK               0xFFFF0000
+
+#define TMVH_I2C3203_MODULE_ID_MAJ_REV_POS             12
+#define TMVH_I2C3203_MODULE_ID_MAJ_REV_MSK             0x0000F000
+
+#define TMVH_I2C3203_MODULE_ID_MIN_REV_POS             8
+#define TMVH_I2C3203_MODULE_ID_MIN_REV_MSK             0x00000F00
+
+#define TMVH_I2C3203_MODULE_ID_APERTURE_POS            0
+#define TMVH_I2C3203_MODULE_ID_APERTURE_MSK            0x000000FF
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /*TMHWI2C3203_VHIP_H*/
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhIic0105_Reg.h linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhIic0105_Reg.h
--- linux-2.6.34.orig/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhIic0105_Reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/algos/i2c_phlm/tmhwI2c/src/tmvhIic0105_Reg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,236 @@
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *----------------------------------------------------------------------------
+ * %filename    : tmvhIic0105_Reg.h %
+ * %pid_version : PB5#1 %
+ *----------------------------------------------------------------------------
+ * DESCRIPTION  : vHAL file for Iic module IP 0105
+ *
+ *
+ * NOTES        :
+ *----------------------------------------------------------------------------
+ */
+
+#ifndef TMHWIIC0105_VHIP_H
+#define TMHWIIC0105_VHIP_H
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+/* ---------------------------------------------------------------------------
+ *  Register offsets from base address
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2CCONTROL_OFFSET          0x0000
+#define TMVH_IIC0105_I2CDAT_OFFSET              0x0004
+#define TMVH_IIC0105_I2CSTATUS_OFFSET           0x0008
+#define TMVH_IIC0105_I2C_ADDR_OFFSET            0x000C
+#define TMVH_IIC0105_I2C_STOP_OFFSET            0x0010
+#define TMVH_IIC0105_I2C_PD_OFFSET              0x0014
+#define TMVH_IIC0105_I2C_SETPINS_OFFSET         0x0018
+#define TMVH_IIC0105_I2C_OBS_PINS_OFFSET        0x001C
+#define TMVH_IIC0105_INT_STATUS_OFFSET          0x0FE0
+#define TMVH_IIC0105_INT_ENABLE_OFFSET          0x0FE4
+#define TMVH_IIC0105_INT_CLEAR_OFFSET           0x0FE8
+#define TMVH_IIC0105_INT_SET_OFFSET             0x0FEC
+#define TMVH_IIC0105_I2C_POWERDOWN_OFFSET       0x0FF4
+#define TMVH_IIC0105_MODULE_ID_OFFSET           0x0FFC
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Control register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2CCONTROL_AA_POS                 7
+#define TMVH_IIC0105_I2CCONTROL_AA_MSK                 0x00000080u
+
+#define TMVH_IIC0105_I2CCONTROL_EN_I2C_POS             6
+#define TMVH_IIC0105_I2CCONTROL_EN_I2C_MSK             0x00000040u
+
+#define TMVH_IIC0105_I2CCONTROL_START_POS              5
+#define TMVH_IIC0105_I2CCONTROL_START_MSK              0x00000020u
+
+#define TMVH_IIC0105_I2CCONTROL_SETSTOP_POS            4
+#define TMVH_IIC0105_I2CCONTROL_SETSTOP_MSK            0x00000010
+
+#define TMVH_IIC0105_I2CCONTROL_CR2_POS                0
+#define TMVH_IIC0105_I2CCONTROL_CR2_MSK                0x00000007u
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Data register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2CDAT_DATA_POS                   0
+#define TMVH_IIC0105_I2CDAT_DATA_MSK                   0x000000FFu
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Status register
+ * ---------------------------------------------------------------------------
+ */
+
+/* NOTE: 
+ * The datasheet specifies that bits 7:3 contain the status code. 
+ * And bits 2:0 are reserved. However, status code is 8bit long. 
+ * Hence the status code mask will be bit positions 7:3, but no
+ * right shifting must be done. Hence the last 3 bits will always 
+ * be zeros.(PR PB5#54)
+ */
+#define TMVH_IIC0105_I2CSTATUS_STATUS_CODE_POS         0
+#define TMVH_IIC0105_I2CSTATUS_STATUS_CODE_MSK         0x000000F8
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Slave address register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_ADDR_SLAVE_ADDR_POS           1
+#define TMVH_IIC0105_I2C_ADDR_SLAVE_ADDR_MSK           0x000000FEu
+
+#define TMVH_IIC0105_I2C_ADDR_WATCH_GC_POS             0
+#define TMVH_IIC0105_I2C_ADDR_WATCH_GC_MSK             0x00000001u
+
+
+
+/* ---------------------------------------------------------------------------
+ *  I2C STOP register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_STOP_STO_POS                  0
+#define TMVH_IIC0105_I2C_STOP_STO_MSK                  0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  I2C PD register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_PD_RESET_CLKDOMAIN_POS        2
+#define TMVH_IIC0105_I2C_PD_RESET_CLKDOMAIN_MSK        0x00000004
+
+
+
+/* ---------------------------------------------------------------------------
+ *  I2C Bus set register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_SETPINS_SETSCL_LOW_POS        1
+#define TMVH_IIC0105_I2C_SETPINS_SETSCL_LOW_MSK        0x00000002
+
+#define TMVH_IIC0105_I2C_SETPINS_SETSDA_LOW_POS        0
+#define TMVH_IIC0105_I2C_SETPINS_SETSDA_LOW_MSK        0x00000001
+
+
+
+/* ---------------------------------------------------------------------------
+ *  I2C Bus observation register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_OBS_PINS_OBS_SCL_POS          1
+#define TMVH_IIC0105_I2C_OBS_PINS_OBS_SCL_MSK          0x00000002
+
+#define TMVH_IIC0105_I2C_OBS_PINS_OBS_SDA_POS          0
+#define TMVH_IIC0105_I2C_OBS_PINS_OBS_SDA_MSK          0x00000001
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Status register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_INT_STATUS_STA_POS                0
+#define TMVH_IIC0105_INT_STATUS_STA_MSK                0x00000001
+
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Enable register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_INT_ENABLE_EN_POS                 0
+#define TMVH_IIC0105_INT_ENABLE_EN_MSK                 0x00000001u
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Clear register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_INT_CLEAR_CLR_POS                 0
+#define TMVH_IIC0105_INT_CLEAR_CLR_MSK                 0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  Interrupt Set register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_INT_SET_SET0_POS                  0
+#define TMVH_IIC0105_INT_SET_SET0_MSK                  0x00000001
+
+
+/* ---------------------------------------------------------------------------
+ *  Power Setting register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_POS        31
+#define TMVH_IIC0105_I2C_POWERDOWN_PWR_DOWN_MSK        0x80000000u
+
+
+/* ---------------------------------------------------------------------------
+ *  Module ID register
+ * ---------------------------------------------------------------------------
+ */
+
+#define TMVH_IIC0105_MODULE_ID_MODID_POS               16
+#define TMVH_IIC0105_MODULE_ID_MODID_MSK               0xFFFF0000
+
+#define TMVH_IIC0105_MODULE_ID_MAJ_REV_POS             12
+#define TMVH_IIC0105_MODULE_ID_MAJ_REV_MSK             0x0000F000
+
+#define TMVH_IIC0105_MODULE_ID_MIN_REV_POS             8
+#define TMVH_IIC0105_MODULE_ID_MIN_REV_MSK             0x00000F00
+
+#define TMVH_IIC0105_MODULE_ID_APERTURE_POS            0
+#define TMVH_IIC0105_MODULE_ID_APERTURE_MSK            0x000000FF
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*TMHWIIC0105_VHIP_H*/
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/Kconfig linux-2.6.34/drivers/i2c/algos/Kconfig
--- linux-2.6.34.orig/drivers/i2c/algos/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/i2c/algos/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -14,4 +14,18 @@ config I2C_ALGOPCF
 config I2C_ALGOPCA
 	tristate "I2C PCA 9564 interfaces"
 
+config I2C_ALGO3203
+  tristate "IP3203 and IP0105 support"
+  depends on I2C
+  help
+    Supports IP3203 and IP0105.
+
+config I2C_DEBUG
+  bool "I2C Debugging messages"
+  depends on I2C_ALGO3203
+  help
+    Say Y here if you want the I2C to produce a bunch of debug
+    messages.  Select this if you are having a
+    problem with I2C support and want to see more of what is going on.
+    
 endmenu
diff -Naurp linux-2.6.34.orig/drivers/i2c/algos/Makefile linux-2.6.34/drivers/i2c/algos/Makefile
--- linux-2.6.34.orig/drivers/i2c/algos/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/i2c/algos/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -5,6 +5,7 @@
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
+obj-$(CONFIG_I2C_ALGO3203)  += i2c_phlm/
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Naurp linux-2.6.34.orig/drivers/i2c/i2c-proc.c linux-2.6.34/drivers/i2c/i2c-proc.c
--- linux-2.6.34.orig/drivers/i2c/i2c-proc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/i2c-proc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,910 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * linux/drivers/i2c/i2c-proc.c
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *--------------------------------------------------------------------------
+ * %filename:     i2c-proc.c %
+ *--------------------------------------------------------------------------
+ * description    : This file contains the I2C Procfs access implementation for IP_3203
+ *
+ *--------------------------------------------------------------------------
+ */
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/idr.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/completion.h>
+#include <linux/hardirq.h>
+#include <linux/irqflags.h>
+#include <asm/uaccess.h>
+
+#include "i2c-core.h"
+#include "i2c-proc.h"
+
+//#define CONFIG_PROC_I2C_DEBUG
+
+#ifdef CONFIG_PROC_I2C_DEBUG
+#define PROC_I2C_PRINT(fmt, args...) \
+                printk(fmt, ##args); 
+#else
+#define PROC_I2C_PRINT(fmt, args...)
+#endif
+
+#define PROC_I2C_FLD "i2c"
+#define PROC_NUM_I2C_BUS (3)
+
+struct i2c_proc_entry_t {
+    const unsigned int device_bus_num;
+    const unsigned int device_addr;
+    const char *i2c_dev_name;
+    const unsigned int page_size;
+    unsigned int current_offset;
+    unsigned int trans_buffer_size;
+    unsigned int io_block_size;
+};
+
+struct proc_i2c_data {
+	unsigned char *buf;
+	unsigned int size;
+	struct mutex lock;
+	const struct i2c_proc_entry_t *entry;
+	struct i2c_msg *msg;
+	void *private;
+};
+
+#define PROC_EEPROM_BUFFER_SIZE (64)
+
+/* 64 bytes page size for EEPROM1 & EEPROM2 */
+#define PROC_BLOCK_SIZE (64)
+
+typedef enum {
+       I2C_BUS_0 = 0,
+	I2C_BUS_1,
+	I2C_BUS_2,
+} I2C_BUS_NO;
+
+#define PROC_I2C_DEV_DEF(device_bus_num, \
+	device_addr, \
+	i2c_dev_name, \
+	page_size, \
+	offset, \
+	trans_size) 	{device_bus_num, device_addr, i2c_dev_name, page_size, offset, trans_size, 0},
+
+#define PROC_I2C_DEV_ASSAIGN_LIST() \
+    /* Hardware Semaphore List */   \
+    PROC_I2C_DEV_DEF( I2C_BUS_0, \
+                            PROC_I2C_DEV_EEPROM1_ADDR, \
+                            PROC_I2C_DEV_EEPROM1_NAME, \
+                            PROC_EEPROM_BUFFER_SIZE, \
+                            0, \
+                            0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_0, \
+                            PROC_I2C_DEV_EEPROM2_ADDR, \
+                            PROC_I2C_DEV_EEPROM2_NAME, \
+                            PROC_EEPROM_BUFFER_SIZE, \
+                            0, \
+                            0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_0, \
+                            PROC_I2C_DEV_GPIO_EXPANDER_ADDR, \
+                            PROC_I2C_DEV_GPIO_EXPANDER_NAME, \
+                            1, \
+                            0, \
+                            0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_1, 0x00, "bus1-device0", 0, 0, 0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_1, 0x00, "bus1-device1", 0, 0, 0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_1, 0x00, "bus1-device2", 0, 0, 0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_2, 0x00, "bus2-device0", 0, 0, 0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_2, 0x00, "bus2-device1", 0, 0, 0)  \
+    PROC_I2C_DEV_DEF( I2C_BUS_2, 0x00, "bus2-device2", 0, 0, 0)  \
+    /* PROC_I2C_DEV_LIST() */
+
+/* Extern declaration */
+extern int i2c_get_adapterno(int deviceno);
+
+/* Static functions declaration */
+/* Helper functions */
+static void proc_print_help(void);
+int proc_i2c_atoui (const char* str);
+static int proc_i2c_parse_option(const char *string, unsigned int *offset, 
+	                         unsigned int *size, char **buf,  unsigned int length);
+#if 0
+static struct i2c_proc_entry_t *proc_i2c_get_device_info(struct file *file);
+#endif
+static struct i2c_adapter*proc_i2c_get_adapter(unsigned int bus_no);
+static void proc_create_i2c_msg(struct i2c_msg* msg, unsigned int addr, 
+                                               int flag, unsigned int length, char *buffer);
+
+/* File IOCTLs functions */
+static int proc_i2c_open(struct inode *inode, struct file *file);
+static int proc_i2c_release(struct inode *inode, struct file *file);
+static ssize_t proc_i2c_read(struct file *file, char __user *buf,
+			       size_t length, loff_t *ppos);
+static ssize_t proc_i2c_write(struct file *file, const char __user *buf, size_t length, loff_t *ppos);
+static loff_t proc_i2c_lseek(struct file *file, loff_t offset, int origin);
+static int proc_i2c_ioctl(struct inode *, struct file *, unsigned int flag, unsigned long args);
+
+
+
+static struct i2c_proc_entry_t i2c_proc_entry[] = 
+{
+     /* 12c-device proc entries */
+   PROC_I2C_DEV_ASSAIGN_LIST()
+   {0, 0, NULL},
+   /* List completed*/
+};
+
+
+/**********************
+ *      Helper functions
+ **********************/
+/**
+ * proc_print_help - Display the help
+ */
+static void proc_print_help(void)
+{
+	printk("I2C Procfs Access:\n");
+	printk("\techo|cat /proc/i2c/i2c-0/<devicename> <option> <value>\n");
+	printk("\t<option>\n\t\t -f|-offset <offset>               - Device offset for read or write or ioctl\n");
+	printk("\t\t -l|-length <size>                    - Buffer size for read or write\n");
+	printk("\t\t -d|-data <data string>            - Data string for write\n");
+	printk("\t\t -h|-help                                 - Display this help\n");
+	printk("Example:\n\tTo read from I2C Devices\n\t\techo -f 0 -l 64 && cat /proc/i2c/i2c-0/eeprom1\n");
+	printk("Example:\n\tTo write to I2C Devices\n\t\techo -f 0 -l 64 -d 123456789abcdefgh...\n");
+}
+
+/**
+ * proc_i2c_atoui - Array to integer function
+ */
+int proc_i2c_atoui (const char* str)
+{
+   int val=0;
+   while (*str >= '0' && *str <='9') {
+        val *= 10;
+        val += (*str++ - '0');
+   }
+   return (val);
+}
+
+
+
+/**
+ * proc_i2c_strtok - Split a string into tokens
+ */
+char *proc_isc_strtok = NULL;
+char * proc_i2c_strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : proc_isc_strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		proc_isc_strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	proc_isc_strtok = send;
+	return (sbegin);
+}
+
+/**
+ * proc_i2c_parse_option - Parse the command line passed with echo function
+ */
+static int proc_i2c_parse_option(const char *string, unsigned int *offset, 
+	                                                    unsigned int *size, char **buf, unsigned int length)
+{
+	char *str = (char *)string;
+	char *token;
+	int of = -1;
+	int sz = -1;
+
+	PROC_I2C_PRINT("Entry: %s: string:%s\n",
+		__FUNCTION__, string);
+	
+	if (str == NULL)
+		return -EINVAL;
+
+	if ((offset == NULL) && (size == NULL) && (*buf == NULL))
+		return -ENOMEM;
+
+	*offset = 0;
+	*size = 0;
+	*buf = NULL;
+
+	token = proc_i2c_strtok(str, " ");
+
+	PROC_I2C_PRINT("%s: token = %s\n", 
+		__FUNCTION__, token);
+
+	while (token != NULL) {
+		if ((strcmp(token, "-offset") == 0) || (strcmp(token, "-f") == 0)) {
+			token = proc_i2c_strtok(NULL, " ");
+			if (token != NULL)
+				of = proc_i2c_atoui(token);
+		}
+		else if ((strcmp(token, "-length") == 0) || (strcmp(token, "-l") == 0)) {
+			token = proc_i2c_strtok(NULL, " ");
+			if (token != NULL)
+				sz = proc_i2c_atoui(token);
+		}
+		else if ((strcmp(token, "-data") == 0) || (strcmp((token + 1), "-d") == 0)) {
+			token = proc_i2c_strtok(NULL, " ");
+			if (token != NULL)
+				*buf = token;
+		}
+		else if ((strcmp(token, "-help") == 0) || (strcmp((token + 1), "-h") == 0)) 
+			return -1;
+
+		token = proc_i2c_strtok(NULL, " ");
+		PROC_I2C_PRINT("%s: token = %s\n", 
+		__FUNCTION__, token);
+
+	}
+
+	if ((sz == -1) && (of == -1)) {
+		*offset = sz = 0;
+		*size = of = 0;
+		*buf = (char *)string;
+	}
+
+	if ((sz == -1) || (of == -1))
+		return -1;
+
+	*offset = of;
+	*size = sz;
+
+	PROC_I2C_PRINT("Exit: %s: offset = %d, size = %d, buffer = Addr:0x%x, Str:%s\n", 
+		__FUNCTION__, *offset, *size, *buf, *buf);
+
+	return 0;
+}
+
+#if 0
+/**
+ * proc_i2c_get_device_info - Proc entry device information
+ */
+static struct i2c_proc_entry_t *proc_i2c_get_device_info(struct file *file)
+{
+	int index = 0;
+	//char *file_name = file->f_path.dentry->d_name.name;
+	struct i2c_proc_entry_t *entry = i2c_proc_entry;
+
+	PROC_I2C_PRINT("%s: file->f_path.dentry->d_name.name=%s\n", 
+                               __FUNCTION__, file->f_path.dentry->d_name.name);
+
+	for (index = 0; index < ((sizeof (i2c_proc_entry))/(sizeof (struct i2c_proc_entry_t))); index++)
+		if (strcmp(entry->i2c_dev_name, file->f_path.dentry->d_name.name) == 0)
+			break;
+
+	printk ("%s: Proc entry index=%d\n", index);
+
+	return (entry + index);
+}
+#endif
+
+
+/**
+ * proc_i2c_get_adapter - Gets the I2C adapter on the respective bus
+ */
+static struct i2c_adapter*proc_i2c_get_adapter(unsigned int bus_no)
+{
+	int  adapno;
+	struct i2c_adapter* adap = NULL;
+
+	/*Get the Adpaterno i.e. i2c_adapter->nr corresponding bus no*/
+	adapno = i2c_get_adapterno(bus_no);
+	PROC_I2C_PRINT("proc_i2c_get_adapter: adapno=%d\n", adapno);
+	if (adapno == -ENODEV) /*wrong uBus no passed, no adapter*/
+		return NULL;
+
+	/*Get the i2c_adapter object corresponding to adapter no... to be used in i2c_transfer function*/
+	adap = i2c_get_adapter(adapno);
+	PROC_I2C_PRINT("proc_i2c_get_adapter: adap=0x%x\n", adap);
+	if (adap == NULL)
+		return NULL;
+
+	return adap;
+}
+
+
+/**
+ * proc_create_i2c_msg - Creates the i2c message for transfer
+ */
+static void proc_create_i2c_msg(struct i2c_msg* msg, unsigned int addr, int flag, unsigned int length, char *buffer)
+{
+	if (msg == NULL)
+		return;
+
+	memset (msg, 0 , sizeof (struct i2c_msg));
+	
+	msg->addr = (u32)addr;
+	msg->flags = (u8)flag;
+	msg->len = (__u16)length;
+	msg->buf = buffer;
+
+	PROC_I2C_PRINT("%s : i2c_msg:addr = 0x%x, flags = %d, len = %d, buffer = 0x%x\n", 
+		__FUNCTION__, msg->addr, msg->flags, msg->len, msg->buf);
+}
+
+
+/********************************
+ *      Following are the gule function
+ ********************************/
+/**
+ * proc_i2c_open - glue function
+ *
+ */
+static int proc_i2c_open(struct inode *inode, struct file *file)
+{
+	int index = 0;
+	struct i2c_proc_entry_t *proc = i2c_proc_entry;
+	struct proc_i2c_data *data = kmalloc(sizeof(struct proc_i2c_data), GFP_KERNEL);
+	struct i2c_adapter *adap = NULL;
+
+	PROC_I2C_PRINT("Entry: %s: Device Name %s\n", 
+		__FUNCTION__,
+		file->f_path.dentry->d_name.name);
+
+	PROC_I2C_PRINT ("I2C Dev: %s on the Bus Number: %d with Device Address: 0x%x\n", 
+		proc->i2c_dev_name, 
+		proc->device_bus_num,
+		proc->device_addr);
+
+	for (index = 0; index < ((sizeof (i2c_proc_entry))/(sizeof (struct i2c_proc_entry_t))); index++, proc++)
+		if (strcmp(proc->i2c_dev_name, file->f_path.dentry->d_name.name) == 0)
+			break;
+
+	memset (data, 0, sizeof (struct proc_i2c_data));
+	mutex_init(&data->lock);	
+
+	if (data) {
+		data->entry = proc;
+
+		data->buf = kmalloc(data->size = PAGE_SIZE, GFP_KERNEL);
+		if (!data->buf)
+			return -ENOMEM;
+
+		data->msg = kzalloc(sizeof(struct i2c_msg), GFP_KERNEL);;
+		if (!data->msg)
+			return -ENOMEM;
+
+		adap = proc_i2c_get_adapter(proc->device_bus_num);
+		if (adap == NULL)
+			return -ENODEV;
+		
+		data->private = (void *)adap;
+	}
+	else
+		return -ENOMEM;
+
+	file->private_data = (void *)data;
+
+	PROC_I2C_PRINT("Exit: %s\n", __FUNCTION__);
+	return 0;
+
+}
+
+
+
+
+
+/**
+ * proc_i2c_release - glue function
+ */
+static int proc_i2c_release(struct inode *inode, struct file *file)
+{
+	struct proc_i2c_data *data = (struct proc_i2c_data *)file->private_data;
+	
+	PROC_I2C_PRINT("Entry: %s\n", __FUNCTION__);
+
+	kfree (data->msg);
+	kfree (data->buf);
+	kfree (data);
+
+	PROC_I2C_PRINT("Exit: %s\n", __FUNCTION__);
+	return 0;
+
+}
+
+
+
+/**
+ * proc_i2c_read - handle reads from /proc/i2c/i2c-n/<devicename>
+ * @file: not used
+ * @buf: buffer to write
+ * @length: length of buf, at most PAGE_SIZE
+ * @ppos: not used
+ */
+static ssize_t proc_i2c_read(struct file *file, char __user *buf,
+			       size_t length, loff_t *ppos)
+{
+	struct proc_i2c_data *data = (struct proc_i2c_data *)file->private_data;
+	struct i2c_adapter *adap = (struct i2c_adapter *)data->private;
+	struct i2c_proc_entry_t *proc =  (struct i2c_proc_entry_t *)data->entry;
+	unsigned int size = 0, read_size = 0, remain = 0;
+	unsigned int read_pos = 0;
+	struct i2c_msg* msg = data->msg;
+	unsigned char *buffer;
+	int ret;
+
+	PROC_I2C_PRINT("Entry: %s file = 0x%x, buf = 0x%x, length = %d, ppos = %d,  data = 0x%x, adap: adap = 0x%x\n", 
+		__FUNCTION__, file, buf,length, *ppos, data, adap);
+	
+	if ((!data) && (!adap) && (!proc))
+		return -ENODEV;
+
+
+	if (proc->trans_buffer_size == 0) {
+#if 0		
+		PROC_I2C_PRINT("I2C Procfs: 0 bytes read from: %d device, use the following read/write:\n");
+		proc_print_help();
+#endif		
+		return 0;
+	}
+
+	PROC_I2C_PRINT("%s: reading with agrs: offset = %d, size = %d\n", 
+		__FUNCTION__, proc->current_offset, proc->trans_buffer_size);
+
+	memset (msg, 0, sizeof (struct i2c_msg));
+	memset (data->buf, 0, data->size);
+
+
+	/* Read Sequence */
+	mutex_lock(&data->lock);
+
+	PROC_I2C_PRINT("%s: Seeks the device to %d pos\n", 
+		__FUNCTION__, read_pos);
+
+	/* Move to the respective position */
+	if (read_pos != proc->current_offset) 
+	{
+		*(data->buf + 0) =  (unsigned char)((read_pos >> 8) & 0xFF);
+		*(data->buf + 1) =  (unsigned char)(read_pos & 0xFF);
+		proc_create_i2c_msg(msg, proc->device_addr, 0, 2, data->buf);
+
+	        /*Call the I2C native API to execute a single or combined I2C message*/
+	        ret = i2c_transfer(adap, msg, 1);
+		 if (ret < 0)
+		 	goto READ_FAULT;
+
+		 proc->current_offset = read_pos;
+	}
+
+	buffer = (unsigned char*)buf;
+
+	PROC_I2C_PRINT("%s: Read loop started for size: %d\n", 
+		__FUNCTION__, proc->trans_buffer_size);
+
+	while(read_size < (unsigned int)proc->trans_buffer_size)
+	{
+		size = (data->size < proc->trans_buffer_size) ? data->size: proc->trans_buffer_size;
+		
+		proc_create_i2c_msg(msg, proc->device_addr, 1, size, data->buf);
+
+	        /*Call the I2C native API to execute a single or combined I2C message*/
+	        ret = i2c_transfer(adap, msg, 1);
+		 if (ret < 0)
+		 	goto READ_FAULT;
+
+		read_size += size;
+		proc->current_offset += size;
+		read_pos += size;
+
+		ret = copy_to_user(buffer, data->buf, size);
+		if (ret)
+			goto READ_FAULT;
+		buffer += size;
+		remain -= size;
+	}
+
+	proc->trans_buffer_size = 0;
+
+	mutex_unlock(&data->lock);
+	PROC_I2C_PRINT("Exit: %s: Read loop completed size data: %d red\n", 
+		__FUNCTION__, read_size);
+
+	return read_size;
+
+READ_FAULT:
+	PROC_I2C_PRINT("Exit: %s error\n", __FUNCTION__);
+	mutex_unlock(&data->lock);
+	return ret;
+}
+
+
+
+
+
+/**
+ * proc_i2c_write - handle writes to /proc/i2c/i2c-n/<devicename>
+ * @file: not used
+ * @buf: buffer to write
+ * @length: length of buf, at most PAGE_SIZE
+ * @ppos: not used
+ *
+ */
+static ssize_t proc_i2c_write(struct file *file, const char __user *buf, size_t length, loff_t *ppos)
+{
+	struct proc_i2c_data *data = (struct proc_i2c_data *)file->private_data;
+	struct i2c_adapter *adap = (struct i2c_adapter *)data->private;
+	struct i2c_proc_entry_t *proc =  (struct i2c_proc_entry_t *)data->entry;
+	unsigned int size = 0, write_size = 0, write_length = 0;
+	unsigned int write_pos = 0;
+	struct i2c_msg* msg = data->msg;
+	char *buffer = (char *)buf;
+	int ret;
+
+	PROC_I2C_PRINT("Entry: %s file = 0x%x, buf = 0x%x, buf str = %s, length = %d, ppos = %d\n", 
+		__FUNCTION__, file, buf, buf, length, *ppos);
+
+	if ((!data) && (!adap) && (!proc))
+		return -ENODEV;
+
+	if ((proc->trans_buffer_size == 0) &&
+		(proc_i2c_parse_option(buf, &write_pos, &write_length, &buffer, length) < 0))
+	{
+		proc_print_help();
+		return length;
+	}
+
+	if ((write_length == 0) && (proc->io_block_size == 0)) {
+		proc->trans_buffer_size = length;
+		write_length = length;
+	}
+	else {
+		if (write_length == 0) {
+			proc->trans_buffer_size = (length > proc->io_block_size) ? proc->io_block_size : length;
+		}
+		else {
+			proc->trans_buffer_size = write_length;
+			proc->io_block_size = write_length;
+		}
+	}
+
+	write_length = proc->trans_buffer_size;
+	memset (msg, 0, sizeof (struct i2c_msg));
+	memset (data->buf, 0, data->size);
+
+	if (buffer == NULL) {
+		PROC_I2C_PRINT("%s No data write, just sets the argument offset = %d, size = %d\n", 
+		__FUNCTION__, write_pos, write_length);
+
+		mutex_lock(&data->lock);
+		/* Move to the respective position */
+		if (write_pos != proc->current_offset) 
+		{
+			*(data->buf + 0) =  (unsigned char)((write_pos >> 8) & 0xFF);
+			*(data->buf + 1) =  (unsigned char)(write_pos & 0xFF);
+			proc_create_i2c_msg(msg, proc->device_addr, 0, 2, data->buf);
+
+		        /*Call the I2C native API to execute a single or combined I2C message*/
+		        ret = i2c_transfer(adap, msg, 1);
+			 if (ret < 0)
+			 	goto WRITE_FAULT;
+
+			 proc->current_offset = write_pos;
+		}
+		mutex_unlock(&data->lock);
+
+		return length;		
+	}
+		
+	mutex_lock(&data->lock);
+
+	PROC_I2C_PRINT("%s Write loop starts with size %d\n", 
+		__FUNCTION__, write_length);
+
+	while(write_size < (unsigned int)proc->trans_buffer_size)
+	{
+		size = proc->page_size - ((write_pos + write_size) % proc->page_size);
+		size = (size < (write_length - write_size)) ? size: (write_length - write_size);
+
+		*(data->buf + 0) =  (unsigned char)((write_pos >> 8) & 0xFF);
+		*(data->buf + 1) =  (unsigned char)(write_pos & 0xFF);
+
+		if (copy_from_user((data->buf + 2), buffer, size)){
+		   mutex_unlock(&data->lock);
+                   return -EFAULT;
+		}
+
+		proc_create_i2c_msg(msg, proc->device_addr, 0, (size + 2), data->buf);
+
+	        /*Call the I2C native API to execute a single or combined I2C message*/
+	        ret = i2c_transfer(adap, msg, 1);
+		 if (ret < 0)
+		 	goto WRITE_FAULT;
+
+		write_size += size;
+		write_pos +=size;
+		proc->current_offset += size;
+		buffer += size;
+	}
+
+	mutex_unlock(&data->lock);
+	PROC_I2C_PRINT("Exit: %s Write loop completed %d wrote\n", 
+		__FUNCTION__, write_length);
+
+	proc->trans_buffer_size =  (proc->trans_buffer_size == length) ? 0: \
+                                                                                proc->trans_buffer_size;
+	return (write_size + (length -write_size));
+
+WRITE_FAULT:
+	PROC_I2C_PRINT("Exit: %s error\n", __FUNCTION__);
+	mutex_unlock(&data->lock);
+	return ret;
+}
+
+
+/**
+ * proc_i2c_lseek - glue function
+ */
+
+static loff_t proc_i2c_lseek(struct file *file, loff_t offset, int origin)
+{
+	struct proc_i2c_data *data = (struct proc_i2c_data *)file->private_data;
+	struct i2c_adapter *adap = (struct i2c_adapter *)data->private;
+	struct i2c_proc_entry_t *proc =  (struct i2c_proc_entry_t *)data->entry;
+	unsigned int seek_pos = 0;
+	struct i2c_msg* msg = NULL;
+ 	int ret = 0;
+
+	PROC_I2C_PRINT("Entry: %s file = 0x%x, offset = %d, origin = %d\n", 
+		__FUNCTION__, offset, origin);
+
+	if ((!data) && (!adap) && (!proc))
+		return -ENODEV;
+
+	/*Prepare i2c_msg buffer*/
+	msg = kzalloc(sizeof(struct i2c_msg) , GFP_KERNEL); 
+	if (!msg)
+		return -ENODEV;
+
+	seek_pos = ((unsigned int)offset + origin);
+
+	/* grab buffer if we didn't have one */
+	if (!data->buf) {
+		data->buf = kmalloc(data->size = PAGE_SIZE, GFP_KERNEL);
+		if (!data->buf) {
+			return -ENOMEM;
+		}
+	}
+	
+
+	/* Read Sequence */
+	mutex_lock(&data->lock);
+
+	PROC_I2C_PRINT("%s Seek started with %d offset, %d origin\n", 
+		__FUNCTION__, seek_pos, origin);
+
+	/* Move to the respective position */
+	if (seek_pos != proc->current_offset) 
+	{
+		*(data->buf + 0) =  (unsigned char)((seek_pos >> 8) & 0xFF);
+		*(data->buf + 1) =  (unsigned char)(seek_pos & 0xFF);
+		proc_create_i2c_msg(msg, proc->device_addr, 0, 2, data->buf);
+
+	        /*Call the I2C native API to execute a single or combined I2C message*/
+	        ret = i2c_transfer(adap, msg, 1);
+		 if (ret < 0) {
+			PROC_I2C_PRINT("%s i2c_transfer error = %d\n", __FUNCTION__, ret);
+		 	return -1;
+		};
+
+		 proc->current_offset = seek_pos;
+	}
+
+	PROC_I2C_PRINT("Exit: %s completed\n", __FUNCTION__);
+
+	mutex_unlock(&data->lock);
+	return seek_pos;
+}
+
+/**
+ * proc_i2c_ioctl - glue function
+ */
+
+static int proc_i2c_ioctl(struct inode *inode, struct file *file, unsigned int flag, unsigned long args)
+{
+	struct i2c_proc_entry_t *proc = (struct i2c_proc_entry_t *)((struct proc_i2c_data *)file->private_data)->entry;
+	proc_i2c_dev_info_t *p = NULL;
+	unsigned int option = flag;
+	unsigned int offset = 0;
+	unsigned int size = 0;
+	int ret = 0;
+
+	PROC_I2C_PRINT("Entry: %s file = 0x%x, flag = %d, args = 0x%x\n", 
+		__FUNCTION__, file, flag, (unsigned int)args);
+
+	printk("Entry: %s file = 0x%x, flag = %d, args = 0x%x\n", 
+		__FUNCTION__, (unsigned int)file, flag, (unsigned int)args);
+	switch(option)
+	{
+	case PROC_I2C_IOCTL_DEV_INFO:
+		p = (proc_i2c_dev_info_t *)args;
+		if (p != NULL) {
+			if (copy_to_user ((void __user *)&p->name, &proc->i2c_dev_name, strlen(proc->i2c_dev_name)))
+                           return -EFAULT;
+			if (copy_to_user ((void __user *)&p->device_addr, &proc->device_addr, sizeof (unsigned int)))
+                           return -EFAULT;
+			if (copy_to_user ((void __user *)&p->device_bus_num, &proc->device_bus_num, sizeof (unsigned int)))
+                           return -EFAULT;
+		}
+		else { 
+			printk("Proc i2c IOCTL: Invalid IOCLT\n");
+			ret = -EINVAL;
+		}
+ 		break;
+	case PROC_I2C_IOCTL_SEEK:
+		p = (proc_i2c_dev_info_t *)args;
+		if (p != NULL) {
+			offset = p->offset;
+			ret = proc_i2c_lseek(file, offset, SEEK_SET);
+			if ( ret < 0) {
+				printk("Proc i2c IOCTL: Seek failed to offset: %d\n", offset);
+			}
+		}
+		else {
+			printk("Proc i2c IOCTL: Invalid IOCLT\n");
+			ret = -EINVAL;
+		}
+
+		break;
+	case PROC_I2C_IOCTL_READ:
+		p = (proc_i2c_dev_info_t *)args;
+		if (p != NULL) {
+			offset = p->offset;
+			size = p->size;
+			ret = proc_i2c_read(file, p->buffer, size, (loff_t *)&offset);
+			if (ret < 0) 
+				printk("Proc i2c IOCTL: Read failed\n");
+		}
+		else {
+			printk("Proc i2c IOCTL: Invalid IOCLT\n");
+			ret = -EINVAL;
+		}
+		break;
+	case PROC_I2C_IOCTL_WRITE:
+		p = (proc_i2c_dev_info_t *)args;
+		if (p != NULL) {
+			offset = p->offset;
+			size = p->size;
+			ret = proc_i2c_write(file, p->buffer, size, (loff_t *)&offset);
+			if (ret < 0) 
+				printk("Proc i2c IOCTL: Read failed\n");
+		}
+		else {
+			printk("Proc i2c IOCTL: Invalid IOCLT\n");
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		printk("Proc i2c IOCTL: Not supported\n");
+		ret = -EINVAL;
+	}
+	
+	PROC_I2C_PRINT("Exit: %s Completed ret = 0x%d\n",__FUNCTION__, ret);
+	return ret;
+}
+
+
+
+static const struct file_operations proc_i2c_operations = {
+	.owner		= THIS_MODULE,
+	.open		= proc_i2c_open,
+	.release        = proc_i2c_release,
+	.read		= proc_i2c_read,
+	.write		= proc_i2c_write,
+	.ioctl          = proc_i2c_ioctl,
+	.llseek		= proc_i2c_lseek,
+};
+
+
+static struct proc_dir_entry *proc_i2c;
+static struct proc_dir_entry *proc_i2c_bus[PROC_NUM_I2C_BUS];
+
+/**
+ * i2c_init_procfs - create i2c folders, sunfolders and devices in procfs
+ */
+int __init i2c_init_procfs(void)
+{
+	struct proc_dir_entry *pde;
+	int folder  = 0;
+	struct i2c_proc_entry_t *entry = i2c_proc_entry;
+	char proc_name_file[PROC_MAX_I2C_DEV_NAME];
+ 
+	PROC_I2C_PRINT("Entry: %s\n",__FUNCTION__);
+
+	proc_i2c = proc_mkdir(PROC_I2C_FLD, NULL);
+	if (!proc_i2c)
+		goto err1;
+
+	proc_i2c->owner = THIS_MODULE;
+
+	for (folder = 0; folder <PROC_NUM_I2C_BUS; folder++)
+	{
+		memset (proc_name_file, 0, sizeof(proc_name_file));
+		sprintf(proc_name_file, "i2c-%d", folder);
+		proc_i2c_bus[folder] = proc_mkdir(proc_name_file, proc_i2c);
+		if (!proc_i2c_bus[folder]) {
+			PROC_I2C_PRINT("Exit: %s error in proc_mkdir %s\n",__FUNCTION__, proc_name_file);
+			goto err1;
+		}
+		proc_i2c_bus[folder]->owner = THIS_MODULE;
+	}
+
+       while (entry->i2c_dev_name != NULL)
+       {
+       	if (entry->device_addr != 0)
+       	{
+	       	pde = proc_create(entry->i2c_dev_name, 0, proc_i2c_bus[entry->device_bus_num], &proc_i2c_operations);
+			if (!pde) 
+			{
+				PROC_I2C_PRINT("Exit: %s error in proc_create=%s\n",__FUNCTION__, entry->i2c_dev_name);
+				goto err2;
+			}
+       	}
+		entry++;
+       }
+
+	PROC_I2C_PRINT("Exit: %s\n",__FUNCTION__);
+	return 0;
+err2:
+	PROC_I2C_PRINT("Exit: %s error exit1\n",__FUNCTION__);
+	remove_proc_entry("i2c", NULL);
+err1:
+	PROC_I2C_PRINT("Exit: %s error exit2\n",__FUNCTION__);
+	return -ENOMEM;
+}
+
+/**
+ * i2c_exit_procfs - Remove i2c folders, sunfolders and devices from procfs
+ */
+void i2c_exit_procfs(void)
+{
+	char i2c_proc_entry_name[PROC_MAX_I2C_DEV_NAME];
+	int index  = 0;
+	
+       for (index = 0; index < PROC_NUM_I2C_BUS; index++)
+       {
+             memset (i2c_proc_entry_name, 0, sizeof (i2c_proc_entry_name));
+             sprintf(i2c_proc_entry_name, "i2c/i2c-%d", index);
+             remove_proc_entry("i2c/i2c-%d", NULL);
+       }
+	remove_proc_entry("i2c", NULL);
+}
+
+
+MODULE_DESCRIPTION("I2C /procfs entries driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_init_procfs);
+module_exit(i2c_exit_procfs);
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/i2c-proc.h linux-2.6.34/drivers/i2c/i2c-proc.h
--- linux-2.6.34.orig/drivers/i2c/i2c-proc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/i2c/i2c-proc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * linux/drivers/i2c/i2c-proc.h
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *--------------------------------------------------------------------------
+ * %filename:     i2c-proc.c %
+ *--------------------------------------------------------------------------
+ * description    : This file is the header the I2C Procfs access implementation for IP_3203
+ *
+ *--------------------------------------------------------------------------
+ */
+
+
+#ifndef __H_I2C_PROC_H__
+#define __H_I2C_PROC_H__
+
+/* i2c devices name string max size */
+#define PROC_MAX_I2C_DEV_NAME (128)
+
+
+typedef struct {
+	char name[PROC_MAX_I2C_DEV_NAME];
+	unsigned int device_bus_num;
+	unsigned int device_addr;
+	unsigned char *buffer;
+	unsigned int offset;
+	unsigned int size;
+} proc_i2c_dev_info_t;
+
+#define PROC_I2C_DEV_EEPROM1_NAME "eeprom1"
+#define PROC_I2C_DEV_EEPROM2_NAME "eeprom2"
+#define PROC_I2C_DEV_GPIO_EXPANDER_NAME "gpio_expander"
+
+#define PROC_I2C_DEV_EEPROM1_ADDR (0x50)
+#define PROC_I2C_DEV_EEPROM2_ADDR (0x52)
+#define PROC_I2C_DEV_GPIO_EXPANDER_ADDR (0x74)
+
+
+/* IOCTL defines */
+#define PROC_I2C_IOCTL_DEV_INFO   0x01
+#define PROC_I2C_IOCTL_SEEK            0x02
+#define PROC_I2C_IOCTL_READ            0x03
+#define PROC_I2C_IOCTL_WRITE          0x04
+
+
+#endif /* __H_I2C_PROC_H__ */
+
diff -Naurp linux-2.6.34.orig/drivers/i2c/Makefile linux-2.6.34/drivers/i2c/Makefile
--- linux-2.6.34.orig/drivers/i2c/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/i2c/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -6,6 +6,7 @@ obj-$(CONFIG_I2C_BOARDINFO)	+= i2c-board
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_SMBUS)		+= i2c-smbus.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
+obj-$(CONFIG_I2C_PROCFS_INTERFACE)	+= i2c-proc.o
 obj-y				+= algos/ busses/
 
 ifeq ($(CONFIG_I2C_DEBUG_CORE),y)
diff -Naurp linux-2.6.34.orig/drivers/Kconfig linux-2.6.34/drivers/Kconfig
--- linux-2.6.34.orig/drivers/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -110,5 +110,7 @@ source "drivers/xen/Kconfig"
 
 source "drivers/staging/Kconfig"
 
+source "drivers/gcs_dmac/Kconfig"
+
 source "drivers/platform/Kconfig"
 endmenu
diff -Naurp linux-2.6.34.orig/drivers/Makefile linux-2.6.34/drivers/Makefile
--- linux-2.6.34.orig/drivers/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -6,6 +6,7 @@
 #
 
 obj-y				+= gpio/
+obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -37,6 +38,7 @@ obj-$(CONFIG_FB_I810)           += video
 obj-$(CONFIG_FB_INTEL)          += video/intelfb/
 
 obj-y				+= serial/
+obj-y				+= gcs_dmac/
 obj-$(CONFIG_PARPORT)		+= parport/
 obj-y				+= base/ block/ misc/ mfd/
 obj-$(CONFIG_NUBUS)		+= nubus/
@@ -102,7 +104,6 @@ obj-$(CONFIG_CRYPTO)		+= crypto/
 obj-$(CONFIG_SUPERH)		+= sh/
 obj-$(CONFIG_ARCH_SHMOBILE)	+= sh/
 obj-$(CONFIG_GENERIC_TIME)	+= clocksource/
-obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_DCA)		+= dca/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
@@ -113,3 +114,4 @@ obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-$(CONFIG_DCS_NETWORK_SUPPORT)	+= dcs_net/
diff -Naurp linux-2.6.34.orig/drivers/mmc/card/Kconfig linux-2.6.34/drivers/mmc/card/Kconfig
--- linux-2.6.34.orig/drivers/mmc/card/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/card/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -50,3 +50,11 @@ config MMC_TEST
 
 	  This driver is only of interest to those developing or
 	  testing a host driver. Most people should say N here.
+
+config MMC_TEST_NX_SDIOMC_PATTERN
+	bool "Only pattern tests for MMC host driver"
+  depends on MMC_TEST
+	default n
+	help
+	  Pattern testcases that effectively tests each of SD_DAT lines
+
diff -Naurp linux-2.6.34.orig/drivers/mmc/card/mmc_test.c linux-2.6.34/drivers/mmc/card/mmc_test.c
--- linux-2.6.34.orig/drivers/mmc/card/mmc_test.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/card/mmc_test.c	2010-09-07 22:16:40.000000000 -0500
@@ -463,10 +463,15 @@ static int mmc_test_transfer(struct mmc_
 
 struct mmc_test_case {
 	const char *name;
-
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+  int (*prepare)(struct mmc_test_card *test, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size);
+  int (*run)(struct mmc_test_card *test, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size);
+  int (*cleanup)(struct mmc_test_card *test, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size);
+#else
 	int (*prepare)(struct mmc_test_card *);
 	int (*run)(struct mmc_test_card *);
 	int (*cleanup)(struct mmc_test_card *);
+#endif
 };
 
 static int mmc_test_basic_write(struct mmc_test_card *test)
@@ -895,7 +900,178 @@ static int mmc_test_multi_read_high(stru
 
 #endif /* CONFIG_HIGHMEM */
 
+
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+
+#define TEST_WRITE (1)
+#define TEST_READ (0)
+#define MY_TEST_BLOCK_SIZE (512)
+
+void my_test_fill_pattern( u32 *p_buffer, u32 pattern, int len)
+{
+  u8 *pbuf = (u8*) p_buffer;
+  while(len > 0) {
+    pbuf[3]=pattern & 0xFF;
+    pbuf[2]= ((pattern & 0xFF00) >> 8);
+    pbuf[1]= ((pattern & 0xFF0000) >> 16);
+    pbuf[0]= ((pattern & 0xFF000000) >> 24);
+//    *p_buffer = pattern;
+    pbuf+=4;
+    //p_buffer++;
+    len-=4;
+  }
+}
+
+int my_test_init_buff_etc(struct mmc_test_card *test, 
+    u32 **p_buffer, 
+    u32 pattern, 
+    int size,
+    unsigned long *p_addr_incr,
+    struct scatterlist *p_sg)
+{
+  *p_buffer = kmalloc(size, GFP_KERNEL);
+  if(!*p_buffer) {
+    printk(KERN_ERR "Unable to allocate memory\n");
+    return -1;
+  }
+
+  my_test_fill_pattern( *p_buffer, pattern, size );
+
+  if(test->card->state & MMC_STATE_BLOCKADDR ){
+    *p_addr_incr = (size/MY_TEST_BLOCK_SIZE);
+  }
+  else {
+    *p_addr_incr = size;
+  }
+
+  sg_init_one(p_sg, *p_buffer, size);
+
+  return 0;
+}
+
+int my_test_compare(u32 *p_buffer, u32 val, int size )
+{
+  int i=0;
+  u32 new_val;
+  int err = 0;
+  u32 pattern=0;
+  u32 new_val_conv=0;
+
+  pattern = ((val & 0xFF) << 24);
+  pattern |= (((val & 0xFF00) >> 8) << 16);
+  pattern |= (((val & 0xFF0000) >> 16) << 8);
+  pattern |= ((val & 0xFF000000) >> 24);
+  
+  for(i=0;i<size;i+=4) {
+    new_val = *p_buffer;
+    if(new_val != pattern) {
+      new_val_conv = ((new_val & 0xFF) << 24);
+      new_val_conv |= (((new_val & 0xFF00) >> 8) << 16);
+      new_val_conv |= (((new_val & 0xFF0000) >> 16) << 8);
+      new_val_conv |= ((new_val & 0xFF000000) >> 24);
+      printk(KERN_ERR "Data not equal: Value read @0x%08X is 0x%08X , expected is 0x%08X\n", i, new_val_conv, val);
+      err++;
+      break;
+    }
+    p_buffer++;
+  }
+  //if(!err)
+  //  printk(KERN_ERR "Data are equal\n");
+
+  return err;
+}
+
+
+static int my_test_multi_block_write_data(struct mmc_test_card *test, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size)
+{
+  u32 *p_buffer;
+  int ret;
+  unsigned int size;
+  struct scatterlist sg;
+  unsigned long addr_incr;
+
+  printk(KERN_ERR "pattern=0x%08X adma_size=0x%08X tfr_size=0x%08X\n", pattern, adma_size, tfr_size);
+  ret = my_test_init_buff_etc(test, &p_buffer, pattern, adma_size, &addr_incr, &sg);
+  if(ret) return ret;
+
+  ret = mmc_test_set_blksize(test, MY_TEST_BLOCK_SIZE);
+  if(ret) {
+    kfree(p_buffer);
+    return ret;
+  }
+
+  for(size=0;size < tfr_size; size+= adma_size) {
+    ret = mmc_test_simple_transfer(test, &sg, 1, dev_addr, 
+        (adma_size/MY_TEST_BLOCK_SIZE), MY_TEST_BLOCK_SIZE, TEST_WRITE);
+    if(ret) {
+      printk(KERN_ERR "block_write failed @ 0x%08X with error=%d\n", dev_addr, ret);
+      break;
+    }
+    dev_addr += addr_incr;
+  }
+
+  kfree(p_buffer);
+  return ret;
+}
+
+
+static int my_test_multi_block_read_data(struct mmc_test_card *test, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size)
+{
+  u32 *p_buffer;
+  int ret;
+  unsigned int size;
+  struct scatterlist sg;
+  unsigned long addr_incr;
+
+  printk(KERN_ERR "pattern=0x%08X adma_size=0x%08X tfr_size=0x%08X\n", pattern, adma_size, tfr_size);
+  ret = my_test_init_buff_etc(test, &p_buffer, 0x00, adma_size, &addr_incr, &sg);
+  if(ret) return ret;
+
+  ret = mmc_test_set_blksize(test, MY_TEST_BLOCK_SIZE);
+  if(ret) {
+    kfree(p_buffer);
+    return ret;
+  }
+
+  for(size=0;size < tfr_size; size+= adma_size) {
+    ret = mmc_test_simple_transfer(test, &sg, 1, dev_addr, 
+        (adma_size/MY_TEST_BLOCK_SIZE), MY_TEST_BLOCK_SIZE, TEST_READ);
+    if(ret) {
+      printk(KERN_ERR "block_read failed @ 0x%08X with error=%d\n", dev_addr, ret);
+      break;
+    }
+    ret = my_test_compare(p_buffer, pattern, adma_size);
+    if(ret) {
+      printk(KERN_ERR "block_read compare failed @ 0x%08X with error=%d\n", dev_addr, ret);
+      break;
+    }
+    dev_addr += addr_incr;
+  }
+
+  kfree(p_buffer);
+  return ret;
+
+}
+
+#endif
+
+
+
 static const struct mmc_test_case mmc_test_cases[] = {
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+  {
+    .name = "Multi_block_write with a pattern",
+    .prepare = NULL,
+    .run = my_test_multi_block_write_data,
+    .cleanup = NULL,
+  },
+  {
+    .name = "Multi_block_read with a pattern",
+    .prepare = NULL,
+    .run = my_test_multi_block_read_data,
+    .cleanup = NULL,
+  },
+#else
 	{
 		.name = "Basic write (no data verification)",
 		.run = mmc_test_basic_write,
@@ -1042,11 +1218,16 @@ static const struct mmc_test_case mmc_te
 
 #endif /* CONFIG_HIGHMEM */
 
+#endif /* CONFIG_MMC_TEST_NX_SDIOMC_PATTERN */
 };
 
 static DEFINE_MUTEX(mmc_test_lock);
 
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+static void mmc_test_run(struct mmc_test_card *test, int testcase, u32 pattern, u32 dev_addr, u32 adma_size, u32 tfr_size)
+#else
 static void mmc_test_run(struct mmc_test_card *test, int testcase)
+#endif
 {
 	int i, ret;
 
@@ -1064,8 +1245,12 @@ static void mmc_test_run(struct mmc_test
 			mmc_test_cases[i].name);
 
 		if (mmc_test_cases[i].prepare) {
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+      ret = mmc_test_cases[i].prepare(test, pattern, dev_addr, adma_size, tfr_size);
+#else
 			ret = mmc_test_cases[i].prepare(test);
-			if (ret) {
+#endif
+      if (ret) {
 				printk(KERN_INFO "%s: Result: Prepare "
 					"stage failed! (%d)\n",
 					mmc_hostname(test->card->host),
@@ -1074,7 +1259,11 @@ static void mmc_test_run(struct mmc_test
 			}
 		}
 
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+    ret = mmc_test_cases[i].run(test, pattern, dev_addr, adma_size, tfr_size);
+#else
 		ret = mmc_test_cases[i].run(test);
+#endif
 		switch (ret) {
 		case RESULT_OK:
 			printk(KERN_INFO "%s: Result: OK\n",
@@ -1100,7 +1289,11 @@ static void mmc_test_run(struct mmc_test
 		}
 
 		if (mmc_test_cases[i].cleanup) {
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+      ret = mmc_test_cases[i].cleanup(test, pattern, dev_addr, adma_size, tfr_size);
+#else
 			ret = mmc_test_cases[i].cleanup(test);
+#endif
 			if (ret) {
 				printk(KERN_INFO "%s: Warning: Cleanup "
 					"stage failed! (%d)\n",
@@ -1132,10 +1325,31 @@ static ssize_t mmc_test_store(struct dev
 	struct mmc_test_card *test;
 	int testcase;
 
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+  u32 pattern=0;
+  u32 dev_addr=0;
+  u32 adma_size=0;
+  u32 tfr_size=0;
+#endif
+
 	card = container_of(dev, struct mmc_card, dev);
 
 	testcase = simple_strtol(buf, NULL, 10);
 
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+  sscanf(buf, "%d 0x%X 0x%X 0x%X 0x%X", &testcase, &pattern, &dev_addr, &adma_size, &tfr_size);
+  printk(KERN_ERR "tc=%d pattern=0x%08X dev_addr=0x%08X adma_size=0x%08X tfr_size=0x%08X\n", testcase, pattern, dev_addr, adma_size, tfr_size);
+
+  if(adma_size == 0 || tfr_size==0) {
+    printk(KERN_ERR "Usage: <tc_num> <pattern> <dev_addr> <adma_size> <tfr_size>\n");
+    printk(KERN_ERR "<tc_num> --> 1 for write, 2 for read\n");
+    printk(KERN_ERR "<pattern> --> A 32-bit pattern to be written/read with car (in hex)\n");
+    printk(KERN_ERR "<dev_addr> --> Address in the card to write/read from (in hex). (in multiples of 512Bytes)\n");
+    printk(KERN_ERR "<adma_size> --> DMA size (in hex). (in multiples of 1024). Max 32KB\n");
+    printk(KERN_ERR "<tfr_size> --> Total transfer size (in multiples of 1024) (in hex)\n");
+    return -EIO;
+  }
+#endif 
 	test = kzalloc(sizeof(struct mmc_test_card), GFP_KERNEL);
 	if (!test)
 		return -ENOMEM;
@@ -1153,7 +1367,11 @@ static ssize_t mmc_test_store(struct dev
 	if (test->buffer) {
 #endif
 		mutex_lock(&mmc_test_lock);
+#ifdef CONFIG_MMC_TEST_NX_SDIOMC_PATTERN
+        mmc_test_run(test, testcase, pattern, dev_addr, adma_size, tfr_size);
+#else
 		mmc_test_run(test, testcase);
+#endif
 		mutex_unlock(&mmc_test_lock);
 	}
 
diff -Naurp linux-2.6.34.orig/drivers/mmc/core/mmc.c linux-2.6.34/drivers/mmc/core/mmc.c
--- linux-2.6.34.orig/drivers/mmc/core/mmc.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/core/mmc.c	2010-09-07 22:16:40.000000000 -0500
@@ -441,6 +441,11 @@ static int mmc_init_card(struct mmc_host
 		max_dtr = card->csd.max_dtr;
 	}
 
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_25MHZ
+  if(max_dtr > 25000000) {
+    max_dtr = 25000000;
+  }
+#endif
 	mmc_set_clock(host, max_dtr);
 
 	/*
diff -Naurp linux-2.6.34.orig/drivers/mmc/core/sd.c linux-2.6.34/drivers/mmc/core/sd.c
--- linux-2.6.34.orig/drivers/mmc/core/sd.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/core/sd.c	2010-09-07 22:16:40.000000000 -0500
@@ -464,8 +464,12 @@ static int mmc_sd_init_card(struct mmc_h
 	/*
 	 * Attempt to change to high-speed (if supported)
 	 */
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_NS_MODE
+  printk(KERN_ERR "%s: Staying in Normal-Speed mode\n", mmc_hostname(card->host));
+#else
 	err = mmc_switch_hs(card);
-	if (err)
+#endif
+  if (err)
 		goto free_card;
 
 	/*
@@ -480,6 +484,11 @@ static int mmc_sd_init_card(struct mmc_h
 		max_dtr = card->csd.max_dtr;
 	}
 
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_25MHZ
+  if(max_dtr > 25000000) {
+    max_dtr = 25000000;
+  }
+#endif
 	mmc_set_clock(host, max_dtr);
 
 	/*
diff -Naurp linux-2.6.34.orig/drivers/mmc/core/sd_ops.c linux-2.6.34/drivers/mmc/core/sd_ops.c
--- linux-2.6.34.orig/drivers/mmc/core/sd_ops.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/core/sd_ops.c	2010-09-07 22:16:40.000000000 -0500
@@ -20,6 +20,8 @@
 #include "core.h"
 #include "sd_ops.h"
 
+#undef NX_SDIOMC_MMC_PRINT_DATA
+
 static int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)
 {
 	int err;
@@ -345,6 +347,14 @@ int mmc_sd_switch(struct mmc_card *card,
 	if (data.error)
 		return data.error;
 
+#ifdef NX_SDIOMC_MMC_PRINT_DATA
+  {
+    int i=0;
+    for(i=0;i<64;i++) {
+      printk(KERN_WARNING "%s: resp[%d]=0x%02X\n", mmc_hostname(card->host), i, resp[i]);
+    }
+  }
+#endif
 	return 0;
 }
 
diff -Naurp linux-2.6.34.orig/drivers/mmc/host/Kconfig linux-2.6.34/drivers/mmc/host/Kconfig
--- linux-2.6.34.orig/drivers/mmc/host/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/host/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -412,3 +412,118 @@ config SDH_BFIN_MISSING_CMD_PULLUP_WORKA
 	depends on SDH_BFIN
 	help
 	  If you say yes here SD-Cards may work on the EZkit.
+
+config MMC_SDHCI_NX_SDIOMC
+	tristate "SD/SDIO/MMC host controller support on APOLLO boards"
+	depends on MMC_SDHCI && ARCH_APOLLO
+	default y
+	help
+	    This selects the NXP SD/SDIO/MMC host controller IP_3413 found in APOLLO
+	    boards.
+	    If you have a controller with this interface, say Y or M here.
+	    If unsure, say N.
+	    
+	    Note: This will disable the option to configure a NOR flash device.
+
+choice
+        prompt "Select SDIO slot interface - IO Bus or RGMII"
+        default MMC_SDHCI_NX_SDIOMC_ON_IO_BUS
+        depends on MMC_SDHCI_NX_SDIOMC
+        help
+                This option allows to select between IO Bus or RGMII interface for SDIO Slot.
+
+config MMC_SDHCI_NX_SDIOMC_ON_IO_BUS
+        bool "SDIO slot connected via IO Bus interface"
+        depends on !MTD_APOLLO_NOR
+        help
+            "Enable this option when the SDIO slot connected via IO Bus interface"
+
+config MMC_SDHCI_NX_SDIOMC_ON_RGMII
+        bool "SDIO slot connected via RGMII pin interface"
+        help
+            "Enable this option when the SDIO slot connected via RGMII pin interface"
+
+endchoice
+
+choice
+	prompt "Select SDIO Card Detect connection - SGPIO3 or PIO181"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default MMC_SDHCI_NX_SDIOMC_CRDETECT_ON_PIO181
+	help
+	    Select SDIO Card Detect connection - SGPIO3 or PIO181.
+
+config MMC_SDHCI_NX_SDIOMC_CRDETECT_ON_SGPIO3
+	bool "SDIO Card Detect on SGPIO3"
+	help
+	    "Enable this option when the SDIO Card Detect connected to SGPIO3"
+
+config MMC_SDHCI_NX_SDIOMC_CRDETECT_ON_PIO181
+	bool "SDIO Card Detect on PIO181"
+	help
+	    "Enable this option when the SDIO Card Detect connected to PIO181"
+
+endchoice
+
+choice
+	prompt "Select SDIO Card LED connection - SGPIO4 or PIO161"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default MMC_SDHCI_NX_SDIOMC_CRLED_ON_PIO161
+	help
+	    Select SDIO Card LED connection - SGPIO4 or PIO161.
+
+config MMC_SDHCI_NX_SDIOMC_CRLED_ON_SGPIO4
+	bool "SDIO Card LED on SGPIO4"
+	help
+	    "Enable this option when the SDIO Card LED connected to SGPIO4"
+
+config MMC_SDHCI_NX_SDIOMC_CRLED_ON_PIO161
+	bool "SDIO Card LED on PIO161"
+	help
+	    "Enable this option when the SDIO Card LED connected to PIO161"
+
+endchoice
+
+choice
+	prompt "Select SDIO Card Write Protect connection - SGPIO5 or PIO182"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default MMC_SDHCI_NX_SDIOMC_CRDWP_ON_PIO182
+	help
+	    Select SDIO Card Write Protect connection - SGPIO5 or PIO182.
+
+config MMC_SDHCI_NX_SDIOMC_CRDWP_ON_SGPIO5
+	bool "SDIO Card Write Protect on SGPIO5"
+	help
+	    "Enable this option when the SDIO Card Write Protect connected to SGPIO5"
+
+config MMC_SDHCI_NX_SDIOMC_CRDWP_ON_PIO182
+	bool "SDIO Card Write Protect on PIO182"
+	help
+	    "Enable this option when the SDIO Card Write Protect connected to PIO182"
+
+endchoice
+
+config MMC_SDHCI_NX_SDIOMC_SD1_BIT_ALWAYS
+	bool "Always use SD1-bit mode for data transfer (only for debugging purpose)"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default n
+	help
+	    This selects always SD1-bit mode of data transfer. If this is unselected, either SD1-bit mode
+	    or SD4-bit mode will be chosen depending upon the card capability. For best performance,
+	    do not select it.
+
+config MMC_SDHCI_NX_SDIOMC_NS_MODE
+	bool "Normal-Speed mode for data transfer (only for debugging purpose)"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default n
+	help
+	    This selects the data transfer with SD/MMC card is carried out in Normal-Speed mode and not 
+	    in High-Speed mode. For best performance, do not select it.
+
+config MMC_SDHCI_NX_SDIOMC_25MHZ
+	bool "Use 25MHz SD clock for data transfer (only for debugging purpose)"
+	depends on MMC_SDHCI_NX_SDIOMC
+	default n
+	help
+	    This selects 25MHz of SD_CLK instead of 50MHz for data transfer with SD/MMC card. For best
+	    performance, do not select it.
+
diff -Naurp linux-2.6.34.orig/drivers/mmc/host/Makefile linux-2.6.34/drivers/mmc/host/Makefile
--- linux-2.6.34.orig/drivers/mmc/host/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/host/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -34,7 +34,7 @@ obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
 obj-$(CONFIG_MMC_CB710)	+= cb710-mmc.o
 obj-$(CONFIG_MMC_VIA_SDMMC)	+= via-sdmmc.o
 obj-$(CONFIG_SDH_BFIN)		+= bfin_sdh.o
-
+obj-$(CONFIG_MMC_SDHCI_NX_SDIOMC) += sdhci_nx_sdiomc.o
 obj-$(CONFIG_MMC_SDHCI_OF)	+= sdhci-of.o
 sdhci-of-y				:= sdhci-of-core.o
 sdhci-of-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
diff -Naurp linux-2.6.34.orig/drivers/mmc/host/sdhci.c linux-2.6.34/drivers/mmc/host/sdhci.c
--- linux-2.6.34.orig/drivers/mmc/host/sdhci.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mmc/host/sdhci.c	2010-09-07 22:16:40.000000000 -0500
@@ -496,6 +496,14 @@ static int sdhci_adma_table_pre(struct s
 		WARN_ON((desc - host->adma_desc) > (128 * 2 + 1) * 4);
 	}
 
+#if defined(CONFIG_MMC_SDHCI_NX_SDIOMC) || defined(CONFIG_MMC_SDHCI_NX_SDIOMC_MODULE)
+  /*
+   * IP_3413, sees a terminating entry with nop, end, valid is giving an error
+   * saying ADMA descriptor invalid. hence make last valid descriptor with end
+   * option
+   */
+  desc[-8] |= 0x02;
+#else
 	/*
 	 * Add a terminating entry.
 	 */
@@ -503,6 +511,7 @@ static int sdhci_adma_table_pre(struct s
 	/* nop, end, valid */
 	sdhci_set_adma_desc(desc, 0, 0, 0x3);
 
+#endif
 	/*
 	 * Resync align buffer as we might have changed it.
 	 */
@@ -1786,8 +1795,11 @@ int sdhci_add_host(struct sdhci_host *ho
 		mmc->caps |= MMC_CAP_4_BIT_DATA;
 
 	if (caps & SDHCI_CAN_DO_HISPD)
+#if defined(CONFIG_MMC_SDHCI_NX_SDIOMC) || defined(CONFIG_MMC_SDHCI_NX_SDIOMC_MODULE)
+		mmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
+#else
 		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
-
+#endif
 	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
 		mmc->caps |= MMC_CAP_NEEDS_POLL;
 
diff -Naurp linux-2.6.34.orig/drivers/mmc/host/sdhci_nx_sdiomc.c linux-2.6.34/drivers/mmc/host/sdhci_nx_sdiomc.c
--- linux-2.6.34.orig/drivers/mmc/host/sdhci_nx_sdiomc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mmc/host/sdhci_nx_sdiomc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,531 @@
+/*
+ * Platform device driver for SD/SDIO/MMC controller IP_3413 found in PNX85500
+ * platforms.
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090216     Draft-Initial version
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <asm/io.h>
+#include <mach/nx_sdiomc_dev.h>
+
+#include "sdhci.h"
+
+
+#define MAX_SLOTS			8
+#define NX_SDIOMC_VENDOR_REVISION (0x75)
+
+struct nx_sdiomc_slot;
+struct nx_sdiomc_chip;
+/*!
+ * This structure is used to store the SDHCI host structure which effectively
+ * contains the instantiation of a MMC device.
+ */
+struct nx_sdiomc_slot {
+  struct nx_sdiomc_chip *chip;     /*!< Chip specific information (IP_3413 wide) */
+  struct sdhci_host     *host;     /*!< SDHCI host structure that points to the instantiation of a MMC device */
+  int                    slot_num; /*!< Slot number */
+};
+
+/*!
+ * This structure is used to store the chip specific information including the
+ * platform specific device structure. It also contains information on the
+ * number of slots and slot specific structure information that contains the
+ * SDHCI host structure information.
+ */
+struct nx_sdiomc_chip {
+  struct platform_device *pdev;             /*!< platform specific device structure */
+  unsigned int            quirks;           /*!< Any hardware quirks that need to be taken care of */
+  int                     num_slots;        /*!< Number of slots present in the IP_3413 controller */
+  void __iomem           *ioaddr;           /*!< Chip specific register port */
+  struct nx_sdiomc_slot  *slots[MAX_SLOTS]; /*!< Slot specific information for each of the slots present in the IP_3413 controller */
+};
+
+
+/*!
+ * Through this variable, the platform driver for NXP platform publish the
+ * information on enabling of DMA whenever SDHCI driver module asked to do.
+ *
+ * For SD/SDIO/MMC Controller IP_3413, this field shall be NULL, as it uses
+ * ADMA and ADMA2 which are handled in the SDHCI driver module itself.
+ * 
+ */
+static struct sdhci_ops nx_sdiomc_ops = {
+  .enable_dma	= NULL,
+};
+
+
+/*!\fn struct nx_sdiomc_slot * nx_sdiomc_probe_slot( struct platform_device 
+ * *pdev, struct nx_sdiomc_chip *chip, void __iomem *ioaddr, int irq, 
+ * int slot_num );
+ *     This routine will call \a sdhci_allo_host() and fills the \a sdhci_host
+ *     structure members that are necessary and then instantiate the sdhci
+ *     device.
+ *
+ * \param[in] pdev --> \a platform_device structure 
+ * \param[in] chip --> pointer to \a nx_sdiomc_chip structure that stores the
+ *            slot pointer 
+ * \param[in] ioaddr --> Register base address for the slot where SDIO
+ *            controller registers can be accessed. 
+ * \param[in] irq --> Interrupt number that is associated with the SDIO/SD/MMC
+ *            controller IP_3413 
+ * \param[in] slot_num --> Slot number for which the MMC device instantiation
+ *            to be done 
+ *
+ * \return NULL --> if \a sdhci() driver module does not allocate memory or if
+ *                  the device could't be instatniated
+ * \return Address of nx_sdiomc_slot() that was allocated and instantiated by
+ *                  the \a sdhci driver module.
+ * 
+ * - PseudoCode:
+ * - Call \a sdhci_alloc_host() to allocate memory for \a nx_sdiomc_slot
+ *   structure.
+ * - Get the private part of \a sdhci_host structure. This points to the \a
+ *   nx_sdiomc_slot structure.
+ * - Now store the following:
+ *   -# \a slot->chip = \a chip
+ *   -# \a slot->host = \a host
+ *   -# \a slot->slot_num = \a slot_num
+ *   -# \a host->hw_name = \a "IP_3413"
+ *   -# \a host->ops = \a nx_sdiomc_ops
+ *   -# \a host->quirks = \a chip->quirks
+ *   -# \a host->irq = \a irq
+ *   -# \a host->ioaddr = \a ioaddr
+ * - Call \a sdhci_add_host() to instantiate the MMC device through \a sdhci
+ *   driver module routines
+ * - Return address of \a nx_sdiomc_slot() structure if everything is
+ *   successfull
+ * - Return NULL if any error occured after freeing up the memory that was 
+ *   allocated earler.
+ *        
+ */
+struct nx_sdiomc_slot * nx_sdiomc_probe_slot( struct platform_device *pdev, struct nx_sdiomc_chip *chip, void __iomem *ioaddr, int irq, int slot_num )
+{
+  struct nx_sdiomc_slot *slot;
+  struct sdhci_host *host;
+  int ret;
+
+  host = sdhci_alloc_host( &pdev->dev, sizeof(struct nx_sdiomc_slot));
+  if (IS_ERR(host)) {
+    return NULL;
+  }
+
+  slot = sdhci_priv(host);
+
+  slot->chip = chip;
+  slot->host = host;
+  slot->slot_num = slot_num;
+
+  host->hw_name = "IP_3413";
+  host->ops = &nx_sdiomc_ops;
+  host->quirks = chip->quirks;
+  host->irq = irq;
+  host->ioaddr = ioaddr;
+  host->flags = (SDHCI_USE_ADMA);
+
+  ret = sdhci_add_host(host);
+  if (ret)
+    goto _free_host;
+
+  return slot;
+
+_free_host:
+  sdhci_free_host(host);
+  return NULL;
+}
+
+/*!\fn static void nx_sdiomc_remove_slot(struct nx_sdiomc_slot *slot);
+ *     This routine will remove the MMC device instatination from Linux MMC
+ *     framework.
+ *
+ * \param[in] slot --> pointer to \a nx_sdiomc_slot structure that was
+ *                     instantiated through \a sdhci module
+ *
+ * - PseudoCode:
+ * - Call \a sdhci_remove_host() to remove the MMC device instantitaion for the
+ *   give \a nx_sdiomc_slot structure
+ * - Call \a sdhci_free_host() to free-up the memory allocated to \a
+ *   nx_sdiomc_slot structure and also strucutres within \a sdhci module
+ * - Return
+ *        
+ */
+static void nx_sdiomc_remove_slot(struct nx_sdiomc_slot *slot)
+{
+  int dead;
+  u32 scratch;
+
+  dead = 0;
+  scratch = readl(slot->host->ioaddr + 0x100*slot->slot_num + SDHCI_INT_STATUS);
+  if (scratch == (u32)-1)
+    dead = 1;
+
+  sdhci_remove_host(slot->host, dead);
+
+  sdhci_free_host(slot->host);
+}
+
+/*!\fn int __init nx_sdiomc_probe(struct platform_device *pdev);
+ *     this routine will probe the ip_3413 existance and get relevant details
+ *     about the ip_3413 platform details such as irq, base address, number of
+ *     slots etc. and then instantiate mmc device to work with linux mmc
+ *     framework.
+ *
+ * \param[in] pdev --> platform device pointer
+ *
+ * \return 0 --> successfull
+ * \return -ENXIO --> error in io, unable to get platform details
+ * \return -ENOMEM --> memory could not be allocated
+ *
+ * - pseudocode:
+ * - check if incoming platform data is present or not. if not present return
+ *   \a -enxio.
+ * - check if number of slots are zero. if so, return \a -enxio.
+ * - get the sdio ip_3413 base address by calling \a
+ *   platform_get_resource()
+ * - get the irq for sdio ip_3413 by calling \a platform_get_irq()
+ * - if any error is returned, return \a -enxio
+ * - io remap the sdio ip_3413 register map
+ * - read the host controller version of ip_3413. if the vendor revision value
+ *   does not match with fixed value (0x73), then return \a -enxio.
+ * - now allocate memory for \a nx_sdiomc_chip structure. if any error return
+ *   \a -enomem
+ * - store the following in \a nx_sdiomc_chip structure
+ *   -# \a chip->num_slots = platform_data->num_slots
+ *   -# \a chip->pdev = \a pdev
+ *   -# \a chip->ioaddr = \a ioaddr (ioremapped address)
+ * - now set the platform driver data to this \a nx_sdiomc_chip structure
+ * - now for all the slots present in ip_3413 do the following:
+ *   -# call \a nx_sdiomc_probe_slot() to instantiate the slot into a linux mmc
+ *      framework device
+ *   -# if any error is returned, then remove the instantiation of all the
+ *      devices that are instantiated earlier by calling \a
+ *      nx_sdiomc_remove_slot() and return an error.
+ *   -# store the instantiated mmc device which has pointer stored in \a
+ *   nx_sdiomc_slot structure onto \a nx_sdiomc_chip->slots[slot_num]
+ * - If any error occurs, return appropriate error after freeing up the memory
+ *   allocated for \a nx_sdiomc_chip structure
+ * - If no error occurs, return 0.
+ *        
+ */
+static int __init nx_sdiomc_probe(struct platform_device *pdev)
+{
+  struct nx_sdiomc_platform_data *pdata = pdev->dev.platform_data;
+  struct nx_sdiomc_chip *chip = NULL;
+  struct nx_sdiomc_slot *slot = NULL;
+  struct resource *res_reg;
+  void __iomem *ioaddr;
+  int num_slots;
+  int irq;
+  int i, ret = 0;
+  u16 rev;
+
+  if (pdata == NULL) {
+    dev_err(&pdev->dev, "platform data missing\n");
+    return -ENXIO;
+  }
+
+  if (pdata->num_slots == 0) {
+    dev_err(&pdev->dev, "no slots\n");
+    return -ENXIO;
+  }
+
+  res_reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  irq = platform_get_irq(pdev, 0);
+
+  if (res_reg == NULL || irq < 0)
+    return -ENXIO;
+
+  ioaddr = devm_ioremap( &pdev->dev, res_reg->start, (res_reg->end - res_reg->start + 1 ));
+  if( !ioaddr )
+    return -ENXIO;
+
+  /*
+   * Now detect the IP whether it contains proper vendor id or not
+   */
+  rev = readw(ioaddr + SDHCI_HOST_VERSION);
+
+  if( ( ( rev & SDHCI_VENDOR_VER_MASK ) >> SDHCI_VENDOR_VER_SHIFT ) != NX_SDIOMC_VENDOR_REVISION ) {
+    ret = -ENXIO;
+    goto _unmap;
+  }
+
+  dev_info(&pdev->dev, "SD/SDIO/MMC controller IP_3413 found @ [%08x] (rev %x)\n",
+      (int)ioaddr, (int)rev);
+
+  /** allocate memory to chip-specific structure */
+  chip = kzalloc(sizeof(struct nx_sdiomc_chip), GFP_KERNEL);
+  if (chip == NULL) {
+    ret = -ENOMEM;
+    goto _unmap;
+  }
+
+  num_slots = pdata->num_slots;
+  chip->num_slots = num_slots;
+  chip->pdev = pdev;
+  chip->ioaddr = ioaddr;
+  chip->quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
+
+  platform_set_drvdata(pdev, chip);
+
+  for (i = 0;i < num_slots;i++) {
+    slot = nx_sdiomc_probe_slot( pdev, chip, ioaddr, irq, i );
+    if (IS_ERR(slot)) {
+      for (i--;i >= 0;i--)
+        nx_sdiomc_remove_slot(chip->slots[i]);
+      ret = PTR_ERR(slot);
+      goto _free_mem;
+    }
+    ioaddr += 0x100;
+    chip->slots[i] = slot;
+  }
+
+  return 0;
+
+_free_mem:
+  kfree(chip);
+  platform_set_drvdata(pdev, NULL);
+_unmap:
+  devm_iounmap( &pdev->dev, ioaddr );
+  return ret;
+}
+
+
+/*!\fn static int nx_sdiomc_remove(struct platform_device *pdev);
+ *     In this routine, the resources that were allocated in 
+ *     \a nx_sdiomc_probe() will be freed and MMC host information that is 
+ *     registered with Linux MMC framework and return 0.
+ *
+ * \param[in] pdev --> contains platform device specific information
+ * \return 0 - Successfull
+ * 
+ * - PseudoCode:
+ * - The parameter \a pdev points to the private structure \a nx_sdiomc_chip
+ *   during \a nx_sdiomc_probe() routine. Store this in a local variable 
+ *   called \a chip
+ * - For all the slots that are configured in the \a nx_sdiomc_probe(), call
+ *   nx_sdiomc_remove_slot() routine that will un-register the MMC host from
+ *   the Linux MMC driver framework through \a sdhci.
+ * - Unmap the IOmap of register map of IP_3413 by calling \a devm_iounmap()
+ * - Free the memory allocated to \a nx_sdiomc_chip structure
+ * - Return zero.
+ *        
+ */
+static int nx_sdiomc_remove(struct platform_device *pdev)
+{
+  int i;
+  struct nx_sdiomc_chip *chip;
+
+  chip = platform_get_drvdata(pdev);
+
+  if (chip) {
+    for (i = 0;i < chip->num_slots; i++)
+      nx_sdiomc_remove_slot(chip->slots[i]);
+    platform_set_drvdata(pdev, NULL);
+    devm_iounmap( &pdev->dev, chip->ioaddr);
+    kfree(chip);
+  }
+  return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+/*!\fn static int nx_sdiomc_suspend(struct platform_device *pdev, pm_message_t
+ * mesg);
+ *     In this routine, the SDIO host controller will be put in suspended 
+ *     mode (where in the power and clock will be switched off for the SDIO
+ *     bus) for all the slots. If any failure to go into suspended mode, 
+ *     the SDIO host controller will resume to normal operation.
+ *
+ * \param[in] pdev --> contains platform device specific information
+ * \param[in] mesg --> power management message infomration
+ * \return 0 - Successfull
+ * 
+ * - PseudoCode:
+ * - The parameter \a pdev points to the private structure \a nx_sdiomc_chip
+ *   during \a nx_sdiomc_probe() routine. Store this in a local variable called
+ *   \a chip
+ * - If \a chip is NULL, return 0.
+ * - For all the slots that are configured in the \a nx_sdiomc_probe(), do
+ *   the following
+ *   -# Get the address of slot private data structure through \a
+ *      host->slots[ ]
+ *   -# Call \a sdhci_suspend_host() with \a chip->slots[i] value and \a mesg.
+ *   -# If return value is non-zero, then:
+ *      -# Call \a sdhci_resume_host() with \a chip->slots[i] value for all those
+ *         slots which are suspended till this moment.
+ *      -# Return the value returned by \a sdhci_suspend_host().
+ * - Return zero.
+ *        
+ */
+static int nx_sdiomc_suspend (struct platform_device *pdev, pm_message_t state)
+{
+  struct nx_sdiomc_chip *chip;
+  struct nx_sdiomc_slot *slot;
+  int i, ret;
+
+  chip = platform_get_drvdata(pdev);
+  if (!chip)
+    return 0;
+
+  for (i = 0;i < chip->num_slots;i++) {
+    slot = chip->slots[i];
+    if (!slot)
+      continue;
+
+    ret = sdhci_suspend_host(slot->host, state);
+
+    if (ret) {
+      for (i--;i >= 0;i--)
+        sdhci_resume_host(chip->slots[i]->host);
+      return ret;
+    }
+  }
+
+  /** todo - switch off the power and clock ?? */
+
+  return 0;
+}
+
+/*!\fn static int nx_sdiomc_resume(struct platform_device *pdev);
+ *     In this routine, the SDIO host controller will be resumed from 
+ *     suspended mode and power and clock lines will be switched ON for 
+ *     all the slots.
+ *
+ * \param[in] pdev --> contains platform device specific information
+ * \return 0 - Successfull
+ *
+ * - PseudoCode:
+ * - The parameter \a pdev points to the private structure \a nx_sdiomc_chip
+ *   during \a nx_sdiomc_probe() routine. Store this in a local variable called
+ *   \a chip
+ * - If \a chip is NULL, return 0.
+ * - For all the slots that are configured in the \a nx_sdiomc_probe(), do
+ *   the following
+ *   -# Get the address of slot private data structure through \a
+ *      chip->slots[ ]
+ *   -# Call \a sdhci_resume_host() with \a chip->slot[i] value.
+ *   -# If return value is non-zero, return that value.
+ * - Return zero.
+ *        
+ */
+static int nx_sdiomc_resume (struct platform_device *pdev)
+{
+  struct nx_sdiomc_chip *chip;
+  struct nx_sdiomc_slot *slot;
+  int i, ret;
+
+  chip = platform_get_drvdata(pdev);
+  if (!chip)
+    return 0;
+
+  /** todo - switch on power and clock ?? */
+  for (i = 0;i < chip->num_slots;i++) {
+    slot = chip->slots[i];
+    if (!slot)
+      continue;
+
+    ret = sdhci_resume_host(slot->host);
+    if (ret)
+      return ret;
+  }
+
+  return 0;
+}
+
+#else /* CONFIG_PM */
+
+#define nx_sdiomc_suspend NULL
+#define nx_sdiomc_resume NULL
+
+#endif /* CONFIG_PM */
+
+
+/*!
+ * Through this variable, the Linux MMC driver for SD/SDIO/MMC controller
+ * publishes the routines that will be called by the Linux kernel to probe the
+ * device present, remove the device, suspend the operation of the device and
+ * resume the operation of device.
+ *
+ * This structure will be registered with platform in \a nx_sdiomc_init()
+ * routine.
+ *
+ */
+struct platform_driver nx_sdiomc_driver = {
+  .probe		= nx_sdiomc_probe,
+  .remove		= nx_sdiomc_remove,
+  .suspend	= nx_sdiomc_suspend,
+  .resume		= nx_sdiomc_resume,
+  .driver		= {
+    .name	= "nx_sdiomc",
+    .owner	= THIS_MODULE,
+  },
+};
+
+/*!\fn  int __init nx_sdiomc_init(void);
+ *        This routine will be called when the driver is loaded onto memory or
+ *        during the loading of the modules by the kernel during startup.
+ *
+ * \return Value returned by \a platform_driver_register() routine.
+ * 
+ * - PseudoCode:
+ * - Call \a platform_driver_register() with \a nx_sdiomc_driver 
+ *   variable address.
+ * - Return the value returned by \a platform_driver_register() function.
+ *        
+ */
+int __init nx_sdiomc_init(void)
+{
+  return platform_driver_register(&nx_sdiomc_driver);
+}
+
+/*!\fn  void __exit nx_sdiomc_exit(void);
+ *        This routine will be called when the driver is being unloaded from 
+ *        the memory by kernel.
+ *
+ * - PseudoCode:
+ * - Call \a platform_driver_unregister() with \a nx_sdiomc_driver 
+ *   variable address.
+ * - Return from the function.
+ *        
+ */
+void __exit nx_sdiomc_exit(void)
+{
+  platform_driver_unregister(&nx_sdiomc_driver);
+}
+
+module_init(nx_sdiomc_init);
+module_exit(nx_sdiomc_exit);
+
+MODULE_DESCRIPTION("NXP SDIO/SD/MMC Controller driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NXP B.V.");
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/Kconfig linux-2.6.34/drivers/mtd/Kconfig
--- linux-2.6.34.orig/drivers/mtd/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -329,4 +329,6 @@ source "drivers/mtd/lpddr/Kconfig"
 
 source "drivers/mtd/ubi/Kconfig"
 
+source "drivers/mtd/sfc/Kconfig"
+
 endif # MTD
diff -Naurp linux-2.6.34.orig/drivers/mtd/Makefile linux-2.6.34/drivers/mtd/Makefile
--- linux-2.6.34.orig/drivers/mtd/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -29,6 +29,6 @@ obj-$(CONFIG_MTD_OOPS)		+= mtdoops.o
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
+obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ sfc/ tests/
 
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff -Naurp linux-2.6.34.orig/drivers/mtd/maps/Kconfig linux-2.6.34/drivers/mtd/maps/Kconfig
--- linux-2.6.34.orig/drivers/mtd/maps/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/maps/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -422,6 +422,15 @@ config MTD_H720X
 	  This enables access to the flash chips on the Hynix evaluation boards.
 	  If you have such a board, say 'Y'.
 
+config MTD_APOLLO_NOR
+	tristate "APOLLO board mappings"
+	depends on MTD_CFI && ARCH_APOLLO && MTD_COMPLEX_MAPPINGS
+	select MTD_PARTITIONS
+	help
+	  This enables access to the NOR flash chips on APOLLO-based
+	  boards defining flash platform devices and flash platform data.
+	  If you have such a board, say 'Y'.
+
 # This needs CFI or JEDEC, depending on the cards found.
 config MTD_PCI
 	tristate "PCI MTD driver"
diff -Naurp linux-2.6.34.orig/drivers/mtd/maps/Makefile linux-2.6.34/drivers/mtd/maps/Makefile
--- linux-2.6.34.orig/drivers/mtd/maps/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/maps/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -58,4 +58,5 @@ obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
+obj-$(CONFIG_MTD_APOLLO_NOR)	+= nx_nor.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
diff -Naurp linux-2.6.34.orig/drivers/mtd/maps/nx_nor.c linux-2.6.34/drivers/mtd/maps/nx_nor.c
--- linux-2.6.34.orig/drivers/mtd/maps/nx_nor.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/maps/nx_nor.c	2010-09-07 22:47:51.000000000 -0500
@@ -0,0 +1,1053 @@
+/*
+ * Device driver for NOR IP_2070.
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version     Author           Date          Remarks    
+ * 1.0.0    Sundarapandian A     20090720    Updated for APOLLO
+ */
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+
+#include <linux/dmaengine.h>
+#include <linux/nx_dmac_1902.h>
+
+#include <linux/nx_dmac.h>
+
+#include <mach/nor.h>
+
+static const char *probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", NULL };
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+static void *virt_bounce_write_buffer, *virt_bounce_read_buffer;
+static unsigned int phys_bounce_write_buffer, phys_bounce_read_buffer;
+static int suspend=0;
+
+struct nx_nor_info {
+   struct mtd_partition       *parts;
+   struct mtd_info            *mtd;
+   struct map_info            map;
+   struct map_info            map_copy;
+   struct nx_dmac_1902_slave  slave;
+   struct dma_chan            *chan;
+   resource_size_t            mmio_start;
+   resource_size_t            mmio_len;
+   void __iomem               *mmio_base; /* IP2016 MMIO base address */
+};
+
+static void nx_nor_set_vpp(struct map_info *map, int enable)
+{
+   return;  
+}
+
+#define NX_NOR_DMA_BASE_ADDR (void __iomem *)0x00000000
+#define USE_DMAC_1902_DRIVER 0
+#define USE_NX_NOR_DMAC_FUNCTIONS 1
+
+#if USE_DMAC_1902_DRIVER
+static void nx_nor_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+   struct nx_nor_info *info = container_of(map, struct nx_nor_info, map);
+   enum dma_status status;
+   dma_cookie_t cookie;
+
+#if 0
+   /* check to see if the channel is already allocated */
+   if(info->chan) {
+      dev_err(info->slave.slave.dev, "A DMA operation is already going on\n");
+      return;
+   }
+
+   /* try to allocate a DMA channel */
+   dma_async_client_chan_request( &info->client);
+
+   /* check whether the channel is allocated or not */
+   if(!info->chan) {
+      dev_err(info->slave.slave.dev, "A DMA channel could not be allocated\n");
+      return;
+   }
+#endif
+
+   /* 
+    * channel is allocated, prepare the nx_dmac_1902_slave and perform
+    * buf_to_buf memcpy through DMA.
+    */
+   /* setup the slave specific data here */
+   info->slave.src_burst   = nx_dmac_1902_burst_128;
+   info->slave.dst_burst   = nx_dmac_1902_burst_128;
+   info->slave.src_select  = nx_dmac_1902_ahb_master_2;
+   info->slave.dst_select  = nx_dmac_1902_ahb_master_1;
+   info->slave.slave.reg_width = info->map.bankwidth;
+
+   cookie = dma_async_memcpy_buf_to_buf(info->chan, to, NX_NOR_DMA_BASE_ADDR + from, len);
+   if(dma_submit_error(cookie)) {
+      /* error happened. Just free-up the channel */
+      goto _free_channel;
+   }
+   status = dma_sync_wait( info->chan, cookie);
+   /* whatever be the case here, just return after freeing up the channel */
+
+_free_channel:
+
+   dma_chan_put(info->chan);
+   //info->chan = NULL;
+   return;
+}
+
+static map_word nx_nor_map_read(struct map_info *map, unsigned long ofs)
+{
+   map_word r;
+
+   nx_nor_map_copy_from(map, r.x, ofs, 1);
+
+   return r;
+}
+
+static void nx_nor_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+   struct nx_nor_info *info = container_of(map, struct nx_nor_info, map);
+   enum dma_status status;
+   dma_cookie_t cookie;
+
+#if 0
+   /* check to see if the channel is already allocated */
+   if(info->chan) {
+      dev_err(info->slave.slave.dev, "A DMA operation is already going on\n");
+      return;
+   }
+
+   /* try to allocate a DMA channel */
+   dma_async_client_chan_request( &info->client);
+
+   /* check whether the channel is allocated or not */
+   if(!info->chan) {
+      dev_err(info->slave.slave.dev, "A DMA channel could not be allocated\n");
+      return;
+   }
+#endif
+
+   /* 
+    * channel is allocated, prepare the nx_dmac_1902_slave and perform
+    * buf_to_buf memcpy through DMA.
+    */
+   /* setup the slave specific data here */
+   info->slave.src_burst = nx_dmac_1902_burst_8;
+   info->slave.dst_burst = nx_dmac_1902_burst_8;
+   info->slave.src_select = nx_dmac_1902_ahb_master_1;
+   info->slave.dst_select = nx_dmac_1902_ahb_master_1;
+   info->slave.slave.reg_width = info->map.bankwidth;
+
+   cookie = dma_async_memcpy_buf_to_buf(info->chan, NX_NOR_DMA_BASE_ADDR + to, (void*) from, len);
+   if(dma_submit_error(cookie)) {
+      /* error happened. Just free-up the channel */
+      goto _free_channel;
+   }
+   status = dma_sync_wait( info->chan, cookie);
+   /* whatever be the case here, just return after freeing up the channel */
+
+_free_channel:
+
+   dma_chan_put(info->chan);
+   //info->chan = NULL;
+   return;
+}
+
+static void nx_nor_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
+{
+   nx_nor_map_copy_to(map, ofs, datum.x, 1);
+}
+
+static enum dma_state_client nx_nor_dmac_chan_alloc_cb(struct dma_client *client,struct dma_chan *chan, enum dma_state state)
+{
+  enum dma_state_client ack = DMA_NAK;
+  struct device *dev = client->slave->dev;
+  struct nx_nor_info *info = dev_get_drvdata(dev);
+
+  switch (state) {
+    case DMA_RESOURCE_AVAILABLE:
+      /* 
+       * check whether the channel is already allocated or not. If allocated,
+       * return NAK, else return ACK
+       */
+      if(info->chan) {
+         ack = DMA_NAK;
+      } else {
+         ack = DMA_ACK;
+         info->chan = chan;
+      }
+      break;
+    case DMA_RESOURCE_REMOVED:
+      ack = DMA_ACK;
+      break;
+    default:
+      ack = DMA_NAK;
+      break;
+  }
+  return ack;
+}
+#endif
+
+#if USE_NX_NOR_DMAC_FUNCTIONS
+#if 1
+#define NX_DMAC_1902_DMAC_ENABLE             (0x00000001)
+#define NX_DMAC_1902_DMAC_DISABLE            (0x00000000)
+
+#define NX_DMAC_1902_REG_INT_STATUS          (0x000)
+#define NX_DMAC_1902_REG_INT_TC_STATUS       (0x004)
+#define NX_DMAC_1902_REG_INT_TC_CLEAR        (0x008)
+#define NX_DMAC_1902_REG_INT_ERR_STATUS      (0x00C)
+#define NX_DMAC_1902_REG_INT_ERR_CLEAR       (0x010)
+#define NX_DMAC_1902_REG_INT_RAW_TC_STATUS   (0x014)
+#define NX_DMAC_1902_REG_INT_RAW_ERR_STATUS  (0x018)
+#define NX_DMAC_1902_REG_ENABLED_CHANS       (0x01C)
+
+/* channel specific register */
+#define NX_DMAC_1902_REG_CHAN_BASE(x)        (0x100+((x)*0x20))
+#define NX_DMAC_1902_REG_CHAN_SRC_ADDR       (0x000)
+#define NX_DMAC_1902_REG_CHAN_DST_ADDR       (0x004)
+#define NX_DMAC_1902_REG_CHAN_LLI_ADDR       (0x008)
+#define NX_DMAC_1902_REG_CHAN_CONTROL        (0x00C)
+#define NX_DMAC_1902_REG_CHAN_CONFIG         (0x010)
+
+#define NX_DMAC_1902_CHAN_CNTRL_PROT(x)      ((x)<<28)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_INCR(x)  ((x)<<27)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(x)  ((x)<<26)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_AHB(x)   ((x)<<25)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(x)   ((x)<<24)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(x) ((x)<<21)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(x) ((x)<<18)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_BURST(x) ((x)<<15)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(x) ((x)<<12)
+
+#define NX_DMAC_1902_PROT_CACHEABLE          (0x4)
+#define NX_DMAC_1902_PROT_BUFFERABLE         (0x2)
+#define NX_DMAC_1902_DMAC_CHAN_ENABLE        (0x00000001)
+#define NX_DMAC_1902_DMAC_CHAN_DISABLE       (0x00000000)
+
+#define NX_DMAC_1902_INT_ENABLE              (0x80000000UL)
+
+#define NX_DMAC_1902_UNMASK_INT              (0x0000C000UL)
+
+#define NX_DMAC_1902_REG_DMAC_CONFIG         (0x030)
+
+#define MAX_NX_DMAC_1902_CHANNELS            (8)
+
+static void __iomem *dma_base;
+
+/* these are updated from nx_dmac driver as GCS DMA handler is there */
+extern volatile bool nor_dma_done;
+extern volatile bool nor_dma_error;
+
+static int nx_nor_dma_init(void)
+{
+
+    /* disable the DMA controller */
+    //writel( NX_DMAC_1902_DMAC_DISABLE, dma_base+NX_DMAC_1902_REG_DMAC_CONFIG);
+
+    /* disable the DMA channel */
+    writel(NX_DMAC_1902_DMAC_CHAN_DISABLE, dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID)+
+                                          NX_DMAC_1902_REG_CHAN_CONFIG);
+
+    /* clear the error interrupt status */
+    writel((1<<NX_DMAC_NOR_DMA_CHANNEL_ID), dma_base+NX_DMAC_1902_REG_INT_ERR_CLEAR);
+
+    /* clear the tc interrupt status */
+    writel((1<<NX_DMAC_NOR_DMA_CHANNEL_ID), dma_base+NX_DMAC_1902_REG_INT_TC_CLEAR);
+
+    /* enable the DMA controller */
+    //writel( NX_DMAC_1902_DMAC_ENABLE, dma_base+NX_DMAC_1902_REG_DMAC_CONFIG);
+
+    return 0;
+}
+
+static void nx_nor_dma_start(struct map_info *map, u32 src_addr, u32 dst_addr, u32 xfer_count, u32 access_width, bool iswrite)
+{
+    u32 control = 0;
+    u32 config  = 0;
+
+    nor_dma_done = false;
+    nor_dma_error = false;
+
+    control |= NX_DMAC_1902_INT_ENABLE;
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_INCR(1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_BURST(nx_dmac_1902_burst_256);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(nx_dmac_1902_burst_256);
+    //control |= NX_DMAC_1902_CHAN_CNTRL_PROT(NX_DMAC_1902_PROT_CACHEABLE|NX_DMAC_1902_PROT_BUFFERABLE);   
+    if(iswrite)
+    {
+        control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_2);
+        control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_1);
+    }
+    else
+    {
+        control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_1);
+        control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_2);
+    }
+
+    /* The DWidth and SWidth should be same */
+    control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(access_width>>1);
+    control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(access_width>>1);
+
+    /* Transfer count for this transaction */
+    control |= 0xfff&(xfer_count/access_width);
+
+    writel(src_addr, dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +  NX_DMAC_1902_REG_CHAN_SRC_ADDR);
+    writel(dst_addr, dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +  NX_DMAC_1902_REG_CHAN_DST_ADDR);
+    writel(0,        dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +  NX_DMAC_1902_REG_CHAN_LLI_ADDR);
+    writel(control,  dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +  NX_DMAC_1902_REG_CHAN_CONTROL);
+
+    /* Enable Terminal count and Error Interrupts */
+    config = NX_DMAC_1902_UNMASK_INT;
+
+    /* Enable the DMA */
+    writel((config | NX_DMAC_1902_DMAC_CHAN_ENABLE), dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+                                                     NX_DMAC_1902_REG_CHAN_CONFIG);
+}
+
+static int nx_nor_dma_completion_wait(void)
+{
+    unsigned long dma_wait_timeout = jiffies + msecs_to_jiffies(10000);
+
+    /* As the interrupt for GCS DMA is registered with NX DMAC driver
+       wait for nor_dma_done to be TRUE, if it does not turn up, 
+       we wait for 10sec timeout */
+    do 
+    {
+        if (time_after_eq(jiffies, dma_wait_timeout)) 
+        {
+            printk(KERN_ERR "nx_nor_dma_completion_wait: timeout!\n");
+            return -EIO;
+        }
+    } while (nor_dma_done == false);
+
+    /* disable the DMA channel */
+    writel(NX_DMAC_1902_DMAC_CHAN_DISABLE, dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID)+
+                                           NX_DMAC_1902_REG_CHAN_CONFIG);
+
+    /* See if there is any error from GCS DMA */
+    if(nor_dma_error)
+    {
+        printk(KERN_ERR "nx_nor_dma_completion_wait: Error in NOR DMA!\n");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/* Read from Flash Routine */
+static void nx_nor_map_copy_from(struct map_info *map, void *dst_buffer, unsigned long offset, ssize_t len)
+{
+    dma_addr_t dma_dst=0;
+    ssize_t thislen;
+    int status;
+    int bankwidth = map_bankwidth(map);
+    int access_width;
+
+    if(suspend)
+      return;
+
+    /* Transfer till there is a valid length */
+    while(len)
+    {
+        /* The TransferSize[11:0] field of DMACCxControl.register can be
+         * maximum value of 4095, which limits the maximum size of any DMA
+         * transfer request for a NOR flash device to 4095*bankwidth. */
+        /* Check if length exceeds the maximum supported length per transfer */
+        if (len >= (4095*bankwidth))
+        {
+            /* If length exceeds the max, program the max per xfer */
+            thislen = (4095*bankwidth);
+        }
+        else
+        {
+            /* If length does not exceeds max, program this for xfer */
+            thislen = len;
+        }
+
+        /* Check if the destination buffer is outside of kernel valid address,
+           like vmalloc/ioremap regions */
+        if (!virt_addr_valid(dst_buffer))
+        {
+            /* Check if the Flash offset or xfer size is multiple of bankwidth */
+            if((offset%bankwidth) || (thislen%bankwidth))
+            {
+                /* If the offset or size is not multiple of bankwdith,
+                   we have to do byte access of flash */
+                access_width=1;
+            
+                /* As we are doing a byte access now, make sure that the xfer
+                   size does not exceed the max supported per transaction, if 
+                   it does assume 4095 as the length for this xfer */
+                if(thislen > 4095)
+                    thislen=4095;
+            }
+            else
+            {
+                /* If offset and xfer are multiple of bankwidth, we can access
+                   the flash by bankwidth witdh*/
+                access_width=bankwidth;
+            }
+        
+            /* Use a bounce buffer to read the data as destination buffer 
+               cannot be used for DMA, invalidate the buffer region */
+            dma_unmap_single(NULL, (dma_addr_t)phys_bounce_read_buffer, (size_t)thislen, DMA_FROM_DEVICE);
+
+            /* Start the DMA xfer using the access_width */
+            nx_nor_dma_start(map, offset, phys_bounce_read_buffer, thislen, access_width, 0);
+
+            /* Wait for DMA xfer to complete */
+            status = nx_nor_dma_completion_wait();
+            if (status)
+            {         
+                printk(KERN_ERR "nx_nor_map_copy_from: nx_nor_dma_completion_wait \
+                                 failed for offset = %lx len = %d\n", offset, thislen);
+                return;
+            }
+
+            /* As the requested data has been read into bounce buffer, now copy it 
+               to destination buffer */
+            memcpy(dst_buffer, __va(phys_bounce_read_buffer), thislen);
+        }
+        else
+        {
+            /* Check if the Flash offset/xfer size/destination buffer is multiple of bankwidth */
+            if((offset%bankwidth) || (thislen%bankwidth) || (__pa(dst_buffer)%bankwidth))
+            {
+                /* If the offset or size is not multiple of bankwdith,
+                   we have to access flash bytewise */
+                access_width=1;
+            
+                /* As we are doing a byte access now, make sure that the xfer
+                   size does not exceed the max supported per transaction, if 
+                   it does assume 4095 as the length for this xfer */
+                if(thislen > 4095)
+                    thislen=4095;
+            }
+            else
+            {
+                /* If offset and xfer are multiple of bankwidth, we can access
+                   the flash by bankwidth witdh*/
+                access_width=bankwidth;
+            }
+        
+            /* As the destination buffer is valid, map it for DMA */
+            dma_dst = dma_map_single(NULL, dst_buffer, thislen, DMA_FROM_DEVICE);
+
+            /* Start the DMA xfer using the access_width */
+            nx_nor_dma_start(map, offset, dma_dst, thislen, access_width, 0);
+
+            /* Wait for DMA xfer to complete */
+            status = nx_nor_dma_completion_wait();
+            if (status)
+            {
+                dma_unmap_single(NULL, dma_dst, thislen, DMA_FROM_DEVICE);
+                printk(KERN_ERR "nx_nor_map_copy_from: nx_nor_dma_completion_wait \
+                                 failed for offset = %lx len = %d\n", offset, thislen);
+                return;
+            }
+            
+            /* As the data has been read into destination buffer, unmap the buffer */
+            dma_unmap_single(NULL, dma_dst, thislen, DMA_FROM_DEVICE);
+        }
+
+        /* Substract the length of data transfered in this transaction */
+        offset += thislen;
+        dst_buffer += thislen;
+        len -= thislen;
+    }
+
+    /* Transfer complete, go back */
+    return;
+}
+
+/* Write to Flash Routine */
+static void nx_nor_map_copy_to (struct map_info *map, unsigned long offset, const void *src_buffer, ssize_t len)
+{
+    dma_addr_t dma_src;
+    ssize_t thislen;
+    int status;
+    int bankwidth = map_bankwidth(map);
+
+    if(suspend)
+       return;
+
+    /* Transfer till there is a valid length */
+    while(len)
+    {
+        /* The TransferSize[11:0] field of DMACCxControl.register can assume
+         * maximum value of 4095, which limits the maximum size of any DMA
+         * transfer request for a NOR flash device to 4095*bankwidth. */
+        /* Check if length exceeds the maximum supported length per transfer */         
+        if (len >= (4095*bankwidth))
+        {
+            /* If length exceeds the max, program the max per xfer */
+            thislen = (4095*bankwidth);
+        }
+        else
+        {
+            /* If length does not exceeds max, program this for xfer */
+            thislen = len;
+        }
+
+        /* Check if the source buffer is outside of kernel valid address,
+           like vmalloc/ioremap regions */
+        if (!virt_addr_valid(src_buffer))
+        {
+            /* Use a bounce buffer to write the data as source buffer 
+               cannot be used for DMA, copy the data into bounce buffer  */        
+            memcpy(__va(phys_bounce_write_buffer), src_buffer, thislen);
+
+            /* Clean the data from the caches, for DMA */
+            dma_map_single(NULL, __va(phys_bounce_write_buffer), (size_t)thislen, DMA_TO_DEVICE);
+
+            /* Start the DMA xfer using the access_width */
+            nx_nor_dma_start(map, offset, phys_bounce_write_buffer, thislen, bankwidth, 1);
+
+            /* Wait for DMA xfer to complete */
+            status = nx_nor_dma_completion_wait();
+            if (status)
+            {         
+                printk(KERN_ERR "nx_nor_map_copy_to: nx_nor_dma_completion_wait \
+                                 failed for offset = %lx len = %d\n", offset, thislen);
+                return;
+            }
+        }
+        else
+        {
+            /* As the source buffer is valid, map it for DMA to device */
+            dma_src = dma_map_single(NULL, (void*)src_buffer, thislen, DMA_TO_DEVICE);
+
+            /* Start the DMA xfer using the access_width */
+            nx_nor_dma_start(map, dma_src, offset, thislen, bankwidth, 1);
+
+            /* Wait for DMA xfer to complete */
+            status = nx_nor_dma_completion_wait();
+            if (status)
+            {
+                dma_unmap_single(NULL, dma_src, thislen, DMA_TO_DEVICE);      
+                printk(KERN_ERR "nx_nor_map_copy_to: nx_nor_dma_completion_wait \
+                                 failed for offset = %lx len = %d\n", offset, thislen);
+                return;
+            }
+
+            /* As the data has been written, unmap the buffer */
+            dma_unmap_single(NULL, dma_src, thislen, DMA_TO_DEVICE);
+        }
+        
+        /* Substract the length of data transfered in this transaction */
+        offset += thislen;
+        src_buffer += thislen;
+        len -= thislen;
+    }
+
+    /* Transfer complete, go back */
+    return;
+}
+
+/* Read 1 bankwidth length data from given offset */
+static inline map_word nx_nor_map_read(struct map_info *map, unsigned long offset)
+{
+   static map_word current_map_word;
+   nx_nor_map_copy_from(map, (void*)current_map_word.x, offset, map->bankwidth);
+   return current_map_word;
+}
+
+/* Write 1 bankwidth length data to given offset */
+static inline void nx_nor_map_write(struct map_info *map, const map_word datum, unsigned long offset)
+{
+   nx_nor_map_copy_to(map, offset, datum.x, map->bankwidth);
+   mb();   
+}
+#else
+typedef struct tag_nor_dmac_ctrl
+{
+   struct map_info   *map;
+   u32               src_addr;
+   u32               dst_addr;
+   u32               xfer_count;
+   bool              iswrite;
+} nx_nor_dmac_ctrl_t;
+
+static nx_nor_dmac_ctrl_t   nor_ctrl;
+static nx_dmac_tfr_t        req;
+static nx_dmac_stgt_t       stgt[5];
+
+/**
+* nx_nor_dmac_init - Configure the DMAC scatter gather list
+* @ctrl: NOR DMA control structure
+* @req:  Request structure
+* @stgt: Scatter gather array
+*
+* Initialise the DMAC scatter gather list
+*/
+static inline void nx_nor_dmac_init(
+   nx_nor_dmac_ctrl_t *ctrl, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
+{
+   const int i=0;
+
+   stgt[i].src_addr  = ctrl->src_addr;
+   stgt[i].dst_addr  = ctrl->dst_addr;
+   stgt[i].tfr_size  = ((ctrl->xfer_count)/(ctrl->map->bankwidth));
+   stgt[i].flowctl   = nx_dmac_mem2mem_dma;
+   stgt[i].src_per   = 0;
+   stgt[i].dst_per   = 0;
+   stgt[i].src_inc   = true;
+   stgt[i].dst_inc   = true;
+   stgt[i].src_brst  = nx_dmac_256;
+   stgt[i].dst_brst  = nx_dmac_256;
+
+   if(ctrl->iswrite) 
+   {
+      stgt[i].src_ahb = nx_dmac_1902_ahb_master_1;
+      stgt[i].dst_ahb = nx_dmac_1902_ahb_master_2;
+      stgt[i].src_width = (ctrl->map->bankwidth>>1);
+      stgt[i].dst_width = (ctrl->map->bankwidth>>1);
+   }
+   else 
+   {
+      stgt[i].src_ahb = nx_dmac_1902_ahb_master_2;
+      stgt[i].dst_ahb = nx_dmac_1902_ahb_master_1;
+      stgt[i].src_width = (ctrl->map->bankwidth>>1);
+      stgt[i].dst_width = (0);
+   }
+   req->num_reqs = 1;
+   req->req = &stgt[0];
+}
+
+static void nx_nor_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+   struct nx_nor_info   *info = container_of(map, struct nx_nor_info, map);
+   dma_addr_t           dma_dst;
+   int                  chanid, status;
+
+   if(len < map->bankwidth)
+   {
+      info->map_copy.copy_from(map, to, from, len);
+   }
+   else
+   {
+      dma_dst = dma_map_single(NULL, to, len, DMA_FROM_DEVICE);
+
+      nor_ctrl.map         = map;
+      nor_ctrl.src_addr    = from;
+      nor_ctrl.dst_addr    = dma_dst;
+      nor_ctrl.xfer_count  = len;
+      nor_ctrl.iswrite     = false;
+
+      /* Scatter gather list for DMAC */
+      nx_nor_dmac_init(&nor_ctrl, &req, stgt);
+
+      chanid = nx_dmac_tfr(&req);
+      if(chanid < 0) 
+      {
+         printk(KERN_ERR "nx_nor_map_copy_from: nx_dmac_tfr\n"); 
+         return;
+      }
+
+      /* Complete DMAC transfer */
+      status = nx_dmac_tfr_comp(chanid);
+      if(status) 
+      {
+         printk(KERN_ERR "nx_nor_map_copy_from: nx_dmac_tfr_comp\n");
+         return;
+      }
+
+      if (len % map->bankwidth)
+      {
+         info->map_copy.copy_from (map, 
+            (void*)((u32)(to)+(len/map->bankwidth)*map->bankwidth),
+            from+(len/map->bankwidth)*map->bankwidth, 
+            len%map->bankwidth);
+      }
+   }
+   return;
+}
+
+static void nx_nor_map_copy_to (struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+   struct nx_nor_info   *info = container_of(map, struct nx_nor_info, map);
+   dma_addr_t           dma_src;
+   int                  chanid, status;
+   u32                  src = (u32)from;
+
+   if(len < map->bankwidth)
+   {
+      info->map_copy.copy_to(map, to, from, len);
+   }
+   else
+   {
+      dma_src = dma_map_single(NULL, (void *)src, len, DMA_TO_DEVICE);
+
+      nor_ctrl.map         = map;
+      nor_ctrl.src_addr    = dma_src;
+      nor_ctrl.dst_addr    = to;
+      nor_ctrl.xfer_count  = len;
+      nor_ctrl.iswrite     = true;
+
+      /* Scatter gather list for DMAC */
+      nx_nor_dmac_init(&nor_ctrl, &req, stgt);
+
+      chanid = nx_dmac_tfr(&req);
+      if(chanid < 0) 
+      {
+         printk(KERN_ERR "nx_nor_map_copy_to: nx_dmac_tfr\n"); 
+         return;
+      }
+
+      /* Complete DMAC transfer */
+      status = nx_dmac_tfr_comp(chanid);
+      if(status) 
+      {
+         printk(KERN_ERR "nx_nor_map_copy_to: nx_dmac_tfr_comp\n");
+         return;
+      }
+
+      if (len % map->bankwidth)
+      {
+         info->map_copy.copy_to (map, 
+            ((u32)(to)+(len/map->bankwidth)*map->bankwidth),
+            (void*)((u32)(from)+(len/map->bankwidth)*map->bankwidth), 
+            len%map->bankwidth);
+      }
+   }
+   return;
+}
+
+static void nx_nor_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
+{
+   nx_nor_map_copy_to(map, ofs, datum.x, map->bankwidth);
+}
+#endif
+#endif
+
+static int __init nx_nor_probe(struct platform_device *pdev)
+{
+   int err;
+   const char **probe_type;
+   struct nx_nor_info *info;
+   struct physmap_flash_data *pdata = pdev->dev.platform_data;
+   struct resource *res;
+   void __iomem *mmio_regs = NULL;
+   #if USE_DMAC_1902_DRIVER
+   extern struct platform_device dmac_1902_gcs_device;
+   #endif
+
+   resource_size_t mmio_start, mmio_len;
+
+   /* Get MMIO registers resource */
+   res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   if (!res) {
+      dev_err(&pdev->dev, "No MMIO resource found\n");
+      return -ENXIO;
+   }
+
+   mmio_start = res->start;
+   mmio_len   = res->end - res->start + 1;
+   mmio_regs = (void*)res->start;
+   
+   /* Get DMA MMIO registers resource */
+   res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+   if (!res){
+      dev_err(&pdev->dev, "No DMA resource found\n");
+      return -ENXIO;
+   }
+
+   dma_base = (void*)res->start;
+
+   /* Get I/O resource */
+   res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+   if (!res) {
+      dev_err(&pdev->dev, "No Memory resource found\n");
+      err = -ENXIO;
+      goto out_free2;
+   }
+
+   /* Alloc mem for info */
+   info = kzalloc(sizeof(struct nx_nor_info), GFP_KERNEL);
+   if (!info) {
+      dev_err(&pdev->dev, "Memory alloc failure\n");
+      err = -ENOMEM;
+      goto out_free2;
+   }
+
+   /* Allocate internal Read bounce buffer */
+   virt_bounce_read_buffer = dmam_alloc_coherent(&pdev->dev,
+         pdata->width*SZ_4K, &phys_bounce_read_buffer, GFP_DMA | GFP_KERNEL);
+   if(!virt_bounce_read_buffer) {
+      printk(KERN_ERR "nx_nor: DMA read buf alloc fail\r\n");
+      err = -ENOMEM;
+      goto out_free1;
+   }
+
+   /* Allocate internal Write bounce buffer */
+   virt_bounce_write_buffer = dmam_alloc_coherent(&pdev->dev,
+         pdata->width*SZ_4K, &phys_bounce_write_buffer, GFP_DMA | GFP_KERNEL);
+   if(!virt_bounce_write_buffer) {
+      printk(KERN_ERR "nx_nor: DMA write buf alloc \r\n");
+      err = -ENOMEM;
+      goto out_free1;
+   }
+      
+   /* Init info structure */
+   info->mmio_start    = mmio_start;
+   info->mmio_len      = mmio_len;
+   info->mmio_base     = mmio_regs;
+   info->map.virt      = 0;
+   info->map.name      = dev_name(&pdev->dev);
+   info->map.phys      = 0;
+   info->map.size      = res->end - res->start + 1;;
+   info->map.bankwidth = pdata->width;
+   info->map.set_vpp   = nx_nor_set_vpp;
+
+   /* simple_map_init(&info->map); */
+
+#if USE_DMAC_1902_DRIVER
+   info->map.read = nx_nor_map_read;
+   info->map.write = nx_nor_map_write;
+   info->map.copy_from = nx_nor_map_copy_from;
+   info->map.copy_to = nx_nor_map_copy_to;
+#endif
+
+#if USE_NX_NOR_DMAC_FUNCTIONS
+      info->map.read = nx_nor_map_read;
+      info->map.write = nx_nor_map_write;
+      info->map.copy_from = nx_nor_map_copy_from;
+      info->map.copy_to = nx_nor_map_copy_to;
+
+      err = nx_nor_dma_init();
+      if (err)
+         goto out_free1;
+#endif
+
+   /* Probe attached devices */
+   probe_type = probe_types;
+   for (; info->mtd == NULL && *probe_type != NULL; probe_type++) {
+      info->mtd = do_map_probe(*probe_type, &info->map);
+   }
+   if (!info->mtd) {
+      dev_err(&pdev->dev, "map_probe failed\n");
+      err = -EIO;
+      goto out_free1;
+   }
+   info->mtd->owner = THIS_MODULE;
+
+
+#if USE_DMAC_1902_DRIVER
+   /* Set DMA specific things here */
+   dma_cap_set(DMA_MEMCPY, info->client.cap_mask);
+   dma_cap_set(DMA_SLAVE, info->client.cap_mask);
+
+   info->client.event_callback = nx_nor_dmac_chan_alloc_cb;
+   info->client.slave = (struct dma_slave*) &info->slave;
+   info->slave.slave.dev = &pdev->dev;
+   info->slave.slave.dma_dev = &dmac_1902_gcs_device.dev;
+   dma_async_client_register(&info->client);
+
+   /* try to allocate a DMA channel */
+   dma_async_client_chan_request( &info->client);
+   /* check whether the channel is allocated or not */
+   if(!info->chan) {
+      dev_err(info->slave.slave.dev, "A DMA channel could not be allocated\n");
+      err = -EIO;
+      goto out_free;
+   }
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+   err = parse_mtd_partitions(info->mtd, part_probes, &info->parts, 0);
+   if (err > 0) {
+      add_mtd_partitions(info->mtd, info->parts, err);
+   }
+   else if (err <= 0) {
+      add_mtd_partitions(info->mtd, pdata->parts, pdata->nr_parts);
+   }
+   else {
+   } 
+#endif
+
+   /* Add MTD device */
+   add_mtd_device(info->mtd);
+
+   platform_set_drvdata(pdev, info);
+
+   return 0;
+
+out_free1:
+   kfree(info);
+   platform_set_drvdata(pdev, NULL);
+
+out_free2:
+   return err;
+}
+
+static int __exit nx_nor_remove(struct platform_device *pdev)
+{
+   struct nx_nor_info *info = platform_get_drvdata(pdev);
+
+   platform_set_drvdata(pdev, NULL);
+   if (info) {
+      /* De-Allocate internal Read driver buffer */
+      dmam_free_coherent(&pdev->dev, info->map.bankwidth*SZ_4K, virt_bounce_read_buffer, phys_bounce_read_buffer);
+
+      /* De-Allocate internal Write driver buffer */
+      dmam_free_coherent(&pdev->dev, info->map.bankwidth*SZ_4K, virt_bounce_write_buffer, phys_bounce_write_buffer);
+
+      if(info->mmio_base) {
+         iounmap(info->mmio_base);
+         release_mem_region(info->mmio_start, info->mmio_len);
+      }
+
+      if (info->parts) {
+         del_mtd_partitions(info->mtd);
+         kfree(info->parts);
+      } 
+
+      del_mtd_device(info->mtd);
+      map_destroy(info->mtd);
+      kfree(info);
+   }
+
+   return 0;
+}
+
+#ifdef CONFIG_PM
+static int nx_nor_suspend(struct platform_device *pdev, pm_message_t state)
+{
+   struct nx_nor_info *info = platform_get_drvdata(pdev);
+   int ret = 0;
+   unsigned long val;
+   unsigned long dma_wait_timeout = jiffies + msecs_to_jiffies(10000);
+
+   suspend=1;
+
+   if (info)
+   { 
+      if(info->mtd && info->mtd->suspend)
+         ret = info->mtd->suspend(info->mtd);
+
+      do
+      {
+          if (time_after_eq(jiffies, dma_wait_timeout))
+          {
+              printk(KERN_ERR "nx_nor_dma_completion_wait: timeout!\n");
+              return -EIO;
+          }
+      } while (nor_dma_done == false);
+
+      /* Put the controller (IP2016) into power down mode */
+      if(!ret)
+      {
+         val = readl((info->mmio_base + APOLLO_IP2016_POWER_DOWN_CFG_OFFSET));
+
+         val &= ~APOLLO_IP2016_POWER_DOWN_MASK;
+         val |= (APOLLO_IP2016_POWER_DOWN_ENABLE & APOLLO_IP2016_POWER_DOWN_MASK);
+
+         writel(val, (info->mmio_base + APOLLO_IP2016_POWER_DOWN_CFG_OFFSET));
+      }
+   }
+
+   return ret;
+}
+
+static int nx_nor_resume(struct platform_device *pdev)
+{
+   struct nx_nor_info *info = platform_get_drvdata(pdev);
+   unsigned long val;
+
+   if (info)
+   {
+      /* Bring the controller out of power down mode */
+      val = readl((info->mmio_base + APOLLO_IP2016_POWER_DOWN_CFG_OFFSET));
+
+      val &= ~APOLLO_IP2016_POWER_DOWN_MASK;
+      val |= (APOLLO_IP2016_POWER_DOWN_DISABLE & APOLLO_IP2016_POWER_DOWN_MASK);
+
+      writel(val, (info->mmio_base + APOLLO_IP2016_POWER_DOWN_CFG_OFFSET));
+
+      if (info->mtd && info->mtd->resume)
+         info->mtd->resume(info->mtd);
+   }
+
+   suspend=0;
+
+   return 0;
+}
+
+static void nx_nor_shutdown(struct platform_device *pdev)
+{
+   struct nx_nor_info *info = platform_get_drvdata(pdev);
+
+   if (info)
+   { 
+      if(info->mtd && info->mtd->suspend && info->mtd->resume) {
+         if(0 == info->mtd->suspend(info->mtd))
+            info->mtd->resume(info->mtd);
+      }
+   }
+}
+
+#else
+#define nx_nor_suspend   NULL
+#define nx_nor_resume    NULL
+#define nx_nor_shutdown  NULL
+#endif
+
+static struct platform_driver nx_nor_driver = {
+   .remove   = __exit_p(nx_nor_remove),
+   .suspend  = nx_nor_suspend,
+   .resume   = nx_nor_resume,
+   .shutdown = nx_nor_shutdown,
+   .driver   = {
+      .name  = "nx_2016",
+      .owner = THIS_MODULE,
+   },
+};
+
+static int __init nx_nor_init(void)
+{
+   return platform_driver_probe(&nx_nor_driver, nx_nor_probe);
+}
+
+static void __exit nx_nor_exit(void)
+{
+   platform_driver_unregister(&nx_nor_driver);
+}
+
+module_init(nx_nor_init);
+module_exit(nx_nor_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD NOR map driver for APOLLO");
+MODULE_ALIAS("platform:nx_2016");
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/Kconfig linux-2.6.34/drivers/mtd/nand/Kconfig
--- linux-2.6.34.orig/drivers/mtd/nand/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -488,4 +488,6 @@ config MTD_NAND_W90P910
 	  This enables the driver for the NAND Flash on evaluation board based
 	  on w90p910.
 
+source "drivers/mtd/nand/nx_nand/Kconfig"
+
 endif # MTD_NAND
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/Makefile linux-2.6.34/drivers/mtd/nand/Makefile
--- linux-2.6.34.orig/drivers/mtd/nand/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -28,6 +28,7 @@ obj-$(CONFIG_MTD_NAND_GPIO)		+= gpio.o
 obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o
 obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+obj-$(CONFIG_MTD_NX_NAND)		+= nx_nand/
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
 obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nand_base.c linux-2.6.34/drivers/mtd/nand/nand_base.c
--- linux-2.6.34.orig/drivers/mtd/nand/nand_base.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nand_base.c	2010-09-07 22:16:40.000000000 -0500
@@ -2533,6 +2533,65 @@ static void nand_resume(struct mtd_info 
 		       "in suspended state\n", __func__);
 }
 
+/*************************************************************************************************/
+#if 0
+/*
+ * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
+ * after mapping over any bad blocks when read only.
+ *
+ * @mtd:        MTD device structure
+ * @from:       offset to read from
+ * @len:        number of bytes to read
+ * @retlen:     pointer to variable to store the number of read bytes
+ * @buf:        the databuffer to put data
+*/
+static int nand_block_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+   int ret;
+
+#ifdef CONFIG_MTD_SKIP_BB_FOR_SQUASHFS
+   /* if partition writable (and not squashfs) just read with ECC */
+   if ((mtd->flags & MTD_SKIP_BB_FOR_SQUASHFS) != MTD_SKIP_BB_FOR_SQUASHFS)
+#endif
+      if ((mtd->flags & MTD_WRITEABLE) == MTD_WRITEABLE) {
+         ret = nand_read (mtd, from, len, retlen, buf);
+         return (ret == -EUCLEAN) ? 0 : ret;
+      }
+
+   /* skip bad blocks (for squashfs irrespectable of ro/rw */
+   from = map_over_bad_blocks(mtd, from);
+
+   /* exchausted memory; simulated read of 0xff */
+   if (from == (loff_t)-1) {
+      memset(buf, 0xff, len);
+      *retlen = len;
+      return 0;
+   }
+
+   /* the length must always be less than the erase size */
+   BUG_ON(len > mtd->erasesize);
+
+
+   /* do the read by just skipping over any bad blocks as they weren't there */
+   ret = nand_read (mtd, from, len, retlen, buf);
+   return (ret == -EUCLEAN) ? 0 : ret;
+}
+
+/*
+ * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
+ *
+ * @mtd:        MTD device structure
+ * @to:         offset to write to
+ * @len:        number of bytes to write
+ * @retlen:     pointer to variable to store the number of written bytes
+ * @buf:        the data to write
+*/
+static int nand_block_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+   BUG_ON((mtd->flags & MTD_WRITEABLE) == MTD_WRITEABLE);  /* must be writable to work */
+   return (nand_write (mtd, to, len, retlen, buf));
+}
+#endif
 /*
  * Set default functions
  */
@@ -2717,7 +2776,7 @@ static struct nand_flash_dev *nand_get_f
 	/* Check if chip is a not a samsung device. Do not clear the
 	 * options for chips which are not having an extended id.
 	 */
-	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+	if ((*maf_id != NAND_MFR_SAMSUNG) && (*maf_id != NAND_MFR_STMICRO) && (*maf_id != NAND_MFR_HYNIX) && (!type->pagesize))
 		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 
 	/* Check for AND chips with 4 page planes */
@@ -3006,6 +3065,11 @@ int nand_scan_tail(struct mtd_info *mtd)
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
 
+#if 0
+   mtd->block_read = nand_block_read;
+   mtd->block_write = nand_block_write;
+#endif
+
 	/* propagate ecc.layout to mtd_info */
 	mtd->ecclayout = chip->ecc.layout;
 
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nand_bbt.c linux-2.6.34/drivers/mtd/nand/nand_bbt.c
--- linux-2.6.34.orig/drivers/mtd/nand/nand_bbt.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nand_bbt.c	2010-09-07 22:16:40.000000000 -0500
@@ -336,6 +336,8 @@ static int scan_block_fast(struct mtd_in
 	ops.ooboffs = 0;
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
+	
+	mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
 
 	for (j = 0; j < len; j++) {
 		/*
@@ -352,6 +354,9 @@ static int scan_block_fast(struct mtd_in
 
 		offs += mtd->writesize;
 	}
+	
+	mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+
 	return 0;
 }
 
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/Kconfig linux-2.6.34/drivers/mtd/nand/nx_nand/Kconfig
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,44 @@
+#NAND driver for TV555555atforms
+
+menuconfig MTD_NX_NAND
+	tristate "NAND Device IP_2070 Support"
+	depends on MTD_NAND
+  select MTD_PARTITIONS
+	help
+	  This enables support for accessing NAND flash
+	  devices on TV55X platforms.
+
+if MTD_NX_NAND
+
+choice #ECC options
+	prompt "PNX85XXX/TV55X ECC options"
+	depends on MTD_NX_NAND
+	default  MTD_NX_NAND_HWECC
+
+config MTD_NX_NAND_HWECC
+	bool "HWECC RS codec support"
+	help
+	  This is enables the HW ECC provided by IP_2070 controller.
+		The controller supports 5 symbols correction per 512 bytes.
+
+config MTD_NX_NAND_SWECC
+	bool "SWECC support"
+	help
+	  This is enables the SW ECC provided by MTD subsytem.
+		The controller supports 1 bit correction per 256 bytes.
+
+config MTD_NX_NAND_NONEECC
+	bool "ECC support disabled"
+	help
+	  This is disbales the ECC support.
+
+endchoice #ECC options
+
+endif # MTD_NAND
+
+config MTD_NX_NAND_PART_PARSE
+  tristate "Partition parser support IP_2070 driver"
+  depends on MTD_NX_NAND
+  help
+    This enables the Flash partition parser functionality
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/Makefile linux-2.6.34/drivers/mtd/nand/nx_nand/Makefile
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,22 @@
+# Makefile for the Linux IP_2070 NAND driver
+
+
+_TMDIVERSITY=nobsl
+HWAPI_FLAGS-y := -Iinclude/HwAPI
+HWAPI_FLAGS-y +=  -Idrivers/mtd/nand/nx_nand/tmhwEfmc/cfg \
+                  -Idrivers/mtd/nand/nx_nand/tmhwEfmc/inc \
+                  -Idrivers/mtd/nand/nx_nand/tmhwEfmc/src \
+                  -Iarch/mips/include/asm
+
+nx_nand_flags-$(CONFIG_SOC_PNX85500) := -DTMFL_PNX_ID=85500
+nx_nand_flags-$(CONFIG_ARCH_APOLLO) := -DMIPSEL
+
+EXTRA_CFLAGS   := $(HWAPI_FLAGS-y)
+EXTRA_CFLAGS += $(nx_nand_flags-y) -DLINUX_BUILD -DLINUX -DMONTAVISTA_GNU -DTMFL_OS_IS_HPUNIX=0
+
+nand_nx-objs += $(nx_nand-y) nx_nand.o \
+                    tmhwEfmc/src/tmhwEfmc.o \
+                    tmhwEfmc/cfg/tmhwEfmc_Cfg.o
+
+obj-$(CONFIG_MTD_NX_NAND_PART_PARSE) += nx_part.o
+obj-$(CONFIG_MTD_NX_NAND) += nand_nx.o
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_nand.c linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_nand.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,2442 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version     Author           Date          Remarks    
+ * 0.0.1    Bangaragiri G        20080318    Draft-Initial version
+ * 0.1.0    Bangaragiri G        20080804    Proposal-After self review
+ * 0.2.0    Bangaragiri G        20080925    Proposal-After including review comments
+ * 1.0.0    Bangaragiri G        20090305    Accepted-After testing on TV550M0 board
+ * 1.1.0    Bangaragiri G        20090313    Accepted-After DMAC updates for OneNAND
+ */
+
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/nx_dmac.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <mach/nx_nand_dev.h>
+
+#include "nx_nand.h"
+#include "tmhwEfmc.h"
+#include "tmhwEfmc_Cfg.h"
+#include "tmhwEfmc_Vhip.h"
+
+#ifdef CONFIG_MTD_PERF_MEAS
+#include <mach-pnx85500/glb.h>
+#define  TSU_COUNTER_REG      (volatile unsigned int *)(PNX8XXX_MMIO_BASE_VIRT + 0x14C0C0)
+#endif
+
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+
+#define  NUM_OOB_OVERLAP_DATA (16 * 3)
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+*  OOB structure
+*/
+/* For LPF */
+static struct nand_ecclayout nx_nand_oob_64 = {
+   .eccbytes = 48,
+   .eccpos = {
+          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+         20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+         52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
+   .oobfree = {
+      {.offset = 2,
+       .length = 2},
+      {.offset = 16,
+       .length = 4},
+      {.offset = 32,
+       .length = 4},
+      {.offset = 48,
+       .length = 4},
+   }
+};
+
+/* For SPF */
+static struct nand_ecclayout nx_nand_oob_16 = {
+      .eccbytes = 16,
+            .eccpos = {
+                  4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
+            },
+            .oobfree = {
+            {
+                  .offset = 0,
+                  .length = 4},
+            }
+      };
+#endif
+
+/**
+*  Flash based BBT information for LPF
+*/
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+
+static uint8_t nx_bbt_pattern[] = {'N', 'X', 'P' };
+static uint8_t nx_mirror_pattern[] = {'P', 'X', 'N' };
+
+static struct nand_bbt_descr nx_bbt_main = {
+   .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+      | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+   .offs =  0,
+   .len = 3,
+   .veroffs = 3,
+   .maxblocks = 4,
+   .pattern = nx_bbt_pattern
+};
+
+static struct nand_bbt_descr nx_bbt_mirror = {
+   .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+      | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+   .offs =  0,
+   .len = 3,
+   .veroffs = 3,
+   .maxblocks = 4,
+   .pattern = nx_mirror_pattern
+};
+
+#endif
+
+/**
+* NAND control structure
+*/
+struct nx_nand_ctrl *nx_nc = NULL;
+
+/**
+* MTD Partitions structure 
+*/
+static struct mtd_partition partition_info1[] = {
+   {
+      .name = (char *)"bootcode",
+      .offset = 0,
+      .size   = 16*1024,
+   },
+   {
+      .name = (char *)"Flash partition 0",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = (2*1024*1024)-(16*1024),
+   },
+   {
+      .name = (char *)"Flash partition 1",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = 2*1024*1024,
+   },
+   {
+      .name = (char *)"Flash partition 2",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = MTDPART_SIZ_FULL,
+   }
+};
+
+struct mtd_partition partition_info2[] = {
+   {
+      .name = (char *)"Bootloader (256K)",
+      .offset = 0,
+      .size   = (256*1024),
+   },
+   {
+      .name = (char *)"2. kernel-image (12M)",
+      .offset = (256*1024),
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"3. AVDSP Image (12M)",
+      .offset = ((256*1024) + (12*1024*1024)), 
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"4. RFS-SELP-SISC-NXP (12M-CRAMFS)",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)), 
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"5. DTV APP(40M-CRAMFS)",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)), 
+      .size   = (40*1024*1024),
+   },
+   {
+      .name = (char *)"6. RW Area (5M-JFFS2) ",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)), 
+      .size   = 5*1024*1024,
+   },
+   {
+      .name = (char *)"7. TEMP (40M-JFFS2) ",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)+(5*1024*1024)), 
+      .size   = 40*1024*1024,
+   },
+};
+
+/**
+* MTD command line partition parser 
+*/
+/*We don't need nxpart parser */
+/*const char *part_probes[] = { "cmdlinepart", "nxpart", NULL };*/
+
+const char *part_probes[] = { "cmdlinepart", NULL };
+
+#define NX_NAND_READ_INT   (NX_NAND_INT_DEC_UNCOR | \
+                                           NX_NAND_INT_DEC_0_ERR | \
+                                           NX_NAND_INT_DEC_1_ERR | \
+                                           NX_NAND_INT_DEC_2_ERR | \
+                                           NX_NAND_INT_DEC_3_ERR | \
+                                           NX_NAND_INT_DEC_4_ERR | \
+                                          NX_NAND_INT_DEC_5_ERR)
+
+/*------------------------------------------------------------------------------------
+* Internal functions 
+--------------------------------------------------------------------------------------*/
+#ifdef CONFIG_MTD_NX_NAND_DMAC
+/**
+* nx_nand_dmac_init - Configure the DMAC scatter gather list
+* @nc: NAND control structure
+* @read: Read command
+* @req: Request structure
+* @stgt: Scatter gather array
+*
+* Initialise the DMAC scatter gather list
+*/
+static inline void nx_nand_dmac_init(struct nx_nand_ctrl *nc, 
+         uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
+{
+   int i;
+
+   if(cmd) {
+         
+      /* Read Main Area */
+      for(i=0; i < nc->num_blks; i++) {
+         stgt[i].src_addr = NX_NAND_AHB_BUF;     
+      stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
+      stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
+         stgt[i].flowctl = nx_dmac_per2mem_dma;         
+         stgt[i].src_per = 0;              
+      stgt[i].dst_per = 0;
+         stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+      stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      stgt[i].src_brst = nx_dmac_128;
+      stgt[i].dst_brst = nx_dmac_128;
+      stgt[i].src_width = nx_dmac_width_32;
+      stgt[i].dst_width = nx_dmac_width_32;
+      }
+   
+      /* Read OOB area */
+      stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
+   stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
+   stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+      stgt[i].flowctl = nx_dmac_per2mem_dma;         
+      stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+   stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+      stgt[i].src_per = 0;              
+      stgt[i].dst_per = 0;
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      if(nc->mtd.oobsize == 128) {
+         stgt[i].src_brst = nx_dmac_32;
+         stgt[i].dst_brst = nx_dmac_32;
+      }
+      else if(nc->mtd.oobsize == 64) {
+         stgt[i].src_brst = nx_dmac_16;
+         stgt[i].dst_brst = nx_dmac_16;
+      }
+      else {
+         stgt[i].src_brst = nx_dmac_4;
+         stgt[i].dst_brst = nx_dmac_4;
+      }
+   stgt[i].src_width = nx_dmac_width_32;
+   stgt[i].dst_width = nx_dmac_width_32;
+   }
+   else { 
+      
+      /* Write OOB area */
+      i=0;  
+      stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
+   stgt[i].src_addr = nc->dmabuf_phy + (nc->num_blks * NX_NAND_BLK_SIZE);
+   stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+      stgt[i].flowctl = nx_dmac_mem2per_dma;         
+      stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+      stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+      stgt[i].src_per = 0;              
+      stgt[i].dst_per = 0;
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      if(nc->mtd.oobsize == 128) {
+         stgt[i].src_brst = nx_dmac_32;
+         stgt[i].dst_brst = nx_dmac_32;
+      }
+      else if(nc->mtd.oobsize == 64) {
+         stgt[i].src_brst = nx_dmac_16;
+         stgt[i].dst_brst = nx_dmac_16;
+      }
+      else {
+         stgt[i].src_brst = nx_dmac_4;
+         stgt[i].dst_brst = nx_dmac_4;
+      }
+   stgt[i].src_width = nx_dmac_width_32;
+   stgt[i].dst_width = nx_dmac_width_32;
+         
+      /* Write Main area */
+      for(i=1; i< (nc->num_blks+1); i++) {
+      stgt[i].src_addr = nc->dmabuf_phy + ( (i-1) * NX_NAND_BLK_SIZE);
+         stgt[i].dst_addr = NX_NAND_AHB_BUF;     
+      stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
+         stgt[i].flowctl = nx_dmac_mem2per_dma;         
+         stgt[i].src_per = 0;             
+      stgt[i].dst_per = 0;
+         stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+      stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      stgt[i].src_brst = nx_dmac_128;
+      stgt[i].dst_brst = nx_dmac_128;
+      stgt[i].src_width = nx_dmac_width_32;
+      stgt[i].dst_width = nx_dmac_width_32;
+      }
+   }
+ 
+   req->num_reqs = nc->num_blks + 1;
+   req->req = &stgt[0];
+}
+#endif
+
+/**
+* nx_nand_cmd_addr - Send cmd & address cycles to chip
+* @nc: NAND control structure
+* @cmd: Command to be send
+* @data: command or data
+* @last: Last cycle
+*
+* Send command & address cycles to chip for small page chips
+*/
+static inline void nx_nand_cmd_addr(struct nx_nand_ctrl *nc, uint32_t cmd,
+                 uint32_t data, int last)
+{
+   tmhwEfmc_CmdAddr_t   cmd_addr;
+   
+   /* Chip enable */
+   cmd_addr.deviceNum = (0 << (nc->slotid + NX_NAND_CMD_FIFO_CE_START));
+
+   /* Cmd or address */
+   switch(cmd)
+   {
+      case NX_NAND_CMD_FIFO_ADDR_CYC:
+         cmd_addr.cycleType = tmhwEfmc_AddrCycle;
+         break;
+      
+      case NX_NAND_CMD_FIFO_CMD_CYC:
+         cmd_addr.cycleType = tmhwEfmc_CmdCycle;
+         break;
+      
+      case NX_NAND_CMD_FIFO_POST_CMD:
+         cmd_addr.cycleType = tmhwEfmc_PostWrCmdCycle;
+         break;
+      
+      default:
+         printk(KERN_ERR "nx_nand:Invalid cmd \r\n"); 
+         return;
+   }
+
+   /* Last cmd or addr cycle */
+   if(last)
+      cmd_addr.lastCycle = TM_TRUE;
+   else
+      cmd_addr.lastCycle = TM_FALSE;
+   
+   /* Addr or Cmd */
+   cmd_addr.data = data;
+   
+   /* Send to chip */
+   tmhwEfmc_WriteCmdAddr(0, &cmd_addr);
+}
+
+/*------------------------------------------------------------------------------------
+* Performance Measurement functions 
+--------------------------------------------------------------------------------------*/
+#ifdef CONFIG_MTD_PERF_MEAS
+
+#define TSU_CYCLE_TIME   (75)  // 75nsec
+
+int nand_perf_meas(struct mtd_info *mtd,  uint32_t start, uint32_t end,
+            enum mtd_meas_oper oper)
+{
+   int i;
+   uint32_t diff, min, max, sum, ave;
+
+   if(!mtd->perf.cmd_meas) {
+      printk(KERN_INFO "Operation Not Set\r\n");
+      return 0;
+   }
+
+   /* Check if mode valid */
+   if(mtd->perf.cmd_meas != oper) {
+      printk(KERN_INFO "Not correct operation Set\r\n");
+      return 0;
+   }
+
+   /* Check if number of iterations still valid */
+   if(mtd->perf.cnt >= mtd->perf.num_iter){
+      //printk(KERN_INFO "Iterations cnt: 0x%x iter: 0x%x \r\n", mtd->perf.cnt, mtd->perf.num_iter);
+      return 0;
+   }
+
+   /* store value */
+   diff = end - start;
+   mtd->perf.values[mtd->perf.cnt] = diff; 
+   mtd->perf.cnt++;
+   if(mtd->perf.cnt == mtd->perf.num_iter) {
+
+      /* Get min value */
+      min = 0xFFFFFFFF;
+      for(i=0; i < mtd->perf.cnt; i++)
+      {
+         if(mtd->perf.values[i] < min) {
+            min = mtd->perf.values[i];
+         }
+      }
+      //mtd->perf.data.min_time = min;
+      mtd->perf.data.min_time = (min * TSU_CYCLE_TIME);
+      
+      /* Get max value */
+      max = 0x0;
+      for(i=0; i < mtd->perf.cnt; i++)
+      {
+         if(mtd->perf.values[i] > max) {
+            max = mtd->perf.values[i];
+         }
+      }
+      //mtd->perf.data.max_time = max;
+      mtd->perf.data.max_time = (max * TSU_CYCLE_TIME);
+
+      sum = 0;
+      for(i=0; i < mtd->perf.cnt; i++) {
+         //printk(KERN_INFO "iter: %d cycles: 0x%x \r\n", i, mtd->perf.values[i]);
+         sum += mtd->perf.values[i];
+      }
+      ave = sum / mtd->perf.cnt;
+      //mtd->perf.data.ave_time = ave;
+      mtd->perf.data.ave_time = (ave * TSU_CYCLE_TIME);
+      //mtd->perf.cmd_meas = MTD_MEAS_NONE;
+      //mtd->perf.cnt = 0;
+   }
+   
+   return 1;
+}
+#endif
+ 
+/*------------------------------------------------------------------------------------
+* NAND chip specific functions 
+--------------------------------------------------------------------------------------*/
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_calculate_ecc - HW ECC calculate
+* @mtd: MTD information structure
+* @dat: Databuffer
+* @ecc_code: ECC code buffer
+*
+* Dummy function for HW ECC calculation
+*/
+static int nx_nand_calculate_ecc(struct mtd_info *mtd ATTRIBUTE_UNUSED, const uint8_t *dat ATTRIBUTE_UNUSED,
+                     uint8_t *ecc_code ATTRIBUTE_UNUSED)
+{
+   return 0;
+}
+
+/**
+* nx_nand_correct_data - HW ECC correct
+* @mtd: MTD information structure
+* @dat: Databuffer
+* @read_ecc: Read ECC code buffer
+* @calc_ecc: Calculated ECC buffer
+*
+* Dummy function for HW ECC calculation
+*/
+static int nx_nand_correct_data(struct mtd_info *mtd ATTRIBUTE_UNUSED, uint8_t *dat ATTRIBUTE_UNUSED,
+                   uint8_t *read_ecc ATTRIBUTE_UNUSED, uint8_t *calc_ecc ATTRIBUTE_UNUSED)
+{
+   return 0;
+}
+
+/**
+* nx_nand_hwctl - HW ECC control function
+* @mtd: MTD information structure
+* @mode: Mode
+*
+* Dummy function for HW ECC calculation
+*/
+static void nx_nand_hwctl(struct mtd_info *mtd ATTRIBUTE_UNUSED, int mode ATTRIBUTE_UNUSED)
+{
+   return;
+}
+
+#endif
+
+/**
+* nx_nand_select_chip - Enable or Disable chip
+* @mtd: MTD information structure
+* @chipnr: Chip number
+*
+* Enable the chip if it chipnr >= 0, else disable the chip
+*/
+static void nx_nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+   if(chipnr == -1)
+      return;
+   
+   /* Store the value in nand control structure 
+    * Chip enable/disable done in command function */
+   nc->slotid = chipnr;
+}
+
+/**
+* nx_nand_dev_ready - Check device ready
+* @mtd: MTD information structure
+*
+* Return true if the device is ready, false otherwise
+*/
+static int nx_nand_dev_ready(struct mtd_info *mtd)
+{
+   tmhwEfmc_ReadBusySignal_t dev_stat;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   
+   /* Get status from controller */
+   tmhwEfmc_GetBusyStatus(nc->unitid, nc->slotid, &dev_stat);
+
+   /* Return with R/B status */
+   return (dev_stat.rbEdge_Status_Ready);
+}
+
+/**
+* nx_nand_read_byte - Read a byte from chip
+* @mtd: MTD information structure
+*
+* Read a byte from the nand chip
+*/
+static uint8_t nx_nand_read_byte(struct mtd_info *mtd)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint16_t data;
+
+   /* Read 16-bit word */
+   tmhwEfmc_ReadSingleData(nc->unitid, &data);
+   
+   return (uint8_t) cpu_to_le16(data);
+}
+
+/**
+* nx_nand_read_byte16 - Read a byte from 16bit chip
+* @mtd: MTD information structure
+*
+* Read a byte from the 16bit nand chip
+*/
+static uint8_t nx_nand_read_byte16(struct mtd_info *mtd)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint16_t data;
+
+   /* Read byte word */
+   tmhwEfmc_ReadSingleData(nc->unitid, &data);
+   
+   return (uint8_t) cpu_to_le16(data);
+}
+
+/**
+* nx_nand_read_buf - Read data from chip
+* @mtd: MTD information structure
+* @buf: Data buffer
+* @len: Transfer size
+*
+* Read specified number of bytes from the driver buffer
+*/
+static void nx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   
+   /* Copy from driver buffer */
+   memcpy(buf, nc->dmabuf + nc->offset, len);
+   nc->offset += len;
+}
+
+/**
+* nx_nand_read_page_raw - Read 1 page data from chip
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Read a full page + oob into the buffer
+*/
+static int nx_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+              uint8_t *buf, int page)
+{
+   chip->read_buf(mtd, buf, mtd->writesize);
+   chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+   return 0;
+}
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_read_page - Read 1 page data from chip with HWECC
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Read a full page + oob into the buffer
+*/
+static int nx_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+              uint8_t *buf, int page)
+{
+   int stat=0, i;
+   uint32_t j;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   int eccsteps = chip->ecc.steps;
+   int no_all_ffs=0;
+   
+#ifdef CONFIG_MTD_PERF_MEAS
+   volatile uint32_t start, end1;
+#endif
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   start = readl(TSU_COUNTER_REG);
+#endif
+   
+   /* Read page data */
+   nx_nand_read_page_raw(mtd, chip, buf, page);
+
+   /* Check ECC status */
+   for (i = 0 ; i<eccsteps; i++) {
+         
+      if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
+   
+         for(j=0; j < mtd->writesize; j++) {
+            if(buf[j] != 0xFF) {
+               no_all_ffs = 1;
+               break;
+            }
+         }
+
+         if(no_all_ffs) {  
+            printk(KERN_INFO "step %d: ECC failed \r\n", j);   
+            mtd->ecc_stats.failed++;
+         }
+      }
+      else {
+         /* Update stats */   
+         switch (nc->ecc_status[i])
+         {
+            case NX_NAND_INT_DEC_1_ERR:
+               printk(KERN_INFO "step %d:ECC 1 bit corrected \r\n", i); 
+               stat = 1;
+               break;
+            
+            case NX_NAND_INT_DEC_2_ERR:
+               printk(KERN_INFO "step %d:ECC 2 bits corrected \r\n", i);   
+               stat = 2;
+               break;
+               
+            case NX_NAND_INT_DEC_3_ERR:
+               printk(KERN_INFO "step %d:ECC 3 bits corrected \r\n", i);   
+               stat = 3;
+               break;
+               
+            case NX_NAND_INT_DEC_4_ERR:
+               printk(KERN_INFO "step %d:ECC 4 bits corrected \r\n", i);   
+               stat = 4;
+               break;
+               
+            case NX_NAND_INT_DEC_5_ERR:
+               printk(KERN_INFO "step %d:ECC 5 bits corrected \r\n", i);   
+               stat = 5;
+               break;
+         }
+         mtd->ecc_stats.corrected += stat;
+      }
+   }
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   end1 = readl(TSU_COUNTER_REG);
+   nand_perf_meas(mtd, start, end1, MTD_MEAS_READ);
+#endif
+   
+   return 0;
+}
+#endif
+
+/**
+* nx_nand_read_oob - Read OOB data
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @page: Page address
+* @sndcmd: Send command flag
+*
+* Read OOB data into the buffer
+*/
+static int nx_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+              int page, int sndcmd)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint8_t *buf = chip->oob_poi;
+   int status = 0;
+  int length = mtd->oobsize;
+   int column, addr, i;
+   uint16_t data;
+   tmhwEfmc_PageConfig_t   page_cfg;
+
+   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+   
+      /* Use Device OOB layout (Main page data followed by OOB data) */    
+      /* No page operation  for OOB */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      page_cfg.includeAES = false;
+      page_cfg.includeECC = false;
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+   
+      /* Send READOOB command */ 
+      if(sndcmd) {
+         chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+      }
+   
+      /* Check if CE DON't care is supported */
+      column = nc->cur_col;
+      i = 0;
+      while(length) {
+      
+         /* Send Address & cmd cycles */
+         if(sndcmd) {
+         
+            nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
+   
+            if(nc->lb_chip) {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+               
+               addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+         
+               /* if > 2Gb, extra address cycle */
+               if (nc->chip.chipsize >= (1 << 28)) {
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+               }
+            
+               /* Send Read confirm command */
+               nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+            }
+            else {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+         
+               /* if > 64Mb, extra adddress cycle */
+               if (nc->chip.chipsize > (32 << 20)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+               
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+            }
+            sndcmd = 0;
+
+            /* Wait for completion */
+            udelay(chip->chip_delay);
+         }
+
+         /* Write data into chip */
+         status  = tmhwEfmc_ReadSingleData(nc->unitid, &data);    
+         buf[i] = (uint8_t) data; 
+         //printk(KERN_INFO "ReadSingle data 0x%x 0x%x \r\n", buf[i], data);
+      
+         length--;
+         i++;
+      
+         if(!nx_nc->cedontcare) {
+            sndcmd = 1; 
+            column++;
+         }
+      }
+   }
+   else {
+      /* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
+      /* Use IP_2017 OOB layout - Read page */
+         
+      /* Send READOOB command */ 
+      if(sndcmd) {
+         chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+         sndcmd = 0;
+      }
+
+      /* Copy into user buffer */
+      nc->offset = mtd->writesize;
+      chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+   }
+   
+   return 0;
+}
+
+/**
+* nx_nand_write_buf - Write data into chip
+* @mtd: MTD information structure
+* @buf: Data buffer
+* @len: Transfer size
+*
+* Write specified number of bytes into the nand chip
+*/
+static void nx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, 
+      int len)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+   /* Copy data to driver buffer */
+   memcpy(nc->dmabuf + nc->offset, buf, len);
+   nc->offset += len;
+}
+
+/**
+* nx_nand_write_page_raw - Write 1 page data into chip
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Write a full page + oob into the buffer
+*/
+static void nx_nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+              const uint8_t *buf)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint32_t intr=0;
+   uint16_t addr;
+   tmhwEfmc_PageConfig_t page_cfg;
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC   
+   int chanid, status;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t           req;
+   nx_dmac_stgt_t       stgt[5];
+#endif
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   uint32_t start, end1;
+#endif
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   start = readl(TSU_COUNTER_REG);
+#endif
+   
+   /* Copy data into buffer */
+   chip->write_buf(mtd, buf, mtd->writesize);
+   chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC   
+   
+   /* Scatter gather list for DMAC */
+   nx_nand_dmac_init(nc, 0, &req, stgt);
+   
+   /* Flow control */
+   dma_cfg.enableM2PDma = tmhwEfmc_Enable;
+   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+   chanid = nx_dmac_tfr(&req);
+   if(chanid < 0) {
+      printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n"); 
+      return;
+   }
+
+   /* Page operation */
+   page_cfg.includeOOB = true;
+   page_cfg.operType = tmhwEfmc_PageWrite;
+   
+   if(nc->aes) {
+      page_cfg.includeAES = true;
+   }
+   else {
+      page_cfg.includeAES = false;
+   }
+   
+   if(nc->hwecc) {
+      page_cfg.includeECC = true;
+   }
+   else {
+      page_cfg.includeECC = false;
+   }
+   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+   
+   /* Clear the interrupts */
+   intr = NX_NAND_INT_SEQ_WRITE;
+   intr |= 1 << (NX_NAND_INT_READY_START + nc->slotid);
+   tmhwEfmc_IntClear(nc->unitid, intr);
+   
+   /* Enable the SEQ READ PAGE DONE interrupt */
+   tmhwEfmc_IntEnable(nc->unitid, intr);
+
+   /* Send address cycles & command */
+   nc->done = false;
+   nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+   
+   if(nc->lb_chip) {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+         
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      /* if > 2Gb, extra address cycle */
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+   else {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+         
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      /* if > 64Mb, extra adddress cycle */
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+   
+   /* Send post write command */
+   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+
+   /* Complete DMAC transfer */
+   status = nx_dmac_tfr_comp(chanid);
+   if(status) {
+      printk(KERN_ERR "nx_nand: write_page_raw \r\n");   
+      return;
+   }
+   
+   /* Wait for READY interrupt */   
+   wait_event(nc->nand_queue, (nc->done != false));
+   
+   /* Disable interrupts */   
+   tmhwEfmc_IntDisable(nc->unitid, intr);
+      
+   /* Disable Flow control */
+   dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+   
+#else 
+   
+   /* Init page operation */
+   nc->blk_index = 0;
+
+   /* Send Cmd & address to chip */
+   page_cfg.includeOOB = true;
+   page_cfg.operType = tmhwEfmc_PageWrite;
+   if(nc->aes) {
+      intr |= NX_NAND_INT_AES_DEC;
+      page_cfg.includeAES = true;
+   }
+   else {
+      page_cfg.includeAES = false;
+   }
+
+   if(nc->hwecc) {
+      intr |= NX_NAND_INT_ENC;
+      page_cfg.includeECC = true;
+   }
+   else {
+      page_cfg.includeECC = false;
+      intr |= NX_NAND_INT_BLK_WRITE;
+   }
+   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+   /* Int Enable */
+   intr |= (NX_NAND_INT_OOB_WRITE | (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+   tmhwEfmc_IntClear(nc->unitid, intr);
+   tmhwEfmc_IntEnable(nc->unitid, intr);
+   
+   /* Send the address commands to chip */
+   nc->done = false;
+   nx_nand_cmd_addr(nc,1, NAND_CMD_SEQIN, 0);
+   
+   if(nc->lb_chip) {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize >= (1 << 28)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+   else {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+   
+   /* Post write command */
+   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+   
+   /* Wait for READY interrupt */   
+   wait_event(nc->nand_queue, (nc->done != false));
+
+   /* Disable interrupts */
+   tmhwEfmc_IntDisable(nc->unitid, intr);
+
+#endif
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   end1 = readl(TSU_COUNTER_REG);
+   nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
+#endif
+   
+   return;
+}
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_write_page - Write 1 page data into chip when HW ECC enabled
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Write a full page + oob into the buffer
+*/
+static void nx_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+              const uint8_t *buf)
+{
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   uint32_t start, end1;
+#endif
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   start = readl(TSU_COUNTER_REG);
+#endif
+   
+   nx_nand_write_page_raw(mtd, chip, buf);
+   
+#ifdef CONFIG_MTD_PERF_MEAS
+   end1 = readl(TSU_COUNTER_REG);
+   nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
+#endif
+   
+   return;
+}
+#endif
+
+static u_char temp_buf[NAND_MAX_PAGESIZE+NAND_MAX_OOBSIZE];
+#define  OOB_BYTES_PER_BLK  (16)
+
+/**
+* nx_nand_write_oob - Write OOB data
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @page: Page address
+*
+* Write OOB data into the chip
+*/
+static int nx_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+              int page)
+{
+
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   int status = 0;
+   int sndcmd = 1;
+  const uint8_t *buf = chip->oob_poi;
+  int length;
+   int column, addr, i;
+   uint16_t data;
+   tmhwEfmc_PageConfig_t   page_cfg;
+   bool  ecc_old, aes_old;
+   u_char *temp1;
+   uint8_t   *oob_poi_orig;
+   
+   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+      /* Use Device OOB layout -  write only OOB data */    
+      /* No page operation */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      page_cfg.includeAES = false;
+      page_cfg.includeECC = false;
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      /* Send SEQIN command */
+      chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+      /* Write to driver buffer */
+      length = mtd->oobsize;
+      chip->write_buf(mtd, buf, length);
+
+      /* Check if CE DON't care is supported */
+      column = nc->cur_col;
+      i = 0;
+      while(length) {
+         /* Send Address & cmd cycles */
+         if(sndcmd) {
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+   
+            if(nc->lb_chip) {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+               
+               /* if > 2Gb, extra address cycle */
+               if (nc->chip.chipsize >= (1 << 28)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+               
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+            }
+            else {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+         
+               /* if > 64Mb, extra adddress cycle */
+               if (nc->chip.chipsize > (32 << 20)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+               
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+            }
+            sndcmd = 0;
+         }
+
+         /* Write data into chip */
+         data = buf[i];
+         status  = tmhwEfmc_WriteSingleData(nc->unitid, data);    
+      
+         length--;
+         i++;
+      
+         if(!nx_nc->cedontcare) {
+            sndcmd = 1; 
+            column++;
+         }
+      }
+   
+      /* write  confirm command */
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
+      }
+      else {
+         /* Use IP_2017 OOB layout - write page */
+         /* Store ECC,AES values & Disbale */   
+         ecc_old = nc->hwecc;
+         aes_old = nc->aes;
+         oob_poi_orig = chip->oob_poi;
+         nc->hwecc = false;
+         nc->aes = false;
+      
+         /* Send SEQIN command */
+         chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
+         
+         /* Initialise temp_buf */
+         memset(temp_buf, 0xff, (mtd->writesize + mtd->oobsize));
+
+         /* copy OOB */ 
+         temp1 = temp_buf;
+         for(i=0; i < nc->num_blks; i++) {
+            temp1 += NX_NAND_BLK_SIZE;
+            memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), OOB_BYTES_PER_BLK);
+            temp1 += OOB_BYTES_PER_BLK;   
+         }
+         chip->oob_poi = &temp_buf[mtd->writesize];
+
+         /* Call write page raw */
+         nx_nand_write_page_raw(mtd, chip, temp_buf);
+
+         /* Restore ECC,AES values */  
+         chip->oob_poi = oob_poi_orig;
+         nc->hwecc = ecc_old;
+         nc->aes = aes_old;
+   }
+   
+   /* Send command to program the OOB data */
+  chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+  status = chip->waitfunc(mtd, chip);
+
+  return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/**
+* nx_nand_command - Command function for small page chips
+* @mtd: MTD information structure
+* @cmd: Command
+* @column: Column address
+* @page_addr: Page address
+*
+* Command control function:
+*/
+static void nx_nand_command(struct mtd_info *mtd, unsigned int cmd,
+              int column, int page_addr)
+{
+   tmhwEfmc_PageConfig_t   page_cfg;
+   uint16_t addr;
+   uint32_t intr=0;
+   int   status;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC 
+   int   chanid;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t           req;
+   nx_dmac_stgt_t       stgt[5];
+#endif
+
+   /* Store the command, colmn & page address */
+   nc->cur_cmd = cmd;
+   if(column == -1)
+      column = 0;
+   nc->cur_col = column;
+   if(page_addr == -1)
+      page_addr = 0;
+   nc->cur_page = page_addr;
+
+   /*
+    * Issue the correct first command, when we write to
+    * the device.
+    */
+   switch(cmd) {
+   case NAND_CMD_SEQIN:
+      nc->offset = 0;
+      /* Address cycles & command will be sent in write_page_raw */
+      break;
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC 
+   case NAND_CMD_PAGEPROG:
+      break;
+      
+   case NAND_CMD_RESET:
+   case NAND_CMD_STATUS:
+      nx_nand_cmd_addr(nc, 1, cmd, 1);
+      break;
+      
+#else 
+   case NAND_CMD_PAGEPROG:
+      /* Post write command feature used */
+      break;
+   
+   case NAND_CMD_RESET:
+   case NAND_CMD_STATUS:
+      nx_nand_cmd_addr(nc, 1, cmd, 1);
+      break;
+#endif
+
+   case NAND_CMD_ERASE1:
+      /* Enable READY interupt */
+      intr |= (1 << (NX_NAND_INT_READY_START + nc->slotid));
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, intr);
+      
+      /* Send address cycles & command */
+      nc->done = false;
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+      
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Disable READY interrupt */
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+
+      break;
+
+   case NAND_CMD_ERASE2:
+      /* Already done in CMD_ERASE1 */
+      break;
+
+   case NAND_CMD_READ0:
+      nc->offset = 0;
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC
+      /* Start the DMAC */
+      nx_nand_dmac_init(nc, 1, &req, stgt);
+ 
+      /* Configure Flow control */
+      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+      dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+      /* Enable the SEQ READ PAGE DONE interrupt */
+      intr |= NX_NAND_INT_SEQ_READ;
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, intr);
+
+      /* Page operation */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_PageRead;
+      if(nc->aes) {
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+      if(nc->hwecc) {
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+      }
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      chanid = nx_dmac_tfr(&req);
+      if(chanid < 0) {
+         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+         return;
+      }
+
+      /* Send address cycles & command */
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+      
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+      else {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+
+      /* Complete DMAC transfer */
+      status = nx_dmac_tfr_comp(chanid);
+      if(status) {
+         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+         return;
+      }
+   
+      /* Disable interrupts */   
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+      
+      /* Disable Flow control */
+      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+      dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+   
+#else
+      
+      nc->blk_index = 0;
+   
+      /* Init page operation */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_PageRead;
+      if(nc->aes) {
+         intr |= NX_NAND_INT_AES_DEC;
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+
+      if(nc->hwecc) {
+         intr |= NX_NAND_INT_DEC;
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+         intr |= NX_NAND_INT_BLK_READ;
+      }
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+      
+      intr |= NX_NAND_INT_OOB_READ;
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+      /* Send the address commands to chip */
+      nc->done = false;
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+      else {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Disable interrupts */
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+      
+#endif
+      break;
+
+   case NAND_CMD_READOOB:
+      /* Offset to OOB area in driver buffer */
+      nc->offset = mtd->writesize;
+      nc->blk_index = (nc->num_blks * NX_NAND_BLK_SIZE);
+   
+      /* Enable the OOB block request */
+      tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_OOB_READ);
+      tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+      /* Init page operation command */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_PageRead;
+      if(nc->aes) {
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+      if(nc->hwecc) {
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+      }
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      /* Send cmd & address cycles */
+      nc->done = false;
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READOOB, 0);
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+      else {
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 1);
+      }
+      
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Disable the OOB block request */
+      tmhwEfmc_IntDisable(nc->unitid, NX_NAND_INT_OOB_READ);
+      
+      break;
+
+   case NAND_CMD_READID:
+      
+      /* Init page operation command */
+      page_cfg.includeOOB = false;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      if(nc->aes) {
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+      
+      if(nc->hwecc) {
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+      }
+      
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+      
+      nx_nand_cmd_addr(nc, 1, cmd, 0);
+      nx_nand_cmd_addr(nc, 0, column, 1);
+      break;
+
+   default:
+      printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+   }
+}
+
+/**
+* nx_nand_command_lp - Command function for large page chips
+* @mtd: MTD information structure
+* @cmd: Command
+* @column: Column address
+* @page_addr: Page address
+*
+* Command control function:
+*/
+static void nx_nand_command_lp(struct mtd_info *mtd, unsigned int cmd,
+              int column, int page_addr)
+{
+   tmhwEfmc_PageConfig_t   page_cfg;
+   uint16_t addr;
+   uint32_t intr=0;
+   int   status;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC 
+   int   chanid;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t           req;
+   nx_dmac_stgt_t       stgt[5];
+#endif
+
+   /* Store the command, colmn & page address */
+   if(cmd == NAND_CMD_READOOB) {
+      cmd = NAND_CMD_READ0;
+
+      /* If Device OOB layout, read data in read_OOB function */ 
+      if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+         nc->cur_cmd = cmd;
+         nc->cur_col = mtd->writesize;
+         nc->cur_page = page_addr;
+         return;
+      }
+   }
+
+   /* Store cmd, addresses */
+   nc->cur_cmd = cmd;
+   if(column == -1)
+      column = 0;
+   nc->cur_col = column;
+   if(page_addr == -1)
+      page_addr = 0;
+   nc->cur_page =  (page_addr);
+
+   /*
+    * Issue the correct first command, when we write to
+    * the device.
+    */
+   switch(cmd) {
+   case NAND_CMD_SEQIN:
+      nc->offset = column;
+      /* Address cycles & command will be sent in write_page_raw */
+      break;
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC 
+   case NAND_CMD_PAGEPROG:
+      break;
+      
+   case NAND_CMD_RESET:
+   case NAND_CMD_STATUS:
+      nx_nand_cmd_addr(nc, 1, cmd, 1);
+      break;
+      
+#else 
+   case NAND_CMD_PAGEPROG:
+      /* Post write command feature used */
+      break;
+   
+   case NAND_CMD_RESET:
+   case NAND_CMD_STATUS:
+      nx_nand_cmd_addr(nc, 1, cmd, 1);
+      break;
+#endif
+
+   case NAND_CMD_ERASE1:
+      /* Enable READY interupt */
+      intr = 1 << (NX_NAND_INT_READY_START + nc->slotid);
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, intr);
+      
+      /* Send address cycles & command */
+      nc->done = false;
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+      
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Disable READY interrupt */
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+      break;
+
+   case NAND_CMD_ERASE2:
+      /* Already done in CMD_ERASE1 */
+      break;
+
+   case NAND_CMD_READ0:
+      nc->offset = column;
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC
+      /* Start the DMAC */
+      nx_nand_dmac_init(nc, 1, &req, stgt);
+ 
+      /* Configure Flow control */
+      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+      dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+      /* Enable the SEQ READ PAGE DONE interrupt */
+      intr = NX_NAND_INT_SEQ_READ;
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, intr);
+
+      /* Page operation */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_PageRead;
+      if(nc->aes) {
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+      if(nc->hwecc) {
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+      }
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      chanid = nx_dmac_tfr(&req);
+      if(chanid < 0) {
+         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+         return;
+      }
+
+      /* Send address cycles & command */
+      nc->done = false;
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+
+      addr = column & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+      
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Complete DMAC transfer */
+      status = nx_dmac_tfr_comp(chanid);
+      if(status) {
+         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+         return;
+      }
+   
+      /* Disable interrupts */   
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+      
+      /* Disable Flow control */
+      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+      dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+   
+#else
+   
+      nc->blk_index = 0;
+   
+      /* Init page operation */
+      page_cfg.includeOOB = true;
+      intr |= NX_NAND_INT_OOB_READ;
+      page_cfg.operType = tmhwEfmc_PageRead;
+      if(nc->aes) {
+         intr |= NX_NAND_INT_AES_DEC;
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+
+      if(nc->hwecc) {
+         intr |= NX_NAND_INT_DEC;
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+         intr |= NX_NAND_INT_BLK_READ;
+      }
+      tmhwEfmc_IntClear(nc->unitid, intr);
+      tmhwEfmc_IntEnable(nc->unitid, intr);
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      /* Send the address commands to chip */
+      nc->done = false;
+      /* Send address cycles & command */
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+      
+      /* Wait for the completion */ 
+      wait_event(nc->nand_queue, (nc->done != false));
+      
+      /* Disable interrupts */
+      tmhwEfmc_IntDisable(nc->unitid, intr);
+      
+#endif
+      break;
+      
+   case NAND_CMD_READID:
+      page_cfg.includeOOB = false;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      if(nc->aes) {
+         page_cfg.includeAES = true;
+      }
+      else {
+         page_cfg.includeAES = false;
+      }
+      
+      if(nc->hwecc) {
+         page_cfg.includeECC = true;
+      }
+      else {
+         page_cfg.includeECC = false;
+      }
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      nx_nand_cmd_addr(nc, 1, cmd, 0);
+      nx_nand_cmd_addr(nc, 0, column, 1);
+      break;
+
+   default:
+      printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+   }
+}
+
+/**
+ * nx_nand_block_bad - Read bad block marker from the chip
+ * @mtd: MTD device structure
+ * @ofs: offset from device start
+ * @getchip:   0, if the chip is already selected
+ *
+ * Check, if the block is bad.
+ */
+static int nx_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip ATTRIBUTE_UNUSED)
+{
+   struct mtd_oob_ops ops;
+   uint8_t  buf[NAND_MAX_OOBSIZE];
+  int ret;
+   u8 bad;
+   int res = 0;
+   struct nand_chip *chip = mtd->priv;
+
+   printk(KERN_INFO "Bad block check 0x%x \r\n", (int)ofs);
+   
+   mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
+   
+   /* Read OOB data */
+  ops.ooblen = mtd->oobsize;
+  ops.oobbuf = buf;
+  ops.ooboffs = 0;
+  ops.datbuf = NULL;
+  ops.mode = MTD_OOB_PLACE;
+  ret = mtd->read_oob(mtd, ofs, &ops);
+  if (ret) {
+      printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
+    return ret;
+   }
+   mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+   
+   /* Check the bad block marker */ 
+   bad = buf[chip->badblockpos];
+   if (bad != 0xff) {
+      res = 1;
+   }
+   
+   printk(KERN_INFO "Bad block res 0x%x \r\n", res);
+      
+   return res;
+}
+
+/*------------------------------------------------------------------------------------
+* Partitions scan functions 
+--------------------------------------------------------------------------------------*/
+/**
+* nx_nand_scan_partitions - Partition creation function
+* @mtd: MTD information structure
+*
+* Scan the part table
+*/
+static void nx_nand_scan_partitions(struct mtd_info *mtd)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   struct mtd_partition *parts = NULL;
+   int res;
+
+   res = parse_mtd_partitions(mtd, part_probes, &parts, 0);
+   if (res <= 0) {
+      if(nc->lb_chip) { 
+         parts = partition_info2;
+         res = ARRAY_SIZE(partition_info2);
+      }
+      else {
+         parts = partition_info1;
+         res = ARRAY_SIZE(partition_info1);
+      }
+   } else {
+      nc->partinfo = parts;
+   }
+
+   add_mtd_partitions(mtd, parts, res);
+}
+
+extern void mtd_blktrans_stop(void);
+extern int mtd_blktrans_restart(void);
+
+/**
+* nx_nand_repartition - Repatition function
+* @mtd: MTD information structure
+*
+* Repartition a device
+*/
+static int nx_nand_repartition(struct mtd_info *mtd)
+{
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+   /* Hack alert: sysfs is unfixable broken in this kernel !! */
+   //mtd_blktrans_stop();
+
+   /* Deregister partitions */
+   del_mtd_partitions(mtd);
+
+   /* Hack alert: sysfs is unfixable broken in this kernel !! */
+   //mtd_blktrans_restart();
+
+   /* Free the previous allocated partition array */
+   if (nc->partinfo) {
+      kfree(nc->partinfo);
+      nc->partinfo = NULL;
+   }
+
+   nx_nand_scan_partitions(mtd);
+   return 0;
+}
+
+/**
+* nx_nand_ctrl_isr - NAND controller ISR function 
+* @irq_no: IRQ number
+* @dev_id: Device ID
+*
+* Handles the NAND Controller interrupt events
+*/
+static irqreturn_t nx_nand_ctrl_isr(int irq_no ATTRIBUTE_UNUSED, void *dev_id)
+{
+#ifdef CONFIG_MTD_NX_NAND_DMAC   
+   int i;
+#endif
+   
+   uint32_t int_stat;
+   uint32_t int_ena;
+   struct nx_nand_ctrl  *nc=(struct nx_nand_ctrl *)dev_id;
+      
+   /* Read the interrupt status & chan ID */
+   tmhwEfmc_IntGetStatus(nc->unitid, (ptmhwEfmc_IntMask_t) &int_stat);
+   int_ena = readl(nx_nc->ctrl_base + NX_NAND_INT_ENA_OFFSET);
+
+#ifdef CONFIG_MTD_NX_NAND_DMAC   
+   /* Clear the interrupt */
+   tmhwEfmc_IntClear(nc->unitid, int_stat);
+   
+   if(nc->cur_cmd == NAND_CMD_READ0) {
+      if(nc->hwecc) {
+         for(i=0; i < nc->num_blks; i++)  {
+            nc->ecc_status[i] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                                                            NX_NAND_INT_DEC_0_ERR | 
+                                                            NX_NAND_INT_DEC_1_ERR |
+                                                            NX_NAND_INT_DEC_2_ERR |
+                                                            NX_NAND_INT_DEC_3_ERR |
+                                                            NX_NAND_INT_DEC_4_ERR |
+                                                            NX_NAND_INT_DEC_5_ERR));
+         }
+      }
+      
+      if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ)) {
+         nc->done = true; 
+         wake_up(&nc->nand_queue); 
+      }
+   }
+   
+   if(nc->cur_cmd == NAND_CMD_SEQIN) {
+      if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+         tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_SEQ_WRITE);
+      }
+      
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+   
+   /* Erase command */
+   if(nc->cur_cmd == NAND_CMD_ERASE1) {
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+   
+#else
+   
+   /* Write command */
+   if((nc->cur_cmd == NAND_CMD_SEQIN) || (nc->cur_cmd == NAND_CMD_PAGEPROG)) {
+      if((int_stat & NX_NAND_INT_OOB_WRITE) && (int_ena & NX_NAND_INT_OOB_WRITE)) {
+         tmhwEfmc_WriteOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+
+      if(nc->hwecc) {
+         if((int_stat & NX_NAND_INT_ENC) && (int_ena & NX_NAND_INT_ENC)) {
+            tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index*NX_NAND_BLK_SIZE));
+            nc->blk_index++;
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+         }
+      }
+      else {
+         if((int_stat & NX_NAND_INT_BLK_WRITE) && (int_ena & NX_NAND_INT_BLK_WRITE)){
+            tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf + (nc->blk_index*NX_NAND_BLK_SIZE));
+            nc->blk_index++;
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+         }
+      }
+      
+      if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+      
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+   
+   /* Read command */
+   if((nc->cur_cmd == NAND_CMD_READ0) || (nc->cur_cmd == NAND_CMD_READOOB)) {
+      if((int_stat & NX_NAND_INT_OOB_READ) && (int_ena & NX_NAND_INT_OOB_READ)) {
+         tmhwEfmc_ReadOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+      
+      if(nc->hwecc) {
+         if((int_stat & NX_NAND_INT_DEC) && (int_ena & NX_NAND_INT_DEC)) {
+            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
+            nc->ecc_status[nc->blk_index] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                                                            NX_NAND_INT_DEC_0_ERR | 
+                                                            NX_NAND_INT_DEC_1_ERR |
+                                                            NX_NAND_INT_DEC_2_ERR |
+                                                            NX_NAND_INT_DEC_3_ERR |
+                                                            NX_NAND_INT_DEC_4_ERR |
+                                                            NX_NAND_INT_DEC_5_ERR));
+            nc->blk_index++;
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+         }
+      }
+      else {
+         if((int_stat & NX_NAND_INT_BLK_READ) && (int_ena & NX_NAND_INT_BLK_READ)) {
+            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
+            nc->blk_index++;
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+         }
+      }
+      
+      if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ) ){
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+   }
+   
+   /* Erase command */
+   if(nc->cur_cmd == NAND_CMD_ERASE1) {
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+#endif   
+   return IRQ_HANDLED;
+}
+
+/**
+* nx_nand_probe - Module probe function
+* @pdev: Device structure
+*
+* Probes the device & do the initialisation
+*/
+static int nx_nand_probe(struct platform_device *pdev)
+{
+   struct resource *res1, *res2;
+   struct nand_chip *chip;
+   struct mtd_info *mtd;
+   tmhwEfmc_Capabilities_t pcaps;
+   tmhwEfmc_FlashConfig_t  pconfig;
+   int ret=0;  
+
+   /* Allocate memory for nand control structure */
+   nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
+   if (!nx_nc) {
+      printk(KERN_ERR "nx_nand: NAND ctrl mem alloc \r\n");
+      return -ENOMEM;
+   }
+
+   /* Unit ID */
+   nx_nc->unitid = 0;
+
+   /* Get I/O resource */
+   res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   if (!res1) {
+      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+      ret = -ENXIO;
+      goto out_free1;
+   }
+   
+   /* Ioremap controller base */
+   nx_nc->ctrl_base = devm_ioremap(&pdev->dev, res1->start, (res1->end-res1->start+1));
+   if (!nx_nc->ctrl_base) {
+      printk(KERN_ERR "nx_nand: NAND base devm_iormep \r\n");  
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   /* Get interrupt resource */
+   res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+   if (!res2) {
+      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+      ret = -ENXIO;
+      goto out_free1;
+   }
+   
+   /* Alloc IRQ */
+   ret = devm_request_irq (&pdev->dev, res2->start, 
+         nx_nand_ctrl_isr, IRQF_DISABLED, "nx_2070", nx_nc);
+   if (ret < 0){
+      printk(KERN_ERR "nx_nand: NAND irq alloc \r\n");   
+      goto out_free1;
+   }
+   
+#ifndef CONFIG_MTD_NX_NAND_DMAC
+   /* Ioremap AHB buffer for interrupt flow control */
+   nx_nc->ahb_buf = devm_ioremap(&pdev->dev, NX_NAND_AHB_BUF, NX_NAND_AHB_BUF_MAX_SIZE);
+   if (!nx_nc->ahb_buf) {
+      goto out_free1;
+   }
+#endif
+   
+   /* Store in dev structure */
+   dev_set_drvdata(&pdev->dev, nx_nc);
+   
+   /* Store in HwAPI config */
+   gktmhwEfmc_Config[nx_nc->unitid].baseAddress = (uint32_t) nx_nc->ctrl_base;
+   gktmhwEfmc_Config[nx_nc->unitid].ahbMemAddress = (uint8_t *)nx_nc->ahb_buf;
+
+   /* Init wait queue */
+   init_waitqueue_head(&nx_nc->nand_queue);
+   
+   /* Read the control configuration & store */
+   ret = tmhwEfmc_GetCapabilities(nx_nc->unitid, &pcaps);
+   nx_nc->aes = pcaps.supportAES;
+   nx_nc->slots = pcaps.maxDevices;
+   nx_nc->slotid = 0;
+   
+   /* Flash configuration */
+   ret = tmhwEfmc_GetFlashConfig(nx_nc->unitid, nx_nc->slotid, &pconfig);
+      
+   /* Initialise the lbchip flag to false */
+   nx_nc->cedontcare = pconfig.enableCENDontCare; /* CE don;t care support */
+   nx_nc->lb_chip = 0;
+   mtd = &nx_nc->mtd;
+   mtd->owner = THIS_MODULE;
+   /* mtd->name = "nx_2017"; This has to come from the platform driver*/
+   mtd->name = pdev->name;
+   chip = &nx_nc->chip;
+   mtd->priv = chip;
+
+   /* Initialize hardware controller structure */
+   spin_lock_init(&nx_nc->nandctrl.lock);
+   init_waitqueue_head(&nx_nc->nandctrl.wq);
+   chip->controller = &nx_nc->nandctrl;
+
+   /* Store reference to the nx_nand structure */
+   chip->priv = nx_nc;
+   
+   /* Chip Information */
+   chip->chip_delay = 0;
+   chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
+      NAND_NO_SUBPAGE_WRITE;
+   chip->select_chip = nx_nand_select_chip;
+   chip->dev_ready = nx_nand_dev_ready;
+   if (pconfig.dataWidth) {
+      chip->options |= NAND_BUSWIDTH_16;
+      chip->read_byte = nx_nand_read_byte16;
+   } else {
+      chip->read_byte = nx_nand_read_byte;
+   }
+
+   chip->cmdfunc = nx_nand_command;
+   chip->ecc.read_page_raw = nx_nand_read_page_raw;
+   chip->ecc.write_page_raw = nx_nand_write_page_raw;
+   chip->ecc.read_oob = nx_nand_read_oob;
+   chip->ecc.write_oob = nx_nand_write_oob;
+   chip->read_buf = nx_nand_read_buf;
+   chip->write_buf = nx_nand_write_buf;
+   chip->block_bad = nx_nand_block_bad;
+   
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+   nx_nc->hwecc = true;
+   chip->ecc.read_page = nx_nand_read_page;
+   chip->ecc.write_page = nx_nand_write_page;
+   chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+   chip->ecc.calculate = nx_nand_calculate_ecc;
+   chip->ecc.correct = nx_nand_correct_data;
+   chip->ecc.hwctl = nx_nand_hwctl;
+   chip->ecc.size = 512;
+   chip->ecc.bytes = 12;
+   chip->bbt_td = &nx_bbt_main;  
+   chip->bbt_md = &nx_bbt_mirror;
+#endif
+
+#ifdef CONFIG_MTD_NX_NAND_SWECC
+   nx_nc->hwecc = false;
+   chip->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_MTD_NX_NAND_NONEECC
+   chip->ecc.read_page = nx_nand_read_page_raw;
+   chip->ecc.write_page = nx_nand_write_page_raw;
+   nx_nc->hwecc = false;
+   chip->ecc.mode = NAND_ECC_NONE;
+#endif
+   
+   /* Call chip identify function */
+   if(nand_scan_ident(mtd, 1)) {
+      printk(KERN_ERR "nx_nand: NAND scan ident \r\n");  
+      ret = -ENXIO;
+      goto out_free1;
+   }
+   
+   /* Calculate number of 512byte blocks in a page */
+   nx_nc->num_blks = mtd->writesize >> 9;
+   
+   /* Allocate ECC status array */
+   nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
+   if(!nx_nc->ecc_status) {
+      printk(KERN_ERR "nx_nand: ECC status alloc \r\n");
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   /* Allocate internal driver buffer */
+   nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
+         mtd->writesize + mtd->oobsize, 
+         &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
+   if(!nx_nc->dmabuf) {
+      printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   if(chip->options & NAND_SAMSUNG_LP_OPTIONS) {
+      chip->cmdfunc = nx_nand_command_lp;
+      nx_nc->lb_chip = 1;
+   }
+
+   chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | NAND_USE_FLASH_BBT;
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+   switch (mtd->oobsize) {
+      case 16:
+         chip->ecc.layout = &nx_nand_oob_16;
+         break;
+      case 64:
+         chip->ecc.layout = &nx_nand_oob_64;
+         break;
+      default:
+         printk(KERN_WARNING "No oob scheme defined for "
+                "oobsize %d\n", mtd->oobsize);
+         BUG();
+   }
+#endif   
+   
+   if(nand_scan_tail(mtd)) {
+      printk(KERN_ERR "nx_nand: NAND scan tail \r\n");   
+      ret = -ENXIO;
+      goto out_free1;
+   }
+   
+   mtd->repartition = nx_nand_repartition;
+
+#ifdef CONFIG_MTD_PERF_MEAS
+   mtd->perf_meas = mtd_perf_meas;
+#endif
+   
+   /* Add the master device, to allow full updates */
+   add_mtd_device(mtd);
+
+   /* Scan for the partitions */
+   nx_nand_scan_partitions(mtd);
+
+   return 0;
+
+out_free1:  
+   kfree(nx_nc);
+
+   return ret;
+}
+
+/**
+* nx_nand_remove - Module remove function
+* @pdev: Device structure
+*
+* Removes the device & do the deinitialisation
+*/
+static int nx_nand_remove(struct platform_device *pdev)
+{
+   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+
+   /* Release resources */
+   nand_release(&nc->mtd);
+
+   /* Free DMA buf */
+   kfree(nc);
+   
+   return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int nx_nand_suspend(struct platform_device *pdev, pm_message_t state)
+{
+   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+   int ret = 0;
+   unsigned long val;
+
+   if (nc)
+   { 
+      if(nc->mtd.suspend)
+         ret = nc->mtd.suspend(&nc->mtd);
+
+      /* Put the controller (IP2017) into power down mode */
+      if(!ret)
+      {
+         val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+
+         val &= ~NX_NAND_POWER_DOWN_MASK;
+         val |= (NX_NAND_POWER_DOWN_ENABLE & NX_NAND_POWER_DOWN_MASK);
+
+         writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+      }
+   }
+
+   return ret;
+}
+
+static int nx_nand_resume(struct platform_device *pdev)
+{
+   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+   unsigned long val;
+
+   if (nc)
+   {
+      /* Bring the controller out of power down mode */
+      val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+
+      val &= ~NX_NAND_POWER_DOWN_MASK;
+      val |= (NX_NAND_POWER_DOWN_DISABLE & NX_NAND_POWER_DOWN_MASK);
+
+      writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+
+      if (nc->mtd.resume)
+         nc->mtd.resume(&nc->mtd);
+   }
+
+   return 0;
+}
+#else
+
+#define nx_nand_suspend NULL
+#define nx_nand_resume  NULL
+
+#endif
+
+/**
+* NAND device registration
+*/
+static struct platform_driver nx_nand_driver = {
+   .probe      = nx_nand_probe,
+   .remove     = nx_nand_remove,
+   .suspend    = nx_nand_suspend,
+   .resume     = nx_nand_resume,
+   .driver     = {
+      .name = "nx_2017",
+      .owner   = THIS_MODULE,
+   },
+};
+
+/**
+* nx_nand_init - Module initialisation function
+*
+* Register the NAND driver
+*/
+static int __init nx_nand_init(void)
+{
+   return platform_driver_register(&nx_nand_driver);
+}
+module_init(nx_nand_init);
+
+#ifdef MODULE
+/**
+* nx_nand_exit - Module exit function
+*
+* Unregister the NAND driver
+*/
+static void __exit nx_nand_exit(void)
+{
+   platform_driver_unregister(&nx_nand_driver);
+}
+module_exit(nx_nand_exit);
+#endif
+
+EXPORT_SYMBOL(nx_nc);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NXP B.V.");
+MODULE_DESCRIPTION("NAND Flash driver for IP_2070 NAND controller");
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_nand.h linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.h
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_nand.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,135 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 0.0.1		Bangaragiri G			20080318		Draft-Initial version
+ * 0.1.0		Bangaragiri G			20080804		Proposal-After self review
+ * 0.2.0		Bangaragiri G			20080925		Proposal-After including review comments
+ * 1.0.0		Bangaragiri G			20090305		Accepted-After testing on TV550M0 board
+ */
+
+#ifndef _NX_NAND_H
+#define _NX_NAND_H
+
+#ifdef __KERNEL__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+
+#if defined(CONFIG_MTD_NX_NAND_DMAC) && defined(CONFIG_ARCH_APOLLO)
+	#define NX_NAND_AHB_BUF     (0x40000000) /* DMAC Flow conttrol */
+#elif defined(CONFIG_MTD_NX_NAND_DMAC) && !defined(CONFIG_ARCH_APOLLO)
+	#define NX_NAND_AHB_BUF 	(0x00000000) /* DMAC Flow conttrol */
+#else
+	#define NX_NAND_AHB_BUF 	(NX_NAND_AHB_INTFC_BUF) /* Interrupt Flow control */
+#endif
+
+/**
+* NAND control structure
+*/
+struct nx_nand_ctrl {
+  struct mtd_info       mtd;    	    /* MTD information structure */
+  struct nand_chip      chip;     	  /* NAND chip structure */
+	struct nand_hw_control	nandctrl;		/* NAND control lock */
+  uint8_t               *dmabuf;    	/* DMA buffer */
+	dma_addr_t            dmabuf_phy;   /* DMA buffer PHY address */
+  int                   slots;      	/* # of chips */
+  int                   slotid;     	/* current chip number */
+  uint32_t              slotbase;   	/* Chip start address */
+  int                   unitid;       /* Current unit ID of controller */
+  int                   cur_col;    	/* Current column address */
+  int                   cur_page;   	/* Current page address */
+  int                   cur_cmd;   	/* Current page address */
+  int                   lb_chip;   	  /* Large Block chip flag */
+  void __iomem          *ctrl_base; 	/* Controller base address */
+  void __iomem          *ahb_buf;   	/* Controller base address */
+  struct mtd_partition  *partinfo;  	/* partition info structure */
+  bool                  aes;        	/* AES decryption support */
+  bool		              hwecc;     	/* Use HW ECC */
+  uint32_t              aes_key[4]; 	/* AES 128 bit key */
+	uint32_t              aes_val[4]; 	/* AES initial 128 bit value */
+  int		                num_blks;   	/* # of 512 bytes blocks per page */ 
+  int		                blk_index;  	/* Block index */
+  int                   *ecc_status;	/* ECC status array */
+  bool                  done;       	/* Read, write, erase done flag */  
+	wait_queue_head_t   	nand_queue;		/* NAND queue */
+  int                   offset;				/* Offset in inetrnal driver buffer */
+	bool									cedontcare;		/* CE dont care support */
+};
+
+/* Max Data buffer size */
+#define NX_NAND_BLK_SIZE          (512)
+
+/* Max OOB buffer size */
+#define NX_NAND_MAX_OOB_SIZE      (128)
+
+/* Maximum AHB buffer size */
+#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
+
+/* NAND CONTROLLER register definitions */
+#define NX_NAND_INT_ENA_OFFSET    (0xFE4)
+
+#define NX_NAND_INT_READY_START   (20)
+
+/* Interrupt status bits */
+#define NX_NAND_INT_OOB_READ      (1<<0)
+#define NX_NAND_INT_OOB_WRITE     (1<<1)
+#define NX_NAND_INT_BLK_READ      (1<<2)
+#define NX_NAND_INT_BLK_WRITE     (1<<3)
+#define NX_NAND_INT_ENC           (1<<4)
+#define NX_NAND_INT_DEC           (1<<5)
+#define NX_NAND_INT_DEC_0_ERR     (1<<6)
+#define NX_NAND_INT_DEC_1_ERR     (1<<7)
+#define NX_NAND_INT_DEC_2_ERR     (1<<8)
+#define NX_NAND_INT_DEC_3_ERR     (1<<9)
+#define NX_NAND_INT_DEC_4_ERR     (1<<10)
+#define NX_NAND_INT_DEC_5_ERR     (1<<11)
+#define NX_NAND_INT_DEC_UNCOR     (1<<12)
+#define NX_NAND_INT_AES_DEC       (1<<13)
+#define NX_NAND_INT_SEQ_READ      (1<<14)
+#define NX_NAND_INT_SEQ_WRITE     (1<<15)
+#define NX_NAND_INT_BUSY1         (1<<16)
+#define NX_NAND_INT_BUSY2         (1<<17)
+#define NX_NAND_INT_BUSY3         (1<<18)
+#define NX_NAND_INT_BUSY4         (1<<19)
+#define NX_NAND_INT_READY1        (1<<20)
+#define NX_NAND_INT_READY2        (1<<21)
+#define NX_NAND_INT_READY3        (1<<22)
+#define NX_NAND_INT_READY4        (1<<23)
+
+/* Position of address */
+#define NX_NAND_SP_ADDR_MASK      (0xFF)
+#define NX_NAND_SP_ADDR_MASK1     (0x03)
+
+#define NX_NAND_SP_ADDR1_POS      (0)
+#define NX_NAND_SP_ADDR2_POS      (9)
+#define NX_NAND_SP_ADDR3_POS      (17)
+#define NX_NAND_SP_ADDR4_POS      (29)
+
+/* Cmd FIFO bit information */
+#define NX_NAND_CMD_FIFO_CE_START  (19)
+#define NX_NAND_CMD_FIFO_ADDR_CYC  (0x0)
+#define NX_NAND_CMD_FIFO_CMD_CYC   (0x1)
+#define NX_NAND_CMD_FIFO_POST_CMD  (0x2)
+
+#endif /* __KERNEL__ */
+#endif /* _NX_NAND_H */
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_part.c linux-2.6.34/drivers/mtd/nand/nx_nand/nx_part.c
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/nx_part.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_part.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,263 @@
+/*
+ * MTD style partition parser for BFFS tags
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/proc_fs.h>
+
+#define BFFS_NAME_LEN						(32)
+#define UBTM_START							(0x00000000)
+#define	OFFSET_TDF_KEY					(0x0200)
+#define	OFFSET_PARTITION_TABLE	(0x0400)
+#define PUBLIC_KEY_LEN          (512)
+#define	PART_INFO_NUM_PAGES			(2)
+#define	BL_NUM_BLKS				(3)
+
+static uint8_t  tdf_key[PUBLIC_KEY_LEN];
+
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+
+/*
+ * Make TDF public key available using the /proc filesystem
+ */
+static int read_tdf_key(char *buf, char **start, off_t fpos, int length, int *eof, void *data)
+{
+    printk("proc length = %d\n", length);
+
+    memcpy(buf, tdf_key, PUBLIC_KEY_LEN);
+    
+    *eof = 1;
+    
+    return PUBLIC_KEY_LEN;
+}
+
+/*
+ * Read ProcFS function
+ */
+void *nx_nand_read_key(void)
+{
+    return (void *)tdf_key;
+}
+EXPORT_SYMBOL(nx_nand_read_key);
+
+/*
+ * Parse BFFS paritition tables
+ */
+static int nx_part_parse(struct mtd_info *master,
+				 struct mtd_partition **pparts,
+				 unsigned long data ATTRIBUTE_UNUSED)
+{
+	struct mtd_partition *parts;
+	struct mtd_oob_ops ops;
+	int ret, blk_num = 0, blk_cnt=0, numparts = 0, realparts = 0;
+	loff_t blk_offset;
+	uint8_t *buf, *p8, i;
+	char *names;
+	struct proc_dir_entry *proc_sign;
+	uint32_t ubtm_size, pages_per_blk;
+
+	/* Part info is in 2 pages */	
+	pages_per_blk = master->erasesize / master->writesize;
+	ubtm_size = (PART_INFO_NUM_PAGES * master->writesize);	
+	buf = vmalloc(ubtm_size);
+	if (!buf) {
+		printk(KERN_ERR "nx_part: mem alloc failure \r\n");
+		return -ENOMEM;
+	}	
+
+	/* Find last block of bootloader */
+	while(blk_num < BL_NUM_BLKS) {
+		blk_offset = UBTM_START + (blk_cnt * master->erasesize);		
+		ret = master->block_isbad(master, blk_offset);
+		if(!ret) {
+			blk_num++;
+		}
+		blk_cnt++;
+	}
+
+	/* Read from last 2 pages of last block */	
+	blk_offset += ((pages_per_blk - PART_INFO_NUM_PAGES) * master->writesize);
+
+	/* Read data */
+	ops.mode = MTD_OOB_RAW;
+	ops.datbuf = buf;
+	ops.oobbuf = NULL;
+	ops.len = ubtm_size;
+	ret = master->read_oob(master, blk_offset, &ops);
+	if (ret) {
+		printk(KERN_ERR "nx_part: Read data failed 0x%x \r\n", ret);
+		goto out;
+	}
+
+	if (ops.retlen != ubtm_size) {
+		printk(KERN_ERR "nx_part: Return len wrong! 0x%x \r\n", ops.retlen);
+		ret = -EIO;
+		goto out;
+	}
+
+	ret = -EINVAL;
+
+	/* Get a reference to the partition content */
+	p8 = buf + OFFSET_PARTITION_TABLE;
+
+	/* First count the number of partitions to create */
+	for (i = 0; i < 20; i++) {
+		uint32_t x;
+
+		/* offset info */
+		x  = *p8 * 16777216; p8++;
+		x += *p8 * 65536;    p8++;
+		x += *p8 * 256;      p8++;
+		x += *p8;            p8++;
+
+		/* Check if end of parts info */
+		if (x == 0xFFFFFFFF)
+		{
+			break;
+		}
+
+		/* Check if offset is valid */
+		if(x >= master->size) {
+			printk(KERN_WARNING "nx_part:offset corrupted! 0x%x \r\n", x);
+			break;
+		}
+		
+		/* Size  info */
+		x  = *p8 * 16777216; p8++;
+		x += *p8 * 65536;    p8++;
+		x += *p8 * 256;      p8++;
+		x += *p8;            p8++;
+		
+		/* Check if size is valid */
+		if(x >= master->size) {
+			printk(KERN_WARNING "nx_part:size corrupted! 0x%x \r\n", x);
+			break;
+		}
+
+		numparts++;
+
+		//p8 += 4;
+		p8 += 4;
+		p8++;
+		p8 += 4;
+
+		printk("Found: %s\n", (char *)p8);
+
+		p8 += 12;
+	}
+
+	realparts = numparts;
+	printk("Found %d partitions\n", numparts);
+
+	/*
+	* Since the TVBL binary is read copy the TDF signature as well 
+	*/
+	memcpy(tdf_key, buf + OFFSET_TDF_KEY, PUBLIC_KEY_LEN);
+
+	/* 
+	* Allow the signature to be read from the outside through the /proc fs
+	*/
+	proc_sign = create_proc_read_entry("public_key", 0, NULL, read_tdf_key, NULL);
+
+	/* Add one additionally for the uBTM partition */
+	//realparts++;
+	parts = kzalloc((BFFS_NAME_LEN + sizeof(*parts)) * realparts,
+		GFP_KERNEL);
+	if (!parts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	names = (char *) &parts[realparts];
+
+	/* Create mtd1 (ubtm device) */
+	//parts[0].size = blk_cnt * master->erasesize;
+	//parts[0].offset = UBTM_START;
+	//parts[0].name = names;
+	//strcpy(names, "u-boot");
+	//names += BFFS_NAME_LEN;
+
+	numparts = 0;
+
+	/* Lets start from the beginning again and walk the walk */
+	p8 = buf + OFFSET_PARTITION_TABLE;
+
+	/* Walk the table and fill in the mtd parts */
+	while (numparts < realparts) {
+		uint32_t x;
+
+		/* Offset */
+		x  = *p8 * 16777216; p8++;
+  	x += *p8 * 65536;    p8++;
+  	x += *p8 * 256;      p8++;
+  	x += *p8;            p8++;
+		parts[numparts].offset = x;
+
+		/* Size */
+		x  = *p8 * 16777216; p8++;
+		x += *p8 * 65536;    p8++;
+		x += *p8 * 256;      p8++;
+		x += *p8;            p8++;
+		parts[numparts].size = x;
+
+		/* Skip info from partition table not needed by the kernel */
+  	p8 += 4;
+
+		/* R/W flag */
+		if (*p8 == 0)
+			parts[numparts].mask_flags = MTD_WRITEABLE;
+
+		/* Name */
+		p8++;
+		p8 += 4;
+		parts[numparts].name = names;
+		strncpy(names, p8, 12 - 1);
+
+		/* Next part info start */
+		p8 += 12;
+
+		names += BFFS_NAME_LEN - 1;
+		*names++ = 0x0;
+
+		numparts++;
+	}
+
+	ret = realparts;
+	*pparts = parts;
+
+out:
+	vfree(buf);
+	return ret;
+}
+
+/**
+* Partition parser for BFFS
+*/
+static struct mtd_part_parser nx_parser = {
+	.owner = THIS_MODULE,
+	.parse_fn = nx_part_parse,
+	.name = "nxpart",
+};
+
+static int __init nx_parse_init(void)
+{
+	return register_mtd_parser(&nx_parser);
+}
+
+static void __exit nx_parse_exit(void)
+{
+	deregister_mtd_parser(&nx_parser);
+}
+
+module_init(nx_parse_init);
+module_exit(nx_parse_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Thomas Gleixner");
+MODULE_DESCRIPTION("Parsing code for BFFS tables");
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.c linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.c
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,71 @@
+/*
+ * Copyright(C) 2007
+ * NXP B.V.
+ * All rights reserved
+ *
+ * This  source code and any compilation or derivative thereof is the
+ * proprietary information of NXP B.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be exposed to or placed
+ * under an Open Source License of any type without the expressed
+ * written permission of NXP B.V.
+ */
+/*----------------------------------------------------------------------------*/
+/*!
+ * \FILENAME:      tmhwEfmc_Cfg.c
+ *
+ * \DESCRIPTION:   Configuration source file for HwAPI driver of IP_2017 that is
+ *                 part of IP_2070
+ *
+ * \DOCUMENT REF:  IP_2017 of IP_2070 data sheet
+ *
+ * \REVISION HISTORY:
+ * \Version    Author                               Date                 Remarks
+ * \1.0      Mahadev Cholachagudda     2006-06-08           Draft
+ * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
+ */
+
+/*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+* Standard include files:
+*----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Project specific include files:
+*-----------------------------------------------------------------------------*/
+#include "tmNxTypes.h"
+
+/*-----------------------------------------------------------------------------
+* Component specific include files:
+*-----------------------------------------------------------------------------*/
+#include "tmhwEfmc_Cfg.h"
+
+/*-----------------------------------------------------------------------------
+* Typedefs and Macros
+*-----------------------------------------------------------------------------*/
+
+/*
+ * Types and defines:
+ */
+/* Base addresses of the peripheral */
+#ifndef TMHW_EFMC_PHY_MMIO_ADDRESS0
+#define TMHW_EFMC_PHY_MMIO_ADDRESS0      (0x8001A000)
+#define TMHW_EFMC_AHB_MEM_ADDRESS0 (0xC0000000)
+#endif
+
+/*-----------------------------------------------------------------------------
+* Global data
+*-----------------------------------------------------------------------------*/
+//const tmhwEfmc_Cfg_t gktmhwEfmc_Config [NUMBER_OF_MODULES] =
+tmhwEfmc_Cfg_t gktmhwEfmc_Config [NUMBER_OF_MODULES] =
+{
+    { TMHW_EFMC_PHY_MMIO_ADDRESS0, (pUInt8) TMHW_EFMC_AHB_MEM_ADDRESS0}
+};
+
+/*-----------------------------------------------------------------------------
+* Exported functions
+*-----------------------------------------------------------------------------*/
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.h
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/cfg/tmhwEfmc_Cfg.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,117 @@
+/*
+ * Copyright(C) 2007
+ * NXP B.V.
+ * All rights reserved
+ *
+ * This  source code and any compilation or derivative thereof is the
+ * proprietary information of NXP B.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be exposed to or placed
+ * under an Open Source License of any type without the expressed
+ * written permission of NXP B.V.
+ */
+/*----------------------------------------------------------------------------*/
+/*!
+ * \FILENAME:      tmhwEfmc_Cfg.h
+ *
+ * \DESCRIPTION:   Configuration header file for HwAPI driver of EFMC IP_2070
+ *
+ * \DOCUMENT REF:  EFMC IP_2070 data sheet
+ *
+ * \REVISION HISTORY:
+ * \Version    Author                               Date                 Remarks
+ * \1.0      Mahadev Cholachagudda     2006-06-08           Draft
+ * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc
+ */
+/*----------------------------------------------------------------------------*/
+
+#ifndef  TMHWEFMC_CFG_H
+#define  TMHWEFMC_CFG_H
+
+/*----------------------------------------------------------------------------
+* Standard include files:
+*----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Project specific include files:
+*-----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Component specific include files:
+*-----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*-----------------------------------------------------------------------------
+* Typedefs and Macros
+*-----------------------------------------------------------------------------*/
+
+/* Scalability Settings Start */
+
+/*!
+ * \def TMFL_SD_ALL
+ * Select all the APIs for final image. If this flag is disabled then scalability settings as
+ * defined below are used by preprocessor.
+ * \n NOTE: The flags need to be modified by the user as per system requirements. Also, care
+ * should be taken in case multiple units of this IP are available in Hw sybsystem.
+ * In case of multiple units with different features User will need to enable superset of
+ * features of individual unit. In such case it is Applications responsibility to keep track of which
+ * features are supported by which IP.
+ */
+
+#define NUMBER_OF_MODULES (1)
+
+#define TMFL_SD_ALL  (0)
+
+//#if (TMFL_SD_ALL == 0)
+
+#define TMFL_EFMCSD_POWER              1
+/*!< Select APIs to handle Power management functions. */
+#define TMFL_EFMCSD_EBI                0
+/*!< Select APIs to handle EBI (Pin sharing) functionality of EFMC */
+#define TMFL_EFMCSD_AHB                0
+/*!< Select APIs to handle AHB related functions of EFMC */
+#define TMFL_EFMCSD_APB                0
+/*!< Select APIs to handle APB related functions of EFMC */
+#define TMFL_EFMCSD_AES               1
+/*!< Select APIs to handle the AES functions of EFMC */
+#define TMFL_EFMCSD_DMA               1
+/*!< Select APIs to handle the DMA functions of EFMC */
+#define TMFL_EFMCSD_INT               1
+/*!< Select APIs to handle the Interrupt functions of EFMC */
+#define TMFL_EFMCSD_OTHERS             1
+/*!< Select APIs to handle other functions. */
+
+//#endif
+/* Scalability Settings End */
+
+/*-----------------------------------------------------------------------------
+* Global data
+*-----------------------------------------------------------------------------*/
+
+typedef struct tmhwEfmc_Cfg
+/*! \brief This structure is the HwAPI configuration structure. */
+ {
+   UInt32  baseAddress; /*!< Physical base address of EFMC IP.*/ 
+   pUInt8  ahbMemAddress; /*!< AHB memory address for EFMC IP.*/ 
+ } tmhwEfmc_Cfg_t, *ptmhwEfmc_Cfg_t ;
+
+//extern const tmhwEfmc_Cfg_t              gktmhwEfmc_Config[NUMBER_OF_MODULES];
+extern tmhwEfmc_Cfg_t              gktmhwEfmc_Config[NUMBER_OF_MODULES];
+/*!< Config Structure definitions  */
+#define TMHW_EFMC_GET_BASE(x)           (gktmhwEfmc_Config[x].baseAddress)
+#define TMHW_EFMC_GET_AHB_ADDRESS(x)           (gktmhwEfmc_Config[x].ahbMemAddress)
+/*!< Get Base definitions  */
+
+/*-----------------------------------------------------------------------------
+* Exported functions
+*-----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMHWEFMC_CFG_H */
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1115 @@
+/*
+ * Copyright(C) 2007
+ * NXP B.V.
+ * All rights reserved
+ *
+ * This  source code and any compilation or derivative thereof is the
+ * proprietary information of NXP B.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be exposed to or placed
+ * under an Open Source License of any type without the expressed
+ * written permission of NXP B.V.
+ */
+/*----------------------------------------------------------------------------*/
+/*!
+ * \FILENAME:     tmhwEfmc.h
+ *
+ * \DESCRIPTION:Generic interface for the EFMC IP 2070 HwAPI Layer Device Driver
+ *              are provided. HwAPI supports multiple instances of the IP by
+ *              means of unit ID. Applicatoin can program multiple units by
+ *              passsing corresponding unit number.HwAPI is trusted interface
+ *              hence input parameter checking is very limited.
+ *              Key Features are
+ *               .Independent configuration for up to 4 devices
+ *               .Programmable timing periods for various parameters
+ *               .Programmable hardware page read/write
+ *               .AHB/APB data register access
+ *
+ *
+ * \DOCUMENT REF:
+ *
+ * \REVISION HISTORY:
+ * \Version    Author                               Date                 Remarks
+ * \1.0      Mahadev Cholachagudda     2006-06-06           Draft
+ * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
+ *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ */
+
+#ifndef TMHWEFMC_H
+#define TMHWEFMC_H
+
+/*-----------------------------------------------------------------------------
+ * Project include files:
+ *----------------------------------------------------------------------------*/
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+#include "tmhwEfmc_Cfg.h"
+
+/*-----------------------------------------------------------------------------
+* Component specific include files:
+*-----------------------------------------------------------------------------*/
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+
+/*-----------------------------------------------------------------------------
+* Typedefs and Macros
+*-----------------------------------------------------------------------------*/
+
+/* Typedefs */
+
+/*! \addtogroup Basic
+* \{
+*/
+
+typedef UInt8 tmhwEfmc_DeviceNumber_t; /*!< This typedef is for denoting the device number that is connected to the memory controller */
+typedef UInt8 *ptmhwEfmc_DeviceNumber_t; /*!< This typedef is for denoting pointer to the device number that is connected to the memory controller */
+
+/*! \} */ /* addtogroup Basic */
+
+#if (TMFL_EFMCSD_INT || TMFL_SD_ALL)
+
+/*! \addtogroup InterruptSupport
+*  \{
+*/
+
+typedef UInt32 tmhwEfmc_IntMask_t; /*!< This typedef is for denoting the interrupt mask */
+typedef UInt32 *ptmhwEfmc_IntMask_t ; /*!< This typedef is for denoting pointer to the interrupt mask */
+
+/*! \} */ /* addtogroup InterruptSupport */
+
+#endif
+
+
+/* Software Version information */
+#define TMHW_EFMC_COMPATIBILITY_NR     (1) /*!< HwAPI compatibility number */
+#define TMHW_EFMC_MAJOR_VERSION_NR     (1) /*!< HwAPI major version number */
+#define TMHW_EFMC_MINOR_VERSION_NR     (0) /*!< HwAPI minor version number */
+
+#if (TMFL_EFMCSD_INT || TMFL_SD_ALL)
+
+/*! \addtogroup InterruptSupport
+*  \{
+*/
+
+/* interrupt masks */
+#define TMHW_EFMC_INT_OOB_READ              ((tmhwEfmc_IntMask_t)(0x00000001)) /*!< OOB block read request */
+#define TMHW_EFMC_INT_OOB_WRITE             ((tmhwEfmc_IntMask_t)(0x00000002)) /*!< OOB block write request */
+#define TMHW_EFMC_INT_512B_READ             ((tmhwEfmc_IntMask_t)(0x00000004)) /*!< 512byte block read request */
+#define TMHW_EFMC_INT_512B_WRITE            ((tmhwEfmc_IntMask_t)(0x00000008)) /*!< 512byte block write request */
+#define TMHW_EFMC_INT_512B_ENCODED          ((tmhwEfmc_IntMask_t)(0x00000010)) /*!< 512byte block encoded */
+#define TMHW_EFMC_INT_512B_DECODED          ((tmhwEfmc_IntMask_t)(0x00000020)) /*!< 512byte block decoded */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_0    ((tmhwEfmc_IntMask_t)(0x00000040)) /*!< 512byte block decoded with 0 symbol errors */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_1    ((tmhwEfmc_IntMask_t)(0x00000080)) /*!< 512byte block decoded with 1 symbol errors */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_2    ((tmhwEfmc_IntMask_t)(0x00000100)) /*!< 512byte block decoded with 2 symbol errors */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_3    ((tmhwEfmc_IntMask_t)(0x00000200)) /*!< 512byte block decoded with 3 symbol errors */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_4    ((tmhwEfmc_IntMask_t)(0x00000400)) /*!< 512byte block decoded with 4 symbol errors */
+#define TMHW_EFMC_INT_512B_DECODED_ERR_5    ((tmhwEfmc_IntMask_t)(0x00000800)) /*!< 512byte block decoded with 5 symbol errors */
+#define TMHW_EFMC_INT_512B_UNCORR           ((tmhwEfmc_IntMask_t)(0x00001000)) /*!< 512byte block uncorrectable */
+#define TMHW_EFMC_INT_512B_ENCRYPT          ((tmhwEfmc_IntMask_t)(0x00002000)) /*!< Reserved (when AES encryption is disabled), 512byte block decrypted (when AES encryption is enabled) */
+#define TMHW_EFMC_INT_SEQ_PAGE_READ         ((tmhwEfmc_IntMask_t)(0x00004000)) /*!< Sequential page read done */
+#define TMHW_EFMC_INT_SEQ_PAGE_WRITE        ((tmhwEfmc_IntMask_t)(0x00008000)) /*!< Sequential page write done */
+#define TMHW_EFMC_INT_NAND_1_BUSY           ((tmhwEfmc_IntMask_t)(0x00010000)) /*!< Nand flash #1 busy */
+#define TMHW_EFMC_INT_NAND_2_BUSY           ((tmhwEfmc_IntMask_t)(0x00020000)) /*!< Nand flash #2 busy */
+#define TMHW_EFMC_INT_NAND_3_BUSY           ((tmhwEfmc_IntMask_t)(0x00040000)) /*!< Nand flash #3 busy */
+#define TMHW_EFMC_INT_NAND_4_BUSY           ((tmhwEfmc_IntMask_t)(0x00080000)) /*!< Nand flash #4 busy */
+#define TMHW_EFMC_INT_NAND_1_READY          ((tmhwEfmc_IntMask_t)(0x00100000)) /*!< Nand flash #1 ready */
+#define TMHW_EFMC_INT_NAND_2_READY          ((tmhwEfmc_IntMask_t)(0x00200000)) /*!< Nand flash #2 ready */
+#define TMHW_EFMC_INT_NAND_3_READY          ((tmhwEfmc_IntMask_t)(0x00400000)) /*!< Nand flash #3 ready */
+#define TMHW_EFMC_INT_NAND_4_READY          ((tmhwEfmc_IntMask_t)(0x00800000)) /*!< Nand flash #4 ready */
+
+/*! \} */ /* addtogroup InterruptSupport */
+
+#endif
+
+
+/*-----------------------------------------------------------------------------
+* Error codes:
+*-----------------------------------------------------------------------------*/
+#define TMHW_ERR_EFMC_BASE              ((UInt32) CID_EFMC | (UInt32)CID_LAYER_HWAPI)
+
+
+/*-----------------------------------------------------------------------------
+* Global data
+*-----------------------------------------------------------------------------*/
+
+
+/*! \addtogroup Basic
+* \{
+*/
+
+/*
+ * enum definitions
+ */
+
+
+typedef enum tmhwEfmc_EnableDisable
+/*! This enum is used to Enable or Disable a feature in EFMC controller */
+{
+  tmhwEfmc_Disable,       /*!< Disables the corresponding feature */
+  tmhwEfmc_Enable         /*!< Enables the corresponding feature */
+} tmhwEfmc_EnableDisable_t, *ptmhwEfmc_EnableDisable_t;
+
+typedef enum tmhwEfmc_ChipEn
+/*! This enum is used to Enable the corresponding flash chips connected to the EFMC controller */
+{
+  tmhwEfmc_ChipEn0 = 0x00000000,       /*!< Enables the flash chip 0 connected to the EFMC controller */
+  tmhwEfmc_ChipEn1 = 0x00080000,       /*!< Enables the flash chip 1 connected to the EFMC controller */
+  tmhwEfmc_ChipEn2 = 0x00100000,       /*!< Enables the flash chip 2 connected to the EFMC controller */
+  tmhwEfmc_ChipEn3 = 0x00180000        /*!< Enables the flash chip 3 connected to the EFMC controller */
+} tmhwEfmc_ChipEn_t, *ptmhwEfmc_ChipEn_t;
+
+typedef enum tmhwEfmc_CycleType
+/*! This enum is used to send the appropriate command/address cycle to the flash chip connected to the EFMC controller */
+{
+  tmhwEfmc_AddrCycle = 0x00000000,     /*!< Address cycle for the flash chip connected to the EFMC controller */
+  tmhwEfmc_CmdCycle = 0x00010000,      /*!< command cycle for the flash chip connected to the EFMC controller */
+  tmhwEfmc_PostWrCmdCycle = 0x00020000 /*!< post-write command cycle; a post-write command will not be issued until the last write cycle of a sequential page write has been executed. IP_2017 will always consider a post-write command cycle as the last cycle of a command / address sequence */
+} tmhwEfmc_CycleType_t, *ptmhwEfmc_CycleType_t;
+
+typedef enum tmhwEfmc_RWSel
+/*! This enum is used for sending the page_read or page_write command sequence to the flash chip connected to the EFMC controller */
+{
+  tmhwEfmc_Nothing = 0x00,   /*!< This will notify the nand flash controller that a HW controlled page read is to be executed after the next command/address sequence. */
+  tmhwEfmc_PageRead = 0x01,   /*!< This will notify the nand flash controller that a HW controlled page read is to be executed after the next command/address sequence. */
+  tmhwEfmc_PageWrite = 0x02   /*!< This will notify the nand flash controller that a HW controlled page write is to be executed after the next command/address sequence. */
+} tmhwEfmc_RWSel_t, *ptmhwEfmc_RWSel_t;
+
+typedef enum tmhwEfmc_DataWidth
+/*! This enum indicates data width of the correspondig nand flash device connected to EFMC */
+{
+  tmhwEfmc_8Bit,          /*!< 8 bit width */
+  tmhwEfmc_16Bit,         /*!< 16 bit width */
+  tmhwEfmc_Pseudo_16Bit   /*!< Pseudo 16 bit width. Two 8-bit devices connected in parallel */
+} tmhwEfmc_DataWidth_t, *ptmhwEfmc_DataWidth_t;
+
+typedef enum tmhwEfmc_PageSize
+/*! This enum specifies the page size of the corresponding NAND flash device connected to the EFMC controller */
+{
+  tmhwEfmc_512Byte = 0x00,  /*!< Page size = 512 bytes */
+  tmhwEfmc_2048Byte = 0x10, /*!< Page size = 2048 bytes */
+  tmhwEfmc_4096Byte = 0x20  /*!< Page size = 4096 bytes */
+} tmhwEfmc_PageSize_t, *ptmhwEfmc_PageSize_t;
+
+typedef enum tmhwEfmc_RdyDelay
+/*! This enum defines the data read delay timing in AXI/AHB clock cycles */
+{
+  tmhwEfmc_Cycles_0 =   0x00000000,   /*!< 0 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_0_H = 0x00400000, /*!< Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_1 =   0x00800000,   /*!< 1 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_1_H = 0x00C00000, /*!< 1 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_2 =   0x01000000,   /*!< 2 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_2_H = 0x01400000, /*!< 2 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_3 =   0x01800000,   /*!< 3 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_3_H = 0x01C00000, /*!< 3 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_4 =   0x02000000,   /*!< 4 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_4_H = 0x02400000, /*!< 4 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_5 =   0x02800000,  /*!< 5 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_5_H = 0x02C00000,/*!< 5 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_6 =   0x03000000,  /*!< 6 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_6_H = 0x03400000,/*!< 6 and Half AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_7 =   0x03800000,  /*!< 7 AXI/AHB clock cycles */
+  tmhwEfmc_Cycles_7_H = 0x03C00000 /*!< 7 and Half AXI/AHB clock cycles */
+} tmhwEfmc_RdyDelay_t, *ptmhwEfmc_RdyDelay_t;
+
+typedef struct tmhwEfmc_ReadBusySignal
+/*! this structure contains status of R/Bn signal for the NAND flash devices connected to the EFMC controller */
+{
+  Bool   rbEdge_Rise;            /*!< This represent occurance of the rising edge (if TM_TRUE) on the R/Bn signal on the given NAND flash device */
+  Bool   rbEdge_Fall;            /*!< This represent occurance of the falling edge (if TM_TRUE) on the R/Bn signal on the given NAND flash device */
+  Bool   rbEdge_Status_Ready;    /*!< This represent R/Bn signal on the given NAND flash device. TM_TRUE --> device is ready, TM_FALSE --> device is busy. */
+} tmhwEfmc_ReadBusySignal_t, *ptmhwEfmc_ReadBusySignal_t;
+
+
+/*
+ * structures definitions
+ */
+typedef struct tmhwEfmc_CmdAddr
+/*! This structure contains the command/address and the corresponding data to be put onto the IO lines for the flash devices connected to the EFMC controller */
+{
+  tmhwEfmc_ChipEn_t    deviceNum;  /*!< The value of CEn lines during command/address/read-write cycles */
+  Bool                     lastCycle;  /*!< The specified command/address is the last on the sequence. When TRUE, nand flash controller will start sending all the commands and/or address present in the FIFO to the nand flash device */
+  tmhwEfmc_CycleType_t cycleType;  /*!< Address/command/PostWrite command cycle type */
+  UInt16                   data;       /*!< data on the IO lines during address/command cycle */
+}tmhwEfmc_CmdAddr_t, *ptmhwEfmc_CmdAddr_t;
+
+typedef struct tmhwEfmc_PageConfig
+/*! this structure contains the page related read/write configuration for the flash device */
+{
+  Bool                 includeOOB; /*!< Specifies whether OOB block to be included in the page read/write transfer. TM_TRUE --> OOB block included, FALSE --> OOB block is not included */
+  Bool                 includeAES; /*!< Specifies whether AES IP needs to be included. TM_TRUE --> AES IP is included, TM_FALSE --> AES IP is not included */
+  Bool                 includeECC; /*!< Specifies whether hardware ECC to be enabled/disabled. TM_TRUE --> hardware ECC is enabled, TM_FALSE --> hardware ECC is disabled. */
+  tmhwEfmc_RWSel_t operType;   /*!< Operation type. Hardware page read or hardware page write operation */
+} tmhwEfmc_PageConfig_t, *ptmhwEfmc_PageConfig_t;
+
+typedef struct tmhwEfmc_TimingConfig
+/*! This structure contains the timing configuration for the corresponding NAND flash device connected to the EFMC controller */
+{
+  UInt8                   tCenSetup;    /*!< CEn pre-setup time. Range: 1-16 AXI/AHB cycles. Number of AXI/AHB clock cycles between
+                                           - falling edge of CEn and rising edge of ALE at the beginning of an address latch
+                                           - falling edge of CEn and rising edge of CLE at the beginning of a command latch
+                                           - falling edge of CEn and falling edge of WEn/REn at the beginning of a write/read */
+  UInt8                   tCenHold;     /*!< CEn post-hold time. Range: 1-16 AXI/AHB cycles. Number of AXI/AHB clock cycles between
+                                           - falling edge of ALE and rising edge of CEn at the end of an address latch
+                                           - falling edge of CLE and rising edge of CEn at the end of a command latch
+                                           - rising edge of WEn/REn and rising edge of CEn at the end of a write/read */
+  UInt8                   tCleSetup;    /*!< defines the CLE setup time, i.e. the number of AXI/AHB clock cycles between rising/falling  edge of CLE and falling edge of WEn. Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tCleHold;     /*!< defines the CLE hold time, i.e. the number of AXI/AHB clock cycles between rising edge of WEn and falling edge of CLE.  Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tAleSetup;    /*!< defines the ALE setup time, i.e. the number of AXI/AHB clock cycles between rising/falling edge of ALE and falling edge of WEn.  Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tAleHold;     /*!< defines the ALE hold time, i.e. the number of AXI/AHB clock cycles between rising edge of WEn and falling edge of ALE.  Range: 1-16 AXI/AHB clock cycles  */
+  UInt8                   tWaitForRdy;  /*!< defines the wait until ready time, i.e. the number of AXI/AHB clock cycles between rising edge of R/Bn and falling edge of REn. Range: 4-16 AXI/AHB clock cycles. */
+  tmhwEfmc_RdyDelay_t tRdDelay;     /*!< defines the data read delay, i.e. the number of AXI/AHB clock cycles divided by two between rising edge of REn and clocking of the read data. This delay can be used to compensate for IO pad delay. */
+  UInt8                   tWaitForBusy; /*!< defines the wait until busy time, i.e. the number of AXI/AHB clock cycles between rising edge of WEn and falling edge of R/Bn. Range: 1-64 AXI/AHB cycles */
+  UInt8                   tWenWidth;    /*!< defines the WEn pulse width, i.e. the number of AXI/AHB clock cycles [3] that WEn is asserted low. Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tWenHigh;     /*!< defines the WEn high hold time, i.e. the number of AXI/AHB clock cycles [3] between rising and falling edge of WEn. Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tRenWidth;    /*!< defines the REn pulse width, i.e. the number of clock AXI/AHB clock cycles [3] that REn is asserted low. Range: 1-16 AXI/AHB clock cycles */
+  UInt8                   tRenHigh;     /*!< defines the REn high hold time, i.e. the number of AXI/AHB clock cycles [3] between rising and falling edge of REn. Range: 1-16 AXI/AHB clock cycles */
+} tmhwEfmc_TimingConfig_t, *ptmhwEfmc_TimingConfig_t;
+
+typedef struct tmhwEfmc_FlashConfig
+/*! This structure specifies the flash configuration for the correspondign flash device connected to the EFMC controller */
+{
+  tmhwEfmc_PageSize_t      pageSize;          /*!< Page size of the NAND flash device. */
+  tmhwEfmc_EnableDisable_t enableWrProtect;   /*!< Data write protection enabled/disabled */
+  tmhwEfmc_EnableDisable_t enableCENDontCare; /*!< defines whether the nand flash device supports "CEn don.t care". The "CEn don.t care" feature allows another memory controller like e.g. the IP_2016 to interrupt an ongoing sequential read/write. */
+  tmhwEfmc_DataWidth_t     dataWidth;         /*!< data width of the NAND flash device */
+  tmhwEfmc_TimingConfig_t  devTiming;         /*!< timing parameters for the NAND flash device */
+} tmhwEfmc_FlashConfig_t, *ptmhwEfmc_FlashConfig_t;
+
+/*! \} */ /* addtogroup Basic */
+
+
+#if (TMFL_EFMCSD_EBI || TMFL_SD_ALL)
+
+/*! \addtogroup EBIPinSharingMode
+* \{
+*/
+
+/*
+ * enum definitions
+ */
+
+typedef enum tmhwEfmc_BackoffMode
+/*! This enum defines the backoff mode that specifies when to backoff when the backoff-timeout occurs for the EFMC */
+{
+  tmhwEfmc_Always = 0x00, /*!< always complete current AHB burst and then backoff */
+  tmhwEfmc_Current = 0x02 /*!< complete only the current memory transaction and then backoff */
+} tmhwEfmc_BackoffMode_t, *ptmhwEfmc_BackoffMode_t;
+
+/*
+ * structure definitions
+ */
+
+typedef struct tmhwEfmc_BackoffConfig
+/*! This structure defines the Back-Off configuration for EBI pin-sharing for the EFMC */
+{
+  tmhwEfmc_EnableDisable_t    defaultReqEnable; /*!< EBI default request mode: When enabled, NAND flash controller will do a default request for the memory bus whenever it is idle. In overall system there shall only be one memory controller with default request enabled. */
+  UInt8                           timeOut; /*!< Backoff timout value after which the EBI backoff singal will be taken into account. Range 0 - 0xFF where in 0x00--> timeout immediately, otherwise timeout after n AHB clock cycles  */
+  tmhwEfmc_BackoffMode_t      mode; /*!< When backoff timeout is reached, this defines when to backoff */
+} tmhwEfmc_BackoffConfig_t, *ptmhwEfmc_BackoffConfig_t;
+
+
+/*! \} */ /* addtogroup EBIPinSharingMode */
+
+#endif
+
+#if (TMFL_EFMCSD_DMA || TMFL_SD_ALL)
+/*! \addtogroup DmaSupport
+ *  \{
+ */
+
+/*
+ * structure definitions
+ */
+
+
+typedef struct tmhwEfmc_DmaConfig
+/*! This structure is used to configure the flow control for the DMA operation for EFMC */
+{
+  tmhwEfmc_EnableDisable_t   enableM2PDma;  /*!< Enables/disables flow control for memory-to-peripheral DMA (used when writing to Nand flash)  */
+  tmhwEfmc_EnableDisable_t   enableP2MDma;  /*!< Enables/disables flow control for peripheral-to-memory DMA (used when reading from Nand flash) */
+} tmhwEfmc_DmaConfig_t, *ptmhwEfmc_DmaConfig_t;
+
+/*! \} */ /* end of DmaSupport */
+
+#endif
+
+
+#if (TMFL_EFMCSD_AES || TMFL_SD_ALL)
+/*! \addtogroup AESSupport
+ *  \{
+ */
+
+/*
+ * enum definitions
+ */
+
+typedef enum tmhwEfmc_AESStatus
+/*! This enum specifies the status of the AES IP */
+{
+  tmhwEfmc_AESBusy = 0x00,     /*!< AES IP is busy condition */
+  tmhwEfmc_AESSetupKey = 0x02, /*!< AES IP is in key-setup condition, where in new data (to AES IP) will not be accepted until a key has been expanded */
+  tmhwEfmc_AESIdle = 0x03      /*!< AES IP is idle condition and can accept new key for expansion or for more data processing */
+} tmhwEfmc_AESStatus_t, *ptmhwEfmc_AESStatus_t;
+
+/*
+ * structure definitions
+ */
+
+typedef struct tmhwEfmc_AESConfig
+/*! This structure stores the AES configuration that need to be sent to AES IP */
+{
+  UInt32   keyAES[4];  /*!< 128-bit AES key value to be transferred to AES IP */
+  UInt32   initAES[4]; /*!< 128-bit AES initial value to be transferred to AES IP */
+} tmhwEfmc_AESConfig_t, *ptmhwEfmc_AESConfig_t;
+
+
+/*! \} */ /* addtogroup AESSupport */
+
+#endif
+
+#if (TMFL_EFMCSD_APB || TMFL_SD_ALL)
+
+/*! \addtogroup APBConfig
+*  \{
+*/
+
+/*
+ * enum definitions
+ */
+
+typedef enum tmhwEfmc_Apb_Latency
+/*! This enum defines the APB latency for read/write on APB */
+{
+  tmhwEfmc_Apb_Latency_1_Cycle = 0x00, /*!< No additional wait state insertion. Minimum read/write latency is 1 APB clock cycle */
+  tmhwEfmc_Apb_Latency_2_Cycle = 0x01  /*!< Insert one additional wait state. Minimum read/write latency is 2 APB clock cycles */
+} tmhwEfmc_Apb_Latency_t, *ptmhwEfmc_Apb_Latency_t;
+
+/*! \} */ /* end of APBConfig */
+#endif
+
+
+#if (TMFL_EFMCSD_AHB || TMFL_SD_ALL)
+/*! \addtogroup AHBConfig
+ *  \{
+ */
+
+
+typedef enum tmhwEfmc_SelRegistering
+/*! This enum defines the registering of combinational data and the read-data registering */
+{
+  tmhwEfmc_Combinational = 0x00, /*!< AHB/APB command is combinational */
+  tmhwEfmc_Registered = 0x01 /*!< AHB/APB command or read data is registered */
+} tmhwEfmc_SelRegistering_t, *ptmhwEfmc_SelRegistering_t;
+
+
+/*! \} */ /* addtogroup AHBConfig */
+
+#endif
+
+
+#if (TMFL_EFMCSD_OTHERS || TMFL_SD_ALL)
+
+/*! \addtogroup Others
+ *  \{
+ */
+
+/*
+ * enum definitions
+ */
+
+typedef enum tmhwEfmc_SelConfig
+/*! This enum specifies the mode of relevant APB feature whether it is a configurable or programmable */
+{
+  tmhwEfmc_Configurable = 0x00, /*!< APB configuration is configurable i.e Read-only */
+  tmhwEfmc_Programmable = 0x01 /*!< APB configuration is programmable i.e Read/write */
+} tmhwEfmc_SelConfig_t, *ptmhwEfmc_SelConfig_t;
+
+typedef enum tmhwEfmc_DataBusType
+/*! This enum specifies the data bus type supported by EFMC */
+{
+  tmhwEfmc_DataBus_32BitAHB = 0x0000 /*!< 32-bit AHB data bus type */
+} tmhwEfmc_DataBusType_t, *ptmhwEfmc_DataBusType_t;
+
+/*
+ * structure definitions
+ */
+
+typedef struct tmhwEfmc_Capabilities
+/*! This structure provides the capabilities of the EFMC */
+{
+  tmhwEfmc_SelConfig_t        progApbLatency;  /*!< APB latency configuration */
+  tmhwEfmc_SelConfig_t        progApbErrConfig;          /*!< APB error configuration */
+  tmhwEfmc_DataBusType_t      busType;/*!< data bus type supported by EFMC */
+  tmhwEfmc_SelConfig_t        dataBusLatency;  /*!< Data bus latency configuration */
+  Bool                            supportAES;      /*!< Support for AES included or not. TM_TRUE if included, TM_FALSE if not included */
+  Bool                            enEBIPinShare;     /*!< Support for EBI pin-sharing included or not. TM_TRUE if included, TM_FALSE if not included */
+  Bool                            bootFromNAND;    /*!< Support boot from NAND flash device. TM_TRUE if supported, TM_FALSE if not supported */
+  Bool                            localRstSync;       /*!< Reset local synchronizers. TM_TRUE if yes, TM_FALSE if no */
+  UInt8                           maxDevices;      /*!< Maximum number of flash devices supported. Range 1-4 */
+  UInt16                          efmcModuleId;    /*!< EFMC Module ID */
+  UInt8                           efmcRevMajor;    /*!< EFMC Major revision number */
+  UInt8                           efmcRevMinor;    /*!< EFMC Minor revision number */
+  UInt8                           efmcAperSize;    /*!< EFMC MMIO register aperture */
+} tmhwEfmc_Capabilities_t, *ptmhwEfmc_Capabilities_t;
+
+/*! \} */ /* addtogroup Others */
+
+#endif
+
+
+
+/* Function definitions */
+
+/*! \addtogroup Basic
+* \{
+*/
+
+/*! \fn tmErrorCode_t tmhwEfmc_Init (tmUnitSelect_t  efmcUnitID);
+*    This function initializes the EFM Device and powers ON the EFM device. This API should be called before any access to the EFM device.
+*    \param[in] efmcUnitID -> EFMC Unit Number
+*    \return TM_OK - Successful.
+*/
+tmErrorCode_t
+tmhwEfmc_Init(
+    tmUnitSelect_t                 efmcUnitID
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteCmdAddr( tmUnitSelect_t efmcUnitID, const tmhwEfmc_CmdAddr_t * pCmdAddr);
+*     This function issues the appropriate cmd/addr cycle to the appropriate NAND flash device connected to the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pCmdAddr -> pointer to the tmhwEfmc_CmdAddr_t structure that contains the flash command and address to be given for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteCmdAddr(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_CmdAddr_t *         pCmdAddr
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_InitPageOp( tmUnitSelect_t efmcUnitID, const tmhwEfmc_PageConfig_t * pPageOper);
+*     This function configures the page read/write operation for the relevant NAND flash device.
+*     Note: This API should be called before relevant command/address/post-commands sequence put into the FIFO. Please refer to the use
+*     cases of page read/write.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pPageOper -> pointer to the tmhwEfmc_PageConfig_t structure that contains the page configuration for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_InitPageOp(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_PageConfig_t *      pPageOper
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetFlashConfig( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, const tmhwEfmc_FlashConfig_t * pFlashConfig);
+*     This function configures the given NAND flash device for timing parameters, data width and page size and also for write-protect of NAND flash device.
+*     Note: This API should be called before relevant command/address/post-commands sequence put into the FIFO. Please refer to the initialization sequence of the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number for which the configuration to be set
+*     \param[in] pFlashConfig -> pointer to the tmhwEfmc_FlashConfig_t structure that contains the flash configuration for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetFlashConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    const tmhwEfmc_FlashConfig_t *     pFlashConfig
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadSingleData( tmUnitSelect_t efmcUnitID, pUInt16 pDataRead);
+*     This function reads a single 16-bit data from the relevant NAND flash device.
+*     Note: This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pDataRead -> pointer to the UInt16, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadSingleData(
+    tmUnitSelect_t                  efmcUnitID,
+    pUInt16                         pDataRead
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteSingleData( tmUnitSelect_t efmcUnitID, UInt16 dataWrite);
+*     This function writes a single 16-bit data to the relevant NAND flash device.
+*     Note: This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] dataWrite -> data that needs to be written to the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteSingleData(
+    tmUnitSelect_t                  efmcUnitID,
+    UInt16                          dataWrite
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadBufData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataRead);
+*     This function reads 512 bytes of data from the EFMC buffer. If the NAND flash has a page size more than 512 bytes, then
+*     this API should be called number of times to get the whole page size and also memory location address should be provided
+*     appropriately.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. The pointer provided should have the memory space of 512 bytes.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number from which the data to be read
+*     \param[out] pDataRead -> pointer to the memory location, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadBufData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    pVoid                           pDataRead
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadOobData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataRead);
+*     This function reads OOB data of the corresponding page of NAND nand flash device.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. This API must be called only after the whole PAGE data is read from the buffer by calling tmhwEfmc_ReadBufData function.
+*     3. The pointer provided should have the memory space for the OOB data whose size depends upon the PAGE size of the given NAND flash device.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number from which the data to be read
+*     \param[out] pDataRead -> pointer to the memory location, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadOobData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    pVoid                           pDataRead
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteBufData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataWrite);
+*     This function writes 512 bytes of data from the EFMC buffer. If the NAND flash has a page size more than 512 bytes, then
+*     this API should be called number of times to write the whole page size and also memory location address should be provided
+*     appropriately.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. The pointer provided should have the memory space of 512 bytes.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number to which the data needs to be written.
+*     \param[out] pDataWrite -> pointer to the memory location, from where the data is read and is written onto the NAND flash.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteBufData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    pVoid                           pDataWrite
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteOobData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataWrite);
+*     This function writes OOB data to the NAND flash page.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. This API must be called only after the whole page data is written onto the NAND flash device by tmhwEfmc_WriteBufData function.
+*     3. The pointer provided should have the memory space for the OOB data whose size depends upon the PAGE size of the given NAND flash device.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number to which the OOB data needs to be written.
+*     \param[out] pDataWrite -> pointer to the memory location, from where the OOB data is read and is written onto the NAND flash.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteOobData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    pVoid                           pDataWrite
+);
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetBusyStatus( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, ptmhwEfmc_ReadBusySignal_t pBusyStatus);
+*     This function gets the status of the given flash device connected to the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number
+*     \param[out] pBusyStatus -> pointer to the tmhwEfmc_ReadBusySignal_t structure that contains the status of NAND flash device ready/busy signal.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetBusyStatus(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    ptmhwEfmc_ReadBusySignal_t  pBusyStatus
+);
+
+
+/*! \} */ /* addtogroup Basic */
+
+
+
+#if (TMFL_EFMCSD_DMA || TMFL_SD_ALL)
+/*! \addtogroup DmaSupport
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetDmaConfig( tmUnitSelect_t efmcUnitID, const tmhwEfmc_DmaConfig_t * pDmaConfig);
+*     This function will setup the DMA configuration for the data transfer to/from NAND flash devices connected the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pDmaConfig -> pointer to the tmhwEfmc_DmaConfig_t structure that contains the DMA configuration for the data transfer to/from the NAND flash devices.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetDmaConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_DmaConfig_t *       pDmaConfig
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetDmaConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_DmaConfig_t pDmaConfig);
+*     This function will retrieve the DMA configuration that is used for the data transfer to/from NAND flash devices connected the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pDmaConfig -> pointer to the tmhwEfmc_DmaConfig_t structure where in the read DMA configuration to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetDmaConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_DmaConfig_t       pDmaConfig
+);
+
+
+/*! \} */ /* end of DmaSupport */
+
+#endif
+
+
+
+#if (TMFL_EFMCSD_AES || TMFL_SD_ALL)
+/*! \addtogroup AESSupport
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetAESConfig( tmUnitSelect_t efmcUnitID, const tmhwEfmc_AESConfig_t * pAESConfig);
+*     This function will setup the AES configuration required for AES IP.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pAESConfig -> pointer to the tmhwEfmc_AESConfig_t structure that contains the AES configuration data to be sent to the AES IP.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetAESConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_AESConfig_t *       pAESConfig
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAESConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_AESConfig_t pAESConfig);
+*     This function will retrieve the AES configuration set in the AES IP.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pAESConfig -> pointer to the tmhwEfmc_AESConfig_t structure where in the configuration data read from AES IP needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAESConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_AESConfig_t       pAESConfig
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAESStatus( tmUnitSelect_t efmcUnitID, ptmhwEfmc_AESStatus_t pAESStatus);
+*     This function will retrieve the status of AES IP whether it is busy or idle.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pAESStatus -> pointer to the tmhwEfmc_AESStatus_t enum where in the status of AES IP needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAESStatus(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_AESStatus_t       pAESStatus
+);
+
+
+/*! \} */ /* end of AESSupport */
+
+#endif
+
+
+
+
+#if (TMFL_EFMCSD_POWER || TMFL_SD_ALL)
+
+/*! \addtogroup PowerState
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetPowerState (tmUnitSelect_t  efmcUnitID, tmPowerState_t  powerState);
+*     Function will set the EFMC Device to a specified power state. Only D0 (Device Powered on) and D3 (Device Powered off) state are valid.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] powerState -> Power state to which EFMC device needs to be set. Only D0 (Device Powered On) and D3 (Device Powered Off) states are valid.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetPowerState (
+    tmUnitSelect_t                 efmcUnitID,
+    tmPowerState_t                 powerState
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetPowerState (tmUnitSelect_t  efmcUnitID, ptmPowerState_t  pPowerState);
+*     This function gets the present Power state of the Device.
+*
+*    \param[in] efmcUnitID -> EFMC Unit Number
+*    \param[out] pPowerState -> Pointer to tmPowerState_t typedefinition.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetPowerState (
+    tmUnitSelect_t                  efmcUnitID,
+    ptmPowerState_t                 pPowerState
+);
+
+/*! \} */ /* end of PowerState */
+
+#endif
+
+
+
+#if (TMFL_EFMCSD_INT || TMFL_SD_ALL)
+
+/*! \addtogroup InterruptSupport
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntEnable(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntEnable);
+*    This function will enable the relevant interrupts defined by the given interrupt mask value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntEnable -> Interrupt enable mask bits for which relevant interrupts to be enabled.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntEnable(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntEnable
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntDisable(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntDisable);
+*    This function will disable the relevant interrupts defined by the given interrupt mask value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntDisable -> Interrupt disable mask bits for which relevant interrupts to be disabled.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntDisable(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntDisable
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntGetStatus(tmUnitSelect_t  efmcUnitID, ptmhwEfmc_IntMask_t pEfmIntGetStatus);
+*    This function will get the current interrupts status.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pEfmIntGetStatus -> Pointer to tmhwEfmc_IntMask_t where in read interrupt status needs to be stored.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntGetStatus(
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_IntMask_t        pEfmIntGetStatus
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntClear(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntClear);
+*    This function will clear the relevent interrupts status. The given maks will provide which interrupt status to be cleared.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntClear -> Interrupt mask for which the relevent interrupts status to be cleared.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntClear(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntClear
+);
+
+
+/*! \} */ /* end of InterruptSupport */
+
+#endif
+
+
+
+
+#if (TMFL_EFMCSD_EBI || TMFL_SD_ALL)
+/*! \addtogroup EBIPinSharingMode
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetBackoffConfig ( tmUnitSelect_t efmcUnitID, const tmhwEfmc_BackoffConfig_t * pBackOffConfig );
+*     This function configures the EBI pin sharing (backoff mode) for the EFMC. The details include hte timeout for
+*     backoff, mode of backoff. This function acts on the whole EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pBackOffConfig -> pointer to the tmhwEfmc_BackoffConfig_t structure that contians the backoff config parameters.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetBackoffConfig (
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_BackoffConfig_t *   pBackOffConfig
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetBackoffConfig ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_BackoffConfig_t pBackOffConfig );
+*     This function retrieves the confiuration of the EBI pin sharing (backoff mode) for the EFMC. The details include hte
+*     timeout for backoff, mode of backoff. This function acts on the whole EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pBackOffConfig -> pointer to the tmhwEfmc_BackoffConfig_t structure where retrieved information to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetBackoffConfig (
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_BackoffConfig_t   pBackOffConfig
+);
+
+
+/*! \} */ /* end of EBIPinSharingMode */
+
+#endif
+
+
+
+
+#if (TMFL_EFMCSD_AHB || TMFL_SD_ALL)
+/*! \addtogroup AHBConfig
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetAhbConfig( tmUnitSelect_t efmcUnitID,tmhwEfmc_SelRegistering_t   commandRegistering, tmhwEfmc_SelRegistering_t   rdDataRegistering);
+*     This function sets the AHB configuration for the command and read-data registering.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] commandRegistering -> AXI/AHB command registering
+*     \param[in] rdDataRegistering -> AXI/AHB read-data registering
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetAhbConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_SelRegistering_t   commandRegistering,
+    tmhwEfmc_SelRegistering_t   rdDataRegistering
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAhbConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_SelRegistering_t   pCommandRegistering, ptmhwEfmc_SelRegistering_t   pRdDataRegistering);
+*     This function gets the AHB configuration for the command and read-data registering.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pCommandRegistering -> AXI/AHB command registering configuration to be stored
+*     \param[out] pRdDataRegistering -> AXI/AHB read-data registering configuration to be stored
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAhbConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_SelRegistering_t  pCommandRegistering,
+    ptmhwEfmc_SelRegistering_t  pRdDataRegistering
+);
+
+
+/*! \} */ /* addtogroup AHBConfig */
+
+#endif
+
+
+
+
+#if (TMFL_EFMCSD_APB || TMFL_SD_ALL)
+
+/*! \addtogroup APBConfig
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbErrConfig ( tmUnitSelect_t efmcUnitID, tmhwEfmc_EnableDisable_t enableWrErr, tmhwEfmc_EnableDisable_t enableRdErr);
+*     This function will configure the APB error generation. Please note that this function should be called only
+*     when the IP is capable of programming the APB error generation. Call tmhwEfmc_GetCapabilities() function
+*     to get the capability of APB error generation in pCaps->progApbErrConfig. The application should call this function only
+*     if pCaps->progApbErrConfig == tmhwEfmc_Programmable.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] enableWrErr -> Enabling of APB write error generation
+*    \param[in] enableRdErr -> Enabling of APB read error generation
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbErrConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_EnableDisable_t   enableWrErr,
+    tmhwEfmc_EnableDisable_t   enableRdErr
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbErrConfig ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_EnableDisable_t pEnableWrErr, ptmhwEfmc_EnableDisable_t pEnableRdErr);
+*     This function will get the APB error generation status
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pEnableWrErr -> APB write error generation status
+*    \param[in] pEnableRdErr -> APB read error generation status
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbErrConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_EnableDisable_t  pEnableWrErr,
+    ptmhwEfmc_EnableDisable_t  pEnableRdErr
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbTimeoutConfig ( tmUnitSelect_t efmcUnitID, UInt16 timeout);
+*     This function will configure the APB operation timeout.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] timeout -> APB operation timeout value. Range : 0x00 - 0xFFFF. If 0x00 represent, timeout is disabled, else timeout value is n APB cycles.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbTimeoutConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    UInt16                         timeout
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbTimeoutConfig ( tmUnitSelect_t efmcUnitID, pUInt16 pTimeout);
+*     This function will get the APB operation timeout value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pTimeout -> APB operation timeout value.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbTimeoutConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    pUInt16                        pTimeout
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbLatency ( tmUnitSelect_t efmcUnitID, tmhwEfmc_Apb_Latency_t insertWait);
+*     This function will configure the APB read/write latency. Please note that this function should be called only
+*     when the IP is capable of programming the APB error generation. Call tmhwEfmc_GetCapabilities() function
+*     to get the capability of APB error generation in pCaps->progApbLatency. The application should call this function only
+*     if pCaps->progApbLatency == tmhwEfmc_Programmable.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] insertWait -> APB read/write latency value
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbLatency (
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_Apb_Latency_t     insertWait
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbLatency ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_Apb_Latency_t pInsertWait);
+*     This function will get the APB read/write latency value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pInsertWait -> APB read/write latency value that to be stored in the location pointed by this variable.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbLatency (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_Apb_Latency_t    pInsertWait
+);
+
+
+/*! \} */ /* end of APBConfig */
+
+#endif
+
+
+#if (TMFL_EFMCSD_OTHERS || TMFL_SD_ALL)
+
+/*! \addtogroup Others
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetSWVersion (ptmSWVersion_t  pEfmVersionInfo);
+*     This function gets the Software version of the HwAPI.Function can be called used by the
+*     application to know whether correct version of the software is used.
+*
+*    \param[out] pEfmVersionInfo -> pointer to tmSWVersion_t structure.
+*    \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetSWVersion (
+    ptmSWVersion_t                 pEfmVersionInfo
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_Deinit(tmUnitSelect_t  efmcUnitID);
+*     This function will deinitialize the EFMC device. This function serves no purpose.
+*
+*    \param[in] efmcUnitID -> EFMC unit number.
+*    \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_Deinit(
+    tmUnitSelect_t                 efmcUnitID
+);
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetCapabilities (tmUnitSelect_t  efmcUnitID, ptmhwEfmc_Capabilities_t  pCaps);
+*     This function gets capabilities of the EFMC Hardware device and the structure elements specifies whether the certain
+*     features of EFMC are configured in the EFMC IP or not.
+*
+*    \param[in] efmcUnitID -> EFMC unit Number.
+*    \param[out] pCaps -> Pointer to tmhwEfmc_Capabilities_t structure.
+*    \return TM_OK - Successful.
+*/
+tmErrorCode_t
+tmhwEfmc_GetCapabilities (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_Capabilities_t   pCaps
+);
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetFlashConfig( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, ptmhwEfmc_FlashConfig_t pFlashConfig);
+*     This function retrieves the given NAND flash device configuration. The configuration such as timing parameters, data width and page size and also for write-protect of NAND flash device is stored in the parameter.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number for which the configuration to be retrieved.
+*     \param[out] pFlashConfig -> pointer to the tmhwEfmc_FlashConfig_t structure where in the read configuration needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetFlashConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    ptmhwEfmc_FlashConfig_t     pFlashConfig
+);
+
+/*!\fn tmErrorCode_t tmhwEfmc_SoftReset ( tmUnitSelect_t efmcUnitID);
+*     This function provides a soft reset to the EFMC unit.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SoftReset (
+    tmUnitSelect_t                  efmcUnitID
+);
+
+/*! \} */ /* end of Others */
+
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* TMHWEFMC_H */
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1477 @@
+/*
+ * Copyright(C) 2007
+ * NXP B.V.
+ * All rights reserved
+ *
+ * This  source code and any compilation or derivative thereof is the
+ * proprietary information of NXP B.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be exposed to or placed
+ * under an Open Source License of any type without the expressed
+ * written permission of NXP B.V.
+ */
+/*----------------------------------------------------------------------------*/
+ /*!
+ * \FILENAME:     tmhwEfmc.c
+ *
+ * \DESCRIPTION: Source code of EFMC IP_2070
+ *
+ * \DOCUMENT REF:
+ *
+ * \REVISION HISTORY:
+ * \Version    Author                               Date                 Remarks
+ * \1.0      Mahadev Cholachagudda     2006-06-07           Draft
+ * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
+ *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ *---------------------------------------------------------------------------
+ */
+
+
+/*----------------------------------------------------------------------------
+* Standard include files:
+*----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Project specific include files:
+*-----------------------------------------------------------------------------*/
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+/*-----------------------------------------------------------------------------
+* Component specific include files:
+*-----------------------------------------------------------------------------*/
+#include "tmhwEfmc_Vhip.h"
+#include "tmhwEfmc_Cfg.h"
+#include "tmhwEfmc.h"
+
+/*-----------------------------------------------------------------------------
+* Typedefs and Macros
+*-----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Global data
+*-----------------------------------------------------------------------------*/
+
+/*------------------------------------------------------------------------------
+* Defines
+*------------------------------------------------------------------------------*/
+
+#define TMVH_EFMC_HWMODULE_MAJOR_REV        0x2
+#define TMVH_EFMC_HWMODULE_MINOR_REV        0x1
+
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+
+/*! \fn tmErrorCode_t tmhwEfmc_Init (tmUnitSelect_t  efmcUnitID);
+*    This function initializes the EFMC and powers ON the EFM device. This API should be called before any access to the EFM device.
+*    \param[in] efmcUnitID -> EFMC Unit Number
+*    \return TM_OK - Successful.
+*/
+tmErrorCode_t
+tmhwEfmc_Init(
+    tmUnitSelect_t                 efmcUnitID ATTRIBUTE_UNUSED
+)
+{
+  /* nothing to be done here */
+  return TM_OK;
+}
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteCmdAddr( tmUnitSelect_t efmcUnitID, const tmhwEfmc_CmdAddr_t * pCmdAddr);
+*     This function issues the appropriate cmd/addr cycle to the appropriate NAND flash device connected to the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pCmdAddr -> pointer to the tmhwEfmc_CmdAddr_t structure that contains the flash command and address to be given for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteCmdAddr(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_CmdAddr_t *         pCmdAddr
+)
+{
+  UInt32              regs   = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs = (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_CMD_ADDR_FIFO_OFFSET );
+  regVal |= (UInt32) (pCmdAddr->deviceNum) ;
+  
+  if( TM_TRUE == pCmdAddr->lastCycle )
+  {
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_LAST_CYCLE_MSK ;
+  }
+  
+  regVal |= (UInt32) (pCmdAddr->cycleType) ;
+  regVal |= (UInt32) ( pCmdAddr->data & TMVH_EFMC_CMD_ADDR_FIFO_IO_MSK) ;
+  TMVH_GEN_WRITE( regs, regVal );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_InitPageOp( tmUnitSelect_t efmcUnitID, const tmhwEfmc_PageConfig_t * pPageOper);
+*     This function configures the page read/write operation for the relevant NAND flash device.
+*     Note: This API should be called before relevant command/address/post-commands sequence put into the FIFO. Please refer to the use
+*     cases of page read/write.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pPageOper -> pointer to the tmhwEfmc_PageConfig_t structure that contains the page configuration for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_InitPageOp(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_PageConfig_t *      pPageOper
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal    = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_PAGE_RW_OFFSET );
+  /* Just write the values directly into the register */
+  if( TM_TRUE == pPageOper->includeOOB  )
+  {
+    regVal |= (UInt32) (TMVH_EFMC_PAGE_RW_OOB_MSK) ;
+  }
+  if( TM_TRUE == pPageOper->includeAES )
+  {
+    regVal |= (UInt32) (TMVH_EFMC_PAGE_RW_AES_MSK) ;
+  }
+  if( TM_TRUE == pPageOper->includeECC )
+  {
+    regVal |= (UInt32) (TMVH_EFMC_PAGE_RW_ECC_MSK) ;
+  }
+  regVal |= (UInt32) (pPageOper->operType) ;
+
+  TMVH_GEN_WRITE( regs, regVal );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetFlashConfig( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, const tmhwEfmc_FlashConfig_t * pFlashConfig);
+*     This function configures the given NAND flash device for timing parameters, data width and page size and also for write-protect of NAND flash device.
+*     Note: This API should be called before relevant command/address/post-commands sequence put into the FIFO. Please refer to the initialization sequence of the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number for which the configuration to be set
+*     \param[in] pFlashConfig -> pointer to the tmhwEfmc_FlashConfig_t structure that contains the flash configuration for the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetFlashConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    const tmhwEfmc_FlashConfig_t *     pFlashConfig
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal    = 0 ;
+
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+
+  /* Just write the values directly into the register */
+  regVal = (UInt32) (pFlashConfig->dataWidth) ;
+  if( tmhwEfmc_Enable == pFlashConfig->enableCENDontCare )
+  {
+    regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK);
+  }
+  if( tmhwEfmc_Enable == pFlashConfig->enableWrProtect )
+  {
+    regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_WP_MSK);
+  }
+  regVal |= (UInt32) (pFlashConfig->pageSize) ;
+
+  TMVH_GEN_WRITE( regs, regVal );
+
+  /* configure the timing0 register */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TIMING0_DIFF ) );
+  regVal = (UInt32) (pFlashConfig->devTiming.tWaitForRdy & TMVH_EFMC_DEV_TIMING0_TRR_MSK);
+
+  /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleHold)) << TMVH_EFMC_DEV_TIMING0_TALH_POS ) & TMVH_EFMC_DEV_TIMING0_TALH_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleSetup)) << TMVH_EFMC_DEV_TIMING0_TALS_POS ) & TMVH_EFMC_DEV_TIMING0_TALS_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleHold)) << TMVH_EFMC_DEV_TIMING0_TCLH_POS ) & TMVH_EFMC_DEV_TIMING0_TCLH_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleSetup)) << TMVH_EFMC_DEV_TIMING0_TCLS_POS ) & TMVH_EFMC_DEV_TIMING0_TCLS_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenHold))<< TMVH_EFMC_DEV_TIMING0_TCPH_POS ) & TMVH_EFMC_DEV_TIMING0_TCPH_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenSetup)) << TMVH_EFMC_DEV_TIMING0_TCPS_POS ) & TMVH_EFMC_DEV_TIMING0_TCPS_MSK );
+
+  TMVH_GEN_WRITE( regs, regVal );
+
+  /* configure the timing1 register */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING1_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TIMING1_DIFF ) );
+  
+  regVal = (UInt32) (pFlashConfig->devTiming.tRenHigh & TMVH_EFMC_DEV_TIMING1_TRH_MSK );
+  regVal |= (UInt32) (pFlashConfig->devTiming.tRdDelay);
+  /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWaitForBusy)) << TMVH_EFMC_DEV_TIMING1_TWB_POS ) & TMVH_EFMC_DEV_TIMING1_TWB_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenWidth)) << TMVH_EFMC_DEV_TIMING1_TWP_POS ) & TMVH_EFMC_DEV_TIMING1_TWP_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenHigh)) << TMVH_EFMC_DEV_TIMING1_TWH_POS ) & TMVH_EFMC_DEV_TIMING1_TWH_MSK );
+  regVal |= ((((UInt32)(pFlashConfig->devTiming.tRenWidth)) << TMVH_EFMC_DEV_TIMING1_TRP_POS ) & TMVH_EFMC_DEV_TIMING1_TRP_MSK );
+  
+  TMVH_GEN_WRITE( regs, regVal );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadSingleData( tmUnitSelect_t efmcUnitID, pUInt16 pDataRead);
+*     This function reads a single 16-bit data from the relevant NAND flash device.
+*     Note: This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pDataRead -> pointer to the UInt16, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadSingleData(
+    tmUnitSelect_t                  efmcUnitID,
+    pUInt16                         pDataRead
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal    = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_SINGLE_READ_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal );
+  *pDataRead = (UInt16) (regVal & TMVH_EFMC_SINGLE_READ_DATA_MSK );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteSingleData( tmUnitSelect_t efmcUnitID, UInt16 dataWrite);
+*     This function writes a single 16-bit data to the relevant NAND flash device.
+*     Note: This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] dataWrite -> data that needs to be written to the relevant NAND flash device.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteSingleData(
+    tmUnitSelect_t                  efmcUnitID,
+    UInt16                          dataWrite
+)
+{
+  UInt32              regs  = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_SINGLE_WRITE_OFFSET );
+  ;
+  TMVH_GEN_WRITE( regs, ( (UInt32) dataWrite & TMVH_EFMC_SINGLE_WRITE_DATA_MSK ) );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadBufData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataRead);
+*     This function reads 512 bytes of data from the EFMC buffer. If the NAND flash has a page size more than 512 bytes, then
+*     this API should be called number of times to get the whole page size and also memory location address should be provided
+*     appropriately.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. The pointer provided should have the memory space of 512 bytes.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number from which the data to be read
+*     \param[out] pDataRead -> pointer to the memory location, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadBufData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum ATTRIBUTE_UNUSED,
+    pVoid                           pDataRead
+)
+{
+  pUInt8   pSrc   = (pUInt8) 0 ;
+  pUInt8   pTgt   = (pUInt8) 0 ;
+  UInt32   ctr    = TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE ;
+  UInt32   i      = 0 ;
+
+  /* source - AHB memory buffer */
+  /* target - user buffer */
+  pSrc = ( pUInt8 ) TMHW_EFMC_GET_AHB_ADDRESS( efmcUnitID ) ;
+  pTgt = ( pUInt8 ) pDataRead ;
+
+  /* regardless of data width, just copy the data present in source buffer to target buffer */
+  while( ctr > 0 )
+  {
+    pTgt[i] = pSrc[i] ;
+    i++;
+    ctr--;
+  }
+
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_ReadOobData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataRead);
+*     This function reads OOB data of the corresponding page of NAND nand flash device.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. This API must be called only after the whole PAGE data is read from the buffer by calling tmhwEfmc_ReadBufData function.
+*     3. The pointer provided should have the memory space for the OOB data whose size depends upon the PAGE size of the given NAND flash device.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number from which the data to be read
+*     \param[out] pDataRead -> pointer to the memory location, where the data read from the NAND flash device needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_ReadOobData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    pVoid                           pDataRead
+)
+{
+  pUInt8   pSrc   = (pUInt8) 0 ;
+  pUInt8   pTgt   = (pUInt8) 0 ;
+  UInt32   ctr    = 0 ;
+  UInt32   i      = 0 ;
+  UInt32   regs   = 0 ;
+  UInt32   regVal = 0 ;
+
+  regs =  (UInt32) (TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+  TMVH_GEN_READ( regs, regVal ) ;
+
+  regVal = ( ( regVal & TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK ) >> TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_POS );
+  switch( regVal )
+  {
+    case 0x00 :
+      {
+        ctr = ( 16 ) ; /* page size = 512 bytes */
+        break;
+      }
+    case 0x01 :
+      {
+        ctr = ( 64 ) ; /* page size = 2048 bytes */
+        break;
+      }
+    case 0x02 :
+      {
+        ctr = ( 128 ) ; /* page size = 4096 bytes */
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  /* source - AHB memory buffer */
+  /* target - user buffer */
+  pSrc = ( pUInt8 ) ( TMHW_EFMC_GET_AHB_ADDRESS( efmcUnitID) ) ;
+  pSrc = &pSrc[TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE];
+  pTgt = ( pUInt8 ) pDataRead ;
+
+  /* regardless of data width, just copy the data present in source buffer to target buffer */
+  while( ctr > 0 )
+  {
+    pTgt[i] = pSrc[i] ;
+    i++;
+    ctr--;
+  }
+
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteBufData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataWrite);
+*     This function writes 512 bytes of data from the EFMC buffer. If the NAND flash has a page size more than 512 bytes, then
+*     this API should be called number of times to write the whole page size and also memory location address should be provided
+*     appropriately.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. The pointer provided should have the memory space of 512 bytes.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number to which the data needs to be written.
+*     \param[out] pDataWrite -> pointer to the memory location, from where the data is read and is written onto the NAND flash.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteBufData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t         deviceNum ATTRIBUTE_UNUSED,
+    pVoid                           pDataWrite
+)
+{
+  pUInt8   pSrc   = (pUInt8) 0 ;
+  pUInt8   pTgt   = (pUInt8) 0 ;
+  UInt32   ctr    = TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE ;
+  UInt32   i      = 0 ;
+
+  /* source - user buffer */
+  /* target - AHB memory buffer */
+
+  pSrc = ( pUInt8 ) pDataWrite ;
+  pTgt = ( pUInt8 ) ( TMHW_EFMC_GET_AHB_ADDRESS( efmcUnitID) ) ;
+
+  /* regardless of data width, just copy the data present in source buffer to target buffer */
+  while( ctr > 0 )
+  {
+    pTgt[i] = pSrc[i] ;
+    i++;
+    ctr--;
+  }
+
+  return TM_OK;
+}
+
+
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_WriteOobData( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, pVoid pDataWrite);
+*     This function writes OOB data to the NAND flash page.
+*     Note: 1. This function should be called after proper command/address cycle is issued to the NAND flash device by calling tmhwEfmc_WriteCmdAddr function.
+*     2. This API must be called only after the whole page data is written onto the NAND flash device by tmhwEfmc_WriteBufData function.
+*     3. The pointer provided should have the memory space for the OOB data whose size depends upon the PAGE size of the given NAND flash device.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> NAND Flash device number to which the OOB data needs to be written.
+*     \param[out] pDataWrite -> pointer to the memory location, from where the OOB data is read and is written onto the NAND flash.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_WriteOobData(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t         deviceNum,
+    pVoid                           pDataWrite
+)
+{
+  pUInt8   pSrc   = (pUInt8) 0 ;
+  pUInt8   pTgt   = (pUInt8) 0 ;
+  UInt32   ctr    = 0 ;
+  UInt32   i      = 0 ;
+  UInt32   regs   = 0 ;
+  UInt32   regVal = 0 ;
+
+  regs =  (UInt32) (TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+  TMVH_GEN_READ( regs, regVal ) ;
+
+  regVal = ( ( regVal & TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK ) >> TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_POS );
+  switch( regVal )
+  {
+    case 0x00 :
+      {
+        ctr = ( 16 ) ; /* page size = 512 bytes */
+        break;
+      }
+    case 0x01 :
+      {
+        ctr = ( 64 ) ; /* page size = 2048 bytes */
+        break;
+      }
+    case 0x02 :
+      {
+        ctr = ( 128 ) ; /* page size = 4096 bytes */
+        break;
+      }
+    default:
+      {
+        break;
+      }
+  }
+
+  /* source - user buffer */
+  /* target - AHB memory buffer */
+  pSrc = ( pUInt8 ) pDataWrite ;
+  pTgt = ( pUInt8 ) ( TMHW_EFMC_GET_AHB_ADDRESS( efmcUnitID) ) ;
+  pTgt = &pTgt[TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE];
+
+  /* regardless of data width, just copy the data present in source buffer to target buffer */
+  while( ctr > 0 )
+  {
+    pTgt[i] = pSrc[i] ;
+    i++;
+    ctr--;
+  }
+
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetBusyStatus( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, ptmhwEfmc_ReadBusySignal_t pBusyStatus);
+*     This function gets the status of the given flash device connected to the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number
+*     \param[out] pBusyStatus -> pointer to the tmhwEfmc_ReadBusySignal_t structure that contains the status of NAND flash device ready/busy signal.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetBusyStatus(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    ptmhwEfmc_ReadBusySignal_t  pBusyStatus
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal     = 0 ;
+  UInt32                         regMsk    = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_NAND_STATUS_OFFSET );
+
+  /* get the mask for the register */
+  regMsk = (UInt32) ( 0x01U << ( deviceNum & TMVH_EFMC_MOD_CONFIG_NUM_DEV_MSK ));
+
+  /* read the data present in module ID register */
+  TMVH_GEN_READ( regs, regVal ) ;
+
+  
+  pBusyStatus->rbEdge_Rise = TM_FALSE ;
+  pBusyStatus->rbEdge_Fall = TM_FALSE ;
+  pBusyStatus->rbEdge_Status_Ready = TM_FALSE ;
+
+  if( 0x00 != ( regVal & regMsk ) )
+  {
+    pBusyStatus->rbEdge_Status_Ready = TM_TRUE ;
+  }
+
+  if( 0x00 != ( regVal & ( regMsk << TMVH_EFMC_NAND_STATUS_RBN_FALL_POS ) ) )
+  {
+    pBusyStatus->rbEdge_Fall = TM_TRUE ;
+  }
+
+  if( 0x00 != ( regVal & ( regMsk << TMVH_EFMC_NAND_STATUS_RBN_RISE_POS )) )
+  {
+    pBusyStatus->rbEdge_Rise = TM_TRUE ;
+  }
+
+  return TM_OK;
+}
+
+
+#if (TMFL_EFMCSD_DMA || TMFL_SD_ALL)
+/*! \addtogroup DmaSupport
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetDmaConfig( tmUnitSelect_t efmcUnitID, const tmhwEfmc_DmaConfig_t * pDmaConfig);
+*     This function will setup the DMA configuration for the data transfer to/from NAND flash devices connected the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pDmaConfig -> pointer to the tmhwEfmc_DmaConfig_t structure that contains the DMA configuration for the data transfer to/from the NAND flash devices.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetDmaConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_DmaConfig_t *       pDmaConfig
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal   = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DMA_CTRL_OFFSET );
+  
+  if( tmhwEfmc_Enable == pDmaConfig->enableM2PDma )
+  {
+    regVal |= TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK;
+  }
+  if( tmhwEfmc_Enable == pDmaConfig->enableP2MDma )
+  {
+    regVal |= TMVH_EFMC_DMA_CTRL_DMA_2_MEM_MSK;
+  }
+  
+  TMVH_GEN_WRITE( regs, regVal );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetDmaConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_DmaConfig_t pDmaConfig);
+*     This function will retrieve the DMA configuration that is used for the data transfer to/from NAND flash devices connected the EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pDmaConfig -> pointer to the tmhwEfmc_DmaConfig_t structure where in the read DMA configuration to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetDmaConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_DmaConfig_t       pDmaConfig
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal   = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DMA_CTRL_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal );
+  
+  pDmaConfig->enableP2MDma = ( tmhwEfmc_EnableDisable_t ) ( regVal & TMVH_EFMC_DMA_CTRL_DMA_2_MEM_MSK );
+  if( TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK == ( regVal & TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK )  )
+  {
+    pDmaConfig->enableM2PDma = tmhwEfmc_Enable;
+  }
+  else
+  {
+    pDmaConfig->enableM2PDma = tmhwEfmc_Disable;
+  }
+  return TM_OK;
+}
+
+
+/*! \} */ /* end of DmaSupport */
+
+#endif
+
+
+#if (TMFL_EFMCSD_AES || TMFL_SD_ALL)
+/*! \addtogroup AESSupport
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetAESConfig( tmUnitSelect_t efmcUnitID, const tmhwEfmc_AESConfig_t * pAESConfig);
+*     This function will setup the AES configuration required for AES IP.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pAESConfig -> pointer to the tmhwEfmc_AESConfig_t structure that contains the AES configuration data to be sent to the AES IP.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetAESConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_AESConfig_t *       pAESConfig
+)
+{
+  UInt32              regs  = 0 ;
+  
+  /* write into the AES Key registers */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY1_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->keyAES[0]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY2_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->keyAES[1]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY3_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->keyAES[2]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY4_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->keyAES[3]);
+  
+  /* write into the AES Initial Value registers */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV1_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->initAES[0]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV2_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->initAES[1]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV3_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->initAES[2]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV4_OFFSET );
+  TMVH_GEN_WRITE( regs, pAESConfig->initAES[3]);
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAESConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_AESConfig_t pAESConfig);
+*     This function will retrieve the AES configuration set in the AES IP.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pAESConfig -> pointer to the tmhwEfmc_AESConfig_t structure where in the configuration data read from AES IP needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAESConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_AESConfig_t       pAESConfig
+)
+{
+  UInt32              regs  = 0 ;
+  
+  /* read from the registers and assign it into the structures members */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY1_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->keyAES[0]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY2_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->keyAES[1]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY3_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->keyAES[2]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_KEY4_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->keyAES[3]);
+  
+  /* write into the AES Initial Value registers */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV1_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->initAES[0]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV2_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->initAES[1]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV3_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->initAES[2]);
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_IV4_OFFSET );
+  TMVH_GEN_READ( regs, pAESConfig->initAES[3]);
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAESStatus( tmUnitSelect_t efmcUnitID, ptmhwEfmc_AESStatus_t pAESStatus);
+*     This function will retrieve the status of AES IP whether it is busy or idle.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pAESStatus -> pointer to the tmhwEfmc_AESStatus_t enum where in the status of AES IP needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAESStatus(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_AESStatus_t       pAESStatus
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal         = 0 ;
+  
+  /* read from the registers and assign it into the structures members */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AES_STATUS_OFFSET );
+  TMVH_GEN_READ( regs, regVal);
+  *pAESStatus = ( tmhwEfmc_AESStatus_t ) ( regVal & ( TMVH_EFMC_AES_STATUS_ACCEPT_KEY_MSK | TMVH_EFMC_AES_STATUS_ACCEPT_IN_MSK ) );
+  
+  return TM_OK;
+}
+
+
+/*! \} */ /* end of AESSupport */
+
+#endif
+
+
+
+#if (TMFL_EFMCSD_POWER || TMFL_SD_ALL)
+
+/** \addtogroup PowerState
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetPowerState (tmUnitSelect_t  efmcUnitID, tmPowerState_t  powerState);
+*     Function will set the EFMC Device to a specified power state. Only D0 (Device Powered on) and D3 (Device Powered off) state are valid.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] powerState -> Power state to which EFMC device needs to be set. Only D0 (Device Powered On) and D3 (Device Powered Off) states are valid.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetPowerState (
+    tmUnitSelect_t                 efmcUnitID,
+    tmPowerState_t                 powerState
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_POWER_DOWN_OFFSET );
+  
+  /* read the register and modify the timeout value */
+  TMVH_GEN_READ( regs, regVal ) ;
+  regVal &= (UInt32) ~( (UInt32)TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK ) ;
+  /* valid values are : tmPowerOff and tmPowerOn */
+  if( tmPowerOff == powerState )
+  {
+    regVal |= TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK ;
+  }
+  
+  TMVH_GEN_WRITE( regs, regVal );
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetPowerState (tmUnitSelect_t  efmcUnitID, ptmPowerState_t  pPowerState);
+*     This function gets the present Power state of the Device.
+*
+*    \param[in] efmcUnitID -> EFMC Unit Number
+*    \param[out] pPowerState -> Pointer to tmPowerState_t typedefinition.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetPowerState (
+    tmUnitSelect_t                  efmcUnitID,
+    ptmPowerState_t                 pPowerState
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_POWER_DOWN_OFFSET );
+  
+  /* read the register and modify the timeout value */
+  TMVH_GEN_READ( regs, regVal ) ;
+  if( ( regVal & TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK ) == TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK )
+  {
+    *pPowerState = tmPowerOff;
+  }
+  else
+  {
+    *pPowerState = tmPowerOn;
+  }
+  return TM_OK;
+}
+
+/*! \} */ /* end of PowerState */
+
+#endif
+
+
+
+#if (TMFL_EFMCSD_INT || TMFL_SD_ALL)
+
+/** \addtogroup InterruptSupport
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntEnable(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntEnable);
+*    This function will enable the relevant interrupts defined by the given interrupt mask value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntEnable -> Interrupt enable mask bits for which relevant interrupts to be enabled.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntEnable(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntEnable
+)
+{
+  UInt32              regs = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_INT_SET_ENABLE_OFFSET );
+  
+  /* write the value directly */
+  TMVH_GEN_WRITE( regs, ( efmIntEnable & TMVH_EFMC_INT_MSK ) );
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntDisable(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntDisable);
+*    This function will disable the relevant interrupts defined by the given interrupt mask value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntDisable -> Interrupt disable mask bits for which relevant interrupts to be disabled.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntDisable(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntDisable
+)
+{
+  UInt32              regs = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_INT_CLR_ENABLE_OFFSET );
+  
+  /* write the value directly */
+  TMVH_GEN_WRITE( regs, ( efmIntDisable & TMVH_EFMC_INT_MSK ) );
+  
+  return TM_OK;
+}
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntGetStatus(tmUnitSelect_t  efmcUnitID, ptmhwEfmc_IntMask_t pEfmIntGetStatus);
+*    This function will get the current interrupts status.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pEfmIntGetStatus -> Pointer to tmhwEfmc_IntMask_t where in read interrupt status needs to be stored.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntGetStatus(
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_IntMask_t        pEfmIntGetStatus
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal           = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_INT_STATUS_OFFSET );
+  
+  /* write the value directly */
+  TMVH_GEN_READ( regs, regVal ) ;
+  *pEfmIntGetStatus = ( tmhwEfmc_IntMask_t ) ( regVal & TMVH_EFMC_INT_MSK ) ;
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_IntClear(tmUnitSelect_t  efmcUnitID, tmhwEfmc_IntMask_t efmIntClear);
+*    This function will clear the relevent interrupts status. The given maks will provide which interrupt status to be cleared.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] efmIntClear -> Interrupt mask for which the relevent interrupts status to be cleared.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_IntClear(
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_IntMask_t         efmIntClear
+)
+{
+  UInt32              regs = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_INT_CLR_STATUS_OFFSET );
+  
+  /* write the value directly */
+  TMVH_GEN_WRITE( regs, ( efmIntClear & TMVH_EFMC_INT_MSK ) ) ;
+  
+  return TM_OK;
+}
+
+
+/*! \} */ /* end of InterruptSupport */
+
+#endif
+
+
+
+
+
+#if (TMFL_EFMCSD_EBI || TMFL_SD_ALL)
+/*! \addtogroup EBIBackOffMode
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetBackoffConfig ( tmUnitSelect_t efmcUnitID, const tmhwEfmc_BackoffConfig_t * pBackOffConfig );
+*     This function configures the EBI pin sharing (backoff mode) for the EFMC. The details include hte timeout for
+*     backoff, mode of backoff. This function acts on the whole EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pBackConfig -> pointer to the tmhwEfmc_BackoffConfig_t structure that contians the backoff config parameters.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetBackoffConfig (
+    tmUnitSelect_t                  efmcUnitID,
+    const tmhwEfmc_BackoffConfig_t *   pBackOffConfig
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_EBI_CTRL_OFFSET );
+  
+  /* write the data to EBI register directly */
+  regVal = pBackOffConfig->defaultReqEnable ;
+  regVal |= (UInt32) (pBackOffConfig->mode & TMVH_EFMC_EBI_CTRL_MODE_MSK );
+  regVal |= (UInt32)  ( ((UInt32)pBackOffConfig->timeOut << TMVH_EFMC_EBI_CTRL_TIMEOUT_POS ) & TMVH_EFMC_EBI_CTRL_TIMEOUT_MSK ) ;
+  TMVH_GEN_WRITE( regs, regVal ) ;
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetBackoffConfig ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_BackoffConfig_t pBackOffConfig );
+*     This function retrieves the confiuration of the EBI pin sharing (backoff mode) for the EFMC. The details include hte
+*     timeout for backoff, mode of backoff. This function acts on the whole EFMC.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] pBackOffConfig -> pointer to the tmhwEfmc_BackoffConfig_t structure where retrieved information to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetBackoffConfig (
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_BackoffConfig_t   pBackOffConfig
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( (UInt32)  TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_EBI_CTRL_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal ) ;
+  pBackOffConfig->defaultReqEnable = ( tmhwEfmc_EnableDisable_t ) ( regVal & TMVH_EFMC_EBI_CTRL_DEF_REQ_MSK ) ;
+  pBackOffConfig->mode = ( tmhwEfmc_BackoffMode_t ) ( regVal & TMVH_EFMC_EBI_CTRL_MODE_MSK );
+  pBackOffConfig->timeOut = ( UInt8 ) ( ( regVal & TMVH_EFMC_EBI_CTRL_TIMEOUT_MSK ) >> TMVH_EFMC_EBI_CTRL_TIMEOUT_POS ) ;
+  return TM_OK;
+}
+
+
+
+/*! \} */ /* end of EBIBackOffMode */
+
+#endif
+
+
+
+
+
+#if (TMFL_EFMCSD_AHB || TMFL_SD_ALL)
+/*! \addtogroup AHBConfig
+ *  \{
+ */
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetAhbConfig( tmUnitSelect_t efmcUnitID,tmhwEfmc_SelRegistering_t   commandRegistering, tmhwEfmc_SelRegistering_t   rdDataRegistering);
+*     This function sets the AHB configuration for the command and read-data registering.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] commandRegistering -> AXI/AHB command registering
+*     \param[in] rdDataRegistering -> AXI/AHB read-data registering
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SetAhbConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_SelRegistering_t   commandRegistering,
+    tmhwEfmc_SelRegistering_t   rdDataRegistering
+)
+
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( (UInt32)  TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AHB_LATENCY_OFFSET );
+  
+  /* write the data to EBI register directly */
+  if( tmhwEfmc_Registered == commandRegistering )
+  {
+    regVal |= TMVH_EFMC_AHB_LATENCY_CMD_MSK ;
+  }
+  regVal |= (UInt32) ( rdDataRegistering );
+  
+  TMVH_GEN_WRITE( regs, regVal ) ;
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetAhbConfig( tmUnitSelect_t efmcUnitID, ptmhwEfmc_SelRegistering_t   pCommandRegistering, ptmhwEfmc_SelRegistering_t   pRdDataRegistering);
+*     This function gets the AHB configuration for the command and read-data registering.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[out] pCommandRegistering -> AXI/AHB command registering configuration to be stored
+*     \param[out] pRdDataRegistering -> AXI/AHB read-data registering configuration to be stored
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetAhbConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    ptmhwEfmc_SelRegistering_t  pCommandRegistering,
+    ptmhwEfmc_SelRegistering_t  pRdDataRegistering
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_AHB_LATENCY_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal );
+  
+  *pCommandRegistering = ( tmhwEfmc_SelRegistering_t ) ( ( regVal & TMVH_EFMC_AHB_LATENCY_CMD_MSK ) >> TMVH_EFMC_AHB_LATENCY_CMD_POS ) ;
+  *pRdDataRegistering = ( tmhwEfmc_SelRegistering_t ) ( ( regVal & TMVH_EFMC_AHB_LATENCY_RD_DATA_MSK ) );
+  
+  return TM_OK;
+}
+
+
+/*! \} */ /* addtogroup AHBConfig */
+
+#endif
+
+
+
+
+#if (TMFL_EFMCSD_APB || TMFL_SD_ALL)
+
+/** \addtogroup APBConfig
+*  \{
+*/
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbErrConfig ( tmUnitSelect_t efmcUnitID, tmhwEfmc_EnableDisable_t enableWrErr, tmhwEfmc_EnableDisable_t enableRdErr);
+*     This function will configure the APB error generation. Please note that this function should be called only
+*     when the IP is capable of programming the APB error generation. Call tmhwEfmc_GetCapabilities() function
+*     to get the capability of APB error generation in pCaps->progApbErrConfig. The application should call this function only
+*     if pCaps->progApbErrConfig == tmhwEfmc_Programmable.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] enableWrErr -> Enabling of APB write error generation
+*    \param[in] enableRdErr -> Enabling of APB read error generation
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbErrConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_EnableDisable_t   enableWrErr,
+    tmhwEfmc_EnableDisable_t   enableRdErr
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_APB_ERROR_GEN_OFFSET );
+  
+  if( tmhwEfmc_Enable == enableWrErr )
+  {
+    regVal |= TMVH_EFMC_APB_ERROR_GEN_WR_MSK ;
+  }
+  regVal |= (UInt32) enableRdErr;
+  
+  TMVH_GEN_WRITE( regs, regVal );
+  
+  return TM_OK;
+}
+
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbErrConfig ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_EnableDisable_t pEnableWrErr, ptmhwEfmc_EnableDisable_t pEnableRdErr);
+*     This function will get the APB error generation status
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pEnableWrErr -> APB write error generation status
+*    \param[in] pEnableRdErr -> APB read error generation status
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbErrConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_EnableDisable_t  pEnableWrErr,
+    ptmhwEfmc_EnableDisable_t  pEnableRdErr
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal  = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_APB_ERROR_GEN_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal );
+  
+  *pEnableWrErr = ( tmhwEfmc_EnableDisable_t) ( (regVal & TMVH_EFMC_APB_ERROR_GEN_WR_MSK) >> TMVH_EFMC_APB_ERROR_GEN_WR_POS );
+  *pEnableRdErr = ( tmhwEfmc_EnableDisable_t ) (regVal & TMVH_EFMC_APB_ERROR_GEN_RD_MSK) ;
+  
+  return TM_OK;
+}
+
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbTimeoutConfig ( tmUnitSelect_t efmcUnitID, UInt16 timeout);
+*     This function will configure the APB operation timeout.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] timeout -> APB operation timeout value. Range : 0x00 - 0xFFFF. If 0x00 represent, timeout is disabled, else timeout value is n APB cycles.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbTimeoutConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    UInt16                         timeout
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_POWER_DOWN_OFFSET );
+  
+  /* read the register and modify the timeout value */
+  TMVH_GEN_READ( regs, regVal ) ;
+  regVal &= TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK;
+  regVal |= (UInt32) ( ( timeout << TMVH_EFMC_POWER_DOWN_TIMEOUT_POS ) & TMVH_EFMC_POWER_DOWN_TIMEOUT_MSK );
+  
+  TMVH_GEN_WRITE( regs, regVal ) ;
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbTimeoutConfig ( tmUnitSelect_t efmcUnitID, pUInt16 ptimeout);
+*     This function will get the APB operation timeout value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pTimeout -> APB operation timeout value.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbTimeoutConfig (
+    tmUnitSelect_t                 efmcUnitID,
+    pUInt16                        pTimeout
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_POWER_DOWN_OFFSET );
+  
+  /* read the register and modify the timeout value */
+  TMVH_GEN_READ( regs, regVal ) ;
+  *pTimeout = ( UInt16 ) ( ( regVal & TMVH_EFMC_POWER_DOWN_TIMEOUT_MSK ) >> TMVH_EFMC_POWER_DOWN_TIMEOUT_POS );
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_SetApbLatency ( tmUnitSelect_t efmcUnitID, tmhwEfmc_Apb_Latency_t insertWait);
+*     This function will configure the APB read/write latency. Please note that this function should be called only
+*     when the IP is capable of programming the APB error generation. Call tmhwEfmc_GetCapabilities() function
+*     to get the capability of APB error generation in pCaps->progApbLatency. The application should call this function only
+*     if pCaps->progApbLatency == tmhwEfmc_Programmable.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] insertWait -> APB read/write latency value
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_SetApbLatency (
+    tmUnitSelect_t                 efmcUnitID,
+    tmhwEfmc_Apb_Latency_t     insertWait
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal         = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_APB_LATENCY_OFFSET );
+  
+  regVal = insertWait;
+  
+  TMVH_GEN_WRITE( regs, regVal ) ;
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetApbLatency ( tmUnitSelect_t efmcUnitID, ptmhwEfmc_Apb_Latency_t pInsertWait);
+*     This function will get the APB read/write latency value.
+*
+*    \param[in] efmcUnitID -> EFMC Unit number
+*    \param[in] pInsertWait -> APB read/write latency value that to be stored in the location pointed by this variable.
+*    \return TM_OK - Successfull.
+*/
+tmErrorCode_t
+tmhwEfmc_GetApbLatency (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_Apb_Latency_t    pInsertWait
+)
+{
+  UInt32              regs = 0 ;
+  UInt32                         regVal        = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_APB_LATENCY_OFFSET );
+  
+  TMVH_GEN_READ( regs, regVal ) ;
+  *pInsertWait = ( tmhwEfmc_Apb_Latency_t) ( regVal & TMVH_EFMC_APB_LATENCY_WS_MSK );
+  
+  return TM_OK;
+}
+
+
+/*! \} */ /* end of APBConfig */
+
+#endif
+
+
+#if (TMFL_EFMCSD_OTHERS || TMFL_SD_ALL)
+
+/** \addtogroup Others
+*  \{
+*/
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetSWVersion (ptmSWVersion_t  pEfmVersionInfo);
+*     This function gets the Software version of the HwAPI.Function can be called used by the
+*     application to know whether correct version of the software is used.
+*
+*    \param[out] pEfmVersionInfo -> pointer to tmSWVersion_t structure.
+*    \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetSWVersion (
+    ptmSWVersion_t                 pEfmVersionInfo
+)
+{
+  pEfmVersionInfo->compatibilityNr = TMHW_EFMC_COMPATIBILITY_NR;
+  pEfmVersionInfo->majorVersionNr  = TMHW_EFMC_MAJOR_VERSION_NR;
+  pEfmVersionInfo->minorVersionNr  = TMHW_EFMC_MINOR_VERSION_NR;
+  return TM_OK;
+}
+
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_Deinit(tmUnitSelect_t  efmcUnitID);
+*     This function will deinitialize the EFMC device. This function serves no purpose.
+*
+*    \param[in] efmcUnitID -> EFMC unit number.
+*    \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_Deinit(
+    tmUnitSelect_t                 efmcUnitID ATTRIBUTE_UNUSED
+)
+{
+  /* This function does nothing.. */
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetCapabilities (tmUnitSelect_t  efmcUnitID, ptmhwEfmc_Capabilities_t  pCaps);
+*     This function gets capabilities of the EFMC Hardware device and the structure elements specifies whether the certain
+*     features of EFMC are configured in the EFMC IP or not.
+*
+*    \param[in] efmcUnitID -> EFMC unit Number.
+*    \param[out] pCaps -> Pointer to tmhwEfmc_Capabilities_t structure.
+*    \return TM_OK - Successful.
+*/
+tmErrorCode_t
+tmhwEfmc_GetCapabilities (
+    tmUnitSelect_t                 efmcUnitID,
+    ptmhwEfmc_Capabilities_t   pCaps
+)
+{
+  UInt32              regs   = 0 ;
+  UInt32                         regVal    = 0 ;
+  
+  regs = (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_MOD_CONFIG_OFFSET );
+  
+  /* read the data present in the config register */
+  TMVH_GEN_READ( regs, regVal ) ;
+
+  pCaps->progApbLatency =   tmhwEfmc_Configurable ;
+  pCaps->progApbErrConfig =   tmhwEfmc_Configurable ;
+  pCaps->dataBusLatency =   tmhwEfmc_Configurable ;
+  pCaps->supportAES = (Bool) TM_FALSE ;
+  pCaps->enEBIPinShare = (Bool) TM_FALSE ;
+  pCaps->bootFromNAND = (Bool) TM_FALSE ;
+  pCaps->localRstSync = (Bool) TM_FALSE ;
+  
+  if( 0x00 != ( regVal & TMVH_EFMC_MOD_CONFIG_APB_LAT_MSK ) )
+  {
+    pCaps->progApbLatency =   tmhwEfmc_Programmable ;
+  }
+  if( 0x00 != ( regVal & TMVH_EFMC_MOD_CONFIG_APB_ERR_MSK ) )
+  {
+    pCaps->progApbErrConfig =   tmhwEfmc_Programmable ;
+  }
+  if( 0x00 != ( regVal & TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_MSK ) )
+  {
+    pCaps->dataBusLatency =   tmhwEfmc_Programmable ;
+  }
+  
+  pCaps->busType = ( tmhwEfmc_DataBusType_t ) ( regVal & TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_MSK );
+  pCaps->maxDevices = ( UInt8 ) ( ( regVal & TMVH_EFMC_MOD_CONFIG_NUM_DEV_MSK ) + 1 );
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_MODID_OFFSET );
+  
+  /* read the data present in module ID register */
+  TMVH_GEN_READ( regs, regVal ) ;
+  
+  pCaps->efmcModuleId = (UInt16) ( ( regVal & TMVH_EFMC_MODID_MODID_MSK ) >> TMVH_EFMC_MODID_MODID_POS);
+  pCaps->efmcRevMajor = ( UInt8 ) (( regVal & TMVH_EFMC_MODID_MAJOR_VER_MSK ) >> TMVH_EFMC_MODID_MAJOR_VER_POS);
+  pCaps->efmcRevMinor = ( UInt8 ) (( regVal & TMVH_EFMC_MODID_MINOR_VER_MSK ) >> TMVH_EFMC_MODID_MINOR_VER_POS);
+  pCaps->efmcAperSize = ( UInt8 ) ( regVal & TMVH_EFMC_MODID_APERTURE_MSK ) ;
+  
+  return TM_OK;
+}
+
+
+/*!\fn tmErrorCode_t tmhwEfmc_GetFlashConfig( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, ptmhwEfmc_FlashConfig_t pFlashConfig);
+*     This function retrieves the given NAND flash device configuration. The configuration such as timing parameters, data width and page size and also for write-protect of NAND flash device is stored in the parameter.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \param[in] deviceNum -> Nand flash device number for which the configuration to be retrieved.
+*     \param[out] pFlashConfig -> pointer to the tmhwEfmc_FlashConfig_t structure where in the read configuration needs to be stored.
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_GetFlashConfig(
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_DeviceNumber_t                           deviceNum,
+    ptmhwEfmc_FlashConfig_t     pFlashConfig
+)
+{
+  UInt32              regs  = 0 ;
+  UInt32                         regVal    = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+  
+  TMVH_GEN_READ( regs, regVal );
+  if( ( regVal & TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK ) == 0 )
+  {
+    pFlashConfig->enableCENDontCare = tmhwEfmc_Disable;
+  }
+  else
+  {
+    pFlashConfig->enableCENDontCare = tmhwEfmc_Enable;
+  }
+  if( ( regVal & TMVH_EFMC_DEV_TYPE0_WP_MSK ) == 0 )
+  {
+    pFlashConfig->enableWrProtect = tmhwEfmc_Disable;
+  }
+  else
+  {
+    pFlashConfig->enableWrProtect = tmhwEfmc_Enable;
+  }
+  pFlashConfig->dataWidth = (tmhwEfmc_DataWidth_t) ( regVal & TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_MSK ) ;
+  pFlashConfig->pageSize = (tmhwEfmc_PageSize_t) ( regVal & TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK ) ;
+  
+  /* now read timing 0 parameters and assign appropriately */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING0_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TIMING0_DIFF ) );
+  TMVH_GEN_READ( regs, regVal );
+  
+  pFlashConfig->devTiming.tWaitForRdy = (UInt8) ( regVal & TMVH_EFMC_DEV_TIMING0_TRR_MSK );
+  if( 0x00 == pFlashConfig->devTiming.tWaitForRdy )
+  {
+    pFlashConfig->devTiming.tWaitForRdy = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  
+  /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
+  pFlashConfig->devTiming.tAleHold = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TALH_MSK ) >> TMVH_EFMC_DEV_TIMING0_TALH_POS );
+  if( 0x00 == pFlashConfig->devTiming.tAleHold )
+  {
+    pFlashConfig->devTiming.tAleHold = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  pFlashConfig->devTiming.tAleSetup = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TALS_MSK ) >> TMVH_EFMC_DEV_TIMING0_TALS_POS );
+  if( 0x00 == pFlashConfig->devTiming.tAleSetup )
+  {
+    pFlashConfig->devTiming.tAleSetup = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  pFlashConfig->devTiming.tCleHold = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TCLH_MSK ) >> TMVH_EFMC_DEV_TIMING0_TCLH_POS );
+  if( 0x00 == pFlashConfig->devTiming.tCleHold )
+  {
+    pFlashConfig->devTiming.tCleHold = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  pFlashConfig->devTiming.tCleSetup = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TCLS_MSK ) >> TMVH_EFMC_DEV_TIMING0_TCLS_POS );
+  if( 0x00 == pFlashConfig->devTiming.tCleSetup )
+  {
+    pFlashConfig->devTiming.tCleSetup = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  pFlashConfig->devTiming.tCenHold = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TCPH_MSK ) >> TMVH_EFMC_DEV_TIMING0_TCPH_POS );
+  if( 0x00 == pFlashConfig->devTiming.tCenHold )
+  {
+    pFlashConfig->devTiming.tCenHold = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  pFlashConfig->devTiming.tCenSetup = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING0_TCPS_MSK ) >> TMVH_EFMC_DEV_TIMING0_TCPS_POS );
+  if( 0x00 == pFlashConfig->devTiming.tCenSetup )
+  {
+    pFlashConfig->devTiming.tCenSetup = (UInt8) (TMVH_EFMC_DEV_TIMING0_MAX_CYCLES) ;
+  }
+  
+  /* configure the timing1 register */
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING1_OFFSET +
+                                   ( deviceNum * TMVH_EFMC_DEV_TIMING1_DIFF ) );
+  
+  TMVH_GEN_READ( regs, regVal );
+
+  pFlashConfig->devTiming.tRdDelay = (tmhwEfmc_RdyDelay_t) ( regVal & TMVH_EFMC_DEV_TIMING1_TDRD_MSK );
+  pFlashConfig->devTiming.tWaitForBusy = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING1_TWB_MSK ) >> TMVH_EFMC_DEV_TIMING1_TWB_POS );
+  
+  if( 0x00 == pFlashConfig->devTiming.tWaitForBusy )
+  {
+    pFlashConfig->devTiming.tWaitForBusy = TMVH_EFMC_DEV_TIMING1_TWB_MAX_CYCLES;
+  }
+  pFlashConfig->devTiming.tWenWidth = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING1_TWP_MSK ) >> TMVH_EFMC_DEV_TIMING1_TWP_POS );
+  if( 0x00 == pFlashConfig->devTiming.tWenWidth )
+  {
+    pFlashConfig->devTiming.tWenWidth = TMVH_EFMC_DEV_TIMING1_MAX_CYCLES;
+  }
+  pFlashConfig->devTiming.tWenHigh = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING1_TWH_MSK ) >> TMVH_EFMC_DEV_TIMING1_TWH_POS );
+  if( 0x00 == pFlashConfig->devTiming.tWenHigh )
+  {
+    pFlashConfig->devTiming.tWenHigh = TMVH_EFMC_DEV_TIMING1_MAX_CYCLES;
+  }
+  pFlashConfig->devTiming.tRenWidth = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING1_TRP_MSK ) >> TMVH_EFMC_DEV_TIMING1_TRP_POS );
+  if( 0x00 == pFlashConfig->devTiming.tRenWidth )
+  {
+    pFlashConfig->devTiming.tRenWidth = TMVH_EFMC_DEV_TIMING1_MAX_CYCLES;
+  }
+  pFlashConfig->devTiming.tRenHigh = (UInt8) ( ( regVal & TMVH_EFMC_DEV_TIMING1_TRH_MSK ));
+  if( 0x00 == pFlashConfig->devTiming.tRenHigh )
+  {
+    pFlashConfig->devTiming.tRenHigh = TMVH_EFMC_DEV_TIMING1_MAX_CYCLES;
+  }
+  return TM_OK;
+}
+
+/*!\fn tmErrorCode_t tmhwEfmc_SoftReset ( tmUnitSelect_t efmcUnitID);
+*     This function provides a soft reset to the EFMC unit.
+*     \param[in] efmcUnitID -> EFMC Unit Number
+*     \return TM_OK - Successful
+*/
+tmErrorCode_t
+tmhwEfmc_SoftReset (
+    tmUnitSelect_t                  efmcUnitID
+)
+{
+  UInt32              regs = 0 ;
+  
+  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_SWRESET_OFFSET );
+  
+  TMVH_GEN_WRITE( regs, TMVH_EFMC_SWRESET_SW_RESET_MSK );
+  return TM_OK;
+}
+
+
+
+/*! \} */ /* end of Others */
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h
--- linux-2.6.34.orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,445 @@
+/*
+ * Copyright(C) 2007
+ * NXP B.V.
+ * All rights reserved
+ *
+ * This  source code and any compilation or derivative thereof is the
+ * proprietary information of NXP B.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be exposed to or placed
+ * under an Open Source License of any type without the expressed
+ * written permission of NXP B.V.
+ */
+/*----------------------------------------------------------------------------*/
+/**
+ * FILENAME:     tmhwEfmc_Vhip.c
+ *
+ * DESCRIPTION:  Register description file (vHAL) for EFMC IP 2070
+ *
+ * DOCUMENT REF: DD, EFMC IP_2070 hardware Datasheet
+ *
+ * \REVISION HISTORY:
+ * \Version    Author                               Date                 Remarks
+ * \1.0      Mahadev Cholachagudda     2006-06-07           Draft
+ * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
+ *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ */
+/*----------------------------------------------------------------------------*/
+
+
+#ifndef TMHWEFMC_VHIP_H
+#define TMHWEFMC_VHIP_H
+
+/*----------------------------------------------------------------------------
+* Standard include files:
+*----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Project specific include files:
+*-----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+* Component specific include files:
+*-----------------------------------------------------------------------------*/
+
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* defined(__cplusplus) */
+
+
+/*-----------------------------------------------------------------------------
+* Typedefs and Macros
+*-----------------------------------------------------------------------------*/
+#ifndef TMVH_GEN_READ
+#define TMVH_GEN_READ(address,result) \
+        (result) = (*(volatile UInt32 *)(address))
+#endif
+
+#ifndef TMVH_GEN_WRITE
+#define TMVH_GEN_WRITE(address,value) (*((volatile UInt32 *)(address)) = (value))
+#endif
+
+/**---------------------------------------------------------------------------*/
+/**
+ * Register offsets from base address
+ */
+/**---------------------------------------------------------------------------*/
+#define TMVH_EFMC_CMD_ADDR_FIFO_OFFSET          (0x000) /**< EFMC Nand Flash Command / Address FIFO register */
+#define TMVH_EFMC_PAGE_RW_OFFSET                (0x004) /**< EFMC Nand Flash Page Read/Write register */
+#define TMVH_EFMC_NAND_STATUS_OFFSET            (0x008) /** Nand Flash Status registers */
+#define TMVH_EFMC_DMA_CTRL_OFFSET               (0x00C) /** DMA Control Register */
+#define TMVH_EFMC_EBI_CTRL_OFFSET               (0x010) /**<  EBI Pin-Sharing Control Register*/
+#define TMVH_EFMC_AHB_LATENCY_OFFSET            (0x014) /**< AX/AHB Latency Register */
+#define TMVH_EFMC_APB_LATENCY_OFFSET            (0x018) /**<  APB Latency Register*/
+#define TMVH_EFMC_APB_ERROR_GEN_OFFSET          (0x01C) /**<  APB Error Register */
+#define TMVH_EFMC_AES_KEY1_OFFSET               (0x020) /**< AES Key Register(1st 32bit) */
+#define TMVH_EFMC_AES_KEY2_OFFSET               (0x024) /**< AES Key Register(2nd 32bit) */
+#define TMVH_EFMC_AES_KEY3_OFFSET               (0x028) /**< AES Key Register (3rd 32bit) */
+#define TMVH_EFMC_AES_KEY4_OFFSET               (0x02C) /**< AES Key Register (4th 32bit) */
+#define TMVH_EFMC_AES_IV1_OFFSET                (0x030) /**<  AES Initial Value Register (1st 32bit)*/
+#define TMVH_EFMC_AES_IV2_OFFSET                (0x034) /**< AES Initial Value Register (2nd32bit) */
+#define TMVH_EFMC_AES_IV3_OFFSET                (0x038) /**< AES Initial Value Register (3rd 32bit) */
+#define TMVH_EFMC_AES_IV4_OFFSET                (0x03C) /**< AES Initial Value Register (4th 32bit) */
+#define TMVH_EFMC_AES_STATUS_OFFSET             (0x040) /**< AES Status Register */
+#define TMVH_EFMC_SINGLE_READ_OFFSET            (0x044) /**<  Nand Flash SInge Read Register*/
+#define TMVH_EFMC_SINGLE_WRITE_OFFSET           (0x048) /**< Nand Flash SInge Write Register */
+#define TMVH_EFMC_DEV_TYPE0_OFFSET              (0x04C) /**<  Nand Flash Device Type Register for CEn[n]*/
+#define TMVH_EFMC_DEV_TYPE0_DIFF                (0x00C) /**  */
+#define TMVH_EFMC_DEV_TIMING0_OFFSET            (0x050) /**<Nand Flash Device Timing Register #0 for CEn[n]  */
+#define TMVH_EFMC_DEV_TIMING0_DIFF              (0x00C) /**  */
+#define TMVH_EFMC_DEV_TIMING1_OFFSET            (0x054) /**< Nand Flash Device Timing Register #1 for CEn[n] */
+#define TMVH_EFMC_DEV_TIMING1_DIFF              (0x00C) /**  */
+#define TMVH_EFMC_MOD_CONFIG_OFFSET             (0xFD4) /**< Module Configuration Register */
+#define TMVH_EFMC_INT_CLR_ENABLE_OFFSET         (0xFD8) /** Interrupt Clear Enable Register */
+#define TMVH_EFMC_INT_SET_ENABLE_OFFSET         (0xFDC) /** Interrupt Set Enable Register */
+#define TMVH_EFMC_INT_STATUS_OFFSET             (0xFE0) /** Interrupt Status Register */
+#define TMVH_EFMC_INT_ENABLE_OFFSET             (0xFE4) /** Interrupt Enable Register */
+#define TMVH_EFMC_INT_CLR_STATUS_OFFSET         (0xFE8) /** Interrupt Clear Status Set Register */
+#define TMVH_EFMC_INT_SET_STATUS_OFFSET         (0xFEC) /** Interrupt Set Status Set Register */
+#define TMVH_EFMC_SWRESET_OFFSET                (0xFF0) /**< Software reset register */
+#define TMVH_EFMC_POWER_DOWN_OFFSET             (0xFF4) /**< Power down register */
+#define TMVH_EFMC_EXT_MODID_OFFSET              (0xFF8) /**< Dynamic memory write recovery time register */
+#define TMVH_EFMC_MODID_OFFSET                  (0xFFC) /**< Dynamic memory write recovery time register */
+
+
+#define TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE         (0x200)
+
+/**---------------------------------------------------------------------------*/
+/**
+ * Register details
+ */
+/**---------------------------------------------------------------------------*/
+
+/**
+ * CMD_ADDR_FIFO register
+ */
+#define TMVH_EFMC_CMD_ADDR_FIFO_CEN_MSK         (0x00180000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_CEN_POS         (19)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_LAST_CYCLE_MSK  (0x00040000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_LAST_CYCLE_POS  (18)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_CYCLE_TYPE_MSK  (0x00030000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_CYCLE_TYPE_POS  (16)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_IO_MSK          (0x0000FFFF)
+#define TMVH_EFMC_CMD_ADDR_FIFO_IO_POS          (0)
+
+
+/**
+ * PAGE_RW register
+ */
+#define TMVH_EFMC_PAGE_RW_OOB_MSK          (0x00000010)
+#define TMVH_EFMC_PAGE_RW_OOB_POS          (4)
+
+#define TMVH_EFMC_PAGE_RW_AES_MSK          (0x00000008)
+#define TMVH_EFMC_PAGE_RW_AES_POS          (3)
+
+#define TMVH_EFMC_PAGE_RW_ECC_MSK          (0x00000004)
+#define TMVH_EFMC_PAGE_RW_ECC_POS          (2)
+
+#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_MSK   (0x00000002)
+#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_POS   (1)
+
+#define TMVH_EFMC_PAGE_RW_READ_PAGE_MSK    (0x00000001)
+#define TMVH_EFMC_PAGE_RW_READ_PAGE_POS    (0)
+
+
+/**
+ * NAND_STATUS register
+ */
+#define TMVH_EFMC_NAND_STATUS_RBN_RISE_MSK (0x00000F00)
+#define TMVH_EFMC_NAND_STATUS_RBN_RISE_POS (8)
+
+#define TMVH_EFMC_NAND_STATUS_RBN_FALL_MSK (0x000000F0)
+#define TMVH_EFMC_NAND_STATUS_RBN_FALL_POS (4)
+
+#define TMVH_EFMC_NAND_STATUS_RBN_MSK      (0x0000000F)
+#define TMVH_EFMC_NAND_STATUS_RBN_POS      (0)
+
+
+/**
+ * DMA_CTRL register
+ */
+#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK   (0x00000002)
+#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_POS   (1)
+
+#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_MSK   (0x00000001)
+#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_POS   (0)
+
+
+/**
+ * EBI_CTRL register
+ */
+#define TMVH_EFMC_EBI_CTRL_TIMEOUT_MSK     (0x000003FC)
+#define TMVH_EFMC_EBI_CTRL_TIMEOUT_POS     (2)
+
+#define TMVH_EFMC_EBI_CTRL_MODE_MSK        (0x00000002)
+#define TMVH_EFMC_EBI_CTRL_MODE_POS        (1)
+
+#define TMVH_EFMC_EBI_CTRL_DEF_REQ_MSK     (0x00000001)
+#define TMVH_EFMC_EBI_CTRL_DEF_REQ_POS     (0)
+
+
+/**
+ * AHB_LATENCY register
+ */
+#define TMVH_EFMC_AHB_LATENCY_CMD_MSK      (0x00000002)
+#define TMVH_EFMC_AHB_LATENCY_CMD_POS      (1)
+
+#define TMVH_EFMC_AHB_LATENCY_RD_DATA_MSK  (0x00000001)
+#define TMVH_EFMC_AHB_LATENCY_RD_DATA_POS  (0)
+
+
+/**
+ * APB_LATENCY register
+ */
+#define TMVH_EFMC_APB_LATENCY_WS_MSK       (0x00000001)
+#define TMVH_EFMC_APB_LATENCY_WS_POS       (0)
+
+
+/**
+ * APB_ERROR_GEN register
+ */
+#define TMVH_EFMC_APB_ERROR_GEN_WR_MSK     (0x00000002)
+#define TMVH_EFMC_APB_ERROR_GEN_WR_POS     (1)
+
+#define TMVH_EFMC_APB_ERROR_GEN_RD_MSK     (0x00000001)
+#define TMVH_EFMC_APB_ERROR_GEN_RD_POS     (0)
+
+
+/**
+ * AES_KEY1 register
+ */
+#define TMVH_EFMC_AES_KEY1_AES_KEY_MSK     (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY1_AES_KEY_POS     (0)
+
+
+/**
+ * AES_KEY2 register
+ */
+#define TMVH_EFMC_AES_KEY2_AES_KEY_MSK     (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY2_AES_KEY_POS     (0)
+
+/**
+ * AES_KEY3 register
+ */
+#define TMVH_EFMC_AES_KEY3_AES_KEY_MSK     (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY3_AES_KEY_POS     (0)
+
+/**
+ * AES_KEY4 register
+ */
+#define TMVH_EFMC_AES_KEY4_AES_KEY_MSK     (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY4_AES_KEY_POS     (0)
+
+
+/**
+ * AES_IV1 register
+ */
+#define TMVH_EFMC_AES_IV1_AES_IV_MSK       (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV1_AES_IV_POS       (0)
+
+/**
+ * AES_IV2 register
+ */
+#define TMVH_EFMC_AES_IV2_AES_IV_MSK       (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV2_AES_IV_POS       (0)
+
+/**
+ * AES_IV3 register
+ */
+#define TMVH_EFMC_AES_IV3_AES_IV_MSK       (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV3_AES_IV_POS       (0)
+
+/**
+ * AES_IV4 register
+ */
+#define TMVH_EFMC_AES_IV4_AES_IV_MSK       (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV4_AES_IV_POS       (0)
+
+
+/**
+ * AES_STATUS register
+ */
+#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_MSK (0x00000002)
+#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_POS (1)
+
+#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_MSK (0x00000001)
+#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_POS (0)
+
+
+/**
+ * SINGLE_READ register
+ */
+#define TMVH_EFMC_SINGLE_READ_DATA_MSK    (0x0000FFFF)
+#define TMVH_EFMC_SINGLE_READ_DATA_POS    (0)
+
+/**
+ * SINGLE_WRITE register
+ */
+#define TMVH_EFMC_SINGLE_WRITE_DATA_MSK   (0x0000FFFF)
+#define TMVH_EFMC_SINGLE_WRITE_DATA_POS   (0)
+
+/**
+ * DEV_TYPE0 register
+ */
+#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK  (0x00000070)
+#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_POS  (4)
+
+#define TMVH_EFMC_DEV_TYPE0_WP_MSK         (0x00000008)
+#define TMVH_EFMC_DEV_TYPE0_WP_POS         (3)
+
+#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK   (0x00000004)
+#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_POS   (2)
+
+#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_MSK (0x00000003)
+#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_POS (0)
+
+
+/**
+ * DEV_TIMING0 register
+ */
+#define TMVH_EFMC_DEV_TIMING0_TCPS_MSK     (0x0F000000)
+#define TMVH_EFMC_DEV_TIMING0_TCPS_POS     (24)
+
+#define TMVH_EFMC_DEV_TIMING0_TCPH_MSK     (0x00F00000)
+#define TMVH_EFMC_DEV_TIMING0_TCPH_POS     (20)
+
+#define TMVH_EFMC_DEV_TIMING0_TCLS_MSK     (0x000F0000)
+#define TMVH_EFMC_DEV_TIMING0_TCLS_POS     (16)
+
+#define TMVH_EFMC_DEV_TIMING0_TCLH_MSK     (0x0000F000)
+#define TMVH_EFMC_DEV_TIMING0_TCLH_POS     (12)
+
+#define TMVH_EFMC_DEV_TIMING0_TALS_MSK     (0x00000F00)
+#define TMVH_EFMC_DEV_TIMING0_TALS_POS     (8)
+
+#define TMVH_EFMC_DEV_TIMING0_TALH_MSK     (0x000000F0)
+#define TMVH_EFMC_DEV_TIMING0_TALH_POS     (4)
+
+#define TMVH_EFMC_DEV_TIMING0_TRR_MSK      (0x0000000F)
+#define TMVH_EFMC_DEV_TIMING0_TRR_POS      (0)
+#define TMVH_EFMC_DEV_TIMING0_MAX_CYCLES   (16)
+
+
+/**
+ * DEV_TIMING1 register
+ */
+#define TMVH_EFMC_DEV_TIMING1_TDRD_MSK (0x03C00000)
+#define TMVH_EFMC_DEV_TIMING1_TDRD_POS (22)
+
+#define TMVH_EFMC_DEV_TIMING1_TWB_MSK  (0x003F0000)
+#define TMVH_EFMC_DEV_TIMING1_TWB_POS  (16)
+#define TMVH_EFMC_DEV_TIMING1_TWB_MAX_CYCLES (64)
+
+#define TMVH_EFMC_DEV_TIMING1_TWP_MSK  (0x0000F000)
+#define TMVH_EFMC_DEV_TIMING1_TWP_POS  (12)
+
+#define TMVH_EFMC_DEV_TIMING1_TWH_MSK  (0x00000F00)
+#define TMVH_EFMC_DEV_TIMING1_TWH_POS  (8)
+
+#define TMVH_EFMC_DEV_TIMING1_TRP_MSK  (0x000000F0)
+#define TMVH_EFMC_DEV_TIMING1_TRP_POS  (4)
+
+#define TMVH_EFMC_DEV_TIMING1_TRH_MSK  (0x0000000F)
+#define TMVH_EFMC_DEV_TIMING1_TRH_POS  (0)
+#define TMVH_EFMC_DEV_TIMING1_MAX_CYCLES   (16)
+
+
+/**
+ * MOD_CONFIG register
+ */
+
+#define TMVH_EFMC_MOD_CONFIG_APB_LAT_MSK          (0x00000400)
+#define TMVH_EFMC_MOD_CONFIG_APB_LAT_POS          (10)
+
+#define TMVH_EFMC_MOD_CONFIG_APB_ERR_MSK          (0x00000200)
+#define TMVH_EFMC_MOD_CONFIG_APB_ERR_POS          (9)
+
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_MSK    (0x00000180)
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_POS    (7)
+
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_MSK     (0x00000040)
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_POS     (6)
+
+#define TMVH_EFMC_MOD_CONFIG_AES_MSK              (0x00000020)
+#define TMVH_EFMC_MOD_CONFIG_AES_POS              (5)
+
+#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_MSK          (0x00000010)
+#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_POS          (4)
+
+#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_MSK        (0x00000008)
+#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_POS        (3)
+
+#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_MSK         (0x00000004)
+#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_POS         (2)
+
+#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_MSK          (0x00000003)
+#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_POS          (0)
+
+
+/**
+ * INT registers
+ */
+
+#define TMVH_EFMC_INT_MSK                      (0x00FFFFFF)
+#define TMVH_EFMC_INT_POS                      (0)
+
+
+/**
+ * SWRESET registers
+ */
+
+#define TMVH_EFMC_SWRESET_SW_RESET_MSK         (0x00000001)
+#define TMVH_EFMC_SWRESET_SW_RESET_POS         (0)
+
+
+/**
+ * POWER_DOWN registers
+ */
+
+#define TMVH_EFMC_POWER_DOWN_TIMEOUT_MSK       (0x0001FFFE)
+#define TMVH_EFMC_POWER_DOWN_TIMEOUT_POS       (1)
+
+#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK    (0x00000001)
+#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_POS    (0)
+
+
+/**
+ * MODID register
+ */
+#define TMVH_EFMC_MODID_MODID_MSK           (0xFFFF0000U)
+#define TMVH_EFMC_MODID_MODID_POS           (16)
+
+#define TMVH_EFMC_MODID_MAJOR_VER_MSK       (0x0000F000)
+#define TMVH_EFMC_MODID_MAJOR_VER_POS       (12)
+
+#define TMVH_EFMC_MODID_MINOR_VER_MSK       (0x00000F00)
+#define TMVH_EFMC_MODID_MINOR_VER_POS       (8)
+
+#define TMVH_EFMC_MODID_APERTURE_MSK        (0x000000FF)
+#define TMVH_EFMC_MODID_APERTURE_POS        (0)
+
+
+/**
+ * EXT_MODID register
+ */
+#define TMVH_EFMC_EXT_MODID_MODID_MSK           (0xFFFF0000U)
+#define TMVH_EFMC_EXT_MODID_MODID_POS           (16)
+
+#define TMVH_EFMC_EXT_MODID_MAJOR_VER_MSK       (0x0000F000)
+#define TMVH_EFMC_EXT_MODID_MAJOR_VER_POS       (12)
+
+#define TMVH_EFMC_EXT_MODID_MINOR_VER_MSK       (0x00000F00)
+#define TMVH_EFMC_EXT_MODID_MINOR_VER_POS       (8)
+
+#define TMVH_EFMC_EXT_MODID_APERTURE_MSK        (0x000000FF)
+#define TMVH_EFMC_EXT_MODID_APERTURE_POS        (0)
+
+#if defined(__cplusplus)
+}
+#endif /* defined(__cplusplus) */
+#endif /* TMHWEFMC_VHIP_H*/
diff -Naurp linux-2.6.34.orig/drivers/mtd/sfc/Kconfig linux-2.6.34/drivers/mtd/sfc/Kconfig
--- linux-2.6.34.orig/drivers/mtd/sfc/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/sfc/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,33 @@
+#SFC driver for PNX8400 Platforms
+
+menuconfig MTD_NX_SFC
+	tristate "SFC Device Support"
+	depends on MTD !=n
+  select MTD_PARTITIONS
+	help
+	  This enables support for accessing SFC flash
+	  devices on PNX8400  platforms.
+
+config MTD_NX_SFC_PREFETCH_EN
+	bool "PREFETCH Buffer support"
+	depends on MTD_NX_SFC
+	help
+	  This is enables the prefetch buffer in the SFC controller.
+		The controller supports 64 prefetch words.
+
+config MTD_NX_SFC_DMAC_EN
+	bool "DMA support"
+	depends on MTD_NX_SFC
+	help
+	  This is enables the A9 to access SFC through the AHB Master Interface.
+		GCS DMA driver is used to xfer the data to/from the SFC apperture in the GCS.
+
+config MTD_NX_SFC_QUAD_MODE
+        bool "QUAD Mode support"
+	depends on MTD_NX_SFC
+        help
+          This is enables the Quad Mode in the SFC controller.
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/sfc/Makefile linux-2.6.34/drivers/mtd/sfc/Makefile
--- linux-2.6.34.orig/drivers/mtd/sfc/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/sfc/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,7 @@
+#
+# linux/drivers/devices/Makefile
+#
+
+#obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
+#obj-y	+= sfc_dmac.o
+obj-$(CONFIG_MTD_NX_SFC)	+= nx_sfc.o
diff -Naurp linux-2.6.34.orig/drivers/mtd/sfc/nx_sfc.c linux-2.6.34/drivers/mtd/sfc/nx_sfc.c
--- linux-2.6.34.orig/drivers/mtd/sfc/nx_sfc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/sfc/nx_sfc.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1108 @@
+/*
+ * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
+ *
+ * Author: Mike Lavender, mike@steroidmicros.com
+ *
+ * Copyright (c) 2005, Intec Automation Inc.
+ *
+ * Some parts are based on lart.c by Abraham Van Der Merwe
+ *
+ * Cleaned up and generalized based on mtd_dataflash.c
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include "nx_sfc.h"
+
+#define FLASH_PAGESIZE		256
+
+/* Flash opcodes. */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+
+/* Status Register bits. */
+#define	SR_WIP			1	/* Write in progress */
+#define	SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define	SR_BP0			4	/* Block protect 0 */
+#define	SR_BP1			8	/* Block protect 1 */
+#define	SR_BP2			0x10	/* Block protect 2 */
+#define	SR_SRWD			0x80	/* SR write protect */
+
+/* Define max times to check status register before we give up. */
+#define	MAX_READY_WAIT_COUNT	100000
+#define	CMD_SIZE		4
+
+#ifdef CONFIG_M25PXX_USE_FAST_READ
+#define OPCODE_READ 	OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 1
+#else
+#define OPCODE_READ 	OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 0
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+#define	mtd_has_partitions()	(1)
+#else
+#define	mtd_has_partitions()	(0)
+#endif
+#define	mtd_has_partitions()	(1)
+struct cmd_data {
+   u8    command[2];
+   u32 offset;
+   u32 length;
+   u8 *buffer;
+};
+
+extern void nx_sfc_map_copy_to (unsigned long to, const void *from, ssize_t len);
+extern void nx_sfc_map_copy_from(void *to, unsigned long from, ssize_t len);
+extern int nx_sfc_dma_init(void);
+
+/****************************************************************************/
+
+struct nx_sfc_mtd {
+	//struct nx_sfc_device	*sfc;
+	struct platform_device	*sfc;
+	struct mutex		lock;
+	struct mtd_info		mtd;
+	unsigned		partitioned:1;
+	u8			erase_opcode;
+	struct cmd_data cd;
+   resource_size_t            mmio_start;
+   resource_size_t            mmio_len;
+   void __iomem               *mmio_base;
+};
+
+static inline struct nx_sfc_mtd *mtd_to_nx_sfc_mtd(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct nx_sfc_mtd, mtd);
+}
+
+/****************************************************************************/
+/* IP2070 GCS: SFC Routines                                                 */
+/****************************************************************************/
+
+ssize_t nx_sfc_prefetch_read(struct nx_sfc_mtd *flash) 
+{
+
+     volatile unsigned long * prefetch_buf_base;
+     volatile unsigned long prefetch_buf_store;
+     u32 count = 0, i =0;
+     u32 cpy_count = 4, round_len =0;
+     u8 * prefetch_buf_ptr = (u8*)&prefetch_buf_store;
+     u8 * buf_ptr = flash->cd.buffer;
+     
+
+   /* Program the protocol delay regsister */
+      writel(SFC_PROTCOL_DELAY_READ,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_REG);
+   
+   /* Program the CSR Register ------------*/
+      writel(SFC_CSR_READ, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+
+   /* Program the SPL CMD ADDR Register ------------*/
+      writel(flash->cd.offset, flash->mmio_base +0x7C);
+
+   /* Program the DATA COUNT Register in multiples of 4 bytes------------*/
+      round_len = flash->cd.length % 4;
+      if(round_len){
+	      round_len = flash->cd.length + (4 - round_len);
+	      writel(round_len,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+      }
+      else
+	      writel(flash->cd.length,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+     // writel(0x40,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   
+   /* Write the CMD to the DEV_CMD Register */
+      writel(SFC_DEV_CMD_READ,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+      nx_sfc_wait(flash->mmio_base);
+
+   /* Copy the data from the Prefetch Buffers------------------*/
+
+      prefetch_buf_base = ((volatile unsigned long *)(0xe063203c));
+      for (i = 0; i < 16; i ++){
+         prefetch_buf_store = readl(prefetch_buf_base);
+         prefetch_buf_base ++;
+         if (flash->cd.length < 4 )
+            cpy_count = flash->cd.length % 4;
+         memcpy(buf_ptr, prefetch_buf_ptr, cpy_count);
+         count += cpy_count;
+         buf_ptr += cpy_count;
+         if (count == flash->cd.length)
+            break;
+      }
+
+      return flash->cd.length;
+}
+
+ssize_t nx_sfc_prefetch_write(struct nx_sfc_mtd *flash) 
+{
+     volatile unsigned long * prefetch_buf_base;
+     volatile unsigned long prefetch_buf_store;
+     u32 count = 0, i =0;
+     u32 cpy_count = 4;
+     u8 * prefetch_buf_ptr = (u8*)&prefetch_buf_store;
+     u8 * buf_ptr = flash->cd.buffer;
+     
+
+   /* Program the protocol delay regsister */
+      writel(SFC_PROTOCL_DELAY_WRITE,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_REG);
+   
+   /* Program the CSR Register ------------*/
+      writel(SFC_CSR_WRITE, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+
+   /* Program the SPL CMD ADDR Register ------------*/
+      writel(flash->cd.offset, flash->mmio_base +0x7C);
+
+   /* Program the DATA COUNT Register ------------*/
+      writel(flash->cd.length << 12, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   
+   /* ----------Setup the Prefetch Buffers------------------*/
+
+      prefetch_buf_base = ((volatile unsigned long *)(0xe063203c));
+      for (i = 0; i < 16; i ++){
+
+         if (flash->cd.length < 4 )
+            cpy_count = flash->cd.length % 4;
+         memcpy(prefetch_buf_ptr, buf_ptr, cpy_count);
+         writel(prefetch_buf_store, prefetch_buf_base);
+         prefetch_buf_base ++;
+         count += cpy_count;
+         buf_ptr += cpy_count;
+         if (count == flash->cd.length)
+            break;
+      }
+      /* -------Write the CMD to the DEV_CMD Register---------- */
+      writel(SFC_DEV_CMD_WRITE,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+      nx_sfc_wait(flash->mmio_base);
+      return flash->cd.length;
+}
+
+#ifdef SFC_DMAC_ENABLE
+
+ssize_t nx_sfc_read(struct nx_sfc_mtd *flash) 
+{
+
+   /* Program the protocol delay regsister */
+      writel(0x10008000,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_REG);
+   
+   /* Program the CSR Register ------------*/
+      writel(0x0000167, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+
+   /* Program the DATA COUNT Register ------------*/
+      writel(flash->cd.length,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   
+   /* Write the CMD to the DEV_CMD Register */
+      writel(0x00000203,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+      nx_sfc_wait(flash->mmio_base);
+
+   /* Map the data buffer to a DMA bounce buffer */
+
+   /* Setup the DMA Xfer ------------------*/
+      nx_sfc_map_copy_from(flash->cd.buffer, flash->cd.offset, flash->cd.length);
+
+   /* Kick Start the DMA xfer and wait for the completion event */
+
+   
+}
+
+ssize_t nx_sfc_write(struct nx_sfc_mtd *flash) 
+{
+   /* Program the protocol delay regsister */
+      writel(0x10000000, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_REG);
+  
+   /* Program the CSR Register ------------*/
+      writel(0x03C20001, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+  
+   /* Program the DATA COUNT Register ------------*/
+      writel(flash->cd.length << 12 ,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+  
+   /* Write the CMD to the DEV_CMD Register */
+      writel(0x00840203 ,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+      nx_sfc_wait(flash->mmio_base);
+  
+   /* Map the data buffer to a DMA bounce buffer */
+  
+   /* Setup the DMA Xfer ------------------*/
+      nx_sfc_map_copy_to(flash->cd.offset, flash->cd.buffer, flash->cd.length);
+  
+   /* Kick Start the DMA xfer and wait for the completion event */
+}
+#endif
+
+ssize_t nx_sfc_erase(struct nx_sfc_mtd *flash) 
+{
+   /* Program the protocol delay regsister */
+    
+   
+   /* Program the CSR Register ------------*/
+   writel(SFC_CSR_ERASE,flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+
+   /* Program the SPL CMD ADDR Register ------------*/
+   writel(flash->cd.offset, flash->mmio_base +0x7C);
+   
+   /* Write the CMD to the DEV_CMD Register */
+   writel(SFC_DEV_CMD_ERASE, flash->mmio_base + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   nx_sfc_wait(flash->mmio_base);
+   return flash->cd.length;
+}
+
+void nx_sfc_write_en(void __iomem  * sfc_regs)
+{
+    
+   //Program the CSR register, enable prefetch, tx_en, tx_hold_en
+   writel(SFC_CSR_WREN, sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG);
+   // Do SPL CMD- "Write Enable" - 06h
+   writel(SFC_DEV_CMD_WREN,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   nx_sfc_wait(sfc_regs);
+}
+
+u32 nx_sfc_read_id(void __iomem * sfc_regs)
+{
+   u32 id;
+   writel(SFC_CSR_READ_ID, sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG); 
+   writel(0x4, sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   writel(SFC_DEV_CMD_ID, sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   nx_sfc_wait(sfc_regs);
+   id = readl(sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR0_DATA_REG);
+
+   return id;
+}
+
+u32 nx_sfc_read_sr(void __iomem * sfc_regs)
+{
+   u32 status;
+   writel(SFC_CSR_READ_STATUS, sfc_regs +IPBGCSFLSHNTWK_SFC_SFC_CSR_REG); 
+   writel(0x1,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   writel(SFC_DEV_CMD_READ_STATUS,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   nx_sfc_wait(sfc_regs);
+   status = readl(sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR0_DATA_REG);
+
+   return status;
+}
+
+void nx_sfc_write_sr(void __iomem * sfc_regs)
+{
+
+   writel(SFC_CSR_WRITE_STATUS,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_CSR_REG); 
+   writel(0x1,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG);
+   writel(SFC_DEV_CMD_WRITE_STATUS,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   nx_sfc_wait(sfc_regs);
+  
+   return;
+}
+
+void nx_sfc_wait(void __iomem * sfc_regs)
+{
+   volatile u32        status;
+   
+   // Wait for SPL CMD to complete
+   do
+   {
+      // Read SFC Status Register - Wait for SPL CMD to complete
+      status = readl(sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG);
+   }
+   while (status & 0x10000);
+}
+
+void nx_sfc_init(void __iomem * sfc_regs)
+{
+   writel(0x1,sfc_regs + IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_REG); 
+   return;
+}
+
+/*
+ * Internal helper functions
+ */
+
+/*
+ * Read the status register, returning its value in the location
+ * Return the status register value.
+ * Returns negative if error occurred.
+ */
+ 
+static int read_sr(struct nx_sfc_mtd *flash)
+{
+	ssize_t retval;
+	//u8 code = OPCODE_RDSR;
+	
+   retval = nx_sfc_read_sr(flash->mmio_base);
+
+	if (retval < 0) {
+		dev_err(&flash->sfc->dev, "error %d reading SR\n",
+				(int) retval);
+		return retval;
+	}
+  
+	return retval;
+}
+
+/*
+ * Write status register 1 byte
+ * Returns negative if error occurred.
+ */
+static int write_sr(struct nx_sfc_mtd *flash, u8 val)
+{
+	flash->cd.command[0] = OPCODE_WRSR;
+	flash->cd.command[1] = val;
+
+   nx_sfc_write_sr(flash->mmio_base);
+   return 0;
+}
+
+/*
+ * Set write enable latch with Write Enable command.
+ * Returns negative if error occurred.
+ */
+int write_enable(struct nx_sfc_mtd *flash)
+{
+	//u8	code = OPCODE_WREN;
+
+	nx_sfc_write_en(flash->mmio_base);
+   return 0;
+}
+
+
+/*
+ * Service routine to read status register until ready, or timeout occurs.
+ * Returns non-zero if error.
+ */
+int wait_till_ready(struct nx_sfc_mtd *flash)
+{
+	int count;
+	int sr;
+
+	/* one chip guarantees max 5 msec wait here after page writes,
+	 * but potentially three seconds (!) after page erase.
+	 */
+	for (count = 0; count < MAX_READY_WAIT_COUNT; count++) {
+		if ((sr = read_sr(flash)) < 0)
+			break;
+		else if (!(sr & SR_WIP))
+			return 0;
+
+		/* REVISIT sometimes sleeping would be best */
+	}
+
+	return 1;
+}
+
+int wait_till_ready_wr(struct nx_sfc_mtd *flash)
+{
+	int count;
+	int sr;
+
+	/* one chip guarantees max 5 msec wait here after page writes,
+	 * but potentially three seconds (!) after page erase.
+	 */
+	for (count = 0; count < MAX_READY_WAIT_COUNT; count++) {
+		if ((sr = read_sr(flash)) < 0)
+			break;
+		else if ((sr & SR_WEL))
+			return 0;
+
+		/* REVISIT sometimes sleeping would be best */
+	}
+
+	return 1;
+}
+/*
+ * Erase the whole flash memory
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_chip(struct nx_sfc_mtd *flash)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, " %s %lldKiB\n",
+			 __func__,
+			flash->mtd.size / 1024);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->cd.command[0] = OPCODE_CHIP_ERASE;
+
+	nx_sfc_erase(flash);
+
+	return 0;
+}
+
+/*
+ * Erase one sector of flash memory at offset ``offset'' which is any
+ * address within the sector which should be erased.
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_sector(struct nx_sfc_mtd *flash, u32 offset)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, " %s %dKiB at 0x%08x\n",
+			 __func__,
+			flash->mtd.erasesize / 1024, offset);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->cd.command[0] = flash->erase_opcode;
+	flash->cd.offset = offset;
+
+	nx_sfc_erase(flash);
+
+	return 0;
+}
+
+/****************************************************************************/
+
+/*
+ * MTD implementation
+ */
+
+/*
+ * Erase an address range on the flash chip.  The address range may extend
+ * one or more erase sectors.  Return an error is there is a problem erasing.
+ */
+static int nx_sfc_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct nx_sfc_mtd *flash = mtd_to_nx_sfc_mtd(mtd);
+	u32 addr,len;
+
+	DEBUG(MTD_DEBUG_LEVEL2, " %s %s 0x%08x, len %lld\n",
+			 __func__, "at",
+			(u32)instr->addr, instr->len);
+
+	/* sanity checks */
+	if (instr->addr + instr->len > flash->mtd.size)
+		return -EINVAL;
+	if ((instr->addr % mtd->erasesize) != 0
+			|| (instr->len % mtd->erasesize) != 0) {
+		return -EINVAL;
+	}
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&flash->lock);
+
+	/* whole-chip erase? */
+	if (len == flash->mtd.size && erase_chip(flash)) {
+		instr->state = MTD_ERASE_FAILED;
+		mutex_unlock(&flash->lock);
+		return -EIO;
+
+	/* REVISIT in some cases we could speed up erasing large regions
+	 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
+	 * to use "small sector erase", but that's not always optimal.
+	 */
+
+	/* "sector"-at-a-time erase */
+	} else {
+		while (len) {
+			if (erase_sector(flash, addr)) {
+				instr->state = MTD_ERASE_FAILED;
+				mutex_unlock(&flash->lock);
+				return -EIO;
+			}
+
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+
+	mutex_unlock(&flash->lock);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+/*
+ * Read an address range from the flash chip.  The address range
+ * may be any size provided it is within the physical boundaries.
+ */
+static int nx_sfc_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct nx_sfc_mtd *flash = mtd_to_nx_sfc_mtd(mtd);
+   u32 page_offset, page_size, first_page, i;
+   
+	DEBUG(MTD_DEBUG_LEVEL2, " %s %s 0x%08x, len %zd\n",
+			 __func__, "from",
+			(u32)from, len);
+   
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (from + len > flash->mtd.size)
+		return -EINVAL;
+
+
+	/* NOTE:
+	 * OPCODE_FAST_READ (if available) is faster.
+	 * Should add 1 byte DUMMY_BYTE.
+	 */
+	/* Byte count starts at zero. */
+	if (retlen)
+		*retlen = 0;
+	mutex_lock(&flash->lock);
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */
+		mutex_unlock(&flash->lock);
+		return 1;
+	}
+
+	/* FIXME switch to OPCODE_FAST_READ.  It's required for higher
+	 * clocks; and at this writing, every chip this driver handles
+	 * supports that opcode.
+	 */
+
+	/* Set up the write data buffer. */
+	flash->cd.command[0] = OPCODE_READ;
+   page_offset = from % FLASH_PAGESIZE;
+   
+	/* the size of data remaining on the first page */
+   if(page_offset)
+	   page_size = FLASH_PAGESIZE - page_offset;
+ 
+   if (page_offset)
+      first_page = page_size;
+   else
+      first_page = 0;
+	//*retlen = actual_length - CMD_SIZE;
+
+	/* write everything in PAGESIZE chunks */
+	for (i = 0; i < len; i += page_size) {
+		page_size = len - i;
+      if (first_page){
+         if (first_page >len ){
+             first_page = len;
+         }
+         if (first_page >= 64){
+             page_size = 64;
+             first_page -= 64;
+         }
+         else{
+            page_size = first_page;
+            first_page -= page_size;
+         }
+      }
+	//	else if (page_size > FLASH_PAGESIZE)
+	//		page_size = FLASH_PAGESIZE;
+      else {
+         if (page_size > 64)
+         page_size = 64;
+      }
+      flash->cd.offset = from + i;
+      flash->cd.length = page_size;
+      flash->cd.buffer = buf + i;
+
+		wait_till_ready(flash);
+      #ifdef SFC_DMAC_ENABLE
+      if (page_size == FLASH_PAGESIZE)
+			nx_sfc_read(flash);
+      else
+      #endif            
+      nx_sfc_prefetch_read(flash);
+
+	}
+
+   if (retlen)
+		*retlen = len;
+	mutex_unlock(&flash->lock);
+
+	return 0;
+}
+
+/*
+ * Write an address range to the flash chip.  Data must be written in
+ * FLASH_PAGESIZE chunks.  The address range may be any size provided
+ * it is within the physical boundaries.
+ */
+static int nx_sfc_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct nx_sfc_mtd *flash = mtd_to_nx_sfc_mtd(mtd);
+	u32 page_offset = 0, page_size = 0, first_page = 0;
+   u32 i;
+   
+	DEBUG(MTD_DEBUG_LEVEL2, " %s %s 0x%08x, len %zd\n",
+			 __func__, "to",
+			(u32)to, len);
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity checks */
+	if (!len)
+		return(0);
+
+	if (to + len > flash->mtd.size)
+		return -EINVAL;
+
+	mutex_lock(&flash->lock);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash)) {
+		mutex_unlock(&flash->lock);
+		return 1;
+	}
+
+	/* Set up the opcode in the write buffer. */
+	flash->cd.command[0] = OPCODE_PP;
+
+	/* what page do we start with? */
+	page_offset = to % FLASH_PAGESIZE;
+
+	/* do all the bytes fit onto one page? */
+       
+	/* the size of data remaining on the first page */
+   if(page_offset)
+	   first_page = FLASH_PAGESIZE - page_offset;
+
+	/* write everything in PAGESIZE chunks */
+	for (i = 0; i < len; i += page_size) {
+		
+      page_size = len - i;
+      if (first_page){
+         if (first_page >len ){
+             first_page = len;
+         }
+         if (first_page >= 64){
+             page_size = 64;
+             first_page -= 64;
+         }
+         else{
+            page_size = first_page;
+            first_page -= page_size;
+         }
+      }
+      else {
+         		//	if (page_size > FLASH_PAGESIZE)
+         		//		page_size = FLASH_PAGESIZE;
+         if (page_size > 64)
+            page_size = 64;
+      }
+      flash->cd.offset = to + i;
+      flash->cd.length= page_size;
+      flash->cd.buffer= (u8*)buf + i;
+
+
+		wait_till_ready(flash);
+      write_enable(flash);
+      wait_till_ready_wr(flash);
+      #ifdef SFC_DMAC_ENABLE
+      if (page_size == FLASH_PAGESIZE)
+			nx_sfc_write(flash);
+      else
+      #endif            
+      nx_sfc_prefetch_write(flash);
+	}
+  
+   if (retlen)
+      *retlen = len;
+	mutex_unlock(&flash->lock);
+
+	return 0;
+}
+
+
+/****************************************************************************/
+
+/*
+ * SPI device driver setup and teardown
+ */
+
+struct flash_info {
+	char		*name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32		jedec_id;
+	u16             ext_id;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned	sector_size;
+	u16		n_sectors;
+
+	u16		flags;
+   #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
+};
+
+
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static struct flash_info __devinitdata serial_flash_data [] = {
+
+	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
+	{ "at25fs010",  0x1f6601, 0, 32 * 1024, 4, SECT_4K, },
+	{ "at25fs040",  0x1f6604, 0, 64 * 1024, 8, SECT_4K, },
+
+	{ "at25df041a", 0x1f4401, 0, 64 * 1024, 8, SECT_4K, },
+	{ "at25df641",  0x1f4800, 0, 64 * 1024, 128, SECT_4K, },
+
+	{ "at26f004",   0x1f0400, 0, 64 * 1024, 8, SECT_4K, },
+	{ "at26df081a", 0x1f4501, 0, 64 * 1024, 16, SECT_4K, },
+	{ "at26df161a", 0x1f4601, 0, 64 * 1024, 32, SECT_4K, },
+	{ "at26df321",  0x1f4701, 0, 64 * 1024, 64, SECT_4K, },
+
+	/* Spansion -- single (large) sector size only, at least
+	 * for the chips listed here (without boot sectors).
+	 */
+	{ "s25sl004a", 0x010212, 0, 64 * 1024, 8, },
+	{ "s25sl008a", 0x010213, 0, 64 * 1024, 16, },
+	{ "s25sl016a", 0x010214, 0, 64 * 1024, 32, },
+	{ "s25sl032a", 0x010215, 0, 64 * 1024, 64, },
+	{ "s25sl064a", 0x010216, 0, 64 * 1024, 128, },
+        { "s25sl12800", 0x012018, 0x0300, 256 * 1024, 64, },
+	{ "s25sl12801", 0x012018, 0x0301, 64 * 1024, 256, },
+
+	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	{ "sst25vf040b", 0xbf258d, 0, 64 * 1024, 8, SECT_4K, },
+	{ "sst25vf080b", 0xbf258e, 0, 64 * 1024, 16, SECT_4K, },
+	{ "sst25vf016b", 0xbf2541, 0, 64 * 1024, 32, SECT_4K, },
+	{ "sst25vf032b", 0xbf254a, 0, 64 * 1024, 64, SECT_4K, },
+
+	/* ST Microelectronics -- newer production may have feature updates */
+	{ "m25p05",  0x202010,  0, 32 * 1024, 2, },
+	{ "m25p10",  0x202011,  0, 32 * 1024, 4, },
+	{ "m25p20",  0x202012,  0, 64 * 1024, 4, },
+	{ "m25p40",  0x202013,  0, 64 * 1024, 8, },
+	{ "m25p80",         0,  0, 64 * 1024, 16, },
+	{ "m25p16",  0x202015,  0, 64 * 1024, 32, },
+	{ "m25p32",  0x202016,  0, 64 * 1024, 64, },
+	{ "m25p64",  0x202017,  0, 64 * 1024, 128, },
+	{ "m25p128", 0x202018, 0, 256 * 1024, 64, },
+
+	{ "m45pe80", 0x204014,  0, 64 * 1024, 16, },
+	{ "m45pe16", 0x204015,  0, 64 * 1024, 32, },
+
+	{ "m25pe80", 0x208014,  0, 64 * 1024, 16, },
+	{ "m25pe16", 0x208015,  0, 64 * 1024, 32, SECT_4K, },
+
+	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{ "w25x10", 0xef3011, 0, 64 * 1024, 2, SECT_4K, },
+	{ "w25x20", 0xef3012, 0, 64 * 1024, 4, SECT_4K, },
+	{ "w25x40", 0xef3013, 0, 64 * 1024, 8, SECT_4K, },
+	{ "w25x80", 0xef3014, 0, 64 * 1024, 16, SECT_4K, },
+	{ "w25x16", 0xef3015, 0, 64 * 1024, 32, SECT_4K, },
+	{ "w25x32", 0xef3016, 0, 64 * 1024, 64, SECT_4K, },
+	{ "w25x64", 0xef3017, 0, 64 * 1024, 128, SECT_4K, },
+	{ "w25x128",0xef4018, 0, 64 * 1024, 256, },
+};
+
+static struct flash_info *__devinit jedec_probe(struct platform_device *spi)
+{
+	int			tmp;
+//	u8			code = OPCODE_RDID;
+	u8			*id;
+	u32			jedec;
+	u16                     ext_jedec;
+	struct flash_info	*info;
+
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+   	struct nx_sfc_mtd	*flash = dev_get_drvdata(&spi->dev);
+   	tmp = nx_sfc_read_id(flash->mmio_base);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "error %d reading JEDEC ID\n",
+			tmp);
+		return NULL;
+	}
+   	id = (u8 *) &tmp;
+ 	jedec = id[0];
+	jedec = jedec << 8;
+	jedec |= id[1];
+	jedec = jedec << 8;
+	jedec |= id[2];
+
+   	ext_jedec = 0;
+   	printk(KERN_ERR "JEDC ID = 0x%x \n", jedec);
+
+	for (tmp = 0, info = serial_flash_data;
+			tmp < ARRAY_SIZE(serial_flash_data);
+			tmp++, info++) {
+		if (info->jedec_id == jedec) {
+			if (info->ext_id != 0 && info->ext_id != ext_jedec)
+				continue;
+			return info;
+		}
+	}
+	dev_err(&spi->dev, "unrecognized JEDEC id %06x\n", jedec);
+	return NULL;
+}
+
+
+/*
+ * board specific setup should have ensured the SPI clock used here
+ * matches what the READ command supports, at least until this driver
+ * understands FAST_READ (for clocks over 25 MHz).
+ */
+static int __devinit nx_sfc_probe(struct platform_device *pdev)
+{
+	struct nx_sfc_info	*data;
+	struct nx_sfc_mtd	*flash;
+	struct flash_info	*info;
+	unsigned		i;
+   	int err;
+
+   	struct resource *res;
+ 	//  unsigned long size;
+   	void __iomem *mmio_regs = NULL;
+   	resource_size_t mmio_start, mmio_len;
+
+   	/* Get MMIO registers resource */
+   	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   	if (!res) {
+      		dev_err(&pdev->dev, "No MMIO resource found\n");
+      		return -ENXIO;
+   	}
+
+   	mmio_start = res->start;
+   	mmio_len   = res->end - res->start + 1;
+
+  	if (!request_mem_region(mmio_start, mmio_len, pdev->name)) {
+      		dev_err(&pdev->dev, "request_mem_region failure\n");
+      		return -EBUSY;
+   	}
+
+   	mmio_regs = ioremap(mmio_start, mmio_len);
+   	if(!mmio_regs) {
+      		dev_err(&pdev->dev, "ioremap failure\n");
+      		err = -ENOMEM;
+      		return err;
+   	}
+      	nx_sfc_init(mmio_regs);
+      	#ifdef SFC_DMAC_ENABLE
+      	err = nx_sfc_dma_init();
+      	if (err)
+        	return err;
+      	#endif
+
+   	flash = kzalloc(sizeof *flash, GFP_KERNEL);
+	if (!flash)
+		return -ENOMEM;
+
+	mutex_init(&flash->lock);
+	dev_set_drvdata(&pdev->dev, flash);
+   
+   	flash->sfc = pdev;
+   	flash->mtd.name = pdev->name;
+	flash->mtd.type = MTD_NORFLASH;
+	flash->mtd.writesize = 1;
+	flash->mtd.flags = MTD_CAP_NORFLASH;
+	flash->mtd.erase = nx_sfc_mtd_erase;
+	flash->mtd.read = nx_sfc_mtd_read;
+	flash->mtd.write = nx_sfc_mtd_write;
+  	flash->mtd.block_read = nx_sfc_mtd_read;
+	flash->mtd.block_write = nx_sfc_mtd_write;
+ 
+   	flash->mmio_start    = mmio_start;
+   	flash->mmio_len      = mmio_len;
+   	flash->mmio_base     = mmio_regs;
+
+
+	/* Platform data helps sort out which chip type we have, as
+	 * well as how this board partitions it.  If we don't have
+	 * a chip ID, try the JEDEC id commands; they'll work for most
+	 * newer chips, even if we don't recognize the particular chip.
+	 */
+	data = pdev->dev.platform_data;
+	if (data && data->type) {
+		for (i = 0, info = serial_flash_data;
+				i < ARRAY_SIZE(serial_flash_data);
+				i++, info++) {
+			if (strcmp(data->type, info->name) == 0)
+				break;
+		}
+
+		/* unrecognized chip? */
+		if (i == ARRAY_SIZE(serial_flash_data)) {
+			DEBUG(MTD_DEBUG_LEVEL0, ": unrecognized id %s\n",
+					 data->type);
+			info = NULL;
+
+		/* recognized; is that chip really what's there? */
+		} else if (info->jedec_id) {
+			struct flash_info	*chip = jedec_probe(pdev);
+
+			if (!chip || chip != info) {
+				dev_warn(&pdev->dev, "found %s, expected %s\n",
+						chip ? chip->name : "UNKNOWN",
+						info->name);
+				info = NULL;
+			}
+		}
+	} else
+	      info = jedec_probe(pdev);
+      
+
+	if (!info)
+		return -ENODEV;
+   
+   	flash->mtd.size = info->sector_size * info->n_sectors;
+   	/* prefer "small sector" erase if possible */
+	if (info->flags & SECT_4K) {
+		flash->erase_opcode = OPCODE_BE_4K;
+		flash->mtd.erasesize = 4096;
+	} else {
+		flash->erase_opcode = OPCODE_SE;
+		flash->mtd.erasesize = info->sector_size;
+	}
+
+	dev_info(&pdev->dev, "%s (%lld Kbytes)\n", info->name,
+			flash->mtd.size / 1024);
+
+	DEBUG(MTD_DEBUG_LEVEL2,
+		"mtd .name = %s, .size = 0x%.8llx (%lluMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		flash->mtd.name,
+		flash->mtd.size, flash->mtd.size / (1024*1024),
+		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+		flash->mtd.numeraseregions);
+
+	if (flash->mtd.numeraseregions)
+		for (i = 0; i < flash->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL2,
+				"mtd.eraseregions[%d] = { .offset = 0x%.8llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, flash->mtd.eraseregions[i].offset,
+				flash->mtd.eraseregions[i].erasesize,
+				flash->mtd.eraseregions[i].erasesize / 1024,
+				flash->mtd.eraseregions[i].numblocks);
+
+
+	/*
+	 * Atmel serial flash tend to power up
+	 * with the software protection bits set
+	 */
+
+	if (info->jedec_id >> 16 == 0x1f) {
+		write_enable(flash);
+		write_sr(flash, 0);
+	}
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	 */
+	if (mtd_has_partitions()) 
+      	{
+		struct mtd_partition	*parts = NULL;
+		int			nr_parts = 0;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+		static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+		nr_parts = parse_mtd_partitions(&flash->mtd,
+				part_probes, &parts, 0);
+#endif
+
+		if (nr_parts <= 0 && data && data->parts) {
+			parts = data->parts;
+			nr_parts = data->nr_parts;
+		}
+
+		if (nr_parts > 0) {
+			for (i = 0; i < nr_parts; i++) {
+				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
+					"{.name = %s, .offset = 0x%.8llx, "
+						".size = 0x%.8llx (%lluKiB) }\n",
+					i, parts[i].name,
+					parts[i].offset,
+					parts[i].size,
+					parts[i].size / 1024);
+			}
+			flash->partitioned = 1;
+			return add_mtd_partitions(&flash->mtd, parts, nr_parts);
+		}
+	} else if (data->nr_parts)
+		dev_warn(&pdev->dev, "ignoring %d default partitions on %s\n",
+				data->nr_parts, data->name);
+
+	return add_mtd_device(&flash->mtd) == 1 ? -ENODEV : 0;
+}
+
+
+static int __devexit nx_sfc_remove(struct platform_device *spi)
+{
+	struct nx_sfc_mtd	*flash = dev_get_drvdata(&spi->dev);
+	int		status;
+
+	/* Clean up MTD stuff. */
+	if (mtd_has_partitions() && flash->partitioned)
+		status = del_mtd_partitions(&flash->mtd);
+	else
+		status = del_mtd_device(&flash->mtd);
+	if (status == 0)
+		kfree(flash);
+	return 0;
+}
+
+static struct platform_driver nx_sfc_driver = {
+   .driver   = {
+      .name  = "nx_sfc",
+      .owner = THIS_MODULE,
+   },
+};
+
+static int __init nx_sfc_drv_init(void)
+{
+   return platform_driver_probe(&nx_sfc_driver, nx_sfc_probe);
+}
+
+static void __exit nx_sfc_drv_exit(void)
+{
+   platform_driver_unregister(&nx_sfc_driver);
+}
+
+module_init(nx_sfc_drv_init);
+module_exit(nx_sfc_drv_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD SFC driver for APOLLO");
+MODULE_ALIAS("platform:nx_sfc");
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/sfc/nx_sfc.h linux-2.6.34/drivers/mtd/sfc/nx_sfc.h
--- linux-2.6.34.orig/drivers/mtd/sfc/nx_sfc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/sfc/nx_sfc.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,436 @@
+#ifndef NX_SFC_FLASH_H
+#define NX_SFC_FLASH_H
+
+   #define IPBGCSFLSHNTWK_BASE 0x0
+   #define IPBGCSFLSHNTWK_SFC_SFC_VERSION_ID_REG  (0x00)
+	#define IPBGCSFLSHNTWK_SFC_SFC_VERSION_ID_VERSION_R (0x07fffffff << 0)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_REG  (0x04)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_SPI_RST_RW (0x01 << 31)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_DMA_REQ_INT_MASK_RW (0x01 << 30)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_DMA_REQ_EN_RW (0x01 << 29)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_ACC_ERR_CLR_RW (0x01 << 28)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TMR_INT_MASK_RW (0x01 << 27)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TMR_INT_EN_RW (0x01 << 26)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_INT_MASK_RW (0x01 << 25)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_INT_EN_RW (0x01 << 24)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_HOLD_EN_RW (0x01 << 23)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_PRE_FETCH_TX_EN_RW (0x01 << 22)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_START_BITS_RW (0x01 << 20)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_TRANS_EDGE_RW (0x01 << 18)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_TX_EN_RW (0x01 << 17)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_LOOP_BACK_RW (0x01 << 16)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_DMA_THRD_RW (0x0f << 11)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_INT_MASK_RW (0x01 << 10)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_INT_EN_RW (0x01 << 9)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_HOLD_EN_RW (0x01 << 8)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_PRE_FETCH_RX_EN_RW (0x01 << 6)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_DATA_WIDTH_RW (0x01 << 4)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_CAP_EDGE_RW (0x01 << 2)
+
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_EN_RW (0x01 << 1)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_EN_SHIFT 1
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_EN_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_RX_EN_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_SPI_EN_RW (0x01 << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_SPI_EN_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_SPI_EN_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_CSR_SPI_EN_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_REG  (0x08)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SCK_RW (0x01 << 31)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SCK_SHIFT 31
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SCK_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SCK_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_WP_RW (0x01 << 30)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_WP_SHIFT 30
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_WP_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_WP_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_HOLD_RW (0x01 << 29)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_HOLD_SHIFT 29
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_HOLD_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_HOLD_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_CS_RW (0x01 << 28)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_CS_SHIFT 28
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_CS_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_CS_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SI_RW (0x01 << 27)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SI_SHIFT 27
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SO_RW (0x01 << 24)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SO_SHIFT 24
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SO_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_SO_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SCK_RW (0x01 << 23)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SCK_SHIFT 23
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SCK_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SCK_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_WP_RW (0x01 << 22)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_WP_SHIFT 22
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_WP_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_WP_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_HOLD_RW (0x01 << 21)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_HOLD_SHIFT 21
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_HOLD_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_HOLD_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_CS_RW (0x01 << 20)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_CS_SHIFT 20
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_CS_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_CS_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SI_RW (0x01 << 19)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SI_SHIFT 19
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SO_RW (0x01 << 18)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SO_SHIFT 18
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SO_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SFT_EN_SO_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_ADDR_TX_MULTI_RW (0x01 << 12)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_ADDR_TX_MULTI_SHIFT 12
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_ADDR_TX_MULTI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_ADDR_TX_MULTI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_TX_MULTI_RW (0x01 << 10)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_TX_MULTI_SHIFT 10
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_TX_MULTI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_TX_MULTI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_RX_MULTI_RW (0x01 << 8)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_RX_MULTI_SHIFT 8
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_RX_MULTI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_RX_MULTI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SI_PIN_MUX_RW (0x01 << 6)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SI_PIN_MUX_SHIFT 6
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SI_PIN_MUX_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SI_PIN_MUX_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SO_PIN_MUX_RW (0x01 << 4)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SO_PIN_MUX_SHIFT 4
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SO_PIN_MUX_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_SO_PIN_MUX_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_WP_PIN_MUX_RW (0x01 << 2)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_WP_PIN_MUX_SHIFT 2
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_WP_PIN_MUX_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_WP_PIN_MUX_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_RW (0x03 << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_VAL2 0x02
+	#define IPBGCSFLSHNTWK_SFC_SFC_PIN_CONFIG_HOLD_PIN_MUX_VAL3 0x03
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_REG  (0x0c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLK_ON_RW (0x01 << 17)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLK_ON_SHIFT 17
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLK_ON_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLK_ON_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_SCK_IDL_RW (0x01 << 16)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_SCK_IDL_SHIFT 16
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_SCK_IDL_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_SCK_IDL_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLOCK_DIV_RW (0x0ffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SCK_CSR_CLOCK_DIV_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_REG  (0x10)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_THWP_RW (0x07f << 24)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_THWP_SHIFT 24
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_TSWP_RW (0x07f << 16)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_TSWP_SHIFT 16
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_THCS_RW (0x07f << 8)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_THCS_SHIFT 8
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_TSCS_RW (0x0ff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TM_WP_CS_TSCS_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_REG  (0x14)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_ADDR_BIT_RW (0x01 << 28)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_ADDR_BIT_SHIFT 28
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_ADDR_BIT_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_ADDR_BIT_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_RW (0x03 << 15)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_SHIFT 15
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_VAL2 0x02
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_FRAME_DELAY_VAL3 0x03
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_IO_ADDR_TURN_RW (0x01f << 6)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_IO_ADDR_TURN_SHIFT 6
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_IO_DATA_TURN_RW (0x03f << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PROTOCOL_DELAY_IO_DATA_TURN_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_REG  (0x18)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_RW (0x07f << 24)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_SHIFT 24
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_ADD_REQ_RW (0x01 << 23)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_ADD_REQ_SHIFT 23
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_ADD_REQ_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_ADD_REQ_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_DST_RW (0x01 << 19)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_DST_SHIFT 19
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_DST_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_DST_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_SCR_RW (0x01 << 18)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_SCR_SHIFT 18
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_SCR_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_CMD_DATA_SCR_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_RW (0x01 << 17)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_SHIFT 17
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_EN_RW (0x01 << 16)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_EN_SHIFT 16
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_EN_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_SP_RW_CTRL_CMD_EN_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_WR_CMD_MEM_RW (0x07f << 8)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_WR_CMD_MEM_SHIFT 8
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_RD_CMD_MEM_RW (0x0ff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_DEVICE_CMD_RD_CMD_MEM_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR0_DATA_REG  (0x1c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR0_DATA_RD_WR_DATA0_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR0_DATA_RD_WR_DATA0_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR1_DATA_REG  (0x20)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR1_DATA_RD_WR_DATA1_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_SP_CMD_RD_WR1_DATA_RD_WR_DATA1_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_REG  (0x24)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_EN_RW (0x01 << 31)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_EN_SHIFT 31
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_EN_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_EN_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_START_SP_RW (0x01 << 30)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_START_SP_SHIFT 30
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_START_SP_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_START_SP_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_ACC_ERR_EN_RW (0x01 << 29)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_ACC_ERR_EN_SHIFT 29
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_ACC_ERR_EN_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_ACC_ERR_EN_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_VAL_RW (0x01fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CMD_TMR_TMR_VAL_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_REG  (0x28)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_TX_COUNT_R (0x07ff << 12)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_TX_COUNT_SHIFT 12
+	#define IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_RX_COUNT_R (0x0fff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_TX_RX_DATA_CNT_RX_COUNT_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_REG_REG  (0x2c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_RW (0x0f << 27)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_SHIFT 27
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL2 0x02
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL3 0x03
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL4 0x04
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL5 0x05
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL6 0x06
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL7 0x07
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL8 0x08
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL9 0x09
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL10 0x0a
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL11 0x0b
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL12 0x0c
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL13 0x0d
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL14 0x0e
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_BOOT_STRAP_VAL15 0x0f
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_CS_RW (0x01 << 26)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_CS_SHIFT 26
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_CS_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_CS_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SCK_RW (0x01 << 25)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SCK_SHIFT 25
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SCK_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SCK_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SI_RW (0x01 << 24)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SI_SHIFT 24
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SI_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SI_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_WP_RW (0x01 << 23)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_WP_SHIFT 23
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_WP_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_WP_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_HOLD_RW (0x01 << 22)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_HOLD_SHIFT 22
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_HOLD_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_HOLD_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SO_RW (0x01 << 21)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SO_SHIFT 21
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SO_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_CUR_SO_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_SP_CMD_DONE_RW (0x01 << 20)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_SP_CMD_DONE_SHIFT 20
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_SP_CMD_DONE_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_SP_CMD_DONE_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_ACC_ERR_RW (0x01 << 19)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_ACC_ERR_SHIFT 19
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_ACC_ERR_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_ACC_ERR_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TMR_INT_RW (0x01 << 18)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TMR_INT_SHIFT 18
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TMR_INT_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TMR_INT_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TX_INT_RW (0x01 << 17)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TX_INT_SHIFT 17
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TX_INT_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_TX_INT_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RX_INT_RW (0x01 << 16)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RX_INT_SHIFT 16
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RX_INT_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RX_INT_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DMA_REQ_RW (0x01 << 15)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DMA_REQ_SHIFT 15
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DMA_REQ_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DMA_REQ_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_RW (0x0f << 10)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_SHIFT 10
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL2 0x02
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL3 0x03
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL4 0x04
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL5 0x05
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL6 0x06
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL7 0x07
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL8 0x08
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL9 0x09
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL10 0x0a
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL11 0x0b
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL12 0x0c
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL13 0x0d
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL14 0x0e
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_VALID_BUFF_ENTRY_VAL15 0x0f
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DEBUG_SIGNALS_RW (0x03f << 3)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_DEBUG_SIGNALS_SHIFT 3
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RD_CURR_DONE_RW (0x01 << 2)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RD_CURR_DONE_SHIFT 2
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RD_CURR_DONE_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_RD_CURR_DONE_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_WR_CURR_DONE_RW (0x01 << 1)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_WR_CURR_DONE_SHIFT 1
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_WR_CURR_DONE_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_WR_CURR_DONE_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_XFER_DONE_RW (0x01 << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_XFER_DONE_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_XFER_DONE_VAL0 0x00
+	#define IPBGCSFLSHNTWK_SFC_SFC_STATUS_XFER_DONE_VAL1 0x01
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_HSX_ADDRESS_REG  (0x30)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_HSX_ADDRESS_HSX_ADDR_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_HSX_ADDRESS_HSX_ADDR_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_READ_DATA_REG  (0x34)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_READ_DATA_HSX_RD_DATA_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_READ_DATA_HSX_RD_DATA_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_WRITE_DATA_REG  (0x38)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_WRITE_DATA_HSX_RD_DATA_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_CURR_WRITE_DATA_HSX_RD_DATA_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_0_REG  (0x3c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_0_BUFF_0_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_0_BUFF_0_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_1_REG  (0x40)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_1_BUFF_1_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_1_BUFF_1_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_2_REG  (0x44)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_2_BUFF_2_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_2_BUFF_2_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_3_REG  (0x48)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_3_BUFF_3_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_3_BUFF_3_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_4_REG  (0x4c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_4_BUFF_4_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_4_BUFF_4_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_5_REG  (0x50)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_5_BUFF_5_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_5_BUFF_5_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_6_REG  (0x54)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_6_BUFF_6_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_6_BUFF_6_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_7_REG  (0x58)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_7_BUFF_7_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_7_BUFF_7_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_8_REG  (0x5c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_8_BUFF_8_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_8_BUFF_8_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_9_REG  (0x60)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_9_BUFF_9_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_9_BUFF_9_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_10_REG  (0x64)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_10_BUFF_10_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_10_BUFF_10_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_11_REG  (0x68)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_11_BUFF_11_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_11_BUFF_11_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_12_REG  (0x6c)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_12_BUFF_12_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_12_BUFF_12_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_13_REG  (0x70)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_13_BUFF_13_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_13_BUFF_13_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_14_REG  (0x74)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_14_BUFF_14_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_14_BUFF_14_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_15_REG  (0x78)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_15_BUFF_15_RW (0x07fffffff << 0)
+	#define IPBGCSFLSHNTWK_SFC_SFC_PRE_FETCH_BUFF_15_BUFF_15_SHIFT 0
+	#define IPBGCSFLSHNTWK_SFC_MODULE_ID_REG  (0xfc)
+
+#define SFC_PROTCOL_DELAY_READ   0x10008000
+#define SFC_PROTOCL_DELAY_WRITE  0x10038000
+#define SFC_CSR_READ          0x0000027
+#define SFC_CSR_WRITE         0x00420001
+#define SFC_CSR_ERASE         0x20001
+#define SFC_CSR_WREN          0x67
+#define SFC_CSR_READ_ID       0x27
+#define SFC_CSR_READ_STATUS   0x7
+#define SFC_CSR_WRITE_STATUS  0x20001
+#define SFC_DEV_CMD_READ      0x03850203 
+#define SFC_DEV_CMD_WRITE     0x02810203
+#define SFC_DEV_CMD_ERASE     0xD8810203
+#define SFC_DEV_CMD_WREN      0x060D0203
+#define SFC_DEV_CMD_ID        0x9F0D0203
+#define SFC_DEV_CMD_READ_STATUS    0x050D0203
+#define SFC_DEV_CMD_WRITE_STATUS    0x070D0203
+struct mtd_partition;
+
+/**
+ * struct flash_platform_data: board-specific flash data
+ * @name: optional flash device name (eg, as used with mtdparts=)
+ * @parts: optional array of mtd_partitions for static partitioning
+ * @nr_parts: number of mtd_partitions for static partitoning
+ * @type: optional flash device type (e.g. m25p80 vs m25p64), for use
+ *	with chips that can't be queried for JEDEC or other IDs
+ *
+ * Board init code (in arch/.../mach-xxx/board-yyy.c files) can
+ * provide information about SPI flash parts (such as DataFlash) to
+ * help set up the device and its appropriate default partitioning.
+ *
+ * Note that for DataFlash, sizes for pages, blocks, and sectors are
+ * rarely powers of two; and partitions should be sector-aligned.
+ */
+struct nx_sfc_info{
+	char		*name;
+	struct mtd_partition *parts;
+	unsigned int	nr_parts;
+
+	char		*type;
+
+	/* we'll likely add more ... use JEDEC IDs, etc */
+};
+
+#if 0
+struct nx_sfc_device
+{
+   dmabuf_phy;
+};
+#endif
+void nx_sfc_wait(void __iomem * sfc_regs);
+#endif
+
+
diff -Naurp linux-2.6.34.orig/drivers/mtd/sfc/sfc_dmac.c linux-2.6.34/drivers/mtd/sfc/sfc_dmac.c
--- linux-2.6.34.orig/drivers/mtd/sfc/sfc_dmac.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/mtd/sfc/sfc_dmac.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,226 @@
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+
+#include <linux/dmaengine.h>
+#include <linux/nx_dmac_1902.h>
+#include <linux/nx_dmac.h>
+
+#define NX_DMAC_1902_DMAC_ENABLE             (0x00000001)
+#define NX_DMAC_1902_DMAC_DISABLE            (0x00000000)
+
+#define NX_DMAC_1902_REG_INT_STATUS          (0x000)
+#define NX_DMAC_1902_REG_INT_TC_STATUS       (0x004)
+#define NX_DMAC_1902_REG_INT_TC_CLEAR        (0x008)
+#define NX_DMAC_1902_REG_INT_ERR_STATUS      (0x00C)
+#define NX_DMAC_1902_REG_INT_ERR_CLEAR       (0x010)
+#define NX_DMAC_1902_REG_INT_RAW_TC_STATUS   (0x014)
+#define NX_DMAC_1902_REG_INT_RAW_ERR_STATUS  (0x018)
+#define NX_DMAC_1902_REG_ENABLED_CHANS       (0x01C)
+
+/* channel specific register */
+#define NX_DMAC_1902_REG_CHAN_BASE(x)        (0x100+((x)*0x20))
+#define NX_DMAC_1902_REG_CHAN_SRC_ADDR       (0x000)
+#define NX_DMAC_1902_REG_CHAN_DST_ADDR       (0x004)
+#define NX_DMAC_1902_REG_CHAN_LLI_ADDR       (0x008)
+#define NX_DMAC_1902_REG_CHAN_CONTROL        (0x00C)
+#define NX_DMAC_1902_REG_CHAN_CONFIG         (0x010)
+
+#define NX_DMAC_1902_CHAN_CNTRL_DST_INCR(x)  ((x)<<27)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(x)  ((x)<<26)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_AHB(x)   ((x)<<25)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(x)   ((x)<<24)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(x) ((x)<<21)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(x) ((x)<<18)
+#define NX_DMAC_1902_CHAN_CNTRL_DST_BURST(x) ((x)<<15)
+#define NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(x) ((x)<<12)
+
+#define NX_DMAC_1902_DMAC_CHAN_ENABLE        (0x00000001)
+#define NX_DMAC_1902_DMAC_CHAN_DISABLE       (0x00000000)
+
+#define NX_DMAC_1902_INT_ENABLE              (0x80000000UL)
+
+#define NX_DMAC_1902_UNMASK_INT              (0x0000C000UL)
+
+#define NX_DMAC_1902_REG_DMAC_CONFIG         (0x030)
+
+#define MAX_NX_DMAC_1902_CHANNELS            (8)
+
+void __iomem *dma_base;
+
+extern volatile bool nor_dma_done;
+
+int nx_sfc_dma_init(void)
+{
+   struct resource *res_reg;
+   struct platform_device *pdev;
+   extern struct platform_device dmac_1902_gcs_device;
+
+   pdev = &dmac_1902_gcs_device;
+
+   res_reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   if (res_reg == NULL)
+     return -ENXIO;
+   
+   dma_base = devm_ioremap( &pdev->dev, res_reg->start, (res_reg->end - res_reg->start + 1 ));
+   if( !dma_base )
+     return -ENXIO;
+
+   /* disable the DMA controller */
+   //writel( NX_DMAC_1902_DMAC_DISABLE, dma_base+NX_DMAC_1902_REG_DMAC_CONFIG);
+
+   /* disable the DMA channel */
+   writel(NX_DMAC_1902_DMAC_CHAN_DISABLE, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID)+
+      NX_DMAC_1902_REG_CHAN_CONFIG);
+
+   /* clear the error interrupt status */
+   writel((1<<NX_DMAC_NOR_DMA_CHANNEL_ID), 
+      dma_base+NX_DMAC_1902_REG_INT_ERR_CLEAR);
+
+   /* clear the tc interrupt status */
+   writel((1<<NX_DMAC_NOR_DMA_CHANNEL_ID), 
+      dma_base+NX_DMAC_1902_REG_INT_TC_CLEAR);
+
+   /* enable the DMA controller */
+   //writel( NX_DMAC_1902_DMAC_ENABLE, dma_base+NX_DMAC_1902_REG_DMAC_CONFIG);
+
+   return 0;
+}
+
+void nx_sfc_dma_start(
+   u32 src_addr, 
+   u32 dst_addr, 
+   u32 xfer_count, 
+   bool iswrite)
+{
+   u32 control = 0;
+   u32 config  = 0;
+
+   nor_dma_done = false;
+
+#if 0
+   control |= NX_DMAC_1902_INT_ENABLE;
+   control |= NX_DMAC_1902_CHAN_CNTRL_DST_INCR(1);
+   control |= NX_DMAC_1902_CHAN_CNTRL_SRC_INCR(1);
+   if(iswrite)
+   {
+      control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_2);
+      control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_1);
+      //control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(map->bankwidth>>1);
+      //control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(map->bankwidth>>1);
+      control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(0x2);
+      control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(0x2);
+   }
+   else
+   {
+      control |= NX_DMAC_1902_CHAN_CNTRL_DST_AHB(nx_dmac_1902_ahb_master_1);
+      control |= NX_DMAC_1902_CHAN_CNTRL_SRC_AHB(nx_dmac_1902_ahb_master_2);
+      control |= NX_DMAC_1902_CHAN_CNTRL_DST_WIDTH(0x2);
+      control |= NX_DMAC_1902_CHAN_CNTRL_SRC_WIDTH(0x2);
+   }
+   control |= NX_DMAC_1902_CHAN_CNTRL_DST_BURST(nx_dmac_1902_burst_256);
+   control |= NX_DMAC_1902_CHAN_CNTRL_SRC_BURST(nx_dmac_1902_burst_256);
+   control |= ((xfer_count)/4); //32 byte xfer width
+#endif   
+   
+   if(iswrite)
+      control = 0x8E4AD040;
+   else
+      control = 0x8d4b6040;
+
+   //config = NX_DMAC_1902_UNMASK_INT;
+   config = 0xC001;
+
+   writel(src_addr, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_SRC_ADDR);
+   writel(dst_addr, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_DST_ADDR);
+   writel(0, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_LLI_ADDR);
+   writel(control, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_CONTROL);
+   #if 0
+   writel((config | NX_DMAC_1902_DMAC_CHAN_ENABLE), 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_CONFIG);
+   #endif
+   
+      writel(config , 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID) +
+      NX_DMAC_1902_REG_CHAN_CONFIG);
+}
+
+int nx_sfc_dma_completion_wait(void)
+{
+   unsigned long dma_wait_timeout = jiffies + msecs_to_jiffies(10000);
+
+   do 
+   {
+      if (time_after_eq(jiffies, dma_wait_timeout)) 
+      {
+         printk(KERN_ERR "nx_sfc_dma_completion_wait: timeout!\n");
+         return -EIO;
+      }
+   } while (nor_dma_done == false);
+
+   /* disable the DMA channel */
+   writel(NX_DMAC_1902_DMAC_CHAN_DISABLE, 
+      dma_base+NX_DMAC_1902_REG_CHAN_BASE(NX_DMAC_NOR_DMA_CHANNEL_ID)+
+      NX_DMAC_1902_REG_CHAN_CONFIG);
+
+   return 0;
+}
+
+void nx_sfc_map_copy_from(void *to, unsigned long from, ssize_t len)
+{
+   dma_addr_t dma_dst;
+   int status;
+  
+   dma_dst = dma_map_single(NULL, to, len, DMA_FROM_DEVICE);
+
+   nx_sfc_dma_start(from, dma_dst, len, 0);
+
+   status = nx_sfc_dma_completion_wait();
+   if (status)
+   {
+      printk(KERN_ERR "nx_sfc_map_copy_from: nx_sfc_dma_completion_wait failed.\n");
+      return;
+   }
+   
+   return;
+}
+
+void nx_sfc_map_copy_to (unsigned long to, const void *from, ssize_t len)
+{
+   
+   dma_addr_t dma_src;
+   int status;
+   u32 src = (u32)from;
+
+   
+   dma_src = dma_map_single(NULL, (void *)src, len, DMA_TO_DEVICE);
+
+   nx_sfc_dma_start(dma_src, to, len, 1);
+
+   status = nx_sfc_dma_completion_wait();
+   if (status)
+   {
+      printk(KERN_ERR "nx_sfc_map_copy_to: nx_sfc_dma_completion_wait failed.\n");
+      return;
+   }
+
+
+   return;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/Kconfig linux-2.6.34/drivers/net/Kconfig
--- linux-2.6.34.orig/drivers/net/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/net/Kconfig	2010-09-07 22:16:40.000000000 -0500
@@ -2495,6 +2495,12 @@ config JME
 	  To compile this driver as a module, choose M here. The module
 	  will be called jme.
 
+config LIPP_6300ETH
+	tristate "Apollo Ethernet Driver for GMAC"
+	default y
+	help
+	  Say Y here if you want to use Apollo Ethernet driver for GMAC
+	  
 config S6GMAC
 	tristate "S6105 GMAC ethernet support"
 	depends on XTENSA_VARIANT_S6000
@@ -2506,6 +2512,7 @@ config S6GMAC
 	  To compile this driver as a module, choose M here. The module
 	  will be called s6gmac.
 
+source "drivers/net/LIPP_6300ETH/Kconfig"
 source "drivers/net/stmmac/Kconfig"
 
 endif # NETDEV_1000
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/inc/tmbslPhyDP83848.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/inc/tmbslPhyDP83848.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/inc/tmbslPhyDP83848.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/inc/tmbslPhyDP83848.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,503 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83848.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83848 PHY
+ *
+ * DOCUMENT REF: Datasheet DP83848 Gig PHYTER V10/100/1000 Ethernet 
+ *               Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyDP83848_H_
+#define tmbslPhyDP83848_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYDP83848_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYDP83848_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYDP83848_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYDP83848_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYDP83848_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYDP83848_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYDP83848_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYDP83848_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYDP83848_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYDP83848_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYDP83848_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYDP83848_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYDP83848_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYDP83848_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYDP83848_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYDP83848_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYDP83848_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYDP83848_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYDP83848_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYDP83848_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYDP83848_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYDP83848_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYDP83848_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYDP83848_BMSR_AN_VAL (0x20)
+#define TMBSL_PHYDP83848_BMCR_LPBK_VAL (0x4000)
+
+
+/* Remote fault value */
+#define TMBSL_PHYDP83848_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYDP83848_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYDP83848_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYDP83848_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYDP83848_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYDP83848_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYDP83848_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYDP83848_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYDP83848_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYDP83848_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYDP83848_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYDP83848_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYDP83848_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYDP83848_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYDP83848_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYDP83848_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYDP83848_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYDP83848_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYDP83848_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYDP83848_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYDP83848_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYDP83848_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYDP83848_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYDP83848_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYDP83848_STRAP_ANE (0x8000)
+#define TMBSL_PHYDP83848_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYDP83848_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYDP83848_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYDP83848_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYDP83848_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYDP83848_PHYSTS_SPEED_10 (0x2)
+#define TMBSL_PHYDP83848_PHYSTS_LINK_STAT (0x1)
+#define TMBSL_PHYDP83848_PHYSTS_DUP_MODE (0x4)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyDP83848Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyDP83848Context_t, *ptmbslPhyDP83848Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyDP83848Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyDP83848Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyDP83848GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyDP83848SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/src/tmbslPhyDP83848.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/src/tmbslPhyDP83848.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/src/tmbslPhyDP83848.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/src/tmbslPhyDP83848.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1109 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83848.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for DP83848 National Semiconductors PHY
+ *
+ * DOCUMENT REF: Datasheet GDP83848J PHYTER Mini LS
+ *               Commercial Temperature Single Port 10/100 Ethernet Transceiver
+ *               October 2007
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyDP83848.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include <linux/delay.h>
+#include "remap.h"
+#include <asm/io.h>
+#include <i2c_ip3203.h>
+
+/* 2.1.5 Auto-Negotiation Complete Time
+** Parallel detection and Auto-Negotiation take approximately 2-3 seconds 
+** to complete. In addition, Auto-Negotiation with next page should take 
+** approximately 2-3 seconds to complete, depending on the number of next
+** pages sent.
+*/
+#define AUTO_NEG_DELAY_MS (3000)
+
+#endif /* __LIPP_6300ETH__ */
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYDP83848_PHY_MMIO_ADDRESS0 (0xC0000000)
+
+#define ANAR_DEFAULT_VAL (0xDE1)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+tmbslPhyDP83848Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYDP83848_PHY_MMIO_ADDRESS0}};
+
+typedef	enum	_tmbslPhyDP83848Reg_t
+{
+    /* Basic mode control */
+    tmbslPhyDP83848Bmcr		      = 0x0,
+    /* Basic mode status */
+    tmbslPhyDP83848Bmsr		      =0x1,
+
+    /* PHY ID1 register */
+    tmbslPhyDP83848PhyIdr1		=0x2,
+
+    /* PHY ID2 register */
+    tmbslPhyDP83848PhyIdr2		=0x3,
+
+    /* Auto negotiation advertisement register */
+    tmbslPhyDP83848Anar			=0x4,
+
+    /* Auto negotiation link partner ability register */
+    tmbslPhyDP83848Anlpar		=0x5,
+
+    /* Auto negotiation expansion register */
+    tmbslPhyDP83848Aner			=0x6,
+
+    /* Auto negotiation next page transmit register */
+    tmbslPhyDP83848AnnPtr		=0x7,
+
+    /* 0x8 to 0xF reserved-*/
+    tmbslPhyDP83848Phystsr = 0x10,
+
+    /* 0x11 to 0x13 reserved */
+
+   /* False carrier sense counter register */
+    tmbslPhyDP83848Fcscr  = 0x14,
+
+   /* Receive Error Counter Register  */
+    tmbslPhyDP83848Recr = 0x15,
+
+   /* PCS Sub-Layer Configuration and Status Register */
+    tmbslPhyDP83848Pcsr = 0x16,
+
+   /* RMII and Bypass Register */
+    tmbslPhyDP83848Rmiir = 0x17,
+
+    /* LED Direct Control Register  */
+    tmbslPhyDP83848Ledcr	= 0x18,
+
+    /* BIST Configuration register1 */
+    tmbslPhyDP83848Phycr = 0x19,
+
+    /* 10Base-T Status/Control Register */
+    tmbslPhyDP8384810Btscr = 0x1A,
+
+    tmbslPhyDP83848Cdctrl1 = 0x1B,
+
+    /* 0x1C reserved */
+
+    /* Energy detect control register */
+    tmbslPhyDP83848Edcr = 0x1D,
+
+    /* 0x1E to 0x1F reserved*/
+
+} tmbslPhyDP83848Reg_t, *ptmbslPhyDP83848Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t
+tmbslPhyDP83848Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t				reg,
+    pUInt16						pVal
+	);
+
+
+static tmErrorCode_t
+tmbslPhyDP83848Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t				reg,
+    UInt16						val
+	);
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's
+//				capabilities (PHY unit initialization is not necessary).
+//				Capabilities may be different among multiple PHY units.For completeness,
+//				a PHY BSL user should call this function for each PHY unit to
+//				determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,
+    ptmbslPhyCapabilities_t  				pPhyCaps
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmsr, &bmsr);
+
+
+    pPhyCaps->T4Support100Base =
+        (((bmsr & TMBSL_PHYDP83848_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYDP83848_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYDP83848_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYDP83848_BMSR_10MBPSFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYDP83848_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYDP83848_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility =
+                (((bmsr &TMBSL_PHYDP83848_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//				default initial configuration.No Autonegotiation is done in the
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848Init(
+    tmUnitSelect_t  						ethUnitId
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+    #ifdef __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* 6.2 SOFTWARE RESET
+    ** A software reset is accomplished by setting the reset bit (bit 15) of the 
+    ** Basic Mode Control Register (BMCR). The period from the point in time when 
+    ** the reset bit is set to the point in time when software reset has concluded 
+    ** is approximately 1 usec.
+    */
+    regval = TMBSL_PHYDP83848_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYDP83848_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYDP83848_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);
+    }
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+  /*  if( ( id1 == 0x2000 ) && (id2 == 0x5C7A) )
+    {
+        // IDs are valid. Do Nothing
+    }
+    else
+    {
+        return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+*/
+
+    regval =0;
+
+    /* Set the PHY for the 10Mbps and Half Duplex mode */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848Deinit(
+    tmUnitSelect_t  						ethUnitId
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYDP83848_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYDP83848_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYDP83848_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYDP83848_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest =
+                (((bmcr & TMBSL_PHYDP83848_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYDP83848_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYDP83848_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYDP83848_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYDP83848_BMCR_SPEED_10;
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Phystsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYDP83848_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYDP83848_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYDP83848_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYDP83848_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYDP83848_BMCR_AN_EN) == 0)
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYDP83848_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYDP83848_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+        }
+
+    }
+    else
+    {
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode =
+                (((phySts & TMBSL_PHYDP83848_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed=
+                (((phySts & TMBSL_PHYDP83848_PHYSTS_SPEED_10) > 0) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+
+
+    }
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//				with Link Partner. Best possible performance configuration is
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=800U;
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_NP;
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_ADV_RF;
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_AP;
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_PAUSE;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_100B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_100B_TX_HD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_10B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_10B_TX_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Enable the Auto negotiation in the BMCR register
+    ** First clear the auto negotiate bit and then enable
+    */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYDP83848_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYDP83848_BMCR_AN_EN;
+
+    ethStatus= tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmsr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYDP83848_BMSR_AN_VAL) != TMBSL_PHYDP83848_BMSR_AN_VAL) &&
+            (timeout != 0U ) )
+    {
+
+        timeout--;            
+
+        mdelay(5);  
+
+        ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmsr,&regVal);
+
+        if(ethStatus != TM_OK)
+        {
+            return(ethStatus);
+        }
+
+    }
+
+    if((timeout == 0U ) &&
+        ((regVal & TMBSL_PHYDP83848_BMSR_AN_VAL) != TMBSL_PHYDP83848_BMSR_AN_VAL))
+    {
+       ethStatus = ~TM_OK;
+    }
+
+    return ethStatus;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848LoopBack (
+    tmUnitSelect_t                  ethUnitId,
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYDP83848_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SoftReset (
+    tmUnitSelect_t                     		ethUnitId
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,TMBSL_PHYDP83848_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 physts;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Phystsr,&physts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((physts & TMBSL_PHYDP83848_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83848Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t		reg,
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        printk(KERN_ERR"\n&*&*&*PHY READ FAILED\n");
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83848Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t		reg,
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+             (timeout < PHY_TIMEOUT) );
+
+	if( (timeout == PHY_TIMEOUT) &&
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+        printk(KERN_ERR"\n&*&*&*PHY WRITE FAILED\n");
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}
+
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+//    pnx8xxx_ip3203_init();
+//    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+//    msleep(1);
+
+    /* Turn the clocks to MAC from PHY */
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47710));	
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47714));	
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47718));	
+
+    msleep(1);
+
+//    printk(KERN_INFO"\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0xbbe47710));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0xbbe47714));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0xbbe47718));                       
+//    printk(KERN_INFO"\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif 
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/inc/tmbslPhyDP83865.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/inc/tmbslPhyDP83865.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/inc/tmbslPhyDP83865.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/inc/tmbslPhyDP83865.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,636 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83865.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83865 PHY
+ *
+ * DOCUMENT REF: Datasheet National Semiconductor DP83865 Gig PHYTER V
+ *               10/100/1000 Ethernet Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyDP83865_H_
+#define tmbslPhyDP83865_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYDP83865_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYDP83865_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYDP83865_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYDP83865_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYDP83865_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYDP83865_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYDP83865_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYDP83865_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYDP83865_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYDP83865_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYDP83865_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYDP83865_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYDP83865_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYDP83865_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYDP83865_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYDP83865_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYDP83865_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYDP83865_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYDP83865_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYDP83865_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYDP83865_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYDP83865_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYDP83865_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYDP83865_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYDP83865_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYDP83865_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYDP83865_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYDP83865_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYDP83865_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYDP83865_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYDP83865_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYDP83865_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYDP83865_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYDP83865_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYDP83865_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYDP83865_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYDP83865_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYDP83865_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYDP83865_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYDP83865_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYDP83865_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYDP83865_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYDP83865_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYDP83865_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYDP83865_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYDP83865_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYDP83865_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYDP83865_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYDP83865_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYDP83865_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYDP83865_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYDP83865_STRAP_ANE (0x8000)
+#define TMBSL_PHYDP83865_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYDP83865_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYDP83865_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYDP83865_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYDP83865_STRAP_SPD_10 (0x0)
+
+/* Link and Autonegotiation Register. Read only */
+#define TMBSL_PHYDP83865_LINKAN_SPEED_MSK (0x18)
+#define TMBSL_PHYDP83865_LINKAN_SPEED_10 (0x0)
+#define TMBSL_PHYDP83865_LINKAN_SPEED_100 (0x8)
+#define TMBSL_PHYDP83865_LINKAN_SPEED_1000 (0x10)
+#define TMBSL_PHYDP83865_LINKAN_LINK_STAT (0x4)
+#define TMBSL_PHYDP83865_LINKAN_DUP_MODE (0x2)
+#define TMBSL_PHYDP83865_LINKAN_PHY_MASTER (0x1)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyDP83865Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyDP83865Context_t, *ptmbslPhyDP83865Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyDP83865Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyDP83865Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyDP83865GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyDP83865SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetIdentifier (
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetCounters (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865PcsConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865PcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result 
+//				will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865Bist (		
+    tmUnitSelect_t  						phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    			phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865ConfigBypass (
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyDP83865
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyDP83865.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/src/tmbslPhyDP83865.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/src/tmbslPhyDP83865.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/src/tmbslPhyDP83865.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/src/tmbslPhyDP83865.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1275 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83865.c %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83865 PHY
+ *
+ * DOCUMENT REF: Datasheet National Semiconductor DP83865 Gig PHYTER V
+ *               10/100/1000 Ethernet Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyDP83865.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Defines */
+
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF) 
+
+/* #define PHY_TIMEOUT                 (0x0FFFFFFF) */
+
+#define TMBSLPHYDP83865_PHY_MMIO_ADDRESS0 (0xC0000000) 
+
+#define ANAR_DEFAULT_VAL (0xADE1)
+#define KTCR1_DEFAULT_VAL (0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+tmbslPhyDP83865Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYDP83865_PHY_MMIO_ADDRESS0}}; 
+
+typedef	enum	_tmbslPhyDP83865Reg_t
+{
+    /* Basic mode control */
+    tmbslPhyDP83865Bmcr		      = 0x0,  
+    /* Basic mode status */    
+    tmbslPhyDP83865Bmsr		      =0x1,  
+
+    /* PHY ID1 register */        
+    tmbslPhyDP83865PhyIdr1		=0x2,
+
+    /* PHY ID2 register */            
+    tmbslPhyDP83865PhyIdr2		=0x3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhyDP83865Anar			=0x4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhyDP83865Anlpar		=0x5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhyDP83865Aner			=0x6,
+
+    /* Auto negotiation next page transmit register */                            
+    tmbslPhyDP83865AnnPtr		=0x7,
+
+    /* Auto negotiation Link Partner received Next Page */                                
+    tmbslPhyDP83865Annprr=0x8,
+
+    /* Auto negotiation 1000 Base-T Master-Slave Control register*/                                
+    tmbslPhyDP838651ktcr =0x9,    
+
+    /* Auto negotiation 1000 Base-T Master-Slave status register*/                                
+    tmbslPhyDP838651kstsr  = 0xA,    
+
+    /* 0xB-1E are reserved */
+
+    /*Extended status register */                                
+    tmbslPhyDP838651kscr = 0xF,    
+
+    /**** Vendor Specific Registers *****/
+    /*Strap */                                
+    tmbslPhyDP83865Sor 	= 0x10,        
+
+   /* Link and Autonegotiation Register */                                
+    tmbslPhyDP83865Lanr 	= 0x11,        
+    
+   /* Auxiliary Control Register */                                
+    tmbslPhyDP83865Acr 	= 0x12,        
+    
+   /* Led Control register */                                
+    tmbslPhyDP83865Ledcr = 0x13,
+
+   /* Interrupt status register */                                    
+    tmbslPhyDP83865Isr  = 0x14,
+
+   /* Interrupt mask register */                                        
+    tmbslPhyDP83865Imr = 0x15,
+
+   /* Expanded memory access control */                                            
+    tmbslPhyDP83865Emcr = 0x16,
+
+   /* Interrupt clear register */                                        
+    tmbslPhyDP83865Icr = 0x17,    
+
+    /* BIST Counter register */    
+    tmbslPhyDP83865Bcr	= 0x18,
+    
+    /* BIST Configuration register1 */        
+    tmbslPhyDP83865Bcfgr1 = 0x19,    
+
+    /* BIST Configuration register2 */            
+    tmbslPhyDP83865Bcfgr2 = 0x1A,        
+
+    /* 0x1B to 0x1C are reserved */ 
+     /* Expanded memory data */
+    tmbslPhyDP83865Emdr = 0x1D,
+
+    /* Expanded memory address register */ 
+    tmbslPhyDP83865Emar = 0x1E,
+
+    /* Expanded memory address  register */     
+    tmbslPhyDP83865Psupr = 0x1F 
+
+} tmbslPhyDP83865Reg_t, *ptmbslPhyDP83865Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhyDP83865Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83865Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhyDP83865Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83865Reg_t				reg,   
+    UInt16						val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83865GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP83865Bmsr, &bmsr);
+
+
+    /*  Read the extended status register */
+    tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP838651kstsr, &extStat);
+    
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYDP83865_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYDP83865_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYDP83865_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYDP83865_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYDP83865_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability = 
+        (((bmsr &TMBSL_PHYDP83865_BMSR_PREAMBLE_SUP) > 0) ? True : False);        
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYDP83865_BMSR_AN_ABLE) > 0) ? True : False);
+
+
+    pPhyCaps->X1000BaseFDSupport = 
+                (((extStat &TMBSL_PHYDP83865_1KSCR_1000BASEX_FD) > 0) ? True : False);
+  
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYDP83865_1KSCR_1000BASEX_HD) > 0) ? True : False);
+    
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYDP83865_1KSCR_1000BASET_FD) > 0) ? True : False);
+    
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYDP83865_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83865Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+   
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;    
+    
+    regval = TMBSL_PHYDP83865_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&regval);
+    
+    while( (regval & TMBSL_PHYDP83865_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&regval);
+
+        if(ethStatus != TM_OK) 
+        {
+            break;
+        }
+
+        timeout++;
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYDP83865_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865PhyIdr1,&id1);
+    
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+    
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    if( ( id1 == 0x2000 ) && (id2 == 0x5C7A) )
+    {
+        /* IDs are valid. Do Nothing */
+    }
+    else
+    {
+        return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+
+    regval =0;
+
+    /* Set the PHY for the 10Mbps and Half Duplex mode */
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYDP83865_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP83865Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYDP83865_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYDP83865_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYDP83865_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyDP83865GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYDP83865_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYDP83865_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYDP83865_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYDP83865_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYDP83865_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+            break;            
+
+        case TMBSL_PHYDP83865_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                        
+            break;            
+
+        default:
+            break;
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyDP83865SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYDP83865_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYDP83865_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYDP83865_BMCR_SPEED_1G;        
+            break;
+
+        case tmbslPhySpeed100Mbps :       
+            bmcr |= TMBSL_PHYDP83865_BMCR_SPEED_100;                
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+            bmcr |= TMBSL_PHYDP83865_BMCR_SPEED_10;                
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,linkan;
+    UInt16 speedVal;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP83865Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP83865Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from Link and Autonegotiation register*/
+    ethStatus = tmbslPhyDP83865Read(ethUnitId, tmbslPhyDP83865Lanr, &linkan);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYDP83865_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYDP83865_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYDP83865_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYDP83865_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYDP83865_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYDP83865_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        switch(bmcr & TMBSL_PHYDP83865_BMCR_SPEED_MSK)
+        {
+            case TMBSL_PHYDP83865_BMCR_SPEED_1G:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+
+            case TMBSL_PHYDP83865_BMCR_SPEED_100:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+                break;            
+
+            case TMBSL_PHYDP83865_BMCR_SPEED_10:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+                break;            
+
+            default:
+                break;
+        }
+
+    }
+    else 
+    {	
+        /* If autonegotiation is enabled, read from LINK_AN register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((linkan & TMBSL_PHYDP83865_LINKAN_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        speedVal = TMBSL_PHYDP83865_LINKAN_SPEED_MSK & linkan;
+
+        switch(speedVal)
+        {
+            case TMBSL_PHYDP83865_LINKAN_SPEED_1000 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+            case TMBSL_PHYDP83865_LINKAN_SPEED_100 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;                
+                break;
+            case TMBSL_PHYDP83865_LINKAN_SPEED_10 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps ;
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+	
+tmErrorCode_t
+tmbslPhyDP83865AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=0; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Anar,regVal);
+
+    /* For 1G configuration */
+    regVal = KTCR1_DEFAULT_VAL;
+
+    mask =0;
+
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP838651ktcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->maskMSConfigEn == True)
+    {
+        mask |= TMBSL_PHYDP83865_1KTCR_MS_CONFIG;        
+    }    
+
+    if(pAutoNegotiationMask->maskMasterEn == True)
+    {
+        mask |= TMBSL_PHYDP83865_1KTCR_MASTER_EN;        
+    }        
+
+    if(pAutoNegotiationMask->maskMultiPortEn == True)
+    {
+        mask |= TMBSL_PHYDP83865_1KTCR_MULTIPORT_EN;        
+    }        
+
+    if(pAutoNegotiationMask->mask1000BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_1KTCR_1000BT_FD;        
+    }            
+
+    if(pAutoNegotiationMask->mask1000BaseTHalfDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83865_1KTCR_1000BT_HD;        
+    }                
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the master/Slave config register 1KTCR */
+    tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP838651ktcr,regVal);
+
+    /* 1G config ends */
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYDP83865_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYDP83865_BMCR_AN_EN;
+    
+    tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,regVal);
+	
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYDP83865_BMSR_AN_VAL) != TMBSL_PHYDP83865_BMSR_AN_VAL) && 
+            (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmsr,&regVal);
+
+        if(ethStatus != TM_OK) 
+        {
+            break; 
+        }
+        
+        timeout++;
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83865LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYDP83865_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYDP83865_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83865SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83865Write(ethUnitId,tmbslPhyDP83865Bmcr,TMBSL_PHYDP83865_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 ansr;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyDP83865Read(ethUnitId,tmbslPhyDP83865Lanr,&ansr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus = 
+    (((ansr & TMBSL_PHYDP83865_LINKAN_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83865Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83865Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83865Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83865Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetIdentifier(
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83865GetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83865GetLinkPartnerCapabilities (
+    tmUnitSelect_t                         ethUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyGetCounters(
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsSetConfig(
+    tmUnitSelect_t phyUnitId,   
+    ptmbslPhyPcsConfig_t pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslPhyBist(		
+    tmUnitSelect_t                        phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyConfigBypass(
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/inc/tmbslPhyEmu.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/inc/tmbslPhyEmu.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/inc/tmbslPhyEmu.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/inc/tmbslPhyEmu.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,636 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEmu.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83865 PHY
+ *
+ * DOCUMENT REF: Datasheet DP83865 Gig PHYTER V10/100/1000 Ethernet 
+ *               Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyEmu_H_
+#define tmbslPhyEmu_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYEMU_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYEMU_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYEMU_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYEMU_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYEMU_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYEMU_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYEMU_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYEMU_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYEMU_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYEMU_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYEMU_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYEMU_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYEMU_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYEMU_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYEMU_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYEMU_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYEMU_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYEMU_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYEMU_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYEMU_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYEMU_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYEMU_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYEMU_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYEMU_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYEMU_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYEMU_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYEMU_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYEMU_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYEMU_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYEMU_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYEMU_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYEMU_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYEMU_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYEMU_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYEMU_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYEMU_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYEMU_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYEMU_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYEMU_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYEMU_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYEMU_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYEMU_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYEMU_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYEMU_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYEMU_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYEMU_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYEMU_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYEMU_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYEMU_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYEMU_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYEMU_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYEMU_STRAP_ANE (0x8000)
+#define TMBSL_PHYEMU_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYEMU_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYEMU_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYEMU_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYEMU_STRAP_SPD_10 (0x0)
+
+/* Link and Autonegotiation Register. Read only */
+#define TMBSL_PHYEMU_LINKAN_SPEED_MSK (0x18)
+#define TMBSL_PHYEMU_LINKAN_SPEED_10 (0x0)
+#define TMBSL_PHYEMU_LINKAN_SPEED_100 (0x8)
+#define TMBSL_PHYEMU_LINKAN_SPEED_1000 (0x10)
+#define TMBSL_PHYEMU_LINKAN_LINK_STAT (0x4)
+#define TMBSL_PHYEMU_LINKAN_DUP_MODE (0x2)
+#define TMBSL_PHYEMU_LINKAN_PHY_MASTER (0x1)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyEmuContext_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyEmuContext_t, *ptmbslPhyEmuContext_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyEmuInit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyEmuDeinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyEmuGetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyEmuSetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuAutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetIdentifier (
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetCounters (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuPcsConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuPcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result 
+//				will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuBist (		
+    tmUnitSelect_t  						phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    			phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuConfigBypass (
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuLoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/src/tmbslPhyEmu.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/src/tmbslPhyEmu.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/src/tmbslPhyEmu.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEmu/src/tmbslPhyEmu.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1300 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEmu.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for DP83865 National Semiconductors PHY
+ *
+ * DOCUMENT REF: iSolve Ethernet user's guide Version 1.0, Release 1
+ *               February 2008, Document Revision 5
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyEmu.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include <linux/delay.h>
+#define AUTO_NEG_DELAY_MS (3000)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF) 
+
+#define TMBSLPHYEMU_PHY_MMIO_ADDRESS0 (0xC0000000) 
+
+#define ANAR_DEFAULT_VAL (0xADE1)
+#define KTCR1_DEFAULT_VAL (0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+tmbslPhyEmuContext_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYEMU_PHY_MMIO_ADDRESS0}}; 
+
+typedef	enum	_tmbslPhyEmuReg_t
+{
+    /* Basic mode control */
+    tmbslPhyEmuBmcr		      = 0x0,  
+    /* Basic mode status */    
+    tmbslPhyEmuBmsr		      =0x1,  
+
+    /* PHY ID1 register */        
+    tmbslPhyEmuPhyIdr1		=0x2,
+
+    /* PHY ID2 register */            
+    tmbslPhyEmuPhyIdr2		=0x3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhyEmuAnar			=0x4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhyEmuAnlpar		=0x5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhyEmuAner			=0x6,
+
+    /* Auto negotiation next page transmit register */                            
+    tmbslPhyEmuAnnPtr		=0x7,
+
+    /* Auto negotiation Link Partner received Next Page */                                
+    tmbslPhyEmuAnnprr=0x8,
+
+    /* Auto negotiation 1000 Base-T Master-Slave Control register*/                                
+    tmbslPhyEmu1ktcr =0x9,    
+
+    /* Auto negotiation 1000 Base-T Master-Slave status register*/                                
+    tmbslPhyEmu1kstsr  = 0xA,    
+
+    /* 0xB-1E are reserved */
+
+    /*Extended status register */                                
+    tmbslPhyEmu1kscr = 0xF,    
+
+    /**** Vendor Specific Registers *****/
+    /*Strap */                                
+    tmbslPhyEmuSor 	= 0x10,        
+
+   /* Link and Autonegotiation Register */                                
+    tmbslPhyEmuLanr 	= 0x11,        
+    
+   /* Auxiliary Control Register */                                
+    tmbslPhyEmuAcr 	= 0x12,        
+    
+   /* Led Control register */                                
+    tmbslPhyEmuLedcr = 0x13,
+
+   /* Interrupt status register */                                    
+    tmbslPhyEmuIsr  = 0x14,
+
+   /* Interrupt mask register */                                        
+    tmbslPhyEmuImr = 0x15,
+
+   /* Expanded memory access control */                                            
+    tmbslPhyEmuEmcr = 0x16,
+
+   /* Interrupt clear register */                                        
+    tmbslPhyEmuIcr = 0x17,    
+
+    /* BIST Counter register */    
+    tmbslPhyEmuBcr	= 0x18,
+    
+    /* BIST Configuration register1 */        
+    tmbslPhyEmuBcfgr1 = 0x19,    
+
+    /* BIST Configuration register2 */            
+    tmbslPhyEmuBcfgr2 = 0x1A,        
+
+    /* 0x1B to 0x1C are reserved */ 
+     /* Expanded memory data */
+    tmbslPhyEmuEmdr = 0x1D,
+
+    /* Expanded memory address register */ 
+    tmbslPhyEmuEmar = 0x1E,
+
+    /* Expanded memory address  register */     
+    tmbslPhyEmuPsupr = 0x1F 
+
+} tmbslPhyEmuReg_t, *ptmbslPhyEmuReg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhyEmuRead (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhyEmuWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t				reg,   
+    UInt16						val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuGetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmsr, &bmsr);
+
+
+    /*  Read the extended status register */
+    tmbslPhyEmuRead(ethUnitId, tmbslPhyEmu1kstsr, &extStat);
+    
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYEMU_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYEMU_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYEMU_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYEMU_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYEMU_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability = 
+        (((bmsr &TMBSL_PHYEMU_BMSR_PREAMBLE_SUP) > 0) ? True : False);        
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYEMU_BMSR_AN_ABLE) > 0) ? True : False);
+
+
+    pPhyCaps->X1000BaseFDSupport = 
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASEX_FD) > 0) ? True : False);
+  
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASEX_HD) > 0) ? True : False);
+    
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASET_FD) > 0) ? True : False);
+    
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuInit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    regval = TMBSL_PHYEMU_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regval);
+    
+    while( (regval & TMBSL_PHYEMU_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regval);
+
+        if(ethStatus != TM_OK) 
+        {
+            break;
+        }
+
+        timeout++;
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYEMU_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+#ifndef __NULL_PHY__ /* Not valid for NULL phy */
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuPhyIdr1,&id1);
+    
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+    
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuPhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    if( ( id1 == 0x2000 ) && (id2 == 0x5C7A) )
+    {
+        /* IDs are valid. Do Nothing */
+    }
+    else
+    {
+        return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+#endif /* NULL PHY */
+
+    regval =0;
+
+    /* Set the PHY for the 10Mbps and Half Duplex mode */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuDeinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYEMU_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuSetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYEMU_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYEMU_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYEMU_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyEmuGetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYEMU_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYEMU_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYEMU_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEMU_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEMU_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+            break;            
+
+        case TMBSL_PHYEMU_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                        
+            break;            
+
+        default:
+            break;
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyEmuSetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_1G;        
+            break;
+
+        case tmbslPhySpeed100Mbps :       
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_100;                
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_10;                
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,linkan=0;
+    UInt16 speedVal;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+#ifndef __NULL_PHY__
+    /* Read the autonegotiation status from Link and Autonegotiation register*/
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuLanr, &linkan);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+#endif 
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYEMU_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYEMU_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYEMU_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYEMU_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYEMU_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYEMU_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        switch(bmcr & TMBSL_PHYEMU_BMCR_SPEED_MSK)
+        {
+            case TMBSL_PHYEMU_BMCR_SPEED_1G:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+
+            case TMBSL_PHYEMU_BMCR_SPEED_100:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+                break;            
+
+            case TMBSL_PHYEMU_BMCR_SPEED_10:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+                break;            
+
+            default:
+                break;
+        }
+
+    }
+    else 
+    {	
+        /* If autonegotiation is enabled, read from LINK_AN register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((linkan & TMBSL_PHYEMU_LINKAN_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        speedVal = TMBSL_PHYEMU_LINKAN_SPEED_MSK & linkan;
+
+        switch(speedVal)
+        {
+            case TMBSL_PHYEMU_LINKAN_SPEED_1000 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+            case TMBSL_PHYEMU_LINKAN_SPEED_100 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;                
+                break;
+            case TMBSL_PHYEMU_LINKAN_SPEED_10 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps ;
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+	
+tmErrorCode_t
+tmbslPhyEmuAutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=0; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    #ifdef __LIPP_6300ETH__
+    Bool timerExpired =False;
+    #endif /* __LIPP_6300ETH__ */            
+    
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuAnar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuAnar,regVal);
+
+    /* For 1G configuration */
+    regVal = KTCR1_DEFAULT_VAL;
+
+    mask =0;
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmu1ktcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->maskMSConfigEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MS_CONFIG;        
+    }    
+
+    if(pAutoNegotiationMask->maskMasterEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MASTER_EN;        
+    }        
+
+    if(pAutoNegotiationMask->maskMultiPortEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MULTIPORT_EN;        
+    }        
+
+    if(pAutoNegotiationMask->mask1000BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_1000BT_FD;        
+    }            
+
+    if(pAutoNegotiationMask->mask1000BaseTHalfDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_1000BT_HD;        
+    }                
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the master/Slave config register 1KTCR */
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmu1ktcr,regVal);
+
+    /* 1G config ends */
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYEMU_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYEMU_BMCR_AN_EN;
+    
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regVal);
+	
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYEMU_BMSR_AN_VAL) != TMBSL_PHYEMU_BMSR_AN_VAL) && 
+            (timeout < PHY_TIMEOUT) )
+    {
+        #ifdef __LIPP_6300ETH__                
+        /* Sleep for 6 sec & check the link status */        
+        msleep(AUTO_NEG_DELAY_MS);
+        timerExpired = True;
+        #endif    
+        ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmsr,&regVal);
+
+
+        #ifdef __LIPP_6300ETH__                
+        if((True == timerExpired) && 
+            ((regVal & TMBSL_PHYEMU_BMSR_AN_VAL) != TMBSL_PHYEMU_BMSR_AN_VAL))
+        {
+           ethStatus = !TM_OK;
+           break;
+        }
+        #endif /* __LIPP_6300ETH__ */                
+
+        if(ethStatus != TM_OK) 
+        {
+            break; 
+        }
+        
+        timeout++;
+       
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuLoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYEMU_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,TMBSL_PHYEMU_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 ansr;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuLanr,&ansr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus = 
+    (((ansr & TMBSL_PHYEMU_LINKAN_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuRead:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyEmuRead (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuWrite:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyEmuWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetIdentifier(
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         ethUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyGetCounters(
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsSetConfig(
+    tmUnitSelect_t phyUnitId,   
+    ptmbslPhyPcsConfig_t pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslPhyBist(		
+    tmUnitSelect_t                        phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: 
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyConfigBypass(
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/apollo_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/apollo_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/apollo_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/apollo_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,70 @@
+/*******************************************************************************
+*
+* Apollo/Inc/apollo_hdr.h
+*
+* Description: Apollo driver main compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_hdr_h__
+#define __apollo_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "inctypes_dvr.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkBus_iface.h"
+#include "ClnkMbx_dvr.h"
+#include "hw_z2_dvr.h"
+
+#include "control_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+#include "debug.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+#include "HostOS_proto.h"
+
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+
+
+#endif // __apollo_hdr_h__
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/Apollo_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/Apollo_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/Apollo_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/Apollo_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,12 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkBus_iface.c ***/
+
+/*** public prototypes from Src/Clnk_ctl_apollo.c ***/
+
+/*** public prototypes from Src/mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/control_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/control_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/control_context_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/control_context_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,70 @@
+/*******************************************************************************
+*
+* Apollo/Inc/control_context_apollo.h
+*
+* Description: Apollo Driver context definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __control_context_apollo_h__
+#define __control_context_apollo_h__
+
+
+// Control plane Context Structure
+struct _control_context
+{
+    void                *p_dg_ctx ;     // pointer to driver gpl context
+    void                *p_dk_ctx ;     // pointer to driver kernel context
+
+    SYS_UINTPTR         baseAddr;
+    Clnk_MBX_Mailbox_t  mailbox;
+    SYS_UINT8           mailboxInitialized;
+
+    SYS_UINT32          pSwUnsolQueue;      // Software unsolicited queue pointer
+    SYS_UINT32          swUnsolQueueSize;
+
+    void                *at_lock_link;          // spinlock for address translation
+    void                *ioctl_sem_link;
+    void                *mbx_cmd_lock_link;     // mailbox cmd spin lock - referenced in !GPL side
+    void                *mbx_swun_lock_link;    // mailbox sw unsol spin lock - referenced in !GPL side
+
+    SYS_UINT32          clnkThreadID;
+    SYS_UINT32          clnkThreadStop;
+
+    SYS_UINT8           clnk_ctl_in[   CLNK_CTL_MAX_IN_LEN];
+    SYS_UINT8           clnk_ctl_out[  CLNK_CTL_MAX_OUT_LEN];
+
+    SYS_UINT32          at3_base;   // Address translator 3 base address
+    ClnkDef_EvmData_t *         evmData;
+} ;
+
+typedef struct _control_context dc_context_t;
+
+#endif /* __control_context_apollo_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/driverversion_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/driverversion_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/driverversion_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/driverversion_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1 @@
+#define DRV_VERSION "0.0.0.0"
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/HostOS_Spec_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/HostOS_Spec_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/HostOS_Spec_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc/HostOS_Spec_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*
+* Apollo/Inc/HostOS_Spec_apollo.h
+*
+* Description: Host OS Specifications
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __HostOS_Spec_h__
+#define __HostOS_Spec_h__
+
+/*
+ * USER CONFIGURABLES
+ */
+
+#define DRV_NAME    "Apollo"
+
+
+// HostOS print control -- This is the lowest priority (numerically highest level) that will print
+#define HOST_OS_PRINTLOG_THRESHOLD   L_INFO
+
+// Mailbox Queue Constants
+#define CLNK_MBX_CMD_QUEUE_SIZE     32  // Must be a multiple of 2
+#define CLNK_MBX_SWUNSOL_QUEUE_SIZE 32  // Must be a multiple of 2
+#define SW_UNSOL_HW_QUEUE_SIZE      12  // set by HW
+
+#define CLNK_ETH_MRT_TRANSACTION_TIMEOUT    3         // in seconds
+
+#define TT_TASK_SLEEP       15  // in milliseconds
+
+#define DEBUG_IOCTL_PRIV    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_CMDQ    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_MEM     0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_UNSOLQ  0   // define for IOCTL debug prints
+
+#endif /* __HostOS_Spec_h__ */
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,133 @@
+################################################################################
+#                        Entropic Communications, Inc.                         #
+#                         Copyright (c) 2001-2008                              #
+#                          All rights reserved.                                #
+################################################################################
+
+################################################################################
+# This file is licensed under GNU General Public license, except that if you   #
+# have entered into a signed, written license agreement with Entropic covering #
+# this file, that agreement applies to this file instead of the GNU General    #
+# Public License.                                                              #
+#                                                                              #
+# This file is free software: you can redistribute and/or modify it under the  #
+# terms of the GNU General Public License, Version 2, as published by the Free #
+# Software Foundation, unless a different license applies as provided above.   #
+#                                                                              #
+# This program is distributed in the hope that it will be useful, but AS-IS and#
+# WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,#
+# FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, #
+# except as permitted by the GNU General Public License or another license     #
+# agreement between you and Entropic, is prohibited.                           #
+#                                                                              #
+# You should have received a copy of the GNU General Public License, Version 2 #
+# along with this file; if not, see <http://www.gnu.org/licenses/>.            #
+################################################################################
+
+# CandD module makefile
+#
+# Makefile for mini driver to drive Clock and Data lines       ##
+#
+
+# This Makefile has been simplified as much as possible, by putting all
+# generic material, independent of this specific directory, into
+# ../Rules.make. Read that file for details
+
+
+
+ifndef DVR_CWD
+    # Pick up full path to cwd because kernel build doesn't do relative paths.
+    # It also calls this makefile a couple of times so grab the cwd at the very
+    # beginning and save it in the environment.
+    export DVR_CWD := $(CURDIR)
+    #$(warning ~~~~~~~~~~~ top DVR_CWD=$(DVR_CWD))
+endif
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+DVR_INCLUDES  = -I $(DVR_CWD)/drivers/clink/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/CandD \
+                -I $(DVR_CWD)/drivers/clink/../Common/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/Common \
+                -I $(TOPDIR)/include/linux/
+else
+DRV_INCLUDES  = -I $(DVR_CWD)/Inc \
+                -I $(DVR_CWD)/../GPL/CandD \
+                -I $(DVR_CWD)/../Common/Inc \
+                -I $(DVR_CWD)/../GPL/Common
+endif
+
+olist := Src/Clnk_ctl_candd.o \
+         Src/ClnkBus_iface_candd.o \
+         ../Common/Src/ClnkIo.o \
+         ../Common/Src/ctx_setup.o \
+         ../Common/Src/ClnkMbx_dvr.o \
+         ../Common/Src/ClnkMbx_call.o \
+         ../Common/Src/ClnkIo_common.o \
+         ../Common/Src/ctx_abs.o \
+         ../Common/Src/util_dvr.o \
+         ../GPL/CandD/CandD.o \
+         ../GPL/CandD/mdio.o \
+         ../GPL/Common/gpl_ctx_setup.o \
+         ../GPL/Common/gpl_ctx_abs.o \
+         ../GPL/Common/hostos_linux.o
+
+
+EXTRA_CFLAGS +=  $(DRV_INCLUDES)
+EXTRA_CFLAGS += -DCANDD_DRVR_SUPPORT
+EXTRA_CFLAGS += -DCLNK_HOST_SEM
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+
+# clnkdvr components
+  CandDdvr-objs := $(olist)
+
+  # final LKM objects
+  obj-$(CONFIG_NET_CLINK) += CandDdvr.o
+  
+  ifeq ($(DEBUG),y)
+    DEBFLAGS = -O -g # "-O" is needed to expand inlines
+  else
+    DEBFLAGS = -O2
+  endif
+  
+  CFLAGS += $(DEBFLAGS)
+  CFLAGS += $(DVR_INCLUDES)
+  
+else # KERN 24
+export-objs :=
+obj-y       :=
+obj-n       :=
+obj-m       :=
+obj-        :=
+O_TARGET    := CandDdvr.ko
+obj-y       += $(olist)
+ 
+obj-$(CONFIG_NET_CLINK) += CandDdvr.ko
+
+include $(TOPDIR)/Rules.make
+endif # KERN 26
+
+EXTRA_CFLAGS_nostdinc += $(DEBFLAGS)
+##EXTRA_CFLAGS_nostdinc += -I../../inc -I.
+
+
+KSRC ?= /usr/src/linux
+
+# V=1 for verbose showing of commands
+kern:   clean
+	$(MAKE) modules -C $(KSRC) KBUILD_EXTMOD=`pwd` V=1
+
+clean:
+	@echo "CLEAN $(DVR_CWD)"
+	-$(MAKE) clean -C $(KSRC) KBUILD_EXTMOD=`pwd`
+	rm -f ../GPL/CandD/*.o 
+	rm -f Src/*.o 
+	rm -f ../Common/Src/*.o
+	rm -f ../GPL/Common/*.o 
+	rm -f *.ko
+
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/ClnkBus_iface_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/ClnkBus_iface_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/ClnkBus_iface_apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/ClnkBus_iface_apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Apollo/Src/ClnkBus_iface_apollo.c
+*
+* Description: Apollo Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data)
+{
+    clnk_read( vctx, addr & 0x0fffffff, data) ;
+}
+
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data)
+{
+    clnk_write( vctx, addr & 0x0fffffff, data) ;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/Clnk_ctl_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/Clnk_ctl_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/Clnk_ctl_apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Src/Clnk_ctl_apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,363 @@
+/*******************************************************************************
+*
+* Apollo/Src/Clnk_ctl_apollo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io);
+
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io)
+{
+    dc_context_t        *dccp = dk_to_dc( vdkcp ) ;
+    Clnk_MBX_Mailbox_t  *pMbx = &dccp->mailbox ;
+
+    switch (cmd)
+    {
+        case CLNK_CTL_NET_CARRIER_OK:
+            break;
+
+        case CLNK_CTL_RESET_DEVICE:
+            break;
+
+        case CLNK_CTL_STOP_DEVICE:
+            Clnk_Kern_Task_Kill((void *)dccp); 
+            break;
+
+        case CLNK_CTL_NET_CARRIER_ON:
+            break;
+        
+        case CLNK_CTL_NET_CARRIER_OFF:
+            // Turn off mailbox processing
+            pMbx->mbxOpen = SYS_FALSE;
+            Clnk_Kern_Task_Stop((void *)dccp);
+            break;
+        
+        case CLNK_CTL_SOC_INIT_BUS:
+            break; 
+        
+        case CLNK_CTL_SOC_BOOTED:
+        {
+            ClnkDef_dataPlaneVars_t *in = (void *)io->in;
+            int                     stat ;
+
+            if (io->in_len < sizeof( *in)) 
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+
+            if (pMbx->mbxOpen == SYS_TRUE)
+            {
+                pMbx->mbxOpen = SYS_FALSE;
+                Clnk_Kern_Task_Stop((void *)dccp);
+            }
+
+            //mailbox reset initialization
+            dccp->pSwUnsolQueue = in->unsol_msgbuf;
+            dccp->swUnsolQueueSize = SW_UNSOL_HW_QUEUE_SIZE;
+
+            if (dccp->pSwUnsolQueue != SYS_NULL)
+            {
+                // set mbxopen
+                stat = Clnk_MBX_Initialize( pMbx, dccp, CLNK_MBX_ETHERNET_TYPE );
+
+                if (stat != SYS_SUCCESS)
+                {
+                    HostOS_PrintLog(L_ERR, "Clink Reset MBX failed, stat=%d.\n", stat);
+                    return (stat);
+                }
+
+                dccp->mailboxInitialized = SYS_TRUE;
+
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+                         0, (SYS_UINTPTR)MbxReplyRdyCallback, (SYS_UINTPTR)dccp);
+                // set unsol mbox pointer
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_Q, 
+                         0, dccp->pSwUnsolQueue, dccp->swUnsolQueueSize);
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+                         0, (SYS_UINTPTR)MbxSwUnsolRdyCallback, (SYS_UINTPTR)dccp);
+
+                if(Clnk_Kern_Task_Init((void *)dccp) != 0)
+                    HostOS_PrintLog(L_ERR, "MBX open, Start TT task failed!\n");
+            }
+            else
+                HostOS_PrintLog(L_ERR, "ERROR: mailbox unsolicited queue is NULL!!\n");
+
+            break;
+        }
+        case CLNK_CTL_TC_DIC_INIT:
+        {
+            struct mb_return *mb = (void *)io->in; 
+ 
+            if (io->in_len < sizeof(*mb) )
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+            // mailbox reset initialization  
+            dccp->pSwUnsolQueue= mb->unsol_msgbuf; 
+            break;
+        }
+        case CLNK_CTL_HW_DESC_INIT:
+            break;
+        case CLNK_CTL_GET_SOC_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_SOC_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_SOC_STATUS, stat=%d.\n", *status);
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_GET_LINK_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_LINK_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_LINK_STATUS\n");
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_SET_MAC_ADDRESS:
+            break;
+        default:
+            return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Ethernet Module.
+*
+* Inputs:
+*       dccp      - Pointer to the control context
+*       option    - Driver option to control
+*       reg       - Register offset or pointer to register offsets
+*       val       - Register value or pointer to register values
+*       length    - Length of data for bulk data
+*
+* Outputs:
+*       CLNK_ETH_RET_CODE_SUCCESS
+*       CLNK_ETH_RET_CODE_GEN_ERR
+*       CLNK_ETH_RET_CODE_RESET_ERR
+*       CLNK_ETH_RET_CODE_LINK_DOWN_ERR
+*
+*******************************************************************************/
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length)
+{
+    dc_context_t *dccp = vdccp;
+    int status = CLNK_ETH_RET_CODE_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_ETH_CTRL_DO_CLNK_CTL:
+            status = do_clnk_ctl_dvr(dccp, (SYS_INT32)reg, (struct clnk_io *)val);
+            break;
+
+        default:
+            status = CLNK_ETH_RET_CODE_GEN_ERR;
+            break;
+    }
+    return (status);
+}
+
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio)
+{
+    SYS_UINT32 cmd = kifr->cmd;
+    SYS_UINT32 subcmd = (SYS_UINT32)kifr->param1;
+
+    switch (cmd)
+    {
+        case CLNK_MBX_ETH_DATA_BUF_CMD:
+        {
+            switch (subcmd)
+            {
+                case CLNK_CTL_GET_MY_NODE_INFO:
+                {
+                    ClnkDef_MyNodeInfo_t *out = (void *)kio->out;
+                    SYS_UINT32  rev1=0, rev2=0, rev3=0, rev4=0;
+                    
+                    HostOS_Sscanf(DRV_VERSION, "%d.%d.%d.%d", 
+                                  &rev1, &rev2, &rev3, &rev4);
+                    out->SwRevNum = ((rev1 & 0xff) << 24) | 
+                                    ((rev2 & 0xff) << 16) |
+                                    ((rev3 & 0xff) << 8)  | 
+                                    ((rev4 & 0xff) );
+                    break;
+                }
+            }
+            break;
+        }
+    }
+}
+
+/**
+* 
+*   Purpose:    Handle clnk_ctl operations originating from within the driver
+*               or from an ioctl.
+*
+*               io->in_len words are used as arguments to the function call.  
+*               Special case:
+*                 if io->in_len is 0, io->in is treated as a single argument 
+*                 rather than a pointer to an argument list.
+*
+*               Up to io->out_len words will be copied as the result of the call.
+*
+*   Imports:    dccp - ClnkEth context struct
+*               cmd  - CLNK_CTL_* command
+*               io   - Inputs and outputs for the CLNK_CTL command
+*
+*   Exports:    CLNK_ETH_RET_CODE_SUCCESS Success.
+*               CLNK_ETH_RET_CODE_GEN_ERR Failure.
+*
+*******************************************************************************/
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io)
+{
+    int ret = CLNK_ETH_RET_CODE_GEN_ERR ;
+    //SYS_UINT32 arg0 = io->in_len ? io->in[0] : ((SYS_UINTPTR)io->in);
+
+    /* cmd is processed by the common driver */
+    switch(cmd)
+    {
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_CTL_GET_BRIDGE_TABLE:
+        {
+            ClnkDef_BridgeTable_t *tbl = (void *)io->out;
+            SYS_UINT32 entries;
+
+            if(io->out_len < sizeof(*tbl))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+
+            entries = Cam_Get(&dccp->cam, &tbl->ent[0], arg0, BRIDGE_ENTRIES);
+            tbl->num_entries = entries;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if 1
+        case CLNK_CTL_GET_EVM_DATA:
+        {
+            ClnkDef_EvmData_t *out = (void *)io->out;
+
+            if (io->out_len < sizeof(*out))
+            {   // Bad Specification
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData)
+            {   // First time, alloc space and return
+                dccp->evmData = (ClnkDef_EvmData_t *)
+                    HostOS_Alloc(sizeof(ClnkDef_EvmData_t));
+                if (dccp->evmData)
+                {
+                    dccp->evmData->valid = 0;
+                    dccp->evmData->NodeId = 0;
+                }
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData->valid)
+            {   // Waiting for New Data
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else
+            {   // Actually got new data
+                HostOS_Memcpy((void *)out, dccp->evmData, sizeof(*out));
+                dccp->evmData->valid = 0;
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+            }
+            break;
+        }
+#endif
+#if 0
+        case CLNK_CTL_GET_EPP_DATA:
+        {
+            ClnkDef_EppData_t *out = (void *)io->out;
+
+            if ((!dccp->eppDataValid) || (io->out_len < sizeof(*out)))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+            HostOS_Memcpy((void *)out, &dccp->eppData, sizeof(*out));
+            dccp->eppDataValid = SYS_FALSE;
+            out->valid = 1;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS:
+        {
+            eclair_ValMboxHostCounts_t *out = (void*)io->out;
+
+            INCTYPES_SAFE_PTR_COPY(out, &clnkEth_valMboxHostCounts);
+
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+        }
+#endif
+    }
+
+    return(ret);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkBus_iface.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkBus_iface.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkBus_iface.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkBus_iface.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,42 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkBus_iface.h
+*
+* Description: Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNKBUS_IFACE_H__
+#define __CLNKBUS_IFACE_H__
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data);
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data);
+
+#endif /* __CLNKBUS_IFACE_H__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Clnk_ctl_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Clnk_ctl_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Clnk_ctl_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Clnk_ctl_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,47 @@
+/*******************************************************************************
+*
+* Common/Inc/Clnk_ctl_dvr.h
+*
+* Description: c.LINK control interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNK_CTL_DVR_H__
+#define __CLNK_CTL_DVR_H__
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io);
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length);
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio);
+
+#endif /* __CLNK_CTL_DVR_H__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/clnkiodefs.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/clnkiodefs.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/clnkiodefs.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/clnkiodefs.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,53 @@
+/*******************************************************************************
+*
+* Common/Inc/clnkiodefs.h
+*
+* Description: Driver IO definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __clnkiodefs_h__
+#define __clnkiodefs_h__
+
+
+
+// from sockios.h : #define SIOCDEVPRIVATE  0x89F0  /* to 89FF */
+
+#define SIOCCLINKDRV	(SIOCDEVPRIVATE+1)  // Control plane commands for the driver
+#define SIOCGCLINKMEM	(SIOCDEVPRIVATE+2)  // Reads registers/memory in c.LINK address space
+#define SIOCSCLINKMEM	(SIOCDEVPRIVATE+3)  // Sets registers/memory in c.LINK address space
+#define SIOCGCLNKCMD    (SIOCDEVPRIVATE+10) // pass thru c.LINK command that expects a response
+#define SIOCSCLNKCMD    (SIOCDEVPRIVATE+11) // pass thru c.LINK command that expects no response
+#define SIOCLNKDRV      (SIOCDEVPRIVATE+12) // a. Initialize Mailbox Queue Handler b. Get Unsolicited Message 
+#define SIOCHDRCMD	    (SIOCDEVPRIVATE+13)  // Resets the SoC , Control the diplexer switch etc.
+
+
+
+
+#endif /* __clnkiodefs_h__ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkMbx_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkMbx_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkMbx_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/ClnkMbx_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,408 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkMbx_dvr.h
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __ClnkMbx_dvr_h__
+#define __ClnkMbx_dvr_h__
+
+/*******************************************************************************
+*                             # i n c l u d e s                                *
+********************************************************************************/
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+// Common Mailbox Module Configuration
+//#define CLNK_MBX_AUTO_REPLY  // Auto reply (for debugging only)
+
+#define MAX_UNSOL_MSG       8
+#define MAX_MBX_MSG         100
+
+// Mailbox Type Constants
+#define CLNK_MBX_ETHERNET_TYPE  0
+#define CLNK_MBX_MPEG_TYPE      1
+
+// Mailbox Polling Rate
+#define MBX_POLL_TIMEOUT_IN_US    (20*1000)
+
+// Mailbox Queue Constants
+// queue sizes are in HostOS_Spec.h
+
+// Mailbox Command Code Definitions
+#define CLNK_MBX_CMD_CODE_OFFSET      0
+#define CLNK_MBX_CMD_CODE_MASK        0xff
+#define CLNK_MBX_CMD_TRANS_ID_OFFSET  8
+#define CLNK_MBX_CMD_TRANS_ID_MASK    0xff
+#define CLNK_MBX_CMD_VER_NUM_OFFSET   16
+#define CLNK_MBX_CMD_VER_NUM_MASK     0xf
+#define CLNK_MBX_CMD_PORT_OFFSET      20
+#define CLNK_MBX_CMD_PORT_MASK        0xf
+#define CLNK_MBX_CMD_LEN_OFFSET       24
+#define CLNK_MBX_CMD_LEN_MASK         0xff
+
+#define CLNK_MBX_SET_CMD(x)       (((x) & CLNK_MBX_CMD_CODE_MASK)     << \
+                                   CLNK_MBX_CMD_CODE_OFFSET)
+#define CLNK_MBX_SET_TRANS_ID(x)  (((x) & CLNK_MBX_CMD_TRANS_ID_MASK) << \
+                                   CLNK_MBX_CMD_TRANS_ID_OFFSET)
+#define CLNK_MBX_SET_VER_NUM(x)   (((x) & CLNK_MBX_CMD_VER_NUM_MASK)  << \
+                                   CLNK_MBX_CMD_VER_NUM_OFFSET)
+#define CLNK_MBX_SET_PORT(x)      (((x) & CLNK_MBX_CMD_PORT_MASK)     << \
+                                   CLNK_MBX_CMD_PORT_OFFSET)
+#define CLNK_MBX_SET_LEN(x)       (((x) & CLNK_MBX_CMD_LEN_MASK)      << \
+                                   CLNK_MBX_CMD_LEN_OFFSET)
+
+#define CLNK_MBX_GET_CMD(x)       (((x) >> CLNK_MBX_CMD_CODE_OFFSET) &   \
+                                   CLNK_MBX_CMD_CODE_MASK)
+#define CLNK_MBX_GET_CMD_LEN(x)   (((x) >> CLNK_MBX_CMD_LEN_OFFSET) &    \
+                                   CLNK_MBX_CMD_LEN_MASK)
+
+
+// Mailbox Reply Status Definitions
+#define CLNK_MBX_REPLY_TRANS_ID_OFFSET  0
+#define CLNK_MBX_REPLY_TRANS_ID_MASK    0xff
+#define CLNK_MBX_REPLY_STATUS_OFFSET    8
+#define CLNK_MBX_REPLY_STATUS_MASK      0xff
+#define CLNK_MBX_REPLY_ARG1_OFFSET      16
+#define CLNK_MBX_REPLY_ARG1_MASK        0xff
+#define CLNK_MBX_REPLY_LEN_OFFSET       24
+#define CLNK_MBX_REPLY_LEN_MASK         0xff
+
+#define CLNK_MBX_GET_TRANS_ID(x)  (((x) >> CLNK_MBX_REPLY_TRANS_ID_OFFSET) & \
+                                   CLNK_MBX_REPLY_TRANS_ID_MASK)
+#define CLNK_MBX_GET_STATUS(x)    (((x) >> CLNK_MBX_REPLY_STATUS_OFFSET)   & \
+                                   CLNK_MBX_REPLY_STATUS_MASK)
+#define CLNK_MBX_GET_ARG1(x)      (((x) >> CLNK_MBX_REPLY_ARG1_OFFSET)     & \
+                                   CLNK_MBX_REPLY_ARG1_MASK)
+#define CLNK_MBX_GET_REPLY_LEN(x) (((x) >> CLNK_MBX_REPLY_LEN_OFFSET)      & \
+                                   CLNK_MBX_REPLY_LEN_MASK)
+
+// CLNK Kernel Thread Status Definition
+#define CLNK_TASK_RUNNING       0
+#define CLNK_TASK_STOPPED       1
+#define CLNK_TASK_SLEEP         2
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// Mailbox Status Codes
+typedef enum
+{
+    CLNK_MBX_STATUS_SUCCESS = SYS_SUCCESS,
+
+    CLNK_MBX_STATUS_MAX  // This must always be last
+}
+CLNK_MBX_STATUS;
+
+// Mailbox Control Options
+typedef enum
+{
+    CLNK_MBX_CTRL_ENABLE_INTERRUPT,
+    CLNK_MBX_CTRL_DISABLE_INTERRUPT,
+    CLNK_MBX_CTRL_CLEAR_INTERRUPT,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_Q,
+    CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+    CLNK_MBX_CTRL_SET_UNSOL_RDY_CB,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+
+    CLNK_MBX_CTRL_MAX  // This must always be last
+}
+CLNK_MBX_CTRL_OPTIONS;
+
+// Command Codes
+typedef enum
+{
+    // Ethernet commands
+    CLNK_MBX_ETH_RESET_CMD                        = 0x00,   /* Alias: ETH_MB_RESET,                             */
+    CLNK_MBX_ETH_ALLOC_TX_FIFO_CMD                = 0x01,   /* Alias: ETH_MB_ALLOCATE_TX_FIFO,                  */
+    CLNK_MBX_ETH_ALLOC_RX_FIFO_CMD                = 0x02,   /* Alias: ETH_MB_ALLOCATE_RX_FIFO,                  */
+    CLNK_MBX_ETH_JOIN_MCAST_CMD                   = 0x03,   /* Alias: ETH_MB_JOIN_MULTICAST,                    */
+    CLNK_MBX_ETH_LEAVE_MCAST_CMD                  = 0x04,   /* Alias: ETH_MB_LEAVE_MULTICAST,                   */
+    CLNK_MBX_ETH_REGISTER_MCAST_CMD               = 0x05,   /* Alias: ETH_MB_REGISTER_MULTICAST,                */
+    CLNK_MBX_ETH_GET_STATS_CMD                    = 0x06,   /* Alias: ETH_MB_QUERY_RCV_STATS,                   */
+    CLNK_MBX_ETH_SET_RCV_MODE_CMD                 = 0x07,   /* Alias: ETH_MB_SET_RCV_MODE,                      */
+    CLNK_MBX_ETH_GET_RCV_MODE_CMD                 = 0x08,   /* Alias: ETH_MB_GET_RCV_MODE,                      */
+    CLNK_MBX_ETH_PUB_UCAST_CMD                    = 0x09,   /* Alias: ETH_MB_PUBLISH_UNICAST_ADDR,              */
+    CLNK_MBX_ETH_DEREGISTER_MCAST_CMD             = 0x0a,   /* Alias: ETH_MB_DEREGISTER_MULTICAST,              */
+    CLNK_MBX_ETH_DATA_BUF_CMD                     = 0x0b,   /* Alias: ETH_MB_DATA_BUF_CMD,                      */
+    CLNK_MBX_ETH_GET_STATUS_CMD                   = 0x0c,   /* Alias: ETH_MB_GET_STATUS,                        */
+    CLNK_MBX_ETH_SET_SW_CONFIG_CMD                = 0x0d,   /* Alias: ETH_MB_SET_SW_CONFIG,                     */
+    CLNK_MBX_ETH_ECHO_PROFILE_PROBE_RESPONSE      = 0x0e,   /* Alias: ETH_MB_ECHO_PROFILE_PROBE_RESPONSE,       */
+    CLNK_MBX_ETH_GET_CMD                          = 0x0f,   /* Alias: ETH_MB_GET_CMD,                           */
+    CLNK_MBX_ETH_SET_CMD                          = 0x10,   /* Alias: ETH_MB_SET_CMD,                           */
+    CLNK_MBX_ETH_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE = 0x11,  /* Alias: ETH_MB_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE, */
+    CLNK_MBX_ETH_SET_BEACON_POWER_LEVEL_CMD       = 0x12,   /* Alias: ETH_MB_SET_BEACON_POWER_LEVEL_CMD,        */
+    CLNK_MBX_ETH_QOS_ASYNC_REQ_BLOB               = 0x13,   /* Alias: ETH_MB_QOS_ASYNC_REQ_BLOB,                */
+    CLNK_MBX_ETH_QFM_RESP_BLOB                    = 0x14,   /* Alias: ETH_MB_QFM_RESP_BLOB,                     */
+    CLNK_MBX_ETH_SET_MIXED_MODE_ACTIVE            = 0x15,   /* Obsolete */
+    CLNK_MBX_ETH_GET_MIXED_MODE_ACTIVE            = 0x16,   /* Obsolete */
+    CLNK_MBX_ETH_QFM_CAM_DONE                     = 0x17,   /* Alias: ETH_MB_QFM_CAM_DONE,                      */
+    // MPEG commands
+    CLNK_MBX_MPEG_CREATE_INPUT_CHANNEL_CMD        = 0x20,
+    CLNK_MBX_MPEG_JOIN_CHANNEL_CMD                = 0x21,
+    CLNK_MBX_MPEG_JOIN_AS_PASSIVE_LISTENER_CMD    = 0x22,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REQUEST_CMD        = 0x23,
+    CLNK_MBX_MPEG_MODIFY_INPUT_CHANNEL_CMD        = 0x24,
+    CLNK_MBX_MPEG_MODIFY_OUTPUT_CHANNEL_CMD       = 0x25,
+    CLNK_MBX_MPEG_LEAVE_INPUT_CHANNEL_CMD         = 0x26,
+    CLNK_MBX_MPEG_LEAVE_OUTPUT_CHANNEL_CMD        = 0x27,
+    CLNK_MBX_MPEG_CREATE_OUTPUT_CHANNEL_CMD       = 0x28,
+    CLNK_MBX_MPEG_RESERVED_CMD_FROM               = 0x29,
+    CLNK_MBX_MPEG_RESERVED_CMD_TO                 = 0x2F,
+    CLNK_MBX_MPEG_READ_TRANSMIT_STATS_CMD         = 0x30,
+    CLNK_MBX_MPEG_READ_RECEIVE_STATS_CMD          = 0x31,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REPORT_REQUEST_CMD = 0x32,
+
+    CLNK_MBX_MAX_CMD  // This must always be last
+}
+CLNK_MBX_CMD_CODES;
+
+// Unsolicited message types
+typedef enum
+{
+    CLNK_MBX_UNSOL_MSG_UCAST_PUB                    = 0,     /* Alias: UNSOL_MSG_UCAST_PUB_TYPE               */
+    CLNK_MBX_UNSOL_MSG_EVM_DATA_READY               = 1,     /* Alias: UNSOL_MSG_EVM_DATA_READY_TYPE          */
+    CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE           = 2,     /* Alias: UNSOL_MSG_ECHO_PROFILE_PROBE           */
+    CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS             = 3,     /* Alias: UNSOL_MSG_ADMISSION_STATUS             */
+    CLNK_MBX_UNSOL_MSG_BEACON_STATUS                = 4,     /* Alias: UNSOL_MSG_BEACON_STATUS                */
+    CLNK_MBX_UNSOL_MSG_RESET                        = 5,     /* Alias: UNSOL_MSG_MAC_RESET                    */
+    CLNK_MBX_UNSOL_MSG_TABOO_INFO                   = 6,     /* Alias: UNSOL_MSG_TABOO_INFO                   */
+    CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC               = 7,     /* Alias: UNSOL_MSG_CHK_MAC_ADDRESS              */
+    CLNK_MBX_UNSOL_MSG_NODE_ADDED                   = 8,     /* Alias: UNSOL_MSG_NODE_ADDED                   */
+    CLNK_MBX_UNSOL_MSG_NODE_DELETED                 = 9,     /* Alias: UNSOL_MSG_NODE_DELETED                 */
+    CLNK_MBX_UNSOL_MSG_UCAST_UNPUB                  = 10,    /* Alias: UNSOL_MSG_UCAST_UNPUB_TYPE             */
+    CLNK_MBX_UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  = 11,    /* Alias: UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  */
+    CLNK_MBX_UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    = 12,    /* Alias: UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    */
+    CLNK_MBX_UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST = 13,    /* Alias: UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST */
+    CLNK_MBX_UNSOL_MSG_FSUPDATE                     = 14,    /* Alias: UNSOL_MSG_FSUPDATE                     */
+    CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY           = 20,    /* Alias: UNSOL_MSG_ADD_CAM_ENTRY                */
+    CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      = 21,    /* Alias: UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      */
+
+#if ECFG_FLAVOR_VALIDATION==1
+    CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT               = 22,    /* Alias: UNSOL_MSG_VAL_ISOC_EVENT               */
+#endif
+
+    CLNK_MBX_MAX_UNSOL_MSG_TYPE // This must always be last
+}
+CLNK_MBX_UNSOL_MSG_TYPES;
+
+// Maximum Message Structure
+typedef struct
+{
+    SYS_UINT32 msg[MAX_MBX_MSG];
+}
+Clnk_MBX_MaxMsg_t;
+
+// Ethernet Command Structure
+typedef struct
+{
+    SYS_UINT32 cmd;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthCmd_t;
+
+// Ethernet Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthReply_t;
+
+// MPEG Command Structure
+typedef struct
+{
+    SYS_UINT32  cmd;
+    SYS_UINT32  param[7];
+}
+Clnk_MBX_MpegCmd_t;
+
+// MPEG Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param;
+}
+Clnk_MBX_MpegReply_t;
+
+// Generic Mailbox Message Structure
+typedef struct
+{
+    union
+    {
+        Clnk_MBX_MaxMsg_t           maxMsg;
+        SYS_UINT32                  cmdCode;
+        SYS_UINT32                  replyStatus;
+
+        // Ethernet mailbox command
+        Clnk_MBX_EthCmd_t           ethCmd;
+
+        // Ethernet mailbox reply
+        Clnk_MBX_EthReply_t         ethReply;
+
+        // MPEG mailbox command
+        Clnk_MBX_MpegCmd_t          mpegCmd;
+
+        // MPEG mailbox reply
+        Clnk_MBX_MpegReply_t        mpegReply;
+    }
+    msg;
+}
+Clnk_MBX_Msg_t;
+
+// Reply and Unsolicited Ready Callback Function
+typedef void (*Clnk_MBX_RdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+typedef int (*Clnk_MBX_SwUnsolRdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+
+// Command Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t          sendMsg;
+    Clnk_MBX_Msg_t          rcvMsg;
+    SYS_UINT8               transID;
+    volatile int            isReplyRdy;
+    volatile int            isReplyTimedOut;
+    void                    *msg_wqt ;
+ //   struct hostos_timer     msg_timer;
+ //   wait_queue_head_t       msg_wq;
+} Clnk_MBX_CmdQueueEntry_t;
+
+// Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+    SYS_UINT8      transID;
+}
+Clnk_MBX_UnsolQueueEntry_t;
+
+// Sw Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+}
+Clnk_MBX_SwUnsolQItem_t;
+
+// Software unsolicited Queue Entry Structure
+typedef struct
+{
+    SYS_UINT32     ownership;
+    SYS_UINT32     transID;
+    SYS_UINT32     msg[MAX_UNSOL_MSG];
+}
+Clnk_MBX_SwUnsolQueueEntry_t;
+
+
+// Mailbox Structure
+typedef struct
+{
+    void                          *dc_ctx; // driver control ctx
+    SYS_UINT32                    type;
+    SYS_UINT32                    mbxOpen;
+
+    // Callback functions
+    Clnk_MBX_RdyCallback          replyRdyCallback;
+    void                          *replyParam;
+    Clnk_MBX_SwUnsolRdyCallback   swUnsolRdyCallback;
+    void                          *swUnsolParam;
+
+    // Command queue
+    Clnk_MBX_CmdQueueEntry_t      cmdQueue[CLNK_MBX_CMD_QUEUE_SIZE];
+    SYS_UINT8                     cmdHeadIndex;   // dequeue point
+    SYS_UINT8                     cmdTailIndex;   // enqueue point
+    SYS_UINT8                     cmdCurrTransID;
+    void                          *mbx_lock;      // referenced here from GPL side
+
+    // Software unsolicited queue
+    SYS_UINT32                    swUnsolQueueSlaveMap;
+    SYS_UINT32                    pSwUnsolQueue; // ptr to array of Clnk_MBX_SwUnsolQueueEntry_t in pci space
+    SYS_UINT32                    swUnsolQueueSize;
+    SYS_UINT8                     swUnsolReadIndex;
+    SYS_UINT8                     swUnsolCurrTransID;
+    Clnk_MBX_SwUnsolQItem_t       swUnsolQueue[CLNK_MBX_SWUNSOL_QUEUE_SIZE];
+    SYS_UINT8                     swUnsolHeadIndex;
+    SYS_UINT8                     swUnsolTailIndex;
+    SYS_UINT8                     swUnsolCount;
+    SYS_UINT8                     swUnsolOverrun;
+    void                          *swUnsolLock;     // referenced here from GPL side
+
+    // Register offsets and bit masks
+    SYS_UINT32                    writeMbxCsrOffset;
+    SYS_UINT32                    readMbxCsrOffset;
+    SYS_UINT32                    writeMbxRegOffset;
+    SYS_UINT32                    readMbxRegOffset;
+    SYS_UINT32                    writeMbxSize;
+    SYS_UINT32                    readMbxSize;
+}
+Clnk_MBX_Mailbox_t;
+
+
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type);
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length);
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus);
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len);
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf);
+                   
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs);
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx );
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+int Clnk_Kern_Task_Init(void *data);
+int Clnk_Kern_Task_Stop(void *data);
+int Clnk_Kern_Task_Kill(void *data);
+#endif
+
+#endif /* __ClnkMbx_dvr_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/com_abs_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/com_abs_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/com_abs_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/com_abs_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,13 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/Clnk_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_abs.c ***/
+void *dc_to_dg( void *dccp );
+void *dc_to_dk( void *dccp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/common_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/common_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/common_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/common_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1417 @@
+/*******************************************************************************
+*
+* Common/Inc/common_dvr.h
+*
+* Description: Driver stuff shared across modules
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __common_dvr_h__
+#define __common_dvr_h__
+
+#include "inctypes_dvr.h"
+#include "entropic-config.h"
+
+/***************** definitions originally from ClnkDefs.h ********************/
+#define NETWORK_TYPE_ACCESS      ECFG_NETWORK_ACCESS
+#define NETWORK_TYPE_MESH        ECFG_NETWORK_MESH
+#define NODE_TYPE_ACCESS_HEADEND ECFG_NODE_HEADEND
+#define NODE_TYPE_ACCESS_CPE     ECFG_NODE_CPE
+#define NODE_TYPE_ACCESS_TCPE    ECFG_NODE_TCPE
+#define NODE_TYPE_MESH_MOCA     (ECFG_NETWORK_MESH && ECFG_NODE_MOCA)
+
+#if ! defined(NETWORK_TYPE_ACCESS)
+#define NETWORK_TYPE_ACCESS                0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFS)
+#define HAS_FAST_IMPLEMENTATION_OF_FFS     0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFZ)
+#define HAS_FAST_IMPLEMENTATION_OF_FFZ     0
+#endif
+
+#if ! defined(CLNK_ETH_PER_PACKET)
+#define CLNK_ETH_PER_PACKET                1
+#endif
+
+#if ! defined(ECFG_FLAVOR_VALIDATION)
+#define ECFG_FLAVOR_VALIDATION             0
+#endif
+
+#if ! defined(FEATURE_IQM)
+#define FEATURE_IQM                        0
+#endif
+
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project.
+ */
+#if ! defined(FEATURE_PUPQ_NMS)
+#define FEATURE_PUPQ_NMS                   1
+#endif
+
+/**
+ * This marks code added to round out last minute customer requests. 
+ */
+#if ! defined(FEATURE_PUPQ_NMS_QUICK_APIS)
+#define FEATURE_PUPQ_NMS_QUICK_APIS        1
+#endif
+
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project- 
+ * new configuration items.  It is not tested disabled.
+ */
+#if ! defined(FEATURE_PUPQ_NMS_CONF)
+#define FEATURE_PUPQ_NMS_CONF              1
+#endif
+
+/**
+ * This marks code (in progress) used to collect items using 
+ * the L2ME Gather Queryable operation
+ */
+#if ! defined(FEATURE_PUPQ_GQ)
+#define FEATURE_PUPQ_GQ                    1
+#endif
+
+/**
+ * This marks code used to collect per-node statistics on receiver
+ * received packet errors, both sync and async.
+ */
+#if ! defined(FEATURE_PUPQ_RX_NODE_STATS)
+#define FEATURE_PUPQ_RX_NODE_STATS         1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_QOS_CCPU_ENTRY)
+#define FEATURE_QOS_CCPU_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_FMR_ENTRY)
+#define FEATURE_CCPU_FMR_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_GENERIC_L2ME_ENTRY)
+#define FEATURE_CCPU_GENERIC_L2ME_ENTRY    1
+#endif
+
+/** 
+ * Marks code that should be COMPLETELY removed from the codebase.  This
+ * variable should absolutely never set to 1.  The only reason this code
+ * remains in the codebase is that several projects must merge to a common
+ * tree; until this merge has happened, the diffs created by deletions
+ * would slow parallel progress.
+ */
+#define NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING  0
+
+#if 0                                        \
+    || ECFG_BOARD_PC_DVT2_PCI_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_MII_ZIP2==1         \
+    || ECFG_BOARD_PC_DVT_TMII_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_GMII_ZIP2==1        \
+    || ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2==1  \
+    || ECFG_BOARD_ECB_PCI_ZIP2==1            \
+    || ECFG_BOARD_PC_PCI_ZIP2==1             \
+    || ECFG_BOARD_PC_PCI_ZIP1==1             \
+    || ECFG_BOARD_ECB_ROW==1                 \
+    || ECFG_BOARD_PC_PCIE_MAVERICKS==1        \
+    || ECFG_BOARD_ECB_4M_L3==1                 \
+    || ECFG_BOARD_ECB_3M_L3==1               \
+    || 0
+#define L2_DONGLE 0
+#else
+#error NOT A KNOWN BOARD!
+#endif
+
+/**
+ * Warning! this value must exactly match the value used in the ccpu image that
+ * was compiled using this file.
+ */
+#if   (NETWORK_TYPE_ACCESS)
+    #define MAX_NUM_NODES        32
+    #error
+#elif (NETWORK_TYPE_MESH)
+
+/* Protem pQOS/NMS specific.  Set to 8 for
+ * PROTEM builds or 16 for ADVANCED builds. 
+ */
+#if (ECFG_FLAVOR_PRODUCTION_PROTEM)
+    #define MAX_NUM_NODES   8
+#else
+    #define MAX_NUM_NODES   16
+#endif
+
+#else
+#error unsupported.
+#endif
+
+/* 
+    log levels for HostOS_PrintLog 
+    0 is highest priority
+
+    See also:
+        HOST_OS_PRINTLOG_THRESHOLD 
+
+ */
+enum
+{
+    L_EMERG      ,
+    L_ALERT      ,
+    L_CRIT       ,
+    L_ERR        ,
+    L_WARNING    ,
+    L_NOTICE     ,
+    L_INFO       ,
+    L_DEBUG      ,
+};
+
+
+// rudimentary back-cast macro
+#ifndef offsetof
+#define offsetof(x, y)          ((int)&(((x *)SYS_NULL)->y))
+#endif
+
+
+// OS timer expiration callback function
+typedef void (*timer_function_t)(unsigned long);
+
+// Wait Q Timer exit condition function
+typedef int (*HostOS_wqt_condition)(void *vp);
+
+// Wait Q exit condition function
+typedef int (*HostOS_waitq_condition)(void *vp);
+
+
+/*******************************************************************************
+*           G L O B A L   B I T F I E L D   M A N I P U L A T O R S            *
+********************************************************************************/
+
+/**
+ * Utility to create a mask given a number of bits
+ */
+#define CLNKDEFS_BITMASK(num_bits)   \
+   ((unsigned)(((num_bits) >= 32) ? 0xFFFFFFFF : ((1 << (num_bits)) - 1)))
+
+/**
+ * Utility to create a shifted mask given a high and low bit position
+ */
+#define CLNKDEFS_SHIFTED_BITMASK(bit_high, bit_low) \
+   ((unsigned)(CLNKDEFS_BITMASK(1 + (bit_high) - (bit_low)) << (bit_low)))
+
+/**
+ * Utility to create a value that alters a particular set of bits
+ * within a processor word
+ */
+#define CLNKDEFS_SUBSTITUTE_FIELD(original, bit_high, bit_low, new_field)                 \
+((unsigned)(                                                                              \
+    ((original)                  & (~CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))) |  \
+     (((new_field) << (bit_low)) &   CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))     \
+)          )
+
+/**
+ * Utility that alters an LVALUE with a substituted field.
+ */
+#define CLNKDEFS_REPLACE_FIELD(lvalue, bit_high, bit_low, new_field)            \
+   do { ((lvalue)) = CLNKDEFS_SUBSTITUTE_FIELD((lvalue), (bit_high),            \
+                                             (bit_low), (new_field));           \
+   } while (0)
+
+/**
+ * Utility to extract a particular field from a word
+ */
+#define CLNKDEFS_EXTRACT_FIELD(original, bit_high, bit_low) \
+     ((unsigned)(((original) & CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low))) >> (bit_low)))
+
+// Firmware download constants
+#if ECFG_CHIP_ZIP1
+#define ISPRAM_START    0xb0040000
+#define DSPRAM_START    0x80000000
+#define ISPRAM_SIZE     0x20000
+#define DSPRAM_SIZE     0x10000
+#elif ECFG_CHIP_ZIP2
+#define ISPRAM_START    0x0c040000
+#define DSPRAM_START    0x0c000000
+#define ISPRAM_SIZE     0x20000
+#define DSPRAM_SIZE     0x18000
+#elif ECFG_CHIP_MAVERICKS
+#define ISPRAM_START    0x0c040000
+#define DSPRAM_START    0x0c000000
+#define ISPRAM_SIZE     0x30000
+#define DSPRAM_SIZE     0x20000
+#endif
+
+/* for hw_z2_pci and clnkEth */
+#define SYS_GET_PARAM(x, p, mask, offset) (((x)->p >> (offset)) & (mask))
+#define SYS_SET_PARAM(x, p, mask, offset, val) do \
+            { \
+                (x)->p = ((x)->p & ~((mask) << (offset))) | \
+                         (((val) & (mask)) << (offset)); \
+            } while(0)
+#define WR_LINEBUF_PDU_SIZE(x, y)   SYS_SET_PARAM((x), packed_0, 0xffff, 0, (y))
+#define WR_LINEBUF_ENTRY_SIZE(x, y) SYS_SET_PARAM((x), packed_0, 0xff, 16, (y))
+#define WR_LINEBUF_PTR_MODE(x, y)   SYS_SET_PARAM((x), packed_0, 0x1, 24, (y))
+/* end for hw_z2_pci and clnkEth */
+
+#define NUM_DEBUG_REG               8
+#define NUM_MAILBOX_RD_REG          8
+#define NUM_MAILBOX_WR_REG          8
+#define NUM_MAILBOX_REG             (NUM_MAILBOX_RD_REG + NUM_MAILBOX_WR_REG)
+
+/// Returns the SoC memory address of element 'x' in dev_shared
+#define DEV_SHARED(x) ((SYS_UINT32)(SYS_UINTPTR)(&(((struct shared_data *)DSPRAM_START)->x)))
+
+struct clnk_hw_params
+{
+    SYS_UINT32              numRxHostDesc;
+    SYS_UINT32              numTxHostDesc;
+#if ECFG_CHIP_ZIP1
+    SYS_UINT32              *minRxLens;
+#endif
+    void                    *at_lock;
+};
+
+typedef struct
+{
+    SYS_UINT32      zip_major;
+    SYS_UINT32      zip_minor;
+    SYS_UINT32      datapath;
+}
+ClnkDef_ZipInfo_t;
+
+//linebuffer descriptor
+struct linebuf
+{
+    SYS_UINT32      packed_0;       /* offset 0x0 */
+    SYS_UINT32      n_entries;      /* offset 0x4 */
+    SYS_UINT32      buffer_base;    /* offset 0x8 */
+    SYS_UINT32      buffer_len;     /* offset 0xc */
+    SYS_UINT32      entry_wptr;     /* offset 0x10 */
+    SYS_UINT32      entry_rptr;     /* offset 0x14 */
+    SYS_UINT32      entry_windex;   /* offset 0x18 */
+    SYS_UINT32      entry_rindex;   /* offset 0x1c */
+    SYS_UINT32      packed_8;       /* offset 0x20 */
+};
+
+#define BRIDGE_ENTRIES      192
+#if ECFG_CHIP_MAVERICKS
+#define CAM_ENTRIES         160
+#else
+#define CAM_ENTRIES         128
+#endif
+#define DATABUF_CAM_ENTRIES 16
+
+typedef struct
+{
+    SYS_UINT32 macAddrHigh;
+    SYS_UINT32 macAddrLow;
+}
+ClnkDef_BridgeEntry_t; 
+
+/* dumps out a portion of the software CAM (ClnkCam.c) */
+typedef struct
+{
+    SYS_UINT32 num_entries;
+    ClnkDef_BridgeEntry_t   ent[BRIDGE_ENTRIES];
+}
+ClnkDef_BridgeTable_t;
+
+#define NUM_TX_PRIO         3
+// clnk_set_eth_fifo_size struct
+typedef struct
+{
+    SYS_UINT32 tx_prio[NUM_TX_PRIO];
+}
+ClnkDef_TxFifoCfg_t;
+
+#if FEATURE_IQM
+// Increase the trace buffer size when DEBUG_DUMP_FFT_VALUES enabled in ccpu code (iqm.h)
+#define CLNK_DEF_TRACE_ENTRIES      /*2505*/ 50
+#else
+#define CLNK_DEF_TRACE_ENTRIES      50
+#endif
+typedef struct
+{
+    SYS_UINT32 ctc_time;
+    SYS_UINT32 info1;
+    SYS_UINT32 info2;
+}
+ClnkDef_TraceEntry_t;
+
+typedef struct
+{
+    SYS_UINT32 dropped;
+    SYS_UINT32 ent_valid;
+    ClnkDef_TraceEntry_t ent;
+}
+ClnkDef_TraceBuf_t;
+
+/*
+ * Frequency Scanning (FS) configuration data
+ */
+typedef struct 
+{
+    SYS_UINT32    scan_mask;
+    SYS_UINT32    prod_mask;
+    SYS_UINT32    chanl_mask;
+    SYS_UINT32    chanl_plan;
+    SYS_UINT32    bias_and_max_passes;
+    SYS_UINT32    cm_ratio;
+    SYS_UINT32    taboo_info;
+    SYS_INT32     lof;
+} fs_config_t;
+
+/*
+ * Frequency Scanning status flags
+ */
+typedef struct
+{
+    SYS_UINT8    lof_avail:1;     // LOF available (1:true, 0:false) 
+    SYS_UINT8    lof_scan:1;      // LOF scan status (1:true, 0:false)
+    SYS_UINT8    single_chanl:1;  // Single channel prod mask (1:true, 0:false)
+    SYS_UINT8    listen_once:1;   // Listen only channel (1:true, 0:false)
+    SYS_UINT8    fs_reset:1;      // FS state machine reset (1:true, 0:false)
+    SYS_UINT8    reserved:3;      // Reserved for future usage
+} fs_flags_t;
+
+/*
+ * Frequency Scanning context data
+ */
+typedef union 
+{
+    SYS_UINT32    word[8];
+    struct 
+    {
+        fs_flags_t   flags;         // FS status flags
+        SYS_UINT8    scan_count;    // Number of full scans
+        SYS_INT8     scan_dir;      // Scan direction (+1:lo->hi, -1:hi->lo)
+        SYS_INT8     tune_idx;      // Tuned freq index
+        SYS_INT8     last_idx;      // Last freq index
+        SYS_INT8     low_idx;       // lowest freq index for scan in single dir
+        SYS_INT8     high_idx;      // highest freq index for scan in single dir
+        SYS_INT8     lof_idx;       // LOF index
+        SYS_UINT8    fs_state;      // Current FS state
+        SYS_UINT8    upd_cause;     // FS state update cause
+        SYS_UINT16   hop_count;     // Running count of frequency hops
+        SYS_UINT32   chanl_qual[2]; // Channel quality array
+    } members;
+} fs_context_t;
+
+/** Structure for storing cached pqos maintenace values in shared
+ *  data. */
+typedef struct {
+    SYS_UINT32 ioc_nodemask;
+    SYS_UINT32 allocated_stps;
+    /** Top 16 bits store the allocated txps received (but thresholded
+     *  in the error event that the value exceeded 16 bits) and the 
+     *  bottom 16 bits store the count of maintenance events since
+     *  joining the network. */
+    SYS_UINT32 trunc_alloc_txps_hi__ctr_lo;
+} shared_qos_maint_cache_t;
+
+#if FEATURE_PUPQ_NMS_CONF
+// pqos NMS initialization structure.
+typedef struct
+{
+    /** This member contains the vendor id 16 bit value in the high
+     * 16 bits and the personality in the low 16 bits. Saves CCPU space. */
+    SYS_UINT32 mfrVendorIdHi_personalityLo;
+    SYS_UINT32 mfrHwVer;
+    SYS_UINT32 mfrSwVer;
+} pupq_nms_init_context_t;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+// per-node based statistics
+typedef struct
+{
+    /** Number of received MoCA transmissions from this node which were
+     *  NOT correctly received or processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_error;
+
+    /** Number of received MoCA transmissions from this node which were
+     *  correctly received and processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_good;
+}                           clnkdefs_per_node_stats_t;
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_per_node_stats_t, 8);
+
+typedef struct
+{
+    clnkdefs_per_node_stats_t nodes[MAX_NUM_NODES];
+}                           clnkdefs_all_node_stats_t;
+#if MAX_NUM_NODES == 16
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 128);
+#else
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 64);
+#endif
+#endif /* FEATURE_PUPQ_RX_NODE_STATS */
+
+// shared data between the host and SoC (Zip2 only)
+struct shared_data
+{
+#if !ECFG_CHIP_ZIP1
+    SYS_UINT32      mailbox_reg[NUM_MAILBOX_REG];
+    SYS_UINT32      debug_reg[NUM_DEBUG_REG];
+    SYS_UINT32      read_csr_reg;
+    SYS_UINT32      write_csr_reg;
+
+    SYS_UINT32      linebuf_host_rx;
+    SYS_UINT32      linebuf_host_tx[4]; /* 4 priorities */
+
+    SYS_UINT32      mac_addr_hi;
+    SYS_UINT32      mac_addr_lo;
+
+    SYS_UINT32      rx_active;
+#endif /* !ECFG_CHIP_ZIP1 */
+
+    SYS_UINT32      trace_dropped;
+
+    fs_config_t     fs_cfg;                // Frequency Scan config parameters
+    fs_context_t    fs_ctx;                // Frequency Scan context data
+
+    SYS_UINT32      target_phy_rate;
+    SYS_UINT32      node_adm_req_rx_ctr;
+    SYS_UINT32      node_link_up_event_ctr;
+    SYS_UINT32      lmo_advanced_ctr;
+    SYS_UINT32      ingr_routing_conflict_ctr;
+    /** This counter counts in tenths of a second. */
+    SYS_UINT32      node_link_time_bad_deciseconds;
+
+#if L2_DONGLE
+    SYS_UINT32      version_id; 
+#endif  
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+    /** ONLY MODIFIED BY CCPU.  Kept here as a convenience since
+     *  the host may want to do a fast read of these statistics without
+     *  mailbox op.  */
+    clnkdefs_all_node_stats_t  all_node_stats;
+#endif
+
+#if FEATURE_PUPQ_NMS_CONF
+    pupq_nms_init_context_t  pni_ctx;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_NMS_QUICK_APIS
+    SYS_UINT32      pqos_mode;
+    SYS_UINT32      hard_reset;
+    /* added shared_data entries 
+     *   vinirn is (UINT16 vendor_id << 16) | (UINT8 node_id << 8) | UINT8 request_number
+     */
+    SYS_UINT32      vinirn;    // vendor id, node id, request number
+
+    /* eventually fit this in a byte somewhere else in shared_data 
+     * Both nmspush_change_ctr and nmspush_change_ack are 
+     * each only 8 bits 
+     */
+    SYS_UINT32      nmspush_change_ctr;
+    SYS_UINT32      nmspush_change_ack;
+    SYS_UINT32      dword_array[6];
+#endif
+
+#if FEATURE_IQM
+    SYS_UINT32      iqm_debug_mask1;
+    SYS_UINT32      iqm_debug_mask2;
+    SYS_UINT32      iqm_debug_mask3;
+#endif
+
+    ClnkDef_TraceEntry_t trace_buf[CLNK_DEF_TRACE_ENTRIES];
+
+    shared_qos_maint_cache_t  qos_maint_cache;
+};
+
+#define FEATURE_ECLAIR                     1
+
+#if (NETWORK_TYPE_ACCESS)
+    #define FEATURE_FREQ_SCAN              0      // 0: disable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    0
+    #define FEATURE_QOS                    0
+    #define ENTROPIC_ECLAIR                0
+    #define BROADCAST_LMO                  0
+#else
+    #define FEATURE_FREQ_SCAN              1      // 1: enable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    1
+    #define FEATURE_QOS                    1
+    #define ENTROPIC_ECLAIR                1
+    #define BROADCAST_LMO                  1
+
+    /** Expect this flag to be set from the build file *.bld */
+    #ifndef FEATURE_ECLAIR_WHITE_BOX_TEST
+        #define FEATURE_ECLAIR_WHITE_BOX_TEST  0
+    #endif
+
+#endif
+
+// C.Link Ethernet Statistics Structureyy
+typedef struct
+{
+    // Driver stats
+    SYS_UINT32 drvSwRevNum;
+    SYS_UINT32 embSwRevNum;
+    SYS_UINT32 upTime;
+    SYS_UINT32 linkUpTime;
+    SYS_UINT32 socResetCount;       // Number of C.Link resets
+    SYS_UINT32 socResetHistory;     // Reason for last 4 resets
+
+    // Transmit and recieve stats
+    SYS_UINT32 rxPackets;           // Total packets received
+    SYS_UINT32 txPackets;           // Total packets transmitted
+    SYS_UINT32 rxBytes;             // Total bytes received
+    SYS_UINT32 txBytes;             // Total bytes transmitted
+    SYS_UINT32 rxPacketsGood;       // Packet receive with no errors
+    SYS_UINT32 txPacketsGood;       // Packet transmitted with no errors
+    SYS_UINT32 rxPacketErrs;        // Packets received with errors
+    SYS_UINT32 txPacketErrs;        // Packets transmitted with errors
+    SYS_UINT32 rxDroppedErrs;       // Packets dropped with no host buffers
+    SYS_UINT32 txDroppedErrs;       // Packet dropped with no host buffers
+    SYS_UINT32 rxMulticastPackets;  // Total multicast packets received
+    SYS_UINT32 txMulticastPackets;  // Total multicast packets transmitted
+    SYS_UINT32 rxMulticastBytes;    // Total multicast bytes received
+    SYS_UINT32 txMulticastBytes;    // Total multicast bytes transmitted
+
+    // Detailed receive errors
+    SYS_UINT32 rxLengthErrs;
+    SYS_UINT32 rxCrc32Errs;         // Packets rx'd with CRC-32 errors
+    SYS_UINT32 rxFrameHeaderErrs;   // Packets rx'd with frame header errors
+    SYS_UINT32 rxFifoFullErrs;      // Packets rx'd with FIFO full
+    SYS_UINT32 rxListHaltErr[3];
+
+    // Detailed transmit errors
+    SYS_UINT32 txCrc32Errs;         // Packets tx'd with CRC-32 errors
+    SYS_UINT32 txFrameHeaderErrs;   // Packets tx'd with frame header errors
+    SYS_UINT32 txFifoFullErrs;      // Packets tx'd with FIFO full
+    SYS_UINT32 txFifoHaltErr[8];
+}
+ClnkDef_EthStats_t;
+
+// EVM Data Structure
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[256];
+}
+ClnkDef_EvmData_t;
+
+// Echo Profile Structures
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[(256 + 3*(256+64))];    /* 0x4c0 words = 4864 bytes */
+}
+ClnkDef_EppData_t;      
+
+//values returned to the host in the initial mailbox
+struct mb_return
+{
+    SYS_UINT32 linebuf0_soc_tx;         /* word 0 */
+    SYS_UINT32 linebuf1_soc_tx;         /* word 1 */
+    SYS_UINT32 linebuf2_soc_tx;         /* word 2 */
+    SYS_UINT32 extra_pkt_mem;           /* word 3 */
+    SYS_UINT32 linebuf3_soc_tx;         /* word 4 */
+    SYS_UINT32 linebuf_soc_rx;          /* word 5 */
+    SYS_UINT32 tx_did;                  /* word 6 */
+    SYS_UINT32 rx_did;                  /* word 7 */
+    SYS_UINT32 tx_gphy_desc;            /* word 8 */
+    SYS_UINT32 rx_gphy_desc;            /* word 9 */
+    SYS_UINT32 pd_queue_0;              /* word 10 */
+    SYS_UINT32 pd_queue_1;              /* word 11 */
+    SYS_UINT32 pd_queue_2;              /* word 12 */
+    SYS_UINT32 pd_queue_3;              /* word 13 */
+    SYS_UINT32 pd_entries;              /* word 14 */
+    SYS_UINT32 unsol_msgbuf;            /* word 15 - also the semaphore */
+};
+////////// END defines needed by ClnkEth.h
+
+////////// defines for ClnkCam
+
+#define    CLNKMAC_BCAST_ADDR      0x3F
+#define    QOS_MAX_FLOWS           24
+
+/* Enums for PQOS Classification mode */
+enum {
+    CLNK_PQOS_MODE_UNKNOWN       = -1,
+    CLNK_PQOS_MODE_MOCA_11       = 0,
+    CLNK_PQOS_MODE_PUPQ_CLASSIFY = 1,
+};
+typedef SYS_UINT32 clnk_pqos_mode_t;
+
+////////// end defines for ClnkCam
+
+////////// defines for eth_ioctl
+
+// Software Configuration Bits
+#define CLNK_DEF_SW_CONFIG_SOFTCAM_BIT                 (1 << 14)
+#define CLNK_DEF_SW_CONFIG_AGGREGATION_METHOD_BIT      (1 << 24)  // used in hw_z2_pci.c
+                                                                   
+// SOC Status Values
+typedef enum
+{
+    CLNK_DEF_SOC_STATUS_SUCCESS           = 0,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_TIMEOUT  = 1,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE  = 2,
+    CLNK_DEF_SOC_STATUS_LINK_CTRL_RESTART = 3,
+    CLNK_DEF_SOC_STATUS_LINK_DOWN_FAILURE = 4,
+    CLNK_DEF_SOC_STATUS_TX_HALTED_FAILURE = 5,
+    CLNK_DEF_SOC_STATUS_RX_HALTED_FAILURE = 6,
+    CLNK_DEF_SOC_STATUS_FORCED_RESET      = 7,
+
+    CLNK_DEF_SOC_STATUS_MAX  // This must always be last
+}
+CLNK_DEF_SOC_STATUS_VALUES;
+
+// a subset Embedded failure reasons
+typedef enum                                    // Hex
+{
+#if (FEATURE_FREQ_SCAN)
+    CLNK_DEF_FREQ_RESET_BAD_CRC       = 23,     // 17
+    CLNK_DEF_FREQ_RESET_FTM_EXPIRE    = 24,     // 18
+    CLNK_DEF_FREQ_RESET_CHNL_MISMATCH = 25,     // 19
+    CLNK_DEF_FREQ_ADM_FAILURE         = 26,     // 1A
+    CLNK_DEF_FREQ_PREAMBLE_MISS       = 27,     // 1B
+    CLNK_DEF_FREQ_SCAN_TABOO_ONLY     = 28,     // 1C
+#endif /* FEATURE_FREQ_SCAN */
+    CLNK_DEF_ACCESS_DENY              = 29,     // 1D
+    CLNK_DEF_LINK_CTRL_RESTART_MAX  // This must always be last
+
+}
+CLNK_DEF_LINK_CTRL_RESTART_EVENTS;
+
+//variables to be used by driver
+typedef struct
+{
+    SYS_UINT32 swConfig;     // data plane variables for PCI driver
+    SYS_UINT32 unsol_msgbuf; // for mailbox init
+    SYS_UINT32 pqosClassifyMode;
+    SYS_UINT32 pSwUnsolQueue;
+    SYS_UINT32 swUnsolQueueSize;
+}
+ClnkDef_dataPlaneVars_t;
+
+// C.Link Node Statistics Structure
+typedef struct
+{
+    SYS_UINT32 NumOfMapTx;
+    SYS_UINT32 NumOfRsrvTx;
+    SYS_UINT32 NumOfLCTx;
+    SYS_UINT32 NumOfAdmTx;
+    SYS_UINT32 NumOfProbeTx;
+    SYS_UINT32 NumOfAsyncTx;
+
+    SYS_UINT32 NumOfMapTxErr;
+    SYS_UINT32 NumOfRsrvTxErr;
+    SYS_UINT32 NumOfLCTxErr;
+    SYS_UINT32 NumOfAdmTxErr;
+    SYS_UINT32 NumOfProbeTxErr;
+    SYS_UINT32 NumOfAsyncTxErr;
+
+    SYS_UINT32 NumOfMapRx;
+    SYS_UINT32 NumOfRsrvRx;
+    SYS_UINT32 NumOfLCRx;
+    SYS_UINT32 NumOfAdmRx;
+    SYS_UINT32 NumOfProbeRx;
+    SYS_UINT32 NumOfAsyncRx;
+
+    SYS_UINT32 NumOfMapRxErr;
+    SYS_UINT32 NumOfRsrvRxErr;
+    SYS_UINT32 NumOfLCRxErr;
+    SYS_UINT32 NumOfAdmRxErr;
+    SYS_UINT32 NumOfProbeRxErr;
+    SYS_UINT32 NumOfAsyncRxErr;
+
+    SYS_UINT32 NumOfMapRxDropped;
+    SYS_UINT32 NumOfRsrvRxDropped;
+    SYS_UINT32 NumOfLCRxDropped;
+    SYS_UINT32 NumOfAdmRxDropped;
+    SYS_UINT32 NumOfProbeRxDropped;
+    SYS_UINT32 NumOfAsyncRxDropped;
+
+    SYS_UINT32 NumOfBadIsocTx;
+    SYS_UINT32 NumOfCtlDescrFailed;
+    SYS_UINT32 NumOfUpdateDescrFailed;
+    SYS_UINT32 NumOfStatDescrFailed;
+    SYS_UINT32 NumOfBufferAllocFailed;
+    SYS_UINT32 NumOfRSCorrectedBytes;
+    SYS_UINT32 Events;
+    SYS_UINT32 Interrupts;
+
+    SYS_UINT32 InternalWarnings;
+    SYS_UINT32 InternalErrors;
+
+    SYS_UINT32 qosRcvdSubmits;
+    SYS_UINT32 qosRcvdRequests;
+    SYS_UINT32 qosRcvdResponses;
+    SYS_UINT32 qosAcceptedSubmits;
+    SYS_UINT32 qosDroppedSubmits;
+    SYS_UINT32 qosIssuedWaves;
+    SYS_UINT32 qosSkippedWaves;
+    SYS_UINT32 qosSuccessWaves;
+    SYS_UINT32 qosFailedWaves;
+
+    SYS_UINT32 qosIssuedTxns;
+    SYS_UINT32 qosSuccessTxns;
+    SYS_UINT32 qosEarlyTerminatedTxns;
+    SYS_UINT32 qosEntryCancelledTxns;
+    SYS_UINT32 qosTxnErrors;
+    SYS_UINT32 qosPerformedEntryCancels;
+    SYS_UINT32 qosRcvdTxnErrors;
+
+    SYS_UINT32 qosTotalEgressBurst;
+    SYS_UINT32 qosMaxEgressBurst;
+}
+ClnkDef_Stats_t;
+
+// C.Link My Node Info Structure
+typedef struct
+{
+    SYS_UINT32      ClearStats;
+    SYS_UINT32      SwRevNum;
+    SYS_UINT32      EmbSwRevNum;
+    SYS_UINT32      LinkStatus;
+    SYS_UINT32      TxChannelBitMask;
+    SYS_UINT32      RxChannelBitMask;
+    SYS_UINT32      IsCyclemaster;
+    SYS_UINT32      RFChanFreq;
+    SYS_UINT32      CurrNetworkState;
+    SYS_UINT32      NetworkType;
+    SYS_UINT32      NodeId;
+    SYS_UINT32      CMNodeId;
+    SYS_UINT32      BestCMNodeId;
+    SYS_UINT32      BackupCMNodeId;
+    SYS_UINT32      NetworkNodeBitMask;
+    SYS_UINT32      TxIsocChanInfo;
+    SYS_UINT32      RxIsocChanInfo;
+    SYS_UINT32      PrivacyStat;
+    SYS_UINT32      MocaField;
+    SYS_UINT32      TxIQImbalance;
+    SYS_UINT32      RxIQImbalance;
+    SYS_UINT32      RxIQImbalance2;
+    ClnkDef_Stats_t Stats;
+    SYS_UINT32      TabooChanMask;
+    SYS_UINT32      TabooMaskStart;
+}
+ClnkDef_MyNodeInfo_t;
+// end defines for eth_ioctl
+// **********************************************
+// END Inserting all ClnkDefs.h neeeded by driver 
+
+/**********    Common to ClnkCAM and ClnkETH   ***************/
+#if (NETWORK_TYPE_ACCESS)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      (2)
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL)     /* HW Queues */
+    #define MAX_TX_PRIORITY           (32*CLNK_ETH_VLAN_ACTUAL)  /* SW Queues */
+    #define TX_ADVERTIZE_SIZE         (162)                      //- (200)
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE+8) * 32)
+    #define MAP_PRIO_TO_FIFO(PRIO)    ((PRIO) >> 5)
+    #define TMR_2_JIFFIES             (2456)
+
+#else
+
+  #define  CLNK_VLAN_MODE_HWVLAN   1  /* Nominal: 3 SW Q ---> 3 HW Q */
+  #define  CLNK_VLAN_MODE_SWVLAN   0  /* Alternate: 3 SW Q ---> 1 HW Q */
+
+  #if (CLNK_VLAN_MODE_HWVLAN)
+
+    #define CLNK_ETH_VLAN_ACTUAL      3 /* Nominal 3 but any value up to 8 */
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* HW Qs*/
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs*/
+    #define TX_ADVERTIZE_SIZE         256
+#if ECFG_CHIP_ZIP1
+    #define TX_MAPPING_SIZE           400
+    #define CAM_TMR_JIFFIES           TMR_2_JIFFIES
+#else
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE + 1) * MAX_TX_PRIORITY)
+    #define CAM_TMR_JIFFIES           100               /* 100 clocks/sec = 10ms period */
+#endif
+    #define MAP_PRIO_TO_FIFO(PRIO)    (PRIO)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (3333)
+   #endif
+
+  #elif (CLNK_VLAN_MODE_SWVLAN)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      8
+    #define MAX_TX_FIFOS              1                                   /* HW Qs */
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs */
+    #define TX_ADVERTIZE_SIZE         128
+    #define TX_MAPPING_SIZE           (TX_ADVERTIZE_SIZE * MAX_TX_PRIORITY)
+    #define MAP_PRIO_TO_FIFO(PRIO)    (0)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (2468)
+   #endif
+
+  #endif
+
+#endif
+/************* End definitions originally from ClnkDefs.h ********************/
+
+
+/************************** original common.h defines ************************/
+// Number of VLANs
+#define CLNK_ETH_VLAN_8021Q 8      // Number Logical 802.1Q VLAN Queues
+//#define CLNK_ETH_VLAN_ACTUAL xx  // See ClnkEth.h
+#define MAX_POSSIBLE_FIFOS    8
+
+/* Firmware image struct
+ *
+ * fw.pFirmware can point to one of three things:
+ *
+ * 1) the builtin firmware
+ * 2) a user-supplied firmware image
+ * 3) NULL (don't download firmware)
+ *
+ * All fields are native-endian.
+ */
+struct fw_img
+{
+    SYS_UINT32  *fw_text;       // instruction memory image
+    SYS_UINT32  fw_text_size;   // image size
+    SYS_UINT32  *fw_data;       // initialized data memory image
+    SYS_UINT32  fw_data_size;   // image size
+    SYS_UINT32  version;        // firmware version
+    SYS_UINT8   builtin;        // 1=built in to the driver, 0 if user-supplied
+    SYS_UINT8   native;         // 1=native endianness, 0=SoC (BE) endianness
+};
+
+// Firmware Structure
+typedef struct
+{
+    const struct fw_img *pFirmware; // Pointer to firmware info struct
+    SYS_UINT32  DistanceMode;
+    SYS_UINT32  privacyKey[4];  // MMK and PMKi
+    SYS_UINT32  cmRatio;        // Cycle master ratio (0% to 100%)
+    SYS_UINT32  txPower;        // Transmit power
+    SYS_UINT32  phyMargin;      // Phy margin settings
+    SYS_UINT32  phyBitMask;     // Phy #bits
+    SYS_UINT32  swConfig;       // Software configuration
+#if defined(L3_DONGLE_HIRF)
+    SYS_UINT32  Diplexer_;	// Diplxere Mode
+#endif    
+    SYS_UINT32  beaconPwrLevel; // Beacon power level setting. 
+    SYS_UINT32* pRFIC_Tuning_Data; // pointer to RFIC tuning data channel table for all channels
+    SYS_UINT32* pAGC_Gain_Table;// pointer to AGC gain table
+    SYS_UINT32  macAddrHigh;    // C.Link MAC address high (bytes 0-3)
+    SYS_UINT32  macAddrLow;     // C.Link MAC address low (bytes 4-5)
+    SYS_UINT8   txFifoLut[CLNK_ETH_VLAN_8021Q]; // Priority Mapping
+#if ECFG_CHIP_ZIP1
+    SYS_UINT16  txFifoPct[MAX_POSSIBLE_FIFOS]; // Tx fifo size (initial, backup)
+    SYS_UINT16  txFifoSize[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/o flows)
+#if FEATURE_QOS
+    SYS_UINT16  txFifoSizeQos[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/ flows)
+#endif /* FEATURE_QOS */
+    SYS_UINT16  txFifoChunks[MAX_POSSIBLE_FIFOS]; // Tx fifo size (runtime,  in chunks)
+    SYS_UINT32  rxFifoSize;      // Rx fifo size
+#endif /* ECFG_CHIP_ZIP1 */
+    SYS_UINT32  channelMask;     // Tunable RF Channel Mask
+    SYS_UINT32  productMask;     // Product Mask
+    SYS_UINT32  scanMask;        // Scan mask
+    SYS_UINT32  lof;             // LOF
+    SYS_UINT32  bias;            // Bias
+    SYS_UINT32  channelPlan;     // Channel Plan
+    SYS_UINT32  tabooInfo;       // Taboo mask + taboo offset
+    SYS_UINT32  PowerCtlPhyRate; // Power control PHY rate
+    SYS_UINT32  MiiPausePriLvl;  // MII Pause Priority Level
+    SYS_UINT32  PQoSClassifyMode;// PQoS Classification Mode
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32  mfrVendorId;     // Manufacturer Vendor Id (See MoCA 1.1) [we only use 16 lsbs]
+    SYS_UINT32  mfrHwVer;        // Manufacturer Hardware Version (vendor specific)
+    SYS_UINT32  mfrSwVer;        // Manufacturer Software Version (vendor specific)
+    SYS_UINT32  personality;     // Manufacturer node personality
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_IQM
+    SYS_UINT32      iqmDebugMask1;
+    SYS_UINT32      iqmDebugMask2;
+    SYS_UINT32      iqmDebugMask3;
+#endif
+
+}
+Clnk_ETH_Firmware_t;
+
+// List Entry Structure
+// This defines the structure for an entry in the linked list.
+typedef struct ListEntry_t
+{
+    struct ListEntry_t* pNext;
+    struct ListEntry_t* pPrev;
+}
+ListEntry_t;
+
+// List Header Structure
+// This defines the header structure for the linked list.
+typedef struct ListHeader_t
+{
+    ListEntry_t* pHead;
+    ListEntry_t* pTail;
+    SYS_UINT32   numElements;
+}
+ListHeader_t;
+
+
+// { StaticUsageCount: AH=4 AT=12 RH=15 RT=2 RN=2 MH=1 }
+#define COMMON_LIST_INIT(list)      (list)->pHead = SYS_NULL; \
+                             (list)->pTail = SYS_NULL;        \
+                             (list)->numElements = 0
+#define COMMON_LIST_SIZE(list)      ((list)->numElements)
+#define COMMON_LIST_EMPTY(list)     ((list)->pHead == SYS_NULL)
+#define COMMON_LIST_HEAD(T,L)       ((T *) ((L)->pHead))
+#define COMMON_LIST_TAIL(T,L)       ((T *) ((L)->pTail))
+#define COMMON_LIST_NEXT(T,E)       ((T *) (((ListEntry_t *) (E))->pNext))
+#define COMMON_LIST_PREV(T,E)       ((T *) (((ListEntry_t *) (E))->pPrev))
+#define COMMON_LIST_ADD_HEAD(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = (list)->pHead;  \
+            ((ListEntry_t *)(entry))->pPrev = SYS_NULL;       \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pNext->pPrev =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pTail = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pHead = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_ADD_TAIL(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = SYS_NULL;       \
+            ((ListEntry_t *)(entry))->pPrev = (list)->pTail;  \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pPrev->pNext =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pHead = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pTail = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_REM_HEAD(list)                            \
+            (list)->pHead;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_REM_TAIL(list)                            \
+            (list)->pTail;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_MOVE_TO_HEAD(list,entry)                  \
+            if (!COMMON_LIST_EMPTY(list) &&                   \
+                ((ListEntry_t*)(entry) != (list)->pHead))     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t *)(entry);  \
+                ListEntry_t *pNext = pCurr->pNext;            \
+                ListEntry_t *pPrev = pCurr->pPrev;            \
+                /* Remove Node */                             \
+                if (pNext) {                                  \
+                    pNext->pPrev = pPrev;                     \
+                } else {                                      \
+                    (list)->pTail = pPrev;                    \
+                }                                             \
+                pPrev->pNext = pNext;                         \
+                /* Add to Head */                             \
+                pNext = (list)->pHead;                        \
+                pCurr->pNext = pNext;                         \
+                pNext->pPrev = pCurr;                         \
+                (list)->pHead = pCurr;                        \
+            }
+#define COMMON_LIST_REM_NODE(list,entry)                      \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t*)entry;     \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else if ((list)->pHead == pCurr)              \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                else if ((list)->pTail == pCurr)              \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                else                                          \
+                {                                             \
+                    ListEntry_t *tPrev,*tNext;                \
+                    tPrev = pCurr->pPrev;                     \
+                    tNext = pCurr->pNext;                     \
+                    tNext->pPrev = pCurr->pPrev;              \
+                    tPrev->pNext = pCurr->pNext;              \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+
+/* end *************** original common.h defines ************************/
+
+/******************* ClnkEth_Vlan.h definitions *************************/
+// used in hw_z2_pci.c
+#define CLNK_ETH_GET_DST_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[3]))
+
+#define CLNK_ETH_GET_DST_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_SRC_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[3]))
+
+#define CLNK_ETH_GET_SRC_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_VLAN_PRIORITY_FROM_BUF(buf)                      \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81) ?     \
+             (((Clnk_ETH_EthHdr_t *)(buf))->tagCtrlInfo[0] >> 5) : 0)
+
+#define IS_CLNK_ETH_PKT_TAGGED(buf)                                   \
+	    ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81)  &&   \
+             (((Clnk_ETH_EthHdr_t *)(buf))->lenType[1] == 0x00)  ?    \
+              SYS_TRUE : SYS_FALSE)
+
+/// Ethernet Header
+typedef struct
+{
+    SYS_UINT8  dstMacAddr[6];
+    SYS_UINT8  srcMacAddr[6];
+    SYS_UINT8  lenType[2];
+    SYS_UINT8  tagCtrlInfo[2];
+}
+Clnk_ETH_EthHdr_t;
+/* end ********* ClnkEth_Vlan.h definitions *****************/
+
+/************ clnkdvrapi.h definitions **********************/
+// driver/API structure definitions
+#define DRV_CLNK_CTL             55
+typedef struct
+{
+    SYS_UINT32 cmd;
+    void*      param1;
+    void*      param2;
+    void*      param3;
+}
+IfrDataStruct;
+
+struct clnk_soc_opt
+{
+    /* copied from conf file */
+    SYS_UINT32      CMRatio;
+    SYS_UINT32      DistanceMode;
+    SYS_UINT32      TxPower;
+    SYS_UINT32      phyMargin;
+    SYS_UINT32      phyMBitMask;
+    SYS_UINT32      SwConfig;
+#if defined(L3_DONGLE_HIRF)
+    SYS_UINT32	    Diplexer;
+#endif        
+    SYS_UINT32      channelPlan;
+    SYS_UINT32      scanMask;
+    SYS_UINT32      productMask;
+    SYS_UINT32      tabooMask;
+    SYS_UINT32      tabooOffset;
+    SYS_UINT32      channelMask;
+    SYS_UINT32      lof;
+    SYS_UINT32      bias;
+    SYS_UINT32      PowerCtlPhyRate;
+    SYS_UINT32      BeaconPwrLevel;
+    SYS_UINT32      MiiPausePriLvl;
+    SYS_UINT32      PQoSClassifyMode;  /* PQoS Classification Mode */
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32      mfrVendorId;        /* we only use 16 lsbs */
+    SYS_UINT32      mfrHwVer;
+    SYS_UINT32      mfrSwVer;
+    SYS_UINT32      personality;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+    /* derived from conf file */
+    SYS_UINT32      pmki_lo;
+    SYS_UINT32      pmki_hi;
+    SYS_UINT32      mmk_lo;
+    SYS_UINT32      mmk_hi;
+};
+
+/* end *********** clnkdvrapi.h definitions **********************/
+
+/*************** ClnkCtl.h definitions **********************/
+
+// ClnkEth.c dependecies below
+#define MIN_VAL(x, y) (((x) > (y)) ? (y) : (x))
+
+// eth.c dependecies below
+struct clnk_io
+{
+    SYS_UINT32      *in;
+    SYS_UINT32      in_len;
+    SYS_UINT32      *out;
+    SYS_UINT32      out_len;
+};
+typedef enum
+{
+    DATA_BUF_MY_NODE_INFO_CMD_TYPE      = 0,
+    DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE = 1,
+    DATA_BUF_NODE_PHY_DATA_CMD_TYPE     = 2,
+    DATA_BUF_TEST_PORT_CMD_TYPE         = 3,
+    DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE  = 4,
+    DATA_BUF_RX_ERR_DATA_CMD_TYPE       = 5,
+    DATA_BUF_PRIV_INFO                  = 6,
+    DATA_BUF_PRIV_STATS                 = 7,
+    DATA_BUF_PRIV_NODE_INFO             = 8,
+    DATA_BUF_DUMP_CAM                   = 9,
+    DATA_BUF_GET_MIXED_MODE_ACTIVE      = 10, // obsolete
+    DATA_BUF_SET_MIXED_MODE_ACTIVE      = 11, // obsolete
+    DATA_BUF_GET_PEER_RATES             = 12,
+    DATA_BUF_GET_DYN_PARAMS             = 13,
+    DATA_BUF_SET_DYN_PARAMS             = 14,
+    DATA_BUF_GET_AGGR_STATS             = 15,
+    DATA_BUF_SEND_GCAP                  = 16,
+    DATA_BUF_obsolete                   = 17, 
+    DATA_BUF_GET_EPHY_STATS             = 18,
+
+#if FEATURE_QOS
+    DATA_BUF_CREATE_FLOW                = 19,
+    DATA_BUF_UPDATE_FLOW                = 20,
+    DATA_BUF_DELETE_FLOW                = 21,
+    DATA_BUF_QUERY_INGRESS_FLOW         = 22,
+    DATA_BUF_LIST_INGRESS_FLOWS         = 23,
+    DATA_BUF_QUERY_NODES                = 24,
+    DATA_BUF_QUERY_INTERFACE_CAPS       = 26,
+    DATA_BUF_GET_EVENT_COUNTS           = 27,
+#endif
+
+#if FEATURE_ECLAIR
+    DATA_BUF_ECLAIR_GET_HINFO          ,
+    DATA_BUF_ECLAIR_SET_TWEAKABLE      ,
+    DATA_BUF_ECLAIR_RESET_TEST_CONTEXT ,
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+    DATA_BUF_ECLAIR_PUSH_COMMAND       ,
+    DATA_BUF_ECLAIR_GET_COMMAND        ,
+    DATA_BUF_ECLAIR_SET_RECEIPT        ,
+    DATA_BUF_ECLAIR_PULL_RECEIPT       ,
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+
+#if FEATURE_ECLAIR_WHITE_BOX_TEST
+    DATA_BUF_ECLAIR_MORPH_CFG          ,
+    DATA_BUF_ECLAIR_MORPH_EXEC         ,
+    DATA_BUF_ECLAIR_MULTINODE_QUERY    ,
+    DATA_BUF_ECLAIR_MULTINODE_COMMIT   ,
+#endif
+
+#if ECFG_FLAVOR_VALIDATION==1
+    DATA_BUF_VAL_GET_MBOX_HOST_COUNTS  , 
+    DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS  , 
+    DATA_BUF_VAL_TRIGGER_MBOX_EVENT    ,   
+#endif
+
+#endif
+
+    MAX_DATA_BUF_TYPE // This must always be last
+} DATA_BUF_CMD_TYPE;
+
+#define CLNK_CTL_VERSION                    0x01
+
+#define CLNK_CTL_MAX_IN_LEN                 0x2000
+#define CLNK_CTL_MAX_OUT_LEN                0x2000
+
+#define CLNK_CTL_SOC_CMD                    0x00000000
+#define CLNK_CTL_ETH_CMD                    0x00000100
+#define CLNK_CTL_DRV_CMD                    0x00000200
+
+#define CLNK_CMD_DST_MASK                   0x00000f00
+
+#define CLNK_CMD_BYTE_MASK                 (0x000000ff)
+
+#define CLNK_CTL_FOR_DRV(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_DRV_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_SOC(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_SOC_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_ETH(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_ETH_CMD) ? 1 : 0)
+
+#define CLNK_CTL_GET_MY_NODE_INFO           (CLNK_CTL_SOC_CMD | DATA_BUF_MY_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_NET_NODE_INFO          (CLNK_CTL_SOC_CMD | DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_PHY_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_NODE_PHY_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RFIC_TUNING_DATA       (CLNK_CTL_SOC_CMD | DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RX_ERR_DATA            (CLNK_CTL_SOC_CMD | DATA_BUF_RX_ERR_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_PRIV_INFO              (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_INFO)
+#define CLNK_CTL_GET_PRIV_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_STATS)
+#define CLNK_CTL_GET_PRIV_NODE_INFO         (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_NODE_INFO)
+#define CLNK_CTL_GET_CAM                    (CLNK_CTL_SOC_CMD | DATA_BUF_DUMP_CAM)
+#define CLNK_CTL_GET_PEER_RATES             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_PEER_RATES)
+#define CLNK_CTL_GET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_DYN_PARAMS)
+#define CLNK_CTL_SET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_SET_DYN_PARAMS)
+#define CLNK_CTL_GET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_GET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_SET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_SET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_GET_AGGR_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_AGGR_STATS)
+#define CLNK_CTL_SEND_GCAP                  (CLNK_CTL_SOC_CMD | DATA_BUF_SEND_GCAP)
+#define CLNK_CTL_GET_EPHY_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EPHY_STATS)
+
+
+#if FEATURE_QOS
+#define CLNK_CTL_CREATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_CREATE_FLOW)
+#define CLNK_CTL_UPDATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_UPDATE_FLOW)
+#define CLNK_CTL_DELETE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_DELETE_FLOW)
+#define CLNK_CTL_QUERY_INGRESS_FLOW         (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INGRESS_FLOW)
+#define CLNK_CTL_LIST_INGRESS_FLOWS         (CLNK_CTL_SOC_CMD | DATA_BUF_LIST_INGRESS_FLOWS)
+#define CLNK_CTL_QUERY_NODES                (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_NODES)
+#define CLNK_CTL_QUERY_INTERFACE_CAPS       (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INTERFACE_CAPS)
+#define CLNK_CTL_GET_EVENT_COUNTS           (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EVENT_COUNTS)
+#endif /* FEATURE_QOS */
+
+#if FEATURE_ECLAIR
+#define CLNK_CTL_ECLAIR_GET_HINFO           (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_HINFO)
+#define CLNK_CTL_ECLAIR_SET_TWEAKABLE       (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_TWEAKABLE)
+#define CLNK_CTL_ECLAIR_RESET_TEST_CONTEXT  (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_RESET_TEST_CONTEXT)
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+#define CLNK_CTL_ECLAIR_PUSH_COMMAND        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PUSH_COMMAND  | CLNK_CTL_ASYNC_CMD)
+#define CLNK_CTL_ECLAIR_GET_COMMAND         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_COMMAND)
+#define CLNK_CTL_ECLAIR_SET_RECEIPT         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_RECEIPT)
+#define CLNK_CTL_ECLAIR_PULL_RECEIPT        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PULL_RECEIPT  | CLNK_CTL_ASYNC_CMD)
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+#endif /* FEATURE_ECLAIR */
+
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_CCPU_COUNTS   (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS)
+#define CLNK_CTL_VAL_TRIGGER_MBOX_EVENT     (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_TRIGGER_MBOX_EVENT)
+#endif
+
+#if FEATURE_IQM
+#define CLNK_CTL_GET_IQM_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_GET_IQM_DATA)
+#endif
+
+#define CLNK_CTL_GET_ZIP_INFO               (CLNK_CTL_ETH_CMD | 0x00)
+#define CLNK_CTL_GET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x01)
+#define CLNK_CTL_SET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x02)
+#define CLNK_CTL_GET_MEM                    (CLNK_CTL_ETH_CMD | 0x03)
+#define CLNK_CTL_SET_MEM                    (CLNK_CTL_ETH_CMD | 0x04)
+#define CLNK_CTL_GET_TRACEBUF               (CLNK_CTL_ETH_CMD | 0x05)
+#define CLNK_CTL_GET_ETH_STATS              (CLNK_CTL_ETH_CMD | 0x06)
+#define CLNK_CTL_GET_BRIDGE_TABLE           (CLNK_CTL_ETH_CMD | 0x07)
+#define CLNK_CTL_SET_ETH_FIFO_SIZE          (CLNK_CTL_ETH_CMD | 0x08)
+#define CLNK_CTL_GET_EVM_DATA               (CLNK_CTL_ETH_CMD | 0x09)
+#define CLNK_CTL_GET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0a)
+#define CLNK_CTL_SET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0b) // OBSOLETE
+
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS   (CLNK_CTL_ETH_CMD | 0x0c)
+#endif
+
+#define CLNK_CTL_RESET_DEVICE               (CLNK_CTL_DRV_CMD | 0x00)
+#define CLNK_CTL_STOP_DEVICE                (CLNK_CTL_DRV_CMD | 0x01)
+#define CLNK_CTL_NET_CARRIER_ON             (CLNK_CTL_DRV_CMD | 0x02) 
+#define CLNK_CTL_NET_CARRIER_OFF            (CLNK_CTL_DRV_CMD | 0x03) 
+#define CLNK_CTL_NET_CARRIER_OK             (CLNK_CTL_DRV_CMD | 0x04) 
+#define CLNK_CTL_SOC_INIT_BUS               (CLNK_CTL_DRV_CMD | 0x05) 
+#define CLNK_CTL_SOC_BOOTED                 (CLNK_CTL_DRV_CMD | 0x06) 
+#define CLNK_CTL_HW_DESC_INIT               (CLNK_CTL_DRV_CMD | 0x07) 
+#define CLNK_CTL_TC_DIC_INIT                (CLNK_CTL_DRV_CMD | 0x08) 
+#define CLNK_CTL_GET_SOC_STATUS             (CLNK_CTL_DRV_CMD | 0x09) 
+#define CLNK_CTL_GET_LINK_STATUS            (CLNK_CTL_DRV_CMD | 0x0a) 
+#define CLNK_CTL_SET_MAC_ADDRESS            (CLNK_CTL_DRV_CMD | 0x0b) 
+#define CLNK_CTL_GET_NMS_LOCAL_MSG          (CLNK_CTL_DRV_CMD | 0x0c) /* NMS */
+#define CLNK_CTL_SET_DATA_PLANE_VARS        (CLNK_CTL_DRV_CMD | 0x0d) /* PQoS */
+
+/* end *************** ClnkCtl.h definitions **********************/
+
+// Driver Return Codes
+typedef enum
+{
+    CLNK_ETH_RET_CODE_SUCCESS            = 0,
+    CLNK_ETH_RET_CODE_GEN_ERR            = 1,
+    CLNK_ETH_RET_CODE_MEM_ALLOC_ERR      = 2,
+    CLNK_ETH_RET_CODE_RESET_ERR          = 3,
+    CLNK_ETH_RET_CODE_NOT_OPEN_ERR       = 4,
+    CLNK_ETH_RET_CODE_LINK_DOWN_ERR      = 5,
+    CLNK_ETH_RET_CODE_NO_HOST_DESC_ERR   = 6,
+    CLNK_ETH_RET_CODE_UCAST_FLOOD_ERR    = 7,
+    CLNK_ETH_NO_KEY_ERROR                = 8,
+    CLNK_ETH_MRT_TRANSACTION_IN_PROGRESS = 9,
+    CLNK_ETH_RET_CODE_PKT_LEN_ERR        = 10,
+
+    CLNK_ETH_RET_CODE_MAX  // This must always be last
+}
+CLNK_ETH_RET_CODES;
+
+
+
+
+#endif /* __common_dvr_h__ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Common_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Common_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Common_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/Common_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo.c ***/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg );
+unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response );
+unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg );
+unsigned long clnkioc_mem_read( void *dkcp, void *arg );
+unsigned long clnkioc_mem_write( void *dkcp, void *arg );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo_common.c ***/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob );
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length);
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length);
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_call.c ***/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg);
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_dvr.c ***/
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_ttask.c ***/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data);
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data);
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/util_dvr.c ***/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+void *ctx_alloc_dc_context( void );
+void ctx_free_dc_context( void *dccp );
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/control_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/control_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/control_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/control_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,52 @@
+/*******************************************************************************
+*
+* Common/Inc/control_context.h
+*
+* Description: control context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __control_context_h__
+#define __control_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "control_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "control_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "control_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "control_context_apollo.h"
+#endif
+
+#endif // __control_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/debug.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/debug.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/debug.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/debug.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Common/Inc/debug.h
+*
+* Description: debug macros and such
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __debug_h__
+#define __debug_h__
+
+
+
+#ifdef IOCTL_DEBUG
+static void _ioctl_dbg(dk_context_t *dkcp, char *str)
+{
+    HostOS_PrintLog(L_ERR, "%s: %s failed!\n", dkcp->name, str);
+}
+#else
+//static inline void _ioctl_dbg(char *name, char *str) { }
+#define _ioctl_dbg(NAME,STR)   do { } while (0)
+#endif
+
+
+#endif // __debug_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/driverversion.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/driverversion.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/driverversion.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/driverversion.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1 @@
+#define DRV_VERSION "1.03.01.21"
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_ctl_opts.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_ctl_opts.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_ctl_opts.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_ctl_opts.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,173 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_ctl_opts.h
+*
+* Description: driver (io)control options
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __drv_ctl_opts_h__
+#define __drv_ctl_opts_h__
+
+#include "common_dvr.h"
+
+#ifndef FEATURE_QOS
+#define FEATURE_QOS     0
+#endif
+
+
+
+
+// Driver Control Options
+typedef enum
+{
+    CLNK_ETH_CTRL_GET_REG,
+    CLNK_ETH_CTRL_SET_REG,
+    CLNK_ETH_CTRL_GET_MEM,
+    CLNK_ETH_CTRL_SET_MEM,
+    CLNK_ETH_CTRL_GET_TRACE,
+    CLNK_ETH_CTRL_GET_BRIDGE_SRC_TABLE, // COMBINE THESE 4 !!!!
+    CLNK_ETH_CTRL_GET_BRIDGE_DST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_BCAST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_MCAST_TABLE,
+    CLNK_ETH_CTRL_GET_EPP_DATA,
+    CLNK_ETH_CTRL_GET_EVM_DATA,
+    CLNK_ETH_CTRL_GET_MY_NODE_INFO,
+    CLNK_ETH_CTRL_GET_NET_NODE_INFO,
+    CLNK_ETH_CTRL_GET_PHY_DATA,
+    CLNK_ETH_CTRL_GET_RX_ERR_DATA,
+    CLNK_ETH_CTRL_GET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_LINK_STATUS,
+    CLNK_ETH_CTRL_GET_MAC_ADDR,
+    CLNK_ETH_CTRL_GET_MULTICAST_TABLE,
+    CLNK_ETH_CTRL_GET_NUM_TX_HOST_DESC,
+    CLNK_ETH_CTRL_GET_SOC_STATUS,  /* OBSOLETE/DO_NOT_REUSE */  
+    CLNK_ETH_CTRL_GET_STATS,
+    CLNK_ETH_CTRL_GET_SW_REV_NUM,
+    CLNK_ETH_CTRL_SET_CM_RATIO,
+    CLNK_ETH_CTRL_SET_EPP_DATA,    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_FIRMWARE,
+    CLNK_ETH_CTRL_SET_MAC_ADDR,
+    CLNK_ETH_CTRL_SET_PHY_MARGIN,
+    CLNK_ETH_CTRL_SET_PRIVACY_MODE, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SHA_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_SW_CONFIG,
+    CLNK_ETH_CTRL_SET_TX_POWER,
+    CLNK_ETH_CTRL_TEST_PORT,
+    CLNK_ETH_CTRL_RESET,
+    CLNK_ETH_CTRL_ENABLE_INTERRUPT,
+    CLNK_ETH_CTRL_DISABLE_INTERRUPT,
+    CLNK_ETH_CTRL_RD_CLR_INTERRUPT,
+    CLNK_ETH_CTRL_DETACH_SEND_PACKET,
+    CLNK_ETH_CTRL_DETACH_RCV_PACKET,
+    CLNK_ETH_CTRL_JOIN_MULTICAST,
+    CLNK_ETH_CTRL_LEAVE_MULTICAST,
+    CLNK_ETH_CTRL_SET_SEND_CALLBACK,
+    CLNK_ETH_CTRL_SET_RCV_CALLBACK,
+    CLNK_ETH_CTRL_SET_UNSOL_CALLBACK,
+    CLNK_ETH_CTRL_GET_RFIC_TUNING_DATA,
+    CLNK_ETH_CTRL_SET_RFIC_TUNING_DATA, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_AGC_GAIN_TABLE,   /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_CHANNEL_MASK,
+    CLNK_ETH_CTRL_GET_RANDOM_BITS,  /* OBSOLETE/DO_NOT_REUSE */
+   // CLNK_SOFTCAM
+    CLNK_ETH_CTRL_GET_SOFT_CAMDATA,
+
+    CLNK_ETH_CTRL_SET_LOF,
+    CLNK_ETH_CTRL_GET_LOF,
+    CLNK_ETH_CTRL_SET_BIAS,
+    CLNK_ETH_CTRL_FS_UPDATE,  /* OBSOLETE */
+    CLNK_ETH_CTRL_SET_CHANNEL_PLAN,
+    CLNK_ETH_CTRL_SET_TABOO_INFO,
+    CLNK_ETH_CTRL_SET_SCAN_MASK,
+
+    CLNK_ETH_CTRL_SET_DISTANCE_MODE,
+    CLNK_ETH_CTRL_SET_POWERCTL_PHYRATE,
+
+    CLNK_ETH_CTRL_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE,
+    CLNK_ETH_CTRL_DEFINE_CLM_INIT_SETTINGS,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_PRIVACY_SEND,
+    CLNK_ETH_CTRL_PRIVACY_SET_KEY,
+    CLNK_ETH_CTRL_PRIVACY_UPDATE,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_GET_PRIVACY_EVENT,
+    CLNK_ETH_CTRL_GET_PRIVACY_STAT,
+    CLNK_ETH_CTRL_GET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_GET_PRIVACY_DATA,
+    CLNK_ETH_CTRL_GET_PRIVACY_RANDBIT,
+
+    CLNK_ETH_CTRL_NODEMANAGE_ADD ,
+    CLNK_ETH_CTRL_NODEMANAGE_DELETE ,
+    CLNK_ETH_CTRL_NODEMANAGE_GET,
+
+    CLNK_ETH_CTRL_SET_TIMER_SPEED,
+
+    CLNK_ETH_CTRL_GET_PRIV_INFO,
+    CLNK_ETH_CTRL_GET_PRIV_STATS,
+    CLNK_ETH_CTRL_GET_PRIV_NODE_INFO,
+
+    CLNK_ETH_CTRL_DO_CLNK_CTL,
+    CLNK_ETH_CTRL_SET_BEACON_POWER_LEVEL, // added for DIP feature.
+
+#if FEATURE_QOS
+    CLNK_ETH_CTRL_CREATE_FLOW,
+    CLNK_ETH_CTRL_UPDATE_FLOW,
+    CLNK_ETH_CTRL_DELETE_FLOW,
+    CLNK_ETH_CTRL_QUERY_FLOW,
+    CLNK_ETH_CTRL_LIST_FLOWS,
+    CLNK_ETH_CTRL_GET_EVENT_COUNTS,
+    CLNK_ETH_CTRL_QUERY_IF_CAPS,
+    CLNK_ETH_CTRL_QUERY_NODES,
+    CLNK_ETH_CTRL_QUERY_PATH_INFO,
+    CLNK_ETH_CTRL_EXPIRE_FLOW,
+#if ECFG_CHIP_ZIP1
+    CLNK_ETH_CTRL_SET_TFIFO_RESIZE_CALLBACK,
+#endif /* ECFG_CHIP_ZIP1 */
+#endif
+
+    CLNK_ETH_CTRL_GET_PEER_RATES,
+    CLNK_ETH_CTRL_STOP,
+
+    CLNK_ETH_CTRL_MAX  // This must always be last
+}
+CLNK_ETH_CTRL_OPTIONS;
+
+
+
+
+
+#endif // __drv_ctl_opts_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/drv_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_hdr.h
+*
+* Description: Generic driver compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*
+* This file simply includes the driver's main compilation control file.
+* That file will be named after the driver in some way.
+*
+* The reason for this is to allow both local and common .c and .h files 
+* to include a file specific to a single driver thus customizing the
+* compilation for the selected driver.
+*
+*******************************************************************************/
+
+#ifndef __drv_hdr_h__
+#define __drv_hdr_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "pci_hdr.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "mii_hdr.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "candd_hdr.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "apollo_hdr.h"
+#endif
+
+#endif // __drv_hdr_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/entropic-config.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/entropic-config.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/entropic-config.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/entropic-config.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,61 @@
+#ifndef __entropic_config_h_
+#define __entropic_config_h_
+/*     ###########    W A R N I N G ! ! !    ##########     */
+/*     ##  Do not edit this file! it is generated!   ##     */
+/*     ###########    W A R N I N G ! ! !    ##########     */
+#define ECFG_CHIP_ZIP1    0
+#define ECFG_CHIP_ZIP2    0
+#define ECFG_CHIP_MAVERICKS    1
+#define ECFG_CHIP_STRING     "ECFG_CHIP_MAVERICKS"
+
+#define ECFG_BOARD_ECB_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP1    0
+#define ECFG_BOARD_PC_DVT_MII_ZIP2    0
+#define ECFG_BOARD_PC_DVT_TMII_ZIP2    1
+#define ECFG_BOARD_PC_DVT_GMII_ZIP2    0
+#define ECFG_BOARD_PC_DVT2_PCI_ZIP2    0
+#define ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2    0
+#define ECFG_BOARD_ECB_ROW    0
+#define ECFG_BOARD_GPC    0
+#define ECFG_BOARD_ECB_4M_L3    0
+#define ECFG_BOARD_ECB_3M_L3    0
+#define ECFG_BOARD_PC_PCIE_MAVERICKS    0
+#define ECFG_BOARD_STRING     "ECFG_BOARD_PC_DVT_TMII_ZIP2"
+
+#define ECFG_NETWORK_ACCESS    0
+#define ECFG_NETWORK_MESH    1
+#define ECFG_NETWORK_STRING     "ECFG_NETWORK_MESH"
+
+#define ECFG_NODE_CPE    0
+#define ECFG_NODE_HEADEND    0
+#define ECFG_NODE_TCPE    0
+#define ECFG_NODE_MOCA    1
+#define ECFG_NODE_STRING     "ECFG_NODE_MOCA"
+
+#define ECFG_OS_LINUX_TYPICAL    1
+#define ECFG_OS_NONE    0
+#define ECFG_OS_STRING     "ECFG_OS_LINUX_TYPICAL"
+
+#define ECFG_FLAVOR_PRODUCTION    1
+#define ECFG_FLAVOR_PRODUCTION_PROTEM    0
+#define ECFG_FLAVOR_PHYSVT    0
+#define ECFG_FLAVOR_VALIDATION    0
+#define ECFG_FLAVOR_STRING     "ECFG_FLAVOR_PRODUCTION"
+
+#define ECFG_DATAPATH_GMII    0
+#define ECFG_DATAPATH_RGMII    0
+#define ECFG_DATAPATH_TMII    1
+#define ECFG_DATAPATH_MII    0
+#define ECFG_DATAPATH_PCI    0
+#define ECFG_DATAPATH_PCIE    0
+#define ECFG_DATAPATH_FLEX    0
+#define ECFG_DATAPATH_STRING     "ECFG_DATAPATH_TMII"
+
+#define ECFG_MISC_REF_XTAL_25M_CLOCK    1
+#define ECFG_MISC_REF_SOC_25M_CLOCK    0
+#define ECFG_MISC_STRING     "ECFG_MISC_REF_XTAL_25M_CLOCK"
+
+
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/HostOS_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/HostOS_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/HostOS_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/HostOS_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,86 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Common/gpl_ctx_abs.c ***/
+void *dk_to_dd( void *dkcp );
+void *dd_to_dg( void *ddcp );
+void *dg_to_dc( void *dgcp );
+void *dg_to_dd( void *dgcp );
+void *dk_to_dc( void *dkcp );
+void *dd_to_dc( void *ddcp );
+void *dk_to_dg( void *dkcp );
+void *dc_to_dd( void *dccp );
+
+/*** public prototypes from Common/gpl_ctx_setup.c ***/
+void *ctx_alloc_dg_context( void );
+void ctx_free_dg_context( void *dgcp );
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp );
+void Clnk_init_os_context( void *vdgcp ); /* BZ 5072 fix */
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len );
+
+/*** public prototypes from Common/hostos.c ***/
+void HostOS_Memset(void *pMem, int val, int size);
+void HostOS_Memcpy(void *pTo, void *pFrom, int size);
+void HostOS_Sscanf(const char *buf, const char *fmt, ...);
+void* HostOS_Alloc(int size);
+void HostOS_Free(void* pMem, int size);
+void HostOS_Sleep(int timeInUsec);
+void HostOS_lock_init( void *vlk);
+void HostOS_Lock(void *vlk);
+void HostOS_Lock_Irqsave(void *vlk);
+int HostOS_Lock_Try(void *vlk);
+void HostOS_Unlock(void *vlk);
+void HostOS_Unlock_Irqrestore(void *vlk);
+void HostOS_TermLock(void *vlk);
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...);
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr );
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr );
+void HostOS_timer_init( void *vtmr );
+int HostOS_timer_del( void *vtmr );
+int HostOS_timer_del_sync( void *vtmr );
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout );
+void HostOS_timer_add( void *vtmr );
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data );
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout );
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future );
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future );
+void *HostOS_wqt_alloc( void );
+void HostOS_wqt_free( void *vwqt );
+void HostOS_wqt_timer_init( void *vwqt );
+void HostOS_wqt_timer_del( void *vwqt );
+int HostOS_wqt_timer_del_sync( void *vwqt );
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_timer_add( void *vwqt );
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data );
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_waitq_init( void *vwqt );
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt );
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp );
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal);
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal);
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val);
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val);
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa);
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa);
+void HostOS_task_init( void *vtl, void *func, unsigned long data );
+void HostOS_task_schedule( void *vtl );
+void HostOS_task_enable( void *vtl );
+void HostOS_task_disable( void *vtl );
+void HostOS_task_kill( void *vtl );
+void HostOS_mutex_init( void *vmt );
+void HostOS_mutex_release( void *vmt );
+void HostOS_mutex_acquire( void *vmt );
+int HostOS_mutex_acquire_intr( void *vmt );
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_netif_carrier_ok( void *kdev );
+void HostOS_netif_carrier_on( void *kdev );
+void HostOS_netif_carrier_off( void *kdev );
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo );
+void HostOS_open( void *kdev );
+void HostOS_close( void *kdev );
+int HostOS_signal_pending(void *pTask);
+void HostOS_msleep_interruptible(unsigned int msecs);
+int HostOS_thread_start(unsigned int *pThreadID, char *thName, void (*func)(void *), void *arg);
+int HostOS_thread_stop(unsigned long threadID);
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/hw_z2_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/hw_z2_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/hw_z2_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/hw_z2_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,273 @@
+/*******************************************************************************
+*
+* Common/Inc/hw_z2_dvr.h
+*
+* Description: Header file for general Zip2 support (all datapaths)
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _HW_Z2_H_
+#define _HW_Z2_H_
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/* Fragment Gather Support:
+ *
+ * For stock Linux implementations, 1 FRAG is necessary and sufficient. 
+ * - Standard rule of thumb is driver must support IP chksum (NETIF_F_IP_CSUM)
+ *   before it makes sense to enable scatter/gather (NETIF_F_SG) in the
+ *   dev->features flag mask.  Linux always builds a single buffer WHEN it has
+ *   to do to its own IP Checksum (defeating NETIF_F_SG) !!
+ * - Due to various restrictions (see custom), general support of _SG would
+ *   require backstop code to coalesce when restrictions are violated.  See
+ *   drivers/net/typhoon.c for some good examples.
+ *
+ * For custom implementations, Gathered Fragments can be supported. Details ...
+ * - Limit of 4 Fragments exists with current CCPU/TC code
+ * -- See CLNK_HW_MAX_FRAGMENTS compile define below.
+ * -- Common driver also limited to 4. (See CLNK_ETH_MAX_FRAGMENTS. Modifiable)
+ * -- Has been well tested up to 4 Fragments.
+ * -- Configuring more than you need wastes some host driver space
+ * -- Configuring more than you need increases ptr_list DMA size
+ * - Restrictions below this point are not validated by code!
+ * -- Minimum Fragment must be at least 32 bytes
+ * -- External Fragment data can be on any byte host address boundary.
+ * -- Internal Fragment data has to start with 4 byte aligned.
+ * -- All fragments must be multiple of 4 in length, except final.
+ * - See SIMULATE_FRAGMENTS define in eth.c for example code.
+ * -- Includes tests which set successive frag sizes to 32, 64, 128 ...
+ */
+#define CLNK_HW_MAX_FRAGMENTS   1
+#if (CLNK_HW_MAX_FRAGMENTS > 4)
+#warning "Current 1.5 (SOC,TC) Xmit Support limited to 4 Fragments"
+#endif
+struct _frag_desc
+{
+    SYS_UINT32              ptr;
+    SYS_UINT32              len;
+};
+struct ptr_list
+{
+    SYS_UINT32              n_frags;
+    struct _frag_desc       fragments[CLNK_HW_MAX_FRAGMENTS];
+    SYS_UINT32              magic;
+};
+
+#define EHI_START       0x0c100000
+#define EHI_END         0x0c1003fc
+
+#define AT1_BASE        0x0c000000
+#define AT2_BASE        0x0c080000
+#define AT3_BASE        0x0c100400
+
+#define HOST_INTR       (1 << 1)        /* interrupt bit for tx/rx/mbx */
+#define TMR_INTR        (1 << 24)       /* interrupt bit for zip2 timer 0 */
+
+#if ! defined(CLNK_ETH_ENDIAN_SWAP)
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = (val)
+#else
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = HOST_OS_ENDIAN_SWAP(val)
+
+#endif /* ! defined(CLNK_ETH_ENDIAN_SWAP) */
+
+#define RX_STATUS_PTR(ctx, idx) ((ctx)->rx_linebuf + sizeof(struct linebuf) + ((idx) << 2))
+
+#define TX_STATUS_PTR(ctx, pri, idx) ((ctx)->tx_linebuf[pri] + sizeof(struct linebuf) + ((idx) << 2))
+
+
+/*
+ * CLNK_REG_*() and soc*Mem() take full Sonics addresses on Zip2,
+ * and handle the translation themselves for buses on which it is necessary
+ */
+#define SETUP_ATRANS(pContext, addr) do { } while(0)
+
+/*
+ * ZIP2 REGISTERS
+ */
+
+#define CLNK_ETH_INTERRUPT_FLAG  0x01
+
+// PCI device/vendor ID
+#define CLNK_ETH_PCI_DEVICE_ID  0x002117e6
+
+// Unused macro (Zip1b only)
+#define SEM_INIT_DONE_BITS() do { } while(0)
+
+#define CLNK_REG_ETH_MAC_ADDR_HIGH              DEV_MAC_ADDRESS0H
+#define CLNK_REG_ETH_MAC_ADDR_LOW               DEV_MAC_ADDRESS0L
+
+#define EHI_BASE                    0x0c100000
+#define CSC_BASE                    0x0c100400
+#define CCPU_BASE                   0x0c100800
+#define DIC_CSR_BASE                0x0c100c00
+#define ETH_CSR_BASE                0x0c103000
+#define GPHY_BASE                   0x0c103800
+#define DIC_BASE                    0x0c104000
+#define CPC_BASE                    0x0c108000
+#define RFIC_BASE                   0x0c109000
+#define FEC_BASE                    0x0c10a000
+#define CPC_TC_BASE                 0x0c10c000
+#define PHY_RX_BASE                 0x0c110000
+#define PHY_TX_BASE                 0x0c118000
+#define PCIE_CSR_BASE               0x0c102000
+#define HOST_INTR_TO_INTX           (1 << 10)
+#define PCIE_CSC_CORE_CTL           (PCIE_CSR_BASE + 0xc00)
+
+#define EHI_VERSION                 (EHI_BASE + 0x00)
+#define DEV_MAC_ADDRESS0L           (EHI_BASE + 0xd0)
+#define DEV_MAC_ADDRESS0H           (EHI_BASE + 0xd4)
+
+#define CLNK_REG_CPU_COLD_RESET_BIT (1 << 0)
+#define CLNK_REG_CPU_RESET          (CCPU_BASE + 0x04)
+#define CLNK_SYS_RST_CONTROL        (CCPU_BASE + 0x7c)
+
+#define EHI_INTR_OUT_MASK           (EHI_BASE + 0x24)
+#define CSC_INTR_BUS                (CSC_BASE + 0xc)
+
+#define EHI_TIMEOUT_CTL             (EHI_BASE + 0x38)
+#define EHI_ERR_ADDR_EXT            (EHI_BASE + 0xf8)
+#define EHI_ERR_ADDR_INT            (EHI_BASE + 0xfc)
+#define EHI_ERR_AT                  (EHI_BASE + 0xec)
+#define EHI_ERR_DET                 (EHI_BASE + 0x1c)
+
+#define EHI_MISC_CTL                (EHI_BASE + 0x90)
+#define EHI_AT1_CTL                 (EHI_BASE + 0x50)
+#define EHI_AT1_ADDR                (EHI_BASE + 0x54)
+#define EHI_AT1_MASK                (EHI_BASE + 0x58)
+#define EHI_AT2_CTL                 (EHI_BASE + 0x60)
+#define EHI_AT2_ADDR                (EHI_BASE + 0x64)
+#define EHI_AT2_MASK                (EHI_BASE + 0x68)
+#define EHI_AT3_CTL                 (EHI_BASE + 0x70)
+#define EHI_AT3_ADDR                (EHI_BASE + 0x74)
+#define EHI_AT3_MASK                (EHI_BASE + 0x78)
+
+#define IMI_AT0_CTL                 (EHI_BASE + 0xa0)
+#define IMI_AT0_ADDR                (EHI_BASE + 0xa4)
+#define IMS_CTL_0                   (EHI_BASE + 0xc0)
+#define IMS_CTL_1                   (EHI_BASE + 0xc4)
+#define IMS_CTL_2                   (EHI_BASE + 0xc8)
+#define IMI_ARB_CTL_0               (EHI_BASE + 0xe0)
+#define IMI_ARB_CTL_1               (EHI_BASE + 0xe4)
+#define IMI_ARB_CTL_2               (EHI_BASE + 0xe8)
+#if ECFG_CHIP_MAVERICKS 
+#define CPC_TC_INST_MEM             (CPC_TC_BASE + 0x0)
+#define CPC_TC_INST_MEM_SZ          0x3000
+#define CPC_TC_DATA_MEM_SZ          0x2000
+#define CPC_TC_DATA_MEM             (CPC_TC_BASE + CPC_TC_INST_MEM_SZ)
+#endif
+
+#define DIC_TC_CTL_0                (DIC_CSR_BASE + 0x50)
+#define DIC_MISC_CTL_0              (DIC_CSR_BASE + 0x40)
+#define DIC_ATRANS0_CTL0            (DIC_CSR_BASE + 0x70)
+#define DIC_ATRANS1_CTL0            (DIC_CSR_BASE + 0x78)
+#define DIC_TC_NOTIFY_SET           (DIC_CSR_BASE + 0x5c)
+
+#define DIC_TC_INST_MEM             (DIC_BASE + 0x00)
+#if ECFG_CHIP_ZIP2
+#define DIC_TC_INST_MEM_SZ          0x2000
+#define DIC_TC_DATA_MEM_SZ          0x1000
+#elif ECFG_CHIP_MAVERICKS
+#define DIC_TC_INST_MEM_SZ          0x2800
+#define DIC_TC_DATA_MEM_SZ          0x1800
+#endif
+/*For ZIP1 there are no TCs*/
+#define DIC_TC_DATA_MEM             (DIC_BASE + DIC_TC_INST_MEM_SZ)
+
+#define DIC_D_STATUS                (DIC_TC_DATA_MEM + 0x00)
+#define DIC_D_DESC_TX_PTR           (DIC_TC_DATA_MEM + 0x04)
+#define DIC_D_DESC_RX_PTR           (DIC_TC_DATA_MEM + 0x08)
+#define DIC_D_MISC_CFG              (DIC_TC_DATA_MEM + 0x0c)
+#define DIC_D_PROC_STATE            (DIC_TC_DATA_MEM + 0x10)
+#define DIC_D_LINEBUF_SOC_RX        (DIC_TC_DATA_MEM + 0x20)
+#define DIC_D_MIN_PKT_SIZE          (DIC_TC_DATA_MEM + 0x38)
+#define DIC_D_LINEBUF_HOST_RX       (DIC_TC_DATA_MEM + 0x24)
+#define DIC_D_LINEBUF0_SOC_TX       (DIC_TC_DATA_MEM + 0x2c)
+#define DIC_D_ETH_SPU_LEN_W_FCS_MAX (DIC_TC_DATA_MEM + 0x30)
+#define DIC_D_AGGR_HDR_SPU_CNT_MAX  (DIC_TC_DATA_MEM + 0x34)
+#define DIC_D_RX_DST_PTR            (DIC_TC_DATA_MEM + 0x68)
+#define DIC_D_RX_DST_IDX            (DIC_TC_DATA_MEM + 0x6c)
+#define DIC_D_TX_DMA_CTL            (DIC_TC_DATA_MEM + 0x78)
+#define DIC_D_RX_DMA_CTL            (DIC_TC_DATA_MEM + 0x7c)
+
+
+#define DIC_CFG_USAGE_MODE_PCI      0x00000000
+#define DIC_CFG_USAGE_MODE_MII      0x00000001
+#define DIC_CFG_BAD_PKT_FLTR_OFF    0x00000000
+#define DIC_CFG_BAD_PKT_FLTR_ON     0x00000010
+#define DIC_CFG_SPU_FCS_ENABLED     0x00000020
+#define DIC_CFG_SPU_FCS_DISABLED    0x00000000
+#define DIC_CFG_AGGR_DST_ONLY       0x00000040
+#define DIC_CFG_AGGR_DST_AND_PRI    0x00000000
+#define DIC_CFG_TX_BUF_PROF_WAN     0x00000080
+#define DIC_CFG_TX_BUF_PROF_LAN     0x00000000
+#define DIC_CFG_MII_SPEED_MASK      0x000FFF00
+#define DIC_CFG_PQOS_MODE_MASK      0x00F00000
+#define DIC_CFG_PQOS_MODE_MOCA_11   0x00000000
+#define DIC_CFG_PQOS_MODE_PUPQ      0x00100000
+
+#define DIC_TX_DMA_CTL_WORD         0x00048000
+#define DIC_RX_DMA_CTL_WORD         0x00048100
+
+#define CSC_CLK_CTL1                (CSC_BASE + 0xe4)
+
+#define CSC_SYS_TMR_LO              (CSC_BASE + 0x70)
+#define CSC_TMR_TIMEOUT_0           (CSC_BASE + 0x80)
+#define CSC_TMR_MASK_0              (CSC_BASE + 0x84)
+
+#define GPHY_MAC_CONFIG             (GPHY_BASE + 0x00)
+#define GPHY_FILTER                 (GPHY_BASE + 0x04)
+#define GPHY_FLOW                   (GPHY_BASE + 0x18)
+
+#define GPHY_FLOW_MAC_LO	    (GPHY_BASE + 0x40)		// Low 2 bytes of mac address as (xx xx MM ZZ) where MM is lowest byte
+#define GPHY_FLOW_MAC_HI	    (GPHY_BASE + 0x44)		// High 4 bytes of mac address in reverse order 
+                                                                //             (AA BB CC DD) where DD is highest byte.
+#define GPHY_BMCR                   (GPHY_BASE + 0x100)
+#define GPHY_ENH_CTRL               (GPHY_BASE + 0x168)
+#define GPHY_BUS_MODE               (GPHY_BASE + 0x200)
+#define GPHY_RX_DESCR_PTR           (GPHY_BASE + 0x20c)
+#define GPHY_TX_DESCR_PTR           (GPHY_BASE + 0x210)
+#define GPHY_OP_MODE                (GPHY_BASE + 0x218)
+
+#define CLNK_REG_MBX_REG_1          DEV_SHARED(mailbox_reg[0])
+#define CLNK_REG_MBX_REG_9          DEV_SHARED(mailbox_reg[8])
+#define CLNK_REG_MBX_REG_16         DEV_SHARED(mailbox_reg[15])
+#define CLNK_REG_MBX_READ_CSR       DEV_SHARED(read_csr_reg)
+#define CLNK_REG_MBX_WRITE_CSR      DEV_SHARED(write_csr_reg)
+#define CLNK_REG_MBX_SEMAPHORE_BIT  0x80000000UL
+
+#define CLNK_REG_DEBUG_0            DEV_SHARED(debug_reg[0])
+#define CLNK_REG_DEBUG_1            DEV_SHARED(debug_reg[1])
+
+#define CLNK_REG_MBX_FIRST          CLNK_REG_MBX_REG_1
+#define CLNK_REG_MBX_LAST           CLNK_REG_MBX_REG_16
+
+#endif /* ! _HW_Z2_H_ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/inctypes_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/inctypes_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/inctypes_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc/inctypes_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,300 @@
+/*******************************************************************************
+*
+* Common/Inc/inctypes_dvr.h
+*
+* Description: System definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __INCTYPES_H__
+#define __INCTYPES_H__
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+//  System Constants
+#define SYS_TRUE     1
+#define SYS_FALSE    0
+#define SYS_NULL     0
+#define SYS_SUCCESS  0
+
+// NOTE: The error constants defined below MUST be the same value as the 
+//       corresponding error codes defined by your specific OS.  If not, then
+//       change the values of the defines below to match your specific OS error
+//       values.
+// 
+//       Entropic has defined the error constants below to match the OS we use in
+//       our evaluation platforms and may differ from the error values defined by 
+//       your specific OS.
+#define SYS_INPUT_OUTPUT_ERROR     5
+#define SYS_OUT_OF_MEMORY_ERROR    12
+#define SYS_PERMISSION_ERROR       13
+#define SYS_INVALID_ADDRESS_ERROR  14
+#define SYS_INVALID_ARGUMENT_ERROR 22
+#define SYS_OUT_OF_SPACE_ERROR     28
+#define SYS_DIR_NOT_EMPTY_ERROR    39
+#define SYS_BAD_MSG_TYPE_ERROR     42
+#define SYS_TIMEOUT_ERROR          110
+
+
+#define DOWHILE0(x)  do { x; } while(0)
+
+#define INCTYPES_MIN(x,y)		  ((x) < (y) ? (x) : (y))
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// System Variable Types
+typedef void            SYS_VOID;
+typedef void*           SYS_VOID_PTR;
+
+typedef char            SYS_CHAR;
+typedef char*           SYS_CHAR_PTR;
+typedef signed char     SYS_INT8;
+typedef signed char*    SYS_INT8_PTR;
+typedef unsigned char   SYS_UCHAR;
+typedef unsigned char*  SYS_UCHAR_PTR;
+typedef unsigned char   SYS_UINT8;
+typedef unsigned char*  SYS_UINT8_PTR;
+typedef unsigned char   SYS_BOOLEAN; 
+
+/** Used in places where the type is a boolean type but 32 bit words reduce
+ * code space by avoiding the need for various masking */
+typedef unsigned char   SYS_BOOLEAN32; 
+
+typedef unsigned short  SYS_UINT16;
+typedef unsigned short* SYS_UINT16_PTR;
+typedef short           SYS_INT16;
+typedef short*          SYS_INT16_PTR;
+
+typedef int             SYS_INT32;
+typedef int*            SYS_INT32_PTR;
+typedef unsigned int    SYS_UINT32;
+typedef unsigned int*   SYS_UINT32_PTR;
+
+typedef long            SYS_LONG;
+typedef long*           SYS_LONG_PTR;
+typedef unsigned long   SYS_ULONG;
+typedef unsigned long*  SYS_ULONG_PTR;
+
+#if defined(_LP64)
+typedef unsigned long   SYS_UINTPTR;
+#else
+typedef unsigned int    SYS_UINTPTR;
+#endif
+
+typedef struct {
+	SYS_INT32 I;
+	SYS_INT32 Q;
+} SYS_COMPLEX_INT32;
+
+typedef struct {
+	SYS_UINT32 		hi;
+	SYS_UINT32 		lo;
+} mac_addr_t;
+
+typedef void (*SYS_VDFCVD_PTR) (void *);
+
+/** Query if the mac address represents a multicast */
+#define INCTYPES_MAC_ADDR_IS_MULTICAST( _mac_addr ) \
+  (((_mac_addr).hi & 0x01000000) ? SYS_TRUE : SYS_FALSE)
+
+
+/** Query if two mac address match (low order bits masked off) */
+#define INCTYPES_MAC_ADDR_MATCH( _mac_addr_a, _mac_addr_b )              \
+  ((                                                                     \
+      (_mac_addr_a).hi == (_mac_addr_b).hi                               \
+   ) &&                                                                  \
+   (                                                                     \
+      ((_mac_addr_a).lo & 0xFFFF0000) == ((_mac_addr_b).lo & 0xFFFF0000) \
+   ))
+
+
+typedef struct {
+    SYS_UINT32 hi;  // Bytes 5432 of flow id
+    SYS_UINT32 lo;  // Bytes 10xx of flow id, bottom 2 bytes zeroed always
+} clink_flow_id_t;
+
+typedef clink_flow_id_t flow_id_t;
+
+/* persistent name for a clink node, may differ from devices mac address */
+typedef mac_addr_t guid_mac_t;
+
+typedef mac_addr_t clink_guid_t;
+
+typedef SYS_UINT8 clink_node_id_t;
+
+typedef SYS_UINT32 clink_nodemask_t;
+
+typedef SYS_UINT8  moca_version_t;
+
+#define MOCA_FROM_NPS(_nps) ((moca_version_t)(((_nps) >> 24) & 0xFF))
+
+#define MOCA_01  ((moca_version_t)0x01)
+#define MOCA_10  ((moca_version_t)0x10)
+#define MOCA_11  ((moca_version_t)0x11)
+#define MOCA_1C  ((moca_version_t)0x1C) /* Future compatibility testing */
+
+/** Used internally to indicate that the true node protocol support field
+ * values are not yet known. */
+#define MOCA_UNSPECIFIED  ((moca_version_t)0x02)
+
+#define MOCA_TO_NPS(moca_version) ((moca_version) << 24)
+
+#define MOCA_VERSION_SPECIFIED(nps) (MOCA_FROM_NPS(nps)!=MOCA_UNSPECIFIED)
+
+/** Causes a compile time error if a condition is not true at compile time
+ * from within a function definition.
+ * 
+ * Note that the arguments to this must be evaluatable at compile time. If
+ * this check fails, you will see an error like: 'the size of an array must
+ * be greater than zero'. 
+ */
+#define INCTYPES_COMPILE_TIME_ASSERT(_condition)      \
+do                                                    \
+{                                                     \
+    extern int inctypes_assert[(_condition) ? 1 : 0]; \
+    (void)inctypes_assert;                            \
+} while (0)
+
+
+/** Given a reference to an array of definite size, return num elements */
+#define INCTYPES_ARRAY_LEN(_arrayVar) ( sizeof(_arrayVar) / sizeof(*_arrayVar) )
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is larger than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)    \
+struct _struct##_size_verify_lte_t                             \
+{                                                              \
+    int lo[(int)1 + (int)(_size) - (int)sizeof(_struct)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is smaller than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size) \
+struct _struct##_size_verify_gte_t                             \
+{                                                              \
+    int hi[(int)1 + (int)sizeof(_struct) - (int)(_size)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is not equal to the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_SIZE(_struct,_size)          \
+    INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)     \
+    INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size)
+
+/**
+ * A special macro that when passed the name of an enumeration or define
+ * will cause a compilation error if the value is larger than another 
+ * value.
+ */
+#define INCTYPES_VERIFY_TOKEN_LESS_THAN(_token,_size) \
+struct _token##_size_verify_lt_t                      \
+{                                                     \
+    int lo[(int)(_size) - (int)(_token)];             \
+};
+
+/**
+ * Utility to safely copy pointers to structures of the same size. This only 
+ * works in evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_PTR_COPY(_destPtr,_srcPtr)                             \
+do                                                                           \
+{                                                                            \
+    INCTYPES_COMPILE_TIME_ASSERT(sizeof(*(_destPtr)) == sizeof(*(_srcPtr))); \
+                                                                             \
+    memcpy((_destPtr),(_srcPtr),sizeof(*(_destPtr)));                        \
+} while (0)
+
+/**
+ * Utility to safely copy variables of the same size.  This only works in 
+ * evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_VAR_COPY(_dest,_src) \
+        INCTYPES_SAFE_PTR_COPY((&(_dest)),(&(_src)))
+
+/**
+ * Utility to safely zero a structure referred to by a typed pointer. This only 
+ * works in evironments implementing memset.
+ */
+#define INCTYPES_SAFE_PTR_ZERO(_destPtr)        \
+    memset((_destPtr),0,sizeof(*(_destPtr)))    
+
+/**
+ * Utility to safely zero a variable. This only works in evironments 
+ * implementing memset.
+ */
+#define INCTYPES_SAFE_VAR_ZERO(_destVar)        \
+    memset(&(_destVar),0,sizeof(_destVar))
+
+
+
+/*******************************************************************************
+*                        G l o b a l   C o n s t a n t s                       *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                           G l o b a l   D a t a                              *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                            I n t e r f a c e s                               *
+********************************************************************************/
+
+
+#endif /* __INCTYPES_H__ */
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,695 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response );
+static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr, 
+                                         struct clnk_io *uio, struct clnk_io *kio );
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio, 
+                                          struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+                                          void *odata );
+
+
+/****************************************************************************
+*                      IOCTL Methods                                        *
+*****************************************************************************/
+
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV 
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_driver_cmd_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV 
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32 cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_PRIV    
+    //HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( CLNK_CTL_FOR_DRV(cmd)) {
+            error = clnk_ctl_drv( dkcp, cmd, &kio );
+        } else if( CLNK_CTL_FOR_ETH(cmd) ) {
+            error = Clnk_ETH_Control_drv( dccp, CLNK_ETH_CTRL_DO_CLNK_CTL, cmd, (SYS_UINTPTR)&kio, 0);
+
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+        }
+
+        // send reply back to IOCTL caller
+        if( !error ) {
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_PRIV    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *              This is a daemon sending a command mailbox request 
+ *              and expecting a response.
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              arg      - request structure from user via kernel
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response )
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mbox_cmd_request_work( dkcp, &kifr, response ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              kifr     - kernel ifr pointer
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response )
+{
+    dc_context_t   *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR    param1, param2, param3;
+    SYS_INT32      error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32     cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_CMDQ    
+    HostOS_PrintLog(L_INFO, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( response ) {
+
+            // send MESSAGE - wait for response
+
+            error = clnk_cmd_msg_send_recv(       dccp, kifr->cmd, param1, &kio ) ;
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+
+        } else {
+
+            // send MESSAGE
+
+            error = clnk_cmd_msg_send( dccp, kifr->cmd, param1, &kio ) ;
+
+        }
+
+        if( !error ) {
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_CMDQ    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for unsolicited message retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg ) 
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mbox_unsolq_retrieve_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for sw unsolicited retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR     param1, param2, param3;
+    SYS_INT32       error = SYS_SUCCESS;
+    struct clnk_io  uio, kio ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_UNSOLQ    
+    //HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( uio.out_len != MAX_UNSOL_MSG )
+        {
+            _ioctl_dbg( dkcp, "SW UNSOL length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            error = Clnk_MBX_RcvUnsolMsg( &dccp->mailbox, (SYS_UINT32 *)dccp->clnk_ctl_out ) ;
+            if( !error ) {
+                // send reply back to IOCTL caller
+                error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+            }
+        }
+    }
+
+#if DEBUG_IOCTL_UNSOLQ    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_read( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mem_read_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM    
+    //HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        // check stuff
+        if( (uio.out_len == 0) ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL 0 out length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            addr = kio.in_len ? kio.in[0] : ((SYS_UINTPTR)kio.in);
+
+            // the READ
+
+            clnk_blk_read( dccp, addr, (SYS_UINT32 *)kio.out, kio.out_len ) ;
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM 
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_write( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mem_write_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr, *data, len ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM    
+    //HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        addr = kio.in[0];               // first  in long is the address
+        data = &kio.in[1];              // second in long is the first data long
+        len  = kio.in_len - sizeof(SYS_UINT32);  // len is the block length less the address long
+        if( len < sizeof(SYS_UINT32) )
+        {
+            // kio.in_len includes the address (4 bytes) and the data
+            /* minimum write is 1 word */
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL min write");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        } else {
+
+            // the WRITE
+            clnk_blk_write(dccp, addr, (SYS_UINT32 *)data, len);
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM 
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+/**
+ *  Purpose:    Copies the IOCTL request block to kernel space
+ *              Maybe performs some checks.
+ *
+ *  Imports:    arg  - request structure from user via kernel
+ *              kifr - kernel space block to recieve IOCTL request block       
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+    // copy the user's request block to kernel space
+    if( HostOS_copy_from_user( (void *)kifr, arg, sizeof(IfrDataStruct)) ) {
+        HostOS_PrintLog(L_INFO, "fault: %p\n", arg );
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    } else {
+		// cursory checks
+        if( (SYS_INT32)kifr->param3 != CLNK_CTL_VERSION ) {
+            HostOS_PrintLog(L_INFO, "fault: version not %d\n", CLNK_CTL_VERSION );
+            error = -SYS_PERMISSION_ERROR ;
+        }
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    Setup io block for IOCTL 
+ *
+ *              This is called after clnkioc_copy_request_block()
+ *
+ *              The io block is copied from user space to kernel space
+ *              into the uio. The uio is then used to setup the kio.
+ *
+ *  Imports:    dccp - driver control context pointer
+ *              kifr - kernel ifr pointer
+ *              uio  - io block copied from user space
+ *              kio  - kernel io block
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr, 
+                                         struct clnk_io *uio, struct clnk_io *kio )
+{
+    SYS_UINTPTR  param1, param2 ;
+    SYS_INT32    error = SYS_SUCCESS;
+    SYS_UINT32   in_len, max_in, max_out;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block pointer
+
+    // copy the user's io block to kernel space
+    if( HostOS_copy_from_user( uio, (void *)param2, sizeof(struct clnk_io)) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (uio)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    } else {
+
+        in_len = uio->in_len;
+
+        max_in  = CLNK_CTL_MAX_IN_LEN;
+        max_out = CLNK_CTL_MAX_OUT_LEN;
+
+        if( (in_len > max_in)        || 
+            (in_len & 3)             || 
+            (uio->out_len > max_out) ||
+            (uio->out_len & 3)          ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL lengths");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+            if( in_len ) {   // 'in' to the driver
+                // copy data block to fixed buffer
+                if( HostOS_copy_from_user( dccp->clnk_ctl_in, uio->in, uio->in_len) )
+                {
+                    _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (data in)");
+                    error = -SYS_INVALID_ADDRESS_ERROR;
+                } else {
+                    // set the kio 'in' pointer
+                    kio->in     = (SYS_UINT32 *)( dccp->clnk_ctl_in );
+                    kio->in_len = in_len;
+                }
+            } else {
+                /* if in_len is 0, uio.in is an integer single argument */
+                kio->in     = uio->in;
+                kio->in_len = 0;
+            }
+            // set the kio 'out' pointer
+            kio->out     = (SYS_UINT32 *)( dccp->clnk_ctl_out );
+            kio->out_len = uio->out_len;
+            // Note that some IOCTLs require out_len non-zero - we don't check for that.
+        }
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    Reply back to the IOCTL caller by copying the io block
+ *              and data, if any, back to user space.
+ *
+ *              This is called at the end of the IOCTL operation
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              uio      - user io block pointer, in kernel space
+ *              kio      - kernel io block pointer
+ *              us_ioblk - user space pointer to user io block
+ *              odata    - out data, in kernel space
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio, 
+                                          struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+                                          void *odata )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+
+    /* update out length if shorter now */
+    if( kio->out_len < uio->out_len ) {
+
+        uio->out_len = kio->out_len;     // set new length
+
+        // copy length to user space - along with the rest of the io block
+        if( HostOS_copy_to_user( (void *)us_ioblk, (void *)uio, sizeof(struct clnk_io)) )
+        {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (uio)");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        }
+    }
+
+    if( uio->out_len &&       // if supposed to return data
+        HostOS_copy_to_user( uio->out, odata, uio->out_len) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (out data)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    }
+
+    return( error );
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo_common.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo_common.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo_common.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo_common.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,258 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo_common.c
+*
+* Description: ioctl common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+/**
+* 
+*   Purpose:    Sends and receives a command message.
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+*                         Note: If io->in_len is 0, io->in is treated as a 
+*                               single argument
+*
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob )  // io block pointer
+{
+    int             error ;
+    Clnk_MBX_Msg_t  mbxMsg;
+    int             len;
+    SYS_INT32       out_len ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);          /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & ~CLNK_CMD_DST_MASK;      /* wd 1 */
+    mbxMsg.msg.ethCmd.param[1] = 0;                                 /* wd 2 */
+
+    if( iob->in_len )
+    {
+        /* send a blob of data down to the SoC */
+        int i;
+        
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);  // get number of longs
+        for(i = 0; i < len; i++) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];            /* wd 3+ */
+        }
+    } else {
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in;          /* wd 3 */
+        len = 1;
+    }
+
+#if ECFG_FLAVOR_VALIDATION==1
+    if (cmd == CLNK_CTL_VAL_TRIGGER_MBOX_EVENT)
+    {
+        clnkEth_valMboxHostCounts.triggeredSendRcvs++;
+    }
+#endif
+
+    // send message - wait for and receive response
+
+    error = Clnk_MBX_SendRcvMsg( &dccp->mailbox, &mbxMsg, &mbxMsg,
+                                    3 + len, MBX_POLL_TIMEOUT_IN_US);
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg, subcmd = %x, error = %d\n", rq_scmd, error);
+    /*
+    * status is the status of the mailbox transaction itself
+    *
+    * CLNK_MBX_GET_STATUS() reports the replyStatus from
+    *   ETH_ProcDataBufCmd() handler on the SoC (if the mailbox
+    *   transaction didn't fail)
+    */
+    if( !error &&
+        (CLNK_MBX_GET_STATUS(mbxMsg.msg.ethReply.status) == SYS_SUCCESS))
+    {
+        // extract out length
+        out_len = (CLNK_MBX_GET_REPLY_LEN(mbxMsg.msg.ethReply.status) << 2) - 4;
+
+        // adjust out length for reality
+        iob->out_len = MIN_VAL(iob->out_len, out_len);
+        if( iob->out_len )
+        {
+            // copy response to 'out' buffer
+            HostOS_Memcpy( iob->out, &mbxMsg.msg.ethReply.param[0], out_len);
+        }
+    }
+
+    return( error );
+}
+
+
+/*
+*   Purpose:    Reads a block of register address space into a buffer.
+*
+*               The block is read as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp            - control context
+*               sourceClinkAddr - beginning register address
+*               destHostAddr    - beginning memory buffer address
+*               length          - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_read_burst( dccp, sourceClinkAddr, destHostAddr, length, 1); //1 for SOC, 0 for FPGA
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, sourceClinkAddr += 4, destHostAddr++ ) {
+        clnk_reg_read(dccp, sourceClinkAddr, destHostAddr);
+    }
+
+#endif
+
+}
+
+/*
+*   Purpose:    Writes a buffer to a block of register address space.
+*
+*               The block is written as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp           - control context
+*               destClnkAddr   - beginning register address
+*               sourceHostAddr - beginning memory buffer address
+*               length         - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_write_burst( dccp, destClnkAddr, sourceHostAddr, length, 1); //for SOC
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, destClnkAddr += 4, sourceHostAddr++ ) {
+        clnk_reg_write(dccp, destClnkAddr, *sourceHostAddr);
+    }
+#endif
+}
+
+/**
+*   Purpose:    Sends command message 
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+* 
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob )  // io block pointer
+{
+    SYS_INT32           error = SYS_SUCCESS;
+    Clnk_MBX_Msg_t      mbxMsg;
+    int                 len, i;
+    SYS_UINT8           tid ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);                  /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & CLNK_CMD_BYTE_MASK;              /* wd 1 */             
+    mbxMsg.msg.ethCmd.param[1] = 0;                                         /* wd 2 */
+
+    if( iob->in_len )   // buffer to send
+    {
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);
+        for( i = 0 ; i < len ; i++ ) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];                    /* wd 3+ */
+        }
+    } else {            // single long to send
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in ;                 /* wd 3 */
+        len = 1;        // len is in longs
+    }
+
+    error = Clnk_MBX_SendMsg( &dccp->mailbox, &mbxMsg, &tid, 3 + len );
+
+    return( error );
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_call.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_call.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_call.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_call.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,217 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_call.c
+*
+* Description: mailbox common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**
+ * Callback function for unsolicited mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when an unsolicited
+ * message appears on the SW unsol queue.
+ *
+ * Unsolicited messages poked into the hardware mailbox CSRs are unsupported
+ * and should never be produced by the embedded.
+ * 
+ * vcp       - void pointer to control context
+ * pMsg      - Struct containing newly received message in DRIVER SPACE
+ *             Some of the cases in this function modify this message
+ *
+ * Returns 1 for message consumed. 0 for message NOT consumed.
+ *
+*PUBLIC***************************************************************************/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg)
+{
+    int consumed = 1 ;              // message consumed flag
+    dc_context_t *dccp = vcp;
+    switch (pMsg->msg.maxMsg.msg[0])
+    {
+        case CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS:
+        case CLNK_MBX_UNSOL_MSG_BEACON_STATUS:
+        case CLNK_MBX_UNSOL_MSG_RESET:
+            consumed = 0 ;
+            break;
+
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_PUB:
+            break;
+#endif
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_UNPUB:
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_NODE_ADDED:
+            break;
+        case CLNK_MBX_UNSOL_MSG_NODE_DELETED:
+            break; 
+//#ifdef CLNK_ETH_PHY_DATA_LOG
+        case CLNK_MBX_UNSOL_MSG_EVM_DATA_READY:
+            //HostOS_PrintLog(L_INFO, "FSUPDATE: IMO Node = %d\n", pMsg->msg.maxMsg.msg[1]);
+               
+            if (dccp->evmData)
+            {
+                int i;
+
+                dccp->evmData->valid = SYS_FALSE;                   // Don't let others read the data while it s updated
+                dccp->evmData->NodeId = pMsg->msg.maxMsg.msg[1];    // Get the data 
+                for (i=0;i<256;i++)
+                {    
+                    dccp->evmData->Data[i]=0;
+                }
+                dccp->evmData->valid = SYS_TRUE;      
+            }            
+            consumed = 0 ;
+            break;
+//#endif
+#ifdef CLNK_ETH_ECHO_PROFILE
+         #define NUMBER_OF_RX_ECHO_PROBE_SYMBOLS 3
+         #define EP_RX_PROBE_SIZE ((256 + NUMBER_OF_RX_ECHO_PROBE_SYMBOLS*(256 + 64)) * 4)
+        case CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE:
+            consumed = 0 ;
+            break;
+#endif
+#if (NETWORK_TYPE_ACCESS)
+        case CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC:
+            consumed = 0 ;
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_TABOO_INFO:
+            HostOS_PrintLog(L_INFO, "FSUPDATE: Taboo Mask = 0x%06x, Offset = %d\n",
+                            pMsg->msg.maxMsg.msg[1] >> 8,
+                            pMsg->msg.maxMsg.msg[1] & 0x0ff);
+            consumed = 0 ;
+            break;
+        case CLNK_MBX_UNSOL_MSG_FSUPDATE:
+            HostOS_PrintLog(L_INFO,
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            800 +  ((pMsg->msg.maxMsg.msg[1] & 0x00ff) * 25),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);
+            consumed = 0 ;
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY:
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES:
+            break;
+
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT:
+            consumed = 0 ;
+            break ;
+#endif
+        default:
+            consumed = 0 ;
+            break;
+    }
+
+    return( consumed ) ;
+}
+
+
+/**
+ * \brief Callback function for HOST_ORIG mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when a mailbox
+ * reply to a HOST_ORIG message is received.
+ *
+ * The only message we actually process in this callback is the
+ * ETH_MB_GET_STATUS / CLNK_MBX_ETH_GET_STATUS_CMD response.
+ * socStatusEmbedded is used later in Get SocStatus().
+ *
+ * \param[in] pvContext void pointer to our dc_context_t
+ * \param[in] pMsg Struct containing newly received message
+ *
+*PUBLIC*****************************************************************/
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg)
+{
+#if 000
+    dc_context_t *dccp = vcp;
+    SYS_UINT8  transID;
+
+    transID = (SYS_UINT8)CLNK_MBX_GET_TRANS_ID(pMsg->msg.ethReply.status);
+    if (transID == dccp->socStatusLastTransID)
+    {
+        /*
+         * This reply comes from ETH_MB_GET_STATUS in the embedded.
+         * If there was a reset condition, it copied the reset reason into
+         * param[0].  Otherwise, it wrote 0.
+         */
+        if (pMsg->msg.ethReply.param[0] != 0)
+        {
+            dccp->socStatusEmbedded =
+                CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE |
+                ((pMsg->msg.ethReply.param[0] & 0xffff) << 16);
+        }
+        dccp->socStatusInProgress  = SYS_FALSE;
+        dccp->socStatusLastTransID = 0;
+    }
+#endif
+}
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_dvr.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_dvr.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1611 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_dvr.c
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+// Mailbox version number
+#define VER_NUM                  0x00
+
+// Queue Constants
+#define CMD_QUEUE_MASK           (CLNK_MBX_CMD_QUEUE_SIZE-1)
+#define SWUNSOL_QUEUE_MASK       (CLNK_MBX_SWUNSOL_QUEUE_SIZE-1)
+
+// Transaction ID Constants
+#define HOST_ORIG_BIT            0x80UL
+#define UNSOL_TYPE_BIT           0x40UL
+
+#if ECFG_CHIP_ZIP1
+  #define IS_READ_INTERRUPT(y)     ((y) & \
+          (CLNK_REG_PCI_READ_MBX_SEM_SET_BIT | CLNK_REG_PCI_SW_INT_1_BIT))
+  #define IS_WRITE_INTERRUPT(y)    ((y) & (CLNK_REG_PCI_WRITE_MBX_SEM_CLR_BIT))
+  #define IS_SW_UNSOL_INTERRUPT(x) ((x) & CLNK_REG_PCI_SW_INT_1_BIT)
+  #define ACK_SW_UNSOL_INTERRUPT(x) \
+          { clnk_reg_write((x)->dc_ctx, CLNK_REG_SLAVE_1_MAP_ADDR, (x)->swUnsolQueueSlaveMap); }
+#else
+  #define IS_READ_INTERRUPT(y)     1
+  #define IS_WRITE_INTERRUPT(y)    1
+  #define IS_SW_UNSOL_INTERRUPT(x) 1
+  #define ACK_SW_UNSOL_INTERRUPT(x) {}
+#endif // ECFG_CHIP_ZIP1
+
+#define UMSG_ELEMENT(x, y)      ((x) + offsetof(Clnk_MBX_SwUnsolQueueEntry_t, y))
+
+
+/*******************************************************************************
+*                             D a t a   T y p e s                              *
+********************************************************************************/
+
+/*******************************************************************************
+*                             C o n s t a n t s                                *
+********************************************************************************/
+
+/*******************************************************************************
+*                             G l o b a l   D a t a                            *
+********************************************************************************/
+
+/*******************************************************************************
+*                       M e t h o d   P r o t o t y p e s                      *
+********************************************************************************/
+
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx );
+static int Clnk_MBX_wqt_condition( void *vmp );
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data);
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                           Clnk_MBX_Msg_t     *pMsg,
+                           SYS_UINT8          transID);
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID);
+static void Clnk_MBX_Init_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx);
+#endif
+
+/*******************************************************************************
+*                      M e t h o d   D e f i n i t i o n s                     *
+********************************************************************************/
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the Mailbox Module.
+*
+* Inputs:
+*       pMbx  - Pointer to the mailbox
+*       dcctx - pointer to the control context
+*       type  - Type of mailbox (Ethernet or MPEG)
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       It is assumed that sufficient time will elapse between the
+*       RST_STATE_INIT_CCPU and RST_STATE_INIT_MBX states of the
+*       reset state machine to allow the CCPU to initialize the
+*       mailbox registers before checking them in this routine
+*
+*******************************************************************************/
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type)
+{
+    SYS_UINT32 reg;
+    dc_context_t *dccp = (dc_context_t *)dcctx ;
+
+    //HostOS_PrintLog(L_ERR, "Clnk_MBX_Initialize\n" );
+    // Free any wqts
+    Clnk_MBX_Free_wqts( pMbx ) ;
+
+    // Initialize mailbox block
+    HostOS_Memset(pMbx, 0, sizeof(Clnk_MBX_Mailbox_t));
+
+    pMbx->dc_ctx             = dccp;
+    pMbx->type               = type;
+    pMbx->cmdCurrTransID     = HOST_ORIG_BIT;
+
+    // Initialize mailbox locks
+    pMbx->mbx_lock          = dccp->mbx_cmd_lock_link ; 
+    pMbx->swUnsolLock       = dccp->mbx_swun_lock_link ;
+
+    // Initialize register offsets
+    if (pMbx->type == CLNK_MBX_ETHERNET_TYPE)
+    {
+        pMbx->writeMbxCsrOffset  = CLNK_REG_MBX_WRITE_CSR;
+        pMbx->readMbxCsrOffset   = CLNK_REG_MBX_READ_CSR;
+        pMbx->writeMbxRegOffset  = CLNK_REG_MBX_REG_1;
+        pMbx->readMbxRegOffset   = CLNK_REG_MBX_REG_9;
+        pMbx->readMbxSize        = MAX_MBX_MSG;
+        pMbx->writeMbxSize       = MAX_MBX_MSG;
+    }
+#if 0
+    HostOS_PrintLog(L_INFO, "Initialize register offsets\n");
+    HostOS_PrintLog(L_INFO, "unsol  = %x\n",pMbx->pSwUnsolQueue);
+    HostOS_PrintLog(L_INFO, "writeMbxCsrOffset = %x\n",CLNK_REG_MBX_WRITE_CSR);
+    HostOS_PrintLog(L_INFO, "readMbxCsrOffset = %x\n",CLNK_REG_MBX_READ_CSR);
+    HostOS_PrintLog(L_INFO, "writeMbxRegOffset = %x\n",CLNK_REG_MBX_REG_1);
+    HostOS_PrintLog(L_INFO, "readMbxRegOffset = %x\n",CLNK_REG_MBX_REG_9);
+    HostOS_PrintLog(L_INFO, "readMbxSize  = %x\n",MAX_MBX_MSG);
+    HostOS_PrintLog(L_INFO, "writeMbxSize = %x\n",MAX_MBX_MSG);
+#endif
+    // allocate all wqts, setup timers and wait queues
+    Clnk_MBX_Alloc_wqts( pMbx ) ;
+
+    // Initialize the hardware mailbox
+    Clnk_MBX_Init_Hw_Mailbox(pMbx);
+
+    // Confirm that the CCPU has initialized the mailbox registers
+    // Register was cleared by host driver before CCPU was released,
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, &reg);
+//    if (0 == reg) 
+//        return (~SYS_SUCCESS);
+    
+    pMbx->mbxOpen = SYS_TRUE;
+    
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Frees all Mailbox message wqts.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( mp->msg_wqt )
+        {
+            HostOS_wqt_timer_del( mp->msg_wqt ) ;
+
+            HostOS_wqt_free( mp->msg_wqt );
+            mp->msg_wqt = 0 ;
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Terminates the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx)
+{
+    // Terminate mailbox lock
+    HostOS_TermLock(pMbx->mbx_lock);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       int                  Driver option to control
+*       SYS_UINT32           Register offset or pointer to register offsets
+*       SYS_UINT32           Register value or pointer to register values
+*       SYS_UINT32           Length of data for bulk data
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       Driver option                     Parameters
+*       -------------                     ----------
+*       CLNK_MBX_CTRL_ENABLE_INTERRUPT    reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_DISABLE_INTERRUPT   reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_CLEAR_INTERRUPT     reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_Q      reg    - Not used
+*                                         val    - Pointer to emb mem
+*                                         length - Number of entries
+*       CLNK_MBX_CTRL_SET_REPLY_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_UNSOL_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*
+*
+*******************************************************************************/
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length)
+{
+    int status = SYS_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_Q:
+            // Initialize the software unsolicited queue
+        #if ECFG_CHIP_ZIP1
+            pMbx->swUnsolQueueSlaveMap = (val & 0x0ffc0000) |
+                                         CLNK_REG_ADDR_TRANS_ENABLE_BIT;
+            pMbx->pSwUnsolQueue        =  val & 0x0003ffff;
+        #else
+            pMbx->pSwUnsolQueue        = val;
+        #endif 
+            pMbx->swUnsolQueueSize     = length;
+            pMbx->swUnsolReadIndex     = 0;
+            break;
+
+        case CLNK_MBX_CTRL_SET_REPLY_RDY_CB:
+            // Set the reply ready callback function   MbxReplyRdyCallback
+            pMbx->replyRdyCallback = (Clnk_MBX_RdyCallback)val;
+            pMbx->replyParam       = (void *)length;
+            break;
+
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB:
+            // Set the unsolicited ready callback function   MbxSwUnsolRdyCallback
+            pMbx->swUnsolRdyCallback = (Clnk_MBX_SwUnsolRdyCallback)val;
+            pMbx->swUnsolParam       = (void *)length; // context at this point
+            break;
+
+        default:
+            status = -SYS_BAD_MSG_TYPE_ERROR;
+            break;
+    }
+    return (status);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the interrupt for the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       SYS_UINT32           PCI interrupt status register
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus)
+{
+
+    // Check if hardware mailbox has command response
+    if (IS_READ_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Read_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox has unsolicited msg
+    if ( IS_SW_UNSOL_INTERRUPT(pciIntStatus) )
+    {
+        Clnk_MBX_Unsol_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox can take a command
+    if (IS_WRITE_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Write_ISR(pMbx);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Sends a mailbox message.
+*
+* Inputs:   pMbx     - Pointer to the mailbox
+*           pMsg     - Pointer to the message to send
+*           pTransID - Pointer to place to return the transaction ID
+*           len      - length of message in longs
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR     - mailbox not open
+*           -SYS_INVALID_ARGUMENT_ERROR    - invalid request, length
+*           -SYS_OUT_OF_SPACE_ERROR        - queue full, message dropped
+*
+*******************************************************************************/
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len)
+{
+    SYS_UINT32 index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if((len < 1) || (len > MAX_MBX_MSG))
+    {
+        HostOS_PrintLog(L_ERR, "warning: invalid mbx request: %d words\n", len);
+        return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    /*  
+        Check if mailbox is (too) full.  
+        Note that we always leave two entries empty.
+        This is the only place Send messages are queued so it's safe to say
+        that this is the only place where tail may attempt to overrun head.
+    */
+    if (((pMbx->cmdTailIndex+3) & CMD_QUEUE_MASK) == pMbx->cmdHeadIndex)
+    {
+        // mailbox full - log queuing error
+        HostOS_Unlock(pMbx->mbx_lock);
+        return (-SYS_OUT_OF_SPACE_ERROR);
+    }
+
+    // Save the transaction ID for the command
+    *pTransID = pMbx->cmdCurrTransID;    // push the transID back to the caller
+    index = pMbx->cmdTailIndex;
+    pMbx->cmdQueue[index].transID    = *pTransID;
+    pMbx->cmdQueue[index].isReplyRdy = SYS_FALSE;
+    pMsg->msg.cmdCode |=                                        // byte 0 = cmd
+                         CLNK_MBX_SET_TRANS_ID(*pTransID) |     // byte 1
+                         CLNK_MBX_SET_VER_NUM(VER_NUM)    |     // byte 2 lo nybl
+                         CLNK_MBX_SET_PORT(pMbx->type)    |     // byte 2 hi nybl
+                         CLNK_MBX_SET_LEN(len);                 // byte 3  (num longs)
+
+    // Copy message to into mail box buffer
+    HostOS_Memcpy(&pMbx->cmdQueue[index].sendMsg, pMsg, len * sizeof(SYS_UINT32));
+
+    // Check if Q empty and hardware mailbox is in use
+    if ((pMbx->cmdTailIndex == pMbx->cmdHeadIndex) &&
+        Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, pMsg);
+
+        // Effectively Q the msg. There might be a response
+        // Since the Q is empty move the head along, too, so head will stay at or ahead of tail
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+    else
+    {
+        //HostOS_PrintLog(L_NOTICE, "SendMsg to Q  tid=%02xx\n", *pTransID);
+
+        // Add entry to tail of command queue
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+
+    // Generate new transaction ID (make sure host originated bit is set)
+    pMbx->cmdCurrTransID++;
+    pMbx->cmdCurrTransID |= HOST_ORIG_BIT;
+
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+    // Automatically generate reply
+    AutoReplyMsg(pMbx);
+#endif
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Purpose:  Receives a sw unsolicited mailbox message.
+*           This reads messages that have not been internally
+*           consumed from the sw unsolicited Q.
+*           There may not be any such messages.
+*           There may have been a Q overrun.
+*
+* Imports:  pMbx    - Pointer to the mailbox
+*           pbuf    - Pointer to a kernel buffer to get the message
+*
+* Exports:  0           - success, no more messages
+*           -SYS_DIR_NOT_EMPTY_ERROR  - success, more messages
+*           -SYS_BAD_MSG_TYPE_ERROR   - no message, try again later
+*           -SYS_INPUT_OUTPUT_ERROR   - queue overrun, oldest message returned
+*                                       and the overrun error is cleared
+*           -SYS_INVALID_ADDRESS_ERROR- mailbox not open
+*                                       sw unsolicited Q not setup
+*                                       other
+*
+*******************************************************************************/
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf)
+{                   
+    SYS_UINT32      index;
+    int             error = 0 ;
+
+    if( !pMbx->mbxOpen)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    // Check if software unsolicited queue has been created
+    if( !error && pMbx->pSwUnsolQueue == 0)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    if( !error )
+    {
+        if( pMbx->swUnsolCount ) // we have message     
+        {
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // Copy message to receive buffer
+            index = pMbx->swUnsolHeadIndex;
+            HostOS_Memcpy(pbuf, 
+                          &pMbx->swUnsolQueue[index].msg.msg.maxMsg.msg, 
+                          MAX_UNSOL_MSG * sizeof(SYS_UINT32));
+
+            pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            pMbx->swUnsolCount-- ;          // uncount an item taken
+
+            if( pMbx->swUnsolCount ) // we have more
+            {
+                error = -SYS_DIR_NOT_EMPTY_ERROR ;
+            }
+            if( pMbx->swUnsolOverrun ) // we have overrun 
+            {
+                error = -SYS_INPUT_OUTPUT_ERROR ;
+                pMbx->swUnsolOverrun = 0 ;   // and clear it
+            }
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+        }
+        else
+        {
+            error = -SYS_BAD_MSG_TYPE_ERROR ;
+        }
+    }
+    return( error );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sends and receives a mailbox message.
+*
+* Inputs:   pMbx        - Pointer to the mailbox
+*           pSendMsg    - Pointer to the message to send
+*           pRcvMsg     - Pointer to the buffer for receiving message
+*           len         - length of send message
+*           timeoutInUs - Time to wait for reply in ms
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR    - I/O error
+*           -SYS_TIMEOUT_ERROR         - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs)
+{
+    SYS_UINT8                   transID;
+    int                         status;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    if (!pMbx->mbxOpen)
+    {
+        return (-SYS_INVALID_ADDRESS_ERROR);
+    }
+
+    // Send message    (get transaction ID)
+    status = Clnk_MBX_SendMsg(pMbx, pSendMsg, &transID, len);
+    //HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg send status=%d , transid=%x.\n", status,transID );
+    if (status != SYS_SUCCESS)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to send msg!!\n");
+        return (status);
+    }
+
+    // setup to wait
+    HostOS_Lock(pMbx->mbx_lock);
+
+    if( !Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // msg not ready - start wait
+        mp = &pMbx->cmdQueue[transID & CMD_QUEUE_MASK] ;
+        mp->isReplyTimedOut = 0 ;
+        HostOS_wqt_timer_set_timeout( mp->msg_wqt, HostOS_timer_expire_seconds(2));
+        HostOS_wqt_timer_add( mp->msg_wqt);
+
+        HostOS_Unlock(pMbx->mbx_lock);
+
+        HostOS_wqt_waitq_wait_event_intr( mp->msg_wqt,
+                                          Clnk_MBX_wqt_condition,
+                                          mp );
+
+        // done waiting
+        //HostOS_PrintLog(L_INFO, "We had to sleep!!\n");
+        HostOS_wqt_timer_del( mp->msg_wqt );
+    }
+    else
+    {
+        // msg ready already
+        //HostOS_PrintLog(L_INFO, "Msg read already - did not have to sleep\n");
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+
+    // msg should be ready now
+    if( Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // Get the reply
+        status = Clnk_MBX_RcvMsg(pMbx, pRcvMsg, transID);
+    }
+    else
+    {
+        status = -SYS_TIMEOUT_ERROR ;  // timeout - no message
+    }
+
+    return (status);
+}
+
+
+// define U_SHOW_TRAFFIC to see unsol traffic
+#define xU_SHOW_TRAFFIC
+// define Q_SHOW to see the unsol Q
+#define xQ_SHOW
+// define Q_RESYNC to try to resync the unsol Q for when the SOC overruns it
+#define xQ_RESYNC
+
+#ifdef Q_SHOW
+extern int strcpy(char *, const char *) ;
+extern int strcmp(const char *, const char *) ;
+extern unsigned long volatile jiffies;
+#endif
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the read interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+    SYS_UINT32          offset, regVal;
+    SYS_UINT8           transID, index ;
+
+    if (Clnk_MBX_Read_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Get the transaction ID
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &offset);
+#if ECFG_CHIP_ZIP1
+        offset &= 0x3ffff;
+#endif
+        clnk_reg_read(pMbx->dc_ctx, offset, &regVal);
+        transID = regVal & 0xff;
+
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_Read_ISR transid=%d \n", transID );
+        if (transID & HOST_ORIG_BIT)
+        {
+            index = transID & CMD_QUEUE_MASK;
+
+            // Lock the mailbox
+            HostOS_Lock(pMbx->mbx_lock);
+
+            // Check if transaction ID is valid
+            if (pMbx->cmdQueue[index].transID != transID)
+            {
+                // Toss message if transaction ID is not valid
+                Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);
+
+                // Unlock the mailbox
+                HostOS_Unlock(pMbx->mbx_lock);
+
+                return;
+            }
+
+            // Read message from hardware mailbox
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, &pMbx->cmdQueue[index].rcvMsg);
+
+            // Mark reply as received
+            pMbx->cmdQueue[index].isReplyRdy = SYS_TRUE;
+//HostOS_PrintLog(L_INFO, "In ClnkMBX_READ_ISR  replyRdy = true\n");
+            // Call reply ready callback function
+            if (pMbx->replyRdyCallback != SYS_NULL)
+            {           // MbxReplyRdyCallback
+                pMbx->replyRdyCallback(pMbx->replyParam,
+                                       &pMbx->cmdQueue[index].rcvMsg);
+            }
+
+            // Unlock the mailbox
+            HostOS_Unlock(pMbx->mbx_lock);
+            HostOS_wqt_waitq_wakeup_intr( pMbx->cmdQueue[index].msg_wqt );
+
+        }
+        else
+        {
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);       // discard this type of unsolicited msg
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the write interrupt.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+
+    if (Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if command queue is emtpy
+        if (pMbx->cmdHeadIndex == pMbx->cmdTailIndex)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return;
+        }
+
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, &pMbx->cmdQueue[pMbx->cmdHeadIndex].sendMsg);
+
+        // Remove entry from head of command queue
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the unsolicited message (read) interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx )
+{
+    SYS_UINT32          tid;
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership, i, *up, *qp, type ;
+    int                 consumed ;
+    Clnk_MBX_Msg_t      mbuf;
+#ifdef Q_SHOW
+    int                 hit ;
+    SYS_UINT32          pSwUnsolMsgX;
+    static char         ox[SW_UNSOL_HW_QUEUE_SIZE+1] ;
+    static SYS_UINT8    dexx ;
+#endif
+    // Check if software unsolicited queue has been created
+    if (pMbx->pSwUnsolQueue == 0)
+    {
+        return;
+    }
+
+    // Process the unsolicited messages
+
+    ACK_SW_UNSOL_INTERRUPT(pMbx);
+#if 1
+// for loop with clnk_reg_read caused hang
+    for ( ; ; )
+    {
+        // get the current index
+        index = pMbx->swUnsolReadIndex;
+
+        // Check ownership bit
+        pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+        clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+        if (!ownership)
+        {
+            break ;
+        }
+#if 1
+        // we have a message, process it
+
+        // Generate transaction ID (make sure host originated bit is clear)
+        pMbx->swUnsolCurrTransID = index;
+        pMbx->swUnsolCurrTransID &= ~HOST_ORIG_BIT;
+        pMbx->swUnsolCurrTransID |= UNSOL_TYPE_BIT;
+        tid = pMbx->swUnsolCurrTransID;
+
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, transID), tid);
+
+        // process the message
+
+        // copy from hw Q to local msg buffer
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+#if 1
+        for (i = 0; i < MAX_UNSOL_MSG; i++, up++)
+        {
+            clnk_reg_read(pMbx->dc_ctx,
+                            UMSG_ELEMENT(pSwUnsolMsg, msg[0]) + (i << 2),
+                            up);
+        }
+#endif
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+        type = *up ;
+
+        consumed = 0 ;
+#if 1
+        if (pMbx->swUnsolRdyCallback != SYS_NULL)      // if there's a callback, call it
+        {               // MbxSwUnsolRdyCallback
+            consumed = pMbx->swUnsolRdyCallback(pMbx->swUnsolParam, &mbuf);
+#ifdef U_SHOW_TRAFFIC
+            if( consumed )
+            {
+                HostOS_PrintLog(L_NOTICE, "sw unsol msg, type=%d. consumed=%d tid=%xx\n",
+                                type, consumed, tid );
+            }
+#endif
+        }
+#endif
+#if 1
+        if( !consumed )
+        {
+            // queue msg in sw Q
+
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // copy from buffer to sw Q
+            qp = &pMbx->swUnsolQueue[pMbx->swUnsolTailIndex].msg.msg.maxMsg.msg[0] ; 
+            for (i = 0; i < MAX_UNSOL_MSG; i++)
+            {
+                *qp++ = *up++ ; 
+            }
+            up = &mbuf.msg.maxMsg.msg[0] ; 
+
+            if( pMbx->swUnsolCount == SW_UNSOL_HW_QUEUE_SIZE )
+            {  // if max count pMbx->swUnsolOverrun = 1 ;      // flag an error
+                // move head to oldest
+                pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            }
+            else
+            {
+                pMbx->swUnsolCount++ ;          // count an item added
+            }
+            // move tail off newest
+            pMbx->swUnsolTailIndex = (pMbx->swUnsolTailIndex+1) & SWUNSOL_QUEUE_MASK;
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+#ifdef U_SHOW_TRAFFIC
+            HostOS_PrintLog(L_NOTICE, "sw unsol msg Qd, type=%d. cnt=%d. tid=%xx\n",
+                            *up, pMbx->swUnsolCount, tid );
+#endif
+        }
+
+#endif
+        // Clear ownership
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), 0);
+
+        // Increment HW's read index
+        pMbx->swUnsolReadIndex = (pMbx->swUnsolReadIndex+1) % pMbx->swUnsolQueueSize;
+#endif
+    }
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to read
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &regVal);
+//HostOS_PrintLog(L_INFO, "HostCheckMailboxAvailToRead: readMbxCsrOffset = %x, regVal = %x \n",
+//                pMbx->readMbxCsrOffset, regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) != 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to write.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to write, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to write
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) == 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the write cmd message mailbox is empty.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 = empty, 0 = !empty
+*
+*******************************************************************************/
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx)
+{
+    int mt ;
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    // Check if command queue is emtpy
+    mt = (pMbx->cmdHeadIndex == pMbx->cmdTailIndex) ;
+    
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+    return( mt ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware unsolicited mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership ;
+
+    ownership = 0 ;
+
+    // get the current index
+    index = pMbx->swUnsolReadIndex;
+
+    // Check ownership bit
+    pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+//    HostOS_PrintLog(L_INFO, "In Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready: pMbx->pSwUnsolQueue=%x, index=%d, sizeofSwUnsolEntry=%d\n",
+//                    pMbx->pSwUnsolQueue, index , sizeof(Clnk_MBX_SwUnsolQueueEntry_t));
+    clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+//    clnk_reg_read(pMbx->dc_ctx, 0x8c00b204, &ownership);
+if (ownership == 1)
+    return(1);
+else 
+    return(0);
+}
+
+
+/*******************************************************************************
+*
+* Description:
+*       Allocates all Mailbox message wqts.
+*       Sets up the timer and wq.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( !mp->msg_wqt ) {
+            mp->msg_wqt = HostOS_wqt_alloc( );
+            if( mp->msg_wqt )
+            {
+                HostOS_wqt_waitq_init( mp->msg_wqt );
+                HostOS_wqt_timer_init( mp->msg_wqt );
+                HostOS_wqt_timer_setup( mp->msg_wqt , 
+                                        Clnk_MBX_msg_timer, 
+                                        (SYS_UINTPTR)mp ) ;
+            }
+            else
+            {
+                HostOS_PrintLog(L_ERR, "Cannot allocate wqt.\n" );
+                break ;
+            }
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Wait q condition expression check.
+*
+* Inputs:   vmp - Pointer to a mailbox message
+*
+* Outputs:  true/false
+*
+*******************************************************************************/
+static int Clnk_MBX_wqt_condition( void *vmp )
+{
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+    int cond ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)vmp ;
+
+    cond = (mp->isReplyTimedOut || mp->isReplyRdy) ;
+//HostOS_PrintLog(L_NOTICE, "<wqt> cond=%d. to=%d. rdy=%d.\n",
+//                cond, mp->isReplyTimedOut, mp->isReplyRdy );
+/*
+if (cond)
+    HostOS_PrintLog(L_INFO, "reply = %x\n", mp->isReplyRdy);
+*/
+    return( cond ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       msg timer expiration function.
+*
+* Inputs:
+*       data    - Pointer to the mailbox message with timeout
+*
+* Outputs:
+*
+*******************************************************************************/
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data)
+{
+    Clnk_MBX_CmdQueueEntry_t *mp ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)data ;
+    mp->isReplyTimedOut = 1 ;
+    HostOS_wqt_timer_del( mp->msg_wqt );
+    HostOS_wqt_waitq_wakeup_intr( mp->msg_wqt );
+//HostOS_PrintLog(L_NOTICE, "<msgtimer> expired\n" );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Receives a mailbox message.
+*
+* Inputs:   pMbx    - Pointer to the mailbox
+*           pMsg    - Pointer to the buffer for receiving message
+*           transID - Transaction ID of message to receive
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR  - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR     - I/O error
+*           -SYS_TIMEOUT_ERROR          - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                    Clnk_MBX_Msg_t     *pMsg,
+                    SYS_UINT8          transID)
+{
+    SYS_UINT32      index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if (transID & HOST_ORIG_BIT)
+    {
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg recv tid=%02xx\n", transID);
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if the transaction ID is still valid
+        index = transID & CMD_QUEUE_MASK;
+        if (pMbx->cmdQueue[index].transID != transID)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_INPUT_OUTPUT_ERROR);
+        }
+
+        // Check if reply has been received
+        if (!pMbx->cmdQueue[index].isReplyRdy)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_TIMEOUT_ERROR);
+        }
+
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg tid=%02xx\n", transID );
+
+        // Copy message to receive buffer
+        HostOS_Memcpy(pMsg, &pMbx->cmdQueue[index].rcvMsg, sizeof(*pMsg));
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+//HostOS_PrintLog(L_NOTICE, "<rm>\n" );
+    }
+    else
+    {
+        return (-SYS_INPUT_OUTPUT_ERROR);
+    }
+
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if a reply has been received.
+*
+* Inputs:
+*       pMbx    - Pointer to the mailbox
+*       transID - Transaction ID of message to check
+*
+* Outputs:
+*       1 if a reply has been received, 0 otherwise
+*
+* Notes:
+*       None
+*
+*******************************************************************************/
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID)
+{
+    SYS_UINT32  index;
+    int         rdy ;
+
+    rdy = 123456 ;
+
+    // Check if transaction ID is valid
+    if ((transID & HOST_ORIG_BIT) == 0)
+    {
+        return (0);
+    }
+
+    // we're just reading, no lock
+
+    index = transID & CMD_QUEUE_MASK;
+    if (pMbx->cmdQueue[index].transID != transID)
+    {
+        return (0);
+    }
+
+    //HostOS_PrintLog(L_NOTICE, "x\n" );
+    rdy = (volatile int)(pMbx->cmdQueue[index].isReplyRdy) ;
+    //HostOS_PrintLog(L_NOTICE, "x%d\n", rdy );
+
+    // Check if reply has been received
+    if( rdy )
+    {
+        //HostOS_PrintLog(L_INFO, "reply has been received \n");
+        return (1);
+    }
+        //HostOS_PrintLog(L_INFO, "reply has not been received \n");
+    return (0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Intializes the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+static void Clnk_MBX_Init_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx)
+{
+#if 0
+    SYS_UINT32 i;
+    SYS_UINT32 reg;
+
+    // Initialize mailbox
+
+    // clear write ready
+    clnk_reg_write(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, 0);
+
+    // clear write mailbox
+    reg = pMbx->writeMbxRegOffset;
+    for (i = 0; i < pMbx->writeMbxSize; i++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, 0);
+        reg += 4;
+    }
+
+    // clear read ready
+    clnk_reg_write(pMbx->dc_ctx, pMbx->readMbxCsrOffset, 0);
+
+    // clear read mailbox
+    reg = pMbx->readMbxRegOffset;
+    for (i = 0; i < pMbx->readMbxSize; i++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, 0);
+        reg += 4;
+    }
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clears the read mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &val);
+    val &= ~CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->readMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sets the write hardware mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &val);
+    val |= CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Reads a message from the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the buffer for reading message
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+
+    // Read message from mailbox
+    if (pMsg != SYS_NULL)
+    {
+        SYS_UINT32 reg, lastReg;
+
+        // Read location of mailbox message
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+        reg &= 0x0003ffff;
+#endif
+
+        // Read first word
+        clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        len = CLNK_MBX_GET_REPLY_LEN(*pMsg);
+        reg += 4;
+        pMsg++;
+        
+        if((len < 1) || (len > MAX_MBX_MSG))
+        {
+            HostOS_PrintLog(L_ERR, "warning: invalid mbx reply: %d words\n", len);
+            HostOS_Memset(pMsg, 0, sizeof(*pMsg));
+            return;
+        }
+
+        // Read subsequent words, if necessary
+        lastReg = reg + ((len-1) * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+
+#if 0
+        SYS_UINT32 reg = pMbx->readMbxRegOffset;
+        SYS_UINT32 lastReg = reg + (pMbx->readMbxSize * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+#endif
+    }
+
+    Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(pMbx);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Writes a message to the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the message to write
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+    SYS_UINT32  reg, lastReg;
+
+    // Read location of mailbox message
+//HostOS_PrintLog(L_INFO, "In Clnk_MBX_Write_Hw_Mailbox: writeMbxRegOffset=%x\n",pMbx->writeMbxRegOffset);
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+    reg &= 0x0003ffff;
+#endif
+
+    // Write message to mailbox
+    len = CLNK_MBX_GET_CMD_LEN(*pMsg);
+    lastReg = reg + (len * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+//HostOS_PrintLog(L_INFO, "C_MBX_Wr_Hw_Mbx a=%08x data=%08x\n", reg, *pMsg );
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+
+#if 0
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  reg = pMbx->writeMbxRegOffset;
+    SYS_UINT32  lastReg = reg + (8 * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+#endif
+
+    Clnk_MBX_Write_Hw_Mailbox_Set_Ready(pMbx);
+}
+
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static 
+void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check the write semaphore bit
+    for ( ; ; )
+    {
+        clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &regVal);
+        if (regVal & CLNK_REG_MBX_SEMAPHORE_BIT)
+        {
+            break;
+        }
+    }
+
+    // Loop back message
+    clnk_reg_read(pMbx->dc_ctx,  CLNK_REG_MBX_REG_1,  &regVal);
+    regVal >>= 8;
+    regVal &= 0xff;
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_9,  regVal);
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, 0);
+
+    // Set the read semaphore bit
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_READ_CSR, CLNK_REG_MBX_SEMAPHORE_BIT);
+}
+#endif
+
+
+//BRJ temp to test sending of mailbox message and recieving response via interrupt
+#ifdef SEND_MBX_MSG_TEST
+int Clnk_MBX_SendTestMsg( void* pvMailBox )
+{
+    ClnkDef_MyNodeInfo_t NodeInfo;
+    Clnk_MBX_Mailbox_t* pMbx;
+    SYS_UINT32  u32Val;
+    pMbx = ( Clnk_MBX_Mailbox_t* )pvMailBox;
+
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &u32Val);
+    if( 0 == ( CLNK_REG_MBX_SEMAPHORE_BIT & u32Val))
+    {
+        // mailbox is available to write to
+        // get interrupt status for debugging
+#if !ECFG_CHIP_ZIP1
+        clnk_reg_read(pMbx->dc_ctx, CLNK_MBX_INTERRUPT_REG, &u32Val);
+#endif // !ECFG_CHIP_ZIP1
+        // set command
+        NodeInfo.ClearStats = 0;
+        u32Val = CLNK_ETH_CTRL_GET_MY_NODE_INFO;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, u32Val);
+        // set params 
+        u32Val = CLNK_MBX_SET_CMD( CLNK_MBX_ETH_DATA_BUF_CMD ); 
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_2, u32Val);
+    
+        u32Val = sizeof(ClnkDef_MyNodeInfo_t);
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_3, u32Val);
+    
+        u32Val = NodeInfo.ClearStats;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_4, u32Val);
+    
+        // tell clink we wrote a message
+        u32Val = CLNK_REG_MBX_SEMAPHORE_BIT;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, u32Val);
+    }
+    return (SYS_SUCCESS);
+}
+#endif // SEND_MBX_MSG_TEST
+
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread main loop function. it processes mbox messages etc.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_Kthread_Mainloop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+  
+    while(1)
+    {
+        if(dccp->clnkThreadStop == CLNK_TASK_RUNNING)
+        {
+            //PCI mode, CAM processing
+            //Clnk_ETH_Cam_Proc(dccp);
+        
+            //MBOX processing
+            Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+            Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+            //Unsol msg processing
+            if(Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ))
+            {
+               Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+            }
+        }
+        else
+            dccp->clnkThreadStop = CLNK_TASK_SLEEP;
+
+        /* Sleep */
+        HostOS_msleep_interruptible(TT_TASK_SLEEP); 
+
+        if(HostOS_signal_pending(SYS_NULL) != 0)
+            break;
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread initialization.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Init(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret;
+    char name[20] = "kclinkd";
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Init(): Entry dccp 0x%x \n", data);
+
+    if(dccp->clnkThreadID != 0)
+    {   
+        if(dccp->clnkThreadStop == CLNK_TASK_STOPPED || dccp->clnkThreadStop == CLNK_TASK_SLEEP)
+            dccp->clnkThreadStop = CLNK_TASK_RUNNING; //Running
+        return 0;
+    }
+
+    ret = HostOS_thread_start(&dccp->clnkThreadID, (char *)name, (SYS_VDFCVD_PTR)Clnk_Kthread_Mainloop, data);
+    if(ret < 0)
+    {
+        HostOS_PrintLog(L_ERR, "Failed to start kclinkd thread! \n");
+        dccp->clnkThreadID = 0;
+        return -1;
+    }
+    //else
+    //    HostOS_PrintLog(L_INFO, "Start kclinkd thread %d\n", dccp->clnkThreadID);
+
+    dccp->clnkThreadStop = CLNK_TASK_RUNNING;
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Stop Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Stop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int loopCnt = 0;
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Entry \n");
+
+    if(dccp->clnkThreadID != 0)
+    {
+        dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+
+        // Wait thread to stop,
+        while(1)
+        {
+            if(dccp->clnkThreadStop == CLNK_TASK_SLEEP || loopCnt > 10)
+                break;
+
+            //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Delay %d \n", loopCnt);
+            HostOS_msleep_interruptible(1); // 1ms
+            loopCnt++;
+        }
+    }
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Kill Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Kill(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret = 0;
+    
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Kill(): Entry \n");
+
+    ret = HostOS_thread_stop(dccp->clnkThreadID);
+
+    if(ret != 0)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to stop kclnkd thread! (thread ID %d)\n", dccp->clnkThreadID);
+        return -1;
+    }
+
+    dccp->clnkThreadID = 0;
+    dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+    return 0;
+}
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_ttask.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_ttask.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_ttask.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_ttask.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,241 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_ttask.c
+*
+* Description: mailbox timer task support 
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task );
+
+
+
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT timer expiration function.
+*
+*   Imports:    data - timer's opaque data, driver control context
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+//    Clnk_MBX_Mailbox_t *pMbx = &dccp->mailbox; 
+#if 0 
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Pass\n");
+    else
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Fail\n");
+
+#endif
+#if 0
+
+    // detect command message HW Q ready - rx
+  //  HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -rx\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // detect command message HW Q ready - tx
+   //     HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+            clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+        }
+    }
+
+    // detect unsolicited message ready - rx
+    //    HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+     //   HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_umtask_link ) ;
+    }
+#endif
+#if 0
+    // detect command message HW Q ready - rx
+//    HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+    }
+
+    // detect command message HW Q ready - tx
+ //       HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+  //      HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+        }
+    }
+#endif
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+#if 1
+//    HostOS_Lock(pMbx->swUnsolLock);
+    // detect unsolicited message ready - rx
+//        HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+//        HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+    }
+#endif
+ //  HostOS_Unlock(pMbx->swUnsolLock);
+
+    // go again
+    if( !dccp->tt_stopping ) {
+        HostOS_timer_mod( dccp->tt_timer_link, HostOS_timer_expire_ticks(TT_TASK_TIMEOUT) );
+    }
+}
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT command message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+//HostOS_PrintLog(L_INFO, "In clnketh_tt_cmtask() \n" );
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+#if 1
+    // possibly re-schedule
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // possibly re-schedule
+    if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+#endif
+}
+
+/****************************************************************************
+*           
+*   Purpose:    TT unsolicited message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+    Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+
+    // no re-schedule as Handle UnsolInterrupt already sucks up multiple messages 
+}
+
+/****************************************************************************
+*           
+*   Purpose:    Possibly reschedules a TT tasklet.
+*
+*   Imports:    dccp - control context
+*               task - pointer to task structure
+*
+*   Exports:    
+*
+*STATIC**********************************************************************/
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task )
+{
+
+    // possibly re-schedule
+    if( !dccp->tt_stopping )
+    {
+        HostOS_task_schedule( task ) ;
+    }
+
+}
+
+
+
+
+
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_abs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_abs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,116 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+/**
+*  Purpose:    Converts a driver control context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    dccp - pointer to a device control context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dc_to_dg( void *dccp )
+{
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dgcp = ((dc_context_t *)dccp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dc_context_t *)dccp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+
+/**
+*  Purpose: Converts a driver control context pointer to
+*           a driver kernel context pointer.
+*
+*           This is the only way to get back to the dk!           
+*
+*  Imports: dccp - pointer to a device control context
+*
+*  Exports: pointer to the driver kernel context
+*
+*PUBLIC**************************/
+void *dc_to_dk( void *dccp )
+{
+    void *dkcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dkcp = ((dc_context_t *)dccp)->p_dk_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dk\n" );
+        dkcp = 0 ;
+    }
+#else
+    dkcp = ((dc_context_t *)dccp)->p_dk_ctx ;
+#endif
+
+    return( dkcp ) ;
+}
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_setup.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/ctx_setup.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,261 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp );
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base );
+
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the context structures for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our context
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*
+* Outputs:
+*       0 or error code
+*
+*STATIC***************************************************************************/
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+
+    // Allocate the contexts
+
+    dgcp = ctx_alloc_dg_context();
+    if( !dgcp )
+    {
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    dccp = (dc_context_t *)ctx_alloc_dc_context();
+    if( !dccp )
+    {
+        ctx_free_dg_context( dgcp ) ;
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    // linkage init
+    *ddcp_dgcp     = dgcp;   // link dd to dg
+    dccp->p_dg_ctx = dgcp;   // link dc to dg
+    ctx_link_dg_context( dgcp, ddcp, dccp ) ;
+
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*STATIC***************************************************************************/
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base )
+{
+    unsigned int *linkarray[4], **vp ;
+
+    dccp->p_dk_ctx = dkcp ;  // reverse link to the kernel context
+    dccp->baseAddr = dev_base; 
+
+    vp = &linkarray[0] ;
+    ctx_linkage_lister( dkcp, vp, 4 ) ;
+
+    // the order of this list must match that in ctx_linkage_lister
+    dccp->at_lock_link                  = (void *)*vp++ ;
+    dccp->ioctl_sem_link                = (void *)*vp++ ;
+    dccp->mbx_cmd_lock_link             = (void *)*vp++ ;
+    dccp->mbx_swun_lock_link            = (void *)*vp++ ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the clink for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our contexts
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*       Point the control context at the gpl context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*       dkcp        - Pointer to the kernel context.
+*                     This will be saved in the control context.        
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+    int err ;
+
+    // Allocate the contexts
+
+    err = Clnk_alloc_contexts( ddcp_dgcp, ddcp );
+    if( !err )
+    {
+        dgcp = dd_to_dg( ddcp ) ;
+        dccp = dg_to_dc( dgcp ) ;
+
+        // Initialize OS context: BZ 5072 fix
+
+        Clnk_init_os_context( dgcp ) ; 
+
+        // Initialize control context
+
+        Clnk_init_control_context( dccp, dkcp, dev_base ) ;
+    }
+
+    return(err);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       De-Initializes the Mailbox Module for a device.
+*       Called from the remove function for each device.
+*
+*       The thinking here, based on assumptions about what the
+*       kernel does during remove, is to assume that ioctls
+*       are stopped already and that there is no need to lock
+*       them out.
+*
+*       Stops the Timer Task.
+*       Offs the mailboxes.
+*       De-Allocates everything.
+*    
+* Inputs:
+*       vdgcp - Pointer into the gpl context 
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+void Clnk_exit_dev( void *vdgcp )
+{
+    dc_context_t *dccp ;
+
+    if( vdgcp ) {
+        dccp = dg_to_dc( vdgcp ) ;
+
+        // Free any wqts
+        Clnk_MBX_Free_wqts( &dccp->mailbox ) ;
+
+        ctx_free_dc_context( dccp ) ; 
+        ctx_free_dg_context( vdgcp ) ;
+    }
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DC
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dc_context( void )
+{
+    dc_context_t *dccp ;
+
+    dccp = (dc_context_t *)HostOS_Alloc(sizeof(dc_context_t));
+    if( dccp )
+    {
+        HostOS_Memset(dccp, 0, sizeof(dc_context_t));
+    }
+
+    return(dccp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DC
+*    
+* Inputs:   dccp - the DC context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dc_context( void *dccp )
+{
+
+    HostOS_Free( dccp, sizeof(dc_context_t) ) ;
+}
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/util_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/util_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/util_dvr.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Src/util_dvr.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,239 @@
+/*******************************************************************************
+*
+* Common/Src/util_dvr.c
+*
+* Description: Ethernet Driver Utility Functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT)
+static volatile SYS_UINT32 *setup_atrans( dc_context_t *dccp, SYS_UINT32 addr);
+#endif
+
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Messes with the addresses
+*
+*   Imports:    dccp - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*STATIC*******************************************************************************/
+static volatile SYS_UINT32 *setup_atrans(dc_context_t *dccp, SYS_UINT32 addr)
+{
+    SYS_UINTPTR base = dccp->baseAddr;
+    volatile SYS_UINT32 *dst;
+    SYS_UINT32 addr_hi = (addr & 0x0fff0000);
+    SYS_UINT32 addr_lo = (addr & 0x0000ffff);
+
+#if ECFG_CHIP_ZIP1
+    if(((addr & 0xffff0000) == 0x30000) || (addr_hi == 0x100000))
+    {
+        /* this is in the CSR block (Sonics 0x0010xxxx), so use SLV2MAR */
+        dst = (volatile SYS_UINT32 *)(base + (addr_lo | 0x30000));
+    } else {
+        /*
+         * not in the CSR block - configure and use SLV1MAR
+         * note: bits 16 and 17 should never be set at the same time
+         * it is unclear whether bit 17 will ever be set by the host driver
+         */
+        //SETUP_ATRANS(ctx, &addr);
+        dst = (volatile SYS_UINT32 *)(base + CLNK_REG_SLAVE_1_MAP_ADDR);
+        HostOS_Write_Word((addr & 0x0ffc0000) | CLNK_REG_ADDR_TRANS_ENABLE_BIT,
+                          (SYS_UINT32 *)dst);
+        dst = (volatile SYS_UINT32 *)(base + (addr & 0x3ffff));
+    }
+#else  /* ECFG_CHIP_ZIP2/ECFG_CHIP_MAVERICKS */
+    if ((addr >= EHI_START) && (addr <= EHI_END))
+    {
+        dst = (volatile SYS_UINT32 *)(base + 0x00000 + addr_lo);
+    } else if (addr_hi == AT1_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x10000 + addr_lo);
+    } else if (addr_hi == AT2_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x20000 + addr_lo);
+    } else {
+        if (addr_hi != dccp->at3_base)
+        {
+            dst = (volatile SYS_UINT32 *)(base + 0x00074);
+
+            clnk_bus_write( dccp, (SYS_UINTPTR)dst, addr_hi);
+
+            dccp->at3_base = addr_hi;
+        }
+        dst = (volatile SYS_UINT32 *)(base + 0x30000 + addr_lo);
+    }
+#endif /* ECFG_CHIP_ZIP1 */
+
+    return(dst);
+}
+#endif
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+#endif
+    HostOS_Lock(dccp->at_lock_link);
+//HostOS_PrintLog(L_INFO, "In clnk_reg_read: address=%x \n",addr);
+#if defined(PCI_DRVR_SUPPORT)
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+//HostOS_PrintLog(L_INFO, "Done clnk_reg_read: val=%x \n",*val);
+
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*   Purpose:    Writes a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+#endif
+
+    HostOS_Lock(dccp->at_lock_link);
+#if defined(PCI_DRVR_SUPPORT)
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT)  || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*
+*   Purpose:    Writes a clink bus register/location
+*                 WITHOUT LOCKING
+*               This is in support of a block write operation
+*               and the lock is outside the write loop.
+*
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+
+}
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*                 WITHOUT LOCKING
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,66 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_gpl_hdr_h__
+#define __apollo_gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkMbx_dvr.h"
+
+#include "data_context.h"
+#include "gpl_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+
+#define dc_context_t void // Temporary
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+#include "HostOS_proto.h"
+
+
+#endif // __apollo_gpl_hdr_h__
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_gpl_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,75 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_proto.h
+*
+* Description: Linux Ethernet Driver types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/* Do Not Edit! The following contents produced by script.  Thu Jan 22 16:27:49 HKT 2009  */
+
+
+/*** public prototypes from GPL/Apollo/en2512.c ***/
+int memory_init(void);
+void memory_exit(void);
+int memory_open(struct inode *inode, struct file *filp);
+int memory_release(struct inode *inode, struct file *filp);
+ssize_t memory_read(struct file *filp, char *buf, 
+                    size_t count, loff_t *f_pos);
+ssize_t memory_write(   struct file *filp, 
+                        const char *buf, 
+                        size_t count, 
+                        loff_t *f_pos);
+int ioctl_operation(struct inode  *fs_inode, 
+                    struct file   *filp, 
+                    unsigned int  cmd, 
+                    unsigned long argument);
+int ioctl_operation_work(   struct inode *fs_inode, 
+                            struct file *filp, 
+                            unsigned int cmd, 
+                            unsigned long argument);
+unsigned long int rand(int init);
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+void setup_gpio_signals(void);
+
+/*** public prototypes from GPL/Apollo/apollo_mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_mdio.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_mdio.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_mdio.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_mdio.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,106 @@
+/*******************************************************************************
+*
+* GPL/Apollo/mdio.c
+*
+* Description: High level MDIO access
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "apollo_gpl_hdr.h"
+
+
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_close(void);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data)
+{
+    ClinkWriteTo( addr, data );
+
+    return(SYS_SUCCESS);
+}
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data)
+{
+    SYS_UINT32      ret;
+    
+    ret = ClinkReadFrom( addr );
+    *data = ret;
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc )
+{
+    unsigned int    i;
+   
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        Turbo_write(*data);
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc)
+{
+    unsigned int    i;
+
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        *data = Turbo_read();
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/data_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/data_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/data_context_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/data_context_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,37 @@
+/*******************************************************************************
+*
+* GPL/CandD/data_context_candd.h
+*
+* Description: Apollo Driver data definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __data_context_apollo_h__
+#define __data_context_apollo_h__
+
+#include "gmac_drv.h"
+
+#endif /* __data_context_apollo_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/en2510.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/en2510.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/en2510.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo/en2510.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,463 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          en2510.c %
+ * %pid_version:       1.2      %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:      Linux driver source file for MoCA 2510
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/* Necessary includes for device drivers */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/slab.h> /* kmalloc() */
+#include <linux/fs.h> /* everything... */
+#include <linux/errno.h> /* error codes */
+#include <linux/types.h> /* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h> /* O_ACCMODE */
+#include <asm/system.h> /* cli(), *_flags */
+#include <asm/uaccess.h> /* copy_from/to_user */
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/sockios.h>
+
+#include <tmNxTypes.h>
+#include "apollo_gpl_hdr.h"
+#include "tmbslPhyEN2510.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/mii.h"
+#include "mach/gmac_eth_drv.h"
+#include "data_context_apollo.h"
+
+// definitions
+
+
+#define VERSION "Apollo Version 1.22"
+
+#define K_BUF_SIZE  512
+
+#define G_IO_START  0xc8004000
+
+
+
+#define reverse_endian(b)       ((b) >= 8 ? (b)+8 : (b)+24)
+#define reverse_endian_bit(b)   (1 << reverse_endian(b))
+
+//------------------------------------------------------------------------------
+// Define Ports used
+//------------------------------------------------------------------------------
+#define MDIO_PORT           0
+#define MDIO_CONFIG_PORT    4
+#define MDIO_INPUT_PORT     8
+
+//------------------------------------------------------------------------------
+// Define Bits in the GPIO ports
+//------------------------------------------------------------------------------
+#define MDIO_CLOCK_BIT  reverse_endian_bit(4)
+#define MDIO_DATA_BIT   reverse_endian_bit(5)
+
+#define SMI_CLOCK_BIT   reverse_endian_bit(6)
+#define SMI_DATA_BIT    reverse_endian_bit(7)
+
+#define YELLOW          reverse_endian_bit(0)
+#define GREEN           reverse_endian_bit(1)
+#define IXP_MII_DIS     reverse_endian_bit(2)
+#define SoC_RESET       reverse_endian_bit(3)
+#define SWITCH_RESET    reverse_endian_bit(8)
+#define SWITCH_INTR     reverse_endian_bit(9)
+#define BUTTON          reverse_endian_bit(10)
+#define SOC_XMII_DIS    reverse_endian_bit(11)
+#define DIPLEXER        reverse_endian_bit(12)
+#define CPU_RESET       reverse_endian_bit(13)
+
+
+#define __PHY_ADDRESS           0x01
+
+
+#define MDIO_START_BITS         (0x01 << (30-16))
+#define MDIO_OP_READ            (0x02 << (28-16))
+#define MDIO_OP_WRITE           (0x01 << (28-16))
+#define MDIO_READ_TURN_AROUND   (0x03 << (16-16))
+#define MDIO_WRITE_TURN_AROUND  (0x02 << (16-16))
+
+#define MDIO_READ_MASK          (MDIO_START_BITS | MDIO_OP_READ  | PHY_ADDRESS << (23-16))
+#define MDIO_WRITE_MASK         (MDIO_START_BITS | MDIO_OP_WRITE | PHY_ADDRESS << (23-16))  
+#define MDIO_REG_PLACEMENT      (18-16)
+
+#define ADDRESS_MODE            0x1b
+#define ADDRESS_HIGH            0x1c
+#define ADDRESS_LOW             0x1d
+#define DATA_HIGH               0x1e
+#define DATA_LOW                0x1f
+
+#define _BV(n)                  (1 << (n))
+
+#define CLINK_START_WRITE       _BV(0)
+#define CLINK_START_READ        _BV(1)
+#define CLINK_AUTO_INC          _BV(2)
+#define CLINK_BUSY              _BV(3)
+#define CLINK_ERROR             _BV(4)
+
+#define PHY_READ    (MDIO_START_BITS | MDIO_OP_READ  | MDIO_READ_TURN_AROUND)
+#define PHY_WRITE   (MDIO_START_BITS | MDIO_OP_WRITE | MDIO_WRITE_TURN_AROUND)
+
+//
+// structures and definitions
+//
+
+/* This structure is used in all SIOCxMIIxxx ioctl calls */
+struct mmi_ioctl_data {
+        uint16_t                phy_id;
+        uint16_t                reg_num;
+        uint16_t                val_in;
+        uint16_t                val_out;
+};
+
+struct ioctl_stuff
+{
+    char                        name[16];
+    union ioctl_data 
+    {
+        unsigned int            *ptr;
+        struct mmi_ioctl_data   mmi;
+        unsigned char           MAC[8];
+    } dat;
+};
+
+/* Global variables of the driver */
+
+//------------------------------------------------------------------------------
+// This is the location of the gpio registers 
+//------------------------------------------------------------------------------
+
+// prototypes
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned int );
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+extern tmErrorCode_t tmbslPhyEN2510Read (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN2510Reg_t	reg,
+	pUInt16			pVal
+	);
+
+
+extern tmErrorCode_t tmbslPhyEN2510Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2510Reg_t		reg,
+    UInt16			val
+	);
+static int en2510_unitnum, en2510_phy_addr;
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned cmd )
+{
+    struct mii_ioctl_data *data = if_mii(ifr);
+    int flag,status = 0;
+    void *arg = NULL;
+    dk_context_t *dkcp;
+    arg = ifr->ifr_data;
+
+    dkcp = (dk_context_t *)data_kernel_context ;
+
+    switch (cmd)
+    {
+        case SIOCGMIIPHY:       // Get PHY address
+            data->phy_id = en2510_phy_addr;   //pPlatData->phy_addr_val;
+            break;
+        case SIOCHDRCMD:        // Resets the SoC , Control the diplexer switch etc
+            flag = ifr->ifr_ifru.ifru_ivalue;
+            if(flag)
+            {
+                writel(0x00008000, 0xe06d503c); //We are writing to GPIO directly too bad
+                printk(KERN_INFO "MoCA en2510 SoC in-reset\n");
+            }
+            else
+            {
+                writel(0x80008000, 0xe06d503c); //We are writing to GPIO directly too too bad
+                printk(KERN_INFO "MoCA en2510 SoC out of reset\n");
+            }
+            break;
+        case SIOCGMIIREG:       // PHY read request
+            data->val_out = ClinkReadMDIOData(data->reg_num);
+            break;
+        case SIOCSMIIREG:       // PHY write request
+            ClinkWriteMDIOData(data->reg_num,data->val_in);
+            break;
+        case SIOCCLINKDRV :     // Control plane commands for the driver
+            status = clnkioc_driver_cmd( dkcp, arg ) ;
+            break ; 
+        case SIOCGCLINKMEM :    // Reads registers/memory in c.LINK address space
+            status = clnkioc_mem_read( dkcp, arg ) ;
+            break ; 
+        case SIOCSCLINKMEM :    // Sets registers/memory in c.LINK address space
+            status = clnkioc_mem_write( dkcp, arg ) ;
+            break ; 
+        case SIOCGCLNKCMD :     // mbox cmmds: request with response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 1 ) ;
+            break ;
+        case SIOCSCLNKCMD :     // mbox cmmds: request with no response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 0 ) ;
+            break ;
+        case SIOCLNKDRV :       // mbox cmmds: retrieve unsol messages
+            status = clnkioc_mbox_unsolq_retrieve( dkcp, arg ) ;
+            break ;         
+
+        default:
+            printk(KERN_ALERT "DIAG: IOCTL operation %x \n",cmd);
+            break ;
+    }
+    return(status);
+}
+
+/******************************************************
+
+        End of MODULE functions
+
+        Start of Utility functions
+
+*******************************************************/
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr)
+{
+    en2510_unitnum = unitNum;
+    en2510_phy_addr = phy_addr;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int ClinkReadMDIOData(int reg_addr)
+{
+    unsigned short data;
+    
+    tmbslPhyEN2510Read(en2510_unitnum, reg_addr, &data);
+
+    return(data);
+
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteMDIOData(int reg_addr,unsigned val)
+{    
+    tmbslPhyEN2510Write(en2510_unitnum, reg_addr, val);
+}
+
+
+/*
+*           wait for SoC bus to say idle
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWaitMDIOReady(void)
+{
+    unsigned int rc;
+    for (;;) {          // If there is problem in SoC, Watchdog interrupt will reset me !!!
+        rc=ClinkReadMDIOData(ADDRESS_MODE);
+        if ((rc & 0xff) == 0)
+            return;
+        if (rc & CLINK_BUSY)
+        {
+            continue;
+        }
+        if (rc & CLINK_ERROR)
+        {
+            continue;
+        }
+        return;
+    }
+}
+
+
+/*
+*            read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned long ClinkReadFrom(unsigned long addr)
+{
+    unsigned long data;
+
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ);
+    ClinkWaitMDIOReady();
+    data=ClinkReadMDIOData(DATA_HIGH);
+    data = data << 16;
+    data |= (ClinkReadMDIOData(DATA_LOW) & 0xffff);
+    return data;
+}
+
+
+/*
+*          read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteTo(unsigned long addr, unsigned long data)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_open(unsigned long addr)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_write(unsigned long data)
+{
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE | CLINK_AUTO_INC);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int Turbo_read(void)
+{
+    unsigned int data = 0;
+    unsigned int retVal = 0;
+
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ | CLINK_AUTO_INC);
+
+    data = ClinkReadMDIOData(DATA_HIGH);
+    retVal = data << 16;
+    data = ClinkReadMDIOData(DATA_LOW);
+    retVal |= data & 0xFFFF;
+    
+    return retVal;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_close(void)
+{
+    ClinkWriteMDIOData(ADDRESS_MODE, 0);
+}
+
+/*****************************************************
+
+        End of utility functions
+
+******************************************************/
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/data_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/data_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/data_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/data_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,47 @@
+/*******************************************************************************
+*
+* GPL/Common/data_context.h
+*
+* Description: data context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __data_context_h__
+#define __data_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "data_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "data_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "data_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "data_context_apollo.h"
+#endif
+#endif // __data_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_context.h
+*
+* Description: PCI Driver GPL Context
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_context_h__
+#define __gpl_context_h__
+
+
+/*
+    This structure/variable is instantiated at probe time by allocation.
+    It is pointed to from the driver data context p_dg_ctx member. 
+*/
+
+struct _driver_gpl_context_ {
+    void                *p_dd_ctx ; // pointer to driver data    context
+    void                *p_dc_ctx ; // pointer to driver control context
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       at_lock; 
+#else
+    hostos_lock_t       at_lock;        // address translator spin lock - referenced in !GPL side
+#endif
+
+    hostos_sema_t       ioctl_sem;      // Mutex for ioctl threads, keeps them one at a time 
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       mbx_cmd_lock;   // mailbox cmd mutex semphore - referenced in !GPL side
+    hostos_sema_t       mbx_swun_lock;  // mailbox sw unsol mutex semphore - referenced in !GPL side
+#else
+    hostos_lock_t       mbx_cmd_lock;   // mailbox cmd spin lock - referenced in !GPL side
+    hostos_lock_t       mbx_swun_lock;  // mailbox sw unsol spin lock - referenced in !GPL side
+#endif
+
+};
+
+typedef struct _driver_gpl_context_ dg_context_t ;
+
+#endif  // __gpl_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_abs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_abs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,310 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+
+
+
+/**
+*  Purpose:    Converts a driver kernel context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dkcp - pointer to a device kernel context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dk_to_dd( void *dkcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dkcp ) {
+        ddcp = ((dk_context_t *)dkcp)->priv;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dk_context_t *)dkcp)->priv;
+#endif
+    return( ddcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver data context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    ddcp - pointer to a device data context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dd_to_dg( void *ddcp )
+{
+    dg_context_t *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( ddcp ) {
+        dgcp = ((dd_context_t *)ddcp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dd_context_t *)ddcp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver control context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver control context
+*
+*PUBLIC**************************/
+void *dg_to_dc( void *dgcp )
+{
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        dccp = ((dg_context_t *)dgcp)->p_dc_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dc\n" );
+        dccp = 0 ;
+    }
+#else
+    dccp = ((dg_context_t *)dgcp)->p_dc_ctx ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dg_to_dd( void *dgcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        ddcp = ((dg_context_t *)dgcp)->p_dd_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dg_context_t *)dgcp)->p_dd_ctx ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+////////////////////////////////////////////////////////////
+// === combo functions
+////////////////////////////////////////////////////////////
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dk_to_dc( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+            if( dgcp ) {
+                dccp = dg_to_dc( dgcp ) ;
+            }
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dc\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver data context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dd_to_dc( void *ddcp )
+{
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( ddcp ) {
+        dgcp = dd_to_dg( ddcp ) ;
+        if( dgcp ) {
+            dccp = dg_to_dc( dgcp ) ;
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dc\n" );
+    }
+#else
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver gpl context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver gpl context
+ *
+*PUBLIC**************************/
+void *dk_to_dg( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    dgcp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+        }
+    }
+    if( !dgcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dg\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver control context pointer to
+ *              a driver data context pointer.
+ *
+ *  Imports:    dccp - pointer to a device control context
+ *
+ *  Exports:    pointer to the driver data context
+ *
+*PUBLIC**************************/
+void *dc_to_dd( void *dccp )
+{
+    void *dgcp ;
+    void *ddcp ;
+
+#if CONTEXT_DEBUG
+    ddcp = 0 ;
+    if( dccp ) {
+        dgcp = dc_to_dg( dccp ) ;
+        if( dgcp ) {
+            ddcp = dg_to_dd( dgcp ) ;
+        }
+    }
+    if( !ddcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dd\n" );
+    }
+#else
+    dgcp = dc_to_dg( dccp ) ;
+    ddcp = dg_to_dd( dgcp ) ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_setup.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_setup.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,158 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DG
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dg_context( void )
+{
+    dg_context_t *dgcp ;
+
+    dgcp = (dg_context_t *)HostOS_Alloc(sizeof(dg_context_t));
+    if( dgcp )
+    {
+        HostOS_Memset(dgcp, 0, sizeof(dg_context_t));
+    }
+
+    return(dgcp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DG
+*    
+* Inputs:   dgcp - the DG context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dg_context( void *dgcp )
+{
+
+    HostOS_Free( dgcp, sizeof(dg_context_t) ) ;
+
+}
+
+/*******************************************************************************
+*           
+* Purpose:  links a DG somewhere
+*    
+* Inputs:   vdgcp - void pointer to DG context 
+*           ddcp  - void pointer to DD context
+*           dccp  - void pointer to DC context
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+    dgcp->p_dd_ctx = (void *)ddcp ;  // link dg to dd
+    dgcp->p_dc_ctx = (void *)dccp;   // link dg to dc
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the OS context.
+*
+* Inputs:
+*       vdgcp        - void Pointer to the OS context.
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void Clnk_init_os_context( void *vdgcp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->at_lock);       // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->at_lock);        // referenced from !GPL side
+#endif
+
+    HostOS_mutex_init(  &dgcp->ioctl_sem);
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_mutex_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_lock_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len )
+{
+    dg_context_t *dgcp = dk_to_dg( dkcp ) ;
+
+    *vp++ = (unsigned int *)&dgcp->at_lock;
+    *vp++ = (unsigned int *)&dgcp->ioctl_sem;
+    *vp++ = (unsigned int *)&dgcp->mbx_cmd_lock;
+    *vp++ = (unsigned int *)&dgcp->mbx_swun_lock;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,77 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_hdr_h__
+#define __gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "HostOS_Spec_pci.h"
+#include "eth_dvr.h"
+#endif
+
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "HostOS_Spec_candd.h"
+#endif
+
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "HostOS_Spec_apollo.h"
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) 
+#include "HostOS_Spec_e1000.h"
+#include "e1000.h"
+#endif
+
+#include "data_context.h"
+#include "gpl_context.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "pci_gpl_proto.h"
+#endif
+#include "com_abs_proto.h"
+
+#include "HostOS_proto.h"
+
+
+#endif // __gpl_hdr_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1433 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.c
+*
+* Description: Host OS support for Linux
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+#define LOCK_MAGIC      0x4c4f434b       // spells "LOCK"
+
+#define KMALLOC_MAX     65536
+
+extern unsigned long volatile jiffies;
+
+
+/**
+*   Purpose:    Sets size bytes of memory to a given byte value.
+*
+*   Imports:    pMem - pointer to block of memory to set
+*               val  - value to set each byte to
+*               size - number of bytes to set
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memset(void *pMem, int val, int size)
+{
+    memset(pMem, val, size);
+}
+
+/**
+*   Purpose:    Copies size bytes of memory from pFrom to pTo.
+*               The memory areas may not overlap.
+*
+*   Imports:    pTo   - pointer to destination memory area
+*               pFrom - pointer to source memory area
+*               size  - number of bytes to copy
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memcpy(void *pTo, void *pFrom, int size)
+{
+    memcpy(pTo, pFrom, size);
+}
+
+/**
+*   Purpose:    Scans input buffer and according to format specified.
+*
+*   Imports:    buf   - input buffer
+*               fmt   - input format
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sscanf(const char *buf, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vsscanf(buf, fmt, args);
+    va_end(args);
+}
+
+/**
+*   Purpose:    Allocates DMA-addressable memory.
+*
+*   Imports:    size - size to allocate
+*
+*   Exports:    pointer to allocated block
+*
+*PUBLIC**************************/
+void* HostOS_Alloc(int size)
+{
+    void *pMem;
+
+    if (size < KMALLOC_MAX)
+        pMem = kmalloc(size, GFP_KERNEL /* | __GFP_DMA */);
+    else
+        pMem = (void *)__get_free_pages(GFP_KERNEL, get_order(size));
+    // printk("AllocMem %d %p\n", size, pMem);
+
+    /** Assure that system constants defined in Entropic space have harmonious
+     *  definitions compared with Unix constants.  This is not the most 
+     *  pure place to put this but it does not have any runtime cost since
+     *  the compiler optimizes it away. */
+    INCTYPES_COMPILE_TIME_ASSERT( EIO       == SYS_INPUT_OUTPUT_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMEM    == SYS_OUT_OF_MEMORY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( EACCES    == SYS_PERMISSION_ERROR       );
+    INCTYPES_COMPILE_TIME_ASSERT( EFAULT    == SYS_INVALID_ADDRESS_ERROR  );
+    INCTYPES_COMPILE_TIME_ASSERT( EINVAL    == SYS_INVALID_ARGUMENT_ERROR );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOSPC    == SYS_OUT_OF_SPACE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOTEMPTY == SYS_DIR_NOT_EMPTY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMSG    == SYS_BAD_MSG_TYPE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ETIMEDOUT == SYS_TIMEOUT_ERROR          );
+
+    return (pMem);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    pMem - allocation pointer from get free pages
+*               size - Requested block size
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_Free(void* pMem, int size)
+{
+    if (size < KMALLOC_MAX)
+        kfree(pMem);
+    else
+        free_pages((unsigned long)pMem, get_order(size));
+}
+
+/**
+*   Purpose:    Delays for about timeInUsec microseconds.
+*               The operation of this function is architecture dependent.
+*               It is probably a tight loop.
+*
+*   Imports:    timeInUsec - delay in microseconds
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sleep(int timeInUsec)
+{
+    if( timeInUsec < 1000 ) {
+        udelay(timeInUsec);
+    } else {
+        //HostOS_PrintLog(L_NOTICE, "mdelay delay=%d. jif=%d.\n", timeInUsec/1000, jiffies );
+        mdelay(timeInUsec/1000);
+        //HostOS_PrintLog(L_NOTICE, "mdelay jif=%d.\n", jiffies );
+    }
+}
+
+/**
+*   Purpose:    Inits a spinlock.
+*               Sets the magic code for later testing.
+*
+*   Imports:    vlk - pointer to an Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_lock_init( void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    if( !lk ) {
+        HostOS_PrintLog(L_ERR, "Error: invalid lock pointer\n");
+    } else {
+        spin_lock_init( &lk->lock_spinlock );
+        lk->lock_magic     = LOCK_MAGIC;
+    }
+}
+
+/**
+*   Purpose:    Waits for the lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Lock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*                     or pointer to the mutex structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM    
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_lock(&lk->lock_spinlock);
+    } else {
+        spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    down((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Saves current interrupt context and waits for the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock_Irqsave(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Trys to get the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    0 - the lock was NOT acquired. Please try again.
+*               1 - the lock is yours. Please ulock it later.
+*
+*PUBLIC**************************/
+int HostOS_Lock_Try(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+    int locked ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    locked = spin_trylock(&lk->lock_spinlock) ;
+
+    return( locked );
+}
+
+/**
+*   Purpose:    Unlocks a lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Unlock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM 
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_unlock(&lk->lock_spinlock);
+    } else {
+        spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    up((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Unlocks a lock and restores interrupt context.
+*               The lock must be initialized.
+*
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock_Irqrestore(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+   spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Terminates a lock.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_TermLock(void *vlk)
+{
+}
+
+
+// Host Print ForMaT string
+#define HPFMT "%s: %s"
+
+/**
+*   Purpose:    Variable argument OS print.
+*
+*   Imports:    lev - severity level. See the L_* enum.
+*                     See HOST_OS_PRINTLOG_THRESHOLD
+*               fmt - printf format string
+*               ... - printf format arguments
+*
+*   Exports:    none
+*
+*  For reference:  Linux has these
+*
+*  #define KERN_EMERG      "<0>"   / * system is unusable                   * /
+*  #define KERN_ALERT      "<1>"   / * action must be taken immediately     * /
+*  #define KERN_CRIT       "<2>"   / * critical conditions                  * /
+*  #define KERN_ERR        "<3>"   / * error conditions                     * /
+*  #define KERN_WARNING    "<4>"   / * warning conditions                   * /
+*  #define KERN_NOTICE     "<5>"   / * normal but significant condition     * /
+*  #define KERN_INFO       "<6>"   / * informational                        * /
+*  #define KERN_DEBUG      "<7>"   / * debug-level messages                 * /
+*
+*PUBLIC**************************/
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...)
+{
+    va_list args;
+    int  printed_len;
+    static char printk_buf[1024]; /* BZ 4739 Fix - Making it static as this is
+                                   * too much data to allocate on the stack. */
+
+    if (lev <= HOST_OS_PRINTLOG_THRESHOLD)
+    {   
+        /* Emit the output into the temporary buffer */
+        va_start(args, fmt);
+        printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
+        va_end(args);
+
+        switch ( lev )
+        {
+            case L_EMERG   :
+                printk(KERN_EMERG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ALERT   :
+                printk(KERN_ALERT   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_CRIT    :
+                printk(KERN_CRIT    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ERR     :
+                printk(KERN_ERR     HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_WARNING :
+                printk(KERN_WARNING HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_NOTICE  :
+                printk(KERN_NOTICE  HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_INFO    :
+                printk(KERN_INFO    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_DEBUG   :
+                printk(KERN_DEBUG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+        }
+    }
+}
+
+/**
+*   Purpose:    register/memory read access from kernel space.
+*
+*   Imports:    addr - address to read from
+*
+*   Exports:    32 bit value from given address
+*
+*PUBLIC**************************/
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr )
+{
+    SYS_UINT32 rv ;
+
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    rv = *(volatile SYS_UINT32 *)addr ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    rv = readl( (const volatile void *)addr );
+#else
+    rv = readl( addr ) ;
+#endif
+#endif
+    return( rv ) ;
+}
+
+/**
+*   Purpose:    register/memory write access from kernel space.
+*
+*   Imports:    val  - 32 bit value to write
+*               addr - address to write to
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr )
+{
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    *(volatile SYS_UINT32 *)addr = val ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    writel( val, (volatile void *)addr );
+#else
+    writel( val, addr );
+#endif
+#endif
+}
+
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vtmr - pointer to the timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_init( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    init_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*               And ensure the timer is not running on any CPU
+*               Can sleep
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del_sync( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer_sync( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( mod_timer( &tmr->ostimer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer.
+*               Call this after HostOS_timer_setup
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_timer_add( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    add_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.function = func ;
+    tmr->ostimer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In seconds.
+*
+*   Imports:    future - number of seconds into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future )
+{
+
+    return( jiffies + (future * HZ) ) ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In jiffies.
+*
+*   Imports:    future - number of ticks into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future )
+{
+
+    return( jiffies + future ) ;
+}
+
+
+/**************************************************************
+
+    wait queue timer - support
+
+    This structure contains everything necessary to
+    use timers and wait queues from the !GPL side.
+
+    You allocate one of these wqt_t things and then
+    pass its pointer back on the various calls.
+
+***************************************************************/
+
+typedef struct hostos_w_q_t
+{
+    int                 wqt_allocated ; // 0 = no, 1 = yes
+    struct timer_list   wqt_timer;
+    wait_queue_head_t   wqt_wq;
+}
+wqt_t ;
+
+
+/**
+*   Purpose:    Allocates a wqt entry from the heap.
+*
+*   Imports:
+*
+*   Exports:    !0 = void pointer to opaque data (really a wqt_t)
+*               0 = allocation failure
+*
+*PUBLIC**************************/
+void *HostOS_wqt_alloc( void )
+{
+    wqt_t       *wqt ;
+
+    wqt = kmalloc( sizeof( wqt_t ), GFP_KERNEL ) ;
+
+    return( (void *)wqt ) ;
+}
+
+/**
+*   Purpose:    De-allocates a wqt entry from the heap.
+*
+*   Imports:    vwqt - pointer to the wqt_t to be freed
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_free( void *vwqt )
+{
+
+    kfree( vwqt ) ;
+}
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_allocated = 1 ;  // mark the timer inited
+    init_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a wqt timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_del( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt->wqt_allocated ) {
+        del_timer( &wqt->wqt_timer ) ;
+    }
+}
+
+/**
+*   Purpose:    Deactivate a registered timer
+*               And ensure the timer is not running on any CPU.
+*               Can sleep.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_del_sync( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( del_timer_sync( &wqt->wqt_timer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to modify
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                        or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( mod_timer( &wqt->wqt_timer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer
+*               Call this after HostOS_timer_setup.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to add
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_add( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    add_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to  init
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.function = func ;
+    wqt->wqt_timer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to set
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Inits a wait queue head in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to init
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    init_waitqueue_head( &wqt->wqt_wq );
+}
+
+/**
+*   Purpose:    Wakes up a wait q in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wake
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt )
+    {
+        wake_up_interruptible( &wqt->wqt_wq );
+    }
+}
+
+/**
+*   Purpose:    Waits for a wait q event in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wait on
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wait_event_interruptible( wqt->wqt_wq, /* pass by value */
+                              func(vp) );
+
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_word(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*              These functions read or write the PCI bus device.
+*
+*              Linux uses nested macros to define these.
+*              See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with pci_dev pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_dword(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_word(pdev, reg, val);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_dword(pdev, reg, val);
+}
+
+/**
+*   Purpose:    Allocate DMA-addressable memory.
+*
+*   Imports:    ddev    - pci_dev pointer
+*               size    - Requested block size
+*               ppMemPa - Pointer to place to return the Physical memory address
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+    dma_addr_t     dma_buf;
+    void           *pMemVa;
+
+    pMemVa   = pci_alloc_consistent(pdev, size, &dma_buf);
+    *ppMemPa = (void *)dma_buf;
+
+    // printk("AllocDmaMem %d %x %x\n", size, pMemVa, dma_buf);
+
+    return (pMemVa);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    ddev   - pci_dev pointer
+*               size   - Requested block size
+*               pMemVa - Virtual memory address returned by HostOS_AllocDmaMem()
+*               pMemPa - Physical memory address returned by    ditto
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_free_consistent(pdev, (size_t) size, pMemVa, (dma_addr_t)pMemPa);
+}
+#endif
+
+/**
+*   Purpose:    Initialize a tasklet.
+*
+*               Prototype:
+*               void tasklet_init(struct tasklet_struct *t,
+*                                 void (*func)(unsigned long),
+*                                 unsigned long data)
+*
+*   Imports:    vtl  - pointer to the tasklet structure
+*               func - tasklet function
+*               data - tasklet context data
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_init( void *vtl, void *func, unsigned long data )
+{
+
+    tasklet_init((struct tasklet_struct *)vtl, func, data ) ; // abstraction
+}
+
+/**
+*   Purpose:    Schedule a tasklet.
+*               Tasklet must already be initialized.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_schedule( void *vtl )
+{
+
+    tasklet_schedule( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Enable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_enable( void *vtl )
+{
+
+    tasklet_enable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Disable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_disable( void *vtl )
+{
+
+    tasklet_disable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Kill a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_kill( void *vtl )
+{
+
+    tasklet_kill( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Initialize a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_init( void *vmt )
+{
+
+    init_MUTEX( (struct semaphore *)vmt ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Release (up) a mutex.
+*
+*               Do NOT call this from an ISR!
+*
+*               Do NOT call this if you are not the current
+*               holder of the mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_release( void *vmt )
+{
+
+    up( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex.
+*
+*               Might sleep.
+*               When this returns you have the mutex.
+*
+*               This is NOT the preferred method. See
+*               HostOS_mutex_acquire_intr().
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_acquire( void *vmt )
+{
+
+    down( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex. Interruptible
+*
+*               Might sleep.
+*               When this returns 0 you have the mutex.
+*               When this returns -EINTR you have been interrupted
+*               and must bail out. You do NOT have the mutex. The
+*               purpose here is to allow the caller, probably a
+*               user space app, to be interrupted and die quickly
+*               and quietly; rather than becoming a zombie because
+*               the driver won't let go.
+*
+*               This is the preferred method.
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:    0      - you got the mutex
+*               -EINTR - you've been interrupted, no mutex
+*
+*PUBLIC**************************/
+int HostOS_mutex_acquire_intr( void *vmt )
+{
+    int rc ;
+
+    rc = down_interruptible( (struct semaphore *)vmt ) ; // abstraction
+    return( rc ) ;
+}
+
+/**
+*   Purpose:    Copies a block from user space to kernel space.
+*
+*   Imports:    to     - pointer to a kernel space buffer to receive the data
+*               from   - pointer to a user space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_from_user( to, from, nbytes );
+    return( n ) ;
+}
+
+/**
+*   Purpose:    Copies a block from kernel space to user space.
+*
+*   Imports:    to     - pointer to a user space buffer to receive the data
+*               from   - pointer to a kernel space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_to_user( to, from, nbytes );
+    return( n ) ;
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Check if the carrier is ok.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:    1 if carrier is ok, 0 if not
+*
+*PUBLIC**************************/
+unsigned long HostOS_netif_carrier_ok( void *kdev )
+{
+
+    return( netif_carrier_ok((struct net_device *)kdev) ) ;
+}
+
+/**
+*   Purpose:    Sets net carrier on.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_on( void *kdev )
+{
+
+    netif_carrier_on((struct net_device *)kdev);
+    netif_wake_queue((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets net carrier off.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_off( void *kdev )
+{
+
+    netif_carrier_off((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets the MAC address in the OS.
+*
+*   Imports:    mac_hi - Bytes 0-3 of MAC address
+*               mac_lo - Bytes 4-5 of MAC address
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    dev->dev_addr[0] = (SYS_UCHAR) ((mac_hi >> 24) & 0xff);
+    dev->dev_addr[1] = (SYS_UCHAR) ((mac_hi >> 16) & 0xff);
+    dev->dev_addr[2] = (SYS_UCHAR) ((mac_hi >>  8) & 0xff);
+    dev->dev_addr[3] = (SYS_UCHAR) ((mac_hi      ) & 0xff);
+    dev->dev_addr[4] = (SYS_UCHAR) ((mac_lo >> 24) & 0xff);
+    dev->dev_addr[5] = (SYS_UCHAR) ((mac_lo >> 16) & 0xff);
+}
+
+/**
+*   Purpose:    Brings up the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_open( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_open(dev);
+    }
+}
+
+/**
+*   Purpose:    Shuts down the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_close( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_close(dev);
+    }
+}
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+
+/* declaring mutexes for kernel thread start/stop */
+DECLARE_MUTEX (HostOS_thread_mutex);
+
+hostos_kthread_t hostosThread;
+
+/**
+*   Purpose:    Check pending signal of task.
+*
+*   Imports:    vtask - pointer to the task
+*
+*   Exports:    0 - no pending signal
+*               1 - has pendign signal
+*
+*PUBLIC**************************/
+int HostOS_signal_pending(void *vtask)
+{
+    struct task_struct *p;
+    
+    if(vtask== SYS_NULL)
+        p = current;
+    else
+        p = (struct task_struct *)vtask;
+
+    return signal_pending(p);
+}
+
+/**
+*   Purpose:    Convert  jiffies to milliseconds.
+*
+*   Imports:    j- jiffies
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned int HostOS_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+    return (1000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+    return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+    return (j * 1000) / HZ;
+#endif
+}
+
+/**
+*   Purpose:    Convert milliseconds to jiffies.
+*
+*   Imports:    m - milliseconds
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned long HostOS_msecs_to_jiffies(const unsigned int m)
+{
+    if (m > HostOS_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+        return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+    return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+    return m * (HZ / 1000);
+#else
+    return (m * HZ + 999) / 1000;
+#endif
+}
+
+/**
+*   Purpose:    Sleep waiting for waitqueue interruptions.
+*
+*   Imports:    msecs - Time in milliseconds to sleep for
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_msleep_interruptible(unsigned int msecs)
+{
+    unsigned long timeout = HostOS_msecs_to_jiffies(msecs) + 1;
+
+    while (timeout && !signal_pending(current)) {
+        __set_current_state(TASK_INTERRUPTIBLE);
+        timeout = schedule_timeout(timeout);
+    }
+}
+
+/**
+*   Purpose:    Kernel thread internal function.
+*
+*   Imports:    pdata - pointer to thread struct
+*
+*   Exports:    none
+*
+***************************/
+static void HostOS_thread_inter_func(void *pdata)
+{
+    hostos_kthread_t *pThread = (hostos_kthread_t *)pdata;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    daemonize(hostosThread.name, 0);
+    allow_signal(SIGKILL);
+    allow_signal(SIGTERM);    
+#else
+    daemonize();
+#endif
+
+    /* kernel thread main function */
+    pThread->func(pThread->arg);
+
+    return ;
+}
+
+/**
+*   Purpose:    Create new kernel thread.
+*
+*   Imports:    pThreadID - pointer to new kernel threadID
+*               pName     - pointer to thread name string
+*               func      - pointer to thread internal function
+*               arg       - argument to pass to thread function
+*
+*   Exports:    0  - OK
+*               -1 - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_start(unsigned int *pThreadID, char *pName, void (*func)(void *), void *arg)
+{
+    down(&HostOS_thread_mutex);
+
+    strncpy(hostosThread.name, pName,16);
+    hostosThread.func = func;
+    hostosThread.arg = arg;
+
+    /* Create kernel thread */
+    hostosThread.threadID = kernel_thread((int (*)(void *))HostOS_thread_inter_func, &hostosThread, 0);
+    *pThreadID = hostosThread.threadID;
+
+    if(hostosThread.threadID < 0)
+    {
+        up (&HostOS_thread_mutex);
+        return -1;
+    }
+    
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+/**
+*   Purpose:    Stop a kernel thread.
+*
+*   Imports:    threadID - kernel threadID that to be stopped
+*
+*   Exports:    0   - OK
+*               -1  - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_stop(unsigned long threadID)
+{
+    int ret = 0;
+
+    down(&HostOS_thread_mutex);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)    
+    if((ret = kill_pid(find_vpid(threadID), SIGKILL, 1)))
+#else
+    if((ret = kill_proc(threadID, SIGKILL, 1)))
+#endif
+    {
+        up(&HostOS_thread_mutex);
+        return -1;
+    }
+
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,123 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.h
+*
+* Description: OS includes and abstracted types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _hostos_linux_h_
+#define _hostos_linux_h_
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+
+/**
+ *  spinlock structure with added bells and whistles
+ */
+
+// for locking purposes
+typedef struct hostos_lock
+{
+    int             lock_magic;        // used to verify the structure is initialized
+    unsigned long   lock_irq_flags;    // irq flags for restoring later
+    spinlock_t      lock_spinlock;
+}
+hostos_lock_t ;
+
+// timer operations
+// for linux this contains a struct timer_list
+typedef struct hostos_timer
+{
+    struct timer_list ostimer ;
+}
+hostos_timer_t ;
+
+// tasklet operations
+// for linux this contains a struct tasklet_struct
+typedef struct hostos_task
+{
+    struct tasklet_struct ostask ;
+}
+hostos_task_t ;
+
+// semaphore operations
+// for linux this contains a struct semaphore
+typedef struct hostos_sema
+{
+    struct semaphore ossema ;
+}
+hostos_sema_t ;
+
+typedef struct _hostos_waitq
+{
+    wait_queue_head_t   wq;
+}
+hostos_waitq_t ;
+
+// thread operations 
+// for linux this contains kernel thread related information
+typedef struct hostos_kthread
+{
+    char name[20];          /* thread name */
+    int  threadID;    
+    void (*func) (void *);  /* thread internal function */    
+    void *arg;              /* argument to pass to kernel thread */
+} 
+hostos_kthread_t;
+
+#endif /* _hostos_linux_h_ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/COPYING linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/COPYING
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/COPYING	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/COPYING	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,173 @@
+The GNU General Public License (GPL)
+Version 2, June 1991
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+
+Preamble
+
+The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.
+
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.
+
+We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.
+
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and modification follow.
+
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.
+
+1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
+
+
+   a) You must cause the modified files to carry prominent notices
+      stating that you changed the files and the date of any change.
+
+
+   b) You must cause any work that you distribute or publish, that in
+      whole or in part contains or is derived from the Program or any part
+      thereof, to be licensed as a whole at no charge to all third parties
+      under the terms of this License.
+
+
+   c) If the modified program normally reads commands interactively when
+      run, you must cause it, when started running for such interactive use
+      in the most ordinary way, to print or display an announcement including
+      an appropriate copyright notice and a notice that there is no warranty
+      (or else, saying that you provide a warranty) and that users may
+      redistribute the program under these conditions, and telling the user
+      how to view a copy of this License. (Exception: if the Program itself
+      is interactive but does not normally print such an announcement, your
+      work based on the Program is not required to print an announcement.)
+
+
+These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.
+
+3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:
+
+
+   a) Accompany it with the complete corresponding machine-readable source
+      code, which must be distributed under the terms of Sections 1 and
+      2 above on a medium customarily used for software interchange; or,
+
+
+   b) Accompany it with a written offer, valid for at least three
+      years, to give any third party, for a charge no more than your
+      cost of physically performing source distribution, a complete
+      machine-readable copy of the corresponding source code, to be
+      distributed under the terms of Sections 1 and 2 above on a medium
+      customarily used for software interchange; or,
+
+
+   c) Accompany it with the information you received as to the offer to
+      distribute corresponding source code. (This alternative is allowed
+      only for noncommercial distribution and only if you received the
+      program in object code or executable form with such an offer,
+      in accord with Subsection b above.)
+
+
+The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.
+
+If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.
+
+4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.
+
+5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.
+
+6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.
+
+7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
+
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
+
+8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.
+
+9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.
+
+10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
+
+NO WARRANTY
+
+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+END OF TERMS AND CONDITIONS
+
+How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.
+
+To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.
+
+
+   one line to give the program's name and a brief idea of what it does.
+   Copyright (C) 
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this when it starts in an interactive mode:
+
+
+   Gnomovision version 69, Copyright (C) year name of author Gnomovision
+   comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is
+   free software, and you are welcome to redistribute it under certain
+   conditions; type `show c' for details.
+
+
+The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, the commands you use may be called something other than `show w' and `show c'; they could even be mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary. Here is a sample; alter the names:
+
+
+   Yoyodyne, Inc., hereby disclaims all copyright interest 
+   in the program `Gnomovision' (which makes passes at compilers)
+   written by James Hacker.
+
+   signature of Ty Coon, 1 April 1989
+   Ty Coon, President of Vice
+
+
+This General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Library General Public License instead of this License.
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/inc/tmbslPhyEN2510.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/inc/tmbslPhyEN2510.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/inc/tmbslPhyEN2510.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/inc/tmbslPhyEN2510.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,697 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN2510.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN2510 PHY
+ *
+ * DOCUMENT REF: Datasheet Entropic EN2510
+ *               Integrated 10/100/1000 Gigabit MoCA Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyEN2510_H_
+#define tmbslPhyEN2510_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET  (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL  (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR  (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL  (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYEN2510_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYEN2510_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYEN2510_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYEN2510_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYEN2510_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYEN2510_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYEN2510_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYEN2510_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYEN2510_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYEN2510_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYEN2510_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYEN2510_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYEN2510_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYEN2510_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYEN2510_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYEN2510_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYEN2510_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYEN2510_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYEN2510_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYEN2510_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYEN2510_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYEN2510_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYEN2510_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYEN2510_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYEN2510_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYEN2510_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYEN2510_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYEN2510_BMSR_JAB_VAL (0x2)
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYEN2510_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYEN2510_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYEN2510_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYEN2510_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYEN2510_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYEN2510_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYEN2510_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYEN2510_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYEN2510_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYEN2510_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYEN2510_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYEN2510_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYEN2510_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYEN2510_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYEN2510_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYEN2510_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYEN2510_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYEN2510_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYEN2510_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYEN2510_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYEN2510_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYEN2510_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYEN2510_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** PHY Specific Control register ******/
+#define TMBSL_PHYEN2510_PHYCR_CRS          (0x800)
+#define TMBSL_PHYEN2510_PHYCR_FORCE_LNK    (0x400)
+#define TMBSL_PHYEN2510_PHYCR_DIS_CLK125   (0x10)
+#define TMBSL_PHYEN2510_PHYCR_DIS_JABBER   (0x1)
+
+/* Bit 6:5 MDI Crossover Mode
+ *   00: Manual MDI Crossover configuration
+ *   01: Manual MDI configuration
+ *   10: Default value
+ * Note: Before setting register, address 0xE bit 10 needs to be set to 1.
+ *       After setting register, a PHY reset is required.
+ */
+#define TMBSL_PHYEN2510_PHYCR_MDI_XOVR_MODE_MSK (0x60)
+#define TMBSL_PHYEN2510_PHYCR_MAN_MDI_XOVR      (0x0)
+#define TMBSL_PHYEN2510_PHYCR_MAN_MDI           (0x1)
+#define TMBSL_PHYEN2510_PHYCR_MDI               (0x2)
+
+/****** PHY Specific Status Register ******/
+/* Bit 15:14 Speed
+ *   00: 10 Mbps
+ *   01: 100 Mbps
+ *   10: 1000 Mbps
+ *   11: Reserved
+ */
+#define TMBSL_PHYEN2510_PHYSTAT_SPEED_MSK       (0xC000)
+#define TMBSL_PHYEN2510_PHYSTAT_SPEED_10        (0x0)
+#define TMBSL_PHYEN2510_PHYSTAT_SPEED_100       (0x1)
+#define TMBSL_PHYEN2510_PHYSTAT_SPEED_1000      (0x2)
+
+#define TMBSL_PHYEN2510_PHYSTAT_DUPLEX          (0x2000)
+#define TMBSL_PHYEN2510_PHYSTAT_PAGE_RX         (0x1000)
+#define TMBSL_PHYEN2510_PHYSTAT_SPD_DUP_RES     (0x800)
+#define TMBSL_PHYEN2510_PHYSTAT_LINK_RT         (0x400)
+#define TMBSL_PHYEN2510_PHYSTAT_MDI_XOVR_STAT   (0x40)
+#define TMBSL_PHYEN2510_PHYSTAT_JABBER_RT       (0x1)
+
+/****** Interrupt Enable Register ******/
+#define TMBSL_PHYEN2510_IER_AN_ERR              (0x8000)
+#define TMBSL_PHYEN2510_IER_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN2510_IER_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN2510_IER_PG_RX               (0x1000)
+#define TMBSL_PHYEN2510_IER_AN_COMP             (0x800)
+#define TMBSL_PHYEN2510_IER_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN2510_IER_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN2510_IER_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN2510_IER_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN2510_IER_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN2510_IER_JABBER              (0x1)
+
+/****** Interrupt Status Register ******/
+#define TMBSL_PHYEN2510_ISR_AN_ERR              (0x8000)
+#define TMBSL_PHYEN2510_ISR_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN2510_ISR_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN2510_ISR_PG_RX               (0x1000)
+#define TMBSL_PHYEN2510_ISR_AN_COMP             (0x800)
+#define TMBSL_PHYEN2510_ISR_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN2510_ISR_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN2510_ISR_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN2510_ISR_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN2510_ISR_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN2510_ISR_JABBER              (0x1)
+
+/****** LED Control Register ******/
+#define TMBSL_PHYEN2510_LEDCR_DISABLE_LED        (0x8000)
+#define TMBSL_PHYEN2510_LEDCR_LINK_CTL           (0x8)
+#define TMBSL_PHYEN2510_LEDCR_RX_CTL             (0x2)
+#define TMBSL_PHYEN2510_LEDCR_TX_CTL             (0x1)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef enum
+{
+    /* Basic mode control */
+    tmbslPhyEN2510Bmcr			= 0x0,
+    /* Basic mode status */
+    tmbslPhyEN2510Bmsr			= 0x1,
+
+    /* 0x2-1E are reserved */
+
+    /*Extended status register */
+    tmbslPhyEN25101kscr		= 0xF,
+
+    /**** Vendor Specific Registers *****/
+    /* 0x10-19 are reserved */
+
+} tmbslPhyEN2510Reg_t;
+
+typedef struct  _tmbslPhyEN2510Context_t
+{
+    UInt32	pRegs;         // Array ETHERNET Module regs
+} tmbslPhyEN2510Context_t, *ptmbslPhyEN2510Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetSWVersion (
+    ptmSWVersion_t	pPhyVersion
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetCapabilities (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCapabilities_t	pPhyCaps
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.
+//		1. Enable the auto negotiation. In auto-negotiation mode the
+//		highest possible performance mode is selected automatically
+//		which the Link Partner also supports. (In auto negotiation mode
+//		speed and duplex mode will be selected by means of auto negotiation.
+//		Writing to speed and duplex mode does not have meaning in auto
+//		negotiation mode.)
+//		2. The device abilities are programmed to Auto negotiation advertise
+//		register. None of the device abilities are masked. If the PHY
+//		device does not support Auto-negotiation mode, then this function
+//		will set the PHY to basic capabilities of the device.The function
+//		tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to
+//		know what are the default configurations the tmbslPhyInit function
+//		has set to
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNInit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyEN2510BNDeinit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNSetPowerState(
+    tmUnitSelect_t	phyUnitId ,
+    tmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetPowerState(
+    tmUnitSelect_t	phyUnitId,
+    ptmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.
+//		tmbslPhyInit Enable the Auto negotiation mode and will configure
+//		the PHY device for the maximum performance mode available. After
+//		the device is initialized this function can be called to know the
+//		present settings of the PHY device. If application wants to change
+//		the settings it can call tmbslPhySetBasicModeControl to change
+//		the configuration after knowing the capabilities of the PHY device
+//		and Link Partner. #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t
+tmbslPhyEN2510BNSetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetBasicModeStatus (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNAutoNegotiate (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyAutoNegotitationMask_t    	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetIdentifier (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetCounters (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNPcsConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNPcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result
+//		will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNBist (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t  	phyPsedoRandomSeq ,
+    pUInt8			pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNConfigBypass (
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t  	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNLoopBack (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNSoftReset (
+    tmUnitSelect_t	phyUnitId
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetLinkStatus (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyEN2510
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyEN2510.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/src/tmbslPhyEN2510.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/src/tmbslPhyEN2510.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/src/tmbslPhyEN2510.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/src/tmbslPhyEN2510.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,881 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN2510.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN2510 PHY
+ *
+ * DOCUMENT REF: Datasheet Entropic EN2510
+ *               Integrated 10/100/1000 Gigabit MoCA Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyEN2510.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/spinlock.h"
+
+/* Defines */
+
+#define PHY_TIMEOUT				(100000)
+
+#define ANAR_DEFAULT_VAL			(0xADE1)
+#define KTCR1_DEFAULT_VAL			(0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+static tmbslPhyEN2510Context_t gEthContext;
+
+extern spinlock_t moca_spinlock;
+
+/* Static functions definition */
+
+tmErrorCode_t
+tmbslPhyEN2510Read (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN2510Reg_t	reg,
+	pUInt16			pVal
+	);
+
+
+tmErrorCode_t
+tmbslPhyEN2510Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2510Reg_t	reg,
+    UInt16			val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetSWVersion (
+	ptmSWVersion_t	pPhyVersion
+	)
+{
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetCapabilities (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyCapabilities_t  	pPhyCaps
+    )
+
+{
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyEN2510Read(ethUnitId, tmbslPhyEN2510Bmsr, &bmsr);
+
+    /*  Read the extended status register */
+    tmbslPhyEN2510Read(ethUnitId, tmbslPhyEN25101kscr, &extStat);
+
+    pPhyCaps->T4Support100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = True;
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = False;
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = False;
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYEN2510_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility = False;
+
+
+    pPhyCaps->X1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN2510_1KSCR_1000BASEX_FD) > 0) ? True : False);
+
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN2510_1KSCR_1000BASEX_HD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN2510_1KSCR_1000BASET_FD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN2510_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.No Autonegotiation is done in the
+//		initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2510BNInit(
+    tmUnitSelect_t	ethUnitId
+    )
+{
+//    tmErrorCode_t	ethStatus = TM_OK;
+//    UInt16		regval = 0;
+
+    gEthContext.pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+#if 0
+
+    /* Read the defaults in the BMCR */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId,tmbslPhyEN2510Bmcr,&regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    regval |= 0x2100;
+
+    /* Set the PHY for the 100Mbps and Full Duplex */
+    ethStatus = tmbslPhyEN2510Write(ethUnitId,tmbslPhyEN2510Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+#endif
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNDeinit(
+    tmUnitSelect_t	ethUnitId
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNSetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    tmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;    
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    ptmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId,tmbslPhyEN2510Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = False;
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYEN2510_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYEN2510_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN2510_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN2510_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN2510_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNSetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+#if 0    
+    UInt16		bmcr = 0;
+
+    /* Only Full Duplex is supported */
+    bmcr = TMBSL_PHYEN2510_BMCR_FD_EN;
+
+    switch(pPhyBasicModeControl->speed)
+    {
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYEN2510_BMCR_SPEED_1G;
+            break;
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYEN2510_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYEN2510_BMCR_SPEED_10;
+            break;
+
+        default:
+            bmcr |= TMBSL_PHYEN2510_BMCR_SPEED_100;
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyEN2510Write(ethUnitId,tmbslPhyEN2510Bmcr,bmcr);
+#endif
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetBasicModeStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyBasicModeStatus_t	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr,bmcr;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId, tmbslPhyEN2510Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId, tmbslPhyEN2510Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = False;
+
+    pPhyBasicModeStatus->remoteFaultDetected = False;
+
+    pPhyBasicModeStatus->autoNegotiationComplete = False;
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYEN2510_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    /* Not an auto negotiation. So read the values from BMCR */
+    pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+
+    switch(bmcr & TMBSL_PHYEN2510_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN2510_BMCR_SPEED_1G:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN2510_BMCR_SPEED_100:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN2510_BMCR_SPEED_10:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNAutoNegotiate (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t	pAutoNegotiationMask
+    )
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//		mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2510BNLoopBack (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId,tmbslPhyEN2510Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYEN2510_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYEN2510_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyEN2510Write(ethUnitId,tmbslPhyEN2510Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510BNSoftReset (
+    tmUnitSelect_t	ethUnitId
+	)
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetLinkStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr;
+
+    /* Read the BMSR register */
+    ethStatus = tmbslPhyEN2510Read(ethUnitId,tmbslPhyEN2510Bmsr,&bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((bmsr & TMBSL_PHYEN2510_BMSR_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510Read (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2510Reg_t	reg,
+    pUInt16			pVal
+	)
+
+{
+    UInt32		timeout = 0;
+    UInt32 		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs; i cannot do this
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+    *pVal = (UInt16) *pDataReg;
+    
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2510Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2510Reg_t	reg,
+    UInt16			val
+	)
+
+{
+    UInt32		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+    UInt32		timeout = 0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }
+    while (((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+            (timeout < PHY_TIMEOUT));
+
+    if ((timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {        
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_WRITE_FAILED);
+    }
+
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetIdentifier(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2510BNGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t	pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510BNGetCounters(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t     	pPhyCounters
+    )
+{
+    return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510PcsSetConfig(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2510PcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslEN2510PhyBist(
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t	phyPsedoRandomSeq ,
+    pUInt8                     	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslEN2510PhyConfigBypass(
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/apollo_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/apollo_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/apollo_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/apollo_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,70 @@
+/*******************************************************************************
+*
+* Apollo/Inc/apollo_hdr.h
+*
+* Description: Apollo driver main compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_hdr_h__
+#define __apollo_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "inctypes_dvr.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkBus_iface.h"
+#include "ClnkMbx_dvr.h"
+#include "hw_z2_dvr.h"
+
+#include "control_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+#include "debug.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+#include "HostOS_proto.h"
+
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+
+
+#endif // __apollo_hdr_h__
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/Apollo_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/Apollo_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/Apollo_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/Apollo_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,12 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkBus_iface.c ***/
+
+/*** public prototypes from Src/Clnk_ctl_apollo.c ***/
+
+/*** public prototypes from Src/mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/control_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/control_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/control_context_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/control_context_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,79 @@
+/*******************************************************************************
+*
+* Apollo/Inc/control_context_apollo.h
+*
+* Description: Apollo Driver context definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __control_context_apollo_h__
+#define __control_context_apollo_h__
+
+#if 1 // added for MID RF (DEBUG_EPP)
+#include "common_dvr.h"
+
+#define EPP_CAP_FLAGS_RAW_DATA  1
+#define EPP_CAP_FLAGS_CORR_DATA 2
+#endif
+// Control plane Context Structure
+struct _control_context
+{
+    void                *p_dg_ctx ;     // pointer to driver gpl context
+    void                *p_dk_ctx ;     // pointer to driver kernel context
+
+    SYS_UINTPTR         baseAddr;
+    Clnk_MBX_Mailbox_t  mailbox;
+    SYS_UINT8           mailboxInitialized;
+
+    SYS_UINT32          pSwUnsolQueue;      // Software unsolicited queue pointer
+    SYS_UINT32          swUnsolQueueSize;
+
+    void                *at_lock_link;          // spinlock for address translation
+    void                *ioctl_sem_link;
+    void                *mbx_cmd_lock_link;     // mailbox cmd spin lock - referenced in !GPL side
+    void                *mbx_swun_lock_link;    // mailbox sw unsol spin lock - referenced in !GPL side
+
+    SYS_UINT32          clnkThreadID;
+    SYS_UINT32          clnkThreadStop;
+
+    SYS_UINT8           clnk_ctl_in[   CLNK_CTL_MAX_IN_LEN];
+    SYS_UINT8           clnk_ctl_out[  CLNK_CTL_MAX_OUT_LEN];
+
+    SYS_UINT32          at3_base;   // Address translator 3 base address
+    ClnkDef_EvmData_t *         evmData;
+#if 1 // added for MID RF (DEBUG_EPP)
+    ClnkDef_EppData_t           eppData;
+    ClnkDef_EppCapCfg_t         eppCapCfg;
+#endif
+} ;
+
+typedef struct _control_context dc_context_t;
+
+#endif /* __control_context_apollo_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/driverversion_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/driverversion_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/driverversion_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/driverversion_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1 @@
+#define DRV_VERSION "0.0.0.0"
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/HostOS_Spec_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/HostOS_Spec_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/HostOS_Spec_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc/HostOS_Spec_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*
+* Apollo/Inc/HostOS_Spec_apollo.h
+*
+* Description: Host OS Specifications
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __HostOS_Spec_h__
+#define __HostOS_Spec_h__
+
+/*
+ * USER CONFIGURABLES
+ */
+
+#define DRV_NAME    "Apollo"
+
+
+// HostOS print control -- This is the lowest priority (numerically highest level) that will print
+#define HOST_OS_PRINTLOG_THRESHOLD   L_INFO
+
+// Mailbox Queue Constants
+#define CLNK_MBX_CMD_QUEUE_SIZE     32  // Must be a multiple of 2
+#define CLNK_MBX_SWUNSOL_QUEUE_SIZE 32  // Must be a multiple of 2
+#define SW_UNSOL_HW_QUEUE_SIZE      12  // set by HW
+
+#define CLNK_ETH_MRT_TRANSACTION_TIMEOUT    3         // in seconds
+
+#define TT_TASK_SLEEP       15  // in milliseconds
+
+#define DEBUG_IOCTL_PRIV    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_CMDQ    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_MEM     0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_UNSOLQ  0   // define for IOCTL debug prints
+
+#endif /* __HostOS_Spec_h__ */
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,133 @@
+################################################################################
+#                        Entropic Communications, Inc.                         #
+#                         Copyright (c) 2001-2008                              #
+#                          All rights reserved.                                #
+################################################################################
+
+################################################################################
+# This file is licensed under GNU General Public license, except that if you   #
+# have entered into a signed, written license agreement with Entropic covering #
+# this file, that agreement applies to this file instead of the GNU General    #
+# Public License.                                                              #
+#                                                                              #
+# This file is free software: you can redistribute and/or modify it under the  #
+# terms of the GNU General Public License, Version 2, as published by the Free #
+# Software Foundation, unless a different license applies as provided above.   #
+#                                                                              #
+# This program is distributed in the hope that it will be useful, but AS-IS and#
+# WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,#
+# FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, #
+# except as permitted by the GNU General Public License or another license     #
+# agreement between you and Entropic, is prohibited.                           #
+#                                                                              #
+# You should have received a copy of the GNU General Public License, Version 2 #
+# along with this file; if not, see <http://www.gnu.org/licenses/>.            #
+################################################################################
+
+# CandD module makefile
+#
+# Makefile for mini driver to drive Clock and Data lines       ##
+#
+
+# This Makefile has been simplified as much as possible, by putting all
+# generic material, independent of this specific directory, into
+# ../Rules.make. Read that file for details
+
+
+
+ifndef DVR_CWD
+    # Pick up full path to cwd because kernel build doesn't do relative paths.
+    # It also calls this makefile a couple of times so grab the cwd at the very
+    # beginning and save it in the environment.
+    export DVR_CWD := $(CURDIR)
+    #$(warning ~~~~~~~~~~~ top DVR_CWD=$(DVR_CWD))
+endif
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+DVR_INCLUDES  = -I $(DVR_CWD)/drivers/clink/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/CandD \
+                -I $(DVR_CWD)/drivers/clink/../Common/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/Common \
+                -I $(TOPDIR)/include/linux/
+else
+DRV_INCLUDES  = -I $(DVR_CWD)/Inc \
+                -I $(DVR_CWD)/../GPL/CandD \
+                -I $(DVR_CWD)/../Common/Inc \
+                -I $(DVR_CWD)/../GPL/Common
+endif
+
+olist := Src/Clnk_ctl_candd.o \
+         Src/ClnkBus_iface_candd.o \
+         ../Common/Src/ClnkIo.o \
+         ../Common/Src/ctx_setup.o \
+         ../Common/Src/ClnkMbx_dvr.o \
+         ../Common/Src/ClnkMbx_call.o \
+         ../Common/Src/ClnkIo_common.o \
+         ../Common/Src/ctx_abs.o \
+         ../Common/Src/util_dvr.o \
+         ../GPL/CandD/CandD.o \
+         ../GPL/CandD/mdio.o \
+         ../GPL/Common/gpl_ctx_setup.o \
+         ../GPL/Common/gpl_ctx_abs.o \
+         ../GPL/Common/hostos_linux.o
+
+
+EXTRA_CFLAGS +=  $(DRV_INCLUDES)
+EXTRA_CFLAGS += -DCANDD_DRVR_SUPPORT
+EXTRA_CFLAGS += -DCLNK_HOST_SEM
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+
+# clnkdvr components
+  CandDdvr-objs := $(olist)
+
+  # final LKM objects
+  obj-$(CONFIG_NET_CLINK) += CandDdvr.o
+  
+  ifeq ($(DEBUG),y)
+    DEBFLAGS = -O -g # "-O" is needed to expand inlines
+  else
+    DEBFLAGS = -O2
+  endif
+  
+  CFLAGS += $(DEBFLAGS)
+  CFLAGS += $(DVR_INCLUDES)
+  
+else # KERN 24
+export-objs :=
+obj-y       :=
+obj-n       :=
+obj-m       :=
+obj-        :=
+O_TARGET    := CandDdvr.ko
+obj-y       += $(olist)
+ 
+obj-$(CONFIG_NET_CLINK) += CandDdvr.ko
+
+include $(TOPDIR)/Rules.make
+endif # KERN 26
+
+EXTRA_CFLAGS_nostdinc += $(DEBFLAGS)
+##EXTRA_CFLAGS_nostdinc += -I../../inc -I.
+
+
+KSRC ?= /usr/src/linux
+
+# V=1 for verbose showing of commands
+kern:   clean
+	$(MAKE) modules -C $(KSRC) KBUILD_EXTMOD=`pwd` V=1
+
+clean:
+	@echo "CLEAN $(DVR_CWD)"
+	-$(MAKE) clean -C $(KSRC) KBUILD_EXTMOD=`pwd`
+	rm -f ../GPL/CandD/*.o 
+	rm -f Src/*.o 
+	rm -f ../Common/Src/*.o
+	rm -f ../GPL/Common/*.o 
+	rm -f *.ko
+
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/ClnkBus_iface_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/ClnkBus_iface_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/ClnkBus_iface_apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/ClnkBus_iface_apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Apollo/Src/ClnkBus_iface_apollo.c
+*
+* Description: Apollo Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data)
+{
+    clnk_read( vctx, addr & 0x0fffffff, data) ;
+}
+
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data)
+{
+    clnk_write( vctx, addr & 0x0fffffff, data) ;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/Clnk_ctl_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/Clnk_ctl_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/Clnk_ctl_apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Src/Clnk_ctl_apollo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,418 @@
+/*******************************************************************************
+*
+* Apollo/Src/Clnk_ctl_apollo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io);
+
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io)
+{
+    dc_context_t        *dccp = dk_to_dc( vdkcp ) ;
+    Clnk_MBX_Mailbox_t  *pMbx = &dccp->mailbox ;
+
+    switch (cmd)
+    {
+        case CLNK_CTL_NET_CARRIER_OK:
+            break;
+
+        case CLNK_CTL_RESET_DEVICE:
+            break;
+
+        case CLNK_CTL_STOP_DEVICE:
+            Clnk_Kern_Task_Kill((void *)dccp); 
+            break;
+
+        case CLNK_CTL_NET_CARRIER_ON:
+            break;
+        
+        case CLNK_CTL_NET_CARRIER_OFF:
+            // Turn off mailbox processing
+            pMbx->mbxOpen = SYS_FALSE;
+            Clnk_Kern_Task_Stop((void *)dccp);
+            break;
+        
+        case CLNK_CTL_SOC_INIT_BUS:
+            break; 
+        
+        case CLNK_CTL_SOC_BOOTED:
+        {
+            ClnkDef_dataPlaneVars_t *in = (void *)io->in;
+            int                     stat ;
+
+            if (io->in_len < sizeof( *in)) 
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+
+            if (pMbx->mbxOpen == SYS_TRUE)
+            {
+                pMbx->mbxOpen = SYS_FALSE;
+                Clnk_Kern_Task_Stop((void *)dccp);
+            }
+
+            //mailbox reset initialization
+            dccp->pSwUnsolQueue = in->unsol_msgbuf;
+            dccp->swUnsolQueueSize = SW_UNSOL_HW_QUEUE_SIZE;
+
+            if (dccp->pSwUnsolQueue != SYS_NULL)
+            {
+                // set mbxopen
+                stat = Clnk_MBX_Initialize( pMbx, dccp, CLNK_MBX_ETHERNET_TYPE );
+
+                if (stat != SYS_SUCCESS)
+                {
+                    HostOS_PrintLog(L_ERR, "Clink Reset MBX failed, stat=%d.\n", stat);
+                    return (stat);
+                }
+
+                dccp->mailboxInitialized = SYS_TRUE;
+
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+                         0, (SYS_UINTPTR)MbxReplyRdyCallback, (SYS_UINTPTR)dccp);
+                // set unsol mbox pointer
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_Q, 
+                         0, dccp->pSwUnsolQueue, dccp->swUnsolQueueSize);
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+                         0, (SYS_UINTPTR)MbxSwUnsolRdyCallback, (SYS_UINTPTR)dccp);
+
+                if(Clnk_Kern_Task_Init((void *)dccp) != 0)
+                    HostOS_PrintLog(L_ERR, "MBX open, Start TT task failed!\n");
+            }
+            else
+                HostOS_PrintLog(L_ERR, "ERROR: mailbox unsolicited queue is NULL!!\n");
+
+            break;
+        }
+        case CLNK_CTL_TC_DIC_INIT:
+        {
+            struct mb_return *mb = (void *)io->in; 
+ 
+            if (io->in_len < sizeof(*mb) )
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+            // mailbox reset initialization  
+            dccp->pSwUnsolQueue= mb->unsol_msgbuf; 
+            break;
+        }
+        case CLNK_CTL_HW_DESC_INIT:
+            break;
+        case CLNK_CTL_GET_SOC_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_SOC_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_SOC_STATUS, stat=%d.\n", *status);
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_GET_LINK_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_LINK_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_LINK_STATUS\n");
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_SET_MAC_ADDRESS:
+            break;
+        default:
+            return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Ethernet Module.
+*
+* Inputs:
+*       dccp      - Pointer to the control context
+*       option    - Driver option to control
+*       reg       - Register offset or pointer to register offsets
+*       val       - Register value or pointer to register values
+*       length    - Length of data for bulk data
+*
+* Outputs:
+*       CLNK_ETH_RET_CODE_SUCCESS
+*       CLNK_ETH_RET_CODE_GEN_ERR
+*       CLNK_ETH_RET_CODE_RESET_ERR
+*       CLNK_ETH_RET_CODE_LINK_DOWN_ERR
+*
+*******************************************************************************/
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length)
+{
+    dc_context_t *dccp = vdccp;
+    int status = CLNK_ETH_RET_CODE_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_ETH_CTRL_DO_CLNK_CTL:
+            status = do_clnk_ctl_dvr(dccp, (SYS_INT32)reg, (struct clnk_io *)val);
+            break;
+
+        default:
+            status = CLNK_ETH_RET_CODE_GEN_ERR;
+            break;
+    }
+    return (status);
+}
+
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio)
+{
+    SYS_UINT32 cmd = kifr->cmd;
+    SYS_UINT32 subcmd = (SYS_UINT32)kifr->param1;
+
+    switch (cmd)
+    {
+        case CLNK_MBX_ETH_DATA_BUF_CMD:
+        {
+            switch (subcmd)
+            {
+                case CLNK_CTL_GET_MY_NODE_INFO:
+                {
+                    ClnkDef_MyNodeInfo_t *out = (void *)kio->out;
+                    SYS_UINT32  rev1=0, rev2=0, rev3=0, rev4=0;
+                    
+                    HostOS_Sscanf(DRV_VERSION, "%d.%d.%d.%d", 
+                                  &rev1, &rev2, &rev3, &rev4);
+                    out->SwRevNum = ((rev1 & 0xff) << 24) | 
+                                    ((rev2 & 0xff) << 16) |
+                                    ((rev3 & 0xff) << 8)  | 
+                                    ((rev4 & 0xff) );
+                    break;
+                }
+            }
+            break;
+        }
+    }
+}
+
+/**
+* 
+*   Purpose:    Handle clnk_ctl operations originating from within the driver
+*               or from an ioctl.
+*
+*               io->in_len words are used as arguments to the function call.  
+*               Special case:
+*                 if io->in_len is 0, io->in is treated as a single argument 
+*                 rather than a pointer to an argument list.
+*
+*               Up to io->out_len words will be copied as the result of the call.
+*
+*   Imports:    dccp - ClnkEth context struct
+*               cmd  - CLNK_CTL_* command
+*               io   - Inputs and outputs for the CLNK_CTL command
+*
+*   Exports:    CLNK_ETH_RET_CODE_SUCCESS Success.
+*               CLNK_ETH_RET_CODE_GEN_ERR Failure.
+*
+*******************************************************************************/
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io)
+{
+    int ret = CLNK_ETH_RET_CODE_GEN_ERR ;
+    //SYS_UINT32 arg0 = io->in_len ? io->in[0] : ((SYS_UINTPTR)io->in);
+
+    /* cmd is processed by the common driver */
+    switch(cmd)
+    {
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_CTL_GET_BRIDGE_TABLE:
+        {
+            ClnkDef_BridgeTable_t *tbl = (void *)io->out;
+            SYS_UINT32 entries;
+
+            if(io->out_len < sizeof(*tbl))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+
+            entries = Cam_Get(&dccp->cam, &tbl->ent[0], arg0, BRIDGE_ENTRIES);
+            tbl->num_entries = entries;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if 1
+        case CLNK_CTL_GET_EVM_DATA:
+        {
+            ClnkDef_EvmData_t *out = (void *)io->out;
+
+            if (io->out_len < sizeof(*out))
+            {   // Bad Specification
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData)
+            {   // First time, alloc space and return
+                dccp->evmData = (ClnkDef_EvmData_t *)
+                    HostOS_Alloc(sizeof(ClnkDef_EvmData_t));
+                if (dccp->evmData)
+                {
+                    dccp->evmData->valid = 0;
+                    dccp->evmData->NodeId = 0;
+                }
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData->valid)
+            {   // Waiting for New Data
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else
+            {   // Actually got new data
+                HostOS_Memcpy((void *)out, dccp->evmData, sizeof(*out));
+                dccp->evmData->valid = 0;
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+            }
+            break;
+        }
+#endif
+#if 1 // modified for MID RF (DEBUG_EPP)
+        case CLNK_CTL_GET_EPP_DATA:
+        {
+            ClnkDef_EppData_t *out = (void *)io->out;
+
+            HostOS_PrintLog(L_DEBUG, 
+                                "CLNK_CTL_GET_EPP_DATA: valid=%x, flags=%x\n",
+                                dccp->eppData.valid, 
+                                dccp->eppCapCfg.flags);
+	    if ((dccp->eppData.valid != dccp->eppCapCfg.flags) || 
+                    (io->out_len < sizeof(*out)))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+            HostOS_Memcpy((void *)out, &dccp->eppData, sizeof(*out));
+            dccp->eppData.valid = 0;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS:
+        {
+            eclair_ValMboxHostCounts_t *out = (void*)io->out;
+
+            INCTYPES_SAFE_PTR_COPY(out, &clnkEth_valMboxHostCounts);
+
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+        }
+#endif
+#if 1 // added for MID RF (DEBUG_EPP)
+	case CLNK_CTL_GET_EPP_CAP_CFG:
+        {
+                ClnkDef_EppCapCfg_t *out = (void *)io->out;
+
+                if (io->out_len < sizeof(*out))
+                {
+                    ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                    break;
+                }
+                HostOS_Memcpy((void *)out, &dccp->eppCapCfg, sizeof(*out));
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+                break;
+        }
+
+        case CLNK_CTL_SET_EPP_CAP_CFG:
+        {
+                ClnkDef_EppCapCfg_t *in = (void *)io->in;
+                //Clnk_MBX_Msg_t mbxMsg;
+                //SYS_UINT8 transID;
+
+                if(io->in_len < sizeof(*in))
+                {
+                    ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                    HostOS_PrintLog(L_INFO, "Error in length of EPP config \n");
+      
+                    break;
+                }
+#if 0
+                mbxMsg.msg.ethCmd.cmd      =
+                    CLNK_MBX_SET_CMD(CLNK_MBX_ETH_SET_EPP_CAP_CFG);
+                mbxMsg.msg.ethCmd.param[0] = in->nodeId;
+                mbxMsg.msg.ethCmd.param[1] = in->flags;
+                Clnk_MBX_SendRcvMsg(&pContext->mailbox, &mbxMsg, &mbxMsg,
+                                    3, MBX_POLL_TIMEOUT_IN_US);
+#endif //0
+                /* 
+                 * Set the new EPP capture config and clear out existing data
+                 * valid flags related to previous captures
+                 */
+                clnk_blk_write(dccp, DEV_SHARED(eppCapSrcId),
+                            (SYS_UINT32 *)in, sizeof(ClnkDef_EppCapCfg_t));
+                dccp->eppCapCfg = *in;
+                dccp->eppData.valid = 0;
+
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+                HostOS_PrintLog(L_INFO, "EPP_CAP_CFG: nodeId=%u, flags=%x\n",
+                                in->nodeId, in->flags);
+                break;
+        }
+#endif
+    }
+
+    return(ret);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkBus_iface.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkBus_iface.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkBus_iface.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkBus_iface.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,42 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkBus_iface.h
+*
+* Description: Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNKBUS_IFACE_H__
+#define __CLNKBUS_IFACE_H__
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data);
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data);
+
+#endif /* __CLNKBUS_IFACE_H__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Clnk_ctl_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Clnk_ctl_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Clnk_ctl_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Clnk_ctl_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,47 @@
+/*******************************************************************************
+*
+* Common/Inc/Clnk_ctl_dvr.h
+*
+* Description: c.LINK control interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNK_CTL_DVR_H__
+#define __CLNK_CTL_DVR_H__
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io);
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length);
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio);
+
+#endif /* __CLNK_CTL_DVR_H__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/clnkiodefs.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/clnkiodefs.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/clnkiodefs.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/clnkiodefs.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,53 @@
+/*******************************************************************************
+*
+* Common/Inc/clnkiodefs.h
+*
+* Description: Driver IO definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __clnkiodefs_h__
+#define __clnkiodefs_h__
+
+
+
+// from sockios.h : #define SIOCDEVPRIVATE  0x89F0  /* to 89FF */
+
+#define SIOCCLINKDRV	(SIOCDEVPRIVATE+1)  // Control plane commands for the driver
+#define SIOCGCLINKMEM	(SIOCDEVPRIVATE+2)  // Reads registers/memory in c.LINK address space
+#define SIOCSCLINKMEM	(SIOCDEVPRIVATE+3)  // Sets registers/memory in c.LINK address space
+#define SIOCGCLNKCMD    (SIOCDEVPRIVATE+10) // pass thru c.LINK command that expects a response
+#define SIOCSCLNKCMD    (SIOCDEVPRIVATE+11) // pass thru c.LINK command that expects no response
+#define SIOCLNKDRV      (SIOCDEVPRIVATE+12) // a. Initialize Mailbox Queue Handler b. Get Unsolicited Message 
+#define SIOCHDRCMD	    (SIOCDEVPRIVATE+13)  // Resets the SoC , Control the diplexer switch etc.
+
+
+
+
+#endif /* __clnkiodefs_h__ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkMbx_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkMbx_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkMbx_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/ClnkMbx_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,408 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkMbx_dvr.h
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __ClnkMbx_dvr_h__
+#define __ClnkMbx_dvr_h__
+
+/*******************************************************************************
+*                             # i n c l u d e s                                *
+********************************************************************************/
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+// Common Mailbox Module Configuration
+//#define CLNK_MBX_AUTO_REPLY  // Auto reply (for debugging only)
+
+#define MAX_UNSOL_MSG       8
+#define MAX_MBX_MSG         100
+
+// Mailbox Type Constants
+#define CLNK_MBX_ETHERNET_TYPE  0
+#define CLNK_MBX_MPEG_TYPE      1
+
+// Mailbox Polling Rate
+#define MBX_POLL_TIMEOUT_IN_US    (20*1000)
+
+// Mailbox Queue Constants
+// queue sizes are in HostOS_Spec.h
+
+// Mailbox Command Code Definitions
+#define CLNK_MBX_CMD_CODE_OFFSET      0
+#define CLNK_MBX_CMD_CODE_MASK        0xff
+#define CLNK_MBX_CMD_TRANS_ID_OFFSET  8
+#define CLNK_MBX_CMD_TRANS_ID_MASK    0xff
+#define CLNK_MBX_CMD_VER_NUM_OFFSET   16
+#define CLNK_MBX_CMD_VER_NUM_MASK     0xf
+#define CLNK_MBX_CMD_PORT_OFFSET      20
+#define CLNK_MBX_CMD_PORT_MASK        0xf
+#define CLNK_MBX_CMD_LEN_OFFSET       24
+#define CLNK_MBX_CMD_LEN_MASK         0xff
+
+#define CLNK_MBX_SET_CMD(x)       (((x) & CLNK_MBX_CMD_CODE_MASK)     << \
+                                   CLNK_MBX_CMD_CODE_OFFSET)
+#define CLNK_MBX_SET_TRANS_ID(x)  (((x) & CLNK_MBX_CMD_TRANS_ID_MASK) << \
+                                   CLNK_MBX_CMD_TRANS_ID_OFFSET)
+#define CLNK_MBX_SET_VER_NUM(x)   (((x) & CLNK_MBX_CMD_VER_NUM_MASK)  << \
+                                   CLNK_MBX_CMD_VER_NUM_OFFSET)
+#define CLNK_MBX_SET_PORT(x)      (((x) & CLNK_MBX_CMD_PORT_MASK)     << \
+                                   CLNK_MBX_CMD_PORT_OFFSET)
+#define CLNK_MBX_SET_LEN(x)       (((x) & CLNK_MBX_CMD_LEN_MASK)      << \
+                                   CLNK_MBX_CMD_LEN_OFFSET)
+
+#define CLNK_MBX_GET_CMD(x)       (((x) >> CLNK_MBX_CMD_CODE_OFFSET) &   \
+                                   CLNK_MBX_CMD_CODE_MASK)
+#define CLNK_MBX_GET_CMD_LEN(x)   (((x) >> CLNK_MBX_CMD_LEN_OFFSET) &    \
+                                   CLNK_MBX_CMD_LEN_MASK)
+
+
+// Mailbox Reply Status Definitions
+#define CLNK_MBX_REPLY_TRANS_ID_OFFSET  0
+#define CLNK_MBX_REPLY_TRANS_ID_MASK    0xff
+#define CLNK_MBX_REPLY_STATUS_OFFSET    8
+#define CLNK_MBX_REPLY_STATUS_MASK      0xff
+#define CLNK_MBX_REPLY_ARG1_OFFSET      16
+#define CLNK_MBX_REPLY_ARG1_MASK        0xff
+#define CLNK_MBX_REPLY_LEN_OFFSET       24
+#define CLNK_MBX_REPLY_LEN_MASK         0xff
+
+#define CLNK_MBX_GET_TRANS_ID(x)  (((x) >> CLNK_MBX_REPLY_TRANS_ID_OFFSET) & \
+                                   CLNK_MBX_REPLY_TRANS_ID_MASK)
+#define CLNK_MBX_GET_STATUS(x)    (((x) >> CLNK_MBX_REPLY_STATUS_OFFSET)   & \
+                                   CLNK_MBX_REPLY_STATUS_MASK)
+#define CLNK_MBX_GET_ARG1(x)      (((x) >> CLNK_MBX_REPLY_ARG1_OFFSET)     & \
+                                   CLNK_MBX_REPLY_ARG1_MASK)
+#define CLNK_MBX_GET_REPLY_LEN(x) (((x) >> CLNK_MBX_REPLY_LEN_OFFSET)      & \
+                                   CLNK_MBX_REPLY_LEN_MASK)
+
+// CLNK Kernel Thread Status Definition
+#define CLNK_TASK_RUNNING       0
+#define CLNK_TASK_STOPPED       1
+#define CLNK_TASK_SLEEP         2
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// Mailbox Status Codes
+typedef enum
+{
+    CLNK_MBX_STATUS_SUCCESS = SYS_SUCCESS,
+
+    CLNK_MBX_STATUS_MAX  // This must always be last
+}
+CLNK_MBX_STATUS;
+
+// Mailbox Control Options
+typedef enum
+{
+    CLNK_MBX_CTRL_ENABLE_INTERRUPT,
+    CLNK_MBX_CTRL_DISABLE_INTERRUPT,
+    CLNK_MBX_CTRL_CLEAR_INTERRUPT,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_Q,
+    CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+    CLNK_MBX_CTRL_SET_UNSOL_RDY_CB,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+
+    CLNK_MBX_CTRL_MAX  // This must always be last
+}
+CLNK_MBX_CTRL_OPTIONS;
+
+// Command Codes
+typedef enum
+{
+    // Ethernet commands
+    CLNK_MBX_ETH_RESET_CMD                        = 0x00,   /* Alias: ETH_MB_RESET,                             */
+    CLNK_MBX_ETH_ALLOC_TX_FIFO_CMD                = 0x01,   /* Alias: ETH_MB_ALLOCATE_TX_FIFO,                  */
+    CLNK_MBX_ETH_ALLOC_RX_FIFO_CMD                = 0x02,   /* Alias: ETH_MB_ALLOCATE_RX_FIFO,                  */
+    CLNK_MBX_ETH_JOIN_MCAST_CMD                   = 0x03,   /* Alias: ETH_MB_JOIN_MULTICAST,                    */
+    CLNK_MBX_ETH_LEAVE_MCAST_CMD                  = 0x04,   /* Alias: ETH_MB_LEAVE_MULTICAST,                   */
+    CLNK_MBX_ETH_REGISTER_MCAST_CMD               = 0x05,   /* Alias: ETH_MB_REGISTER_MULTICAST,                */
+    CLNK_MBX_ETH_GET_STATS_CMD                    = 0x06,   /* Alias: ETH_MB_QUERY_RCV_STATS,                   */
+    CLNK_MBX_ETH_SET_RCV_MODE_CMD                 = 0x07,   /* Alias: ETH_MB_SET_RCV_MODE,                      */
+    CLNK_MBX_ETH_GET_RCV_MODE_CMD                 = 0x08,   /* Alias: ETH_MB_GET_RCV_MODE,                      */
+    CLNK_MBX_ETH_PUB_UCAST_CMD                    = 0x09,   /* Alias: ETH_MB_PUBLISH_UNICAST_ADDR,              */
+    CLNK_MBX_ETH_DEREGISTER_MCAST_CMD             = 0x0a,   /* Alias: ETH_MB_DEREGISTER_MULTICAST,              */
+    CLNK_MBX_ETH_DATA_BUF_CMD                     = 0x0b,   /* Alias: ETH_MB_DATA_BUF_CMD,                      */
+    CLNK_MBX_ETH_GET_STATUS_CMD                   = 0x0c,   /* Alias: ETH_MB_GET_STATUS,                        */
+    CLNK_MBX_ETH_SET_SW_CONFIG_CMD                = 0x0d,   /* Alias: ETH_MB_SET_SW_CONFIG,                     */
+    CLNK_MBX_ETH_ECHO_PROFILE_PROBE_RESPONSE      = 0x0e,   /* Alias: ETH_MB_ECHO_PROFILE_PROBE_RESPONSE,       */
+    CLNK_MBX_ETH_GET_CMD                          = 0x0f,   /* Alias: ETH_MB_GET_CMD,                           */
+    CLNK_MBX_ETH_SET_CMD                          = 0x10,   /* Alias: ETH_MB_SET_CMD,                           */
+    CLNK_MBX_ETH_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE = 0x11,  /* Alias: ETH_MB_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE, */
+    CLNK_MBX_ETH_SET_BEACON_POWER_LEVEL_CMD       = 0x12,   /* Alias: ETH_MB_SET_BEACON_POWER_LEVEL_CMD,        */
+    CLNK_MBX_ETH_QOS_ASYNC_REQ_BLOB               = 0x13,   /* Alias: ETH_MB_QOS_ASYNC_REQ_BLOB,                */
+    CLNK_MBX_ETH_QFM_RESP_BLOB                    = 0x14,   /* Alias: ETH_MB_QFM_RESP_BLOB,                     */
+    CLNK_MBX_ETH_SET_MIXED_MODE_ACTIVE            = 0x15,   /* Obsolete */
+    CLNK_MBX_ETH_GET_MIXED_MODE_ACTIVE            = 0x16,   /* Obsolete */
+    CLNK_MBX_ETH_QFM_CAM_DONE                     = 0x17,   /* Alias: ETH_MB_QFM_CAM_DONE,                      */
+    // MPEG commands
+    CLNK_MBX_MPEG_CREATE_INPUT_CHANNEL_CMD        = 0x20,
+    CLNK_MBX_MPEG_JOIN_CHANNEL_CMD                = 0x21,
+    CLNK_MBX_MPEG_JOIN_AS_PASSIVE_LISTENER_CMD    = 0x22,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REQUEST_CMD        = 0x23,
+    CLNK_MBX_MPEG_MODIFY_INPUT_CHANNEL_CMD        = 0x24,
+    CLNK_MBX_MPEG_MODIFY_OUTPUT_CHANNEL_CMD       = 0x25,
+    CLNK_MBX_MPEG_LEAVE_INPUT_CHANNEL_CMD         = 0x26,
+    CLNK_MBX_MPEG_LEAVE_OUTPUT_CHANNEL_CMD        = 0x27,
+    CLNK_MBX_MPEG_CREATE_OUTPUT_CHANNEL_CMD       = 0x28,
+    CLNK_MBX_MPEG_RESERVED_CMD_FROM               = 0x29,
+    CLNK_MBX_MPEG_RESERVED_CMD_TO                 = 0x2F,
+    CLNK_MBX_MPEG_READ_TRANSMIT_STATS_CMD         = 0x30,
+    CLNK_MBX_MPEG_READ_RECEIVE_STATS_CMD          = 0x31,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REPORT_REQUEST_CMD = 0x32,
+
+    CLNK_MBX_MAX_CMD  // This must always be last
+}
+CLNK_MBX_CMD_CODES;
+
+// Unsolicited message types
+typedef enum
+{
+    CLNK_MBX_UNSOL_MSG_UCAST_PUB                    = 0,     /* Alias: UNSOL_MSG_UCAST_PUB_TYPE               */
+    CLNK_MBX_UNSOL_MSG_EVM_DATA_READY               = 1,     /* Alias: UNSOL_MSG_EVM_DATA_READY_TYPE          */
+    CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE           = 2,     /* Alias: UNSOL_MSG_ECHO_PROFILE_PROBE           */
+    CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS             = 3,     /* Alias: UNSOL_MSG_ADMISSION_STATUS             */
+    CLNK_MBX_UNSOL_MSG_BEACON_STATUS                = 4,     /* Alias: UNSOL_MSG_BEACON_STATUS                */
+    CLNK_MBX_UNSOL_MSG_RESET                        = 5,     /* Alias: UNSOL_MSG_MAC_RESET                    */
+    CLNK_MBX_UNSOL_MSG_TABOO_INFO                   = 6,     /* Alias: UNSOL_MSG_TABOO_INFO                   */
+    CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC               = 7,     /* Alias: UNSOL_MSG_CHK_MAC_ADDRESS              */
+    CLNK_MBX_UNSOL_MSG_NODE_ADDED                   = 8,     /* Alias: UNSOL_MSG_NODE_ADDED                   */
+    CLNK_MBX_UNSOL_MSG_NODE_DELETED                 = 9,     /* Alias: UNSOL_MSG_NODE_DELETED                 */
+    CLNK_MBX_UNSOL_MSG_UCAST_UNPUB                  = 10,    /* Alias: UNSOL_MSG_UCAST_UNPUB_TYPE             */
+    CLNK_MBX_UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  = 11,    /* Alias: UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  */
+    CLNK_MBX_UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    = 12,    /* Alias: UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    */
+    CLNK_MBX_UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST = 13,    /* Alias: UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST */
+    CLNK_MBX_UNSOL_MSG_FSUPDATE                     = 14,    /* Alias: UNSOL_MSG_FSUPDATE                     */
+    CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY           = 20,    /* Alias: UNSOL_MSG_ADD_CAM_ENTRY                */
+    CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      = 21,    /* Alias: UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      */
+
+#if ECFG_FLAVOR_VALIDATION==1
+    CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT               = 22,    /* Alias: UNSOL_MSG_VAL_ISOC_EVENT               */
+#endif
+
+    CLNK_MBX_MAX_UNSOL_MSG_TYPE // This must always be last
+}
+CLNK_MBX_UNSOL_MSG_TYPES;
+
+// Maximum Message Structure
+typedef struct
+{
+    SYS_UINT32 msg[MAX_MBX_MSG];
+}
+Clnk_MBX_MaxMsg_t;
+
+// Ethernet Command Structure
+typedef struct
+{
+    SYS_UINT32 cmd;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthCmd_t;
+
+// Ethernet Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthReply_t;
+
+// MPEG Command Structure
+typedef struct
+{
+    SYS_UINT32  cmd;
+    SYS_UINT32  param[7];
+}
+Clnk_MBX_MpegCmd_t;
+
+// MPEG Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param;
+}
+Clnk_MBX_MpegReply_t;
+
+// Generic Mailbox Message Structure
+typedef struct
+{
+    union
+    {
+        Clnk_MBX_MaxMsg_t           maxMsg;
+        SYS_UINT32                  cmdCode;
+        SYS_UINT32                  replyStatus;
+
+        // Ethernet mailbox command
+        Clnk_MBX_EthCmd_t           ethCmd;
+
+        // Ethernet mailbox reply
+        Clnk_MBX_EthReply_t         ethReply;
+
+        // MPEG mailbox command
+        Clnk_MBX_MpegCmd_t          mpegCmd;
+
+        // MPEG mailbox reply
+        Clnk_MBX_MpegReply_t        mpegReply;
+    }
+    msg;
+}
+Clnk_MBX_Msg_t;
+
+// Reply and Unsolicited Ready Callback Function
+typedef void (*Clnk_MBX_RdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+typedef int (*Clnk_MBX_SwUnsolRdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+
+// Command Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t          sendMsg;
+    Clnk_MBX_Msg_t          rcvMsg;
+    SYS_UINT8               transID;
+    volatile int            isReplyRdy;
+    volatile int            isReplyTimedOut;
+    void                    *msg_wqt ;
+ //   struct hostos_timer     msg_timer;
+ //   wait_queue_head_t       msg_wq;
+} Clnk_MBX_CmdQueueEntry_t;
+
+// Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+    SYS_UINT8      transID;
+}
+Clnk_MBX_UnsolQueueEntry_t;
+
+// Sw Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+}
+Clnk_MBX_SwUnsolQItem_t;
+
+// Software unsolicited Queue Entry Structure
+typedef struct
+{
+    SYS_UINT32     ownership;
+    SYS_UINT32     transID;
+    SYS_UINT32     msg[MAX_UNSOL_MSG];
+}
+Clnk_MBX_SwUnsolQueueEntry_t;
+
+
+// Mailbox Structure
+typedef struct
+{
+    void                          *dc_ctx; // driver control ctx
+    SYS_UINT32                    type;
+    SYS_UINT32                    mbxOpen;
+
+    // Callback functions
+    Clnk_MBX_RdyCallback          replyRdyCallback;
+    void                          *replyParam;
+    Clnk_MBX_SwUnsolRdyCallback   swUnsolRdyCallback;
+    void                          *swUnsolParam;
+
+    // Command queue
+    Clnk_MBX_CmdQueueEntry_t      cmdQueue[CLNK_MBX_CMD_QUEUE_SIZE];
+    SYS_UINT8                     cmdHeadIndex;   // dequeue point
+    SYS_UINT8                     cmdTailIndex;   // enqueue point
+    SYS_UINT8                     cmdCurrTransID;
+    void                          *mbx_lock;      // referenced here from GPL side
+
+    // Software unsolicited queue
+    SYS_UINT32                    swUnsolQueueSlaveMap;
+    SYS_UINT32                    pSwUnsolQueue; // ptr to array of Clnk_MBX_SwUnsolQueueEntry_t in pci space
+    SYS_UINT32                    swUnsolQueueSize;
+    SYS_UINT8                     swUnsolReadIndex;
+    SYS_UINT8                     swUnsolCurrTransID;
+    Clnk_MBX_SwUnsolQItem_t       swUnsolQueue[CLNK_MBX_SWUNSOL_QUEUE_SIZE];
+    SYS_UINT8                     swUnsolHeadIndex;
+    SYS_UINT8                     swUnsolTailIndex;
+    SYS_UINT8                     swUnsolCount;
+    SYS_UINT8                     swUnsolOverrun;
+    void                          *swUnsolLock;     // referenced here from GPL side
+
+    // Register offsets and bit masks
+    SYS_UINT32                    writeMbxCsrOffset;
+    SYS_UINT32                    readMbxCsrOffset;
+    SYS_UINT32                    writeMbxRegOffset;
+    SYS_UINT32                    readMbxRegOffset;
+    SYS_UINT32                    writeMbxSize;
+    SYS_UINT32                    readMbxSize;
+}
+Clnk_MBX_Mailbox_t;
+
+
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type);
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length);
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus);
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len);
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf);
+                   
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs);
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx );
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+int Clnk_Kern_Task_Init(void *data);
+int Clnk_Kern_Task_Stop(void *data);
+int Clnk_Kern_Task_Kill(void *data);
+#endif
+
+#endif /* __ClnkMbx_dvr_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/com_abs_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/com_abs_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/com_abs_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/com_abs_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,13 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/Clnk_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_abs.c ***/
+void *dc_to_dg( void *dccp );
+void *dc_to_dk( void *dccp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/common_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/common_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/common_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/common_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1510 @@
+/*******************************************************************************
+*
+* Common/Inc/common_dvr.h
+*
+* Description: Driver stuff shared across modules
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __common_dvr_h__
+#define __common_dvr_h__
+
+#include "inctypes_dvr.h"
+#include "entropic-config.h"
+
+/***************** definitions originally from ClnkDefs.h ********************/
+#define NETWORK_TYPE_ACCESS      ECFG_NETWORK_ACCESS
+#define NETWORK_TYPE_HIRF_MESH   ECFG_NETWORK_HIRF_MESH
+#define NETWORK_TYPE_MIDRF_MESH  ECFG_NETWORK_MIDRF_MESH
+#define NODE_TYPE_ACCESS_HEADEND ECFG_NODE_HEADEND
+#define NODE_TYPE_ACCESS_CPE     ECFG_NODE_CPE
+#define NODE_TYPE_ACCESS_TCPE    ECFG_NODE_TCPE
+#define NODE_TYPE_MESH_MOCA     ((ECFG_NETWORK_HIRF_MESH||ECFG_NETWORK_MIDRF_MESH) && ECFG_NODE_MOCA)
+
+#if ! defined(NETWORK_TYPE_ACCESS)
+#define NETWORK_TYPE_ACCESS                0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFS)
+#define HAS_FAST_IMPLEMENTATION_OF_FFS     0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFZ)
+#define HAS_FAST_IMPLEMENTATION_OF_FFZ     0
+#endif
+
+#if ! defined(CLNK_ETH_PER_PACKET)
+#define CLNK_ETH_PER_PACKET                1
+#endif
+
+#if ! defined(ECFG_FLAVOR_VALIDATION)
+#define ECFG_FLAVOR_VALIDATION             0
+#endif
+
+#if (NETWORK_TYPE_MIDRF_MESH)
+	#define FEATURE_SPECTRAL_SCULPTING  1
+	#define FEATURE_INGRESS_MARGIN      1
+#else
+	#define FEATURE_SPECTRAL_SCULPTING  0
+	#define FEATURE_INGRESS_MARGIN      0
+#endif
+
+#if ! defined(FEATURE_IQM)
+#define FEATURE_IQM                        0
+#endif
+
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project.
+ */
+#if ! defined(FEATURE_PUPQ_NMS)
+#define FEATURE_PUPQ_NMS                   1
+#endif
+
+/**
+ * This marks code added to round out last minute customer requests. 
+ */
+#if ! defined(FEATURE_PUPQ_NMS_QUICK_APIS)
+#define FEATURE_PUPQ_NMS_QUICK_APIS        1
+#endif
+
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project- 
+ * new configuration items.  It is not tested disabled.
+ */
+#if ! defined(FEATURE_PUPQ_NMS_CONF)
+#define FEATURE_PUPQ_NMS_CONF              1
+#endif
+
+/**
+ * This marks code (in progress) used to collect items using 
+ * the L2ME Gather Queryable operation
+ */
+#if ! defined(FEATURE_PUPQ_GQ)
+#define FEATURE_PUPQ_GQ                    1
+#endif
+
+/**
+ * This marks code used to collect per-node statistics on receiver
+ * received packet errors, both sync and async.
+ */
+#if ! defined(FEATURE_PUPQ_RX_NODE_STATS)
+#define FEATURE_PUPQ_RX_NODE_STATS         1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_QOS_CCPU_ENTRY)
+#define FEATURE_QOS_CCPU_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_FMR_ENTRY)
+#define FEATURE_CCPU_FMR_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_GENERIC_L2ME_ENTRY)
+#define FEATURE_CCPU_GENERIC_L2ME_ENTRY    1
+#endif
+
+/** 
+ * Marks code that should be COMPLETELY removed from the codebase.  This
+ * variable should absolutely never set to 1.  The only reason this code
+ * remains in the codebase is that several projects must merge to a common
+ * tree; until this merge has happened, the diffs created by deletions
+ * would slow parallel progress.
+ */
+#define NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING  0
+
+#if 0                                        \
+    || ECFG_BOARD_PC_DVT2_PCI_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_MII_ZIP2==1         \
+    || ECFG_BOARD_PC_DVT_TMII_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_GMII_ZIP2==1        \
+    || ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2==1  \
+    || ECFG_BOARD_ECB_PCI_ZIP2==1            \
+    || ECFG_BOARD_PC_PCI_ZIP2==1             \
+    || ECFG_BOARD_PC_PCI_ZIP1==1             \
+    || ECFG_BOARD_ECB_ROW==1                 \
+    || ECFG_BOARD_PC_PCIE_MAVERICKS==1        \
+    || ECFG_BOARD_ECB_4M_L3==1                 \
+    || ECFG_BOARD_ECB_3M_L3==1               \
+    || 0
+#define L2_DONGLE 0
+#else
+#error NOT A KNOWN BOARD!
+#endif
+
+/**
+ * Warning! this value must exactly match the value used in the ccpu image that
+ * was compiled using this file.
+ */
+#if   (NETWORK_TYPE_ACCESS)
+    #define MAX_NUM_NODES        32
+    #error
+#elif (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDRF_MESH)
+
+/* Protem pQOS/NMS specific.  Set to 8 for
+ * PROTEM builds or 16 for ADVANCED builds. 
+ */
+#if (ECFG_FLAVOR_PRODUCTION_PROTEM)
+    #define MAX_NUM_NODES   8
+#else
+    #define MAX_NUM_NODES   16
+#endif
+
+#else
+#error unsupported.
+#endif
+
+/* 
+    log levels for HostOS_PrintLog 
+    0 is highest priority
+
+    See also:
+        HOST_OS_PRINTLOG_THRESHOLD 
+
+ */
+enum
+{
+    L_EMERG      ,
+    L_ALERT      ,
+    L_CRIT       ,
+    L_ERR        ,
+    L_WARNING    ,
+    L_NOTICE     ,
+    L_INFO       ,
+    L_DEBUG      ,
+};
+
+
+// rudimentary back-cast macro
+#ifndef offsetof
+#define offsetof(x, y)          ((int)&(((x *)SYS_NULL)->y))
+#endif
+
+
+// OS timer expiration callback function
+typedef void (*timer_function_t)(unsigned long);
+
+// Wait Q Timer exit condition function
+typedef int (*HostOS_wqt_condition)(void *vp);
+
+// Wait Q exit condition function
+typedef int (*HostOS_waitq_condition)(void *vp);
+
+
+/*******************************************************************************
+*           G L O B A L   B I T F I E L D   M A N I P U L A T O R S            *
+********************************************************************************/
+
+/**
+ * Utility to create a mask given a number of bits
+ */
+#define CLNKDEFS_BITMASK(num_bits)   \
+   ((unsigned)(((num_bits) >= 32) ? 0xFFFFFFFF : ((1 << (num_bits)) - 1)))
+
+/**
+ * Utility to create a shifted mask given a high and low bit position
+ */
+#define CLNKDEFS_SHIFTED_BITMASK(bit_high, bit_low) \
+   ((unsigned)(CLNKDEFS_BITMASK(1 + (bit_high) - (bit_low)) << (bit_low)))
+
+/**
+ * Utility to create a value that alters a particular set of bits
+ * within a processor word
+ */
+#define CLNKDEFS_SUBSTITUTE_FIELD(original, bit_high, bit_low, new_field)                 \
+((unsigned)(                                                                              \
+    ((original)                  & (~CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))) |  \
+     (((new_field) << (bit_low)) &   CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))     \
+)          )
+
+/**
+ * Utility that alters an LVALUE with a substituted field.
+ */
+#define CLNKDEFS_REPLACE_FIELD(lvalue, bit_high, bit_low, new_field)            \
+   do { ((lvalue)) = CLNKDEFS_SUBSTITUTE_FIELD((lvalue), (bit_high),            \
+                                             (bit_low), (new_field));           \
+   } while (0)
+
+/**
+ * Utility to extract a particular field from a word
+ */
+#define CLNKDEFS_EXTRACT_FIELD(original, bit_high, bit_low) \
+     ((unsigned)(((original) & CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low))) >> (bit_low)))
+
+// Firmware download constants
+#if ECFG_CHIP_ZIP1
+#define ISPRAM_START    0xb0040000
+#define DSPRAM_START    0x80000000
+#define ISPRAM_SIZE     0x20000
+#define DSPRAM_SIZE     0x10000
+#elif ECFG_CHIP_ZIP2
+#define ISPRAM_START    0x0c040000
+#define DSPRAM_START    0x0c000000
+#define ISPRAM_SIZE     0x20000
+#define DSPRAM_SIZE     0x18000
+#elif ECFG_CHIP_MAVERICKS
+#define ISPRAM_START    0x0c040000
+#define DSPRAM_START    0x0c000000
+#define ISPRAM_SIZE     0x30000
+#define DSPRAM_SIZE     0x20000
+#endif
+
+/* for hw_z2_pci and clnkEth */
+#define SYS_GET_PARAM(x, p, mask, offset) (((x)->p >> (offset)) & (mask))
+#define SYS_SET_PARAM(x, p, mask, offset, val) do \
+            { \
+                (x)->p = ((x)->p & ~((mask) << (offset))) | \
+                         (((val) & (mask)) << (offset)); \
+            } while(0)
+#define WR_LINEBUF_PDU_SIZE(x, y)   SYS_SET_PARAM((x), packed_0, 0xffff, 0, (y))
+#define WR_LINEBUF_ENTRY_SIZE(x, y) SYS_SET_PARAM((x), packed_0, 0xff, 16, (y))
+#define WR_LINEBUF_PTR_MODE(x, y)   SYS_SET_PARAM((x), packed_0, 0x1, 24, (y))
+/* end for hw_z2_pci and clnkEth */
+
+#define NUM_DEBUG_REG               8
+#define NUM_MAILBOX_RD_REG          8
+#define NUM_MAILBOX_WR_REG          8
+#define NUM_MAILBOX_REG             (NUM_MAILBOX_RD_REG + NUM_MAILBOX_WR_REG)
+
+/// Returns the SoC memory address of element 'x' in dev_shared
+#define DEV_SHARED(x) ((SYS_UINT32)(SYS_UINTPTR)(&(((struct shared_data *)DSPRAM_START)->x)))
+
+struct clnk_hw_params
+{
+    SYS_UINT32              numRxHostDesc;
+    SYS_UINT32              numTxHostDesc;
+#if ECFG_CHIP_ZIP1
+    SYS_UINT32              *minRxLens;
+#endif
+    void                    *at_lock;
+};
+
+typedef struct
+{
+    SYS_UINT32      zip_major;
+    SYS_UINT32      zip_minor;
+    SYS_UINT32      datapath;
+}
+ClnkDef_ZipInfo_t;
+
+//linebuffer descriptor
+struct linebuf
+{
+    SYS_UINT32      packed_0;       /* offset 0x0 */
+    SYS_UINT32      n_entries;      /* offset 0x4 */
+    SYS_UINT32      buffer_base;    /* offset 0x8 */
+    SYS_UINT32      buffer_len;     /* offset 0xc */
+    SYS_UINT32      entry_wptr;     /* offset 0x10 */
+    SYS_UINT32      entry_rptr;     /* offset 0x14 */
+    SYS_UINT32      entry_windex;   /* offset 0x18 */
+    SYS_UINT32      entry_rindex;   /* offset 0x1c */
+    SYS_UINT32      packed_8;       /* offset 0x20 */
+};
+
+#define BRIDGE_ENTRIES      192
+#if ECFG_CHIP_MAVERICKS
+#define CAM_ENTRIES         160
+#else
+#define CAM_ENTRIES         128
+#endif
+#define DATABUF_CAM_ENTRIES 16
+
+typedef struct
+{
+    SYS_UINT32 macAddrHigh;
+    SYS_UINT32 macAddrLow;
+}
+ClnkDef_BridgeEntry_t; 
+
+/* dumps out a portion of the software CAM (ClnkCam.c) */
+typedef struct
+{
+    SYS_UINT32 num_entries;
+    ClnkDef_BridgeEntry_t   ent[BRIDGE_ENTRIES];
+}
+ClnkDef_BridgeTable_t;
+
+#define NUM_TX_PRIO         3
+// clnk_set_eth_fifo_size struct
+typedef struct
+{
+    SYS_UINT32 tx_prio[NUM_TX_PRIO];
+}
+ClnkDef_TxFifoCfg_t;
+
+#if FEATURE_IQM
+// Increase the trace buffer size when DEBUG_DUMP_FFT_VALUES enabled in ccpu code (iqm.h)
+#define CLNK_DEF_TRACE_ENTRIES      /*2505*/ 50
+#else
+#define CLNK_DEF_TRACE_ENTRIES      50
+#endif
+typedef struct
+{
+    SYS_UINT32 ctc_time;
+    SYS_UINT32 info1;
+    SYS_UINT32 info2;
+}
+ClnkDef_TraceEntry_t;
+
+typedef struct
+{
+    SYS_UINT32 dropped;
+    SYS_UINT32 ent_valid;
+    ClnkDef_TraceEntry_t ent;
+}
+ClnkDef_TraceBuf_t;
+
+/*
+ * Frequency Scanning (FS) configuration data
+ */
+typedef struct 
+{
+    SYS_UINT32    scan_mask;
+    SYS_UINT32    prod_mask;
+    SYS_UINT32    chanl_mask;
+    SYS_UINT32    chanl_plan;
+    SYS_UINT32    bias_and_max_passes;
+    SYS_UINT32    cm_ratio;
+    SYS_UINT32    taboo_info;
+    SYS_INT32     lof;
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32    beacon_mask;
+    SYS_UINT32    tl_cycles;		// Only 8 lsbs used
+#endif
+} fs_config_t;
+
+/*
+ * Frequency Scanning status flags
+ */
+typedef struct
+{
+    SYS_UINT8    lof_avail:1;     // LOF available (1:true, 0:false) 
+    SYS_UINT8    lof_scan:1;      // LOF scan status (1:true, 0:false)
+    SYS_UINT8    single_chanl:1;  // Single channel prod mask (1:true, 0:false)
+    SYS_UINT8    listen_once:1;   // Listen only channel (1:true, 0:false)
+    SYS_UINT8    fs_reset:1;      // FS state machine reset (1:true, 0:false)
+    SYS_UINT8    reserved:3;      // Reserved for future usage
+} fs_flags_t;
+
+/*
+ * Frequency Scanning context data
+ */
+typedef union 
+{
+    SYS_UINT32    word[8];
+    struct 
+    {
+        fs_flags_t   flags;         // FS status flags
+        SYS_UINT8    scan_count;    // Number of full scans
+        SYS_INT8     scan_dir;      // Scan direction (+1:lo->hi, -1:hi->lo)
+        SYS_INT8     tune_idx;      // Tuned freq index
+        SYS_INT8     last_idx;      // Last freq index
+        SYS_INT8     low_idx;       // lowest freq index for scan in single dir
+        SYS_INT8     high_idx;      // highest freq index for scan in single dir
+        SYS_INT8     lof_idx;       // LOF index
+        SYS_UINT8    fs_state;      // Current FS state
+        SYS_UINT8    upd_cause;     // FS state update cause
+        SYS_UINT16   hop_count;     // Running count of frequency hops
+        SYS_UINT32   chanl_qual[2]; // Channel quality array
+    } members;
+} fs_context_t;
+
+/** Structure for storing cached pqos maintenace values in shared
+ *  data. */
+typedef struct {
+    SYS_UINT32 ioc_nodemask;
+    SYS_UINT32 allocated_stps;
+    /** Top 16 bits store the allocated txps received (but thresholded
+     *  in the error event that the value exceeded 16 bits) and the 
+     *  bottom 16 bits store the count of maintenance events since
+     *  joining the network. */
+    SYS_UINT32 trunc_alloc_txps_hi__ctr_lo;
+} shared_qos_maint_cache_t;
+
+#if FEATURE_PUPQ_NMS_CONF
+// pqos NMS initialization structure.
+typedef struct
+{
+    /** This member contains the vendor id 16 bit value in the high
+     * 16 bits and the personality in the low 16 bits. Saves CCPU space. */
+    SYS_UINT32 mfrVendorIdHi_personalityLo;
+    SYS_UINT32 mfrHwVer;
+    SYS_UINT32 mfrSwVer;
+} pupq_nms_init_context_t;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+// per-node based statistics
+typedef struct
+{
+    /** Number of received MoCA transmissions from this node which were
+     *  NOT correctly received or processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_error;
+
+    /** Number of received MoCA transmissions from this node which were
+     *  correctly received and processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_good;
+}                           clnkdefs_per_node_stats_t;
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_per_node_stats_t, 8);
+
+typedef struct
+{
+    clnkdefs_per_node_stats_t nodes[MAX_NUM_NODES];
+}                           clnkdefs_all_node_stats_t;
+#if MAX_NUM_NODES == 16
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 128);
+#else
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 64);
+#endif
+#endif /* FEATURE_PUPQ_RX_NODE_STATS */
+#if 1 // added for MID RF (DEBUG_EPP)
+typedef struct
+{
+    SYS_UINT32 nodeId;
+    SYS_UINT32 flags;
+}
+ClnkDef_EppCapCfg_t;
+
+// Echo Profile Structures
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 nodeId;
+    SYS_UINT32 probeId;
+    SYS_UINT32 cpLen;
+    SYS_UINT32 sysBias;
+    SYS_UINT32 status;
+    SYS_UINT32 rawData[(256 + 3*(256+64))];    /* 0x4c0 words = 4864 bytes */
+    SYS_UINT8  corrData[256];
+    SYS_UINT8  corrEnergy[256];
+}
+ClnkDef_EppData_t;
+
+typedef struct
+{   // OBSOLETE
+    SYS_UINT32 NodeId;
+    SYS_UINT8  cpLen;
+    SYS_UINT8  systemBias;
+    SYS_UINT8  ftmgThresh;
+    SYS_UINT32 ftmgThresh2;
+    SYS_UINT8  ftmgBias;
+}
+ClnkDef_EppResult_t;
+#endif
+
+// shared data between the host and SoC (Zip2 only)
+struct shared_data
+{
+#if !ECFG_CHIP_ZIP1
+    SYS_UINT32      mailbox_reg[NUM_MAILBOX_REG];
+    SYS_UINT32      debug_reg[NUM_DEBUG_REG];
+    SYS_UINT32      read_csr_reg;
+    SYS_UINT32      write_csr_reg;
+
+    SYS_UINT32      linebuf_host_rx;
+    SYS_UINT32      linebuf_host_tx[4]; /* 4 priorities */
+
+    SYS_UINT32      mac_addr_hi;
+    SYS_UINT32      mac_addr_lo;
+
+    SYS_UINT32      rx_active;
+#endif /* !ECFG_CHIP_ZIP1 */
+
+    SYS_UINT32      trace_dropped;
+
+    fs_config_t     fs_cfg;                // Frequency Scan config parameters
+    fs_context_t    fs_ctx;                // Frequency Scan context data
+
+    SYS_UINT32  dbgMask;     
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32      defaultSeqNum;             // Used for MoCA RESET
+#endif
+#if 1 // added for MID RF (DEBUG_EPP)
+    SYS_UINT32      eppCapSrcId;
+    SYS_UINT32      eppCapFlags;
+#endif
+    SYS_UINT32      target_phy_rate;
+    SYS_UINT32      node_adm_req_rx_ctr;
+    SYS_UINT32      node_link_up_event_ctr;
+    SYS_UINT32      lmo_advanced_ctr;
+    SYS_UINT32      ingr_routing_conflict_ctr;
+    /** This counter counts in tenths of a second. */
+    SYS_UINT32      node_link_time_bad_deciseconds;
+#if FEATURE_INGRESS_MARGIN 
+    SYS_UINT32      ingress_cfg[65/*MAX_rxLevel*//4 + 1];	 
+#endif 
+
+#if FEATURE_SPECTRAL_SCULPTING
+    SYS_UINT32      ss_thr;                // Spectral Sculpting threshold
+    SYS_UINT32      ss_table[64];          // Spectral Sculpting margin adjustments
+#endif
+
+#if L2_DONGLE
+    SYS_UINT32      version_id; 
+#endif  
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+    /** ONLY MODIFIED BY CCPU.  Kept here as a convenience since
+     *  the host may want to do a fast read of these statistics without
+     *  mailbox op.  */
+    clnkdefs_all_node_stats_t  all_node_stats;
+#endif
+
+#if FEATURE_PUPQ_NMS_CONF
+    pupq_nms_init_context_t  pni_ctx;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_NMS_QUICK_APIS
+    SYS_UINT32      pqos_mode;
+    SYS_UINT32      hard_reset;
+    /* added shared_data entries 
+     *   vinirn is (UINT16 vendor_id << 16) | (UINT8 node_id << 8) | UINT8 request_number
+     */
+    SYS_UINT32      vinirn;    // vendor id, node id, request number
+
+    /* eventually fit this in a byte somewhere else in shared_data 
+     * Both nmspush_change_ctr and nmspush_change_ack are 
+     * each only 8 bits 
+     */
+    SYS_UINT32      nmspush_change_ctr;
+    SYS_UINT32      nmspush_change_ack;
+    SYS_UINT32      dword_array[6];
+#endif
+
+#if FEATURE_IQM
+    SYS_UINT32      iqm_debug_mask1;
+    SYS_UINT32      iqm_debug_mask2;
+    SYS_UINT32      iqm_debug_mask3;
+#endif
+
+    ClnkDef_TraceEntry_t trace_buf[CLNK_DEF_TRACE_ENTRIES];
+
+    shared_qos_maint_cache_t  qos_maint_cache;
+};
+
+#define FEATURE_ECLAIR                     1
+
+#if (NETWORK_TYPE_ACCESS)
+    #define FEATURE_FREQ_SCAN              0      // 0: disable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    0
+    #define FEATURE_QOS                    0
+    #define ENTROPIC_ECLAIR                0
+    #define BROADCAST_LMO                  0
+#else
+    #define FEATURE_FREQ_SCAN              1      // 1: enable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    1
+    #define FEATURE_QOS                    1
+    #define ENTROPIC_ECLAIR                1
+    #define BROADCAST_LMO                  1
+
+    /** Expect this flag to be set from the build file *.bld */
+    #ifndef FEATURE_ECLAIR_WHITE_BOX_TEST
+        #define FEATURE_ECLAIR_WHITE_BOX_TEST  0
+    #endif
+
+#endif
+
+// C.Link Ethernet Statistics Structureyy
+typedef struct
+{
+    // Driver stats
+    SYS_UINT32 drvSwRevNum;
+    SYS_UINT32 embSwRevNum;
+    SYS_UINT32 upTime;
+    SYS_UINT32 linkUpTime;
+    SYS_UINT32 socResetCount;       // Number of C.Link resets
+    SYS_UINT32 socResetHistory;     // Reason for last 4 resets
+
+    // Transmit and recieve stats
+    SYS_UINT32 rxPackets;           // Total packets received
+    SYS_UINT32 txPackets;           // Total packets transmitted
+    SYS_UINT32 rxBytes;             // Total bytes received
+    SYS_UINT32 txBytes;             // Total bytes transmitted
+    SYS_UINT32 rxPacketsGood;       // Packet receive with no errors
+    SYS_UINT32 txPacketsGood;       // Packet transmitted with no errors
+    SYS_UINT32 rxPacketErrs;        // Packets received with errors
+    SYS_UINT32 txPacketErrs;        // Packets transmitted with errors
+    SYS_UINT32 rxDroppedErrs;       // Packets dropped with no host buffers
+    SYS_UINT32 txDroppedErrs;       // Packet dropped with no host buffers
+    SYS_UINT32 rxMulticastPackets;  // Total multicast packets received
+    SYS_UINT32 txMulticastPackets;  // Total multicast packets transmitted
+    SYS_UINT32 rxMulticastBytes;    // Total multicast bytes received
+    SYS_UINT32 txMulticastBytes;    // Total multicast bytes transmitted
+
+    // Detailed receive errors
+    SYS_UINT32 rxLengthErrs;
+    SYS_UINT32 rxCrc32Errs;         // Packets rx'd with CRC-32 errors
+    SYS_UINT32 rxFrameHeaderErrs;   // Packets rx'd with frame header errors
+    SYS_UINT32 rxFifoFullErrs;      // Packets rx'd with FIFO full
+    SYS_UINT32 rxListHaltErr[3];
+
+    // Detailed transmit errors
+    SYS_UINT32 txCrc32Errs;         // Packets tx'd with CRC-32 errors
+    SYS_UINT32 txFrameHeaderErrs;   // Packets tx'd with frame header errors
+    SYS_UINT32 txFifoFullErrs;      // Packets tx'd with FIFO full
+    SYS_UINT32 txFifoHaltErr[8];
+}
+ClnkDef_EthStats_t;
+
+// EVM Data Structure
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[256];
+}
+ClnkDef_EvmData_t;
+#if 0 // modified for MID RF (DEBUG_EPP)
+// Echo Profile Structures
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[(256 + 3*(256+64))];    /* 0x4c0 words = 4864 bytes */
+}
+ClnkDef_EppData_t;      
+#endif
+
+//values returned to the host in the initial mailbox
+struct mb_return
+{
+    SYS_UINT32 linebuf0_soc_tx;         /* word 0 */
+    SYS_UINT32 linebuf1_soc_tx;         /* word 1 */
+    SYS_UINT32 linebuf2_soc_tx;         /* word 2 */
+    SYS_UINT32 extra_pkt_mem;           /* word 3 */
+    SYS_UINT32 linebuf3_soc_tx;         /* word 4 */
+    SYS_UINT32 linebuf_soc_rx;          /* word 5 */
+    SYS_UINT32 tx_did;                  /* word 6 */
+    SYS_UINT32 rx_did;                  /* word 7 */
+    SYS_UINT32 tx_gphy_desc;            /* word 8 */
+    SYS_UINT32 rx_gphy_desc;            /* word 9 */
+    SYS_UINT32 pd_queue_0;              /* word 10 */
+    SYS_UINT32 pd_queue_1;              /* word 11 */
+    SYS_UINT32 pd_queue_2;              /* word 12 */
+    SYS_UINT32 pd_queue_3;              /* word 13 */
+    SYS_UINT32 pd_entries;              /* word 14 */
+    SYS_UINT32 unsol_msgbuf;            /* word 15 - also the semaphore */
+};
+////////// END defines needed by ClnkEth.h
+
+////////// defines for ClnkCam
+
+#define    CLNKMAC_BCAST_ADDR      0x3F
+#define    QOS_MAX_FLOWS           24
+
+/* Enums for PQOS Classification mode */
+enum {
+    CLNK_PQOS_MODE_UNKNOWN       = -1,
+    CLNK_PQOS_MODE_MOCA_11       = 0,
+    CLNK_PQOS_MODE_PUPQ_CLASSIFY = 1,
+};
+typedef SYS_UINT32 clnk_pqos_mode_t;
+
+////////// end defines for ClnkCam
+
+////////// defines for eth_ioctl
+
+// Software Configuration Bits
+#define CLNK_DEF_SW_CONFIG_SOFTCAM_BIT                 (1 << 14)
+#define CLNK_DEF_SW_CONFIG_AGGREGATION_METHOD_BIT      (1 << 24)  // used in hw_z2_pci.c
+                                                                   
+// SOC Status Values
+typedef enum
+{
+    CLNK_DEF_SOC_STATUS_SUCCESS           = 0,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_TIMEOUT  = 1,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE  = 2,
+    CLNK_DEF_SOC_STATUS_LINK_CTRL_RESTART = 3,
+    CLNK_DEF_SOC_STATUS_LINK_DOWN_FAILURE = 4,
+    CLNK_DEF_SOC_STATUS_TX_HALTED_FAILURE = 5,
+    CLNK_DEF_SOC_STATUS_RX_HALTED_FAILURE = 6,
+    CLNK_DEF_SOC_STATUS_FORCED_RESET      = 7,
+
+    CLNK_DEF_SOC_STATUS_MAX  // This must always be last
+}
+CLNK_DEF_SOC_STATUS_VALUES;
+
+// a subset Embedded failure reasons
+typedef enum                                    // Hex
+{
+#if (FEATURE_FREQ_SCAN)
+    CLNK_DEF_FREQ_RESET_BAD_CRC       = 23,     // 17
+    CLNK_DEF_FREQ_RESET_FTM_EXPIRE    = 24,     // 18
+    CLNK_DEF_FREQ_RESET_CHNL_MISMATCH = 25,     // 19
+    CLNK_DEF_FREQ_ADM_FAILURE         = 26,     // 1A
+    CLNK_DEF_FREQ_PREAMBLE_MISS       = 27,     // 1B
+    CLNK_DEF_FREQ_SCAN_TABOO_ONLY     = 28,     // 1C
+#endif /* FEATURE_FREQ_SCAN */
+    CLNK_DEF_ACCESS_DENY              = 29,     // 1D
+    CLNK_DEF_LINK_CTRL_RESTART_MAX  // This must always be last
+
+}
+CLNK_DEF_LINK_CTRL_RESTART_EVENTS;
+
+//variables to be used by driver
+typedef struct
+{
+    SYS_UINT32 swConfig;     // data plane variables for PCI driver
+    SYS_UINT32 unsol_msgbuf; // for mailbox init
+    SYS_UINT32 pqosClassifyMode;
+    SYS_UINT32 pSwUnsolQueue;
+    SYS_UINT32 swUnsolQueueSize;
+}
+ClnkDef_dataPlaneVars_t;
+
+// C.Link Node Statistics Structure
+typedef struct
+{
+    SYS_UINT32 NumOfMapTx;
+    SYS_UINT32 NumOfRsrvTx;
+    SYS_UINT32 NumOfLCTx;
+    SYS_UINT32 NumOfAdmTx;
+    SYS_UINT32 NumOfProbeTx;
+    SYS_UINT32 NumOfAsyncTx;
+
+    SYS_UINT32 NumOfMapTxErr;
+    SYS_UINT32 NumOfRsrvTxErr;
+    SYS_UINT32 NumOfLCTxErr;
+    SYS_UINT32 NumOfAdmTxErr;
+    SYS_UINT32 NumOfProbeTxErr;
+    SYS_UINT32 NumOfAsyncTxErr;
+
+    SYS_UINT32 NumOfMapRx;
+    SYS_UINT32 NumOfRsrvRx;
+    SYS_UINT32 NumOfLCRx;
+    SYS_UINT32 NumOfAdmRx;
+    SYS_UINT32 NumOfProbeRx;
+    SYS_UINT32 NumOfAsyncRx;
+
+    SYS_UINT32 NumOfMapRxErr;
+    SYS_UINT32 NumOfRsrvRxErr;
+    SYS_UINT32 NumOfLCRxErr;
+    SYS_UINT32 NumOfAdmRxErr;
+    SYS_UINT32 NumOfProbeRxErr;
+    SYS_UINT32 NumOfAsyncRxErr;
+
+    SYS_UINT32 NumOfMapRxDropped;
+    SYS_UINT32 NumOfRsrvRxDropped;
+    SYS_UINT32 NumOfLCRxDropped;
+    SYS_UINT32 NumOfAdmRxDropped;
+    SYS_UINT32 NumOfProbeRxDropped;
+    SYS_UINT32 NumOfAsyncRxDropped;
+
+    SYS_UINT32 NumOfBadIsocTx;
+    SYS_UINT32 NumOfCtlDescrFailed;
+    SYS_UINT32 NumOfUpdateDescrFailed;
+    SYS_UINT32 NumOfStatDescrFailed;
+    SYS_UINT32 NumOfBufferAllocFailed;
+    SYS_UINT32 NumOfRSCorrectedBytes;
+    SYS_UINT32 Events;
+    SYS_UINT32 Interrupts;
+
+    SYS_UINT32 InternalWarnings;
+    SYS_UINT32 InternalErrors;
+
+    SYS_UINT32 qosRcvdSubmits;
+    SYS_UINT32 qosRcvdRequests;
+    SYS_UINT32 qosRcvdResponses;
+    SYS_UINT32 qosAcceptedSubmits;
+    SYS_UINT32 qosDroppedSubmits;
+    SYS_UINT32 qosIssuedWaves;
+    SYS_UINT32 qosSkippedWaves;
+    SYS_UINT32 qosSuccessWaves;
+    SYS_UINT32 qosFailedWaves;
+
+    SYS_UINT32 qosIssuedTxns;
+    SYS_UINT32 qosSuccessTxns;
+    SYS_UINT32 qosEarlyTerminatedTxns;
+    SYS_UINT32 qosEntryCancelledTxns;
+    SYS_UINT32 qosTxnErrors;
+    SYS_UINT32 qosPerformedEntryCancels;
+    SYS_UINT32 qosRcvdTxnErrors;
+
+    SYS_UINT32 qosTotalEgressBurst;
+    SYS_UINT32 qosMaxEgressBurst;
+}
+ClnkDef_Stats_t;
+
+// C.Link My Node Info Structure
+typedef struct
+{
+    SYS_UINT32      ClearStats;
+    SYS_UINT32      SwRevNum;
+    SYS_UINT32      EmbSwRevNum;
+    SYS_UINT32      LinkStatus;
+    SYS_UINT32      TxChannelBitMask;
+    SYS_UINT32      RxChannelBitMask;
+    SYS_UINT32      IsCyclemaster;
+    SYS_UINT32      RFChanFreq;
+    SYS_UINT32      CurrNetworkState;
+    SYS_UINT32      NetworkType;
+    SYS_UINT32      NodeId;
+    SYS_UINT32      CMNodeId;
+    SYS_UINT32      BestCMNodeId;
+    SYS_UINT32      BackupCMNodeId;
+    SYS_UINT32      NetworkNodeBitMask;
+    SYS_UINT32      TxIsocChanInfo;
+    SYS_UINT32      RxIsocChanInfo;
+    SYS_UINT32      PrivacyStat;
+    SYS_UINT32      MocaField;
+    SYS_UINT32      TxIQImbalance;
+    SYS_UINT32      RxIQImbalance;
+    SYS_UINT32      RxIQImbalance2;
+    ClnkDef_Stats_t Stats;
+    SYS_UINT32      TabooChanMask;
+    SYS_UINT32      TabooMaskStart;
+}
+ClnkDef_MyNodeInfo_t;
+// end defines for eth_ioctl
+// **********************************************
+// END Inserting all ClnkDefs.h neeeded by driver 
+
+/**********    Common to ClnkCAM and ClnkETH   ***************/
+#if (NETWORK_TYPE_ACCESS)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      (2)
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL)     /* HW Queues */
+    #define MAX_TX_PRIORITY           (32*CLNK_ETH_VLAN_ACTUAL)  /* SW Queues */
+    #define TX_ADVERTIZE_SIZE         (162)                      //- (200)
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE+8) * 32)
+    #define MAP_PRIO_TO_FIFO(PRIO)    ((PRIO) >> 5)
+    #define TMR_2_JIFFIES             (2456)
+
+#else
+
+  #define  CLNK_VLAN_MODE_HWVLAN   1  /* Nominal: 3 SW Q ---> 3 HW Q */
+  #define  CLNK_VLAN_MODE_SWVLAN   0  /* Alternate: 3 SW Q ---> 1 HW Q */
+
+  #if (CLNK_VLAN_MODE_HWVLAN)
+
+    #define CLNK_ETH_VLAN_ACTUAL      3 /* Nominal 3 but any value up to 8 */
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* HW Qs*/
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs*/
+    #define TX_ADVERTIZE_SIZE         256
+#if ECFG_CHIP_ZIP1
+    #define TX_MAPPING_SIZE           400
+    #define CAM_TMR_JIFFIES           TMR_2_JIFFIES
+#else
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE + 1) * MAX_TX_PRIORITY)
+    #define CAM_TMR_JIFFIES           100               /* 100 clocks/sec = 10ms period */
+#endif
+    #define MAP_PRIO_TO_FIFO(PRIO)    (PRIO)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (3333)
+   #endif
+
+  #elif (CLNK_VLAN_MODE_SWVLAN)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      8
+    #define MAX_TX_FIFOS              1                                   /* HW Qs */
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs */
+    #define TX_ADVERTIZE_SIZE         128
+    #define TX_MAPPING_SIZE           (TX_ADVERTIZE_SIZE * MAX_TX_PRIORITY)
+    #define MAP_PRIO_TO_FIFO(PRIO)    (0)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (2468)
+   #endif
+
+  #endif
+
+#endif
+
+#if 0
+#if NETWORK_TYPE_MIDRF_MESH
+#define CLNK_ETH_ECHO_PROFILE  1 // for collecting data during field trials 
+                                 // should be turned off eventually
+#endif
+#endif
+/************* End definitions originally from ClnkDefs.h ********************/
+
+
+/************************** original common.h defines ************************/
+// Number of VLANs
+#define CLNK_ETH_VLAN_8021Q 8      // Number Logical 802.1Q VLAN Queues
+//#define CLNK_ETH_VLAN_ACTUAL xx  // See ClnkEth.h
+#define MAX_POSSIBLE_FIFOS    8
+
+/* Firmware image struct
+ *
+ * fw.pFirmware can point to one of three things:
+ *
+ * 1) the builtin firmware
+ * 2) a user-supplied firmware image
+ * 3) NULL (don't download firmware)
+ *
+ * All fields are native-endian.
+ */
+struct fw_img
+{
+    SYS_UINT32  *fw_text;       // instruction memory image
+    SYS_UINT32  fw_text_size;   // image size
+    SYS_UINT32  *fw_data;       // initialized data memory image
+    SYS_UINT32  fw_data_size;   // image size
+    SYS_UINT32  version;        // firmware version
+    SYS_UINT8   builtin;        // 1=built in to the driver, 0 if user-supplied
+    SYS_UINT8   native;         // 1=native endianness, 0=SoC (BE) endianness
+};
+
+// Firmware Structure
+typedef struct
+{
+    const struct fw_img *pFirmware; // Pointer to firmware info struct
+    SYS_UINT32  DistanceMode;
+    SYS_UINT32  privacyKey[4];  // MMK and PMKi
+    SYS_UINT32  cmRatio;        // Cycle master ratio (0% to 100%)
+    SYS_UINT32  txPower;        // Transmit power
+    SYS_UINT32  phyMargin;      // Phy margin settings
+    SYS_UINT32  phyBitMask;     // Phy #bits
+    SYS_UINT32  swConfig;       // Software configuration
+#if defined(L3_DONGLE_HIRF)
+    SYS_UINT32  Diplexer_;	// Diplxere Mode
+#endif    
+    SYS_UINT32  beaconPwrLevel; // Beacon power level setting. 
+    SYS_UINT32* pRFIC_Tuning_Data; // pointer to RFIC tuning data channel table for all channels
+    SYS_UINT32* pAGC_Gain_Table;// pointer to AGC gain table
+    SYS_UINT32  macAddrHigh;    // C.Link MAC address high (bytes 0-3)
+    SYS_UINT32  macAddrLow;     // C.Link MAC address low (bytes 4-5)
+    SYS_UINT8   txFifoLut[CLNK_ETH_VLAN_8021Q]; // Priority Mapping
+#if ECFG_CHIP_ZIP1
+    SYS_UINT16  txFifoPct[MAX_POSSIBLE_FIFOS]; // Tx fifo size (initial, backup)
+    SYS_UINT16  txFifoSize[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/o flows)
+#if FEATURE_QOS
+    SYS_UINT16  txFifoSizeQos[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/ flows)
+#endif /* FEATURE_QOS */
+    SYS_UINT16  txFifoChunks[MAX_POSSIBLE_FIFOS]; // Tx fifo size (runtime,  in chunks)
+    SYS_UINT32  rxFifoSize;      // Rx fifo size
+#endif /* ECFG_CHIP_ZIP1 */
+    SYS_UINT32  channelMask;     // Tunable RF Channel Mask
+    SYS_UINT32  productMask;     // Product Mask
+    SYS_UINT32  scanMask;        // Scan mask
+    SYS_UINT32  lof;             // LOF
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32  beaconMask;	 // Beacon Mask, only on which channel beacons can be transmitted
+    SYS_UINT32  TLCycles;	 // Time limitation cycles. Programmable time limitation in 
+    				 // listening-only mode of network search process
+#endif
+    SYS_UINT32  bias;            // Bias
+    SYS_UINT32  channelPlan;     // Channel Plan
+    SYS_UINT32  tabooInfo;       // Taboo mask + taboo offset
+    SYS_UINT32  PowerCtlPhyRate; // Power control PHY rate
+    SYS_UINT32  MiiPausePriLvl;  // MII Pause Priority Level
+    SYS_UINT32  PQoSClassifyMode;// PQoS Classification Mode
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32  mfrVendorId;     // Manufacturer Vendor Id (See MoCA 1.1) [we only use 16 lsbs]
+    SYS_UINT32  mfrHwVer;        // Manufacturer Hardware Version (vendor specific)
+    SYS_UINT32  mfrSwVer;        // Manufacturer Software Version (vendor specific)
+    SYS_UINT32  personality;     // Manufacturer node personality
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+    SYS_UINT32  dbgMask;     
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32      defaultSeqNum;             // Used for MoCA RESET
+#endif
+#if FEATURE_IQM
+    SYS_UINT32      iqmDebugMask1;
+    SYS_UINT32      iqmDebugMask2;
+    SYS_UINT32      iqmDebugMask3;
+#endif
+
+}
+Clnk_ETH_Firmware_t;
+
+// List Entry Structure
+// This defines the structure for an entry in the linked list.
+typedef struct ListEntry_t
+{
+    struct ListEntry_t* pNext;
+    struct ListEntry_t* pPrev;
+}
+ListEntry_t;
+
+// List Header Structure
+// This defines the header structure for the linked list.
+typedef struct ListHeader_t
+{
+    ListEntry_t* pHead;
+    ListEntry_t* pTail;
+    SYS_UINT32   numElements;
+}
+ListHeader_t;
+
+
+// { StaticUsageCount: AH=4 AT=12 RH=15 RT=2 RN=2 MH=1 }
+#define COMMON_LIST_INIT(list)      (list)->pHead = SYS_NULL; \
+                             (list)->pTail = SYS_NULL;        \
+                             (list)->numElements = 0
+#define COMMON_LIST_SIZE(list)      ((list)->numElements)
+#define COMMON_LIST_EMPTY(list)     ((list)->pHead == SYS_NULL)
+#define COMMON_LIST_HEAD(T,L)       ((T *) ((L)->pHead))
+#define COMMON_LIST_TAIL(T,L)       ((T *) ((L)->pTail))
+#define COMMON_LIST_NEXT(T,E)       ((T *) (((ListEntry_t *) (E))->pNext))
+#define COMMON_LIST_PREV(T,E)       ((T *) (((ListEntry_t *) (E))->pPrev))
+#define COMMON_LIST_ADD_HEAD(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = (list)->pHead;  \
+            ((ListEntry_t *)(entry))->pPrev = SYS_NULL;       \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pNext->pPrev =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pTail = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pHead = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_ADD_TAIL(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = SYS_NULL;       \
+            ((ListEntry_t *)(entry))->pPrev = (list)->pTail;  \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pPrev->pNext =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pHead = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pTail = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_REM_HEAD(list)                            \
+            (list)->pHead;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_REM_TAIL(list)                            \
+            (list)->pTail;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_MOVE_TO_HEAD(list,entry)                  \
+            if (!COMMON_LIST_EMPTY(list) &&                   \
+                ((ListEntry_t*)(entry) != (list)->pHead))     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t *)(entry);  \
+                ListEntry_t *pNext = pCurr->pNext;            \
+                ListEntry_t *pPrev = pCurr->pPrev;            \
+                /* Remove Node */                             \
+                if (pNext) {                                  \
+                    pNext->pPrev = pPrev;                     \
+                } else {                                      \
+                    (list)->pTail = pPrev;                    \
+                }                                             \
+                pPrev->pNext = pNext;                         \
+                /* Add to Head */                             \
+                pNext = (list)->pHead;                        \
+                pCurr->pNext = pNext;                         \
+                pNext->pPrev = pCurr;                         \
+                (list)->pHead = pCurr;                        \
+            }
+#define COMMON_LIST_REM_NODE(list,entry)                      \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t*)entry;     \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else if ((list)->pHead == pCurr)              \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                else if ((list)->pTail == pCurr)              \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                else                                          \
+                {                                             \
+                    ListEntry_t *tPrev,*tNext;                \
+                    tPrev = pCurr->pPrev;                     \
+                    tNext = pCurr->pNext;                     \
+                    tNext->pPrev = pCurr->pPrev;              \
+                    tPrev->pNext = pCurr->pNext;              \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+
+/* end *************** original common.h defines ************************/
+
+/******************* ClnkEth_Vlan.h definitions *************************/
+// used in hw_z2_pci.c
+#define CLNK_ETH_GET_DST_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[3]))
+
+#define CLNK_ETH_GET_DST_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_SRC_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[3]))
+
+#define CLNK_ETH_GET_SRC_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_VLAN_PRIORITY_FROM_BUF(buf)                      \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81) ?     \
+             (((Clnk_ETH_EthHdr_t *)(buf))->tagCtrlInfo[0] >> 5) : 0)
+
+#define IS_CLNK_ETH_PKT_TAGGED(buf)                                   \
+	    ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81)  &&   \
+             (((Clnk_ETH_EthHdr_t *)(buf))->lenType[1] == 0x00)  ?    \
+              SYS_TRUE : SYS_FALSE)
+
+/// Ethernet Header
+typedef struct
+{
+    SYS_UINT8  dstMacAddr[6];
+    SYS_UINT8  srcMacAddr[6];
+    SYS_UINT8  lenType[2];
+    SYS_UINT8  tagCtrlInfo[2];
+}
+Clnk_ETH_EthHdr_t;
+/* end ********* ClnkEth_Vlan.h definitions *****************/
+
+/************ clnkdvrapi.h definitions **********************/
+// driver/API structure definitions
+#define DRV_CLNK_CTL             55
+typedef struct
+{
+    SYS_UINT32 cmd;
+    void*      param1;
+    void*      param2;
+    void*      param3;
+}
+IfrDataStruct;
+
+struct clnk_soc_opt
+{
+    /* copied from conf file */
+    SYS_UINT32      CMRatio;
+    SYS_UINT32      DistanceMode;
+    SYS_UINT32      TxPower;
+    SYS_UINT32      phyMargin;
+    SYS_UINT32      phyMBitMask;
+    SYS_UINT32      SwConfig;
+#if defined(L3_DONGLE_HIRF)
+    SYS_UINT32	    Diplexer;
+#endif        
+    SYS_UINT32      channelPlan;
+    SYS_UINT32      scanMask;
+    SYS_UINT32      productMask;
+    SYS_UINT32      tabooMask;
+    SYS_UINT32      tabooOffset;
+    SYS_UINT32      channelMask;
+    SYS_UINT32      lof;
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32      beaconMask;
+    SYS_UINT32      TLCycles;		// Only 8 lsbs used
+#endif
+    SYS_UINT32      bias;
+    SYS_UINT32      PowerCtlPhyRate;
+    SYS_UINT32      BeaconPwrLevel;
+    SYS_UINT32      MiiPausePriLvl;
+    SYS_UINT32      PQoSClassifyMode;  /* PQoS Classification Mode */
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32      mfrVendorId;        /* we only use 16 lsbs */
+    SYS_UINT32      mfrHwVer;
+    SYS_UINT32      mfrSwVer;
+    SYS_UINT32      personality;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+    SYS_UINT32      dbgMask;
+#if NETWORK_TYPE_MIDRF_MESH
+    SYS_UINT32      defaultSeqNum;             // Used for MoCA RESET
+#endif
+
+    /* derived from conf file */
+    SYS_UINT32      pmki_lo;
+    SYS_UINT32      pmki_hi;
+    SYS_UINT32      mmk_lo;
+    SYS_UINT32      mmk_hi;
+};
+
+/* end *********** clnkdvrapi.h definitions **********************/
+
+/*************** ClnkCtl.h definitions **********************/
+
+// ClnkEth.c dependecies below
+#define MIN_VAL(x, y) (((x) > (y)) ? (y) : (x))
+
+// eth.c dependecies below
+struct clnk_io
+{
+    SYS_UINT32      *in;
+    SYS_UINT32      in_len;
+    SYS_UINT32      *out;
+    SYS_UINT32      out_len;
+};
+typedef enum
+{
+    DATA_BUF_MY_NODE_INFO_CMD_TYPE      = 0,
+    DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE = 1,
+    DATA_BUF_NODE_PHY_DATA_CMD_TYPE     = 2,
+    DATA_BUF_TEST_PORT_CMD_TYPE         = 3,
+    DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE  = 4,
+    DATA_BUF_RX_ERR_DATA_CMD_TYPE       = 5,
+    DATA_BUF_PRIV_INFO                  = 6,
+    DATA_BUF_PRIV_STATS                 = 7,
+    DATA_BUF_PRIV_NODE_INFO             = 8,
+    DATA_BUF_DUMP_CAM                   = 9,
+    DATA_BUF_GET_MIXED_MODE_ACTIVE      = 10, // obsolete
+    DATA_BUF_SET_MIXED_MODE_ACTIVE      = 11, // obsolete
+    DATA_BUF_GET_PEER_RATES             = 12,
+    DATA_BUF_GET_DYN_PARAMS             = 13,
+    DATA_BUF_SET_DYN_PARAMS             = 14,
+    DATA_BUF_GET_AGGR_STATS             = 15,
+    DATA_BUF_SEND_GCAP                  = 16,
+    DATA_BUF_obsolete                   = 17, 
+    DATA_BUF_GET_EPHY_STATS             = 18,
+
+#if FEATURE_QOS
+    DATA_BUF_CREATE_FLOW                = 19,
+    DATA_BUF_UPDATE_FLOW                = 20,
+    DATA_BUF_DELETE_FLOW                = 21,
+    DATA_BUF_QUERY_INGRESS_FLOW         = 22,
+    DATA_BUF_LIST_INGRESS_FLOWS         = 23,
+    DATA_BUF_QUERY_NODES                = 24,
+    DATA_BUF_QUERY_INTERFACE_CAPS       = 26,
+    DATA_BUF_GET_EVENT_COUNTS           = 27,
+#endif
+
+#if FEATURE_ECLAIR
+    DATA_BUF_ECLAIR_GET_HINFO          ,
+    DATA_BUF_ECLAIR_SET_TWEAKABLE      ,
+    DATA_BUF_ECLAIR_RESET_TEST_CONTEXT ,
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+    DATA_BUF_ECLAIR_PUSH_COMMAND       ,
+    DATA_BUF_ECLAIR_GET_COMMAND        ,
+    DATA_BUF_ECLAIR_SET_RECEIPT        ,
+    DATA_BUF_ECLAIR_PULL_RECEIPT       ,
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+
+#if FEATURE_ECLAIR_WHITE_BOX_TEST
+    DATA_BUF_ECLAIR_MORPH_CFG          ,
+    DATA_BUF_ECLAIR_MORPH_EXEC         ,
+    DATA_BUF_ECLAIR_MULTINODE_QUERY    ,
+    DATA_BUF_ECLAIR_MULTINODE_COMMIT   ,
+#endif
+
+#if ECFG_FLAVOR_VALIDATION==1
+    DATA_BUF_VAL_GET_MBOX_HOST_COUNTS  , 
+    DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS  , 
+    DATA_BUF_VAL_TRIGGER_MBOX_EVENT    ,   
+#endif
+
+#endif
+
+    MAX_DATA_BUF_TYPE // This must always be last
+} DATA_BUF_CMD_TYPE;
+
+#define CLNK_CTL_VERSION                    0x01
+
+#define CLNK_CTL_MAX_IN_LEN                 0x2000
+#define CLNK_CTL_MAX_OUT_LEN                0x2000
+
+#define CLNK_CTL_SOC_CMD                    0x00000000
+#define CLNK_CTL_ETH_CMD                    0x00000100
+#define CLNK_CTL_DRV_CMD                    0x00000200
+
+#define CLNK_CMD_DST_MASK                   0x00000f00
+
+#define CLNK_CMD_BYTE_MASK                 (0x000000ff)
+
+#define CLNK_CTL_FOR_DRV(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_DRV_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_SOC(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_SOC_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_ETH(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_ETH_CMD) ? 1 : 0)
+
+#define CLNK_CTL_GET_MY_NODE_INFO           (CLNK_CTL_SOC_CMD | DATA_BUF_MY_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_NET_NODE_INFO          (CLNK_CTL_SOC_CMD | DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_PHY_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_NODE_PHY_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RFIC_TUNING_DATA       (CLNK_CTL_SOC_CMD | DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RX_ERR_DATA            (CLNK_CTL_SOC_CMD | DATA_BUF_RX_ERR_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_PRIV_INFO              (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_INFO)
+#define CLNK_CTL_GET_PRIV_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_STATS)
+#define CLNK_CTL_GET_PRIV_NODE_INFO         (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_NODE_INFO)
+#define CLNK_CTL_GET_CAM                    (CLNK_CTL_SOC_CMD | DATA_BUF_DUMP_CAM)
+#define CLNK_CTL_GET_PEER_RATES             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_PEER_RATES)
+#define CLNK_CTL_GET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_DYN_PARAMS)
+#define CLNK_CTL_SET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_SET_DYN_PARAMS)
+#define CLNK_CTL_GET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_GET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_SET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_SET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_GET_AGGR_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_AGGR_STATS)
+#define CLNK_CTL_SEND_GCAP                  (CLNK_CTL_SOC_CMD | DATA_BUF_SEND_GCAP)
+#define CLNK_CTL_GET_EPHY_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EPHY_STATS)
+
+
+#if FEATURE_QOS
+#define CLNK_CTL_CREATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_CREATE_FLOW)
+#define CLNK_CTL_UPDATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_UPDATE_FLOW)
+#define CLNK_CTL_DELETE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_DELETE_FLOW)
+#define CLNK_CTL_QUERY_INGRESS_FLOW         (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INGRESS_FLOW)
+#define CLNK_CTL_LIST_INGRESS_FLOWS         (CLNK_CTL_SOC_CMD | DATA_BUF_LIST_INGRESS_FLOWS)
+#define CLNK_CTL_QUERY_NODES                (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_NODES)
+#define CLNK_CTL_QUERY_INTERFACE_CAPS       (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INTERFACE_CAPS)
+#define CLNK_CTL_GET_EVENT_COUNTS           (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EVENT_COUNTS)
+#endif /* FEATURE_QOS */
+
+#if FEATURE_ECLAIR
+#define CLNK_CTL_ECLAIR_GET_HINFO           (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_HINFO)
+#define CLNK_CTL_ECLAIR_SET_TWEAKABLE       (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_TWEAKABLE)
+#define CLNK_CTL_ECLAIR_RESET_TEST_CONTEXT  (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_RESET_TEST_CONTEXT)
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+#define CLNK_CTL_ECLAIR_PUSH_COMMAND        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PUSH_COMMAND  | CLNK_CTL_ASYNC_CMD)
+#define CLNK_CTL_ECLAIR_GET_COMMAND         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_COMMAND)
+#define CLNK_CTL_ECLAIR_SET_RECEIPT         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_RECEIPT)
+#define CLNK_CTL_ECLAIR_PULL_RECEIPT        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PULL_RECEIPT  | CLNK_CTL_ASYNC_CMD)
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+#endif /* FEATURE_ECLAIR */
+
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_CCPU_COUNTS   (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS)
+#define CLNK_CTL_VAL_TRIGGER_MBOX_EVENT     (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_TRIGGER_MBOX_EVENT)
+#endif
+
+#if FEATURE_IQM
+#define CLNK_CTL_GET_IQM_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_GET_IQM_DATA)
+#endif
+
+#define CLNK_CTL_GET_ZIP_INFO               (CLNK_CTL_ETH_CMD | 0x00)
+#define CLNK_CTL_GET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x01)
+#define CLNK_CTL_SET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x02)
+#define CLNK_CTL_GET_MEM                    (CLNK_CTL_ETH_CMD | 0x03)
+#define CLNK_CTL_SET_MEM                    (CLNK_CTL_ETH_CMD | 0x04)
+#define CLNK_CTL_GET_TRACEBUF               (CLNK_CTL_ETH_CMD | 0x05)
+#define CLNK_CTL_GET_ETH_STATS              (CLNK_CTL_ETH_CMD | 0x06)
+#define CLNK_CTL_GET_BRIDGE_TABLE           (CLNK_CTL_ETH_CMD | 0x07)
+#define CLNK_CTL_SET_ETH_FIFO_SIZE          (CLNK_CTL_ETH_CMD | 0x08)
+#define CLNK_CTL_GET_EVM_DATA               (CLNK_CTL_ETH_CMD | 0x09)
+#define CLNK_CTL_GET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0a)
+#define CLNK_CTL_SET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0b) // OBSOLETE
+#define CLNK_CTL_SET_DBG_MASK_DYN           (CLNK_CTL_ETH_CMD | 0x21)
+#if 1 // added for MID RF (DEBUG_EPP)
+#define CLNK_CTL_GET_EPP_CAP_CFG            (CLNK_CTL_ETH_CMD | 0x22)
+#define CLNK_CTL_SET_EPP_CAP_CFG            (CLNK_CTL_ETH_CMD | 0x23)
+#endif
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS   (CLNK_CTL_ETH_CMD | 0x28)
+#endif
+
+#define CLNK_CTL_RESET_DEVICE               (CLNK_CTL_DRV_CMD | 0x00)
+#define CLNK_CTL_STOP_DEVICE                (CLNK_CTL_DRV_CMD | 0x01)
+#define CLNK_CTL_NET_CARRIER_ON             (CLNK_CTL_DRV_CMD | 0x02) 
+#define CLNK_CTL_NET_CARRIER_OFF            (CLNK_CTL_DRV_CMD | 0x03) 
+#define CLNK_CTL_NET_CARRIER_OK             (CLNK_CTL_DRV_CMD | 0x04) 
+#define CLNK_CTL_SOC_INIT_BUS               (CLNK_CTL_DRV_CMD | 0x05) 
+#define CLNK_CTL_SOC_BOOTED                 (CLNK_CTL_DRV_CMD | 0x06) 
+#define CLNK_CTL_HW_DESC_INIT               (CLNK_CTL_DRV_CMD | 0x07) 
+#define CLNK_CTL_TC_DIC_INIT                (CLNK_CTL_DRV_CMD | 0x08) 
+#define CLNK_CTL_GET_SOC_STATUS             (CLNK_CTL_DRV_CMD | 0x09) 
+#define CLNK_CTL_GET_LINK_STATUS            (CLNK_CTL_DRV_CMD | 0x0a) 
+#define CLNK_CTL_SET_MAC_ADDRESS            (CLNK_CTL_DRV_CMD | 0x0b) 
+#define CLNK_CTL_GET_NMS_LOCAL_MSG          (CLNK_CTL_DRV_CMD | 0x0c) /* NMS */
+#define CLNK_CTL_SET_DATA_PLANE_VARS        (CLNK_CTL_DRV_CMD | 0x0d) /* PQoS */
+
+/* end *************** ClnkCtl.h definitions **********************/
+
+// Driver Return Codes
+typedef enum
+{
+    CLNK_ETH_RET_CODE_SUCCESS            = 0,
+    CLNK_ETH_RET_CODE_GEN_ERR            = 1,
+    CLNK_ETH_RET_CODE_MEM_ALLOC_ERR      = 2,
+    CLNK_ETH_RET_CODE_RESET_ERR          = 3,
+    CLNK_ETH_RET_CODE_NOT_OPEN_ERR       = 4,
+    CLNK_ETH_RET_CODE_LINK_DOWN_ERR      = 5,
+    CLNK_ETH_RET_CODE_NO_HOST_DESC_ERR   = 6,
+    CLNK_ETH_RET_CODE_UCAST_FLOOD_ERR    = 7,
+    CLNK_ETH_NO_KEY_ERROR                = 8,
+    CLNK_ETH_MRT_TRANSACTION_IN_PROGRESS = 9,
+    CLNK_ETH_RET_CODE_PKT_LEN_ERR        = 10,
+
+    CLNK_ETH_RET_CODE_MAX  // This must always be last
+}
+CLNK_ETH_RET_CODES;
+
+
+
+
+#endif /* __common_dvr_h__ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Common_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Common_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Common_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/Common_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo.c ***/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg );
+unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response );
+unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg );
+unsigned long clnkioc_mem_read( void *dkcp, void *arg );
+unsigned long clnkioc_mem_write( void *dkcp, void *arg );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo_common.c ***/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob );
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length);
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length);
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_call.c ***/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg);
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_dvr.c ***/
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_ttask.c ***/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data);
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data);
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/util_dvr.c ***/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+void *ctx_alloc_dc_context( void );
+void ctx_free_dc_context( void *dccp );
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/control_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/control_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/control_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/control_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,52 @@
+/*******************************************************************************
+*
+* Common/Inc/control_context.h
+*
+* Description: control context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __control_context_h__
+#define __control_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "control_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "control_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "control_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "control_context_apollo.h"
+#endif
+
+#endif // __control_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/debug.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/debug.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/debug.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/debug.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Common/Inc/debug.h
+*
+* Description: debug macros and such
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __debug_h__
+#define __debug_h__
+
+
+
+#ifdef IOCTL_DEBUG
+static void _ioctl_dbg(dk_context_t *dkcp, char *str)
+{
+    HostOS_PrintLog(L_ERR, "%s: %s failed!\n", dkcp->name, str);
+}
+#else
+//static inline void _ioctl_dbg(char *name, char *str) { }
+#define _ioctl_dbg(NAME,STR)   do { } while (0)
+#endif
+
+
+#endif // __debug_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/driverversion.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/driverversion.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/driverversion.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/driverversion.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1 @@
+#define DRV_VERSION "1.00.01.51"
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_ctl_opts.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_ctl_opts.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_ctl_opts.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_ctl_opts.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,173 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_ctl_opts.h
+*
+* Description: driver (io)control options
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __drv_ctl_opts_h__
+#define __drv_ctl_opts_h__
+
+#include "common_dvr.h"
+
+#ifndef FEATURE_QOS
+#define FEATURE_QOS     0
+#endif
+
+
+
+
+// Driver Control Options
+typedef enum
+{
+    CLNK_ETH_CTRL_GET_REG,
+    CLNK_ETH_CTRL_SET_REG,
+    CLNK_ETH_CTRL_GET_MEM,
+    CLNK_ETH_CTRL_SET_MEM,
+    CLNK_ETH_CTRL_GET_TRACE,
+    CLNK_ETH_CTRL_GET_BRIDGE_SRC_TABLE, // COMBINE THESE 4 !!!!
+    CLNK_ETH_CTRL_GET_BRIDGE_DST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_BCAST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_MCAST_TABLE,
+    CLNK_ETH_CTRL_GET_EPP_DATA,
+    CLNK_ETH_CTRL_GET_EVM_DATA,
+    CLNK_ETH_CTRL_GET_MY_NODE_INFO,
+    CLNK_ETH_CTRL_GET_NET_NODE_INFO,
+    CLNK_ETH_CTRL_GET_PHY_DATA,
+    CLNK_ETH_CTRL_GET_RX_ERR_DATA,
+    CLNK_ETH_CTRL_GET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_LINK_STATUS,
+    CLNK_ETH_CTRL_GET_MAC_ADDR,
+    CLNK_ETH_CTRL_GET_MULTICAST_TABLE,
+    CLNK_ETH_CTRL_GET_NUM_TX_HOST_DESC,
+    CLNK_ETH_CTRL_GET_SOC_STATUS,  /* OBSOLETE/DO_NOT_REUSE */  
+    CLNK_ETH_CTRL_GET_STATS,
+    CLNK_ETH_CTRL_GET_SW_REV_NUM,
+    CLNK_ETH_CTRL_SET_CM_RATIO,
+    CLNK_ETH_CTRL_SET_EPP_DATA,    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_FIRMWARE,
+    CLNK_ETH_CTRL_SET_MAC_ADDR,
+    CLNK_ETH_CTRL_SET_PHY_MARGIN,
+    CLNK_ETH_CTRL_SET_PRIVACY_MODE, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SHA_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_SW_CONFIG,
+    CLNK_ETH_CTRL_SET_TX_POWER,
+    CLNK_ETH_CTRL_TEST_PORT,
+    CLNK_ETH_CTRL_RESET,
+    CLNK_ETH_CTRL_ENABLE_INTERRUPT,
+    CLNK_ETH_CTRL_DISABLE_INTERRUPT,
+    CLNK_ETH_CTRL_RD_CLR_INTERRUPT,
+    CLNK_ETH_CTRL_DETACH_SEND_PACKET,
+    CLNK_ETH_CTRL_DETACH_RCV_PACKET,
+    CLNK_ETH_CTRL_JOIN_MULTICAST,
+    CLNK_ETH_CTRL_LEAVE_MULTICAST,
+    CLNK_ETH_CTRL_SET_SEND_CALLBACK,
+    CLNK_ETH_CTRL_SET_RCV_CALLBACK,
+    CLNK_ETH_CTRL_SET_UNSOL_CALLBACK,
+    CLNK_ETH_CTRL_GET_RFIC_TUNING_DATA,
+    CLNK_ETH_CTRL_SET_RFIC_TUNING_DATA, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_AGC_GAIN_TABLE,   /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_CHANNEL_MASK,
+    CLNK_ETH_CTRL_GET_RANDOM_BITS,  /* OBSOLETE/DO_NOT_REUSE */
+   // CLNK_SOFTCAM
+    CLNK_ETH_CTRL_GET_SOFT_CAMDATA,
+
+    CLNK_ETH_CTRL_SET_LOF,
+    CLNK_ETH_CTRL_GET_LOF,
+    CLNK_ETH_CTRL_SET_BIAS,
+    CLNK_ETH_CTRL_FS_UPDATE,  /* OBSOLETE */
+    CLNK_ETH_CTRL_SET_CHANNEL_PLAN,
+    CLNK_ETH_CTRL_SET_TABOO_INFO,
+    CLNK_ETH_CTRL_SET_SCAN_MASK,
+
+    CLNK_ETH_CTRL_SET_DISTANCE_MODE,
+    CLNK_ETH_CTRL_SET_POWERCTL_PHYRATE,
+
+    CLNK_ETH_CTRL_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE,
+    CLNK_ETH_CTRL_DEFINE_CLM_INIT_SETTINGS,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_PRIVACY_SEND,
+    CLNK_ETH_CTRL_PRIVACY_SET_KEY,
+    CLNK_ETH_CTRL_PRIVACY_UPDATE,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_GET_PRIVACY_EVENT,
+    CLNK_ETH_CTRL_GET_PRIVACY_STAT,
+    CLNK_ETH_CTRL_GET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_GET_PRIVACY_DATA,
+    CLNK_ETH_CTRL_GET_PRIVACY_RANDBIT,
+
+    CLNK_ETH_CTRL_NODEMANAGE_ADD ,
+    CLNK_ETH_CTRL_NODEMANAGE_DELETE ,
+    CLNK_ETH_CTRL_NODEMANAGE_GET,
+
+    CLNK_ETH_CTRL_SET_TIMER_SPEED,
+
+    CLNK_ETH_CTRL_GET_PRIV_INFO,
+    CLNK_ETH_CTRL_GET_PRIV_STATS,
+    CLNK_ETH_CTRL_GET_PRIV_NODE_INFO,
+
+    CLNK_ETH_CTRL_DO_CLNK_CTL,
+    CLNK_ETH_CTRL_SET_BEACON_POWER_LEVEL, // added for DIP feature.
+
+#if FEATURE_QOS
+    CLNK_ETH_CTRL_CREATE_FLOW,
+    CLNK_ETH_CTRL_UPDATE_FLOW,
+    CLNK_ETH_CTRL_DELETE_FLOW,
+    CLNK_ETH_CTRL_QUERY_FLOW,
+    CLNK_ETH_CTRL_LIST_FLOWS,
+    CLNK_ETH_CTRL_GET_EVENT_COUNTS,
+    CLNK_ETH_CTRL_QUERY_IF_CAPS,
+    CLNK_ETH_CTRL_QUERY_NODES,
+    CLNK_ETH_CTRL_QUERY_PATH_INFO,
+    CLNK_ETH_CTRL_EXPIRE_FLOW,
+#if ECFG_CHIP_ZIP1
+    CLNK_ETH_CTRL_SET_TFIFO_RESIZE_CALLBACK,
+#endif /* ECFG_CHIP_ZIP1 */
+#endif
+
+    CLNK_ETH_CTRL_GET_PEER_RATES,
+    CLNK_ETH_CTRL_STOP,
+
+    CLNK_ETH_CTRL_MAX  // This must always be last
+}
+CLNK_ETH_CTRL_OPTIONS;
+
+
+
+
+
+#endif // __drv_ctl_opts_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/drv_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,62 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_hdr.h
+*
+* Description: Generic driver compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*
+* This file simply includes the driver's main compilation control file.
+* That file will be named after the driver in some way.
+*
+* The reason for this is to allow both local and common .c and .h files 
+* to include a file specific to a single driver thus customizing the
+* compilation for the selected driver.
+*
+*******************************************************************************/
+
+#ifndef __drv_hdr_h__
+#define __drv_hdr_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "pci_hdr.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "mii_hdr.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "candd_hdr.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "apollo_hdr.h"
+#endif
+
+#endif // __drv_hdr_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/entropic-config.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/entropic-config.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/entropic-config.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/entropic-config.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,61 @@
+#ifndef __entropic_config_h_
+#define __entropic_config_h_
+/*     ###########    W A R N I N G ! ! !    ##########     */
+/*     ##  Do not edit this file! it is generated!   ##     */
+/*     ###########    W A R N I N G ! ! !    ##########     */
+#define ECFG_CHIP_ZIP1    0
+#define ECFG_CHIP_ZIP2    0
+#define ECFG_CHIP_MAVERICKS    1
+#define ECFG_CHIP_STRING     "ECFG_CHIP_MAVERICKS"
+
+#define ECFG_BOARD_ECB_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP1    0
+#define ECFG_BOARD_PC_DVT_MII_ZIP2    0
+#define ECFG_BOARD_PC_DVT_TMII_ZIP2    1
+#define ECFG_BOARD_PC_DVT_GMII_ZIP2    0
+#define ECFG_BOARD_PC_DVT2_PCI_ZIP2    0
+#define ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2    0
+#define ECFG_BOARD_ECB_ROW    0
+#define ECFG_BOARD_GPC    0
+#define ECFG_BOARD_ECB_4M_L3    0
+#define ECFG_BOARD_ECB_3M_L3    0
+#define ECFG_BOARD_PC_PCIE_MAVERICKS    0
+#define ECFG_BOARD_STRING     "ECFG_BOARD_PC_DVT_TMII_ZIP2"
+
+#define ECFG_NETWORK_ACCESS    0
+#define ECFG_NETWORK_MIDRF_MESH    1
+#define ECFG_NETWORK_HIRF_MESH    0
+#define ECFG_NETWORK_STRING     "ECFG_NETWORK_MIDRF_MESH"
+
+#define ECFG_NODE_CPE    0
+#define ECFG_NODE_HEADEND    0
+#define ECFG_NODE_TCPE    0
+#define ECFG_NODE_MOCA    1
+#define ECFG_NODE_STRING     "ECFG_NODE_MOCA"
+
+#define ECFG_OS_LINUX_TYPICAL    1
+#define ECFG_OS_NONE    0
+#define ECFG_OS_STRING     "ECFG_OS_LINUX_TYPICAL"
+
+#define ECFG_FLAVOR_PRODUCTION    1
+#define ECFG_FLAVOR_PRODUCTION_PROTEM    0
+#define ECFG_FLAVOR_PHYSVT    0
+#define ECFG_FLAVOR_VALIDATION    0
+#define ECFG_FLAVOR_STRING     "ECFG_FLAVOR_PRODUCTION"
+
+#define ECFG_DATAPATH_GMII    0
+#define ECFG_DATAPATH_RGMII    0
+#define ECFG_DATAPATH_TMII    1
+#define ECFG_DATAPATH_MII    0
+#define ECFG_DATAPATH_PCI    0
+#define ECFG_DATAPATH_PCIE    0
+#define ECFG_DATAPATH_FLEX    0
+#define ECFG_DATAPATH_STRING     "ECFG_DATAPATH_TMII"
+
+#define ECFG_MISC_REF_XTAL_25M_CLOCK    1
+#define ECFG_MISC_REF_SOC_25M_CLOCK    0
+#define ECFG_MISC_STRING     "ECFG_MISC_REF_XTAL_25M_CLOCK"
+
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/HostOS_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/HostOS_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/HostOS_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/HostOS_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,86 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Common/gpl_ctx_abs.c ***/
+void *dk_to_dd( void *dkcp );
+void *dd_to_dg( void *ddcp );
+void *dg_to_dc( void *dgcp );
+void *dg_to_dd( void *dgcp );
+void *dk_to_dc( void *dkcp );
+void *dd_to_dc( void *ddcp );
+void *dk_to_dg( void *dkcp );
+void *dc_to_dd( void *dccp );
+
+/*** public prototypes from Common/gpl_ctx_setup.c ***/
+void *ctx_alloc_dg_context( void );
+void ctx_free_dg_context( void *dgcp );
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp );
+void Clnk_init_os_context( void *vdgcp ); /* BZ 5072 fix */
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len );
+
+/*** public prototypes from Common/hostos.c ***/
+void HostOS_Memset(void *pMem, int val, int size);
+void HostOS_Memcpy(void *pTo, void *pFrom, int size);
+void HostOS_Sscanf(const char *buf, const char *fmt, ...);
+void* HostOS_Alloc(int size);
+void HostOS_Free(void* pMem, int size);
+void HostOS_Sleep(int timeInUsec);
+void HostOS_lock_init( void *vlk);
+void HostOS_Lock(void *vlk);
+void HostOS_Lock_Irqsave(void *vlk);
+int HostOS_Lock_Try(void *vlk);
+void HostOS_Unlock(void *vlk);
+void HostOS_Unlock_Irqrestore(void *vlk);
+void HostOS_TermLock(void *vlk);
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...);
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr );
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr );
+void HostOS_timer_init( void *vtmr );
+int HostOS_timer_del( void *vtmr );
+int HostOS_timer_del_sync( void *vtmr );
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout );
+void HostOS_timer_add( void *vtmr );
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data );
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout );
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future );
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future );
+void *HostOS_wqt_alloc( void );
+void HostOS_wqt_free( void *vwqt );
+void HostOS_wqt_timer_init( void *vwqt );
+void HostOS_wqt_timer_del( void *vwqt );
+int HostOS_wqt_timer_del_sync( void *vwqt );
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_timer_add( void *vwqt );
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data );
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_waitq_init( void *vwqt );
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt );
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp );
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal);
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal);
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val);
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val);
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa);
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa);
+void HostOS_task_init( void *vtl, void *func, unsigned long data );
+void HostOS_task_schedule( void *vtl );
+void HostOS_task_enable( void *vtl );
+void HostOS_task_disable( void *vtl );
+void HostOS_task_kill( void *vtl );
+void HostOS_mutex_init( void *vmt );
+void HostOS_mutex_release( void *vmt );
+void HostOS_mutex_acquire( void *vmt );
+int HostOS_mutex_acquire_intr( void *vmt );
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_netif_carrier_ok( void *kdev );
+void HostOS_netif_carrier_on( void *kdev );
+void HostOS_netif_carrier_off( void *kdev );
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo );
+void HostOS_open( void *kdev );
+void HostOS_close( void *kdev );
+int HostOS_signal_pending(void *pTask);
+void HostOS_msleep_interruptible(unsigned int msecs);
+int HostOS_thread_start(unsigned int *pThreadID, char *thName, void (*func)(void *), void *arg);
+int HostOS_thread_stop(unsigned long threadID);
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/hw_z2_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/hw_z2_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/hw_z2_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/hw_z2_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,273 @@
+/*******************************************************************************
+*
+* Common/Inc/hw_z2_dvr.h
+*
+* Description: Header file for general Zip2 support (all datapaths)
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _HW_Z2_H_
+#define _HW_Z2_H_
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/* Fragment Gather Support:
+ *
+ * For stock Linux implementations, 1 FRAG is necessary and sufficient. 
+ * - Standard rule of thumb is driver must support IP chksum (NETIF_F_IP_CSUM)
+ *   before it makes sense to enable scatter/gather (NETIF_F_SG) in the
+ *   dev->features flag mask.  Linux always builds a single buffer WHEN it has
+ *   to do to its own IP Checksum (defeating NETIF_F_SG) !!
+ * - Due to various restrictions (see custom), general support of _SG would
+ *   require backstop code to coalesce when restrictions are violated.  See
+ *   drivers/net/typhoon.c for some good examples.
+ *
+ * For custom implementations, Gathered Fragments can be supported. Details ...
+ * - Limit of 4 Fragments exists with current CCPU/TC code
+ * -- See CLNK_HW_MAX_FRAGMENTS compile define below.
+ * -- Common driver also limited to 4. (See CLNK_ETH_MAX_FRAGMENTS. Modifiable)
+ * -- Has been well tested up to 4 Fragments.
+ * -- Configuring more than you need wastes some host driver space
+ * -- Configuring more than you need increases ptr_list DMA size
+ * - Restrictions below this point are not validated by code!
+ * -- Minimum Fragment must be at least 32 bytes
+ * -- External Fragment data can be on any byte host address boundary.
+ * -- Internal Fragment data has to start with 4 byte aligned.
+ * -- All fragments must be multiple of 4 in length, except final.
+ * - See SIMULATE_FRAGMENTS define in eth.c for example code.
+ * -- Includes tests which set successive frag sizes to 32, 64, 128 ...
+ */
+#define CLNK_HW_MAX_FRAGMENTS   1
+#if (CLNK_HW_MAX_FRAGMENTS > 4)
+#warning "Current 1.5 (SOC,TC) Xmit Support limited to 4 Fragments"
+#endif
+struct _frag_desc
+{
+    SYS_UINT32              ptr;
+    SYS_UINT32              len;
+};
+struct ptr_list
+{
+    SYS_UINT32              n_frags;
+    struct _frag_desc       fragments[CLNK_HW_MAX_FRAGMENTS];
+    SYS_UINT32              magic;
+};
+
+#define EHI_START       0x0c100000
+#define EHI_END         0x0c1003fc
+
+#define AT1_BASE        0x0c000000
+#define AT2_BASE        0x0c080000
+#define AT3_BASE        0x0c100400
+
+#define HOST_INTR       (1 << 1)        /* interrupt bit for tx/rx/mbx */
+#define TMR_INTR        (1 << 24)       /* interrupt bit for zip2 timer 0 */
+
+#if ! defined(CLNK_ETH_ENDIAN_SWAP)
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = (val)
+#else
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = HOST_OS_ENDIAN_SWAP(val)
+
+#endif /* ! defined(CLNK_ETH_ENDIAN_SWAP) */
+
+#define RX_STATUS_PTR(ctx, idx) ((ctx)->rx_linebuf + sizeof(struct linebuf) + ((idx) << 2))
+
+#define TX_STATUS_PTR(ctx, pri, idx) ((ctx)->tx_linebuf[pri] + sizeof(struct linebuf) + ((idx) << 2))
+
+
+/*
+ * CLNK_REG_*() and soc*Mem() take full Sonics addresses on Zip2,
+ * and handle the translation themselves for buses on which it is necessary
+ */
+#define SETUP_ATRANS(pContext, addr) do { } while(0)
+
+/*
+ * ZIP2 REGISTERS
+ */
+
+#define CLNK_ETH_INTERRUPT_FLAG  0x01
+
+// PCI device/vendor ID
+#define CLNK_ETH_PCI_DEVICE_ID  0x002117e6
+
+// Unused macro (Zip1b only)
+#define SEM_INIT_DONE_BITS() do { } while(0)
+
+#define CLNK_REG_ETH_MAC_ADDR_HIGH              DEV_MAC_ADDRESS0H
+#define CLNK_REG_ETH_MAC_ADDR_LOW               DEV_MAC_ADDRESS0L
+
+#define EHI_BASE                    0x0c100000
+#define CSC_BASE                    0x0c100400
+#define CCPU_BASE                   0x0c100800
+#define DIC_CSR_BASE                0x0c100c00
+#define ETH_CSR_BASE                0x0c103000
+#define GPHY_BASE                   0x0c103800
+#define DIC_BASE                    0x0c104000
+#define CPC_BASE                    0x0c108000
+#define RFIC_BASE                   0x0c109000
+#define FEC_BASE                    0x0c10a000
+#define CPC_TC_BASE                 0x0c10c000
+#define PHY_RX_BASE                 0x0c110000
+#define PHY_TX_BASE                 0x0c118000
+#define PCIE_CSR_BASE               0x0c102000
+#define HOST_INTR_TO_INTX           (1 << 10)
+#define PCIE_CSC_CORE_CTL           (PCIE_CSR_BASE + 0xc00)
+
+#define EHI_VERSION                 (EHI_BASE + 0x00)
+#define DEV_MAC_ADDRESS0L           (EHI_BASE + 0xd0)
+#define DEV_MAC_ADDRESS0H           (EHI_BASE + 0xd4)
+
+#define CLNK_REG_CPU_COLD_RESET_BIT (1 << 0)
+#define CLNK_REG_CPU_RESET          (CCPU_BASE + 0x04)
+#define CLNK_SYS_RST_CONTROL        (CCPU_BASE + 0x7c)
+
+#define EHI_INTR_OUT_MASK           (EHI_BASE + 0x24)
+#define CSC_INTR_BUS                (CSC_BASE + 0xc)
+
+#define EHI_TIMEOUT_CTL             (EHI_BASE + 0x38)
+#define EHI_ERR_ADDR_EXT            (EHI_BASE + 0xf8)
+#define EHI_ERR_ADDR_INT            (EHI_BASE + 0xfc)
+#define EHI_ERR_AT                  (EHI_BASE + 0xec)
+#define EHI_ERR_DET                 (EHI_BASE + 0x1c)
+
+#define EHI_MISC_CTL                (EHI_BASE + 0x90)
+#define EHI_AT1_CTL                 (EHI_BASE + 0x50)
+#define EHI_AT1_ADDR                (EHI_BASE + 0x54)
+#define EHI_AT1_MASK                (EHI_BASE + 0x58)
+#define EHI_AT2_CTL                 (EHI_BASE + 0x60)
+#define EHI_AT2_ADDR                (EHI_BASE + 0x64)
+#define EHI_AT2_MASK                (EHI_BASE + 0x68)
+#define EHI_AT3_CTL                 (EHI_BASE + 0x70)
+#define EHI_AT3_ADDR                (EHI_BASE + 0x74)
+#define EHI_AT3_MASK                (EHI_BASE + 0x78)
+
+#define IMI_AT0_CTL                 (EHI_BASE + 0xa0)
+#define IMI_AT0_ADDR                (EHI_BASE + 0xa4)
+#define IMS_CTL_0                   (EHI_BASE + 0xc0)
+#define IMS_CTL_1                   (EHI_BASE + 0xc4)
+#define IMS_CTL_2                   (EHI_BASE + 0xc8)
+#define IMI_ARB_CTL_0               (EHI_BASE + 0xe0)
+#define IMI_ARB_CTL_1               (EHI_BASE + 0xe4)
+#define IMI_ARB_CTL_2               (EHI_BASE + 0xe8)
+#if ECFG_CHIP_MAVERICKS 
+#define CPC_TC_INST_MEM             (CPC_TC_BASE + 0x0)
+#define CPC_TC_INST_MEM_SZ          0x3000
+#define CPC_TC_DATA_MEM_SZ          0x2000
+#define CPC_TC_DATA_MEM             (CPC_TC_BASE + CPC_TC_INST_MEM_SZ)
+#endif
+
+#define DIC_TC_CTL_0                (DIC_CSR_BASE + 0x50)
+#define DIC_MISC_CTL_0              (DIC_CSR_BASE + 0x40)
+#define DIC_ATRANS0_CTL0            (DIC_CSR_BASE + 0x70)
+#define DIC_ATRANS1_CTL0            (DIC_CSR_BASE + 0x78)
+#define DIC_TC_NOTIFY_SET           (DIC_CSR_BASE + 0x5c)
+
+#define DIC_TC_INST_MEM             (DIC_BASE + 0x00)
+#if ECFG_CHIP_ZIP2
+#define DIC_TC_INST_MEM_SZ          0x2000
+#define DIC_TC_DATA_MEM_SZ          0x1000
+#elif ECFG_CHIP_MAVERICKS
+#define DIC_TC_INST_MEM_SZ          0x2800
+#define DIC_TC_DATA_MEM_SZ          0x1800
+#endif
+/*For ZIP1 there are no TCs*/
+#define DIC_TC_DATA_MEM             (DIC_BASE + DIC_TC_INST_MEM_SZ)
+
+#define DIC_D_STATUS                (DIC_TC_DATA_MEM + 0x00)
+#define DIC_D_DESC_TX_PTR           (DIC_TC_DATA_MEM + 0x04)
+#define DIC_D_DESC_RX_PTR           (DIC_TC_DATA_MEM + 0x08)
+#define DIC_D_MISC_CFG              (DIC_TC_DATA_MEM + 0x0c)
+#define DIC_D_PROC_STATE            (DIC_TC_DATA_MEM + 0x10)
+#define DIC_D_LINEBUF_SOC_RX        (DIC_TC_DATA_MEM + 0x20)
+#define DIC_D_MIN_PKT_SIZE          (DIC_TC_DATA_MEM + 0x38)
+#define DIC_D_LINEBUF_HOST_RX       (DIC_TC_DATA_MEM + 0x24)
+#define DIC_D_LINEBUF0_SOC_TX       (DIC_TC_DATA_MEM + 0x2c)
+#define DIC_D_ETH_SPU_LEN_W_FCS_MAX (DIC_TC_DATA_MEM + 0x30)
+#define DIC_D_AGGR_HDR_SPU_CNT_MAX  (DIC_TC_DATA_MEM + 0x34)
+#define DIC_D_RX_DST_PTR            (DIC_TC_DATA_MEM + 0x68)
+#define DIC_D_RX_DST_IDX            (DIC_TC_DATA_MEM + 0x6c)
+#define DIC_D_TX_DMA_CTL            (DIC_TC_DATA_MEM + 0x78)
+#define DIC_D_RX_DMA_CTL            (DIC_TC_DATA_MEM + 0x7c)
+
+
+#define DIC_CFG_USAGE_MODE_PCI      0x00000000
+#define DIC_CFG_USAGE_MODE_MII      0x00000001
+#define DIC_CFG_BAD_PKT_FLTR_OFF    0x00000000
+#define DIC_CFG_BAD_PKT_FLTR_ON     0x00000010
+#define DIC_CFG_SPU_FCS_ENABLED     0x00000020
+#define DIC_CFG_SPU_FCS_DISABLED    0x00000000
+#define DIC_CFG_AGGR_DST_ONLY       0x00000040
+#define DIC_CFG_AGGR_DST_AND_PRI    0x00000000
+#define DIC_CFG_TX_BUF_PROF_WAN     0x00000080
+#define DIC_CFG_TX_BUF_PROF_LAN     0x00000000
+#define DIC_CFG_MII_SPEED_MASK      0x000FFF00
+#define DIC_CFG_PQOS_MODE_MASK      0x00F00000
+#define DIC_CFG_PQOS_MODE_MOCA_11   0x00000000
+#define DIC_CFG_PQOS_MODE_PUPQ      0x00100000
+
+#define DIC_TX_DMA_CTL_WORD         0x00048000
+#define DIC_RX_DMA_CTL_WORD         0x00048100
+
+#define CSC_CLK_CTL1                (CSC_BASE + 0xe4)
+
+#define CSC_SYS_TMR_LO              (CSC_BASE + 0x70)
+#define CSC_TMR_TIMEOUT_0           (CSC_BASE + 0x80)
+#define CSC_TMR_MASK_0              (CSC_BASE + 0x84)
+
+#define GPHY_MAC_CONFIG             (GPHY_BASE + 0x00)
+#define GPHY_FILTER                 (GPHY_BASE + 0x04)
+#define GPHY_FLOW                   (GPHY_BASE + 0x18)
+
+#define GPHY_FLOW_MAC_LO	    (GPHY_BASE + 0x40)		// Low 2 bytes of mac address as (xx xx MM ZZ) where MM is lowest byte
+#define GPHY_FLOW_MAC_HI	    (GPHY_BASE + 0x44)		// High 4 bytes of mac address in reverse order 
+                                                                //             (AA BB CC DD) where DD is highest byte.
+#define GPHY_BMCR                   (GPHY_BASE + 0x100)
+#define GPHY_ENH_CTRL               (GPHY_BASE + 0x168)
+#define GPHY_BUS_MODE               (GPHY_BASE + 0x200)
+#define GPHY_RX_DESCR_PTR           (GPHY_BASE + 0x20c)
+#define GPHY_TX_DESCR_PTR           (GPHY_BASE + 0x210)
+#define GPHY_OP_MODE                (GPHY_BASE + 0x218)
+
+#define CLNK_REG_MBX_REG_1          DEV_SHARED(mailbox_reg[0])
+#define CLNK_REG_MBX_REG_9          DEV_SHARED(mailbox_reg[8])
+#define CLNK_REG_MBX_REG_16         DEV_SHARED(mailbox_reg[15])
+#define CLNK_REG_MBX_READ_CSR       DEV_SHARED(read_csr_reg)
+#define CLNK_REG_MBX_WRITE_CSR      DEV_SHARED(write_csr_reg)
+#define CLNK_REG_MBX_SEMAPHORE_BIT  0x80000000UL
+
+#define CLNK_REG_DEBUG_0            DEV_SHARED(debug_reg[0])
+#define CLNK_REG_DEBUG_1            DEV_SHARED(debug_reg[1])
+
+#define CLNK_REG_MBX_FIRST          CLNK_REG_MBX_REG_1
+#define CLNK_REG_MBX_LAST           CLNK_REG_MBX_REG_16
+
+#endif /* ! _HW_Z2_H_ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/inctypes_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/inctypes_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/inctypes_dvr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc/inctypes_dvr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,300 @@
+/*******************************************************************************
+*
+* Common/Inc/inctypes_dvr.h
+*
+* Description: System definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __INCTYPES_H__
+#define __INCTYPES_H__
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+//  System Constants
+#define SYS_TRUE     1
+#define SYS_FALSE    0
+#define SYS_NULL     0
+#define SYS_SUCCESS  0
+
+// NOTE: The error constants defined below MUST be the same value as the 
+//       corresponding error codes defined by your specific OS.  If not, then
+//       change the values of the defines below to match your specific OS error
+//       values.
+// 
+//       Entropic has defined the error constants below to match the OS we use in
+//       our evaluation platforms and may differ from the error values defined by 
+//       your specific OS.
+#define SYS_INPUT_OUTPUT_ERROR     5
+#define SYS_OUT_OF_MEMORY_ERROR    12
+#define SYS_PERMISSION_ERROR       13
+#define SYS_INVALID_ADDRESS_ERROR  14
+#define SYS_INVALID_ARGUMENT_ERROR 22
+#define SYS_OUT_OF_SPACE_ERROR     28
+#define SYS_DIR_NOT_EMPTY_ERROR    39
+#define SYS_BAD_MSG_TYPE_ERROR     42
+#define SYS_TIMEOUT_ERROR          110
+
+
+#define DOWHILE0(x)  do { x; } while(0)
+
+#define INCTYPES_MIN(x,y)		  ((x) < (y) ? (x) : (y))
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// System Variable Types
+typedef void            SYS_VOID;
+typedef void*           SYS_VOID_PTR;
+
+typedef char            SYS_CHAR;
+typedef char*           SYS_CHAR_PTR;
+typedef signed char     SYS_INT8;
+typedef signed char*    SYS_INT8_PTR;
+typedef unsigned char   SYS_UCHAR;
+typedef unsigned char*  SYS_UCHAR_PTR;
+typedef unsigned char   SYS_UINT8;
+typedef unsigned char*  SYS_UINT8_PTR;
+typedef unsigned char   SYS_BOOLEAN; 
+
+/** Used in places where the type is a boolean type but 32 bit words reduce
+ * code space by avoiding the need for various masking */
+typedef unsigned char   SYS_BOOLEAN32; 
+
+typedef unsigned short  SYS_UINT16;
+typedef unsigned short* SYS_UINT16_PTR;
+typedef short           SYS_INT16;
+typedef short*          SYS_INT16_PTR;
+
+typedef int             SYS_INT32;
+typedef int*            SYS_INT32_PTR;
+typedef unsigned int    SYS_UINT32;
+typedef unsigned int*   SYS_UINT32_PTR;
+
+typedef long            SYS_LONG;
+typedef long*           SYS_LONG_PTR;
+typedef unsigned long   SYS_ULONG;
+typedef unsigned long*  SYS_ULONG_PTR;
+
+#if defined(_LP64)
+typedef unsigned long   SYS_UINTPTR;
+#else
+typedef unsigned int    SYS_UINTPTR;
+#endif
+
+typedef struct {
+	SYS_INT32 I;
+	SYS_INT32 Q;
+} SYS_COMPLEX_INT32;
+
+typedef struct {
+	SYS_UINT32 		hi;
+	SYS_UINT32 		lo;
+} mac_addr_t;
+
+typedef void (*SYS_VDFCVD_PTR) (void *);
+
+/** Query if the mac address represents a multicast */
+#define INCTYPES_MAC_ADDR_IS_MULTICAST( _mac_addr ) \
+  (((_mac_addr).hi & 0x01000000) ? SYS_TRUE : SYS_FALSE)
+
+
+/** Query if two mac address match (low order bits masked off) */
+#define INCTYPES_MAC_ADDR_MATCH( _mac_addr_a, _mac_addr_b )              \
+  ((                                                                     \
+      (_mac_addr_a).hi == (_mac_addr_b).hi                               \
+   ) &&                                                                  \
+   (                                                                     \
+      ((_mac_addr_a).lo & 0xFFFF0000) == ((_mac_addr_b).lo & 0xFFFF0000) \
+   ))
+
+
+typedef struct {
+    SYS_UINT32 hi;  // Bytes 5432 of flow id
+    SYS_UINT32 lo;  // Bytes 10xx of flow id, bottom 2 bytes zeroed always
+} clink_flow_id_t;
+
+typedef clink_flow_id_t flow_id_t;
+
+/* persistent name for a clink node, may differ from devices mac address */
+typedef mac_addr_t guid_mac_t;
+
+typedef mac_addr_t clink_guid_t;
+
+typedef SYS_UINT8 clink_node_id_t;
+
+typedef SYS_UINT32 clink_nodemask_t;
+
+typedef SYS_UINT8  moca_version_t;
+
+#define MOCA_FROM_NPS(_nps) ((moca_version_t)(((_nps) >> 24) & 0xFF))
+
+#define MOCA_01  ((moca_version_t)0x01)
+#define MOCA_10  ((moca_version_t)0x10)
+#define MOCA_11  ((moca_version_t)0x11)
+#define MOCA_1C  ((moca_version_t)0x1C) /* Future compatibility testing */
+
+/** Used internally to indicate that the true node protocol support field
+ * values are not yet known. */
+#define MOCA_UNSPECIFIED  ((moca_version_t)0x02)
+
+#define MOCA_TO_NPS(moca_version) ((moca_version) << 24)
+
+#define MOCA_VERSION_SPECIFIED(nps) (MOCA_FROM_NPS(nps)!=MOCA_UNSPECIFIED)
+
+/** Causes a compile time error if a condition is not true at compile time
+ * from within a function definition.
+ * 
+ * Note that the arguments to this must be evaluatable at compile time. If
+ * this check fails, you will see an error like: 'the size of an array must
+ * be greater than zero'. 
+ */
+#define INCTYPES_COMPILE_TIME_ASSERT(_condition)      \
+do                                                    \
+{                                                     \
+    extern int inctypes_assert[(_condition) ? 1 : 0]; \
+    (void)inctypes_assert;                            \
+} while (0)
+
+
+/** Given a reference to an array of definite size, return num elements */
+#define INCTYPES_ARRAY_LEN(_arrayVar) ( sizeof(_arrayVar) / sizeof(*_arrayVar) )
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is larger than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)    \
+struct _struct##_size_verify_lte_t                             \
+{                                                              \
+    int lo[(int)1 + (int)(_size) - (int)sizeof(_struct)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is smaller than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size) \
+struct _struct##_size_verify_gte_t                             \
+{                                                              \
+    int hi[(int)1 + (int)sizeof(_struct) - (int)(_size)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is not equal to the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_SIZE(_struct,_size)          \
+    INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)     \
+    INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size)
+
+/**
+ * A special macro that when passed the name of an enumeration or define
+ * will cause a compilation error if the value is larger than another 
+ * value.
+ */
+#define INCTYPES_VERIFY_TOKEN_LESS_THAN(_token,_size) \
+struct _token##_size_verify_lt_t                      \
+{                                                     \
+    int lo[(int)(_size) - (int)(_token)];             \
+};
+
+/**
+ * Utility to safely copy pointers to structures of the same size. This only 
+ * works in evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_PTR_COPY(_destPtr,_srcPtr)                             \
+do                                                                           \
+{                                                                            \
+    INCTYPES_COMPILE_TIME_ASSERT(sizeof(*(_destPtr)) == sizeof(*(_srcPtr))); \
+                                                                             \
+    memcpy((_destPtr),(_srcPtr),sizeof(*(_destPtr)));                        \
+} while (0)
+
+/**
+ * Utility to safely copy variables of the same size.  This only works in 
+ * evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_VAR_COPY(_dest,_src) \
+        INCTYPES_SAFE_PTR_COPY((&(_dest)),(&(_src)))
+
+/**
+ * Utility to safely zero a structure referred to by a typed pointer. This only 
+ * works in evironments implementing memset.
+ */
+#define INCTYPES_SAFE_PTR_ZERO(_destPtr)        \
+    memset((_destPtr),0,sizeof(*(_destPtr)))    
+
+/**
+ * Utility to safely zero a variable. This only works in evironments 
+ * implementing memset.
+ */
+#define INCTYPES_SAFE_VAR_ZERO(_destVar)        \
+    memset(&(_destVar),0,sizeof(_destVar))
+
+
+
+/*******************************************************************************
+*                        G l o b a l   C o n s t a n t s                       *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                           G l o b a l   D a t a                              *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                            I n t e r f a c e s                               *
+********************************************************************************/
+
+
+#endif /* __INCTYPES_H__ */
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,695 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response );
+static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr, 
+                                         struct clnk_io *uio, struct clnk_io *kio );
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio, 
+                                          struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+                                          void *odata );
+
+
+/****************************************************************************
+*                      IOCTL Methods                                        *
+*****************************************************************************/
+
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV 
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_driver_cmd_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV 
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32 cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_PRIV    
+    //HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( CLNK_CTL_FOR_DRV(cmd)) {
+            error = clnk_ctl_drv( dkcp, cmd, &kio );
+        } else if( CLNK_CTL_FOR_ETH(cmd) ) {
+            error = Clnk_ETH_Control_drv( dccp, CLNK_ETH_CTRL_DO_CLNK_CTL, cmd, (SYS_UINTPTR)&kio, 0);
+
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+        }
+
+        // send reply back to IOCTL caller
+        if( !error ) {
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_PRIV    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *              This is a daemon sending a command mailbox request 
+ *              and expecting a response.
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              arg      - request structure from user via kernel
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response )
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mbox_cmd_request_work( dkcp, &kifr, response ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              kifr     - kernel ifr pointer
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response )
+{
+    dc_context_t   *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR    param1, param2, param3;
+    SYS_INT32      error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32     cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_CMDQ    
+    HostOS_PrintLog(L_INFO, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( response ) {
+
+            // send MESSAGE - wait for response
+
+            error = clnk_cmd_msg_send_recv(       dccp, kifr->cmd, param1, &kio ) ;
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+
+        } else {
+
+            // send MESSAGE
+
+            error = clnk_cmd_msg_send( dccp, kifr->cmd, param1, &kio ) ;
+
+        }
+
+        if( !error ) {
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_CMDQ    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for unsolicited message retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg ) 
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mbox_unsolq_retrieve_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for sw unsolicited retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR     param1, param2, param3;
+    SYS_INT32       error = SYS_SUCCESS;
+    struct clnk_io  uio, kio ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_UNSOLQ    
+    //HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( uio.out_len != MAX_UNSOL_MSG )
+        {
+            _ioctl_dbg( dkcp, "SW UNSOL length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            error = Clnk_MBX_RcvUnsolMsg( &dccp->mailbox, (SYS_UINT32 *)dccp->clnk_ctl_out ) ;
+            if( !error ) {
+                // send reply back to IOCTL caller
+                error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+            }
+        }
+    }
+
+#if DEBUG_IOCTL_UNSOLQ    
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_read( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mem_read_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM    
+    //HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        // check stuff
+        if( (uio.out_len == 0) ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL 0 out length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            addr = kio.in_len ? kio.in[0] : ((SYS_UINTPTR)kio.in);
+
+            // the READ
+
+            clnk_blk_read( dccp, addr, (SYS_UINT32 *)kio.out, kio.out_len ) ;
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM 
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_write( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ; 
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work    
+            error = clnkioc_mem_write_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ * 
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr, *data, len ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM    
+    //HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif        
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        addr = kio.in[0];               // first  in long is the address
+        data = &kio.in[1];              // second in long is the first data long
+        len  = kio.in_len - sizeof(SYS_UINT32);  // len is the block length less the address long
+        if( len < sizeof(SYS_UINT32) )
+        {
+            // kio.in_len includes the address (4 bytes) and the data
+            /* minimum write is 1 word */
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL min write");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        } else {
+
+            // the WRITE
+            clnk_blk_write(dccp, addr, (SYS_UINT32 *)data, len);
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM 
+    if( error ) {   
+        HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+/**
+ *  Purpose:    Copies the IOCTL request block to kernel space
+ *              Maybe performs some checks.
+ *
+ *  Imports:    arg  - request structure from user via kernel
+ *              kifr - kernel space block to recieve IOCTL request block       
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+    // copy the user's request block to kernel space
+    if( HostOS_copy_from_user( (void *)kifr, arg, sizeof(IfrDataStruct)) ) {
+        HostOS_PrintLog(L_INFO, "fault: %p\n", arg );
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    } else {
+		// cursory checks
+        if( (SYS_INT32)kifr->param3 != CLNK_CTL_VERSION ) {
+            HostOS_PrintLog(L_INFO, "fault: version not %d\n", CLNK_CTL_VERSION );
+            error = -SYS_PERMISSION_ERROR ;
+        }
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    Setup io block for IOCTL 
+ *
+ *              This is called after clnkioc_copy_request_block()
+ *
+ *              The io block is copied from user space to kernel space
+ *              into the uio. The uio is then used to setup the kio.
+ *
+ *  Imports:    dccp - driver control context pointer
+ *              kifr - kernel ifr pointer
+ *              uio  - io block copied from user space
+ *              kio  - kernel io block
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr, 
+                                         struct clnk_io *uio, struct clnk_io *kio )
+{
+    SYS_UINTPTR  param1, param2 ;
+    SYS_INT32    error = SYS_SUCCESS;
+    SYS_UINT32   in_len, max_in, max_out;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block pointer
+
+    // copy the user's io block to kernel space
+    if( HostOS_copy_from_user( uio, (void *)param2, sizeof(struct clnk_io)) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (uio)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    } else {
+
+        in_len = uio->in_len;
+
+        max_in  = CLNK_CTL_MAX_IN_LEN;
+        max_out = CLNK_CTL_MAX_OUT_LEN;
+
+        if( (in_len > max_in)        || 
+            (in_len & 3)             || 
+            (uio->out_len > max_out) ||
+            (uio->out_len & 3)          ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL lengths");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+            if( in_len ) {   // 'in' to the driver
+                // copy data block to fixed buffer
+                if( HostOS_copy_from_user( dccp->clnk_ctl_in, uio->in, uio->in_len) )
+                {
+                    _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (data in)");
+                    error = -SYS_INVALID_ADDRESS_ERROR;
+                } else {
+                    // set the kio 'in' pointer
+                    kio->in     = (SYS_UINT32 *)( dccp->clnk_ctl_in );
+                    kio->in_len = in_len;
+                }
+            } else {
+                /* if in_len is 0, uio.in is an integer single argument */
+                kio->in     = uio->in;
+                kio->in_len = 0;
+            }
+            // set the kio 'out' pointer
+            kio->out     = (SYS_UINT32 *)( dccp->clnk_ctl_out );
+            kio->out_len = uio->out_len;
+            // Note that some IOCTLs require out_len non-zero - we don't check for that.
+        }
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    Reply back to the IOCTL caller by copying the io block
+ *              and data, if any, back to user space.
+ *
+ *              This is called at the end of the IOCTL operation
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              uio      - user io block pointer, in kernel space
+ *              kio      - kernel io block pointer
+ *              us_ioblk - user space pointer to user io block
+ *              odata    - out data, in kernel space
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio, 
+                                          struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+                                          void *odata )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+
+    /* update out length if shorter now */
+    if( kio->out_len < uio->out_len ) {
+
+        uio->out_len = kio->out_len;     // set new length
+
+        // copy length to user space - along with the rest of the io block
+        if( HostOS_copy_to_user( (void *)us_ioblk, (void *)uio, sizeof(struct clnk_io)) )
+        {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (uio)");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        }
+    }
+
+    if( uio->out_len &&       // if supposed to return data
+        HostOS_copy_to_user( uio->out, odata, uio->out_len) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (out data)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    }
+
+    return( error );
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo_common.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo_common.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo_common.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo_common.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,258 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo_common.c
+*
+* Description: ioctl common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+/**
+* 
+*   Purpose:    Sends and receives a command message.
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+*                         Note: If io->in_len is 0, io->in is treated as a 
+*                               single argument
+*
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob )  // io block pointer
+{
+    int             error ;
+    Clnk_MBX_Msg_t  mbxMsg;
+    int             len;
+    SYS_INT32       out_len ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);          /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & ~CLNK_CMD_DST_MASK;      /* wd 1 */
+    mbxMsg.msg.ethCmd.param[1] = 0;                                 /* wd 2 */
+
+    if( iob->in_len )
+    {
+        /* send a blob of data down to the SoC */
+        int i;
+        
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);  // get number of longs
+        for(i = 0; i < len; i++) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];            /* wd 3+ */
+        }
+    } else {
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in;          /* wd 3 */
+        len = 1;
+    }
+
+#if ECFG_FLAVOR_VALIDATION==1
+    if (cmd == CLNK_CTL_VAL_TRIGGER_MBOX_EVENT)
+    {
+        clnkEth_valMboxHostCounts.triggeredSendRcvs++;
+    }
+#endif
+
+    // send message - wait for and receive response
+
+    error = Clnk_MBX_SendRcvMsg( &dccp->mailbox, &mbxMsg, &mbxMsg,
+                                    3 + len, MBX_POLL_TIMEOUT_IN_US);
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg, subcmd = %x, error = %d\n", rq_scmd, error);
+    /*
+    * status is the status of the mailbox transaction itself
+    *
+    * CLNK_MBX_GET_STATUS() reports the replyStatus from
+    *   ETH_ProcDataBufCmd() handler on the SoC (if the mailbox
+    *   transaction didn't fail)
+    */
+    if( !error &&
+        (CLNK_MBX_GET_STATUS(mbxMsg.msg.ethReply.status) == SYS_SUCCESS))
+    {
+        // extract out length
+        out_len = (CLNK_MBX_GET_REPLY_LEN(mbxMsg.msg.ethReply.status) << 2) - 4;
+
+        // adjust out length for reality
+        iob->out_len = MIN_VAL(iob->out_len, out_len);
+        if( iob->out_len )
+        {
+            // copy response to 'out' buffer
+            HostOS_Memcpy( iob->out, &mbxMsg.msg.ethReply.param[0], out_len);
+        }
+    }
+
+    return( error );
+}
+
+
+/*
+*   Purpose:    Reads a block of register address space into a buffer.
+*
+*               The block is read as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp            - control context
+*               sourceClinkAddr - beginning register address
+*               destHostAddr    - beginning memory buffer address
+*               length          - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_read_burst( dccp, sourceClinkAddr, destHostAddr, length, 1); //1 for SOC, 0 for FPGA
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, sourceClinkAddr += 4, destHostAddr++ ) {
+        clnk_reg_read(dccp, sourceClinkAddr, destHostAddr);
+    }
+
+#endif
+
+}
+
+/*
+*   Purpose:    Writes a buffer to a block of register address space.
+*
+*               The block is written as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp           - control context
+*               destClnkAddr   - beginning register address
+*               sourceHostAddr - beginning memory buffer address
+*               length         - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_write_burst( dccp, destClnkAddr, sourceHostAddr, length, 1); //for SOC
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, destClnkAddr += 4, sourceHostAddr++ ) {
+        clnk_reg_write(dccp, destClnkAddr, *sourceHostAddr);
+    }
+#endif
+}
+
+/**
+*   Purpose:    Sends command message 
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+* 
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob )  // io block pointer
+{
+    SYS_INT32           error = SYS_SUCCESS;
+    Clnk_MBX_Msg_t      mbxMsg;
+    int                 len, i;
+    SYS_UINT8           tid ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);                  /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & CLNK_CMD_BYTE_MASK;              /* wd 1 */             
+    mbxMsg.msg.ethCmd.param[1] = 0;                                         /* wd 2 */
+
+    if( iob->in_len )   // buffer to send
+    {
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);
+        for( i = 0 ; i < len ; i++ ) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];                    /* wd 3+ */
+        }
+    } else {            // single long to send
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in ;                 /* wd 3 */
+        len = 1;        // len is in longs
+    }
+
+    error = Clnk_MBX_SendMsg( &dccp->mailbox, &mbxMsg, &tid, 3 + len );
+
+    return( error );
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_call.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_call.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_call.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_call.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,286 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_call.c
+*
+* Description: mailbox common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**
+ * Callback function for unsolicited mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when an unsolicited
+ * message appears on the SW unsol queue.
+ *
+ * Unsolicited messages poked into the hardware mailbox CSRs are unsupported
+ * and should never be produced by the embedded.
+ * 
+ * vcp       - void pointer to control context
+ * pMsg      - Struct containing newly received message in DRIVER SPACE
+ *             Some of the cases in this function modify this message
+ *
+ * Returns 1 for message consumed. 0 for message NOT consumed.
+ *
+*PUBLIC***************************************************************************/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg)
+{
+    int consumed = 1 ;              // message consumed flag
+    dc_context_t *dccp = vcp;
+    switch (pMsg->msg.maxMsg.msg[0])
+    {
+        case CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS:
+        case CLNK_MBX_UNSOL_MSG_BEACON_STATUS:
+        case CLNK_MBX_UNSOL_MSG_RESET:
+            consumed = 0 ;
+            break;
+
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_PUB:
+            break;
+#endif
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_UNPUB:
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_NODE_ADDED:
+            break;
+        case CLNK_MBX_UNSOL_MSG_NODE_DELETED:
+            break; 
+//#ifdef CLNK_ETH_PHY_DATA_LOG
+        case CLNK_MBX_UNSOL_MSG_EVM_DATA_READY:
+            //HostOS_PrintLog(L_INFO, "FSUPDATE: IMO Node = %d\n", pMsg->msg.maxMsg.msg[1]);
+               
+            if (dccp->evmData)
+            {
+                int i;
+
+                dccp->evmData->valid = SYS_FALSE;                   // Don't let others read the data while it s updated
+                dccp->evmData->NodeId = pMsg->msg.maxMsg.msg[1];    // Get the data 
+                for (i=0;i<256;i++)
+                {    
+                    dccp->evmData->Data[i]=0;
+                }
+                dccp->evmData->valid = SYS_TRUE;      
+            }            
+            consumed = 0 ;
+            break;
+//#endif
+// #if CLNK_ETH_ECHO_PROFILE 
+#if 1 // modified for MID RF (DEBUG_EPP)
+         #define NUMBER_OF_RX_ECHO_PROBE_SYMBOLS 3
+         #define EP_RX_PROBE_SIZE ((256 + NUMBER_OF_RX_ECHO_PROBE_SYMBOLS*(256 + 64)) * 4)
+         #define EPP_RX_CORR_SIZE 256
+        case CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE:
+            consumed = 0 ;
+	{
+            int  sample;
+            
+            dccp->eppData.nodeId = pMsg->msg.maxMsg.msg[2] & 0x0000FFFF;
+            dccp->eppData.probeId = pMsg->msg.maxMsg.msg[2] >> 16;
+            dccp->eppData.cpLen = pMsg->msg.maxMsg.msg[6] & 0x0000FFFF;
+            dccp->eppData.sysBias = pMsg->msg.maxMsg.msg[6] >> 16;
+            dccp->eppData.status = pMsg->msg.maxMsg.msg[7];
+
+            if (pMsg->msg.maxMsg.msg[1] & EPP_CAP_FLAGS_RAW_DATA)
+            {
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[3],
+                           dccp->eppData.rawData, EP_RX_PROBE_SIZE);
+                for (sample = 0; sample < 128; sample += 127)
+                {
+                    HostOS_PrintLog(L_DEBUG,
+                            "ProbeId:%-5u  "
+                            "Sample:%-3u  "
+                            "Status:%-2u  "
+                            "EPPraw:%u\n",
+                            (SYS_UINT32)dccp->eppData.probeId,
+                            (SYS_UINT32)sample,
+                            (SYS_UINT32)dccp->eppData.status,
+                            (SYS_UINT32)dccp->eppData.rawData[sample]);
+                }
+            }
+
+            if (pMsg->msg.maxMsg.msg[1] & EPP_CAP_FLAGS_CORR_DATA)
+            {
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[4],
+                           (SYS_UINT32 *)dccp->eppData.corrData,
+                           EPP_RX_CORR_SIZE);
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[5],
+                           (SYS_UINT32 *)dccp->eppData.corrEnergy,
+                           EPP_RX_CORR_SIZE);
+                for (sample = 0; sample < 128; sample +=127)
+                {
+                    HostOS_PrintLog(L_DEBUG,
+                            "ProbeId:%-5u  "
+                            "Sample:%-3u  "
+                            "Status:%-2u  "
+                            "CP=%-2u  "
+                            "SB:%-2u  "
+                            "EPPcorr:%-3u  "
+                            "EPPenergy:%-3u\n",
+                            (SYS_UINT32)dccp->eppData.probeId,
+                            (SYS_UINT32)sample,
+                            (SYS_UINT32)dccp->eppData.status,
+                            (SYS_UINT32)dccp->eppData.cpLen,
+                            (SYS_UINT32)dccp->eppData.sysBias,
+                            (SYS_UINT32)dccp->eppData.corrData[sample],
+                            (SYS_UINT32)dccp->eppData.corrEnergy[sample]);
+                }
+            }
+
+            dccp->eppData.valid |= pMsg->msg.maxMsg.msg[1];
+            //    return;
+        }
+
+            break;
+#endif
+#if (NETWORK_TYPE_ACCESS)
+        case CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC:
+            consumed = 0 ;
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_TABOO_INFO:
+            HostOS_PrintLog(L_INFO, "FSUPDATE: Taboo Mask = 0x%06x, Offset = %d\n",
+                            pMsg->msg.maxMsg.msg[1] >> 8,
+                            pMsg->msg.maxMsg.msg[1] & 0x0ff);
+            consumed = 0 ;
+            break;
+        case CLNK_MBX_UNSOL_MSG_FSUPDATE:
+#if NETWORK_TYPE_MIDRF_MESH
+            HostOS_PrintLog(L_INFO, 
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d.%1d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            400 +  ((pMsg->msg.maxMsg.msg[1] & 0x00ff) * 125/10), (((pMsg->msg.maxMsg.msg[1] & 0x00ff)% 2) ? 5: 0),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);   
+#else
+            HostOS_PrintLog(L_INFO,
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            800 +  ((pMsg->msg.maxMsg.msg[1] & 0x00ff) * 25),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);
+#endif
+            consumed = 0 ;
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY:
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES:
+            break;
+
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT:
+            consumed = 0 ;
+            break ;
+#endif
+        default:
+            consumed = 0 ;
+            break;
+    }
+
+    return( consumed ) ;
+}
+
+
+/**
+ * \brief Callback function for HOST_ORIG mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when a mailbox
+ * reply to a HOST_ORIG message is received.
+ *
+ * The only message we actually process in this callback is the
+ * ETH_MB_GET_STATUS / CLNK_MBX_ETH_GET_STATUS_CMD response.
+ * socStatusEmbedded is used later in Get SocStatus().
+ *
+ * \param[in] pvContext void pointer to our dc_context_t
+ * \param[in] pMsg Struct containing newly received message
+ *
+*PUBLIC*****************************************************************/
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg)
+{
+#if 000
+    dc_context_t *dccp = vcp;
+    SYS_UINT8  transID;
+
+    transID = (SYS_UINT8)CLNK_MBX_GET_TRANS_ID(pMsg->msg.ethReply.status);
+    if (transID == dccp->socStatusLastTransID)
+    {
+        /*
+         * This reply comes from ETH_MB_GET_STATUS in the embedded.
+         * If there was a reset condition, it copied the reset reason into
+         * param[0].  Otherwise, it wrote 0.
+         */
+        if (pMsg->msg.ethReply.param[0] != 0)
+        {
+            dccp->socStatusEmbedded =
+                CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE |
+                ((pMsg->msg.ethReply.param[0] & 0xffff) << 16);
+        }
+        dccp->socStatusInProgress  = SYS_FALSE;
+        dccp->socStatusLastTransID = 0;
+    }
+#endif
+}
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_dvr.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_dvr.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1611 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_dvr.c
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+// Mailbox version number
+#define VER_NUM                  0x00
+
+// Queue Constants
+#define CMD_QUEUE_MASK           (CLNK_MBX_CMD_QUEUE_SIZE-1)
+#define SWUNSOL_QUEUE_MASK       (CLNK_MBX_SWUNSOL_QUEUE_SIZE-1)
+
+// Transaction ID Constants
+#define HOST_ORIG_BIT            0x80UL
+#define UNSOL_TYPE_BIT           0x40UL
+
+#if ECFG_CHIP_ZIP1
+  #define IS_READ_INTERRUPT(y)     ((y) & \
+          (CLNK_REG_PCI_READ_MBX_SEM_SET_BIT | CLNK_REG_PCI_SW_INT_1_BIT))
+  #define IS_WRITE_INTERRUPT(y)    ((y) & (CLNK_REG_PCI_WRITE_MBX_SEM_CLR_BIT))
+  #define IS_SW_UNSOL_INTERRUPT(x) ((x) & CLNK_REG_PCI_SW_INT_1_BIT)
+  #define ACK_SW_UNSOL_INTERRUPT(x) \
+          { clnk_reg_write((x)->dc_ctx, CLNK_REG_SLAVE_1_MAP_ADDR, (x)->swUnsolQueueSlaveMap); }
+#else
+  #define IS_READ_INTERRUPT(y)     1
+  #define IS_WRITE_INTERRUPT(y)    1
+  #define IS_SW_UNSOL_INTERRUPT(x) 1
+  #define ACK_SW_UNSOL_INTERRUPT(x) {}
+#endif // ECFG_CHIP_ZIP1
+
+#define UMSG_ELEMENT(x, y)      ((x) + offsetof(Clnk_MBX_SwUnsolQueueEntry_t, y))
+
+
+/*******************************************************************************
+*                             D a t a   T y p e s                              *
+********************************************************************************/
+
+/*******************************************************************************
+*                             C o n s t a n t s                                *
+********************************************************************************/
+
+/*******************************************************************************
+*                             G l o b a l   D a t a                            *
+********************************************************************************/
+
+/*******************************************************************************
+*                       M e t h o d   P r o t o t y p e s                      *
+********************************************************************************/
+
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx );
+static int Clnk_MBX_wqt_condition( void *vmp );
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data);
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                           Clnk_MBX_Msg_t     *pMsg,
+                           SYS_UINT8          transID);
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID);
+static void Clnk_MBX_Init_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx);
+#endif
+
+/*******************************************************************************
+*                      M e t h o d   D e f i n i t i o n s                     *
+********************************************************************************/
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the Mailbox Module.
+*
+* Inputs:
+*       pMbx  - Pointer to the mailbox
+*       dcctx - pointer to the control context
+*       type  - Type of mailbox (Ethernet or MPEG)
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       It is assumed that sufficient time will elapse between the
+*       RST_STATE_INIT_CCPU and RST_STATE_INIT_MBX states of the
+*       reset state machine to allow the CCPU to initialize the
+*       mailbox registers before checking them in this routine
+*
+*******************************************************************************/
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type)
+{
+    SYS_UINT32 reg;
+    dc_context_t *dccp = (dc_context_t *)dcctx ;
+
+    //HostOS_PrintLog(L_ERR, "Clnk_MBX_Initialize\n" );
+    // Free any wqts
+    Clnk_MBX_Free_wqts( pMbx ) ;
+
+    // Initialize mailbox block
+    HostOS_Memset(pMbx, 0, sizeof(Clnk_MBX_Mailbox_t));
+
+    pMbx->dc_ctx             = dccp;
+    pMbx->type               = type;
+    pMbx->cmdCurrTransID     = HOST_ORIG_BIT;
+
+    // Initialize mailbox locks
+    pMbx->mbx_lock          = dccp->mbx_cmd_lock_link ; 
+    pMbx->swUnsolLock       = dccp->mbx_swun_lock_link ;
+
+    // Initialize register offsets
+    if (pMbx->type == CLNK_MBX_ETHERNET_TYPE)
+    {
+        pMbx->writeMbxCsrOffset  = CLNK_REG_MBX_WRITE_CSR;
+        pMbx->readMbxCsrOffset   = CLNK_REG_MBX_READ_CSR;
+        pMbx->writeMbxRegOffset  = CLNK_REG_MBX_REG_1;
+        pMbx->readMbxRegOffset   = CLNK_REG_MBX_REG_9;
+        pMbx->readMbxSize        = MAX_MBX_MSG;
+        pMbx->writeMbxSize       = MAX_MBX_MSG;
+    }
+#if 0
+    HostOS_PrintLog(L_INFO, "Initialize register offsets\n");
+    HostOS_PrintLog(L_INFO, "unsol  = %x\n",pMbx->pSwUnsolQueue);
+    HostOS_PrintLog(L_INFO, "writeMbxCsrOffset = %x\n",CLNK_REG_MBX_WRITE_CSR);
+    HostOS_PrintLog(L_INFO, "readMbxCsrOffset = %x\n",CLNK_REG_MBX_READ_CSR);
+    HostOS_PrintLog(L_INFO, "writeMbxRegOffset = %x\n",CLNK_REG_MBX_REG_1);
+    HostOS_PrintLog(L_INFO, "readMbxRegOffset = %x\n",CLNK_REG_MBX_REG_9);
+    HostOS_PrintLog(L_INFO, "readMbxSize  = %x\n",MAX_MBX_MSG);
+    HostOS_PrintLog(L_INFO, "writeMbxSize = %x\n",MAX_MBX_MSG);
+#endif
+    // allocate all wqts, setup timers and wait queues
+    Clnk_MBX_Alloc_wqts( pMbx ) ;
+
+    // Initialize the hardware mailbox
+    Clnk_MBX_Init_Hw_Mailbox(pMbx);
+
+    // Confirm that the CCPU has initialized the mailbox registers
+    // Register was cleared by host driver before CCPU was released,
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, &reg);
+//    if (0 == reg) 
+//        return (~SYS_SUCCESS);
+    
+    pMbx->mbxOpen = SYS_TRUE;
+    
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Frees all Mailbox message wqts.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( mp->msg_wqt )
+        {
+            HostOS_wqt_timer_del( mp->msg_wqt ) ;
+
+            HostOS_wqt_free( mp->msg_wqt );
+            mp->msg_wqt = 0 ;
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Terminates the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx)
+{
+    // Terminate mailbox lock
+    HostOS_TermLock(pMbx->mbx_lock);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       int                  Driver option to control
+*       SYS_UINT32           Register offset or pointer to register offsets
+*       SYS_UINT32           Register value or pointer to register values
+*       SYS_UINT32           Length of data for bulk data
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       Driver option                     Parameters
+*       -------------                     ----------
+*       CLNK_MBX_CTRL_ENABLE_INTERRUPT    reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_DISABLE_INTERRUPT   reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_CLEAR_INTERRUPT     reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_Q      reg    - Not used
+*                                         val    - Pointer to emb mem
+*                                         length - Number of entries
+*       CLNK_MBX_CTRL_SET_REPLY_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_UNSOL_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*
+*
+*******************************************************************************/
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length)
+{
+    int status = SYS_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_Q:
+            // Initialize the software unsolicited queue
+        #if ECFG_CHIP_ZIP1
+            pMbx->swUnsolQueueSlaveMap = (val & 0x0ffc0000) |
+                                         CLNK_REG_ADDR_TRANS_ENABLE_BIT;
+            pMbx->pSwUnsolQueue        =  val & 0x0003ffff;
+        #else
+            pMbx->pSwUnsolQueue        = val;
+        #endif 
+            pMbx->swUnsolQueueSize     = length;
+            pMbx->swUnsolReadIndex     = 0;
+            break;
+
+        case CLNK_MBX_CTRL_SET_REPLY_RDY_CB:
+            // Set the reply ready callback function   MbxReplyRdyCallback
+            pMbx->replyRdyCallback = (Clnk_MBX_RdyCallback)val;
+            pMbx->replyParam       = (void *)length;
+            break;
+
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB:
+            // Set the unsolicited ready callback function   MbxSwUnsolRdyCallback
+            pMbx->swUnsolRdyCallback = (Clnk_MBX_SwUnsolRdyCallback)val;
+            pMbx->swUnsolParam       = (void *)length; // context at this point
+            break;
+
+        default:
+            status = -SYS_BAD_MSG_TYPE_ERROR;
+            break;
+    }
+    return (status);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the interrupt for the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       SYS_UINT32           PCI interrupt status register
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus)
+{
+
+    // Check if hardware mailbox has command response
+    if (IS_READ_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Read_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox has unsolicited msg
+    if ( IS_SW_UNSOL_INTERRUPT(pciIntStatus) )
+    {
+        Clnk_MBX_Unsol_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox can take a command
+    if (IS_WRITE_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Write_ISR(pMbx);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Sends a mailbox message.
+*
+* Inputs:   pMbx     - Pointer to the mailbox
+*           pMsg     - Pointer to the message to send
+*           pTransID - Pointer to place to return the transaction ID
+*           len      - length of message in longs
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR     - mailbox not open
+*           -SYS_INVALID_ARGUMENT_ERROR    - invalid request, length
+*           -SYS_OUT_OF_SPACE_ERROR        - queue full, message dropped
+*
+*******************************************************************************/
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len)
+{
+    SYS_UINT32 index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if((len < 1) || (len > MAX_MBX_MSG))
+    {
+        HostOS_PrintLog(L_ERR, "warning: invalid mbx request: %d words\n", len);
+        return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    /*  
+        Check if mailbox is (too) full.  
+        Note that we always leave two entries empty.
+        This is the only place Send messages are queued so it's safe to say
+        that this is the only place where tail may attempt to overrun head.
+    */
+    if (((pMbx->cmdTailIndex+3) & CMD_QUEUE_MASK) == pMbx->cmdHeadIndex)
+    {
+        // mailbox full - log queuing error
+        HostOS_Unlock(pMbx->mbx_lock);
+        return (-SYS_OUT_OF_SPACE_ERROR);
+    }
+
+    // Save the transaction ID for the command
+    *pTransID = pMbx->cmdCurrTransID;    // push the transID back to the caller
+    index = pMbx->cmdTailIndex;
+    pMbx->cmdQueue[index].transID    = *pTransID;
+    pMbx->cmdQueue[index].isReplyRdy = SYS_FALSE;
+    pMsg->msg.cmdCode |=                                        // byte 0 = cmd
+                         CLNK_MBX_SET_TRANS_ID(*pTransID) |     // byte 1
+                         CLNK_MBX_SET_VER_NUM(VER_NUM)    |     // byte 2 lo nybl
+                         CLNK_MBX_SET_PORT(pMbx->type)    |     // byte 2 hi nybl
+                         CLNK_MBX_SET_LEN(len);                 // byte 3  (num longs)
+
+    // Copy message to into mail box buffer
+    HostOS_Memcpy(&pMbx->cmdQueue[index].sendMsg, pMsg, len * sizeof(SYS_UINT32));
+
+    // Check if Q empty and hardware mailbox is in use
+    if ((pMbx->cmdTailIndex == pMbx->cmdHeadIndex) &&
+        Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, pMsg);
+
+        // Effectively Q the msg. There might be a response
+        // Since the Q is empty move the head along, too, so head will stay at or ahead of tail
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+    else
+    {
+        //HostOS_PrintLog(L_NOTICE, "SendMsg to Q  tid=%02xx\n", *pTransID);
+
+        // Add entry to tail of command queue
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+
+    // Generate new transaction ID (make sure host originated bit is set)
+    pMbx->cmdCurrTransID++;
+    pMbx->cmdCurrTransID |= HOST_ORIG_BIT;
+
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+    // Automatically generate reply
+    AutoReplyMsg(pMbx);
+#endif
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Purpose:  Receives a sw unsolicited mailbox message.
+*           This reads messages that have not been internally
+*           consumed from the sw unsolicited Q.
+*           There may not be any such messages.
+*           There may have been a Q overrun.
+*
+* Imports:  pMbx    - Pointer to the mailbox
+*           pbuf    - Pointer to a kernel buffer to get the message
+*
+* Exports:  0           - success, no more messages
+*           -SYS_DIR_NOT_EMPTY_ERROR  - success, more messages
+*           -SYS_BAD_MSG_TYPE_ERROR   - no message, try again later
+*           -SYS_INPUT_OUTPUT_ERROR   - queue overrun, oldest message returned
+*                                       and the overrun error is cleared
+*           -SYS_INVALID_ADDRESS_ERROR- mailbox not open
+*                                       sw unsolicited Q not setup
+*                                       other
+*
+*******************************************************************************/
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf)
+{                   
+    SYS_UINT32      index;
+    int             error = 0 ;
+
+    if( !pMbx->mbxOpen)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    // Check if software unsolicited queue has been created
+    if( !error && pMbx->pSwUnsolQueue == 0)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    if( !error )
+    {
+        if( pMbx->swUnsolCount ) // we have message     
+        {
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // Copy message to receive buffer
+            index = pMbx->swUnsolHeadIndex;
+            HostOS_Memcpy(pbuf, 
+                          &pMbx->swUnsolQueue[index].msg.msg.maxMsg.msg, 
+                          MAX_UNSOL_MSG * sizeof(SYS_UINT32));
+
+            pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            pMbx->swUnsolCount-- ;          // uncount an item taken
+
+            if( pMbx->swUnsolCount ) // we have more
+            {
+                error = -SYS_DIR_NOT_EMPTY_ERROR ;
+            }
+            if( pMbx->swUnsolOverrun ) // we have overrun 
+            {
+                error = -SYS_INPUT_OUTPUT_ERROR ;
+                pMbx->swUnsolOverrun = 0 ;   // and clear it
+            }
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+        }
+        else
+        {
+            error = -SYS_BAD_MSG_TYPE_ERROR ;
+        }
+    }
+    return( error );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sends and receives a mailbox message.
+*
+* Inputs:   pMbx        - Pointer to the mailbox
+*           pSendMsg    - Pointer to the message to send
+*           pRcvMsg     - Pointer to the buffer for receiving message
+*           len         - length of send message
+*           timeoutInUs - Time to wait for reply in ms
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR    - I/O error
+*           -SYS_TIMEOUT_ERROR         - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs)
+{
+    SYS_UINT8                   transID;
+    int                         status;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    if (!pMbx->mbxOpen)
+    {
+        return (-SYS_INVALID_ADDRESS_ERROR);
+    }
+
+    // Send message    (get transaction ID)
+    status = Clnk_MBX_SendMsg(pMbx, pSendMsg, &transID, len);
+    //HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg send status=%d , transid=%x.\n", status,transID );
+    if (status != SYS_SUCCESS)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to send msg!!\n");
+        return (status);
+    }
+
+    // setup to wait
+    HostOS_Lock(pMbx->mbx_lock);
+
+    if( !Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // msg not ready - start wait
+        mp = &pMbx->cmdQueue[transID & CMD_QUEUE_MASK] ;
+        mp->isReplyTimedOut = 0 ;
+        HostOS_wqt_timer_set_timeout( mp->msg_wqt, HostOS_timer_expire_seconds(2));
+        HostOS_wqt_timer_add( mp->msg_wqt);
+
+        HostOS_Unlock(pMbx->mbx_lock);
+
+        HostOS_wqt_waitq_wait_event_intr( mp->msg_wqt,
+                                          Clnk_MBX_wqt_condition,
+                                          mp );
+
+        // done waiting
+        //HostOS_PrintLog(L_INFO, "We had to sleep!!\n");
+        HostOS_wqt_timer_del( mp->msg_wqt );
+    }
+    else
+    {
+        // msg ready already
+        //HostOS_PrintLog(L_INFO, "Msg read already - did not have to sleep\n");
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+
+    // msg should be ready now
+    if( Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // Get the reply
+        status = Clnk_MBX_RcvMsg(pMbx, pRcvMsg, transID);
+    }
+    else
+    {
+        status = -SYS_TIMEOUT_ERROR ;  // timeout - no message
+    }
+
+    return (status);
+}
+
+
+// define U_SHOW_TRAFFIC to see unsol traffic
+#define xU_SHOW_TRAFFIC
+// define Q_SHOW to see the unsol Q
+#define xQ_SHOW
+// define Q_RESYNC to try to resync the unsol Q for when the SOC overruns it
+#define xQ_RESYNC
+
+#ifdef Q_SHOW
+extern int strcpy(char *, const char *) ;
+extern int strcmp(const char *, const char *) ;
+extern unsigned long volatile jiffies;
+#endif
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the read interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+    SYS_UINT32          offset, regVal;
+    SYS_UINT8           transID, index ;
+
+    if (Clnk_MBX_Read_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Get the transaction ID
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &offset);
+#if ECFG_CHIP_ZIP1
+        offset &= 0x3ffff;
+#endif
+        clnk_reg_read(pMbx->dc_ctx, offset, &regVal);
+        transID = regVal & 0xff;
+
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_Read_ISR transid=%d \n", transID );
+        if (transID & HOST_ORIG_BIT)
+        {
+            index = transID & CMD_QUEUE_MASK;
+
+            // Lock the mailbox
+            HostOS_Lock(pMbx->mbx_lock);
+
+            // Check if transaction ID is valid
+            if (pMbx->cmdQueue[index].transID != transID)
+            {
+                // Toss message if transaction ID is not valid
+                Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);
+
+                // Unlock the mailbox
+                HostOS_Unlock(pMbx->mbx_lock);
+
+                return;
+            }
+
+            // Read message from hardware mailbox
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, &pMbx->cmdQueue[index].rcvMsg);
+
+            // Mark reply as received
+            pMbx->cmdQueue[index].isReplyRdy = SYS_TRUE;
+//HostOS_PrintLog(L_INFO, "In ClnkMBX_READ_ISR  replyRdy = true\n");
+            // Call reply ready callback function
+            if (pMbx->replyRdyCallback != SYS_NULL)
+            {           // MbxReplyRdyCallback
+                pMbx->replyRdyCallback(pMbx->replyParam,
+                                       &pMbx->cmdQueue[index].rcvMsg);
+            }
+
+            // Unlock the mailbox
+            HostOS_Unlock(pMbx->mbx_lock);
+            HostOS_wqt_waitq_wakeup_intr( pMbx->cmdQueue[index].msg_wqt );
+
+        }
+        else
+        {
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);       // discard this type of unsolicited msg
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the write interrupt.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+
+    if (Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if command queue is emtpy
+        if (pMbx->cmdHeadIndex == pMbx->cmdTailIndex)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return;
+        }
+
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, &pMbx->cmdQueue[pMbx->cmdHeadIndex].sendMsg);
+
+        // Remove entry from head of command queue
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the unsolicited message (read) interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx )
+{
+    SYS_UINT32          tid;
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership, i, *up, *qp, type ;
+    int                 consumed ;
+    Clnk_MBX_Msg_t      mbuf;
+#ifdef Q_SHOW
+    int                 hit ;
+    SYS_UINT32          pSwUnsolMsgX;
+    static char         ox[SW_UNSOL_HW_QUEUE_SIZE+1] ;
+    static SYS_UINT8    dexx ;
+#endif
+    // Check if software unsolicited queue has been created
+    if (pMbx->pSwUnsolQueue == 0)
+    {
+        return;
+    }
+
+    // Process the unsolicited messages
+
+    ACK_SW_UNSOL_INTERRUPT(pMbx);
+#if 1
+// for loop with clnk_reg_read caused hang
+    for ( ; ; )
+    {
+        // get the current index
+        index = pMbx->swUnsolReadIndex;
+
+        // Check ownership bit
+        pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+        clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+        if (!ownership)
+        {
+            break ;
+        }
+#if 1
+        // we have a message, process it
+
+        // Generate transaction ID (make sure host originated bit is clear)
+        pMbx->swUnsolCurrTransID = index;
+        pMbx->swUnsolCurrTransID &= ~HOST_ORIG_BIT;
+        pMbx->swUnsolCurrTransID |= UNSOL_TYPE_BIT;
+        tid = pMbx->swUnsolCurrTransID;
+
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, transID), tid);
+
+        // process the message
+
+        // copy from hw Q to local msg buffer
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+#if 1
+        for (i = 0; i < MAX_UNSOL_MSG; i++, up++)
+        {
+            clnk_reg_read(pMbx->dc_ctx,
+                            UMSG_ELEMENT(pSwUnsolMsg, msg[0]) + (i << 2),
+                            up);
+        }
+#endif
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+        type = *up ;
+
+        consumed = 0 ;
+#if 1
+        if (pMbx->swUnsolRdyCallback != SYS_NULL)      // if there's a callback, call it
+        {               // MbxSwUnsolRdyCallback
+            consumed = pMbx->swUnsolRdyCallback(pMbx->swUnsolParam, &mbuf);
+#ifdef U_SHOW_TRAFFIC
+            if( consumed )
+            {
+                HostOS_PrintLog(L_NOTICE, "sw unsol msg, type=%d. consumed=%d tid=%xx\n",
+                                type, consumed, tid );
+            }
+#endif
+        }
+#endif
+#if 1
+        if( !consumed )
+        {
+            // queue msg in sw Q
+
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // copy from buffer to sw Q
+            qp = &pMbx->swUnsolQueue[pMbx->swUnsolTailIndex].msg.msg.maxMsg.msg[0] ; 
+            for (i = 0; i < MAX_UNSOL_MSG; i++)
+            {
+                *qp++ = *up++ ; 
+            }
+            up = &mbuf.msg.maxMsg.msg[0] ; 
+
+            if( pMbx->swUnsolCount == SW_UNSOL_HW_QUEUE_SIZE )
+            {  // if max count pMbx->swUnsolOverrun = 1 ;      // flag an error
+                // move head to oldest
+                pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            }
+            else
+            {
+                pMbx->swUnsolCount++ ;          // count an item added
+            }
+            // move tail off newest
+            pMbx->swUnsolTailIndex = (pMbx->swUnsolTailIndex+1) & SWUNSOL_QUEUE_MASK;
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+#ifdef U_SHOW_TRAFFIC
+            HostOS_PrintLog(L_NOTICE, "sw unsol msg Qd, type=%d. cnt=%d. tid=%xx\n",
+                            *up, pMbx->swUnsolCount, tid );
+#endif
+        }
+
+#endif
+        // Clear ownership
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), 0);
+
+        // Increment HW's read index
+        pMbx->swUnsolReadIndex = (pMbx->swUnsolReadIndex+1) % pMbx->swUnsolQueueSize;
+#endif
+    }
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to read
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &regVal);
+//HostOS_PrintLog(L_INFO, "HostCheckMailboxAvailToRead: readMbxCsrOffset = %x, regVal = %x \n",
+//                pMbx->readMbxCsrOffset, regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) != 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to write.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to write, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to write
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) == 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the write cmd message mailbox is empty.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 = empty, 0 = !empty
+*
+*******************************************************************************/
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx)
+{
+    int mt ;
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    // Check if command queue is emtpy
+    mt = (pMbx->cmdHeadIndex == pMbx->cmdTailIndex) ;
+    
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+    return( mt ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware unsolicited mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership ;
+
+    ownership = 0 ;
+
+    // get the current index
+    index = pMbx->swUnsolReadIndex;
+
+    // Check ownership bit
+    pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+//    HostOS_PrintLog(L_INFO, "In Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready: pMbx->pSwUnsolQueue=%x, index=%d, sizeofSwUnsolEntry=%d\n",
+//                    pMbx->pSwUnsolQueue, index , sizeof(Clnk_MBX_SwUnsolQueueEntry_t));
+    clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+//    clnk_reg_read(pMbx->dc_ctx, 0x8c00b204, &ownership);
+if (ownership == 1)
+    return(1);
+else 
+    return(0);
+}
+
+
+/*******************************************************************************
+*
+* Description:
+*       Allocates all Mailbox message wqts.
+*       Sets up the timer and wq.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( !mp->msg_wqt ) {
+            mp->msg_wqt = HostOS_wqt_alloc( );
+            if( mp->msg_wqt )
+            {
+                HostOS_wqt_waitq_init( mp->msg_wqt );
+                HostOS_wqt_timer_init( mp->msg_wqt );
+                HostOS_wqt_timer_setup( mp->msg_wqt , 
+                                        Clnk_MBX_msg_timer, 
+                                        (SYS_UINTPTR)mp ) ;
+            }
+            else
+            {
+                HostOS_PrintLog(L_ERR, "Cannot allocate wqt.\n" );
+                break ;
+            }
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Wait q condition expression check.
+*
+* Inputs:   vmp - Pointer to a mailbox message
+*
+* Outputs:  true/false
+*
+*******************************************************************************/
+static int Clnk_MBX_wqt_condition( void *vmp )
+{
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+    int cond ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)vmp ;
+
+    cond = (mp->isReplyTimedOut || mp->isReplyRdy) ;
+//HostOS_PrintLog(L_NOTICE, "<wqt> cond=%d. to=%d. rdy=%d.\n",
+//                cond, mp->isReplyTimedOut, mp->isReplyRdy );
+/*
+if (cond)
+    HostOS_PrintLog(L_INFO, "reply = %x\n", mp->isReplyRdy);
+*/
+    return( cond ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       msg timer expiration function.
+*
+* Inputs:
+*       data    - Pointer to the mailbox message with timeout
+*
+* Outputs:
+*
+*******************************************************************************/
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data)
+{
+    Clnk_MBX_CmdQueueEntry_t *mp ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)data ;
+    mp->isReplyTimedOut = 1 ;
+    HostOS_wqt_timer_del( mp->msg_wqt );
+    HostOS_wqt_waitq_wakeup_intr( mp->msg_wqt );
+//HostOS_PrintLog(L_NOTICE, "<msgtimer> expired\n" );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Receives a mailbox message.
+*
+* Inputs:   pMbx    - Pointer to the mailbox
+*           pMsg    - Pointer to the buffer for receiving message
+*           transID - Transaction ID of message to receive
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR  - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR     - I/O error
+*           -SYS_TIMEOUT_ERROR          - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                    Clnk_MBX_Msg_t     *pMsg,
+                    SYS_UINT8          transID)
+{
+    SYS_UINT32      index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if (transID & HOST_ORIG_BIT)
+    {
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg recv tid=%02xx\n", transID);
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if the transaction ID is still valid
+        index = transID & CMD_QUEUE_MASK;
+        if (pMbx->cmdQueue[index].transID != transID)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_INPUT_OUTPUT_ERROR);
+        }
+
+        // Check if reply has been received
+        if (!pMbx->cmdQueue[index].isReplyRdy)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_TIMEOUT_ERROR);
+        }
+
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg tid=%02xx\n", transID );
+
+        // Copy message to receive buffer
+        HostOS_Memcpy(pMsg, &pMbx->cmdQueue[index].rcvMsg, sizeof(*pMsg));
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+//HostOS_PrintLog(L_NOTICE, "<rm>\n" );
+    }
+    else
+    {
+        return (-SYS_INPUT_OUTPUT_ERROR);
+    }
+
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if a reply has been received.
+*
+* Inputs:
+*       pMbx    - Pointer to the mailbox
+*       transID - Transaction ID of message to check
+*
+* Outputs:
+*       1 if a reply has been received, 0 otherwise
+*
+* Notes:
+*       None
+*
+*******************************************************************************/
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID)
+{
+    SYS_UINT32  index;
+    int         rdy ;
+
+    rdy = 123456 ;
+
+    // Check if transaction ID is valid
+    if ((transID & HOST_ORIG_BIT) == 0)
+    {
+        return (0);
+    }
+
+    // we're just reading, no lock
+
+    index = transID & CMD_QUEUE_MASK;
+    if (pMbx->cmdQueue[index].transID != transID)
+    {
+        return (0);
+    }
+
+    //HostOS_PrintLog(L_NOTICE, "x\n" );
+    rdy = (volatile int)(pMbx->cmdQueue[index].isReplyRdy) ;
+    //HostOS_PrintLog(L_NOTICE, "x%d\n", rdy );
+
+    // Check if reply has been received
+    if( rdy )
+    {
+        //HostOS_PrintLog(L_INFO, "reply has been received \n");
+        return (1);
+    }
+        //HostOS_PrintLog(L_INFO, "reply has not been received \n");
+    return (0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Intializes the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+static void Clnk_MBX_Init_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx)
+{
+#if 0
+    SYS_UINT32 i;
+    SYS_UINT32 reg;
+
+    // Initialize mailbox
+
+    // clear write ready
+    clnk_reg_write(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, 0);
+
+    // clear write mailbox
+    reg = pMbx->writeMbxRegOffset;
+    for (i = 0; i < pMbx->writeMbxSize; i++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, 0);
+        reg += 4;
+    }
+
+    // clear read ready
+    clnk_reg_write(pMbx->dc_ctx, pMbx->readMbxCsrOffset, 0);
+
+    // clear read mailbox
+    reg = pMbx->readMbxRegOffset;
+    for (i = 0; i < pMbx->readMbxSize; i++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, 0);
+        reg += 4;
+    }
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clears the read mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &val);
+    val &= ~CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->readMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sets the write hardware mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &val);
+    val |= CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Reads a message from the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the buffer for reading message
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+
+    // Read message from mailbox
+    if (pMsg != SYS_NULL)
+    {
+        SYS_UINT32 reg, lastReg;
+
+        // Read location of mailbox message
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+        reg &= 0x0003ffff;
+#endif
+
+        // Read first word
+        clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        len = CLNK_MBX_GET_REPLY_LEN(*pMsg);
+        reg += 4;
+        pMsg++;
+        
+        if((len < 1) || (len > MAX_MBX_MSG))
+        {
+            HostOS_PrintLog(L_ERR, "warning: invalid mbx reply: %d words\n", len);
+            HostOS_Memset(pMsg, 0, sizeof(*pMsg));
+            return;
+        }
+
+        // Read subsequent words, if necessary
+        lastReg = reg + ((len-1) * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+
+#if 0
+        SYS_UINT32 reg = pMbx->readMbxRegOffset;
+        SYS_UINT32 lastReg = reg + (pMbx->readMbxSize * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+#endif
+    }
+
+    Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(pMbx);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Writes a message to the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the message to write
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+    SYS_UINT32  reg, lastReg;
+
+    // Read location of mailbox message
+//HostOS_PrintLog(L_INFO, "In Clnk_MBX_Write_Hw_Mailbox: writeMbxRegOffset=%x\n",pMbx->writeMbxRegOffset);
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+    reg &= 0x0003ffff;
+#endif
+
+    // Write message to mailbox
+    len = CLNK_MBX_GET_CMD_LEN(*pMsg);
+    lastReg = reg + (len * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+//HostOS_PrintLog(L_INFO, "C_MBX_Wr_Hw_Mbx a=%08x data=%08x\n", reg, *pMsg );
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+
+#if 0
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  reg = pMbx->writeMbxRegOffset;
+    SYS_UINT32  lastReg = reg + (8 * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+#endif
+
+    Clnk_MBX_Write_Hw_Mailbox_Set_Ready(pMbx);
+}
+
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static 
+void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check the write semaphore bit
+    for ( ; ; )
+    {
+        clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &regVal);
+        if (regVal & CLNK_REG_MBX_SEMAPHORE_BIT)
+        {
+            break;
+        }
+    }
+
+    // Loop back message
+    clnk_reg_read(pMbx->dc_ctx,  CLNK_REG_MBX_REG_1,  &regVal);
+    regVal >>= 8;
+    regVal &= 0xff;
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_9,  regVal);
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, 0);
+
+    // Set the read semaphore bit
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_READ_CSR, CLNK_REG_MBX_SEMAPHORE_BIT);
+}
+#endif
+
+
+//BRJ temp to test sending of mailbox message and recieving response via interrupt
+#ifdef SEND_MBX_MSG_TEST
+int Clnk_MBX_SendTestMsg( void* pvMailBox )
+{
+    ClnkDef_MyNodeInfo_t NodeInfo;
+    Clnk_MBX_Mailbox_t* pMbx;
+    SYS_UINT32  u32Val;
+    pMbx = ( Clnk_MBX_Mailbox_t* )pvMailBox;
+
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &u32Val);
+    if( 0 == ( CLNK_REG_MBX_SEMAPHORE_BIT & u32Val))
+    {
+        // mailbox is available to write to
+        // get interrupt status for debugging
+#if !ECFG_CHIP_ZIP1
+        clnk_reg_read(pMbx->dc_ctx, CLNK_MBX_INTERRUPT_REG, &u32Val);
+#endif // !ECFG_CHIP_ZIP1
+        // set command
+        NodeInfo.ClearStats = 0;
+        u32Val = CLNK_ETH_CTRL_GET_MY_NODE_INFO;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, u32Val);
+        // set params 
+        u32Val = CLNK_MBX_SET_CMD( CLNK_MBX_ETH_DATA_BUF_CMD ); 
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_2, u32Val);
+    
+        u32Val = sizeof(ClnkDef_MyNodeInfo_t);
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_3, u32Val);
+    
+        u32Val = NodeInfo.ClearStats;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_4, u32Val);
+    
+        // tell clink we wrote a message
+        u32Val = CLNK_REG_MBX_SEMAPHORE_BIT;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, u32Val);
+    }
+    return (SYS_SUCCESS);
+}
+#endif // SEND_MBX_MSG_TEST
+
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread main loop function. it processes mbox messages etc.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_Kthread_Mainloop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+  
+    while(1)
+    {
+        if(dccp->clnkThreadStop == CLNK_TASK_RUNNING)
+        {
+            //PCI mode, CAM processing
+            //Clnk_ETH_Cam_Proc(dccp);
+        
+            //MBOX processing
+            Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+            Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+            //Unsol msg processing
+            if(Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ))
+            {
+               Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+            }
+        }
+        else
+            dccp->clnkThreadStop = CLNK_TASK_SLEEP;
+
+        /* Sleep */
+        HostOS_msleep_interruptible(TT_TASK_SLEEP); 
+
+        if(HostOS_signal_pending(SYS_NULL) != 0)
+            break;
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread initialization.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Init(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret;
+    char name[20] = "kclinkd";
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Init(): Entry dccp 0x%x \n", data);
+
+    if(dccp->clnkThreadID != 0)
+    {   
+        if(dccp->clnkThreadStop == CLNK_TASK_STOPPED || dccp->clnkThreadStop == CLNK_TASK_SLEEP)
+            dccp->clnkThreadStop = CLNK_TASK_RUNNING; //Running
+        return 0;
+    }
+
+    ret = HostOS_thread_start(&dccp->clnkThreadID, (char *)name, (SYS_VDFCVD_PTR)Clnk_Kthread_Mainloop, data);
+    if(ret < 0)
+    {
+        HostOS_PrintLog(L_ERR, "Failed to start kclinkd thread! \n");
+        dccp->clnkThreadID = 0;
+        return -1;
+    }
+    //else
+    //    HostOS_PrintLog(L_INFO, "Start kclinkd thread %d\n", dccp->clnkThreadID);
+
+    dccp->clnkThreadStop = CLNK_TASK_RUNNING;
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Stop Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Stop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int loopCnt = 0;
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Entry \n");
+
+    if(dccp->clnkThreadID != 0)
+    {
+        dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+
+        // Wait thread to stop,
+        while(1)
+        {
+            if(dccp->clnkThreadStop == CLNK_TASK_SLEEP || loopCnt > 10)
+                break;
+
+            //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Delay %d \n", loopCnt);
+            HostOS_msleep_interruptible(1); // 1ms
+            loopCnt++;
+        }
+    }
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Kill Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Kill(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret = 0;
+    
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Kill(): Entry \n");
+
+    ret = HostOS_thread_stop(dccp->clnkThreadID);
+
+    if(ret != 0)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to stop kclnkd thread! (thread ID %d)\n", dccp->clnkThreadID);
+        return -1;
+    }
+
+    dccp->clnkThreadID = 0;
+    dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+    return 0;
+}
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_ttask.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_ttask.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_ttask.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_ttask.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,241 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_ttask.c
+*
+* Description: mailbox timer task support 
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task );
+
+
+
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT timer expiration function.
+*
+*   Imports:    data - timer's opaque data, driver control context
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+//    Clnk_MBX_Mailbox_t *pMbx = &dccp->mailbox; 
+#if 0 
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Pass\n");
+    else
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Fail\n");
+
+#endif
+#if 0
+
+    // detect command message HW Q ready - rx
+  //  HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -rx\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // detect command message HW Q ready - tx
+   //     HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+            clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+        }
+    }
+
+    // detect unsolicited message ready - rx
+    //    HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+     //   HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_umtask_link ) ;
+    }
+#endif
+#if 0
+    // detect command message HW Q ready - rx
+//    HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+    }
+
+    // detect command message HW Q ready - tx
+ //       HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+  //      HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+        }
+    }
+#endif
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+#if 1
+//    HostOS_Lock(pMbx->swUnsolLock);
+    // detect unsolicited message ready - rx
+//        HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+//        HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+    }
+#endif
+ //  HostOS_Unlock(pMbx->swUnsolLock);
+
+    // go again
+    if( !dccp->tt_stopping ) {
+        HostOS_timer_mod( dccp->tt_timer_link, HostOS_timer_expire_ticks(TT_TASK_TIMEOUT) );
+    }
+}
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT command message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+//HostOS_PrintLog(L_INFO, "In clnketh_tt_cmtask() \n" );
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+#if 1
+    // possibly re-schedule
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // possibly re-schedule
+    if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+#endif
+}
+
+/****************************************************************************
+*           
+*   Purpose:    TT unsolicited message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+    Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+
+    // no re-schedule as Handle UnsolInterrupt already sucks up multiple messages 
+}
+
+/****************************************************************************
+*           
+*   Purpose:    Possibly reschedules a TT tasklet.
+*
+*   Imports:    dccp - control context
+*               task - pointer to task structure
+*
+*   Exports:    
+*
+*STATIC**********************************************************************/
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task )
+{
+
+    // possibly re-schedule
+    if( !dccp->tt_stopping )
+    {
+        HostOS_task_schedule( task ) ;
+    }
+
+}
+
+
+
+
+
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_abs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_abs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,116 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+/**
+*  Purpose:    Converts a driver control context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    dccp - pointer to a device control context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dc_to_dg( void *dccp )
+{
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dgcp = ((dc_context_t *)dccp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dc_context_t *)dccp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+
+/**
+*  Purpose: Converts a driver control context pointer to
+*           a driver kernel context pointer.
+*
+*           This is the only way to get back to the dk!           
+*
+*  Imports: dccp - pointer to a device control context
+*
+*  Exports: pointer to the driver kernel context
+*
+*PUBLIC**************************/
+void *dc_to_dk( void *dccp )
+{
+    void *dkcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dkcp = ((dc_context_t *)dccp)->p_dk_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dk\n" );
+        dkcp = 0 ;
+    }
+#else
+    dkcp = ((dc_context_t *)dccp)->p_dk_ctx ;
+#endif
+
+    return( dkcp ) ;
+}
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_setup.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/ctx_setup.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,261 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp );
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base );
+
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the context structures for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our context
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*
+* Outputs:
+*       0 or error code
+*
+*STATIC***************************************************************************/
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+
+    // Allocate the contexts
+
+    dgcp = ctx_alloc_dg_context();
+    if( !dgcp )
+    {
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    dccp = (dc_context_t *)ctx_alloc_dc_context();
+    if( !dccp )
+    {
+        ctx_free_dg_context( dgcp ) ;
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    // linkage init
+    *ddcp_dgcp     = dgcp;   // link dd to dg
+    dccp->p_dg_ctx = dgcp;   // link dc to dg
+    ctx_link_dg_context( dgcp, ddcp, dccp ) ;
+
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*STATIC***************************************************************************/
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base )
+{
+    unsigned int *linkarray[4], **vp ;
+
+    dccp->p_dk_ctx = dkcp ;  // reverse link to the kernel context
+    dccp->baseAddr = dev_base; 
+
+    vp = &linkarray[0] ;
+    ctx_linkage_lister( dkcp, vp, 4 ) ;
+
+    // the order of this list must match that in ctx_linkage_lister
+    dccp->at_lock_link                  = (void *)*vp++ ;
+    dccp->ioctl_sem_link                = (void *)*vp++ ;
+    dccp->mbx_cmd_lock_link             = (void *)*vp++ ;
+    dccp->mbx_swun_lock_link            = (void *)*vp++ ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the clink for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our contexts
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*       Point the control context at the gpl context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*       dkcp        - Pointer to the kernel context.
+*                     This will be saved in the control context.        
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+    int err ;
+
+    // Allocate the contexts
+
+    err = Clnk_alloc_contexts( ddcp_dgcp, ddcp );
+    if( !err )
+    {
+        dgcp = dd_to_dg( ddcp ) ;
+        dccp = dg_to_dc( dgcp ) ;
+
+        // Initialize OS context: BZ 5072 fix
+
+        Clnk_init_os_context( dgcp ) ; 
+
+        // Initialize control context
+
+        Clnk_init_control_context( dccp, dkcp, dev_base ) ;
+    }
+
+    return(err);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       De-Initializes the Mailbox Module for a device.
+*       Called from the remove function for each device.
+*
+*       The thinking here, based on assumptions about what the
+*       kernel does during remove, is to assume that ioctls
+*       are stopped already and that there is no need to lock
+*       them out.
+*
+*       Stops the Timer Task.
+*       Offs the mailboxes.
+*       De-Allocates everything.
+*    
+* Inputs:
+*       vdgcp - Pointer into the gpl context 
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+void Clnk_exit_dev( void *vdgcp )
+{
+    dc_context_t *dccp ;
+
+    if( vdgcp ) {
+        dccp = dg_to_dc( vdgcp ) ;
+
+        // Free any wqts
+        Clnk_MBX_Free_wqts( &dccp->mailbox ) ;
+
+        ctx_free_dc_context( dccp ) ; 
+        ctx_free_dg_context( vdgcp ) ;
+    }
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DC
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dc_context( void )
+{
+    dc_context_t *dccp ;
+
+    dccp = (dc_context_t *)HostOS_Alloc(sizeof(dc_context_t));
+    if( dccp )
+    {
+        HostOS_Memset(dccp, 0, sizeof(dc_context_t));
+    }
+
+    return(dccp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DC
+*    
+* Inputs:   dccp - the DC context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dc_context( void *dccp )
+{
+
+    HostOS_Free( dccp, sizeof(dc_context_t) ) ;
+}
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/util_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/util_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/util_dvr.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Src/util_dvr.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,239 @@
+/*******************************************************************************
+*
+* Common/Src/util_dvr.c
+*
+* Description: Ethernet Driver Utility Functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT)
+static volatile SYS_UINT32 *setup_atrans( dc_context_t *dccp, SYS_UINT32 addr);
+#endif
+
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Messes with the addresses
+*
+*   Imports:    dccp - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*STATIC*******************************************************************************/
+static volatile SYS_UINT32 *setup_atrans(dc_context_t *dccp, SYS_UINT32 addr)
+{
+    SYS_UINTPTR base = dccp->baseAddr;
+    volatile SYS_UINT32 *dst;
+    SYS_UINT32 addr_hi = (addr & 0x0fff0000);
+    SYS_UINT32 addr_lo = (addr & 0x0000ffff);
+
+#if ECFG_CHIP_ZIP1
+    if(((addr & 0xffff0000) == 0x30000) || (addr_hi == 0x100000))
+    {
+        /* this is in the CSR block (Sonics 0x0010xxxx), so use SLV2MAR */
+        dst = (volatile SYS_UINT32 *)(base + (addr_lo | 0x30000));
+    } else {
+        /*
+         * not in the CSR block - configure and use SLV1MAR
+         * note: bits 16 and 17 should never be set at the same time
+         * it is unclear whether bit 17 will ever be set by the host driver
+         */
+        //SETUP_ATRANS(ctx, &addr);
+        dst = (volatile SYS_UINT32 *)(base + CLNK_REG_SLAVE_1_MAP_ADDR);
+        HostOS_Write_Word((addr & 0x0ffc0000) | CLNK_REG_ADDR_TRANS_ENABLE_BIT,
+                          (SYS_UINT32 *)dst);
+        dst = (volatile SYS_UINT32 *)(base + (addr & 0x3ffff));
+    }
+#else  /* ECFG_CHIP_ZIP2/ECFG_CHIP_MAVERICKS */
+    if ((addr >= EHI_START) && (addr <= EHI_END))
+    {
+        dst = (volatile SYS_UINT32 *)(base + 0x00000 + addr_lo);
+    } else if (addr_hi == AT1_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x10000 + addr_lo);
+    } else if (addr_hi == AT2_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x20000 + addr_lo);
+    } else {
+        if (addr_hi != dccp->at3_base)
+        {
+            dst = (volatile SYS_UINT32 *)(base + 0x00074);
+
+            clnk_bus_write( dccp, (SYS_UINTPTR)dst, addr_hi);
+
+            dccp->at3_base = addr_hi;
+        }
+        dst = (volatile SYS_UINT32 *)(base + 0x30000 + addr_lo);
+    }
+#endif /* ECFG_CHIP_ZIP1 */
+
+    return(dst);
+}
+#endif
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+#endif
+    HostOS_Lock(dccp->at_lock_link);
+//HostOS_PrintLog(L_INFO, "In clnk_reg_read: address=%x \n",addr);
+#if defined(PCI_DRVR_SUPPORT)
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+//HostOS_PrintLog(L_INFO, "Done clnk_reg_read: val=%x \n",*val);
+
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*   Purpose:    Writes a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+#endif
+
+    HostOS_Lock(dccp->at_lock_link);
+#if defined(PCI_DRVR_SUPPORT)
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT)  || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*
+*   Purpose:    Writes a clink bus register/location
+*                 WITHOUT LOCKING
+*               This is in support of a block write operation
+*               and the lock is outside the write loop.
+*
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+
+}
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*                 WITHOUT LOCKING
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,66 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_gpl_hdr_h__
+#define __apollo_gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkMbx_dvr.h"
+
+#include "data_context.h"
+#include "gpl_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+
+#define dc_context_t void // Temporary
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+#include "HostOS_proto.h"
+
+
+#endif // __apollo_gpl_hdr_h__
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_proto.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_gpl_proto.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,75 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_proto.h
+*
+* Description: Linux Ethernet Driver types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/* Do Not Edit! The following contents produced by script.  Thu Jan 22 16:27:49 HKT 2009  */
+
+
+/*** public prototypes from GPL/Apollo/en2512.c ***/
+int memory_init(void);
+void memory_exit(void);
+int memory_open(struct inode *inode, struct file *filp);
+int memory_release(struct inode *inode, struct file *filp);
+ssize_t memory_read(struct file *filp, char *buf, 
+                    size_t count, loff_t *f_pos);
+ssize_t memory_write(   struct file *filp, 
+                        const char *buf, 
+                        size_t count, 
+                        loff_t *f_pos);
+int ioctl_operation(struct inode  *fs_inode, 
+                    struct file   *filp, 
+                    unsigned int  cmd, 
+                    unsigned long argument);
+int ioctl_operation_work(   struct inode *fs_inode, 
+                            struct file *filp, 
+                            unsigned int cmd, 
+                            unsigned long argument);
+unsigned long int rand(int init);
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+void setup_gpio_signals(void);
+
+/*** public prototypes from GPL/Apollo/apollo_mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,106 @@
+/*******************************************************************************
+*
+* GPL/Apollo/mdio.c
+*
+* Description: High level MDIO access
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "apollo_gpl_hdr.h"
+
+
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_close(void);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data)
+{
+    ClinkWriteTo( addr, data );
+
+    return(SYS_SUCCESS);
+}
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data)
+{
+    SYS_UINT32      ret;
+    
+    ret = ClinkReadFrom( addr );
+    *data = ret;
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc )
+{
+    unsigned int    i;
+   
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        Turbo_write(*data);
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc)
+{
+    unsigned int    i;
+
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        *data = Turbo_read();
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/data_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/data_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/data_context_apollo.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/data_context_apollo.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,37 @@
+/*******************************************************************************
+*
+* GPL/CandD/data_context_candd.h
+*
+* Description: Apollo Driver data definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __data_context_apollo_h__
+#define __data_context_apollo_h__
+
+#include "gmac_drv.h"
+
+#endif /* __data_context_apollo_h__ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,462 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          en2512.c %
+ * %pid_version:       1.2      %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:      Linux driver source file for MoCA 2512
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/* Necessary includes for device drivers */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/slab.h> /* kmalloc() */
+#include <linux/fs.h> /* everything... */
+#include <linux/errno.h> /* error codes */
+#include <linux/types.h> /* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h> /* O_ACCMODE */
+#include <asm/system.h> /* cli(), *_flags */
+#include <asm/uaccess.h> /* copy_from/to_user */
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/sockios.h>
+
+#include <tmNxTypes.h>
+#include "apollo_gpl_hdr.h"
+#include "tmbslPhyEN2512.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/mii.h"
+#include "mach/gmac_eth_drv.h"
+#include "data_context_apollo.h"
+
+// definitions
+
+
+#define VERSION "Apollo Version 1.22"
+
+#define K_BUF_SIZE  512
+
+#define G_IO_START  0xc8004000
+
+
+
+#define reverse_endian(b)       ((b) >= 8 ? (b)+8 : (b)+24)
+#define reverse_endian_bit(b)   (1 << reverse_endian(b))
+
+//------------------------------------------------------------------------------
+// Define Ports used
+//------------------------------------------------------------------------------
+#define MDIO_PORT           0
+#define MDIO_CONFIG_PORT    4
+#define MDIO_INPUT_PORT     8
+
+//------------------------------------------------------------------------------
+// Define Bits in the GPIO ports
+//------------------------------------------------------------------------------
+#define MDIO_CLOCK_BIT  reverse_endian_bit(4)
+#define MDIO_DATA_BIT   reverse_endian_bit(5)
+
+#define SMI_CLOCK_BIT   reverse_endian_bit(6)
+#define SMI_DATA_BIT    reverse_endian_bit(7)
+
+#define YELLOW          reverse_endian_bit(0)
+#define GREEN           reverse_endian_bit(1)
+#define IXP_MII_DIS     reverse_endian_bit(2)
+#define SoC_RESET       reverse_endian_bit(3)
+#define SWITCH_RESET    reverse_endian_bit(8)
+#define SWITCH_INTR     reverse_endian_bit(9)
+#define BUTTON          reverse_endian_bit(10)
+#define SOC_XMII_DIS    reverse_endian_bit(11)
+#define DIPLEXER        reverse_endian_bit(12)
+#define CPU_RESET       reverse_endian_bit(13)
+
+
+#define __PHY_ADDRESS           0x01
+
+
+#define MDIO_START_BITS         (0x01 << (30-16))
+#define MDIO_OP_READ            (0x02 << (28-16))
+#define MDIO_OP_WRITE           (0x01 << (28-16))
+#define MDIO_READ_TURN_AROUND   (0x03 << (16-16))
+#define MDIO_WRITE_TURN_AROUND  (0x02 << (16-16))
+
+#define MDIO_READ_MASK          (MDIO_START_BITS | MDIO_OP_READ  | PHY_ADDRESS << (23-16))
+#define MDIO_WRITE_MASK         (MDIO_START_BITS | MDIO_OP_WRITE | PHY_ADDRESS << (23-16))  
+#define MDIO_REG_PLACEMENT      (18-16)
+
+#define ADDRESS_MODE            0x1b
+#define ADDRESS_HIGH            0x1c
+#define ADDRESS_LOW             0x1d
+#define DATA_HIGH               0x1e
+#define DATA_LOW                0x1f
+
+#define _BV(n)                  (1 << (n))
+
+#define CLINK_START_WRITE       _BV(0)
+#define CLINK_START_READ        _BV(1)
+#define CLINK_AUTO_INC          _BV(2)
+#define CLINK_BUSY              _BV(3)
+#define CLINK_ERROR             _BV(4)
+
+#define PHY_READ    (MDIO_START_BITS | MDIO_OP_READ  | MDIO_READ_TURN_AROUND)
+#define PHY_WRITE   (MDIO_START_BITS | MDIO_OP_WRITE | MDIO_WRITE_TURN_AROUND)
+
+//
+// structures and definitions
+//
+
+/* This structure is used in all SIOCxMIIxxx ioctl calls */
+struct mmi_ioctl_data {
+        uint16_t                phy_id;
+        uint16_t                reg_num;
+        uint16_t                val_in;
+        uint16_t                val_out;
+};
+
+struct ioctl_stuff
+{
+    char                        name[16];
+    union ioctl_data 
+    {
+        unsigned int            *ptr;
+        struct mmi_ioctl_data   mmi;
+        unsigned char           MAC[8];
+    } dat;
+};
+
+/* Global variables of the driver */
+
+//------------------------------------------------------------------------------
+// This is the location of the gpio registers 
+//------------------------------------------------------------------------------
+
+// prototypes
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned int );
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+extern tmErrorCode_t tmbslPhyEN2512Read (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN2512Reg_t	reg,
+	pUInt16			pVal
+	);
+
+
+extern tmErrorCode_t tmbslPhyEN2512Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2512Reg_t		reg,
+    UInt16			val
+	);
+static int en2512_unitnum, en2512_phy_addr;
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned cmd )
+{
+    struct mii_ioctl_data *data = if_mii(ifr);
+    int flag,status = 0;
+    void *arg = NULL;
+    dk_context_t *dkcp;
+    arg = ifr->ifr_data;
+
+    dkcp = (dk_context_t *)data_kernel_context ;
+
+    switch (cmd)
+    {
+        case SIOCGMIIPHY:       // Get PHY address
+            data->phy_id = en2512_phy_addr;   //pPlatData->phy_addr_val;
+            break;
+        case SIOCHDRCMD:        // Resets the SoC , Control the diplexer switch etc
+            flag = ifr->ifr_ifru.ifru_ivalue;
+            if(flag)
+            {
+                writel(0, 0xE0680364); //We are writing to SGPIO directly too bad
+                printk(KERN_INFO "MoCA en2512 SoC in-reset\n");
+            }
+            else
+            {
+                writel(3, 0xE0680364); //We are writing to SGPIO directly too too bad
+                printk(KERN_INFO "MoCA en2512 SoC out of reset\n");
+            }
+            break;
+        case SIOCGMIIREG:       // PHY read request
+            data->val_out = ClinkReadMDIOData(data->reg_num);
+            break;
+        case SIOCSMIIREG:       // PHY write request
+            ClinkWriteMDIOData(data->reg_num,data->val_in);
+            break;
+        case SIOCCLINKDRV :     // Control plane commands for the driver
+            status = clnkioc_driver_cmd( dkcp, arg ) ;
+            break ; 
+        case SIOCGCLINKMEM :    // Reads registers/memory in c.LINK address space
+            status = clnkioc_mem_read( dkcp, arg ) ;
+            break ; 
+        case SIOCSCLINKMEM :    // Sets registers/memory in c.LINK address space
+            status = clnkioc_mem_write( dkcp, arg ) ;
+            break ; 
+        case SIOCGCLNKCMD :     // mbox cmmds: request with response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 1 ) ;
+            break ;
+        case SIOCSCLNKCMD :     // mbox cmmds: request with no response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 0 ) ;
+            break ;
+        case SIOCLNKDRV :       // mbox cmmds: retrieve unsol messages
+            status = clnkioc_mbox_unsolq_retrieve( dkcp, arg ) ;
+            break ;         
+
+        default:
+            printk(KERN_ALERT "DIAG: IOCTL operation %x \n",cmd);
+            break ;
+    }
+    return(status);
+}
+
+/******************************************************
+
+        End of MODULE functions
+
+        Start of Utility functions
+
+*******************************************************/
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr)
+{
+    en2512_unitnum = unitNum;
+    en2512_phy_addr = phy_addr;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int ClinkReadMDIOData(int reg_addr)
+{
+    unsigned short data;
+    
+    tmbslPhyEN2512Read(en2512_unitnum, reg_addr, &data);
+
+    return(data);
+
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteMDIOData(int reg_addr,unsigned val)
+{    
+    tmbslPhyEN2512Write(en2512_unitnum, reg_addr, val);
+}
+
+
+/*
+*           wait for SoC bus to say idle
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWaitMDIOReady(void)
+{
+    unsigned int rc;
+    for (;;) {          // If there is problem in SoC, Watchdog interrupt will reset me !!!
+        rc=ClinkReadMDIOData(ADDRESS_MODE);
+        if ((rc & 0xff) == 0)
+            return;
+        if (rc & CLINK_BUSY)
+        {
+            continue;
+        }
+        if (rc & CLINK_ERROR)
+        {
+            continue;
+        }
+        return;
+    }
+}
+
+
+/*
+*            read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned long ClinkReadFrom(unsigned long addr)
+{
+    unsigned long data;
+
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ);
+    ClinkWaitMDIOReady();
+    data=ClinkReadMDIOData(DATA_HIGH);
+    data = data << 16;
+    data |= (ClinkReadMDIOData(DATA_LOW) & 0xffff);
+    return data;
+}
+
+
+/*
+*          read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteTo(unsigned long addr, unsigned long data)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_open(unsigned long addr)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_write(unsigned long data)
+{
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE | CLINK_AUTO_INC);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int Turbo_read(void)
+{
+    unsigned int data = 0;
+    unsigned int retVal = 0;
+
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ | CLINK_AUTO_INC);
+
+    data = ClinkReadMDIOData(DATA_HIGH);
+    retVal = data << 16;
+    data = ClinkReadMDIOData(DATA_LOW);
+    retVal |= data & 0xFFFF;
+    
+    return retVal;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_close(void)
+{
+    ClinkWriteMDIOData(ADDRESS_MODE, 0);
+}
+
+/*****************************************************
+
+        End of utility functions
+
+******************************************************/
+
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/data_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/data_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/data_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/data_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,47 @@
+/*******************************************************************************
+*
+* GPL/Common/data_context.h
+*
+* Description: data context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __data_context_h__
+#define __data_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "data_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "data_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "data_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "data_context_apollo.h"
+#endif
+#endif // __data_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_context.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_context.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_context.h
+*
+* Description: PCI Driver GPL Context
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_context_h__
+#define __gpl_context_h__
+
+
+/*
+    This structure/variable is instantiated at probe time by allocation.
+    It is pointed to from the driver data context p_dg_ctx member. 
+*/
+
+struct _driver_gpl_context_ {
+    void                *p_dd_ctx ; // pointer to driver data    context
+    void                *p_dc_ctx ; // pointer to driver control context
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       at_lock; 
+#else
+    hostos_lock_t       at_lock;        // address translator spin lock - referenced in !GPL side
+#endif
+
+    hostos_sema_t       ioctl_sem;      // Mutex for ioctl threads, keeps them one at a time 
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       mbx_cmd_lock;   // mailbox cmd mutex semphore - referenced in !GPL side
+    hostos_sema_t       mbx_swun_lock;  // mailbox sw unsol mutex semphore - referenced in !GPL side
+#else
+    hostos_lock_t       mbx_cmd_lock;   // mailbox cmd spin lock - referenced in !GPL side
+    hostos_lock_t       mbx_swun_lock;  // mailbox sw unsol spin lock - referenced in !GPL side
+#endif
+
+};
+
+typedef struct _driver_gpl_context_ dg_context_t ;
+
+#endif  // __gpl_context_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_abs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_abs.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,310 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+
+
+
+/**
+*  Purpose:    Converts a driver kernel context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dkcp - pointer to a device kernel context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dk_to_dd( void *dkcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dkcp ) {
+        ddcp = ((dk_context_t *)dkcp)->priv;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dk_context_t *)dkcp)->priv;
+#endif
+    return( ddcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver data context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    ddcp - pointer to a device data context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dd_to_dg( void *ddcp )
+{
+    dg_context_t *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( ddcp ) {
+        dgcp = ((dd_context_t *)ddcp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dd_context_t *)ddcp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver control context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver control context
+*
+*PUBLIC**************************/
+void *dg_to_dc( void *dgcp )
+{
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        dccp = ((dg_context_t *)dgcp)->p_dc_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dc\n" );
+        dccp = 0 ;
+    }
+#else
+    dccp = ((dg_context_t *)dgcp)->p_dc_ctx ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dg_to_dd( void *dgcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        ddcp = ((dg_context_t *)dgcp)->p_dd_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dg_context_t *)dgcp)->p_dd_ctx ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+////////////////////////////////////////////////////////////
+// === combo functions
+////////////////////////////////////////////////////////////
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dk_to_dc( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+            if( dgcp ) {
+                dccp = dg_to_dc( dgcp ) ;
+            }
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dc\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver data context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dd_to_dc( void *ddcp )
+{
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( ddcp ) {
+        dgcp = dd_to_dg( ddcp ) ;
+        if( dgcp ) {
+            dccp = dg_to_dc( dgcp ) ;
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dc\n" );
+    }
+#else
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver gpl context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver gpl context
+ *
+*PUBLIC**************************/
+void *dk_to_dg( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    dgcp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+        }
+    }
+    if( !dgcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dg\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver control context pointer to
+ *              a driver data context pointer.
+ *
+ *  Imports:    dccp - pointer to a device control context
+ *
+ *  Exports:    pointer to the driver data context
+ *
+*PUBLIC**************************/
+void *dc_to_dd( void *dccp )
+{
+    void *dgcp ;
+    void *ddcp ;
+
+#if CONTEXT_DEBUG
+    ddcp = 0 ;
+    if( dccp ) {
+        dgcp = dc_to_dg( dccp ) ;
+        if( dgcp ) {
+            ddcp = dg_to_dd( dgcp ) ;
+        }
+    }
+    if( !ddcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dd\n" );
+    }
+#else
+    dgcp = dc_to_dg( dccp ) ;
+    ddcp = dg_to_dd( dgcp ) ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_setup.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_setup.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,158 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DG
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dg_context( void )
+{
+    dg_context_t *dgcp ;
+
+    dgcp = (dg_context_t *)HostOS_Alloc(sizeof(dg_context_t));
+    if( dgcp )
+    {
+        HostOS_Memset(dgcp, 0, sizeof(dg_context_t));
+    }
+
+    return(dgcp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DG
+*    
+* Inputs:   dgcp - the DG context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dg_context( void *dgcp )
+{
+
+    HostOS_Free( dgcp, sizeof(dg_context_t) ) ;
+
+}
+
+/*******************************************************************************
+*           
+* Purpose:  links a DG somewhere
+*    
+* Inputs:   vdgcp - void pointer to DG context 
+*           ddcp  - void pointer to DD context
+*           dccp  - void pointer to DC context
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+    dgcp->p_dd_ctx = (void *)ddcp ;  // link dg to dd
+    dgcp->p_dc_ctx = (void *)dccp;   // link dg to dc
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the OS context.
+*
+* Inputs:
+*       vdgcp        - void Pointer to the OS context.
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void Clnk_init_os_context( void *vdgcp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->at_lock);       // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->at_lock);        // referenced from !GPL side
+#endif
+
+    HostOS_mutex_init(  &dgcp->ioctl_sem);
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_mutex_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_lock_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len )
+{
+    dg_context_t *dgcp = dk_to_dg( dkcp ) ;
+
+    *vp++ = (unsigned int *)&dgcp->at_lock;
+    *vp++ = (unsigned int *)&dgcp->ioctl_sem;
+    *vp++ = (unsigned int *)&dgcp->mbx_cmd_lock;
+    *vp++ = (unsigned int *)&dgcp->mbx_swun_lock;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_hdr.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_hdr.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,77 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_hdr_h__
+#define __gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "HostOS_Spec_pci.h"
+#include "eth_dvr.h"
+#endif
+
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "HostOS_Spec_candd.h"
+#endif
+
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "HostOS_Spec_apollo.h"
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) 
+#include "HostOS_Spec_e1000.h"
+#include "e1000.h"
+#endif
+
+#include "data_context.h"
+#include "gpl_context.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "pci_gpl_proto.h"
+#endif
+#include "com_abs_proto.h"
+
+#include "HostOS_proto.h"
+
+
+#endif // __gpl_hdr_h__
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1433 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.c
+*
+* Description: Host OS support for Linux
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+#define LOCK_MAGIC      0x4c4f434b       // spells "LOCK"
+
+#define KMALLOC_MAX     65536
+
+extern unsigned long volatile jiffies;
+
+
+/**
+*   Purpose:    Sets size bytes of memory to a given byte value.
+*
+*   Imports:    pMem - pointer to block of memory to set
+*               val  - value to set each byte to
+*               size - number of bytes to set
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memset(void *pMem, int val, int size)
+{
+    memset(pMem, val, size);
+}
+
+/**
+*   Purpose:    Copies size bytes of memory from pFrom to pTo.
+*               The memory areas may not overlap.
+*
+*   Imports:    pTo   - pointer to destination memory area
+*               pFrom - pointer to source memory area
+*               size  - number of bytes to copy
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memcpy(void *pTo, void *pFrom, int size)
+{
+    memcpy(pTo, pFrom, size);
+}
+
+/**
+*   Purpose:    Scans input buffer and according to format specified.
+*
+*   Imports:    buf   - input buffer
+*               fmt   - input format
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sscanf(const char *buf, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vsscanf(buf, fmt, args);
+    va_end(args);
+}
+
+/**
+*   Purpose:    Allocates DMA-addressable memory.
+*
+*   Imports:    size - size to allocate
+*
+*   Exports:    pointer to allocated block
+*
+*PUBLIC**************************/
+void* HostOS_Alloc(int size)
+{
+    void *pMem;
+
+    if (size < KMALLOC_MAX)
+        pMem = kmalloc(size, GFP_KERNEL /* | __GFP_DMA */);
+    else
+        pMem = (void *)__get_free_pages(GFP_KERNEL, get_order(size));
+    // printk("AllocMem %d %p\n", size, pMem);
+
+    /** Assure that system constants defined in Entropic space have harmonious
+     *  definitions compared with Unix constants.  This is not the most 
+     *  pure place to put this but it does not have any runtime cost since
+     *  the compiler optimizes it away. */
+    INCTYPES_COMPILE_TIME_ASSERT( EIO       == SYS_INPUT_OUTPUT_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMEM    == SYS_OUT_OF_MEMORY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( EACCES    == SYS_PERMISSION_ERROR       );
+    INCTYPES_COMPILE_TIME_ASSERT( EFAULT    == SYS_INVALID_ADDRESS_ERROR  );
+    INCTYPES_COMPILE_TIME_ASSERT( EINVAL    == SYS_INVALID_ARGUMENT_ERROR );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOSPC    == SYS_OUT_OF_SPACE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOTEMPTY == SYS_DIR_NOT_EMPTY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMSG    == SYS_BAD_MSG_TYPE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ETIMEDOUT == SYS_TIMEOUT_ERROR          );
+
+    return (pMem);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    pMem - allocation pointer from get free pages
+*               size - Requested block size
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_Free(void* pMem, int size)
+{
+    if (size < KMALLOC_MAX)
+        kfree(pMem);
+    else
+        free_pages((unsigned long)pMem, get_order(size));
+}
+
+/**
+*   Purpose:    Delays for about timeInUsec microseconds.
+*               The operation of this function is architecture dependent.
+*               It is probably a tight loop.
+*
+*   Imports:    timeInUsec - delay in microseconds
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sleep(int timeInUsec)
+{
+    if( timeInUsec < 1000 ) {
+        udelay(timeInUsec);
+    } else {
+        //HostOS_PrintLog(L_NOTICE, "mdelay delay=%d. jif=%d.\n", timeInUsec/1000, jiffies );
+        mdelay(timeInUsec/1000);
+        //HostOS_PrintLog(L_NOTICE, "mdelay jif=%d.\n", jiffies );
+    }
+}
+
+/**
+*   Purpose:    Inits a spinlock.
+*               Sets the magic code for later testing.
+*
+*   Imports:    vlk - pointer to an Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_lock_init( void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    if( !lk ) {
+        HostOS_PrintLog(L_ERR, "Error: invalid lock pointer\n");
+    } else {
+        spin_lock_init( &lk->lock_spinlock );
+        lk->lock_magic     = LOCK_MAGIC;
+    }
+}
+
+/**
+*   Purpose:    Waits for the lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Lock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*                     or pointer to the mutex structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM    
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_lock(&lk->lock_spinlock);
+    } else {
+        spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    down((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Saves current interrupt context and waits for the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock_Irqsave(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Trys to get the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    0 - the lock was NOT acquired. Please try again.
+*               1 - the lock is yours. Please ulock it later.
+*
+*PUBLIC**************************/
+int HostOS_Lock_Try(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+    int locked ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    locked = spin_trylock(&lk->lock_spinlock) ;
+
+    return( locked );
+}
+
+/**
+*   Purpose:    Unlocks a lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Unlock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM 
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_unlock(&lk->lock_spinlock);
+    } else {
+        spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    up((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Unlocks a lock and restores interrupt context.
+*               The lock must be initialized.
+*
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock_Irqrestore(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+   spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Terminates a lock.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_TermLock(void *vlk)
+{
+}
+
+
+// Host Print ForMaT string
+#define HPFMT "%s: %s"
+
+/**
+*   Purpose:    Variable argument OS print.
+*
+*   Imports:    lev - severity level. See the L_* enum.
+*                     See HOST_OS_PRINTLOG_THRESHOLD
+*               fmt - printf format string
+*               ... - printf format arguments
+*
+*   Exports:    none
+*
+*  For reference:  Linux has these
+*
+*  #define KERN_EMERG      "<0>"   / * system is unusable                   * /
+*  #define KERN_ALERT      "<1>"   / * action must be taken immediately     * /
+*  #define KERN_CRIT       "<2>"   / * critical conditions                  * /
+*  #define KERN_ERR        "<3>"   / * error conditions                     * /
+*  #define KERN_WARNING    "<4>"   / * warning conditions                   * /
+*  #define KERN_NOTICE     "<5>"   / * normal but significant condition     * /
+*  #define KERN_INFO       "<6>"   / * informational                        * /
+*  #define KERN_DEBUG      "<7>"   / * debug-level messages                 * /
+*
+*PUBLIC**************************/
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...)
+{
+    va_list args;
+    int  printed_len;
+    static char printk_buf[1024]; /* BZ 4739 Fix - Making it static as this is
+                                   * too much data to allocate on the stack. */
+
+    if (lev <= HOST_OS_PRINTLOG_THRESHOLD)
+    {   
+        /* Emit the output into the temporary buffer */
+        va_start(args, fmt);
+        printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
+        va_end(args);
+
+        switch ( lev )
+        {
+            case L_EMERG   :
+                printk(KERN_EMERG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ALERT   :
+                printk(KERN_ALERT   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_CRIT    :
+                printk(KERN_CRIT    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ERR     :
+                printk(KERN_ERR     HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_WARNING :
+                printk(KERN_WARNING HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_NOTICE  :
+                printk(KERN_NOTICE  HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_INFO    :
+                printk(KERN_INFO    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_DEBUG   :
+                printk(KERN_DEBUG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+        }
+    }
+}
+
+/**
+*   Purpose:    register/memory read access from kernel space.
+*
+*   Imports:    addr - address to read from
+*
+*   Exports:    32 bit value from given address
+*
+*PUBLIC**************************/
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr )
+{
+    SYS_UINT32 rv ;
+
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    rv = *(volatile SYS_UINT32 *)addr ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    rv = readl( (const volatile void *)addr );
+#else
+    rv = readl( addr ) ;
+#endif
+#endif
+    return( rv ) ;
+}
+
+/**
+*   Purpose:    register/memory write access from kernel space.
+*
+*   Imports:    val  - 32 bit value to write
+*               addr - address to write to
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr )
+{
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    *(volatile SYS_UINT32 *)addr = val ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    writel( val, (volatile void *)addr );
+#else
+    writel( val, addr );
+#endif
+#endif
+}
+
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vtmr - pointer to the timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_init( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    init_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*               And ensure the timer is not running on any CPU
+*               Can sleep
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del_sync( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer_sync( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( mod_timer( &tmr->ostimer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer.
+*               Call this after HostOS_timer_setup
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_timer_add( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    add_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.function = func ;
+    tmr->ostimer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In seconds.
+*
+*   Imports:    future - number of seconds into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future )
+{
+
+    return( jiffies + (future * HZ) ) ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In jiffies.
+*
+*   Imports:    future - number of ticks into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future )
+{
+
+    return( jiffies + future ) ;
+}
+
+
+/**************************************************************
+
+    wait queue timer - support
+
+    This structure contains everything necessary to
+    use timers and wait queues from the !GPL side.
+
+    You allocate one of these wqt_t things and then
+    pass its pointer back on the various calls.
+
+***************************************************************/
+
+typedef struct hostos_w_q_t
+{
+    int                 wqt_allocated ; // 0 = no, 1 = yes
+    struct timer_list   wqt_timer;
+    wait_queue_head_t   wqt_wq;
+}
+wqt_t ;
+
+
+/**
+*   Purpose:    Allocates a wqt entry from the heap.
+*
+*   Imports:
+*
+*   Exports:    !0 = void pointer to opaque data (really a wqt_t)
+*               0 = allocation failure
+*
+*PUBLIC**************************/
+void *HostOS_wqt_alloc( void )
+{
+    wqt_t       *wqt ;
+
+    wqt = kmalloc( sizeof( wqt_t ), GFP_KERNEL ) ;
+
+    return( (void *)wqt ) ;
+}
+
+/**
+*   Purpose:    De-allocates a wqt entry from the heap.
+*
+*   Imports:    vwqt - pointer to the wqt_t to be freed
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_free( void *vwqt )
+{
+
+    kfree( vwqt ) ;
+}
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_allocated = 1 ;  // mark the timer inited
+    init_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a wqt timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_del( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt->wqt_allocated ) {
+        del_timer( &wqt->wqt_timer ) ;
+    }
+}
+
+/**
+*   Purpose:    Deactivate a registered timer
+*               And ensure the timer is not running on any CPU.
+*               Can sleep.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_del_sync( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( del_timer_sync( &wqt->wqt_timer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to modify
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                        or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( mod_timer( &wqt->wqt_timer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer
+*               Call this after HostOS_timer_setup.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to add
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_add( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    add_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to  init
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.function = func ;
+    wqt->wqt_timer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to set
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Inits a wait queue head in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to init
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    init_waitqueue_head( &wqt->wqt_wq );
+}
+
+/**
+*   Purpose:    Wakes up a wait q in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wake
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt )
+    {
+        wake_up_interruptible( &wqt->wqt_wq );
+    }
+}
+
+/**
+*   Purpose:    Waits for a wait q event in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wait on
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wait_event_interruptible( wqt->wqt_wq, /* pass by value */
+                              func(vp) );
+
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_word(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*              These functions read or write the PCI bus device.
+*
+*              Linux uses nested macros to define these.
+*              See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with pci_dev pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_dword(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_word(pdev, reg, val);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_dword(pdev, reg, val);
+}
+
+/**
+*   Purpose:    Allocate DMA-addressable memory.
+*
+*   Imports:    ddev    - pci_dev pointer
+*               size    - Requested block size
+*               ppMemPa - Pointer to place to return the Physical memory address
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+    dma_addr_t     dma_buf;
+    void           *pMemVa;
+
+    pMemVa   = pci_alloc_consistent(pdev, size, &dma_buf);
+    *ppMemPa = (void *)dma_buf;
+
+    // printk("AllocDmaMem %d %x %x\n", size, pMemVa, dma_buf);
+
+    return (pMemVa);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    ddev   - pci_dev pointer
+*               size   - Requested block size
+*               pMemVa - Virtual memory address returned by HostOS_AllocDmaMem()
+*               pMemPa - Physical memory address returned by    ditto
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_free_consistent(pdev, (size_t) size, pMemVa, (dma_addr_t)pMemPa);
+}
+#endif
+
+/**
+*   Purpose:    Initialize a tasklet.
+*
+*               Prototype:
+*               void tasklet_init(struct tasklet_struct *t,
+*                                 void (*func)(unsigned long),
+*                                 unsigned long data)
+*
+*   Imports:    vtl  - pointer to the tasklet structure
+*               func - tasklet function
+*               data - tasklet context data
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_init( void *vtl, void *func, unsigned long data )
+{
+
+    tasklet_init((struct tasklet_struct *)vtl, func, data ) ; // abstraction
+}
+
+/**
+*   Purpose:    Schedule a tasklet.
+*               Tasklet must already be initialized.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_schedule( void *vtl )
+{
+
+    tasklet_schedule( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Enable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_enable( void *vtl )
+{
+
+    tasklet_enable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Disable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_disable( void *vtl )
+{
+
+    tasklet_disable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Kill a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_kill( void *vtl )
+{
+
+    tasklet_kill( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Initialize a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_init( void *vmt )
+{
+
+    init_MUTEX( (struct semaphore *)vmt ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Release (up) a mutex.
+*
+*               Do NOT call this from an ISR!
+*
+*               Do NOT call this if you are not the current
+*               holder of the mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_release( void *vmt )
+{
+
+    up( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex.
+*
+*               Might sleep.
+*               When this returns you have the mutex.
+*
+*               This is NOT the preferred method. See
+*               HostOS_mutex_acquire_intr().
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_acquire( void *vmt )
+{
+
+    down( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex. Interruptible
+*
+*               Might sleep.
+*               When this returns 0 you have the mutex.
+*               When this returns -EINTR you have been interrupted
+*               and must bail out. You do NOT have the mutex. The
+*               purpose here is to allow the caller, probably a
+*               user space app, to be interrupted and die quickly
+*               and quietly; rather than becoming a zombie because
+*               the driver won't let go.
+*
+*               This is the preferred method.
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:    0      - you got the mutex
+*               -EINTR - you've been interrupted, no mutex
+*
+*PUBLIC**************************/
+int HostOS_mutex_acquire_intr( void *vmt )
+{
+    int rc ;
+
+    rc = down_interruptible( (struct semaphore *)vmt ) ; // abstraction
+    return( rc ) ;
+}
+
+/**
+*   Purpose:    Copies a block from user space to kernel space.
+*
+*   Imports:    to     - pointer to a kernel space buffer to receive the data
+*               from   - pointer to a user space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_from_user( to, from, nbytes );
+    return( n ) ;
+}
+
+/**
+*   Purpose:    Copies a block from kernel space to user space.
+*
+*   Imports:    to     - pointer to a user space buffer to receive the data
+*               from   - pointer to a kernel space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_to_user( to, from, nbytes );
+    return( n ) ;
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Check if the carrier is ok.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:    1 if carrier is ok, 0 if not
+*
+*PUBLIC**************************/
+unsigned long HostOS_netif_carrier_ok( void *kdev )
+{
+
+    return( netif_carrier_ok((struct net_device *)kdev) ) ;
+}
+
+/**
+*   Purpose:    Sets net carrier on.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_on( void *kdev )
+{
+
+    netif_carrier_on((struct net_device *)kdev);
+    netif_wake_queue((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets net carrier off.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_off( void *kdev )
+{
+
+    netif_carrier_off((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets the MAC address in the OS.
+*
+*   Imports:    mac_hi - Bytes 0-3 of MAC address
+*               mac_lo - Bytes 4-5 of MAC address
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    dev->dev_addr[0] = (SYS_UCHAR) ((mac_hi >> 24) & 0xff);
+    dev->dev_addr[1] = (SYS_UCHAR) ((mac_hi >> 16) & 0xff);
+    dev->dev_addr[2] = (SYS_UCHAR) ((mac_hi >>  8) & 0xff);
+    dev->dev_addr[3] = (SYS_UCHAR) ((mac_hi      ) & 0xff);
+    dev->dev_addr[4] = (SYS_UCHAR) ((mac_lo >> 24) & 0xff);
+    dev->dev_addr[5] = (SYS_UCHAR) ((mac_lo >> 16) & 0xff);
+}
+
+/**
+*   Purpose:    Brings up the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_open( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_open(dev);
+    }
+}
+
+/**
+*   Purpose:    Shuts down the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_close( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_close(dev);
+    }
+}
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+
+/* declaring mutexes for kernel thread start/stop */
+DECLARE_MUTEX (HostOS_thread_mutex);
+
+hostos_kthread_t hostosThread;
+
+/**
+*   Purpose:    Check pending signal of task.
+*
+*   Imports:    vtask - pointer to the task
+*
+*   Exports:    0 - no pending signal
+*               1 - has pendign signal
+*
+*PUBLIC**************************/
+int HostOS_signal_pending(void *vtask)
+{
+    struct task_struct *p;
+    
+    if(vtask== SYS_NULL)
+        p = current;
+    else
+        p = (struct task_struct *)vtask;
+
+    return signal_pending(p);
+}
+
+/**
+*   Purpose:    Convert  jiffies to milliseconds.
+*
+*   Imports:    j- jiffies
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned int HostOS_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+    return (1000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+    return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+    return (j * 1000) / HZ;
+#endif
+}
+
+/**
+*   Purpose:    Convert milliseconds to jiffies.
+*
+*   Imports:    m - milliseconds
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned long HostOS_msecs_to_jiffies(const unsigned int m)
+{
+    if (m > HostOS_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+        return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+    return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+    return m * (HZ / 1000);
+#else
+    return (m * HZ + 999) / 1000;
+#endif
+}
+
+/**
+*   Purpose:    Sleep waiting for waitqueue interruptions.
+*
+*   Imports:    msecs - Time in milliseconds to sleep for
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_msleep_interruptible(unsigned int msecs)
+{
+    unsigned long timeout = HostOS_msecs_to_jiffies(msecs) + 1;
+
+    while (timeout && !signal_pending(current)) {
+        __set_current_state(TASK_INTERRUPTIBLE);
+        timeout = schedule_timeout(timeout);
+    }
+}
+
+/**
+*   Purpose:    Kernel thread internal function.
+*
+*   Imports:    pdata - pointer to thread struct
+*
+*   Exports:    none
+*
+***************************/
+static void HostOS_thread_inter_func(void *pdata)
+{
+    hostos_kthread_t *pThread = (hostos_kthread_t *)pdata;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    daemonize(hostosThread.name, 0);
+    allow_signal(SIGKILL);
+    allow_signal(SIGTERM);    
+#else
+    daemonize();
+#endif
+
+    /* kernel thread main function */
+    pThread->func(pThread->arg);
+
+    return ;
+}
+
+/**
+*   Purpose:    Create new kernel thread.
+*
+*   Imports:    pThreadID - pointer to new kernel threadID
+*               pName     - pointer to thread name string
+*               func      - pointer to thread internal function
+*               arg       - argument to pass to thread function
+*
+*   Exports:    0  - OK
+*               -1 - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_start(unsigned int *pThreadID, char *pName, void (*func)(void *), void *arg)
+{
+    down(&HostOS_thread_mutex);
+
+    strncpy(hostosThread.name, pName,16);
+    hostosThread.func = func;
+    hostosThread.arg = arg;
+
+    /* Create kernel thread */
+    hostosThread.threadID = kernel_thread((int (*)(void *))HostOS_thread_inter_func, &hostosThread, 0);
+    *pThreadID = hostosThread.threadID;
+
+    if(hostosThread.threadID < 0)
+    {
+        up (&HostOS_thread_mutex);
+        return -1;
+    }
+    
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+/**
+*   Purpose:    Stop a kernel thread.
+*
+*   Imports:    threadID - kernel threadID that to be stopped
+*
+*   Exports:    0   - OK
+*               -1  - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_stop(unsigned long threadID)
+{
+    int ret = 0;
+
+    down(&HostOS_thread_mutex);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)    
+    if((ret = kill_pid(find_vpid(threadID), SIGKILL, 1)))
+#else
+    if((ret = kill_proc(threadID, SIGKILL, 1)))
+#endif
+    {
+        up(&HostOS_thread_mutex);
+        return -1;
+    }
+
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,123 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.h
+*
+* Description: OS includes and abstracted types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _hostos_linux_h_
+#define _hostos_linux_h_
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+
+/**
+ *  spinlock structure with added bells and whistles
+ */
+
+// for locking purposes
+typedef struct hostos_lock
+{
+    int             lock_magic;        // used to verify the structure is initialized
+    unsigned long   lock_irq_flags;    // irq flags for restoring later
+    spinlock_t      lock_spinlock;
+}
+hostos_lock_t ;
+
+// timer operations
+// for linux this contains a struct timer_list
+typedef struct hostos_timer
+{
+    struct timer_list ostimer ;
+}
+hostos_timer_t ;
+
+// tasklet operations
+// for linux this contains a struct tasklet_struct
+typedef struct hostos_task
+{
+    struct tasklet_struct ostask ;
+}
+hostos_task_t ;
+
+// semaphore operations
+// for linux this contains a struct semaphore
+typedef struct hostos_sema
+{
+    struct semaphore ossema ;
+}
+hostos_sema_t ;
+
+typedef struct _hostos_waitq
+{
+    wait_queue_head_t   wq;
+}
+hostos_waitq_t ;
+
+// thread operations 
+// for linux this contains kernel thread related information
+typedef struct hostos_kthread
+{
+    char name[20];          /* thread name */
+    int  threadID;    
+    void (*func) (void *);  /* thread internal function */    
+    void *arg;              /* argument to pass to kernel thread */
+} 
+hostos_kthread_t;
+
+#endif /* _hostos_linux_h_ */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/COPYING linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/COPYING
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/COPYING	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/COPYING	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,173 @@
+The GNU General Public License (GPL)
+Version 2, June 1991
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+
+Preamble
+
+The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.
+
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.
+
+We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.
+
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and modification follow.
+
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.
+
+1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
+
+
+   a) You must cause the modified files to carry prominent notices
+      stating that you changed the files and the date of any change.
+
+
+   b) You must cause any work that you distribute or publish, that in
+      whole or in part contains or is derived from the Program or any part
+      thereof, to be licensed as a whole at no charge to all third parties
+      under the terms of this License.
+
+
+   c) If the modified program normally reads commands interactively when
+      run, you must cause it, when started running for such interactive use
+      in the most ordinary way, to print or display an announcement including
+      an appropriate copyright notice and a notice that there is no warranty
+      (or else, saying that you provide a warranty) and that users may
+      redistribute the program under these conditions, and telling the user
+      how to view a copy of this License. (Exception: if the Program itself
+      is interactive but does not normally print such an announcement, your
+      work based on the Program is not required to print an announcement.)
+
+
+These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.
+
+3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:
+
+
+   a) Accompany it with the complete corresponding machine-readable source
+      code, which must be distributed under the terms of Sections 1 and
+      2 above on a medium customarily used for software interchange; or,
+
+
+   b) Accompany it with a written offer, valid for at least three
+      years, to give any third party, for a charge no more than your
+      cost of physically performing source distribution, a complete
+      machine-readable copy of the corresponding source code, to be
+      distributed under the terms of Sections 1 and 2 above on a medium
+      customarily used for software interchange; or,
+
+
+   c) Accompany it with the information you received as to the offer to
+      distribute corresponding source code. (This alternative is allowed
+      only for noncommercial distribution and only if you received the
+      program in object code or executable form with such an offer,
+      in accord with Subsection b above.)
+
+
+The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.
+
+If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.
+
+4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.
+
+5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.
+
+6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.
+
+7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
+
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
+
+8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.
+
+9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.
+
+10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
+
+NO WARRANTY
+
+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+END OF TERMS AND CONDITIONS
+
+How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.
+
+To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.
+
+
+   one line to give the program's name and a brief idea of what it does.
+   Copyright (C) 
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this when it starts in an interactive mode:
+
+
+   Gnomovision version 69, Copyright (C) year name of author Gnomovision
+   comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is
+   free software, and you are welcome to redistribute it under certain
+   conditions; type `show c' for details.
+
+
+The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, the commands you use may be called something other than `show w' and `show c'; they could even be mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary. Here is a sample; alter the names:
+
+
+   Yoyodyne, Inc., hereby disclaims all copyright interest 
+   in the program `Gnomovision' (which makes passes at compilers)
+   written by James Hacker.
+
+   signature of Ty Coon, 1 April 1989
+   Ty Coon, President of Vice
+
+
+This General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Library General Public License instead of this License.
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/inc/tmbslPhyEN2512.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/inc/tmbslPhyEN2512.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/inc/tmbslPhyEN2512.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/inc/tmbslPhyEN2512.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,697 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN2512.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN2512 PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor EN2512BN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyEN2512_H_
+#define tmbslPhyEN2512_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET  (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL  (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR  (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL  (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYEN2512_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYEN2512_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYEN2512_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYEN2512_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYEN2512_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYEN2512_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYEN2512_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYEN2512_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYEN2512_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYEN2512_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYEN2512_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYEN2512_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYEN2512_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYEN2512_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYEN2512_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYEN2512_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYEN2512_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYEN2512_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYEN2512_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYEN2512_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYEN2512_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYEN2512_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYEN2512_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYEN2512_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYEN2512_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYEN2512_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYEN2512_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYEN2512_BMSR_JAB_VAL (0x2)
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYEN2512_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYEN2512_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYEN2512_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYEN2512_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYEN2512_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYEN2512_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYEN2512_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYEN2512_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYEN2512_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYEN2512_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYEN2512_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYEN2512_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYEN2512_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYEN2512_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYEN2512_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYEN2512_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYEN2512_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYEN2512_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYEN2512_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYEN2512_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYEN2512_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYEN2512_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYEN2512_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** PHY Specific Control register ******/
+#define TMBSL_PHYEN2512_PHYCR_CRS          (0x800)
+#define TMBSL_PHYEN2512_PHYCR_FORCE_LNK    (0x400)
+#define TMBSL_PHYEN2512_PHYCR_DIS_CLK125   (0x10)
+#define TMBSL_PHYEN2512_PHYCR_DIS_JABBER   (0x1)
+
+/* Bit 6:5 MDI Crossover Mode
+ *   00: Manual MDI Crossover configuration
+ *   01: Manual MDI configuration
+ *   10: Default value
+ * Note: Before setting register, address 0xE bit 10 needs to be set to 1.
+ *       After setting register, a PHY reset is required.
+ */
+#define TMBSL_PHYEN2512_PHYCR_MDI_XOVR_MODE_MSK (0x60)
+#define TMBSL_PHYEN2512_PHYCR_MAN_MDI_XOVR      (0x0)
+#define TMBSL_PHYEN2512_PHYCR_MAN_MDI           (0x1)
+#define TMBSL_PHYEN2512_PHYCR_MDI               (0x2)
+
+/****** PHY Specific Status Register ******/
+/* Bit 15:14 Speed
+ *   00: 10 Mbps
+ *   01: 100 Mbps
+ *   10: 1000 Mbps
+ *   11: Reserved
+ */
+#define TMBSL_PHYEN2512_PHYSTAT_SPEED_MSK       (0xC000)
+#define TMBSL_PHYEN2512_PHYSTAT_SPEED_10        (0x0)
+#define TMBSL_PHYEN2512_PHYSTAT_SPEED_100       (0x1)
+#define TMBSL_PHYEN2512_PHYSTAT_SPEED_1000      (0x2)
+
+#define TMBSL_PHYEN2512_PHYSTAT_DUPLEX          (0x2000)
+#define TMBSL_PHYEN2512_PHYSTAT_PAGE_RX         (0x1000)
+#define TMBSL_PHYEN2512_PHYSTAT_SPD_DUP_RES     (0x800)
+#define TMBSL_PHYEN2512_PHYSTAT_LINK_RT         (0x400)
+#define TMBSL_PHYEN2512_PHYSTAT_MDI_XOVR_STAT   (0x40)
+#define TMBSL_PHYEN2512_PHYSTAT_JABBER_RT       (0x1)
+
+/****** Interrupt Enable Register ******/
+#define TMBSL_PHYEN2512_IER_AN_ERR              (0x8000)
+#define TMBSL_PHYEN2512_IER_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN2512_IER_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN2512_IER_PG_RX               (0x1000)
+#define TMBSL_PHYEN2512_IER_AN_COMP             (0x800)
+#define TMBSL_PHYEN2512_IER_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN2512_IER_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN2512_IER_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN2512_IER_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN2512_IER_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN2512_IER_JABBER              (0x1)
+
+/****** Interrupt Status Register ******/
+#define TMBSL_PHYEN2512_ISR_AN_ERR              (0x8000)
+#define TMBSL_PHYEN2512_ISR_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN2512_ISR_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN2512_ISR_PG_RX               (0x1000)
+#define TMBSL_PHYEN2512_ISR_AN_COMP             (0x800)
+#define TMBSL_PHYEN2512_ISR_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN2512_ISR_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN2512_ISR_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN2512_ISR_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN2512_ISR_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN2512_ISR_JABBER              (0x1)
+
+/****** LED Control Register ******/
+#define TMBSL_PHYEN2512_LEDCR_DISABLE_LED        (0x8000)
+#define TMBSL_PHYEN2512_LEDCR_LINK_CTL           (0x8)
+#define TMBSL_PHYEN2512_LEDCR_RX_CTL             (0x2)
+#define TMBSL_PHYEN2512_LEDCR_TX_CTL             (0x1)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef enum
+{
+    /* Basic mode control */
+    tmbslPhyEN2512Bmcr			= 0x0,
+    /* Basic mode status */
+    tmbslPhyEN2512Bmsr			= 0x1,
+
+    /* 0x2-1E are reserved */
+
+    /*Extended status register */
+    tmbslPhyEN25121kscr		= 0xF,
+
+    /**** Vendor Specific Registers *****/
+    /* 0x10-19 are reserved */
+
+} tmbslPhyEN2512Reg_t;
+
+typedef struct  _tmbslPhyEN2512Context_t
+{
+    UInt32	pRegs;         // Array ETHERNET Module regs
+} tmbslPhyEN2512Context_t, *ptmbslPhyEN2512Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetSWVersion (
+    ptmSWVersion_t	pPhyVersion
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetCapabilities (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCapabilities_t	pPhyCaps
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.
+//		1. Enable the auto negotiation. In auto-negotiation mode the
+//		highest possible performance mode is selected automatically
+//		which the Link Partner also supports. (In auto negotiation mode
+//		speed and duplex mode will be selected by means of auto negotiation.
+//		Writing to speed and duplex mode does not have meaning in auto
+//		negotiation mode.)
+//		2. The device abilities are programmed to Auto negotiation advertise
+//		register. None of the device abilities are masked. If the PHY
+//		device does not support Auto-negotiation mode, then this function
+//		will set the PHY to basic capabilities of the device.The function
+//		tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to
+//		know what are the default configurations the tmbslPhyInit function
+//		has set to
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNInit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyEN2512BNDeinit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNSetPowerState(
+    tmUnitSelect_t	phyUnitId ,
+    tmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetPowerState(
+    tmUnitSelect_t	phyUnitId,
+    ptmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.
+//		tmbslPhyInit Enable the Auto negotiation mode and will configure
+//		the PHY device for the maximum performance mode available. After
+//		the device is initialized this function can be called to know the
+//		present settings of the PHY device. If application wants to change
+//		the settings it can call tmbslPhySetBasicModeControl to change
+//		the configuration after knowing the capabilities of the PHY device
+//		and Link Partner. #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t
+tmbslPhyEN2512BNSetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetBasicModeStatus (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNAutoNegotiate (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyAutoNegotitationMask_t    	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetIdentifier (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetCounters (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNPcsConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNPcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result
+//		will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNBist (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t  	phyPsedoRandomSeq ,
+    pUInt8			pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNConfigBypass (
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t  	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNLoopBack (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNSoftReset (
+    tmUnitSelect_t	phyUnitId
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetLinkStatus (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyEN2512
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyEN2512.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/src/tmbslPhyEN2512.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/src/tmbslPhyEN2512.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/src/tmbslPhyEN2512.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/src/tmbslPhyEN2512.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,881 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN2512BN.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN2512BN PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor EN2512BN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyEN2512.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/spinlock.h"
+
+/* Defines */
+
+#define PHY_TIMEOUT				(100000)
+
+#define ANAR_DEFAULT_VAL			(0xADE1)
+#define KTCR1_DEFAULT_VAL			(0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+static tmbslPhyEN2512Context_t gEthContext;
+
+extern spinlock_t moca_spinlock;
+
+/* Static functions definition */
+
+tmErrorCode_t
+tmbslPhyEN2512Read (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN2512Reg_t	reg,
+	pUInt16			pVal
+	);
+
+
+tmErrorCode_t
+tmbslPhyEN2512Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2512Reg_t	reg,
+    UInt16			val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetSWVersion (
+	ptmSWVersion_t	pPhyVersion
+	)
+{
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetCapabilities (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyCapabilities_t  	pPhyCaps
+    )
+
+{
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyEN2512Read(ethUnitId, tmbslPhyEN2512Bmsr, &bmsr);
+
+    /*  Read the extended status register */
+    tmbslPhyEN2512Read(ethUnitId, tmbslPhyEN25121kscr, &extStat);
+
+    pPhyCaps->T4Support100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = True;
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = False;
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = False;
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYEN2512_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility = False;
+
+
+    pPhyCaps->X1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN2512_1KSCR_1000BASEX_FD) > 0) ? True : False);
+
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN2512_1KSCR_1000BASEX_HD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN2512_1KSCR_1000BASET_FD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN2512_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.No Autonegotiation is done in the
+//		initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2512BNInit(
+    tmUnitSelect_t	ethUnitId
+    )
+{
+//    tmErrorCode_t	ethStatus = TM_OK;
+//    UInt16		regval = 0;
+
+    gEthContext.pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+#if 0
+
+    /* Read the defaults in the BMCR */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId,tmbslPhyEN2512Bmcr,&regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    regval |= 0x2100;
+
+    /* Set the PHY for the 100Mbps and Full Duplex */
+    ethStatus = tmbslPhyEN2512Write(ethUnitId,tmbslPhyEN2512Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+#endif
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNDeinit(
+    tmUnitSelect_t	ethUnitId
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNSetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    tmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;    
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    ptmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId,tmbslPhyEN2512Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = False;
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYEN2512_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYEN2512_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN2512_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN2512_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN2512_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNSetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+#if 0    
+    UInt16		bmcr = 0;
+
+    /* Only Full Duplex is supported */
+    bmcr = TMBSL_PHYEN2512_BMCR_FD_EN;
+
+    switch(pPhyBasicModeControl->speed)
+    {
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYEN2512_BMCR_SPEED_1G;
+            break;
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYEN2512_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYEN2512_BMCR_SPEED_10;
+            break;
+
+        default:
+            bmcr |= TMBSL_PHYEN2512_BMCR_SPEED_100;
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyEN2512Write(ethUnitId,tmbslPhyEN2512Bmcr,bmcr);
+#endif
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetBasicModeStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyBasicModeStatus_t	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr,bmcr;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId, tmbslPhyEN2512Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId, tmbslPhyEN2512Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = False;
+
+    pPhyBasicModeStatus->remoteFaultDetected = False;
+
+    pPhyBasicModeStatus->autoNegotiationComplete = False;
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYEN2512_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    /* Not an auto negotiation. So read the values from BMCR */
+    pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+
+    switch(bmcr & TMBSL_PHYEN2512_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN2512_BMCR_SPEED_1G:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN2512_BMCR_SPEED_100:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN2512_BMCR_SPEED_10:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNAutoNegotiate (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t	pAutoNegotiationMask
+    )
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//		mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN2512BNLoopBack (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId,tmbslPhyEN2512Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYEN2512_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYEN2512_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyEN2512Write(ethUnitId,tmbslPhyEN2512Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512BNSoftReset (
+    tmUnitSelect_t	ethUnitId
+	)
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetLinkStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr;
+
+    /* Read the BMSR register */
+    ethStatus = tmbslPhyEN2512Read(ethUnitId,tmbslPhyEN2512Bmsr,&bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((bmsr & TMBSL_PHYEN2512_BMSR_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512Read (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2512Reg_t	reg,
+    pUInt16			pVal
+	)
+
+{
+    UInt32		timeout = 0;
+    UInt32 		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs; i cannot do this
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+    *pVal = (UInt16) *pDataReg;
+    
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN2512Write (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN2512Reg_t	reg,
+    UInt16			val
+	)
+
+{
+    UInt32		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+    UInt32		timeout = 0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }
+    while (((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+            (timeout < PHY_TIMEOUT));
+
+    if ((timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {        
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_WRITE_FAILED);
+    }
+
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetIdentifier(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN2512BNGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t	pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512BNGetCounters(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t     	pPhyCounters
+    )
+{
+    return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512PcsSetConfig(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN2512PcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslEN2512PhyBist(
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t	phyPsedoRandomSeq ,
+    pUInt8                     	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslEN2512PhyConfigBypass(
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc/tmbslPhyIntel972.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc/tmbslPhyIntel972.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc/tmbslPhyIntel972.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc/tmbslPhyIntel972.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,680 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyINTEL972.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for INTEL972 PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor INTEL972BN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyINTEL972_H_
+#define tmbslPhyINTEL972_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET  (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL  (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR  (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL  (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYINTEL972_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYINTEL972_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYINTEL972_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYINTEL972_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYINTEL972_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYINTEL972_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYINTEL972_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYINTEL972_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYINTEL972_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYINTEL972_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYINTEL972_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYINTEL972_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYINTEL972_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYINTEL972_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYINTEL972_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYINTEL972_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYINTEL972_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYINTEL972_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYINTEL972_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYINTEL972_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYINTEL972_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYINTEL972_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYINTEL972_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYINTEL972_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYINTEL972_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYINTEL972_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYINTEL972_BMSR_JAB_VAL (0x2)
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYINTEL972_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYINTEL972_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYINTEL972_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYINTEL972_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYINTEL972_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYINTEL972_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYINTEL972_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYINTEL972_ANAR_10B_TX_HD (0x20)
+
+/* Indicates the INTEL972BN supports 802.3 */
+#define TMBSL_PHYINTEL972_ANAR_SELECTOR_FIELD (0x1)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYINTEL972_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYINTEL972_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYINTEL972_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYINTEL972_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYINTEL972_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYINTEL972_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYINTEL972_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYINTEL972_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYINTEL972_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYINTEL972_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYINTEL972_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYINTEL972_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYINTEL972_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYINTEL972_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYINTEL972_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** PHY Specific Control register ******/
+#define TMBSL_PHYINTEL972_PHYCR_CRS          (0x800)
+#define TMBSL_PHYINTEL972_PHYCR_FORCE_LNK    (0x400)
+#define TMBSL_PHYINTEL972_PHYCR_DIS_CLK125   (0x10)
+#define TMBSL_PHYINTEL972_PHYCR_DIS_JABBER   (0x1)
+
+/* Bit 6:5 MDI Crossover Mode
+ *   00: Manual MDI Crossover configuration
+ *   01: Manual MDI configuration
+ *   10: Default value
+ * Note: Before setting register, address 0xE bit 10 needs to be set to 1.
+ *       After setting register, a PHY reset is required.
+ */
+#define TMBSL_PHYINTEL972_PHYCR_MDI_XOVR_MODE_MSK (0x60)
+#define TMBSL_PHYINTEL972_PHYCR_MAN_MDI_XOVR      (0x0)
+#define TMBSL_PHYINTEL972_PHYCR_MAN_MDI           (0x1)
+#define TMBSL_PHYINTEL972_PHYCR_MDI               (0x2)
+
+/****** PHY Specific Status Register ******/
+/* Bit 15:14 Speed
+ *   00: 10 Mbps
+ *   01: 100 Mbps
+ *   10: 1000 Mbps
+ *   11: Reserved
+ */
+#define TMBSL_PHYINTEL972_PHYSTAT_SPEED_MSK       (0xC000)
+#define TMBSL_PHYINTEL972_PHYSTAT_SPEED_10        (0x0)
+#define TMBSL_PHYINTEL972_PHYSTAT_SPEED_100       (0x1)
+#define TMBSL_PHYINTEL972_PHYSTAT_SPEED_1000      (0x2)
+
+#define TMBSL_PHYINTEL972_PHYSTAT_DUPLEX          (0x2000)
+#define TMBSL_PHYINTEL972_PHYSTAT_PAGE_RX         (0x1000)
+#define TMBSL_PHYINTEL972_PHYSTAT_SPD_DUP_RES     (0x800)
+#define TMBSL_PHYINTEL972_PHYSTAT_LINK_RT         (0x400)
+#define TMBSL_PHYINTEL972_PHYSTAT_MDI_XOVR_STAT   (0x40)
+#define TMBSL_PHYINTEL972_PHYSTAT_JABBER_RT       (0x1)
+
+/****** Interrupt Enable Register ******/
+#define TMBSL_PHYINTEL972_IER_AN_ERR              (0x8000)
+#define TMBSL_PHYINTEL972_IER_SPEED_CHG           (0x4000)
+#define TMBSL_PHYINTEL972_IER_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYINTEL972_IER_PG_RX               (0x1000)
+#define TMBSL_PHYINTEL972_IER_AN_COMP             (0x800)
+#define TMBSL_PHYINTEL972_IER_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYINTEL972_IER_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYINTEL972_IER_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYINTEL972_IER_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYINTEL972_IER_POLARITY_CHG        (0x2)
+#define TMBSL_PHYINTEL972_IER_JABBER              (0x1)
+
+/****** Interrupt Status Register ******/
+#define TMBSL_PHYINTEL972_ISR_AN_ERR              (0x8000)
+#define TMBSL_PHYINTEL972_ISR_SPEED_CHG           (0x4000)
+#define TMBSL_PHYINTEL972_ISR_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYINTEL972_ISR_PG_RX               (0x1000)
+#define TMBSL_PHYINTEL972_ISR_AN_COMP             (0x800)
+#define TMBSL_PHYINTEL972_ISR_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYINTEL972_ISR_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYINTEL972_ISR_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYINTEL972_ISR_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYINTEL972_ISR_POLARITY_CHG        (0x2)
+#define TMBSL_PHYINTEL972_ISR_JABBER              (0x1)
+
+/****** LED Control Register ******/
+#define TMBSL_PHYINTEL972_LEDCR_DISABLE_LED        (0x8000)
+#define TMBSL_PHYINTEL972_LEDCR_LINK_CTL           (0x8)
+#define TMBSL_PHYINTEL972_LEDCR_RX_CTL             (0x2)
+#define TMBSL_PHYINTEL972_LEDCR_TX_CTL             (0x1)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyIntel972Context_t
+{
+    UInt32	pRegs;         // Array ETHERNET Module regs
+} tmbslPhyIntel972Context_t, *ptmbslPhyINTEL972Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetSWVersion (
+    ptmSWVersion_t	pPhyVersion
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetCapabilities (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCapabilities_t	pPhyCaps
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.
+//		1. Enable the auto negotiation. In auto-negotiation mode the
+//		highest possible performance mode is selected automatically
+//		which the Link Partner also supports. (In auto negotiation mode
+//		speed and duplex mode will be selected by means of auto negotiation.
+//		Writing to speed and duplex mode does not have meaning in auto
+//		negotiation mode.)
+//		2. The device abilities are programmed to Auto negotiation advertise
+//		register. None of the device abilities are masked. If the PHY
+//		device does not support Auto-negotiation mode, then this function
+//		will set the PHY to basic capabilities of the device.The function
+//		tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to
+//		know what are the default configurations the tmbslPhyInit function
+//		has set to
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972Init(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyIntel972Deinit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972SetPowerState(
+    tmUnitSelect_t	phyUnitId ,
+    tmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetPowerState(
+    tmUnitSelect_t	phyUnitId,
+    ptmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.
+//		tmbslPhyInit Enable the Auto negotiation mode and will configure
+//		the PHY device for the maximum performance mode available. After
+//		the device is initialized this function can be called to know the
+//		present settings of the PHY device. If application wants to change
+//		the settings it can call tmbslPhySetBasicModeControl to change
+//		the configuration after knowing the capabilities of the PHY device
+//		and Link Partner. #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t
+tmbslPhyIntel972SetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetBasicModeStatus (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972AutoNegotiate (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyAutoNegotitationMask_t    	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetIdentifier (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetCounters (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972PcsConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972PcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result
+//		will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972Bist (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t  	phyPsedoRandomSeq ,
+    pUInt8			pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972ConfigBypass (
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t  	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972LoopBack (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972SoftReset (
+    tmUnitSelect_t	phyUnitId
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972GetLinkStatus (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyIntel972
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyIntel972.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/src/tmbslPhyIntel972.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/src/tmbslPhyIntel972.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/src/tmbslPhyIntel972.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/src/tmbslPhyIntel972.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1002 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyIntel972.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for Intel972 PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor Intel972-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyIntel972.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include <linux/delay.h>
+
+/* Defines */
+
+#define AUTO_NEG_DELAY_MULTIPLIER (300)
+
+#define PHY_TIMEOUT           (100000)
+
+#define TMBSLPHYINTEL972_PHY_MMIO_ADDRESS0 (0xC0000000)
+
+#define ANAR_DEFAULT_VAL            (TMBSL_PHYINTEL972_ANAR_NP | TMBSL_PHYINTEL972_ANAR_ADV_RF | \
+                                     TMBSL_PHYINTEL972_ANAR_AP | TMBSL_PHYINTEL972_ANAR_PAUSE | TMBSL_PHYINTEL972_ANAR_100B_TX_FD | \
+                                     TMBSL_PHYINTEL972_ANAR_100B_TX_HD | TMBSL_PHYINTEL972_ANAR_10B_TX_FD | TMBSL_PHYINTEL972_ANAR_10B_TX_HD |  \
+                                     TMBSL_PHYINTEL972_ANAR_SELECTOR_FIELD)
+
+#define KTCR1_DEFAULT_VAL           (TMBSL_PHYINTEL972_1KTCR_1000BT_FD|TMBSL_PHYINTEL972_1KTCR_1000BT_HD)
+
+/* Global Data */
+
+typedef  enum  _tmbslPhyIntel972Reg_t
+{
+    /* Basic mode control */
+    tmbslPhyIntel972Bmcr       = 0x0,
+    /* Basic mode status */
+    tmbslPhyIntel972Bmsr       = 0x1,
+
+    /* PHY ID1 register */
+    tmbslPhyIntel972PhyIdr1    = 0x2,
+
+    /* PHY ID2 register */
+    tmbslPhyIntel972PhyIdr2    = 0x3,
+
+    /* Auto negotiation advertisement register */
+    tmbslPhyIntel972Anar       = 0x4,
+
+    /* Auto negotiation link partner ability register */
+    tmbslPhyIntel972Anlpar     = 0x5,
+
+    /* Auto negotiation expansion register */
+    tmbslPhyIntel972Aner       = 0x6,
+
+    /* 0xB-1E are reserved */
+
+} tmbslPhyIntel972Reg_t, *ptmbslPhyIntel972Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t
+tmbslPhyIntel972Read (
+   tmUnitSelect_t    ethUnitId,
+   tmbslPhyIntel972Reg_t reg,
+   pUInt16        pVal
+   );
+
+
+static tmErrorCode_t
+tmbslPhyIntel972Write (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyIntel972Reg_t   reg,
+    UInt16        val
+   );
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//    information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//    or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetSWVersion (
+   ptmSWVersion_t pPhyVersion
+   )
+{
+   pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+   pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+   pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+   return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//    unit. The function is callable at any time to return the unit's
+//    capabilities (PHY unit initialization is not necessary).
+//    Capabilities may be different among multiple PHY units.For completeness,
+//    a PHY BSL user should call this function for each PHY unit to
+//    determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyIntel972GetCapabilities (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyCapabilities_t   pPhyCaps
+    )
+
+{
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmsr, &bmsr);
+
+    pPhyCaps->T4Support100Base =
+        (((bmsr & TMBSL_PHYINTEL972_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYINTEL972_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYINTEL972_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYINTEL972_BMSR_10MBPSFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYINTEL972_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYINTEL972_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility =
+                (((bmsr &TMBSL_PHYINTEL972_BMSR_AN_ABLE) > 0) ? True : False);
+
+
+    pPhyCaps->X1000BaseFDSupport = False;
+
+    pPhyCaps->X1000BaseHDSupport = False;
+
+    pPhyCaps->T1000BaseFDSupport = False;
+
+    pPhyCaps->T1000BaseHDSupport = False;
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//    before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//    default initial configuration.No Autonegotiation is done in the
+//    initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyIntel972Init(
+    tmUnitSelect_t   ethUnitId
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt32     timeout = 0;
+    UInt16     regval = 0;
+    UInt16 id1, id2;
+
+    regval = TMBSL_PHYINTEL972_BMCR_RST_VAL | TMBSL_PHYINTEL972_BMCR_AN_EN;
+
+    ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    
+    mdelay(100);
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYINTEL972_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYINTEL972_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);
+    }
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    if( (id1 == 0x13) && (id2 == 0x78e2) )
+    {
+        /* IDs are valid. Do Nothing */
+    }
+    else
+    {
+    //    return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//    deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972Deinit(
+    tmUnitSelect_t   ethUnitId
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    bmcr |= TMBSL_PHYINTEL972_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//    power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972SetPowerState(
+    tmUnitSelect_t   ethUnitId ,
+    tmPowerState_t   phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    ethStatus = tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYINTEL972_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYINTEL972_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,bmcr);
+
+        if(ethStatus == TM_OK)
+        {
+           /* FIXME: On Intel972 phy, unless we read back what ever we just wrote,
+            * the change doesnt take effect.
+            */
+           ethStatus = tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmcr, &bmcr);
+       }
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetPowerState(
+    tmUnitSelect_t   ethUnitId ,
+    ptmPowerState_t  phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     regVal = 0;
+
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYINTEL972_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetBasicModeControl (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyBasicModeControl_t     pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = False;
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYINTEL972_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYINTEL972_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYINTEL972_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYINTEL972_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            break;
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972SetBasicModeControl (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyBasicModeControl_t     pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYINTEL972_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYINTEL972_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYINTEL972_BMCR_SPEED_10;
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//    such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetBasicModeStatus (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyBasicModeStatus_t   pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmsr,bmcr;
+    UInt16     speedVal;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYINTEL972_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYINTEL972_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYINTEL972_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYINTEL972_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYINTEL972_BMCR_AN_EN) == 0)
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYINTEL972_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        switch(bmcr & TMBSL_PHYINTEL972_BMCR_SPEED_MSK)
+        {
+            case TMBSL_PHYINTEL972_BMCR_SPEED_100:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+
+            case TMBSL_PHYINTEL972_BMCR_SPEED_10:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+                break;
+
+            default:
+                break;
+        }
+
+    }
+    else
+    {
+        /* If autonegotiation is enabled, read from LINK_AN register */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYINTEL972_BMCR_FD_EN) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        speedVal = (bmcr & TMBSL_PHYINTEL972_BMCR_SPEED_MSK)>>13;
+
+        switch(speedVal)
+        {
+            case TMBSL_PHYINTEL972_PHYSTAT_SPEED_100 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+            case TMBSL_PHYINTEL972_PHYSTAT_SPEED_10 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps ;
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//    with Link Partner. Best possible performance configuration is
+//    selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972AutoNegotiate (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t pAutoNegotiationMask
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt32     timeout = 0;
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Anar,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_ADV_RF;
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_AP;
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_PAUSE;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_100B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_100B_TX_HD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_10B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYINTEL972_ANAR_10B_TX_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Anar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register
+    ** First clear the auto negotiate bit and then enable
+    */
+    //tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    //regVal &= TMBSL_PHYINTEL972_BMCR_AN_CLR;
+
+    //regVal |= TMBSL_PHYINTEL972_BMCR_AN_EN;
+
+    //tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYINTEL972_BMSR_AN_VAL) != TMBSL_PHYINTEL972_BMSR_AN_VAL) &&
+            (timeout < AUTO_NEG_DELAY_MULTIPLIER) )
+    {
+        mdelay(10);
+    
+        ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmsr,&regVal);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if((timeout <= 0) && ((regVal & TMBSL_PHYINTEL972_BMSR_AN_VAL) != TMBSL_PHYINTEL972_BMSR_AN_VAL))
+    {
+        return(TMBSL_ERR_PHY_AUTONEG_TIMEOUT);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//    mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyIntel972LoopBack (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyEnableDisable_t   loopbackMode
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId,tmbslPhyIntel972Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYINTEL972_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYINTEL972_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyIntel972SoftReset (
+    tmUnitSelect_t   ethUnitId
+   )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyIntel972Write(ethUnitId,tmbslPhyIntel972Bmcr,TMBSL_PHYINTEL972_BMCR_RST_VAL);
+
+    return ethStatus;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetLinkStatus (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyEnableDisable_t  pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    ethStatus = tmbslPhyIntel972Read(ethUnitId, tmbslPhyIntel972Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((bmsr & TMBSL_PHYINTEL972_BMSR_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+// Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyINTEL972Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyIntel972Read (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyIntel972Reg_t   reg,
+    pUInt16       pVal
+   )
+
+{
+    UInt32     timeout = 0;
+    UInt32     pEthRegs;
+    volatile UInt32  *pAdrReg;
+    volatile UInt32  *pDataReg;
+    UInt32     regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyIntel972Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyIntel972Write (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyIntel972Reg_t   reg,
+    UInt16        val
+   )
+
+{
+    UInt32     pEthRegs;
+    volatile UInt32  *pAdrReg;
+    volatile UInt32  *pDataReg;
+    UInt32     regValue;
+    UInt32     timeout = 0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }
+    while (((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+            (timeout < PHY_TIMEOUT));
+
+    if ((timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_WRITE_FAILED);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetIdentifier(
+    tmUnitSelect_t      phyUnitId,
+    ptmbslPhyIdentifier_t        pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyIntel972GetLinkPartnerCapabilities (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc/tmbslPhyMYSTI110E.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc/tmbslPhyMYSTI110E.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc/tmbslPhyMYSTI110E.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc/tmbslPhyMYSTI110E.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,505 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2009-2010, NXP Semiconductors 
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyMYSTI110E.c %
+ * %pid_version:           0.1                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for MystiPHY110e PHY
+ *
+ * DOCUMENT REF: MystiPHY110e Core datasheet version 6.00
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSLPHYMYSTI110E_H_
+#define _TMBSLPHYMYSTI110E_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYMYSTI110E_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYMYSTI110E_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYMYSTI110E_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYMYSTI110E_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYMYSTI110E_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYMYSTI110E_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYMYSTI110E_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYMYSTI110E_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYMYSTI110E_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYMYSTI110E_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYMYSTI110E_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYMYSTI110E_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYMYSTI110E_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYMYSTI110E_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYMYSTI110E_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYMYSTI110E_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYMYSTI110E_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYMYSTI110E_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYMYSTI110E_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYMYSTI110E_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYMYSTI110E_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYMYSTI110E_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYMYSTI110E_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYMYSTI110E_BMSR_AN_VAL (0x20)
+#define TMBSL_PHYMYSTI110E_BMCR_LPBK_VAL (0x4000)
+
+
+/* Remote fault value */
+#define TMBSL_PHYMYSTI110E_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYMYSTI110E_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYMYSTI110E_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYMYSTI110E_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYMYSTI110E_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYMYSTI110E_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYMYSTI110E_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYMYSTI110E_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYMYSTI110E_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYMYSTI110E_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYMYSTI110E_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYMYSTI110E_ANAR_10B_TX_HD (0x20)
+
+/* Selector Field Read-only  */
+#define TMBSL_PHYMYSTI110E_ANAR_SELECTOR_FIELD (0x01)
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYMYSTI110E_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYMYSTI110E_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYMYSTI110E_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYMYSTI110E_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYMYSTI110E_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYMYSTI110E_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYMYSTI110E_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYMYSTI110E_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYMYSTI110E_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYMYSTI110E_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYMYSTI110E_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYMYSTI110E_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYMYSTI110E_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYMYSTI110E_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYMYSTI110E_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYMYSTI110E_STRAP_ANE (0x8000)
+#define TMBSL_PHYMYSTI110E_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYMYSTI110E_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYMYSTI110E_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYMYSTI110E_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYMYSTI110E_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYMYSTI110E_PHYSTS_SPEED_MASK (0x1C)
+
+#define TMBSL_PHYMYSTI110E_PHYSTS_SPEED_10_HD (0x4)
+#define TMBSL_PHYMYSTI110E_PHYSTS_SPEED_10_FD (0x14)
+
+#define TMBSL_PHYMYSTI110E_PHYSTS_SPEED_100_HD (0x8)
+#define TMBSL_PHYMYSTI110E_PHYSTS_SPEED_100_FD (0x18)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyMYSTI110EContext_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyMYSTI110EContext_t, *ptmbslPhyMYSTI110EContext_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyMYSTI110EInit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyMYSTI110EDeinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110ESetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyMYSTI110EGetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyMYSTI110ESetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EAutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ELoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110ELoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110ESoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSLPHYMYSTI110E_H_
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/src/tmbslPhyMYSTI110E.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/src/tmbslPhyMYSTI110E.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/src/tmbslPhyMYSTI110E.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/src/tmbslPhyMYSTI110E.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1572 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2009-2010, NXP Semiconductors
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyMYSTI110E.c %
+ * %pid_version:           0.1                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for MystiPHY110e PHY
+ *
+ * DOCUMENT REF: MystiPHY110e Core datasheet version 6.00
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+#include <linux/kernel.h>
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyMYSTI110E.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include <linux/delay.h>
+#include "remap.h"
+#include <asm/io.h>
+#define AUTO_NEG_DELAY_MULTIPLIER (300)
+#endif
+
+/* Defines */
+
+#define PHY_TIMEOUT                 (100000)
+
+#define ANAR_DEFAULT_VAL (TMBSL_PHYMYSTI110E_ANAR_NP | TMBSL_PHYMYSTI110E_ANAR_ADV_RF | \
+                          TMBSL_PHYMYSTI110E_ANAR_AP | TMBSL_PHYMYSTI110E_ANAR_PAUSE | TMBSL_PHYMYSTI110E_ANAR_100B_TX_FD | \
+                          TMBSL_PHYMYSTI110E_ANAR_100B_TX_HD | TMBSL_PHYMYSTI110E_ANAR_10B_TX_FD | TMBSL_PHYMYSTI110E_ANAR_10B_TX_HD |  \
+                          TMBSL_PHYMYSTI110E_ANAR_SELECTOR_FIELD)
+
+#define ANDSP_DEBUG 0
+
+#define MYSTIPHY_APOLLO_M0_ID1 (0)
+#define MYSTIPHY_APOLLO_M0_ID2 (0)
+#define MYSTIPHY_APOLLO_M1_ID1 (0x0293)
+#define MYSTIPHY_APOLLO_M1_ID2 (0xC411)
+
+#define MYSTIPHY_DSPW_DCBLW_REG      (0x00)
+#define MYSTIPHY_DSPW_DBGCNTL_REG    (0x01)
+#define MYSTIPHY_DSPW_ATHR1_REG      (0x02)
+#define MYSTIPHY_DSPW_ATHR2_REG      (0x03)
+#define MYSTIPHY_DSPW_ATHR3_REG      (0x04)
+#define MYSTIPHY_DSPW_ATHR4_REG      (0x05)
+#define MYSTIPHY_DSPW_ATHR5_REG      (0x06)
+#define MYSTIPHY_DSPW_ATHR6_REG      (0x07)
+#define MYSTIPHY_DSPW_ATHR7_REG      (0x08)
+#define MYSTIPHY_DSPW_ONLVL_REG      (0x09)
+#define MYSTIPHY_DSPW_OFFLVL0123_REG (0x0A)
+#define MYSTIPHY_DSPW_OFFLVL4567_REG (0x0B)
+#define MYSTIPHY_DSPW_TIMESET_REG    (0x0C)
+#define MYSTIPHY_DSPW_BINIT1_REG     (0x0D)
+#define MYSTIPHY_DSPW_BINIT2_REG     (0x0E)
+#define MYSTIPHY_DSPW_TIMING1_REG    (0x0F)
+#define MYSTIPHY_DSPW_TIMING2_REG    (0x10)
+#define MYSTIPHY_DSPW_CONFIG_REG     (0x11)
+#define MYSTIPHY_DSPW_A1CFG_REG      (0x12)
+#define MYSTIPHY_DSPW_A2CFG_REG      (0x13)
+#define MYSTIPHY_DSPW_A3CFG_REG      (0x14)
+#define MYSTIPHY_DSPW_A4CFG_REG      (0x15)
+#define MYSTIPHY_DSPW_A5CFG_REG      (0x16)
+#define MYSTIPHY_DSPW_A6CFG_REG      (0x17)
+#define MYSTIPHY_DSPW_A7CFG_REG      (0x18)
+#define MYSTIPHY_DSPW_DSPCONFIG2_REG (0x19)
+#define MYSTIPHY_DSPW_A8CFG_REG      (0x1A)
+#define MYSTIPHY_DSPW_A9CFG_REG      (0x1B)
+#define MYSTIPHY_DSPW_A10CFG_REG     (0x1C)
+#define MYSTIPHY_DSPW_A11CFG_REG     (0x1D)
+#define MYSTIPHY_DSPW_GAIN1_REG      (0x1E)
+#define MYSTIPHY_DSPW_GAIN2_REG      (0x1F)
+
+#define MYSTIPHY_DSPR_GPSTS_REG      (0x00)
+#define MYSTIPHY_DSPR_FEQ1_REG       (0x01)
+#define MYSTIPHY_DSPR_FEQ2_REG       (0x02)
+#define MYSTIPHY_DSPR_DFE01_REG      (0x03)
+#define MYSTIPHY_DSPR_DFE02_REG      (0x04)
+#define MYSTIPHY_DSPR_DFE03_REG      (0x05)
+#define MYSTIPHY_DSPR_DFE04_REG      (0x06)
+#define MYSTIPHY_DSPR_DFE05_REG      (0x07)
+#define MYSTIPHY_DSPR_DFE06_REG      (0x08)
+#define MYSTIPHY_DSPR_DFE07_REG      (0x09)
+#define MYSTIPHY_DSPR_DFE08_REG      (0x0A)
+#define MYSTIPHY_DSPR_DFE09_REG      (0x0B)
+#define MYSTIPHY_DSPR_DFE10_REG      (0x0C)
+#define MYSTIPHY_DSPR_DFE11_REG      (0x0D)
+#define MYSTIPHY_DSPR_DFE12_REG      (0x0E)
+#define MYSTIPHY_DSPR_EQ_OUT_P2_REG  (0x0F)
+#define MYSTIPHY_DSPR_DSPRES_REG     (0x10)
+#define MYSTIPHY_DSPR_MAXERR_REG     (0x11)
+#define MYSTIPHY_DSPR_FEQOUT1_REG    (0x12)
+#define MYSTIPHY_DSPR_FEQOUT2_REG    (0x13)
+#define MYSTIPHY_DSPR_A3CFG_REG      (0x14)
+#define MYSTIPHY_DSPR_A4CFG_REG      (0x15)
+#define MYSTIPHY_DSPR_A5CFG_REG      (0x16)
+#define MYSTIPHY_DSPR_A6CFG_REG      (0x17)
+#define MYSTIPHY_DSPR_DF_REG         (0x18)
+#define MYSTIPHY_DSPR_VBERLOCK_REG   (0x19)
+#define MYSTIPHY_DSPR_Z_REG          (0x1A)
+#define MYSTIPHY_DSPR_DZ_REG         (0x1B)
+#define MYSTIPHY_DSPR_MAX_REGS       (MYSTIPHY_DSPR_DZ_REG + 1)
+
+#define MYSTIPHY_DSPW_OFFLVL_MASK    (7)
+#define MYSTIPHY_DSPW_OFFLVL0_SHIFT  (0)
+#define MYSTIPHY_DSPW_OFFLVL1_SHIFT  (4)
+#define MYSTIPHY_DSPW_OFFLVL2_SHIFT  (8)
+#define MYSTIPHY_DSPW_OFFLVL3_SHIFT  (12)
+#define MYSTIPHY_DSPW_OFFLVL4_SHIFT  (0)
+#define MYSTIPHY_DSPW_OFFLVL5_SHIFT  (4)
+#define MYSTIPHY_DSPW_OFFLVL6_SHIFT  (8)
+#define MYSTIPHY_DSPW_OFFLVL7_SHIFT  (12)
+#define MYSTIPHY_DSPW_OFFLVL0(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL0_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL1(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL1_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL2(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL2_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL3(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL3_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL4(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL4_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL5(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL5_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL6(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL6_SHIFT)
+#define MYSTIPHY_DSPW_OFFLVL7(x)     (((x)&MYSTIPHY_DSPW_OFFLVL_MASK)<<MYSTIPHY_DSPW_OFFLVL7_SHIFT)
+
+
+#define MYSTIPHY_DSPW_OFFLVL0123_VAL ( MYSTIPHY_DSPW_OFFLVL0(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL1(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL2(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL3(2) )
+#define MYSTIPHY_DSPW_OFFLVL4567_VAL ( MYSTIPHY_DSPW_OFFLVL4(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL5(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL6(2) \
+                                     | MYSTIPHY_DSPW_OFFLVL7(2) )
+
+#define MYSTIPHY_DSPW_A2CFG_RX_SRC_NORMAL_SHIFT (0)
+#define MYSTIPHY_DSPW_A2CFG_RX_SRC_NORMAL       (0 << MYSTIPHY_DSPW_A2CFG_RX_SRC_NORMAL_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RX_SRC_BYREGS       (1 << MYSTIPHY_DSPW_A2CFG_RX_SRC_NORMAL_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT        (1)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_000       (0 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_250       (1 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_375       (2 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_500       (3 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_625       (4 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_750       (5 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_875       (6 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXGAIN_X2_000       (7 << MYSTIPHY_DSPW_A2CFG_RXGAIN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXPD_SHIFT          (4)
+#define MYSTIPHY_DSPW_A2CFG_RXPD_POWERED_UP     (0 << MYSTIPHY_DSPW_A2CFG_RXPD_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXPD_POWERED_DN     (1 << MYSTIPHY_DSPW_A2CFG_RXPD_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXMDIXEN_SHIFT      (5)
+#define MYSTIPHY_DSPW_A2CFG_RXMDIXEN_MDI        (0 << MYSTIPHY_DSPW_A2CFG_RXMDIXEN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXMDIXEN_MDIX       (1 << MYSTIPHY_DSPW_A2CFG_RXMDIXEN_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXPREPGA_SHIFT      (6)
+#define MYSTIPHY_DSPW_A2CFG_RXPREPGA_X0_278     (0 << MYSTIPHY_DSPW_A2CFG_RXPREPGA_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXPREPGA_X0_416     (1 << MYSTIPHY_DSPW_A2CFG_RXPREPGA_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXLPFBYP_SHIFT      (7)
+#define MYSTIPHY_DSPW_A2CFG_RXLPFBYP_ENABLED    (0 << MYSTIPHY_DSPW_A2CFG_RXLPFBYP_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXLPFBYP_BYPASSED   (1 << MYSTIPHY_DSPW_A2CFG_RXLPFBYP_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXCLKINV_SHIFT      (8)
+#define MYSTIPHY_DSPW_A2CFG_RXCLKINV_NORMAL     (0 << MYSTIPHY_DSPW_A2CFG_RXCLKINV_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXCLKINV_INVERTED   (1 << MYSTIPHY_DSPW_A2CFG_RXCLKINV_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_SHIFT     (9)
+#define MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_MASK      (7)
+#define MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_VAL(x)    (((x)&MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_MASK) << MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXITRIM_SHIFT       (12)
+#define MYSTIPHY_DSPW_A2CFG_RXITRIM_MASK        (7)
+#define MYSTIPHY_DSPW_A2CFG_RXITRIM_VAL(x)      (((x)&MYSTIPHY_DSPW_A2CFG_RXITRIM_MASK) << MYSTIPHY_DSPW_A2CFG_RXITRIM_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXDASEL_SHIFT       (15)
+#define MYSTIPHY_DSPW_A2CFG_RXDASEL_ADCOUT      (0 << MYSTIPHY_DSPW_A2CFG_RXDASEL_SHIFT)
+#define MYSTIPHY_DSPW_A2CFG_RXDASEL_RAWDATA     (1 << MYSTIPHY_DSPW_A2CFG_RXDASEL_SHIFT)
+
+/* A2CFG = 0x5600 */
+#define MYSTIPHY_DSPW_A2CFG_VAL ( /*15 0  */ MYSTIPHY_DSPW_A2CFG_RXDASEL_ADCOUT   \
+                                | /*12 101*/ MYSTIPHY_DSPW_A2CFG_RXITRIM_VAL(5)   \
+                                | /*9  011*/ MYSTIPHY_DSPW_A2CFG_RXVMIDADJ_VAL(3) \
+                                | /*8  0  */ MYSTIPHY_DSPW_A2CFG_RXCLKINV_NORMAL  \
+                                | /*7  0  */ MYSTIPHY_DSPW_A2CFG_RXLPFBYP_ENABLED \
+                                | /*6  0  */ MYSTIPHY_DSPW_A2CFG_RXPREPGA_X0_278  \
+                                | /*5  0  */ MYSTIPHY_DSPW_A2CFG_RXMDIXEN_MDI     \
+                                | /*4  0  */ MYSTIPHY_DSPW_A2CFG_RXPD_POWERED_UP  \
+                                | /*1  000*/ MYSTIPHY_DSPW_A2CFG_RXGAIN_X1_000    \
+                                | /*0  0  */ MYSTIPHY_DSPW_A2CFG_RX_SRC_NORMAL    ) 
+
+#define MYSTIPHY_DSPW_RXGAIN_MASK     (7)
+#define MYSTIPHY_DSPW_RXGAIN0_SHIFT   (0)
+#define MYSTIPHY_DSPW_RXGAIN0(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN0_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA0_SHIFT (3)
+#define MYSTIPHY_DSPW_RXPREPGA0(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA0_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN1_SHIFT   (4)
+#define MYSTIPHY_DSPW_RXGAIN1(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN1_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA1_SHIFT (7)
+#define MYSTIPHY_DSPW_RXPREPGA1(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA1_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN2_SHIFT   (8)
+#define MYSTIPHY_DSPW_RXGAIN2(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN2_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA2_SHIFT (11)
+#define MYSTIPHY_DSPW_RXPREPGA2(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA2_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN3_SHIFT   (12)
+#define MYSTIPHY_DSPW_RXGAIN3(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN3_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA3_SHIFT (15)
+#define MYSTIPHY_DSPW_RXPREPGA3(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA3_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN4_SHIFT   (0)
+#define MYSTIPHY_DSPW_RXGAIN4(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN4_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA4_SHIFT (3)
+#define MYSTIPHY_DSPW_RXPREPGA4(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA4_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN5_SHIFT   (4)
+#define MYSTIPHY_DSPW_RXGAIN5(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN5_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA5_SHIFT (7)
+#define MYSTIPHY_DSPW_RXPREPGA5(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA5_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN6_SHIFT   (8)
+#define MYSTIPHY_DSPW_RXGAIN6(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN6_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA6_SHIFT (11)
+#define MYSTIPHY_DSPW_RXPREPGA6(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA6_SHIFT)
+#define MYSTIPHY_DSPW_RXGAIN7_SHIFT   (12)
+#define MYSTIPHY_DSPW_RXGAIN7(x)      (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXGAIN7_SHIFT)
+#define MYSTIPHY_DSPW_RXPREPGA7_SHIFT (15)
+#define MYSTIPHY_DSPW_RXPREPGA7(x)    (((x)&MYSTIPHY_DSPW_RXGAIN_MASK) << MYSTIPHY_DSPW_RXPREPGA7_SHIFT)
+
+/* GAIN1 = 0x8640 */
+#define MYSTIPHY_DSPW_GAIN1_VAL ( MYSTIPHY_DSPW_RXGAIN0(0) | MYSTIPHY_DSPW_RXPREPGA0(0) \
+                                | MYSTIPHY_DSPW_RXGAIN1(4) | MYSTIPHY_DSPW_RXPREPGA1(0) \
+                                | MYSTIPHY_DSPW_RXGAIN2(6) | MYSTIPHY_DSPW_RXPREPGA2(0) \
+                                | MYSTIPHY_DSPW_RXGAIN3(0) | MYSTIPHY_DSPW_RXPREPGA3(1) )
+
+/* GAIN2 = 0xFDAA */
+#define MYSTIPHY_DSPW_GAIN2_VAL ( MYSTIPHY_DSPW_RXGAIN4(2) | MYSTIPHY_DSPW_RXPREPGA4(1) \
+                                | MYSTIPHY_DSPW_RXGAIN5(2) | MYSTIPHY_DSPW_RXPREPGA5(1) \
+                                | MYSTIPHY_DSPW_RXGAIN6(5) | MYSTIPHY_DSPW_RXPREPGA6(1) \
+                                | MYSTIPHY_DSPW_RXGAIN7(7) | MYSTIPHY_DSPW_RXPREPGA7(1) )
+
+
+#define MYSTIPHY_SMI_TSTCNTL_READ_SHIFT      (15)
+#define MYSTIPHY_SMI_TSTCNTL_READ            (1 << MYSTIPHY_SMI_TSTCNTL_READ_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_WRITE_SHIFT     (14)
+#define MYSTIPHY_SMI_TSTCNTL_WRITE           (1 << MYSTIPHY_SMI_TSTCNTL_WRITE_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_TSTMODE_SHIFT   (10)
+#define MYSTIPHY_SMI_TSTCNTL_TSTMODE         (1 << MYSTIPHY_SMI_TSTCNTL_TSTMODE_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_TSTMODE_SET     (1 << MYSTIPHY_SMI_TSTCNTL_TSTMODE_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_TSTMODE_CLEAR   (0 << MYSTIPHY_SMI_TSTCNTL_TSTMODE_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_READADDR_SHIFT  (5)
+#define MYSTIPHY_SMI_TSTCNTL_READADDR(x)     ((x) << MYSTIPHY_SMI_TSTCNTL_READADDR_SHIFT)
+#define MYSTIPHY_SMI_TSTCNTL_WRITEADDR_SHIFT (0)
+#define MYSTIPHY_SMI_TSTCNTL_WRITEADDR(x)    ((x) << MYSTIPHY_SMI_TSTCNTL_WRITEADDR_SHIFT)
+
+
+/* Global Data */
+
+/* Register Names -- addresses in decimal because datasheet uses decimal addresses */
+typedef enum	_tmbslPhyMYSTI110EReg_t
+{
+    /* Basic mode control */
+    tmbslPhyMYSTI110EBmcr          = 0,
+      
+    /* Basic mode status */
+    tmbslPhyMYSTI110EBmsr          = 1,
+
+    /* PHY ID1 register */
+    tmbslPhyMYSTI110EPhyIdr1       = 2,
+
+    /* PHY ID2 register */
+    tmbslPhyMYSTI110EPhyIdr2       = 3,
+
+    /* Auto negotiation advertisement register */
+    tmbslPhyMYSTI110EAnar          = 4,
+
+    /* Auto negotiation link partner ability register */
+    tmbslPhyMYSTI110EAnlpar        = 5,
+
+    /* Auto negotiation expansion register */
+    tmbslPhyMYSTI110EAner          = 6,
+
+    /* Auto negotiation next page transmit register */
+    tmbslPhyMYSTI110EAnnPtr        = 7,
+
+    /* Mode Control/Status Register */
+    tmbslPhyMYSTI110EMcsr          = 17,
+
+    /* Special Mode Register */
+    tmbslPhyMYSTI110ESpecialModes  = 18,
+
+    /*SMII Configuration status Register */
+    tmbslPhyMYSTI110ESMIICfgStatus = 19,
+
+   /* Testability / Configuration Control register */
+   tmbslPhyMYSTI110ETstCntl        = 20,
+
+   /* Testability data Read for LSB Register  */
+   tmbslPhyMYSTI110ETstRead1       = 21,
+
+   /* Testability data Read for MSB Register  */
+   tmbslPhyMYSTI110ETstRead2       = 22,
+
+   /* Testability / Cofiguration data Write Register */
+   tmbslPhyMYSTI110ETstWrite       = 23,
+
+   /* LED Direct Control Register (this is not a register in MYSTI110E) */
+   tmbslPhyMYSTI110ELedcr = 0x18,
+
+   /* Control / Status Indication Register */
+   tmbslPhyMYSTI110ECtrlStatusInd  = 27,
+
+   /* Special Internal testability controls register */
+   tmbslPhyMYSTI110ESitc           = 28,
+
+   /* Interrupt Source Register register */
+   tmbslPhyMYSTI110EIntStatus      = 29,
+
+   /* Interrupt Mask Register register */
+   tmbslPhyMYSTI110EIntMask        = 30,
+
+   /* PHY SPecial Control/Status Register register (31) */
+    tmbslPhyMYSTI110EPhystsr       = 31
+
+} tmbslPhyMYSTI110EReg_t, *ptmbslPhyMYSTI110EReg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t
+tmbslPhyMYSTI110ERead (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyMYSTI110EReg_t				reg,
+    pUInt16						pVal
+	);
+
+
+static tmErrorCode_t
+tmbslPhyMYSTI110EWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyMYSTI110EReg_t				reg,
+    UInt16						val
+	);
+
+static tmErrorCode_t
+tmbslPhyMYSTI110EUnlockAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	);
+
+static tmErrorCode_t
+tmbslPhyMYSTI110ELockDnAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	);
+
+static tmErrorCode_t
+tmbslPhyMYSTI110EDumpAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	);
+
+static tmErrorCode_t
+tmbslPhyMYSTI110EAnDSPRegWR (
+	tmUnitSelect_t  						ethUnitId,
+	UInt16									inRegAddr,
+	UInt16									inDataVal
+	);
+
+static unsigned int tmbslPhyMYSTI110EAnDSPRegDump[MYSTIPHY_DSPR_MAX_REGS];
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+//	UInt32		timeout=0;
+
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's
+//				capabilities (PHY unit initialization is not necessary).
+//				Capabilities may be different among multiple PHY units.For completeness,
+//				a PHY BSL user should call this function for each PHY unit to
+//				determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetCapabilities (
+    tmUnitSelect_t                			ethUnitId,
+    ptmbslPhyCapabilities_t  				pPhyCaps
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyMYSTI110ERead(ethUnitId, tmbslPhyMYSTI110EBmsr, &bmsr);
+
+
+    pPhyCaps->T4Support100Base =
+        (((bmsr & TMBSL_PHYMYSTI110E_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYMYSTI110E_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYMYSTI110E_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYMYSTI110E_BMSR_10MBPSFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYMYSTI110E_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYMYSTI110E_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility =
+                (((bmsr &TMBSL_PHYMYSTI110E_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//				default initial configuration.No Autonegotiation is done in the
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyMYSTI110EInit(
+    tmUnitSelect_t  						ethUnitId
+    )
+{
+
+	tmErrorCode_t       		ethStatus = TM_OK;
+	UInt16 regval=0, id1, id2;
+    
+
+    /* This is an undocumented register -- clearing bit 0 has unknown effects */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110ELedcr,&regval);
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    regval &= 0xfffe;
+    ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110ELedcr,regval);
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Soft Reset the PHY and initialze the AnDSP registers */
+    ethStatus = tmbslPhyMYSTI110ESoftReset (ethUnitId);
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EPhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EPhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    if( (id1 == MYSTIPHY_APOLLO_M0_ID1) && (id2 == MYSTIPHY_APOLLO_M0_ID2) )
+    {
+        // IDs are valid. Do Nothing
+    }
+    else
+    {
+        /* TODO: Add ID check for M1 */
+        if( (id1 == MYSTIPHY_APOLLO_M1_ID1) && (id2 == MYSTIPHY_APOLLO_M1_ID2) )
+        {
+            // ID's are valid.  Do Nothing
+        }
+        else
+        {
+            return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+        }
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110EDeinit(
+    tmUnitSelect_t  						ethUnitId
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYMYSTI110E_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EBmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ESetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110ESetPowerState(
+    tmUnitSelect_t           				ethUnitId ,
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId, tmbslPhyMYSTI110EBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYMYSTI110E_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYMYSTI110E_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EBmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYMYSTI110E_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest =
+                (((bmcr & TMBSL_PHYMYSTI110E_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYMYSTI110E_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYMYSTI110E_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ESetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110ESetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYMYSTI110E_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYMYSTI110E_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYMYSTI110E_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYMYSTI110E_BMCR_SPEED_10;
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EBmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId, tmbslPhyMYSTI110EBmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId, tmbslPhyMYSTI110EBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId, tmbslPhyMYSTI110EPhystsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYMYSTI110E_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYMYSTI110E_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYMYSTI110E_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYMYSTI110E_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYMYSTI110E_BMCR_AN_EN) == 0)
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYMYSTI110E_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYMYSTI110E_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+        }
+
+    }
+    else
+    {
+
+        /* If autonegotiation is enabled, read from PHYSTS register */
+
+        switch(phySts & TMBSL_PHYMYSTI110E_PHYSTS_SPEED_MASK )
+        {
+
+            case TMBSL_PHYMYSTI110E_PHYSTS_SPEED_100_FD:
+                pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps ;
+                break;
+
+            case TMBSL_PHYMYSTI110E_PHYSTS_SPEED_100_HD:
+                pPhyBasicModeStatus->duplexMode = tmbslPhyHalfDuplex;
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+
+            case TMBSL_PHYMYSTI110E_PHYSTS_SPEED_10_FD:
+                pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+                pPhyBasicModeStatus->speed=tmbslPhySpeed10Mbps;
+                break;
+
+            case TMBSL_PHYMYSTI110E_PHYSTS_SPEED_10_HD:
+                pPhyBasicModeStatus->duplexMode = tmbslPhyHalfDuplex;
+                pPhyBasicModeStatus->speed=tmbslPhySpeed10Mbps;
+                break;
+
+            default:
+                pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps ;
+                break;
+
+        }
+
+    }
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//				with Link Partner. Best possible performance configuration is
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EAutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=AUTO_NEG_DELAY_MULTIPLIER; /* Timeout of 800*5 msecs = 4 Sec */
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EAnar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_NP;
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_ADV_RF;
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_AP;
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_PAUSE;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_100B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_100B_TX_HD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_10B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYMYSTI110E_ANAR_10B_TX_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EAnar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYMYSTI110E_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYMYSTI110E_BMCR_AN_EN;
+
+    tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EBmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYMYSTI110E_BMSR_AN_VAL) != TMBSL_PHYMYSTI110E_BMSR_AN_VAL) &&
+           (timeout > 0 ) )
+    {
+        mdelay(10);
+
+        ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmsr,&regVal);
+
+        if(ethStatus != TM_OK)
+        {
+            return ethStatus;
+        }
+
+        timeout--;
+    }
+
+    if((timeout <= 0) && ((regVal & TMBSL_PHYMYSTI110E_BMSR_AN_VAL) != TMBSL_PHYMYSTI110E_BMSR_AN_VAL))
+    {
+        return(TMBSL_ERR_PHY_AUTONEG_TIMEOUT);
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ELoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyMYSTI110ELoopBack (
+    tmUnitSelect_t                  ethUnitId,
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYMYSTI110E_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYMYSTI110E_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyMYSTI110EWrite(ethUnitId,tmbslPhyMYSTI110EBmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ESoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyMYSTI110ESoftReset (
+    tmUnitSelect_t                     		ethUnitId
+	)
+
+{
+	tmErrorCode_t       		ethStatus=TM_OK;
+
+	UInt32 timeout=0;
+	UInt16 regval=0;
+
+   /* All the registers will be reset */
+   ethStatus = tmbslPhyMYSTI110EWrite(
+      ethUnitId,
+      tmbslPhyMYSTI110EBmcr,
+      TMBSL_PHYMYSTI110E_BMCR_RST_VAL);
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    do
+    {
+        ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmcr,&regval);
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+        timeout++;
+    }while( (regval & TMBSL_PHYMYSTI110E_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYMYSTI110E_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);
+    }
+
+   /* Unlocking Access to the Mysticom's EPHY Analog and DSP Register Set */
+   ethStatus = tmbslPhyMYSTI110EUnlockAnDSPRegs(ethUnitId);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+
+   /* Display contents of the Mysticom EPHY Analog and DSP Register Set */
+   ethStatus = tmbslPhyMYSTI110EDumpAnDSPRegs(ethUnitId);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   /* Modify the Deassertion ENERGY_DETECT threshold settings OFFLVL0123 */
+   ethStatus = tmbslPhyMYSTI110EAnDSPRegWR(
+      ethUnitId,
+      MYSTIPHY_DSPW_OFFLVL0123_REG,
+      MYSTIPHY_DSPW_OFFLVL0123_VAL);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   /* Modify the Deassertion ENERGY_DETECT threshold settings OFFLVL4567 */
+   ethStatus = tmbslPhyMYSTI110EAnDSPRegWR(
+      ethUnitId,
+      MYSTIPHY_DSPW_OFFLVL4567_REG,
+      MYSTIPHY_DSPW_OFFLVL4567_VAL);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   /* Modify the GAIN1 to correct issues in the Baseline Wander Test */
+   ethStatus = tmbslPhyMYSTI110EAnDSPRegWR(
+      ethUnitId,
+      MYSTIPHY_DSPW_GAIN1_REG,
+      MYSTIPHY_DSPW_GAIN1_VAL);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   
+   /* Modify the GAIN2 to correct issues in the Baseline Wander Test */
+   ethStatus = tmbslPhyMYSTI110EAnDSPRegWR(
+      ethUnitId,
+      MYSTIPHY_DSPW_GAIN2_REG,
+      MYSTIPHY_DSPW_GAIN2_VAL);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   /* Modify the A2CFG (Analog receiver configuration) to correct issues 
+   in the Baseline Wander Test */
+   ethStatus = tmbslPhyMYSTI110EAnDSPRegWR(
+      ethUnitId,
+      MYSTIPHY_DSPW_A2CFG_REG,
+      MYSTIPHY_DSPW_A2CFG_VAL);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+
+   /* All AnDSP changes are done. Lock down AnDSP Register Access */	
+   ethStatus = tmbslPhyMYSTI110ELockDnAnDSPRegs(ethUnitId);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   
+   return ethStatus;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyMYSTI110EGetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 physts;
+
+    /* Read the BMSR register twice, as per datasheet */
+    ethStatus = tmbslPhyMYSTI110ERead(ethUnitId,tmbslPhyMYSTI110EBmsr,&physts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+        (((physts & TMBSL_PHYMYSTI110E_BMSR_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ERead:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyMYSTI110ERead (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyMYSTI110EReg_t		reg,
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EWrite:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyMYSTI110EWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyMYSTI110EReg_t		reg,
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+             (timeout < PHY_TIMEOUT) );
+
+	if( (timeout == PHY_TIMEOUT) &&
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}
+
+	return TM_OK;
+
+}
+
+
+//555CHK
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EUnlockAnDSPRegs:
+//
+// DESCRIPTION: Function unlocks access to the Mysticom Analog and DSP Register
+//              set. This is done by toggling the TSTMODE bit[10] in MII 
+//				TSTCNTL register. 
+//
+// RETURN: tmErrorCode_t
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+tmbslPhyMYSTI110EUnlockAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	)
+{
+	tmErrorCode_t       		ethStatus = TM_OK;
+
+   // Set TSTMODE	
+	ethStatus = tmbslPhyMYSTI110EWrite(
+	   ethUnitId,
+	   tmbslPhyMYSTI110ETstCntl,
+	   MYSTIPHY_SMI_TSTCNTL_TSTMODE_SET);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+	// Clear TSTMODE
+	ethStatus = tmbslPhyMYSTI110EWrite(
+	   ethUnitId,
+	   tmbslPhyMYSTI110ETstCntl,
+	   MYSTIPHY_SMI_TSTCNTL_TSTMODE_CLEAR);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   #if (ANDSP_DEBUG == 1)
+	printk(KERN_ERR"EPHY AnDSP UNLOCKED\n");
+	#endif
+	return (TM_OK);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EDumpAnDSPRegs:
+//
+// DESCRIPTION: Function dumps the register contents of registers 0 to 27 of 
+//              the Mysticom EPHY Analog and DSP Register Set. 
+
+// RETURN: tmErrorCode_t
+//
+// NOTES: A local copy of the register set is stored in 
+//        tmbslPhyMYSTI110EAnDSPRegDump.
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+tmbslPhyMYSTI110EDumpAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	)
+{
+	tmErrorCode_t       		ethStatus = TM_OK;
+   UInt16 regval=0, anDSPRegAddr, anDSPRegVal;		//- ADDED BY MF
+	
+	for (anDSPRegAddr = 0; anDSPRegAddr < MYSTIPHY_DSPR_MAX_REGS; anDSPRegAddr++)
+	{
+      //- READ=1, TSTMODE=1, READ_ADDRESS=0x15
+      regval = ( MYSTIPHY_SMI_TSTCNTL_READ 
+               | MYSTIPHY_SMI_TSTCNTL_TSTMODE 
+               | MYSTIPHY_SMI_TSTCNTL_READADDR(anDSPRegAddr)
+               );
+      //- EPHY TSTCTL (Reg20). TSTMODE[10]=1
+		ethStatus = tmbslPhyMYSTI110EWrite(
+		   ethUnitId,
+		   tmbslPhyMYSTI110ETstCntl,
+		   regval);
+		if(ethStatus != TM_OK)
+		{
+			return (ethStatus);
+		}
+		//- 0x15 = TSTREAD1
+		ethStatus = tmbslPhyMYSTI110ERead(
+		   ethUnitId,
+		   tmbslPhyMYSTI110ETstRead1,
+		   &anDSPRegVal);
+		if(ethStatus != TM_OK)
+		{
+			return (ethStatus);
+		}
+		tmbslPhyMYSTI110EAnDSPRegDump[anDSPRegAddr] = anDSPRegVal;
+	}
+#if (ANDSP_DEBUG == 1)
+	printk(KERN_ERR"EPHY AnDSP READ Registers Dump:\n");
+	printk(KERN_ERR"EPHY AnDSP 00--07: 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",
+      tmbslPhyMYSTI110EAnDSPRegDump[0], tmbslPhyMYSTI110EAnDSPRegDump[1], 
+      tmbslPhyMYSTI110EAnDSPRegDump[2], tmbslPhyMYSTI110EAnDSPRegDump[3],
+      tmbslPhyMYSTI110EAnDSPRegDump[4], tmbslPhyMYSTI110EAnDSPRegDump[5], 
+      tmbslPhyMYSTI110EAnDSPRegDump[6], tmbslPhyMYSTI110EAnDSPRegDump[7]);
+	printk(KERN_ERR"EPHY AnDSP 08--0F: 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",
+      tmbslPhyMYSTI110EAnDSPRegDump[0x8], tmbslPhyMYSTI110EAnDSPRegDump[0x9], 
+      tmbslPhyMYSTI110EAnDSPRegDump[0xA], tmbslPhyMYSTI110EAnDSPRegDump[0xB],
+      tmbslPhyMYSTI110EAnDSPRegDump[0xC], tmbslPhyMYSTI110EAnDSPRegDump[0xD], 
+      tmbslPhyMYSTI110EAnDSPRegDump[0xE], tmbslPhyMYSTI110EAnDSPRegDump[0xF]);
+	printk(KERN_ERR"EPHY AnDSP 10--17: 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",
+      tmbslPhyMYSTI110EAnDSPRegDump[0x10], tmbslPhyMYSTI110EAnDSPRegDump[0x11], 
+      tmbslPhyMYSTI110EAnDSPRegDump[0x12], tmbslPhyMYSTI110EAnDSPRegDump[0x13],
+      tmbslPhyMYSTI110EAnDSPRegDump[0x14], tmbslPhyMYSTI110EAnDSPRegDump[0x15], 
+      tmbslPhyMYSTI110EAnDSPRegDump[0x16], tmbslPhyMYSTI110EAnDSPRegDump[0x17]);
+	printk(KERN_ERR"EPHY AnDSP 18--1B: 0x%04x 0x%04x 0x%04x 0x%04x\n",
+      tmbslPhyMYSTI110EAnDSPRegDump[0x18], tmbslPhyMYSTI110EAnDSPRegDump[0x19], 
+      tmbslPhyMYSTI110EAnDSPRegDump[0x1A], tmbslPhyMYSTI110EAnDSPRegDump[0x1B]);
+#endif
+	return (TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110EAnDSPRegWR:
+//
+// DESCRIPTION: Function writes the data value(input param 2) and writes it to 
+//              the Analog DSP Register Address supplied in the first parameter. 
+//
+// RETURN: tmErrorCode_t
+//
+// NOTES: ADDED BY MF
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+tmbslPhyMYSTI110EAnDSPRegWR (
+	tmUnitSelect_t  						ethUnitId,
+	UInt16									inRegAddr,
+	UInt16									inDataVal
+	)
+{
+   tmErrorCode_t  ethStatus = TM_OK;
+   UInt16 regval = 0;
+
+   // TST_WRITE_DATA = inDataVal
+	ethStatus = tmbslPhyMYSTI110EWrite(
+	   ethUnitId,
+	   tmbslPhyMYSTI110ETstWrite,
+	   inDataVal);
+	if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+
+	regval = ( MYSTIPHY_SMI_TSTCNTL_WRITE 
+	         | MYSTIPHY_SMI_TSTCNTL_TSTMODE 
+	         | MYSTIPHY_SMI_TSTCNTL_WRITEADDR(inRegAddr) 
+	         );
+   //- TST_CTRL_REG = write, testmode, write address
+	ethStatus = tmbslPhyMYSTI110EWrite(
+	   ethUnitId,
+	   tmbslPhyMYSTI110ETstCntl,
+	   regval);
+	if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }
+   #if (ANDSP_DEBUG == 1)
+	printk(KERN_ERR"EPHY AnDSP WRITE REG %02d = 0x%04x\n", inRegAddr, inDataVal);
+	#endif
+
+	return (TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyMYSTI110ELockAnDSPRegs:
+//
+// DESCRIPTION: Function locks access to the Mysticom Analog and DSP Register
+//              set. This is done by clearing TSTMODE bit[10] in SMI 
+//	             TSTCNTL register. 
+//
+// RETURN: tmErrorCode_t
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+static tmErrorCode_t
+tmbslPhyMYSTI110ELockDnAnDSPRegs (
+	tmUnitSelect_t  						ethUnitId
+	)
+{
+	tmErrorCode_t       		ethStatus = TM_OK;
+ 	
+ 	#if (ANDSP_DEBUG == 1)				
+	printk(KERN_ERR"EPHY AnDSP LOCKED\n");
+	#endif
+	
+	//- Setting TSTMODE=0 Locks down
+	ethStatus = tmbslPhyMYSTI110EWrite(
+	   ethUnitId,
+	   tmbslPhyMYSTI110ETstCntl,
+	   MYSTIPHY_SMI_TSTCNTL_TSTMODE_CLEAR);
+   if(ethStatus != TM_OK)
+   {
+      return (ethStatus);
+   }	
+
+	return (TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc/tmbslPhyRTL8211BN.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc/tmbslPhyRTL8211BN.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc/tmbslPhyRTL8211BN.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc/tmbslPhyRTL8211BN.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,683 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyRTL8211.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for RTL8211 PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor RTL8211BN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyRTL8211_H_
+#define tmbslPhyRTL8211_H
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET  (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL  (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR  (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL  (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYRTL8211_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYRTL8211_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYRTL8211_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYRTL8211_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYRTL8211_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYRTL8211_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYRTL8211_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYRTL8211_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYRTL8211_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYRTL8211_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYRTL8211_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYRTL8211_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYRTL8211_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYRTL8211_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYRTL8211_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYRTL8211_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYRTL8211_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYRTL8211_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYRTL8211_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYRTL8211_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYRTL8211_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYRTL8211_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYRTL8211_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYRTL8211_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYRTL8211_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYRTL8211_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYRTL8211_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYRTL8211_BMSR_JAB_VAL (0x2)
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYRTL8211_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYRTL8211_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYRTL8211_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYRTL8211_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYRTL8211_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYRTL8211_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYRTL8211_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYRTL8211_ANAR_10B_TX_HD (0x20)
+
+/* Indicates the RTL8211BN supports 802.3 */
+#define TMBSL_PHYRTL8211_ANAR_SELECTOR_FIELD (0x1)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYRTL8211_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYRTL8211_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYRTL8211_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYRTL8211_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYRTL8211_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYRTL8211_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYRTL8211_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYRTL8211_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYRTL8211_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYRTL8211_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYRTL8211_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYRTL8211_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYRTL8211_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYRTL8211_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYRTL8211_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** PHY Specific Control register ******/
+#define TMBSL_PHYRTL8211_PHYCR_CRS          (0x800)
+#define TMBSL_PHYRTL8211_PHYCR_FORCE_LNK    (0x400)
+#define TMBSL_PHYRTL8211_PHYCR_DIS_CLK125   (0x10)
+#define TMBSL_PHYRTL8211_PHYCR_DIS_JABBER   (0x1)
+
+/* Bit 6:5 MDI Crossover Mode
+ *   00: Manual MDI Crossover configuration
+ *   01: Manual MDI configuration
+ *   10: Default value
+ * Note: Before setting register, address 0xE bit 10 needs to be set to 1.
+ *       After setting register, a PHY reset is required.
+ */
+#define TMBSL_PHYRTL8211_PHYCR_MDI_XOVR_MODE_MSK (0x60)
+#define TMBSL_PHYRTL8211_PHYCR_MAN_MDI_XOVR      (0x0)
+#define TMBSL_PHYRTL8211_PHYCR_MAN_MDI           (0x1)
+#define TMBSL_PHYRTL8211_PHYCR_MDI               (0x2)
+
+/****** PHY Specific Status Register ******/
+/* Bit 15:14 Speed
+ *   00: 10 Mbps
+ *   01: 100 Mbps
+ *   10: 1000 Mbps
+ *   11: Reserved
+ */
+#define TMBSL_PHYRTL8211_PHYSTAT_SPEED_MSK       (0xC000)
+#define TMBSL_PHYRTL8211_PHYSTAT_SPEED_10        (0x0)
+#define TMBSL_PHYRTL8211_PHYSTAT_SPEED_100       (0x1)
+#define TMBSL_PHYRTL8211_PHYSTAT_SPEED_1000      (0x2)
+
+#define TMBSL_PHYRTL8211_PHYSTAT_DUPLEX          (0x2000)
+#define TMBSL_PHYRTL8211_PHYSTAT_PAGE_RX         (0x1000)
+#define TMBSL_PHYRTL8211_PHYSTAT_SPD_DUP_RES     (0x800)
+#define TMBSL_PHYRTL8211_PHYSTAT_LINK_RT         (0x400)
+#define TMBSL_PHYRTL8211_PHYSTAT_MDI_XOVR_STAT   (0x40)
+#define TMBSL_PHYRTL8211_PHYSTAT_JABBER_RT       (0x1)
+
+/****** Interrupt Enable Register ******/
+#define TMBSL_PHYRTL8211_IER_AN_ERR              (0x8000)
+#define TMBSL_PHYRTL8211_IER_SPEED_CHG           (0x4000)
+#define TMBSL_PHYRTL8211_IER_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYRTL8211_IER_PG_RX               (0x1000)
+#define TMBSL_PHYRTL8211_IER_AN_COMP             (0x800)
+#define TMBSL_PHYRTL8211_IER_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYRTL8211_IER_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYRTL8211_IER_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYRTL8211_IER_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYRTL8211_IER_POLARITY_CHG        (0x2)
+#define TMBSL_PHYRTL8211_IER_JABBER              (0x1)
+
+/****** Interrupt Status Register ******/
+#define TMBSL_PHYRTL8211_ISR_AN_ERR              (0x8000)
+#define TMBSL_PHYRTL8211_ISR_SPEED_CHG           (0x4000)
+#define TMBSL_PHYRTL8211_ISR_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYRTL8211_ISR_PG_RX               (0x1000)
+#define TMBSL_PHYRTL8211_ISR_AN_COMP             (0x800)
+#define TMBSL_PHYRTL8211_ISR_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYRTL8211_ISR_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYRTL8211_ISR_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYRTL8211_ISR_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYRTL8211_ISR_POLARITY_CHG        (0x2)
+#define TMBSL_PHYRTL8211_ISR_JABBER              (0x1)
+
+/****** LED Control Register ******/
+#define TMBSL_PHYRTL8211_LEDCR_DISABLE_LED        (0x8000)
+#define TMBSL_PHYRTL8211_LEDCR_LINK_CTL           (0x8)
+#define TMBSL_PHYRTL8211_LEDCR_RX_CTL             (0x2)
+#define TMBSL_PHYRTL8211_LEDCR_TX_CTL             (0x1)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyRTL8211Context_t
+{
+    UInt32	pRegs;         // Array ETHERNET Module regs
+} tmbslPhyRTL8211Context_t, *ptmbslPhyRTL8211Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetSWVersion (
+    ptmSWVersion_t	pPhyVersion
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetCapabilities (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCapabilities_t	pPhyCaps
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.
+//		1. Enable the auto negotiation. In auto-negotiation mode the
+//		highest possible performance mode is selected automatically
+//		which the Link Partner also supports. (In auto negotiation mode
+//		speed and duplex mode will be selected by means of auto negotiation.
+//		Writing to speed and duplex mode does not have meaning in auto
+//		negotiation mode.)
+//		2. The device abilities are programmed to Auto negotiation advertise
+//		register. None of the device abilities are masked. If the PHY
+//		device does not support Auto-negotiation mode, then this function
+//		will set the PHY to basic capabilities of the device.The function
+//		tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to
+//		know what are the default configurations the tmbslPhyInit function
+//		has set to
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNInit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyRTL8211BNDeinit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSetPowerState(
+    tmUnitSelect_t	phyUnitId ,
+    tmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetPowerState(
+    tmUnitSelect_t	phyUnitId,
+    ptmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.
+//		tmbslPhyInit Enable the Auto negotiation mode and will configure
+//		the PHY device for the maximum performance mode available. After
+//		the device is initialized this function can be called to know the
+//		present settings of the PHY device. If application wants to change
+//		the settings it can call tmbslPhySetBasicModeControl to change
+//		the configuration after knowing the capabilities of the PHY device
+//		and Link Partner. #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetBasicModeStatus (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNAutoNegotiate (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyAutoNegotitationMask_t    	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetIdentifier (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetCounters (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNPcsConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNPcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result
+//		will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNBist (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t  	phyPsedoRandomSeq ,
+    pUInt8			pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNConfigBypass (
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t  	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNLoopBack (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSoftReset (
+    tmUnitSelect_t	phyUnitId
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetLinkStatus (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/makefile	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyRTL8211
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyRTL8211.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/src/tmbslPhyRTL8211BN.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/src/tmbslPhyRTL8211BN.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/src/tmbslPhyRTL8211BN.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/src/tmbslPhyRTL8211BN.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1230 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyRTL8211BN.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for RTL8211BN PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor RTL8211BN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyRTL8211BN.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Defines */
+
+#define PHY_TIMEOUT           (100000)
+
+#define TMBSLPHYRTL8211_PHY_MMIO_ADDRESS0 (0xC0000000)
+
+#define ANAR_DEFAULT_VAL            (TMBSL_PHYRTL8211_ANAR_NP | TMBSL_PHYRTL8211_ANAR_ADV_RF | \
+                                     TMBSL_PHYRTL8211_ANAR_AP | TMBSL_PHYRTL8211_ANAR_PAUSE | TMBSL_PHYRTL8211_ANAR_100B_TX_FD | \
+                                     TMBSL_PHYRTL8211_ANAR_100B_TX_HD | TMBSL_PHYRTL8211_ANAR_10B_TX_FD | TMBSL_PHYRTL8211_ANAR_10B_TX_HD |  \
+                                     TMBSL_PHYRTL8211_ANAR_SELECTOR_FIELD)
+                                     
+#define KTCR1_DEFAULT_VAL           (TMBSL_PHYRTL8211_1KTCR_1000BT_FD|TMBSL_PHYRTL8211_1KTCR_1000BT_HD)
+
+/* Global Data */
+
+typedef  enum  _tmbslPhyRTL8211Reg_t
+{
+    /* Basic mode control */
+    tmbslPhyRTL8211Bmcr       = 0x0,
+    /* Basic mode status */
+    tmbslPhyRTL8211Bmsr       = 0x1,
+
+    /* PHY ID1 register */
+    tmbslPhyRTL8211PhyIdr1    = 0x2,
+
+    /* PHY ID2 register */
+    tmbslPhyRTL8211PhyIdr2    = 0x3,
+
+    /* Auto negotiation advertisement register */
+    tmbslPhyRTL8211Anar       = 0x4,
+
+    /* Auto negotiation link partner ability register */
+    tmbslPhyRTL8211Anlpar     = 0x5,
+
+    /* Auto negotiation expansion register */
+    tmbslPhyRTL8211Aner       = 0x6,
+
+    /* Auto negotiation next page transmit register */
+    tmbslPhyRTL8211AnnPtr     = 0x7,
+
+    /* Auto negotiation Link Partner received Next Page */
+    tmbslPhyRTL8211Annprr     = 0x8,
+
+    /* Auto negotiation 1000 Base-T Master-Slave Control register*/
+    tmbslPhyRTL82111ktcr      = 0x9,
+
+    /* Auto negotiation 1000 Base-T Master-Slave status register*/
+    tmbslPhyRTL82111kstsr     = 0xA,
+
+    /* 0xB-1E are reserved */
+
+    /*Extended status register */
+    tmbslPhyRTL82111kscr      = 0xF,
+
+    /**** Vendor Specific Registers *****/
+    /* PHY Specific Control register */
+    tmbslPhyRTL8211Phycr      = 0x10,
+
+   /* PHY Specific Status register */
+    tmbslPhyRTL8211Physr      = 0x11,
+
+   /* Interrupt Enable register */
+    tmbslPhyRTL8211Ier        = 0x12,
+
+   /* Interrupt Status register */
+    tmbslPhyRTL8211Isr        = 0x13,
+
+   /* Receive Error Counter register */
+    tmbslPhyRTL8211Rxerr      = 0x15,
+
+   /* LED Control register */
+    tmbslPhyRTL8211Ledcr      = 0x18
+
+} tmbslPhyRTL8211Reg_t, *ptmbslPhyRTL8211Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t
+tmbslPhyRTL8211Read (
+   tmUnitSelect_t    ethUnitId,
+   tmbslPhyRTL8211Reg_t reg,
+   pUInt16        pVal
+   );
+
+
+static tmErrorCode_t
+tmbslPhyRTL8211Write (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyRTL8211Reg_t   reg,
+    UInt16        val
+   );
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//    information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//    or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetSWVersion (
+   ptmSWVersion_t pPhyVersion
+   )
+{
+   pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+   pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+   pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+   return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//    unit. The function is callable at any time to return the unit's
+//    capabilities (PHY unit initialization is not necessary).
+//    Capabilities may be different among multiple PHY units.For completeness,
+//    a PHY BSL user should call this function for each PHY unit to
+//    determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetCapabilities (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyCapabilities_t   pPhyCaps
+    )
+
+{
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Bmsr, &bmsr);
+
+
+    /*  Read the extended status register */
+    tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL82111kstsr, &extStat);
+
+
+    pPhyCaps->T4Support100Base =
+        (((bmsr & TMBSL_PHYRTL8211_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYRTL8211_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYRTL8211_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYRTL8211_BMSR_10MBPSFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYRTL8211_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYRTL8211_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility =
+                (((bmsr &TMBSL_PHYRTL8211_BMSR_AN_ABLE) > 0) ? True : False);
+
+
+    pPhyCaps->X1000BaseFDSupport =
+                (((extStat &TMBSL_PHYRTL8211_1KSCR_1000BASEX_FD) > 0) ? True : False);
+
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYRTL8211_1KSCR_1000BASEX_HD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYRTL8211_1KSCR_1000BASET_FD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYRTL8211_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//    before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//    default initial configuration.No Autonegotiation is done in the
+//    initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyRTL8211BNInit(
+    tmUnitSelect_t   ethUnitId
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt32     timeout = 0;
+    UInt16     regval = 0;
+    UInt16 id1, id2;
+
+    regval = TMBSL_PHYRTL8211_BMCR_RST_VAL | TMBSL_PHYRTL8211_BMCR_AN_EN;
+
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYRTL8211_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYRTL8211_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);
+    }
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    if( (id1 == 0x1c) && (id2 == 0xC912) )
+    {
+        /* IDs are valid. Do Nothing */
+    }
+    else
+    {
+        return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//    deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNDeinit(
+    tmUnitSelect_t   ethUnitId
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    bmcr |= TMBSL_PHYRTL8211_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//    power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSetPowerState(
+    tmUnitSelect_t   ethUnitId ,
+    tmPowerState_t   phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYRTL8211_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYRTL8211_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,bmcr);
+
+        if(ethStatus == TM_OK)
+        {
+           /* FIXME: On RTL8211 phy, unless we read back what ever we just wrote,
+            * the change doesnt take effect. 
+            */
+           ethStatus = tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Bmcr, &bmcr);
+       }
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetPowerState(
+    tmUnitSelect_t   ethUnitId ,
+    ptmPowerState_t  phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     regVal = 0;
+
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYRTL8211_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetBasicModeControl (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyBasicModeControl_t     pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest =
+                (((bmcr & TMBSL_PHYRTL8211_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYRTL8211_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYRTL8211_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYRTL8211_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYRTL8211_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYRTL8211_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            break;
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSetBasicModeControl (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyBasicModeControl_t     pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr = 0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYRTL8211_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYRTL8211_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYRTL8211_BMCR_SPEED_1G;
+            break;
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYRTL8211_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYRTL8211_BMCR_SPEED_10;
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//    such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetBasicModeStatus (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyBasicModeStatus_t   pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmsr,bmcr,linkan;
+    UInt16     speedVal;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from Link and Autonegotiation register*/
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId, tmbslPhyRTL8211Physr, &linkan);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYRTL8211_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYRTL8211_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYRTL8211_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYRTL8211_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYRTL8211_BMCR_AN_EN) == 0)
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYRTL8211_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        switch(bmcr & TMBSL_PHYRTL8211_BMCR_SPEED_MSK)
+        {
+            case TMBSL_PHYRTL8211_BMCR_SPEED_1G:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+
+            case TMBSL_PHYRTL8211_BMCR_SPEED_100:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+
+            case TMBSL_PHYRTL8211_BMCR_SPEED_10:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+                break;
+
+            default:
+                break;
+        }
+
+    }
+    else
+    {
+        /* If autonegotiation is enabled, read from LINK_AN register */
+        pPhyBasicModeStatus->duplexMode =
+                (((linkan & TMBSL_PHYRTL8211_PHYSTAT_DUPLEX) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        speedVal = (TMBSL_PHYRTL8211_PHYSTAT_SPEED_MSK & linkan)>>14;
+
+        switch(speedVal)
+        {
+            case TMBSL_PHYRTL8211_PHYSTAT_SPEED_1000 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+            case TMBSL_PHYRTL8211_PHYSTAT_SPEED_100 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+            case TMBSL_PHYRTL8211_PHYSTAT_SPEED_10 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps ;
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//    with Link Partner. Best possible performance configuration is
+//    selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNAutoNegotiate (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t pAutoNegotiationMask
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt32     timeout = 0;
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_NP;
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_ADV_RF;
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_AP;
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_PAUSE;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_100B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_100B_TX_HD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_10B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_ANAR_10B_TX_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Anar,regVal);
+
+    /* For 1G configuration */
+    regVal = KTCR1_DEFAULT_VAL;
+
+    mask =0;
+
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL82111ktcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->maskMSConfigEn == True)
+    {
+        mask |= TMBSL_PHYRTL8211_1KTCR_MS_CONFIG;
+    }
+
+    if(pAutoNegotiationMask->maskMasterEn == True)
+    {
+        mask |= TMBSL_PHYRTL8211_1KTCR_MASTER_EN;
+    }
+
+    if(pAutoNegotiationMask->maskMultiPortEn == True)
+    {
+        mask |= TMBSL_PHYRTL8211_1KTCR_MULTIPORT_EN;
+    }
+
+    if(pAutoNegotiationMask->mask1000BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_1KTCR_1000BT_FD;
+    }
+
+    if(pAutoNegotiationMask->mask1000BaseTHalfDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYRTL8211_1KTCR_1000BT_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the master/Slave config register 1KTCR */
+    tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL82111ktcr,regVal);
+
+    /* 1G config ends */
+
+    /* Enable the Auto negotiation in the BMCR register
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYRTL8211_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYRTL8211_BMCR_AN_EN;
+
+    tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYRTL8211_BMSR_AN_VAL) != TMBSL_PHYRTL8211_BMSR_AN_VAL) &&
+            (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmsr,&regVal);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if((timeout >= PHY_TIMEOUT) && ((regVal & TMBSL_PHYRTL8211_BMSR_AN_VAL) != TMBSL_PHYRTL8211_BMSR_AN_VAL))
+    {        
+        return(TMBSL_ERR_PHY_AUTONEG_TIMEOUT);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//    mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyRTL8211BNLoopBack (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyEnableDisable_t   loopbackMode
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYRTL8211_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYRTL8211_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyRTL8211BNSoftReset (
+    tmUnitSelect_t   ethUnitId
+   )
+
+{
+    tmErrorCode_t ethStatus = TM_OK;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyRTL8211Write(ethUnitId,tmbslPhyRTL8211Bmcr,TMBSL_PHYRTL8211_BMCR_RST_VAL);
+
+    return ethStatus;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetLinkStatus (
+    tmUnitSelect_t      ethUnitId,
+    ptmbslPhyEnableDisable_t  pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     Physr;
+
+    /* Read the PHYSR register */
+    ethStatus = tmbslPhyRTL8211Read(ethUnitId,tmbslPhyRTL8211Physr,&Physr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((Physr & TMBSL_PHYRTL8211_PHYSTAT_LINK_RT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+// Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyRTL8211Read (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyRTL8211Reg_t   reg,
+    pUInt16       pVal
+   )
+
+{
+    UInt32     timeout = 0;
+    UInt32     pEthRegs;
+    volatile UInt32  *pAdrReg;
+    volatile UInt32  *pDataReg;
+    UInt32     regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyRTL8211Write (
+    tmUnitSelect_t      ethUnitId,
+    tmbslPhyRTL8211Reg_t   reg,
+    UInt16        val
+   )
+
+{
+    UInt32     pEthRegs;
+    volatile UInt32  *pAdrReg;
+    volatile UInt32  *pDataReg;
+    UInt32     regValue;
+    UInt32     timeout = 0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }
+    while (((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+            (timeout < PHY_TIMEOUT));
+
+    if ((timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_WRITE_FAILED);
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetIdentifier(
+    tmUnitSelect_t      phyUnitId,
+    ptmbslPhyIdentifier_t        pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyRTL8211BNGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyRTL8211BNGetLinkPartnerCapabilities (
+    tmUnitSelect_t         ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyGetCounters(
+    tmUnitSelect_t      phyUnitId,
+    ptmbslPhyCounters_t       pPhyCounters
+    )
+{
+    tmErrorCode_t ethStatus = TM_OK;
+    UInt16     rxerr = 0;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyRTL8211Read(phyUnitId, tmbslPhyRTL8211Rxerr, &rxerr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyCounters->rxErrorCounter           = rxerr;
+    pPhyCounters->disconnectCounter        = 0;
+    pPhyCounters->falseCarrierEventCounter = 0;
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsSetConfig(
+    tmUnitSelect_t      phyUnitId,
+    ptmbslPhyPcsConfig_t   pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsGetConfig (
+    tmUnitSelect_t      phyUnitId,
+    ptmbslPhyPcsConfig_t      pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslPhyBist(
+    tmUnitSelect_t      phyUnitId,
+    tmbslPhyPseudoRandomSeq_t phyPsedoRandomSeq ,
+    pUInt8                       pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyConfigBypass(
+    tmUnitSelect_t   phyUnitId,
+    ptmbslPhyBypass_t   pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/inc/tmbslPhySMSC8700.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/inc/tmbslPhySMSC8700.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/inc/tmbslPhySMSC8700.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/inc/tmbslPhySMSC8700.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,504 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8700.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8700 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSL_PHYSMSC8700_H_
+#define _TMBSL_PHYSMSC8700_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYSMSC8700_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYSMSC8700_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYSMSC8700_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYSMSC8700_BMCR_AN_EN (0x1000)
+
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART (0x200)
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART_CLR (0xFDFF)
+
+#define TMBSL_PHYSMSC8700_BMCR_AN_CLR (0xEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYSMSC8700_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYSMSC8700_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYSMSC8700_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYSMSC8700_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYSMSC8700_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYSMSC8700_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYSMSC8700_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYSMSC8700_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYSMSC8700_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYSMSC8700_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYSMSC8700_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYSMSC8700_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYSMSC8700_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYSMSC8700_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYSMSC8700_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYSMSC8700_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYSMSC8700_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYSMSC8700_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYSMSC8700_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYSMSC8700_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYSMSC8700_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYSMSC8700_ANAR_PAUSE (0xc00)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYSMSC8700_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYSMSC8700_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYSMSC8700_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYSMSC8700_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYSMSC8700_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYSMSC8700_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYSMSC8700_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYSMSC8700_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYSMSC8700_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYSMSC8700_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYSMSC8700_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYSMSC8700_STRAP_ANE (0x8000)
+#define TMBSL_PHYSMSC8700_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYSMSC8700_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYSMSC8700_PHYSTS_SPEED_MSK (0xC)
+#define TMBSL_PHYSMSC8700_PHYSTS_LINK_STAT (0x4)
+#define TMBSL_PHYSMSC8700_PHYSTS_DUP_MODE (0x10)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhySMSC8700Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhySMSC8700Context_t, *ptmbslPhySMSC8700Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhySMSC8700Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhySMSC8700Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhySMSC8700GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhySMSC8700SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSL_PHYSMSC8700_H_
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/src/tmbslPhySMSC8700.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/src/tmbslPhySMSC8700.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/src/tmbslPhySMSC8700.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/src/tmbslPhySMSC8700.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1190 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8700.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8700 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhySMSC8700.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include <linux/delay.h>
+#include "remap.h"
+#include <asm/io.h>
+#include <i2c_ip3203.h>
+
+#define AUTO_NEG_DELAY_MS (4000)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYSMSC8700_PHY_MMIO_ADDRESS0 (0xC0000000) 
+
+#define ANAR_DEFAULT_VAL (0x1E1)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+tmbslPhySMSC8700Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYSMSC8700_PHY_MMIO_ADDRESS0}}; 
+
+typedef enum _tmbslPhySMSC8700Reg_t
+{
+    /* Basic mode control */
+    tmbslPhySMSC8700Bmcr		      = 0,  
+
+    /* Basic mode status */    
+    tmbslPhySMSC8700Bmsr		      =1,  
+
+    /* PHY ID1 register */        
+    tmbslPhySMSC8700PhyIdr1		=2,
+
+    /* PHY ID2 register */            
+    tmbslPhySMSC8700PhyIdr2		=3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhySMSC8700Anar			=4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhySMSC8700Anlpar		=5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhySMSC8700Aner			=6,
+
+    /* 0x7 to 0xF reserved-*/
+
+    /* Silicon Revision register */
+    tmbslPhySMSC8700Srr=16,
+
+    /* Mode control & status register */
+    tmbslPhySMSC8700Mcsr=17,
+
+    /* Special modes register */
+    tmbslPhySMSC8700Smr=18,
+
+    /* 19-25 reserved */
+
+    /* Symbol error counter register */    
+    tmbslPhySMSC8700Secr	= 26,
+    
+    /* Control/Status indication register */        
+    tmbslPhySMSC8700Csir = 27,    
+
+    /* Special internal testability controls register*/            
+    tmbslPhySMSC8700Sitcr = 28,        
+    
+    /* Interrupt source register */
+    tmbslPhySMSC8700Isr = 29,
+
+    /* Interrupt mask register */
+    tmbslPhySMSC8700Imr = 30,    
+
+    /* PHY special control & status register */    
+    tmbslPhySMSC8700Pscsr = 31,    
+
+} tmbslPhySMSC8700Reg_t, *ptmbslPhySMSC8700Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhySMSC8700Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhySMSC8700Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t				reg,   
+    UInt16						val
+	);
+
+#if __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8700GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmsr, &bmsr);
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYSMSC8700_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_10MBPSHD) > 0) ? True : False);
+
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYSMSC8700_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration. No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+    #ifdef __LIPP_6300ETH__
+    Bool timerExpired =False;
+    #endif /* __LIPP_6300ETH__ */            
+
+    #if __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Set the mode register to default value */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+//    printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+
+    regval &= 0xBF1F; /* Set to 100Mbps FD, MII mode */
+    regval |= 0x60;    
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+//    printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+
+    regval = TMBSL_PHYSMSC8700_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYSMSC8700_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+
+        #ifdef __LIPP_6300ETH__                
+        msleep(6000);
+        timerExpired = True;
+        #endif    
+
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regval);
+
+        if((ethStatus != TM_OK) || (timerExpired == True))
+        {
+            timeout = PHY_TIMEOUT;        
+            break;
+        }
+
+        timeout++;
+
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYSMSC8700_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYSMSC8700_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYSMSC8700_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYSMSC8700_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYSMSC8700_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8700GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYSMSC8700_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                            
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8700SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+    UInt16 regval;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8700_BMCR_SPEED_100;                
+        /* Set the mode register to default value */
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x60;
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+        printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8700_BMCR_SPEED_10;                
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x20;
+
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+        printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+            
+                
+            break;
+
+        default:
+            break;
+
+    }
+
+    ethStatus = tmbslPhySMSC8700SoftReset(ethUnitId);
+
+    msleep(10);
+    printk(KERN_ERR"\nSPEED/MODE updated from MODE pins\n");               
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Pscsr,&regval);
+    printk(KERN_ERR"\nPHY STS reg:%04x\n",regval);               
+
+    if(ethStatus != TM_OK)
+    {
+        printk(KERN_ERR"\nRESET failed after mode change\n");           
+    }
+
+    /* Write the result to the BMC register */
+//    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Pscsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYSMSC8700_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYSMSC8700_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYSMSC8700_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYSMSC8700_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYSMSC8700_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYSMSC8700_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+        }
+
+    }
+    else 
+    {
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((phySts & TMBSL_PHYSMSC8700_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed= 
+                (((phySts & TMBSL_PHYSMSC8700_PHYSTS_SPEED_MSK) == 0x4) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=0; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    #ifdef __LIPP_6300ETH__
+    Bool timerExpired =False;
+    #endif /* __LIPP_6300ETH__ */            
+
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    printk(KERN_ERR"\nANAR val: %08x\n",regVal);
+   
+    /* Program the Auto negotiation mask */
+    tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Anar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYSMSC8700_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYSMSC8700_BMCR_AN_EN |
+              TMBSL_PHYSMSC8700_BMCR_AN_RESTART;
+    
+    printk(KERN_ERR"\nBMCR val: %08x\n",regVal);
+   
+    tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete */
+    tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYSMSC8700_BMSR_AN_VAL) != TMBSL_PHYSMSC8700_BMSR_AN_VAL) && 
+           (timeout < PHY_TIMEOUT) )
+    {
+        #ifdef __LIPP_6300ETH__                
+        /* Sleep for 6 sec & check the link status */        
+        msleep(AUTO_NEG_DELAY_MS);
+        timerExpired = True;
+        #endif    
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&regVal);
+
+        #ifdef __LIPP_6300ETH__                
+        if((True == timerExpired) && 
+        ((regVal & TMBSL_PHYSMSC8700_BMSR_AN_VAL) != TMBSL_PHYSMSC8700_BMSR_AN_VAL))
+        {
+                                                
+            ethStatus = !TM_OK;
+            printk(KERN_ERR"\nBMSR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Anlpar,&regVal);
+            printk(KERN_ERR"\nANLPAR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Aner,&regVal);
+            printk(KERN_ERR"\nANER val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Mcsr,&regVal);
+            printk(KERN_ERR"\nMCSR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regVal);
+            printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Secr,&regVal);
+            printk(KERN_ERR"\nSymbol error val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Csir,&regVal);
+            printk(KERN_ERR"\nCSIR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regVal);
+            printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Imr,&regVal);
+            printk(KERN_ERR"\nIMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Pscsr,&regVal);
+            printk(KERN_ERR"\nPSCSR val: %08x\n",regVal);           
+
+            printk(KERN_ERR"\nAUTONEG FAILED1\n");
+            break;
+
+        }
+        #endif /* __LIPP_6300ETH__ */                
+
+        if(ethStatus != TM_OK) 
+        {
+            printk(KERN_ERR"\nAUTONEG FAILED2\n");
+            break; 
+        }
+        
+        timeout++;
+       
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        printk(KERN_ERR"\nAUTONEG FAILED3\n");    
+        return(ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8700LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYSMSC8700_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,TMBSL_PHYSMSC8700_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 physts;
+
+    /* Read the BMSR register twice, as per datasheet */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&physts);
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&physts);    
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+        (((physts & TMBSL_PHYSMSC8700_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8700Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        printk(KERN_ERR"\n&*&*&*PHY READ FAILED\n");    
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8700Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+        printk(KERN_ERR"\n&*&*&*PHY WRITE FAILED\n");
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+
+#if 0
+static tmErrorCode_t
+set_regs (void );
+
+static tmErrorCode_t
+    set_regs (void )
+{
+
+    tmErrorCode_t err = TM_OK;
+    UInt16 regVal=0;
+    tmUnitSelect_t ethUnitId = 0;
+
+    regVal =0x0;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Mcsr,regVal);
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Mcsr,&regVal);
+    printk(KERN_ERR"\nMCSR val: %08x\n",regVal);           
+
+    regVal = 0xF6;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regVal);        
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regVal);
+    printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+    regVal =0;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Csir,regVal);        
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Csir,&regVal);
+    printk(KERN_ERR"\nCSIR val: %08x\n",regVal);           
+
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Pscsr,&regVal);
+    printk(KERN_ERR"\nPSCSR val: %08x\n",regVal);  
+
+    return err;
+}           
+#endif
+
+#if __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+    pnx8xxx_ip3203_init();
+    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+    msleep(1000);
+
+    /* Turn the clocks to MAC from PHY */
+
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(0xbbe47710));	
+    writel(0x00000003, (unsigned long *)(0xbbe47714));	
+    writel(0x00000003, (unsigned long *)(0xbbe47718));	
+
+    msleep(1000);
+
+//    printk(KERN_INFO"\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0xbbe47710));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0xbbe47714));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0xbbe47718));                       
+//    printk(KERN_INFO"\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif 
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/inc/tmbslPhySMSC8710.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/inc/tmbslPhySMSC8710.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/inc/tmbslPhySMSC8710.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/inc/tmbslPhySMSC8710.h	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,504 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8710.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8710 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSL_PHYSMSC8710_H_
+#define _TMBSL_PHYSMSC8710_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYSMSC8710_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYSMSC8710_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYSMSC8710_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYSMSC8710_BMCR_AN_EN (0x1000)
+
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART (0x200)
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART_CLR (0xFDFF)
+
+#define TMBSL_PHYSMSC8710_BMCR_AN_CLR (0xEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYSMSC8710_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYSMSC8710_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYSMSC8710_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYSMSC8710_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYSMSC8710_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYSMSC8710_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYSMSC8710_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYSMSC8710_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYSMSC8710_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYSMSC8710_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYSMSC8710_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYSMSC8710_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYSMSC8710_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYSMSC8710_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYSMSC8710_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYSMSC8710_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYSMSC8710_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYSMSC8710_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYSMSC8710_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYSMSC8710_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYSMSC8710_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYSMSC8710_ANAR_PAUSE (0xc00)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYSMSC8710_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYSMSC8710_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYSMSC8710_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYSMSC8710_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYSMSC8710_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYSMSC8710_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYSMSC8710_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYSMSC8710_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYSMSC8710_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYSMSC8710_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYSMSC8710_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYSMSC8710_STRAP_ANE (0x8000)
+#define TMBSL_PHYSMSC8710_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYSMSC8710_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYSMSC8710_PHYSTS_SPEED_MSK (0xC)
+#define TMBSL_PHYSMSC8710_PHYSTS_LINK_STAT (0x4)
+#define TMBSL_PHYSMSC8710_PHYSTS_DUP_MODE (0x10)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhySMSC8710Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhySMSC8710Context_t, *ptmbslPhySMSC8710Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhySMSC8710Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhySMSC8710Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhySMSC8710GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhySMSC8710SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSL_PHYSMSC8710_H_
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/src/tmbslPhySMSC8710.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/src/tmbslPhySMSC8710.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/src/tmbslPhySMSC8710.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/src/tmbslPhySMSC8710.c	2010-09-07 22:16:40.000000000 -0500
@@ -0,0 +1,1210 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8710.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8710 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhySMSC8710.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include <linux/delay.h>
+#include "remap.h"
+#include <asm/io.h>
+#include <i2c_ip3203.h>
+
+#define AUTO_NEG_DELAY_MS (3000)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYSMSC8710_PHY_MMIO_ADDRESS0 (0xC0000000) 
+
+#define ANAR_DEFAULT_VAL (0x1E1)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+tmbslPhySMSC8710Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYSMSC8710_PHY_MMIO_ADDRESS0}}; 
+
+typedef enum _tmbslPhySMSC8710Reg_t
+{
+    /* Basic mode control */
+    tmbslPhySMSC8710Bmcr		      = 0,  
+
+    /* Basic mode status */    
+    tmbslPhySMSC8710Bmsr		      =1,  
+
+    /* PHY ID1 register */        
+    tmbslPhySMSC8710PhyIdr1		=2,
+
+    /* PHY ID2 register */            
+    tmbslPhySMSC8710PhyIdr2		=3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhySMSC8710Anar			=4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhySMSC8710Anlpar		=5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhySMSC8710Aner			=6,
+
+    /* 0x7 to 0xF reserved-*/
+
+    /* Silicon Revision register */
+    tmbslPhySMSC8710Srr=16,
+
+    /* Mode control & status register */
+    tmbslPhySMSC8710Mcsr=17,
+
+    /* Special modes register */
+    tmbslPhySMSC8710Smr=18,
+
+    /* 19-25 reserved */
+
+    /* Symbol error counter register */    
+    tmbslPhySMSC8710Secr	= 26,
+    
+    /* Control/Status indication register */        
+    tmbslPhySMSC8710Csir = 27,    
+
+    /* Special internal testability controls register*/            
+    tmbslPhySMSC8710Sitcr = 28,        
+    
+    /* Interrupt source register */
+    tmbslPhySMSC8710Isr = 29,
+
+    /* Interrupt mask register */
+    tmbslPhySMSC8710Imr = 30,    
+
+    /* PHY special control & status register */    
+    tmbslPhySMSC8710Pscsr = 31,    
+
+} tmbslPhySMSC8710Reg_t, *ptmbslPhySMSC8710Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhySMSC8710Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhySMSC8710Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t				reg,   
+    UInt16						val
+	);
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8710GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmsr, &bmsr);
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYSMSC8710_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_10MBPSHD) > 0) ? True : False);
+
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYSMSC8710_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration. No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+    #ifdef __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Set the mode register to default value */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//    printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+
+    regval &= 0xBF1F; /* Set to 100Mbps FD, MII mode */
+    regval |= 0x60;    
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//    printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+
+    regval = TMBSL_PHYSMSC8710_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYSMSC8710_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYSMSC8710_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYSMSC8710_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYSMSC8710_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYSMSC8710_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYSMSC8710_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8710GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYSMSC8710_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                            
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8710SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+    UInt16 regval;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8710_BMCR_COLTEST;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8710_BMCR_SPEED_100;                
+            /* Set the mode register to default value */
+            ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+
+            /* Clear the mode bits */
+            regval &= 0xFF1F;
+
+            if(pPhyBasicModeControl->duplexMode == True)
+            {
+                regval |= 0x60; /*100Base T full duplex, autoneg disabled */                            
+            }
+            else
+            {
+                regval |= 0x40; /* 100Base T half duplex, autoneg disabled */
+            }
+
+            ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+
+            ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//            printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8710_BMCR_SPEED_10;                
+            ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+
+            /* Clear the mode bits */
+            regval &= 0xFF1F;
+
+            if(pPhyBasicModeControl->duplexMode == True)
+            {
+                regval |= 0x20; /*10 Base T full duplex, autoneg disabled */                            
+            }
+            else
+            {
+                regval |= 0x00; /* 10 Base T half duplex, autoneg disabled */
+            }
+
+            ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+            ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//            printk(KERN_ERR"\nSMR val: %08x\n",regval);           
+                
+            break;
+
+        default:
+            break;
+
+    }
+
+    ethStatus = tmbslPhySMSC8710SoftReset(ethUnitId);
+
+    msleep(1);
+
+//    printk(KERN_ERR"\nSPEED/MODE updated from MODE pins\n");               
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Pscsr,&regval);
+//    printk(KERN_ERR"\nPHY STS reg:%04x\n",regval);               
+
+    if(ethStatus != TM_OK)
+    {
+        printk(KERN_ERR"\nRESET failed after mode change\n");           
+    }
+
+    /* Write the result to the BMC register */
+//    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Pscsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYSMSC8710_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYSMSC8710_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYSMSC8710_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYSMSC8710_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYSMSC8710_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYSMSC8710_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+        }
+
+    }
+    else 
+    {
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((phySts & TMBSL_PHYSMSC8710_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed= 
+                (((phySts & TMBSL_PHYSMSC8710_PHYSTS_SPEED_MSK) == 0x4) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=0; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    #ifdef __LIPP_6300ETH__
+    Bool timerExpired =False;
+    #endif /* __LIPP_6300ETH__ */            
+
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+//    printk(KERN_ERR"\nANAR val: %08x\n",regVal);
+   
+    /* Program the Auto negotiation mask */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYSMSC8710_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYSMSC8710_BMCR_AN_EN |
+              TMBSL_PHYSMSC8710_BMCR_AN_RESTART;
+    
+//    printk(KERN_ERR"\nBMCR val: %08x\n",regVal);
+   
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Wait till the Auto negotiation is complete */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&regVal);
+    
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYSMSC8710_BMSR_AN_VAL) != TMBSL_PHYSMSC8710_BMSR_AN_VAL) && 
+           (timeout < PHY_TIMEOUT) )
+    {
+        #ifdef __LIPP_6300ETH__                
+        /* Sleep for 3 sec & check the link status */        
+        msleep(AUTO_NEG_DELAY_MS);
+        timerExpired = True;
+        #endif    
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&regVal);
+
+        #ifdef __LIPP_6300ETH__                
+        if((True == timerExpired) && 
+        ((regVal & TMBSL_PHYSMSC8710_BMSR_AN_VAL) != TMBSL_PHYSMSC8710_BMSR_AN_VAL))
+        {
+                                                
+            ethStatus = !TM_OK;
+            printk(KERN_ERR"\nBMSR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Anlpar,&regVal);
+            printk(KERN_ERR"\nANLPAR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Aner,&regVal);
+            printk(KERN_ERR"\nANER val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Mcsr,&regVal);
+            printk(KERN_ERR"\nMCSR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regVal);
+            printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Secr,&regVal);
+            printk(KERN_ERR"\nSymbol error val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Csir,&regVal);
+            printk(KERN_ERR"\nCSIR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regVal);
+            printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Imr,&regVal);
+            printk(KERN_ERR"\nIMR val: %08x\n",regVal);           
+
+            tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Pscsr,&regVal);
+            printk(KERN_ERR"\nPSCSR val: %08x\n",regVal);           
+
+            printk(KERN_ERR"\nAUTONEG FAILED1\n");
+            break;
+
+        }
+        #endif /* __LIPP_6300ETH__ */                
+
+        if(ethStatus != TM_OK) 
+        {
+            printk(KERN_ERR"\nAUTONEG FAILED2\n");
+            break; 
+        }
+        
+        timeout++;
+       
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        printk(KERN_ERR"\nAUTONEG FAILED3\n");    
+        return(ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8710LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYSMSC8710_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYSMSC8710_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,TMBSL_PHYSMSC8710_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 physts;
+
+    /* Read the BMSR register twice, as per datasheet */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&physts);
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&physts);    
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+        (((physts & TMBSL_PHYSMSC8710_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8710Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        printk(KERN_ERR"\n&*&*&*PHY READ FAILED\n");    
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8710Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+        printk(KERN_ERR"\n&*&*&*PHY WRITE FAILED\n");
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+
+#if 0
+static tmErrorCode_t
+set_regs (void );
+
+static tmErrorCode_t
+    set_regs (void )
+{
+
+    tmErrorCode_t err = TM_OK;
+    UInt16 regVal=0;
+    tmUnitSelect_t ethUnitId = 0;
+
+    regVal =0x0;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Mcsr,regVal);
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Mcsr,&regVal);
+    printk(KERN_ERR"\nMCSR val: %08x\n",regVal);           
+
+    regVal = 0xF6;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regVal);        
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regVal);
+    printk(KERN_ERR"\nSMR val: %08x\n",regVal);           
+
+    regVal =0;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Csir,regVal);        
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Csir,&regVal);
+    printk(KERN_ERR"\nCSIR val: %08x\n",regVal);           
+
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Pscsr,&regVal);
+    printk(KERN_ERR"\nPSCSR val: %08x\n",regVal);  
+
+    return err;
+}           
+#endif
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+//    pnx8xxx_ip3203_init();
+//    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+//    msleep(1);
+
+    /* Turn the clocks to MAC from PHY */
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47710));	
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47714));	
+    writel(0x00000003, (unsigned long *)(PNX8XXX_MMIO_BASE_VIRT+0x47718));	
+
+    msleep(1);
+
+//    printk(KERN_INFO"\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0xbbe47710));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0xbbe47714));                    
+//    printk(KERN_INFO"\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0xbbe47718));                       
+//    printk(KERN_INFO"\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,65 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Cfg.c %
+ * %pid_version:          1.1                         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  This file holds the code for configuration of ethernet GMAC HwApi
+ *
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+/*----------------------------------------------------------------------------*/
+/* Standard include files:                                                    */
+/*----------------------------------------------------------------------------*/
+
+#include <tmNxTypes.h>
+
+/*----------------------------------------------------------------------------*/
+/* Project include files:                                                     */
+/*----------------------------------------------------------------------------*/
+
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/*----------------------------------------------------------------------------*/
+/* Types and defines:                                                         */
+/*----------------------------------------------------------------------------*/
+
+
+/* Base addresses of GMAC0*/
+
+#ifndef TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0
+#define TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0     (0x0U)
+#endif
+
+
+/*----------------------------------------------------------------------------*/
+/* Global data:                                                               */
+/*----------------------------------------------------------------------------*/
+/* This gets assigned in remapBaseAdrs fn */
+tmhwLIPP6100Eth_Cfg_t gtmhwLIPP6100Eth_Base[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0}, {TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0}
+};
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,118 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Cfg.h%
+ * %pid_version:          1.5                         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Configuration header file for Ethernet HwApi Driver
+ *
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMHWLIPP6100ETH_CFG_H
+#define TMHWLIPP6100ETH_CFG_H
+
+/*----------------------------------------------------------------------------*/
+/* Standard include files: */
+/*----------------------------------------------------------------------------*/
+
+
+#include <tmNxTypes.h>
+
+/*----------------------------------------------------------------------------*/
+/* Project include files: */
+/*----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*! 
+ * \def TMFL_SD_ALL
+ * Select all the APIs for final image. If this flag is disabled then scalability settings as 
+ * defined below are used by preprocessor.
+ * \n NOTE: The flags need to be modified by the user as per system requirements. Also, care 
+ * should be taken in case multiple units of this IP are available in Hw sybsystem. 
+ * In case of multiple units with different features User will need to enable superset of
+ * features of individual unit. In such case it is Applications responsibility to keep track of which 
+ * features are supported by which IP.
+ */
+
+/*  Scalability Settings Start  */
+#define TMFL_SD_ALL 0
+#if (TMFL_SD_ALL == 0)
+#define TMFL_LIPP6100ETHSD_MMC 1
+#define TMFL_LIPP6100ETHSD_POWER 1 
+#define TMFL_LIPP6100ETHSD_HASH 1
+#define TMFL_LIPP6100ETHSD_VLAN 1
+#define TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP 0
+#define TMFL_LIPP6100ETHSD_OTHERS 0
+#endif
+/* Scalability Settings End */
+
+/* Defining this macro to 1, incorporates work around for IPC counters bug in 3.41a */
+#define IPVERSION_34_1_A  0
+
+#define TMHWLIPP6100ETH_NUM_UNITS (2)
+/*! 
+ * \def TMHWLIPP6100ETH_NUM_UNITS
+ *  Indicates number of ethernet units supported.
+ *  The definition of gtmhwLIPP6100Eth_Base[] is to be modified.
+ *  with new base addresses, if there are multiple units.
+ */
+
+/* Defined as part of ethernet driver makefile */	
+//#define  TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL (0x16U)
+/*! \def TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL
+*   Default PHY address value used
+*/
+/* Defined as part of ethernet driver makefile */	
+//#define TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL (0x1U)
+/*! \def TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL
+*     CSR clock value, which decides the frequency of MDC clock
+*/
+
+typedef struct tmhwLIPP6100Eth_Cfg
+/*! \brief This structure stores the base Address of Ethernet unit*/
+{
+    UInt32 baseAddress; /*!< baseAddress of GMAC unit */
+
+} tmhwLIPP6100Eth_Cfg_t, *ptmhwLIPP6100Eth_Cfg_t;
+
+extern tmhwLIPP6100Eth_Cfg_t gtmhwLIPP6100Eth_Base[TMHWLIPP6100ETH_NUM_UNITS]; /* ETH context */
+
+/*!
+ * \def GET_BASE(x)
+ * Computes the base address of GMAC unit.
+ */
+#define GET_BASE(x)     (gtmhwLIPP6100Eth_Base[x].baseAddress)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/inc/tmhwLIPP6100Eth.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/inc/tmhwLIPP6100Eth.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/inc/tmhwLIPP6100Eth.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/inc/tmhwLIPP6100Eth.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,3111 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth.h %
+ * %pid_version:          1.5                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Configuration header file for Ethernet HwApi Driver
+ *
+ * DOCUMENT REF: Synopsys DesignWare Cores Ethernet MAC Universal Databook 
+ *                         Version 3.30a, March 22nd 2007 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef  TMHWLIPP6100ETH_H
+#define  TMHWLIPP6100ETH_H
+
+/*-----------------------------------------------------------------------------
+* Standard include files:
+*-----------------------------------------------------------------------------
+*/
+
+#include <tmNxTypes.h>      /*! This is a standard type definition file for NxHome.*/
+#include <tmNxCompId.h>    /*! This file registers all the component IDs as defined in NxHome.*/
+#include <tmNxModId.h>
+#include <tmhwLIPP6100Eth_Cfg.h> /*! Configuration header file */
+
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif  /* defined(__cplusplus) */
+
+/*-----------------------------------------------------------------------------
+** Error Codes :
+**-----------------------------------------------------------------------------
+*/
+
+#define TMHW_LIPP6100ETH_COMPATIBILITY_NR (1)
+/*! \def TMHW_LIPP6100ETH_COMPATIBILITY_NR
+*     Compatability number         
+*/
+
+#define TMHW_LIPP6100ETH_MAJOR_VERSION_NR (1)
+/*! \def TMHW_LIPP6100ETH_MAJOR_VERSION_NR
+*     Major version Number         
+*/
+
+#define TMHW_LIPP6100ETH_MINOR_VERSION_NR (0)
+/*! \def TMHW_LIPP6100ETH_MINOR_VERSION_NR
+*     Minor Version Number         
+*/
+
+#define TMHW_ERR_LIPP6100ETH_BASE         (CID_LIPP6100ETH | CID_LAYER_HWAPI)
+#define TMHW_ERR_LIPP6100ETH_COMP        (CID_LIPP6100ETH | CID_LAYER_HWAPI | \
+                                                                                TM_ERR_COMP_UNIQUE_START)
+
+/*! \def TMHW_ERR_LIPP6100ETH_COMP
+*    This error code is the initial offset from which other error codes are based.
+*/
+
+#define TMHW_ERR_LIPP6100ETH_NOT_SUPPORTED  (TMHW_ERR_LIPP6100ETH_BASE+TM_ERR_NOT_SUPPORTED)
+
+/*! \def TMHW_ERR_LIPP6100ETH_NOT_SUPPORTED
+*    This error code is returned if the feature is not supported by Ethernet hardware.
+*/
+
+/* Interrupt identification flags */
+
+/*! \brief Typedef for interrupt mask value */
+typedef  UInt32  tmhwLIPP6100Eth_IntMask_t,*ptmhwLIPP6100Eth_IntMask_t;
+
+/*! \brief Typedef for interrupt status value */
+typedef  UInt32  tmhwLIPP6100Eth_IntStatus_t,  *ptmhwLIPP6100Eth_IntStatus_t;
+
+/*! \brief Typedef for status value */
+typedef  UInt32  tmhwLIPP6100Eth_StatusMask_t,*ptmhwLIPP6100Eth_StatusMask_t;
+
+
+/*-----------------------------------------------------------------------------
+** Interrupt Macros :
+**-----------------------------------------------------------------------------
+*/
+
+/**
+ * \defgroup group0 Basic Operations
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL
+*   Macro to enable Normal Interrupt Summary Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL
+*      Macro to enable Abnormal Interrupt Summary Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL
+*    Macro to enable Early Receive Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL
+*    Macro to enable Fatal Bus Error interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL
+* Macro to enable Early Transmit interrupt  
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_INT_RWE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RWE_EN_VAL
+*Macro to enable Watchdog Timeout interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RSE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RSE_EN_VAL
+*Macro to enable Receive Stopped interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL
+* Macro to enable Receive Buffer Unavailable interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL
+* Macro to enable Receive Interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL
+* Macro to enable Underflow interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL
+*Macro to enable Overflow interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TJE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TJE_EN_VAL
+* Macro to enable Transmit Jabber Timeout interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TUE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TUE_EN_VAL
+* Macro to enable Transmit Buffer Unavailable interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TSE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TSE_EN_VAL
+* Macro to enable Transmit Stopped interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL
+* Macro to enable Transmit Interrupt  
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PCS_AN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_AN_VAL
+* Macro to enable/disable interrupt generation due to auto negotiation completion event
+*/
+
+#define TMHW_LIPP6100ETH_INTR_LNKSTAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_INTR_LNKSTAT_VAL
+* Macro to enable/disable interrupt generation due to change in link status event
+*/
+
+#define TMHW_LIPP6100ETH_INTR_RGMII_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_INTR_RGMII_VAL
+* Macro to enable/disable interrupt generation due to the setting of RGMII status bit
+*/
+
+/* DMA status register macros. Some are Read Only & Some are Read Clear */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL
+* Macro to check if the cause of the interrupt is due to the Power Management Unit
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL
+* Macro to check if the cause of the interrupt is due to MMC unit 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GLI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GLI_VAL
+* Macro to check if the cause of the interrupt is due to PCS interface block  
+*/
+
+/* The below bits are valid only when the fatal bus error interrupt is set */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EB_MSK ((tmhwLIPP6100Eth_StatusMask_t)0x3800000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EB_MSK
+* Mask to extract the Error bits 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBTX_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBTX_VAL
+* Macro to check if the Error is due to data transfer by TxDMA 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBRD_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBRD_VAL
+* Macro to check if there is an Error during read transfer 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBDESC_VAL
+* Macro to check if there is an Error during descriptor access 
+*/
+
+/* DMA Transmit process status */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_MSK ((tmhwLIPP6100Eth_StatusMask_t)0x700000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_MSK
+* DMA Transmit process state mask  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_TXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_TXDESC_VAL
+* DMA state is running and it is Fetching Transmit Transfer Descriptor   
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_TXSTAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_TXSTAT_VAL
+* DMA state is running and it is  Waiting for status   
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_RDDAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x300000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_RDDAT_VAL
+* DMA state is running: It is  Reading data from host memory buffer and queuing 
+* it to transmit buffer (TX FIFO)  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_SUSP_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x600000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_SUSP_VAL
+* DMA state is Suspended: Transmit Descriptor Unavailable or Transmit Buffer Underflow 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_CTXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x700000)  
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_CTXDESC_VAL
+* DMA is running: Closing Transmit Descriptor
+*/
+
+/* Receive process status 
+**
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_MSK ((tmhwLIPP6100Eth_StatusMask_t)0xE0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_MSK
+* Receive process state mask
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_RXDESC_VAL
+* DMA state is Running: Fetching Receive Transfer Descriptor 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_WTRX_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x60000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_WTRX_VAL
+* DMA state is Running: Waiting for receive packet
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_NO_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_NO_RXDESC_VAL
+ * DMA state is Suspended: No Rx Descriptor available 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_CLOSE_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0xA0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_CLOSE_RXDESC_VAL
+* DMA state is Running: Closing receive descriptor 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_TXFRDATA_VAL ((tmhwLIPP6100Eth_StatusMask_t)0xE0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_TXFRDATA_VAL
+* DMA state is Running: Transferring the receive packet data from receive 
+* buffer to host memory
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL
+*  Normal Interrupt Summary status. To clear this bit, write a 1 to this bit position
+*  after clearing the cause of NIS interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL
+*  Abnormal Interrupt Summary 
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_ERI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_ERI_VAL
+*  Early Receive Interrupt macro which  indicates that the DMA had 
+*  filled the first data buffer of the packet.
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL
+* Macro to indicate that a Bus Error occurred.  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_ETI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_ETI_VAL
+* Early Transmit Interrupt : This macro indicates that the frame 
+* to be transmitted was fully transferred to the MTL Transmit FIFO 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RWT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RWT_VAL
+* Receive Watchdog Timeout indicates a frame with a length greater than 
+* 2048 bytes was received 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RPS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RPS_VAL
+* Receive Process Stopped: Receive process has entered the stopped state
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL
+*    Receive Buffer Unavailable indicates the next descriptor is owned by host. 
+*    DMA enters suspended state 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL
+*     Receive Interrupt indicates completion of frame reception 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL
+*     Transmit Underflow: Transmit buffer had an underflow during transmission 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL
+*     Receive Overflow: There was an overflow during frame reception 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TJT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TJT_VAL
+*     Transmit Jabber Timeout: The transmitter has been excessively active 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TU_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TU_VAL
+*     Transmit Buffer Unavailable: The next descriptor in the transmit list is 
+*     owned by host and cannot be acquired by DMA 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TPS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TPS_VAL
+*     Macro indicates Transmit Process is in Stopped state
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL
+*     Transmit Interrupt: Status to indicate frame transmission is complete
+*/
+
+
+#define TMHW_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL
+* Macro for checking the FCB/BPA bit status
+*/
+
+/* Additional macros to check the status */
+#define TMHW_LIPP6100ETH_INTR_PCS_AN_STAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_AN_STAT_VAL
+* Macro for checking the staus of auto negotiation completion in TBI/RTBI/SGMII PHY interface
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PCS_LS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_LS_VAL
+* Macro for checking the change in the link staus in the TBI/RTBI/SGMII PHY interface
+*/
+
+#define TMHW_LIPP6100ETH_INTR_RGMII_STAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_INTR_RGMII_STAT_VAL
+* Macro for checking the change in the link status for RGMII PHY interface
+*/
+
+/*\}*/ /* Group0 definition end */
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+
+/*
+*  MAC management Interrupt status values. All the bits are clear on read 
+*  Receive interrupt register macros 
+*/
+
+/**
+ * \defgroup group3 MAC Management Counters
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_INTR_MMC_STAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000)
+/*! \def TMHW_LIPP6100ETH_INTR_MMC_STAT_VAL
+* Macro to check if the interrupt is due to MMC unit
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_WD_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_WD_VAL
+* Macro to check if the interrupt is due to watchdog error counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_VLANGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_VLANGB_VAL
+* Macro to check if  the interrupt is due to rxvlanframes_gb counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OVERFLOW_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OVERFLOW_VAL
+* Macro to check if  the interrupt is due to rxfifooverflow counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_PAUSE_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_PAUSE_VAL
+* Macro to check if  the interrupt is due to rxpauseframes counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OUTOFR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OUTOFR_VAL
+* Macro to check if  the interrupt is due to rxoutofrange counter reaching 
+* half the maximum value 
+*/
+
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_LEN_ERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_LEN_ERR_VAL
+* Macro to check if  the interrupt is due to rxlengtherror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_UNICASTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_UNICASTGB_VAL
+* Macro to check if  the interrupt is due to rxunicastframes_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_1024TOMAXGB_VAL
+* Macro to check if  the interrupt is due to rx1024tomaxoctects_gb counter reaching 
+* half the maximum value  
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_512TO1023GB_VAL
+* Macro to check if  the interrupt is due to rx512to1023octects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_256TO511GB_VAL
+* Macro to check if  the interrupt is due to rx256to511octects_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_128TO255GB_VAL
+* Macro to check if  the interrupt is due to rx128to255octects_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_65TO127GB_VAL
+* Macro to check if  the interrupt is due to rx65to127octects_gb counter 
+* reaching half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_64GB_VAL
+* Macro to check if  the interrupt is due to rx64octects_gb counter 
+* reaching half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OVERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OVERSIZEG_VAL
+* Macro to check if  the interrupt is due to rxoversize_g counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_UNDERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_UNDERSIZEG_VAL
+* Macro to check if  the interrupt is due to rxundersize_g counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_JABBER_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_JABBER_VAL
+* Macro to check if  the interrupt is due to rxjabbererror counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_RUNTERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_RUNTERR_VAL
+* Macro to check if  the interrupt is due to rxrunterror counter reaching half the 
+* maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_ALIGN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_ALIGN_VAL
+* Macro to check if  the interrupt is due to rxalignmenterror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_CRC_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_CRC_VAL
+* Macro to check if  the interrupt is due to rxcrcerror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_MULTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_MULTG_VAL
+* Macro to check if  the interrupt is due to rxmulticastframes_g counter 
+* reaching half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_BDCSTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_BDCSTG_VAL
+* Macro to check if  the interrupt is due to rxbroadcastframes_g  counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTG_VAL
+* Macro to check if  the interrupt is due to rxoctetcount_g counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTGB_VAL
+* Macro to check if  the interrupt is due to rxoctetcount_gb counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_FRMCNTGB_VAL
+* Macro to check if  the interrupt is due to rxframecount_gb counter reaching 
+* half the maximum value
+*/
+
+/* Checksum offload interrupt status register macros. Register is clear on read */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxicmp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000000) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxicmp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxtcp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000000 ) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxtcp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxudp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxudp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAYOCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_nopay_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERROCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_hdrerr_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDISOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDISOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_udsbl_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAGOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAGOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_frag_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAYOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_nopay_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERROCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_hdrerr_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxicmp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxicmp_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxtcp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxtcp_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxudp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxudp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAY_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_nopay_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_hdrerr_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDIS_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDIS_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_udsbl_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAG_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAG_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_frag_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAY_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_nopay_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_hdrerr_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_gd_frms counter reaching 
+* half the maximum value
+*/
+
+
+/* MMC Transmit interrupt register status macros */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_VLANG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_VLANG_VAL
+* Macro to check if  the interrupt is due to txvlanframes_g counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_PAUSEERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_PAUSEERR_VAL
+* Macro to check if  the interrupt is due to txpauseframes error counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_EXSDEF_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_EXSDEF_VAL
+* Macro to check if  the interrupt is due to txoexcessdef  counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTG_VAL
+* Macro to check if  the interrupt is due to txframecount_g  counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTG_VAL
+* Macro to check if  the interrupt is due to txoctectcount_g   counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_CARERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_CARERR_VAL
+* Macro to check if  the interrupt is due to txcarriererror counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_EXSCOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_EXSCOL_VAL
+* Macro to check if  the interrupt is due to txexcesscol counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_LATECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_LATECOL_VAL
+* Macro to check if  the interrupt is due to txlatecol counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_DEFCNT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_DEFCNT_VAL
+* Macro to check if  the interrupt is due to txdeferred counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTICOLG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTICOLG_VAL
+* Macro to check if  the interrupt is due to txmulticol_g counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_SINGLECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_SINGLECOL_VAL
+* Macro to check if  the interrupt is due to txsinglecol_g counter reaching half 
+* the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_UNFLWERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_UNFLWERR_VAL
+* Macro to check if  the interrupt is due to txunderflowerror counter 
+* reaching half the maximum value  
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_BRDCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_BRDCSTFMGB_VAL
+* Macro to check if  the interrupt is due to txbroadcastframes_gb counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFMGB_VAL
+* Macro to check if  the interrupt is due to txmulticastframes_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_UNICSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_UNICSTFMGB_VAL
+* Macro to check if  the interrupt is due to txunicastframes_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_1024TOMAXGB_VAL
+* Macro to check if  the interrupt is due to tx1024tomaxoctects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_512TO1023GB_VAL
+* Macro to check if  the interrupt is due to tx512to1023octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_256TO511GB_VAL
+* Macro to check if  the interrupt is due to tx256to511octects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_128TO255GB_VAL
+* Macro to check if  the interrupt is due to tx128to255octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_65TO127GB_VAL
+* Macro to check if  the interrupt is due to tx65to127octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_64GB_VAL
+* Macro to check if  the interrupt is due to tx64to127octects_gb counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFRMG_VAL
+* Macro to check if  the interrupt is due to txmulticastframes_g counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_BDCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_BDCSTFRMG_VAL
+* Macro to check if  the interrupt is due to txbroadcastframes_g counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTGB_VAL
+* Macro to check if  the interrupt is due to txframecount_gb counter reaching
+* half the maximum value   
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTGB_VAL
+* Macro to check if  the interrupt is due to txoctectcount_gb counter reaching 
+* half the maximum value 
+*/
+
+
+/* MMC bit masks to disable interrupts in Rx Directon */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_WD_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_WD_VAL
+* Macro to mask the  generation of rxwatchdog interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_VLANGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_VLANGB_VAL
+* Macro to mask the  generation of rxvlanframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERFLOW_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERFLOW_VAL
+* Macro to mask the  generation of rxfifooverflow interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_PAUSE_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_PAUSE_VAL
+* Macro to mask the  generation of rxpauseframes interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OUTOFR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OUTOFR_VAL
+* Macro to mask the  generation of  rxoutofrange interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_LEN_ERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_LEN_ERR_VAL
+* Macro to mask the  generation of rxlengtherror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNICASTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNICASTGB_VAL
+* Macro to mask the  generation of rxunicastframes_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_1024TOMAXGB_VAL
+* Macro to mask the  generation of rx1024tomaxoctects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_512TO1023GB_VAL
+* Macro to mask the  generation of rx512to1023octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_256TO511GB_VAL
+* Macro to mask the  generation of rx256to511octects_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_128TO255GB_VAL
+* Macro to mask the  generation of rx128to255octects_gb interrupt 
+*/
+
+/* Macro to mask the  generation of rx65to127octects_gb interrupt */
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_65TO127GB_VAL
+* Macro to check if  the interrupt is due to rxcrcerror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_64GB_VAL
+* Macro to mask the  generation of rx64octects_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERSIZEG_VAL
+* Macro to mask the  generation of rxoversize_g interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNDERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNDERSIZEG_VAL
+* Macro to mask the  generation of rxundersize_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_JABBER_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_JABBER_VAL
+* Macro to mask the  generation of rxjabbererror  interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_RUNTERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_RUNTERR_VAL
+* Macro to mask the  generation of rxrunterror interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_ALIGN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_ALIGN_VAL
+* Macro to mask the  generation of rxalignmenterror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_CRC_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_CRC_VAL
+* Macro to mask the  generation of  rxcrcerror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_MULTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_MULTG_VAL
+* Macro to mask the  generation of rxmulticastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_BDCSTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_BDCSTG_VAL
+* Macro to mask the  generation of rxbroadcastframes_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTG_VAL
+* Macro to mask the  generation of rxoctetcount_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTGB_VAL
+* Macro to mask the  generation of rxoctetcount_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_FRMCNTGB_VAL
+* Macro to mask the  generation of rxframecount_gb interrupt 
+*/
+
+/* MMC Transmit interrupt mask register bits */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_VLANG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_VLANG_VAL
+* Macro to mask the  generation of  txvlanframes_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_PAUSEERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_PAUSEERR_VAL
+* Macro to mask the  generation of  txpauseframes interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSDEF_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSDEF_VAL
+* Macro to mask the  generation of  txoexcessdef interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTG_VAL
+* Macro to mask the  generation of  txframecount_g   interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTG_VAL
+* Macro to mask the  generation of  txoctectcount_g  interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_CARERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_CARERR_VAL
+* Macro to mask the  generation of  txcarriererror interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSCOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSCOL_VAL
+* Macro to mask the  generation of  txexcesscol interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_LATECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_LATECOL_VAL
+* Macro to mask the  generation of  txlatecol interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_DEFCNT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_DEFCNT_VAL
+* Macro to mask the  generation of  txdeferred interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTICOLG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTICOLG_VAL
+* Macro to mask the  generation of  txmulticol_g interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_SINGLECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_SINGLECOL_VAL
+* Macro to mask the  generation of txsinglecol_g   interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNFLWERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNFLWERR_VAL
+* Macro to mask the  generation of  txunderflowerror interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BRDCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BRDCSTFMGB_VAL
+* Macro to mask the  generation of  txbroadcastframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFMGB_VAL
+* Macro to mask the  generation of  txmulticastframes_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNICSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNICSTFMGB_VAL
+* Macro to mask the  generation of  txunicastframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_1024TOMAXGB_VAL
+* Macro to mask the  generation of  tx1024tomaxoctects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_512TO1023GB_VAL
+* Macro to mask the  generation of  tx512to1023octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_256TO511GB_VAL
+* Macro to mask the  generation of  tx256to511octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_128TO255GB_VAL
+* Macro to mask the  generation of  tx128to255octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_65TO127GB_VAL
+* Macro to mask the  generation of  tx65to127octects_gb interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_64GB_VAL
+* Macro to mask the  generation of  tx64to127octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFRMG_VAL
+* Macro to mask the  generation of  txmulticastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BDCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BDCSTFRMG_VAL
+* Macro to mask the  generation of  txbroadcastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTGB_VAL
+*Macro to mask the  generation of  txframecount_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTGB_VAL
+* Macro to mask the  generation of  txoctectcount_gb interrupt
+*/
+
+/* Mask to disable generation of interrupts due to ipv4, ipv6, tcp/udp/icmp counters reaching half 
+** the maximum value
+*/    
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERROCT_VAL
+* Macro to mask the  generation of  rxicmp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000000) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GDOCT_VAL
+* Macro to mask the  generation of  rxicmp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERROCT_VAL
+* Macro to mask the  generation of  rxtcp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000000 ) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GDOCT_VAL
+* Macro to mask the  generation of  rxtcp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERROCT_VAL
+* Macro to mask the  generation of  rxudp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GDOCT_VAL
+* Macro to mask the  generation of  rxudp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAYOCT_VAL
+* Macro to mask the  generation of  rxipv6_nopay_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERROCT_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GDOCT_VAL
+* Macro to mask the  generation of  rxipv6_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDISOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDISOCT_VAL
+* Macro to mask the  generation of  rxipv4_udsbl_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAGOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAGOCT_VAL
+* Macro to mask the  generation of  rxipv4_frag_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAYOCT_VAL
+* Macro to mask the  generation of  rxipv4_nopay_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERROCT_VAL
+* Macro to mask the  generation of  rxipv4_hdrerr_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GDOCT_VAL
+* Macro to mask the  generation of  rxipv4_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxicmp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxicmp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxtcp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxtcp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxudp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxudp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAY_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_nopay_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERR_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_frms counter interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GD_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_frms counter interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDIS_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDIS_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_udsbl_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAG_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAG_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_frag_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAY_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_nopay_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERR_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_hdrerr_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GD_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_gd_frms interrupt
+*/
+
+/* Macros to read various MAC management counters */
+
+#define TMHW_LIPP6100ETH_TX_OCTET_CNT_GB (0x0U)
+/*! \def TMHW_LIPP6100ETH_TX_OCTET_CNT_GB
+* Macro used to read the txoctetcount_gb counter
+*/
+
+
+#define TMHW_LIPP6100ETH_TX_FRAME_CNT_GB (0x1U)
+/*! \def TMHW_LIPP6100ETH_TX_FRAME_CNT_GB
+* Macro used to read the txframecount_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_BRDCST_CNT_G (0x2U)
+/*! \def TMHW_LIPP6100ETH_TX_BRDCST_CNT_G
+* Macro used to read the txbroadcastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTCST_CNT_G (0x3U)
+/*! \def TMHW_LIPP6100ETH_TX_MULTCST_CNT_G
+* Macro used to read the txmulticastframes_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_64_CNT_GB (0x4U)
+/*! \def TMHW_LIPP6100ETH_TX_64_CNT_GB
+* Macro used to read the tx64octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_65TO127_CNT_GB (0x5U)
+/*! \def TMHW_LIPP6100ETH_TX_65TO127_CNT_GB
+* Macro used to read the tx65to127octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_128TO255_CNT_GB (0x6U)
+/*! \def TMHW_LIPP6100ETH_TX_128TO255_CNT_GB
+* Macro used to read the tx128to255octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_256TO511_CNT_GB (0x7U)
+/*! \def TMHW_LIPP6100ETH_TX_256TO511_CNT_GB
+* Macro used to read the tx256to511octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB (0x8U)
+/*! \def TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB
+* Macro used to read the tx512to1023octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB (0x9U)
+/*! \def TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB
+* Macro used to read the tx1024tomaxoctets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB (0xAU)
+/*! \def TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB
+* Macro used to read the txunicastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB (0xBU)
+/*! \def TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB
+*  Macro used to read the txmulticastcastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB (0xCU)
+/*! \def TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB
+* Macro used by MMC API to read the txbroadcastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT (0xDU)
+/*! \def TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT
+* Macro used by MMC API to read the txunderflowerror counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G (0xEU)
+/*! \def TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G
+* Macro used by MMC API to read the txsinglecol_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTICOL_COL_G (0xFU)
+/*! \def TMHW_LIPP6100ETH_TX_MULTICOL_COL_G
+* Macro used by MMC API to read the txmulticol_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_DEFERRED_CNT (0x10U)
+/*! \def TMHW_LIPP6100ETH_TX_DEFERRED_CNT
+* Macro used by MMC API to read the txdeferred counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_LATECOL_CNT (0x11U)
+/*! \def TMHW_LIPP6100ETH_TX_LATECOL_CNT
+* Macro used by MMC API to read txlatecol counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT (0x12U)
+/*! \def TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT
+* Macro used by MMC API to read txexcesscol counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT (0x13U)
+/*! \def TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT
+* Macro used by MMC API to read txcarriererror counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_OCTET_CNT_G (0x14U)
+/*! \def TMHW_LIPP6100ETH_TX_OCTET_CNT_G
+* Macro used by MMC API to read txoctetcount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_FRAME_CNT_G (0x15U)
+/*! \def TMHW_LIPP6100ETH_TX_FRAME_CNT_G
+* Macro used by MMC API to read txframecount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT (0x16U)
+/*! \def TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT
+* Macro used by MMC API to read txexcessdef counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT (0x17U)
+/*! \def TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT
+* Macro used by MMC API to read txpauseframes counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G (0x18U)
+/*! \def TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G
+* Macro used by MMC API to read txvlanframes_g counter 
+*/
+
+/* Receive frame statistics*/
+
+ #define TMHW_LIPP6100ETH_RX_FRM_CNT_GB (0x32U)
+/*! \def TMHW_LIPP6100ETH_RX_FRM_CNT_GB
+* Macro used by MMC API to read rxframecount_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_OCTET_CNT_GB (0x33U)
+/*! \def TMHW_LIPP6100ETH_RX_OCTET_CNT_GB
+* Macro used by MMC API to read rxoctetcount_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_OCTET_CNT_G (0x34U)
+/*! \def TMHW_LIPP6100ETH_RX_OCTET_CNT_G
+* Macro used by MMC API to read rxoctetcount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G (0x35U)
+/*! \def TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G
+* Macro used by MMC API to read rxbroadcastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G (0x36U)
+/*! \def TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G
+* Macro used by MMC API to read rxmulticastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_CRC_ERR_CNT (0x37U)
+/*! \def TMHW_LIPP6100ETH_RX_CRC_ERR_CNT
+* Macro used by MMC API to read rxcrcerror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT (0x38U)
+/*! \def TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT
+* Macro used by MMC API to read rxalignmenterror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT (0x39U)
+/*! \def TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT
+* Macro used by MMC API to read rxrunterror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT (0x3AU)
+/*! \def TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT
+* Macro used by MMC API to read rxjabbererror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G (0x3BU)
+/*! \def TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G
+* Macro used by MMC API to read rxundersize_g counter
+*/
+
+
+#define TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G (0x3CU)
+/*! \def TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G
+* Macro used by MMC API to read rxoversize_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_64_CNT_GB (0x3DU)
+/*! \def TMHW_LIPP6100ETH_RX_64_CNT_GB
+* Macro used by MMC API to read rx64octets_gb counter
+*/
+
+
+
+#define TMHW_LIPP6100ETH_RX_65TO127_CNT_GB (0x3EU)
+/*! \def TMHW_LIPP6100ETH_RX_65TO127_CNT_GB
+* Macro used by MMC API to read rx65to127octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_128TO255_CNT_GB (0x3FU)
+/*! \def TMHW_LIPP6100ETH_RX_128TO255_CNT_GB
+* Macro used by MMC API to read rx128to255octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_256TO511_CNT_GB (0x40U)
+/*! \def TMHW_LIPP6100ETH_RX_256TO511_CNT_GB
+* Macro used by MMC API to read rx256to511octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB (0x41U)
+/*! \def TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB
+* Macro used by MMC API to read rx512to1023octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB (0x42U)
+/*! \def TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB
+* Macro used by MMC API to read rx1024tomaxoctets_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_UNICAST_CNT_G (0x43U)
+/*! \def TMHW_LIPP6100ETH_RX_UNICAST_CNT_G
+* Macro used by MMC API to read rxunicastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_LEN_ERR_CNT (0x44U)
+/*! \def TMHW_LIPP6100ETH_RX_LEN_ERR_CNT
+* Macro used by MMC API to read rxlengtherror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT (0x45U)
+/*! \def TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT
+* Macro used by MMC API to read rxoutofrangetype counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_PAUSE_CNT (0x46U)
+/*! \def TMHW_LIPP6100ETH_RX_PAUSE_CNT
+* Macro used by MMC API to read rxpauseframes counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT (0x47U)
+/*! \def TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT
+* Macro used by MMC API to read rxfifooverflow counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB (0x48U)
+/*! \def TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB
+* Macro used by MMC API to read rxvlanframes_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT (0x49U)
+/*! \def TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT
+* Macro used by MMC API to read rxwatchdogerror counter 
+*/
+
+/* Macros to read checksum offload counters on the receive side */
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G (0x5AU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G
+* Macro used by MMC API to read number of ipv4 good frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT (0x5BU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number ipv4 packets with header errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT (0x5CU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT
+* Macro used by MMC API to read number of ipv4 frames without TCP/UDP/ICMP payloads
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT (0x5DU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT
+* Macro used by MMC API to read number of good IPv4 datagrams with fragmentation
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT (0x5EU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT
+* Macro used by MMC API to read number of UDP frames without checksum
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G (0x5FU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G
+* Macro used by MMC API to read number of ipv6 frames 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT (0x60U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames with error in header
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT (0x61U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames without TCP/ICMP/UDP payload
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G (0x62U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G
+* Macro used by MMC API to read number of UDP frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT (0x63U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT
+* Macro used by MMC API to read number of UDP frames received with checksum errors 
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G (0x64U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G
+* Macro used by MMC API to read number of good TCP frames 
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT (0x65U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT
+* Macro used by MMC API to read  of TCP frames received with checksum errors 
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G (0x66U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G
+* Macro used by MMC API to read number of good ICMP frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT (0x67U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT
+* Macro used by MMC API to read number of ICMP frames received with checksum errors 
+*/
+
+/* Octets */
+#define TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G (0x68U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G
+* Macro used by MMC API to read number of ipv4 octets received
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS (0x69U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS
+* Macro used by MMC API to read number of octets received in ipv4 packets with 
+*     header errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS (0x6AU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS
+* Macro used by MMC API to read no. octets received in ipv4 frame with payload 
+*     other than TCP/UDP/ICMP 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS (0x6BU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS
+* Macro used by MMC API to read number of octects in the fragmented IP packet 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS (0x6CU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS
+* Macro used by MMC API to read number of octets received in a UDP segment that 
+*     had the UDP checksum disabled
+*/
+
+
+#define TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G (0x6DU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G
+*      Number of bytes received in good IPv6 datagrams encapsulating TCP, UDP or 
+*      ICMPv6 data
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS (0x6EU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS
+* Number of bytes received in IPv6 datagrams with header errors (length, version mismatch).
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS (0x6FU)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS
+* Number of bytes received in IPv6 datagrams that did not have a TCP, UDP, or
+*     ICMP payload.
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_OCTETS_G (0x70U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_OCTETS_G
+* Number of bytes received in a good UDP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS (0x71U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS
+* Number of bytes received in a UDP segment that had checksum errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_OCTETS_G (0x72U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_OCTETS_G
+* Number of bytes received in a good TCP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS (0x73U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS
+* Number of bytes received in a TCP segment with checksum errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G (0x74U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G
+* Number of bytes received in a good ICMP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS (0x75U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS
+* Number of bytes received in an ICMP segment with checksum errors
+*/
+
+/*\}*/ /* end of group3 */
+
+#endif /* End of MAC management group */
+
+/* Power management related interrupts */
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/**
+ * \defgroup group1 Power Management 
+ */
+/*\{*/
+
+/* Macro to detect the reception of wakeup frame */
+#define TMHW_LIPP6100ETH_PWRMGMT_WKUPFM_RECVD_VAL (0x40U)
+/*! \def TMHW_LIPP6100ETH_PWRMGMT_WKUPFM_RECVD_VAL
+*       Macro to detect the reception of wakeup frame
+*/
+
+/* Macro to detect the reception of magic packet */
+#define TMHW_LIPP6100ETH_PWRMGMT_MAGICPKT_RECVD_VAL (0x20U)
+/*! \def TMHW_LIPP6100ETH_PWRMGMT_MAGICPKT_RECVD_VAL
+*       Macro to detect the reception of magic packet
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PMT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_INTR_PMT_VAL
+* Macro to enable/disable interrupt generation from power management
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PMT_STAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_INTR_PMT_STAT_VAL
+* Macro to check if the PMT bit in interrupt status register is set
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MSK (0xFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MSK
+* Mask to extract the command value
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_EN_VAL (0x1U)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_EN_VAL
+* Macro to check if the PMT bit in interrupt status register is set
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MULT_VAL (0x8U)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MULT_VAL
+* Macro to enable multicast wakeup frame 
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD1_POS (8)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD1_POS
+* Macro for command value for wakeup framefilter1 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD2_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD2_POS
+* Macro for command value for wakeup framefilter2 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD3_POS (24)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD3_POS
+* Macro for command value for wakeup framefilter3 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET_MSK (0xFFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET_MSK
+* Wakeup frame filter register offset mask
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET1_POS (8)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET1_POS
+* Wakeup frame filter register offset position for frame filter1
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET2_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET2_POS
+* Wakeup frame filter register offset position for frame filter2
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET3_POS (24)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET3_POS
+* Wakeup frame filter register offset position for frame filter3
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_MSK (0xFFFFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_MSK
+* Wakeup frame filter register crc mask
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_POS
+* Wakeup frame filter register crc offset for filter 1 and 3
+*/
+
+/*\}*/
+#endif /* End of power management */
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/**
+ * \defgroup group6 IEEE 1588 Time Stamp option
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL (0x20U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+*  Macro to enable addend register update. The Time Stamp Addend registers contents are 
+*  updated to the PTP block for fine correction.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL (0x10U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+*   Macro to enable time stamp interrupt when the system time becomes greater than the value 
+*   written in Target Time register.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL (0x8U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+*   Used when the system time needs to be  updated (added to or subtracted from) with the
+*   value specified in the Time Stamp High Update and Time Stamp Low Update registers.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL (0x4U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+*  When used  the system time is initialized (overwritten) with the value specified in the 
+*  Time Stamp High Update and Time Stamp Low Update registers.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL (0x2)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+*  This macro is used when system time stamp is to be updated using fine update method
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL (0x1U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+*  This macro is used to enable time stamping for transmit and receive frames
+*/
+
+/* Interrupt status related macros w.r.t time stamp options */
+
+#define TMHW_LIPP6100ETH_TS_INT_TRIG_STATUS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_TS_INT_TRIG_STATUS_VAL
+*     Time stamp interrupt trigger status value. This is a read only bit.
+*/
+
+#define TMHW_LIPP6100ETH_TS_INT_STATUS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_TS_INT_STATUS_VAL
+*     Time stamp interrupt status. This is a clear on read bit.
+*/
+
+/* Macro to disable Time stamp interrupts */
+
+#define TMHW_LIPP6100ETH_TS_INT_MSK_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_TS_INT_MSK_VAL
+*     Macro used to mask time stamp interrupt generation.
+*/
+
+/*\}*/
+
+#endif
+
+/*-----------------------------------------------------------------------------
+** Data structures:
+**-----------------------------------------------------------------------------
+*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/**
+ * \defgroup group5 Debug/Support Functions
+ */
+/*\{*/
+
+typedef struct tmhwLIPP6100Eth_DmaHostRegs
+/*! Current Host register values */
+{
+    UInt32 curHostTxDesc ;          /*!< Current Host transmit descriptor */
+    UInt32 curHostRxDesc;           /*!< Current Host Receive descriptor */
+    UInt32 curHostTxBufferAdr;   /*!< Current Host Transmit Buffer address */
+    UInt32 curHostRxBufferAdr;   /*!< Current Host Receive Buffer address */
+}tmhwLIPP6100Eth_DmaHostRegs_t,*ptmhwLIPP6100Eth_DmaHostRegs_t;
+
+typedef struct tmhwLIPP6100Eth_DmaMissedFrmCnt
+/*!Missed Frames Counter */    
+{
+    UInt32 fifoOverflowCnt;    
+    UInt32 buffNotAvlCnt;    
+} tmhwLIPP6100Eth_DmaMissedFrmCnt_t,*ptmhwLIPP6100Eth_DmaMissedFrmCnt_t;
+
+/*\}*/
+
+#endif
+
+/*! \addtogroup group0
+   *  
+   *  \{
+   */
+/* MDC clock values */
+typedef enum tmhwLIPP6100Eth_ClkDiv
+/*! This enum is useful while deciding the MDIO clock frequency */
+{
+    tmhwLIPP6100Eth_ClkDiv_0,  /*!< clk_csr_i/42 */    
+    tmhwLIPP6100Eth_ClkDiv_1,  /*!< clk_csr_i/62 */      
+    tmhwLIPP6100Eth_ClkDiv_2,  /*!< clk_csr_i/16 */
+    tmhwLIPP6100Eth_ClkDiv_3,  /*!< clk_csr_i/26 */
+    tmhwLIPP6100Eth_ClkDiv_4,  /*!< clk_csr_i/102 */
+    tmhwLIPP6100Eth_ClkDiv_5   /*!< clk_csr_i/122 */    
+
+}tmhwLIPP6100Eth_ClkDiv_t,*ptmhwLIPP6100Eth_ClkDiv_t;
+
+/* Flow control structures */
+typedef enum  tmhwLIPP6100Eth_IFG
+/*! This enum is useful for selecting the interframe gap duration */
+{
+    tmhwLIPP6100Eth_IFG96bits=0,  /*!< Inter frame gap of 96 bit times */    
+    tmhwLIPP6100Eth_IFG88bits,      /*!< Inter frame gap of 88 bit times */    
+    tmhwLIPP6100Eth_IFG80bits,      /*!< Inter frame gap of 80 bit times */       
+    tmhwLIPP6100Eth_IFG72bits,      /*!< Inter frame gap of 72 bit times */          
+    tmhwLIPP6100Eth_IFG64bits,      /*!< Inter frame gap of 64 bit times */    
+    tmhwLIPP6100Eth_IFG56bits,      /*!< Inter frame gap of 56 bit times */      
+    tmhwLIPP6100Eth_IFG48bits,      /*!< Inter frame gap of 48 bit times */           
+    tmhwLIPP6100Eth_IFG40bits       /*!< Inter frame gap of 40 bit times */              
+}tmhwLIPP6100Eth_IFG_t,*ptmhwLIPP6100Eth_IFG_t;
+
+typedef enum  tmhwLIPP6100Eth_BackOffLimit
+/*! This enum decides the random integer of slot delays the GMAC waits
+*     before rescheduling a transmission attempt after collision 
+*     n = Retransmission attempt
+*     Range of r : 0 <= r < 2^k
+*/
+{
+    tmhwLIPP6100Eth_BackoffVal0=0,  /*!< k= min(n,10)*/
+    tmhwLIPP6100Eth_BackoffVal1,      /*!< k= min(n,8)*/
+    tmhwLIPP6100Eth_BackoffVal2,      /*!< k= min(n,4)*/   
+    tmhwLIPP6100Eth_BackoffVal3       /*!< k= min(n,1)*/ 
+   
+}tmhwLIPP6100Eth_BackOffLimit_t,*ptmhwLIPP6100Eth_BackOffLimit_t;
+
+typedef struct tmhwLIPP6100Eth_PhyInfo
+/*! Structure  to store PHY & Clk Csr value */
+{
+    UInt32 phyID;
+    UInt32 phyAddr;    /*!< PHY address  */
+    UInt32 clkCsrVal;  /*!< MDC clock    */
+}tmhwLIPP6100Eth_PhyInfo_t, *ptmhwLIPP6100Eth_PhyInfo_t;
+
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_PhyInfo_t */
+typedef const tmhwLIPP6100Eth_PhyInfo_t* const tmhwLIPP6100Eth_PhyInfo_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_StationAddress
+/*! Structure  to store the station address */
+{
+    UInt32 adrHigh; /*!< Upper 2 bytes of station address */
+    UInt32 adrLow;  /*!< Lower 4 bytes of station address*/  
+
+}tmhwLIPP6100Eth_StationAddress_t, *ptmhwLIPP6100Eth_StationAddress_t;
+
+typedef struct  tmhwLIPP6100Eth_DevConfig
+/*! Ethernet configuration structure */
+{
+    Bool txConfiginfo;                /*!< When True, MAC transfers info to PHY in SGMII/RGMII ports*/                  
+    Bool wdTimer;                      /*!< When True, disables Watchdog timer */                  
+    Bool jabberTimer;                /*!< When True, disables Jabber timer */
+    Bool frameBurst;                  /*!< When True, enables frame bursting in 1G mode */
+    Bool jumboFrame;                /*!< When True, enables Jumbo frame transmission */
+    tmhwLIPP6100Eth_IFG_t ifg;/*!< Interframe gap selection */
+    Bool miiSelect;                      /*!< When True, selects MII Interface */
+    Bool disableCS;                     /*!< When True, MAC ignores CRS signal during txmn in Half duplex mode */
+    Bool speed100Mbps;            /*!< When True, selects 100Mbps mode, False selects 10 Mbps */
+    Bool duplexMode;                 /*!< When True, selects duplex mode */    
+    Bool disableReceiveOwn;    /*!<  Disable receive Own Enable/Disable */ 
+    Bool ipChecksumOffload;     /*!<  Enable IP checksum offload & IPv4 checksum verification */
+    Bool disableRetry;                /*!<  When set, GMAC attempts only 1 transmission */
+    Bool linkup;                           /*!<  Read only bit. Valid only during get configruation */ 
+    Bool autoPadCRC;                 /*!<  GMAC Hw calculates the CRC */ 
+    tmhwLIPP6100Eth_BackOffLimit_t backOffLim; /*!< Decides random backoff value */ 
+    Bool deferralCheck;             /*!<  Enable/Disable Deferral check */
+    tmhwLIPP6100Eth_ClkDiv_t clockSelect; /*!<  MDIO Clock selection */
+    UInt32  phyAddress;            /*!< PHY addresss */
+    tmhwLIPP6100Eth_StationAddress_t station; /*!< Station Address */
+} tmhwLIPP6100Eth_DevConfig_t, *ptmhwLIPP6100Eth_DevConfig_t;
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_DevConfig_t  */
+typedef const tmhwLIPP6100Eth_DevConfig_t* const tmhwLIPP6100Eth_DevConfig_Kpk_t;
+
+typedef struct  tmhwLIPP6100Eth_PerfectAdrConfig
+/*! Perfect Address filter configuration structure */
+{
+    Bool addressEnable;  /*!< Enable this perfect address filter */
+    Bool srcAddrCmp;      /*!< Compare source address in the received frame */   
+    UInt32 addrMask;      /*!< Bytes to ignore while comparison */       
+    UInt32 macAddrHigh; /*!< Upper 2 bytes of MAC address */
+    UInt32 macAddrlow;  /*!< First 4 bytes of MAC address  */
+} tmhwLIPP6100Eth_PerfectAdrConfig_t,*ptmhwLIPP6100Eth_PerfectAdrConfig_t;
+
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_PerfectAdrConfig_t  */
+typedef const tmhwLIPP6100Eth_PerfectAdrConfig_t* const tmhwLIPP6100Eth_Kpk_PerAdrCfg_t;
+
+typedef enum tmhwLIPP6100Eth_PCF
+/*! Enum to configure the reception of Control Frames */
+{
+   tmhwLIPP6100Eth_PCF_DisableAll0=0,  /*!< Disable reception of Pause frames */  
+   tmhwLIPP6100Eth_PCF_DisableAll1,      /*!< Disable reception of Pause frames */  
+   tmhwLIPP6100Eth_PCF_PassAll,             /*!< Pass all Pause frames */  
+   tmhwLIPP6100Eth_PCF_EnableFilter      /*!< Pass Pause frames after passing filter */  
+} tmhwLIPP6100Eth_PCF_t, *ptmhwLIPP6100Eth_PCF_t;
+
+typedef struct tmhwLIPP6100Eth_FilterConfig
+/*! General filter configuration structure */
+{
+    Bool receiveAllEnable;                            /*!<  Receive all frames with status updation */
+    Bool srcAdrFilterEnable;                         /*!<  Enable/Disable source address filtering */
+    Bool srcAdrInvFilterEnable;                   /*!<  Enable/Disable source address inverse filtering */
+    Bool hashNPerfectFilterEn;                    /*!<  Enable/Disable both perfect and hash filtering */
+    tmhwLIPP6100Eth_PCF_t pauseSetting;/*!<  Pause frame filter configuration */
+    Bool filterBroadCastFrames;                  /*!<  Enable/Disable all broadcast frames*/
+    Bool recvAllMulticast;                             /*!<  Enable/Disable reception of all Multicast frames */
+    Bool destAdrInvFiltering;                       /*!<  Enable/Disable Destination Inverse filtering*/
+    Bool hashMulticastEnable;                      /*!<  Enable/Disable Hash Multicast filtering */
+    Bool hashUnicastEnable;                        /*!<  Enable/Disable Hash Unicast filtering */
+    Bool passAllFrames;                               /*!<  Receive all frames without status updation */
+}tmhwLIPP6100Eth_FilterConfig_t,*ptmhwLIPP6100Eth_FilterConfig_t;
+
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_FilterConfig_t  */
+typedef const tmhwLIPP6100Eth_FilterConfig_t* const tmhwLIPP6100Eth_FilterConfig_Kpk_t;
+
+
+typedef enum tmhwLIPP6100Eth_EnableDisable
+/*! Enum to enable disable a particular option */
+{
+    tmhwLIPP6100Eth_Disable=0,  /*!< Disable */
+    tmhwLIPP6100Eth_Enable=1    /*!< Enable */
+}tmhwLIPP6100Eth_EnableDisable_t,*ptmhwLIPP6100Eth_EnableDisable_t;
+
+typedef enum tmhwLIPP6100Eth_Dir
+/*! Enum to select the direction */
+{
+    tmhwLIPP6100Eth_Dir_Tx,      /*!< Transmit Direction */
+    tmhwLIPP6100Eth_Dir_Rx,      /*!< Receive Direction */
+    tmhwLIPP6100Eth_Dir_TxRx   /*!< Transmit & Receive Directions */
+}tmhwLIPP6100Eth_Dir_t,*ptmhwLIPP6100Eth_Dir_t;
+
+typedef enum tmhwLIPP6100Eth_PLT
+/*! Enum to select Pause Low Threshold value */
+{
+    tmhwLIPP6100Eth_PLT_4slotTime=0,  /*!<  PLT of 4 Slot times */
+    tmhwLIPP6100Eth_PLT_28slotTime,    /*!<  PLT of 28 Slot times */
+    tmhwLIPP6100Eth_PLT_144slotTime, /*!<  PLT of 144 Slot times */
+    tmhwLIPP6100Eth_PLT_256slotTime  /*!<  PLT of 256 Slot times */
+
+}tmhwLIPP6100Eth_PLT_t,*ptmhwLIPP6100Eth_PLT_t;
+
+typedef struct tmhwLIPP6100Eth_FlowCtrlConfig
+/*! Structure for flow control configuration */
+{
+    UInt32                         pauseTime;                    /*!< Pause Time Value (16 Bit) */
+    Bool                             zeroQuanta;                   /*!< Disable automatic generation of zero quanta pause */
+    tmhwLIPP6100Eth_PLT_t pauseLowThreshold;/*!< Pause Low Threshold */
+    Bool                             unicastPsDetect;            /*!< Enable/Disable Unicast Pause Frame */
+    Bool                             rxFlowCtrlEn;                 /*!< Enable/Disable rx flow control */
+    Bool                             txFlowCtrlEn;                 /*!< Enable/Disable tx flow control */
+
+}tmhwLIPP6100Eth_FlowCtrlConfig_t,*ptmhwLIPP6100Eth_FlowCtrlConfig_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_FlowCtrlConfig_t  */
+typedef const tmhwLIPP6100Eth_FlowCtrlConfig_t* const tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t;
+
+
+typedef enum tmhwLIPP6100Eth_DmaPriority
+/*! Enum to choose the Rx:Tx DMA priority ratio */
+{
+    tmhwLIPP6100Eth_DmaPriority0,/*!< 1:1 */
+    tmhwLIPP6100Eth_DmaPriority1,/*!< 2:1 */
+    tmhwLIPP6100Eth_DmaPriority2,/*!< 3:1 */
+    tmhwLIPP6100Eth_DmaPriority3/*!< 4:1 */
+}tmhwLIPP6100Eth_DmaPriority_t,*ptmhwLIPP6100Eth_DmaPriority_t;
+
+typedef enum tmhwLIPP6100Eth_PBL
+/*! Enum to choose Programmable Burst Length */
+{
+    tmhwLIPP6100Eth_PBL_Val1 =1,     /*!< PBL of 1 */
+    tmhwLIPP6100Eth_PBL_Val2 =2,     /*!< PBL of 2 */
+    tmhwLIPP6100Eth_PBL_Val4 =4,     /*!< PBL of 4 */
+    tmhwLIPP6100Eth_PBL_Val8 =8,     /*!< PBL of 8 */
+    tmhwLIPP6100Eth_PBL_Val16 =16, /*!< PBL of 16 */       
+    tmhwLIPP6100Eth_PBL_Val32 =32  /*!< PBL of 32 */          
+
+}tmhwLIPP6100Eth_PBL_t,*ptmhwLIPP6100Eth_PBL_t ; 
+
+/* For configuring DMA in transmit direction */
+typedef enum tmhwLIPP6100Eth_TTC
+/*! Enum to configure the transmit threshold control */
+{
+    tmhwLIPP6100Eth_TTC_64bytes,    /*!< 64 bytes */
+    tmhwLIPP6100Eth_TTC_128bytes,  /*!< 128 bytes */
+    tmhwLIPP6100Eth_TTC_192bytes,  /*!< 192 bytes */   
+    tmhwLIPP6100Eth_TTC_256bytes,  /*!< 256 bytes */
+    tmhwLIPP6100Eth_TTC_40bytes,    /*!< 40 bytes */ 
+    tmhwLIPP6100Eth_TTC_32bytes,    /*!< 32 bytes */
+    tmhwLIPP6100Eth_TTC_24bytes,    /*!< 24 bytes */
+    tmhwLIPP6100Eth_TTC_16bytes     /*!< 16 bytes */
+
+}tmhwLIPP6100Eth_TTC_t,*ptmhwLIPP6100Eth_TTC_t;
+
+typedef enum tmhwLIPP6100Eth_RTC
+/*! Enum to configure the receive threshold control */
+{
+    tmhwLIPP6100Eth_RTC_64bytes,    /*!< 64 bytes */
+    tmhwLIPP6100Eth_RTC_32bytes,    /*!< 32 bytes */  
+    tmhwLIPP6100Eth_RTC_96bytes,    /*!< 96 bytes */       
+    tmhwLIPP6100Eth_RTC_128bytes   /*!< 128 bytes */
+
+}tmhwLIPP6100Eth_RTC_t,*ptmhwLIPP6100Eth_RTC_t;
+
+typedef struct tmhwLIPP6100Eth_EnTxfr
+/*! Structure  to Enable/Disable Tx/Rx transfers */
+{
+    tmhwLIPP6100Eth_EnableDisable_t  enFlag; /*!< Enable/Disable flag */
+    tmhwLIPP6100Eth_Dir_t                    dirFlag; /*!<  Direction flag */
+}tmhwLIPP6100Eth_EnTxfr_t,*ptmhwLIPP6100Eth_EnTxfr_t;
+
+/*! \brief Constant pointer to constant data refering tmhwLIPP6100Eth_EnTxfr_t */
+typedef const tmhwLIPP6100Eth_EnTxfr_t * const  tmhwLIPP6100Eth_EnTxfr_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_Int
+/*! Structure  to store the interrupt register values */
+{
+    UInt32 dmaIntVal;      /*!<  Variable to store DMA interrupt mask/status values */
+    UInt32 gmacIntVal;     /*!<  Variable to store GMAC interrupt mask/status values */
+}tmhwLIPP6100Eth_Int_t,*ptmhwLIPP6100Eth_Int_t;
+
+/*! \brief Constant pointer to constant data refering tmhwLIPP6100Eth_Int_t */
+typedef const tmhwLIPP6100Eth_Int_t * const  tmhwLIPP6100Eth_Int_Kpk_t;
+
+typedef enum tmhwLIPP6100Eth_RFD
+/*! Enum to select the Flow control deactivating threshold value */
+{
+    tmhwLIPP6100Eth_RFD_1K,  /*!< Deassert flow control after Full-1K */
+    tmhwLIPP6100Eth_RFD_2K,  /*!< Deassert flow control after Full-2K */      
+    tmhwLIPP6100Eth_RFD_3K,  /*!< Deassert flow control after Full-3K */          
+    tmhwLIPP6100Eth_RFD_4K,   /*!< Deassert flow control after Full-4K */
+    tmhwLIPP6100Eth_RFD_5K,   /*!< Deassert flow control after Full-5K */    
+    tmhwLIPP6100Eth_RFD_6K,   /*!< Deassert flow control after Full-6K */        
+    tmhwLIPP6100Eth_RFD_7K    /*!< Deassert flow control after Full-7K */            
+
+}tmhwLIPP6100Eth_RFD_t,*ptmhwLIPP6100Eth_RFD_t;
+
+typedef enum tmhwLIPP6100Eth_RFA
+/*! Enum to select the Flow control activating threshold value */
+{
+    tmhwLIPP6100Eth_RFA_1K,  /*!<  Activate flow control when fifo fill level is (Full-1K) */
+    tmhwLIPP6100Eth_RFA_2K,  /*!<  Activate flow control when fifo fill level is (Full-2K) */      
+    tmhwLIPP6100Eth_RFA_3K,  /*!<  Activate flow control when fifo fill level is (Full-3K) */          
+    tmhwLIPP6100Eth_RFA_4K,  /*!<  Activate flow control when fifo fill level is (Full-4K) */
+    tmhwLIPP6100Eth_RFA_5K,  /*!<  Activate flow control when fifo fill level is (Full-5K) */    
+    tmhwLIPP6100Eth_RFA_6K,  /*!<  Activate flow control when fifo fill level is (Full-6K) */        
+    tmhwLIPP6100Eth_RFA_7K   /*!<  Activate flow control when fifo fill level is (Full-7K) */            
+}tmhwLIPP6100Eth_RFA_t,*ptmhwLIPP6100Eth_RFA_t;
+
+typedef struct tmhwLIPP6100Eth_DmaCfg
+/*! Structure to select the DMA configuration */
+{
+    
+
+    Bool mixedBurst; /*!< Enabled mixed burst mode */    
+    Bool addrAlignedBtsEn;                             /*!< Address aligned beats enable */    
+    Bool fixedBurstEn;                                     /*!< Enable/Disable Fixed Bursting */
+    tmhwLIPP6100Eth_DmaPriority_t priority;/*!< Select the DMA priority */
+    Bool pBL4xmode;                                      /*!< When set, effective PBL becomes (4* burstLen) */
+    Bool differentPBL;                                     /*!<  Use separate PBL for tx & rx */
+    tmhwLIPP6100Eth_PBL_t rxPBL;              /*!<  PBL for receive direction */    
+    tmhwLIPP6100Eth_PBL_t burstLen;          /*!< Programmable Burst Length */
+    Bool enableAltDescSize;                  /*!< Enable alternate descriptor size of 32 bytes */                       
+    UInt32 descSkipLen;                                 /*!< Descriptor skip length */
+    Bool dmaArbitration;                                 /*!< Round Robin or Priority of Rx > Tx */
+
+    /* Transmit side configuration */
+    Bool                                    storeNforwardEn;  /*!< Enable/Disable Store and Forward Mechanism */
+    tmhwLIPP6100Eth_TTC_t   txThreshold;           /*!< Transmit Threshold control */
+    tmhwLIPP6100Eth_RTC_t   rxThreshold;           /*!< Receive Threshold control */
+    Bool                                    txSecondFrameEn;  /*!< Transmit second frame enable/disable  */
+    UInt32                                txDescListBaseAdr; /*!< Transmit descriptor list base address */
+
+     /* Receive side configuration */
+    tmhwLIPP6100Eth_RFA_t actRxThreshold;	/*!< Receive Flow control activate value */
+    tmhwLIPP6100Eth_RFD_t deactRxThreshold;/*!< Receive Flow control Deactivate value */
+    Bool                                   hwFlowCtrlEn; /*!< Enable/Disable Hardware Flow control */
+    Bool                                   errFramesEn; /*!< Enable/Disable reception of error frames */
+    Bool                                   underSizedGdFramesEn; /*!< Enable/Disable reception of undersized good frames */
+    UInt32                               rxDescListBaseAdr;   /*!< Receive descriptor list base address */ 
+    Bool disableFrameFlush;                         /*!< Disable frame flushing, when descriptors are not available */
+    Bool rxStoreNforwardEn; /*!< Enable/Disable receive store and Forward Mechanism */ 
+    Bool recvTcpIpErrFrms; /*!< Enable/Disable reception of TCP/IP error frames */       
+
+ }tmhwLIPP6100Eth_DmaCfg_t,*ptmhwLIPP6100Eth_DmaCfg_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_DmaCfg_t */
+typedef const tmhwLIPP6100Eth_DmaCfg_t* const tmhwLIPP6100Eth_DmaCfg_Kpk_t;
+
+
+/*! \} */ /* End of group0 */
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH )
+
+/**
+ * \defgroup group2 Hash Filter Related
+ */
+/*\{*/
+
+typedef struct tmhwLIPP6100Eth_HashFilter
+/*! Hash Filter configuration Structure */
+{
+    UInt32 hashFilterH;  /*!< Hash Filter High Register */
+    UInt32 hashFilterL;  /*!<  Hash Filter Low Register */   
+}tmhwLIPP6100Eth_HashFilter_t,*ptmhwLIPP6100Eth_HashFilter_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_HashFilter_t */
+typedef const tmhwLIPP6100Eth_HashFilter_t* const tmhwLIPP6100Eth_HashFilter_Kpk_t;
+
+
+/*\}*/ /* End of group2 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+
+/*! \addtogroup group3
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_MmcCtrl
+/*! MAC management counters configuration */
+{
+    Bool freezeCntrs;          /*!< Enable/Disable freezing of counters */
+    Bool resetOnRdEn;        /*!< Enable/Disable reset on Read */
+    Bool rollOverDisable;    /*!< Enable/Disable rollover */
+    Bool resetCounters;       /*!< Reset counters */
+}tmhwLIPP6100Eth_MmcCtrl_t,*ptmhwLIPP6100Eth_MmcCtrl_t;
+
+/*! \brief Contant pointer to constant data of type tmhwLIPP6100Eth_MmcCtrl_t */
+typedef const tmhwLIPP6100Eth_MmcCtrl_t* const tmhwLIPP6100Eth_MmcCtrl_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_MmcIntStat
+/*! MAC management Interrupt status structure */
+{
+    UInt32                               rxCsumStatus; /*!< Rx checksum offload status */
+    UInt32                               intStat;             /*!< Interrupt status */
+    tmhwLIPP6100Eth_Dir_t    dir;                   /*!< Tx/Rx direction  */
+}tmhwLIPP6100Eth_MmcIntStat_t, *ptmhwLIPP6100Eth_MmcIntStat_t;
+
+typedef struct tmhwLIPP6100Eth_MmcIntr
+/*! Structure to enable and disable MAC interrupts */
+{
+    UInt32                          rxCsumIntVal; /*!< Rx checksum offload interrupts */
+    UInt32                          intrVal;             /*!< Interrupts to Enable or disable */
+    tmhwLIPP6100Eth_Dir_t dir;                 /*!< Tx/Rx direction  */
+}tmhwLIPP6100Eth_MmcIntr_t, *ptmhwLIPP6100Eth_MmcIntr_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_MmcIntr_t */
+typedef const tmhwLIPP6100Eth_MmcIntr_t* const tmhwLIPP6100Eth_MmcIntr_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_MmcRegVal
+/*! MAC management structure to read MAC counters */
+{
+    UInt32                        mmcRegVal; /*!< Register Value read */
+    UInt32                        regToRd;       /*!< Register to be read */
+}tmhwLIPP6100Eth_MmcRegVal_t, *ptmhwLIPP6100Eth_MmcRegVal_t;
+
+/*! \} */ /* End of group3 */
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+
+/* Power management related */
+/*! \addtogroup group1
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_WkupCfg
+/*! Structure to store the Wakeup on LAN configuration */
+{
+    Bool      rstRegptr;               /*!< Reset wakeup frame filter register pointer */
+    Bool      globalUnicastEn;    /*!< Enable/Disable Wakeup on Unicast frame reception */
+    Bool      wkupFrameEn;       /*!< Enable/Disable Wakeup Frame */
+    Bool      magicPktEn;           /*!< Enable/Disable Wakeup on Magic Packet reception */
+    UInt32  filterMask[4];         /*!< Mask to be applied for the incoming frame */
+    UInt32  filterCommand;      /*!< Multicast/Unicast and Enable/disable filter options */
+    UInt32  filterOffset;            /*!<  Offset to start sampling the bytes for calucating CRC */
+    UInt32  filterCrcVal6;         /*!< CRC value to be used by filter 0 and filter 1 */
+    UInt32  filterCrcVal7;         /*!< CRC value to be used by filter 2 and filter 3 */    
+}tmhwLIPP6100Eth_WkupCfg_t,*ptmhwLIPP6100Eth_WkupCfg_t;
+/*! \} */ /* End of group1 */
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_WkupCfg_t */
+typedef const tmhwLIPP6100Eth_WkupCfg_t* const tmhwLIPP6100Eth_WkupCfg_Kpk_t;
+
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/*! \addtogroup group6
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_TsReg
+/*! Current Host register values */
+{
+    UInt32 highVal;/*!< Higher 32 bit value of the register */
+    UInt32 lowVal; /*!< Lower 32 bit value of the register */
+}tmhwLIPP6100Eth_TsReg_t,*ptmhwLIPP6100Eth_TsReg_t;
+
+typedef enum tmhwLIPP6100Eth_Ts_Psnt
+/*! Enum to indicate if the value in the update registers is to be added or 
+**   subtracted from the system time.
+*/
+{
+    tmhwLIPP6100Eth_AddToSysTime,
+    tmhwLIPP6100Eth_SubFromSysTime        
+}tmhwLIPP6100Eth_Ts_Psnt_t, *ptmhwLIPP6100Eth_Ts_Psnt_t;
+
+typedef struct tmhwLIPP6100Eth_TsUpdateReg
+/*! Value in the Time Stamp Update registers is added to the system time
+** or subtracted depending on addSub flag
+*/
+{
+    tmhwLIPP6100Eth_TsReg_t updateReg;
+    tmhwLIPP6100Eth_Ts_Psnt_t addSub;    
+
+}tmhwLIPP6100Eth_TsUpdateReg_t, *ptmhwLIPP6100Eth_TsUpdateReg_t;
+
+/*! \} */ /* End of group6 */
+#endif
+
+/*-----------------------------------------------------------------------------*/
+/* Exported functions:*/
+/*-----------------------------------------------------------------------------*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+
+/*! \addtogroup group5
+   *  Additional support functions
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetSWVersion (ptmSWVersion_t  pEthGmacVersion);
+* This function gets the sofware version of the driver 
+*  \param[out] pEthGmacVersion: Pointer to structure tmSWVersion_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSWVersion (
+    ptmSWVersion_t  pEthGmacVersion    
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetHWVersion(tmUnitSelect_t ethUnitId, pUInt32 pHWVersion);
+* This function returns the hardware version number of the ethernet unit
+*  \param[in] ethUnitId: Ethernet Unit ID
+*  \param[out] pHWVersion: Pointer to variable, where the version number is to be stored
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetHWVersion(
+    tmUnitSelect_t                    ethUnitId,  
+    pUInt32                             pHWVersion
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_Deinit(tmUnitSelect_t ethUnitId);
+* This function disables the GMAC hardware
+*  \param[in] ethUnitId: Ethernet Unit ID
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Deinit(
+    tmUnitSelect_t  ethUnitId   
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetConfig(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DevConfig_t pEthConfig);
+* This function gets the current configuration of the GMAC device
+*  \param[in] ethUnitId: Ethernet Unit ID
+*  \param[out] pEthConfig : Fills the information in the pEthConfig pointer passed as parameter
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetConfig(
+    tmUnitSelect_t                      ethUnitId ,    
+    ptmhwLIPP6100Eth_DevConfig_t    pEthConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaFlushTxFifo (tmUnitSelect_t ethUnitId);
+* This function is used to flush the contents of a Transmit FIFO
+* \param[in] ethUnitId: GMAC unit number 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaFlushTxFifo(
+    tmUnitSelect_t  ethUnitId 
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaGetCurrentHostRegs(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DmaHostRegs_t pDmaHostReg);
+* This function is used to retrieve the DMA host registers for debug purposes
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pDmaHostReg: Pointer to structure tmhwLIPP6100Eth_DmaHostRegs_t for storing the read values 
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetCurrentHostRegs(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaHostRegs_t     pDmaHostReg       
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaGetMissedFrameCount (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt);
+* This function is used to clear the Missed Frames counter
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pMissedFrmCnt: Pointer to structure ptmhwLIPP6100Eth_DmaMissedFrmCnt_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetMissedFrameCount(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaMissedFrameCounterClear (tmUnitSelect_t ethUnitId);
+* This function is used to clear the Missed Frames counter
+* \param[in] ethUnitId: GMAC unit number 
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaMissedFrameCounterClear(
+    tmUnitSelect_t                                 ethUnitId
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FilterGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_FilterConfig_t pFilterConfig);
+* This function is used to get the receive filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pFilterConfig: Pointer to tmhwLIPP6100Eth_FilterConfig_t structure for storing the read values
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    ptmhwLIPP6100Eth_FilterConfig_t        pFilterConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_PerfectAdrGetConfig (tmUnitSelect_t ethUnitId,UInt32 regNum,ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig);
+* This function is used to get the perfect address filter configuration
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regNum: Perfect address filter register number
+* \param[out] pAdrConfig: Pointer to structure tmhwLIPP6100Eth_PerfectAdrConfig_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,    
+    ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_FlowCtrlConfig_t pFlowCtrlCfg);
+* This function is used to do flow control configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFlowCtrlCfg: Pointer to tmhwLIPP6100Eth_FlowCtrlConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlGetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    ptmhwLIPP6100Eth_FlowCtrlConfig_t        pFlowCtrlCfg
+);
+/*! \} */ /* Group5 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/*! \addtogroup group1
+   *  Power Management Functions
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetPowerState (tmUnitSelect_t ethUnitId,ptmPowerState_t pEthPowerState);
+* This function gets the current power state of the GMAC device
+*  \param[in] ethUnitId: Ethernet unit ID
+*  \param[out] pEthPowerState: Pointer to tmPowerState_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetPowerState(
+    tmUnitSelect_t    ethUnitId ,
+    ptmPowerState_t pEthPowerState
+    );
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetPowerState(tmUnitSelect_t  ethUnitId, tmPowerState_t ethPowerState);
+* This function sets/resets power down bit of the GMAC. Function tmhwLIPP6100Eth_WoLConfig() is to be 
+* called before putting the device into power down mode.
+* \param[in] ethUnitId: GMAC Unit number.
+* \param[in] ethPowerState: Power On or Power Off
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetPowerState(
+    tmUnitSelect_t   ethUnitId  , 
+    tmPowerState_t  ethPowerState
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_WoLConfig(tmUnitSelect_t  ethUnitId, tmhwLIPP6100Eth_WkupCfg_Kpk_t pWolConfig);
+* This function sets the wakeup method for the GMAC when putting the device into power down mode. 
+* \param[in] ethUnitId: Instance number of the device
+* \param[in] pWolConfig: Pointer to structure tmhwLIPP6100Eth_WkupCfg_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_WoLConfig(
+    tmUnitSelect_t   ethUnitId  , 
+    tmhwLIPP6100Eth_WkupCfg_Kpk_t  pWolConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetWakeupStatus(tmUnitSelect_t  ethUnitId, pUInt32 pRegVal);
+* This function is used to get the cause of a wakeup event 
+* \param[in] ethUnitId: Instance number of the device
+* \param[out] pRegVal: Pointer to variable to store the status
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetWakeupStatus(
+    tmUnitSelect_t       ethUnitId ,    
+    pUInt32                  pRegVal
+    );
+
+/*! \} */ /* group1 */
+#endif 
+
+/*! \addtogroup group0
+   *  Basic API set
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_Init (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_DevConfig_Kpk_t pPhyinfo);
+* This function initializes the GMAC with default values
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pPhyinfo: PHY address & Clk Csr value
+* \param[in] miiSelect: MII interface then True
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Init(
+    tmUnitSelect_t  ethUnitId,
+    tmhwLIPP6100Eth_PhyInfo_Kpk_t pPhyinfo,
+    Bool miiSelect
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig);
+* This function configures the GMAC device with the values passed.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pEthConfig: Pointer to structure tmhwLIPP6100Eth_DevConfig_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetConfig(
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntGetStatus (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_Int_t pIntStat);
+* This function gets DMA interrupt status
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pIntStat: Pointer to structure tmhwLIPP6100Eth_Int_t 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntGetStatus (
+    tmUnitSelect_t                               ethUnitId ,    
+    ptmhwLIPP6100Eth_Int_t                  pIntStat
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntEnable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Int_Kpk_t pIntEn);
+* This function enables the device interrupts
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pIntEn: Interrupts to be enabled
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntEnable (
+    tmUnitSelect_t              ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntEn
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Int_Kpk_t pIntDis);
+* This function disables the device interrupts
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pIntDis: Interrupts to be disabled
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntDisable (
+    tmUnitSelect_t                       ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t     pIntDis
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntClear (tmUnitSelect_t ethUnitId,UInt32 ethIntstatus);
+* This function clears the device interrupts by writing 1s to the status register
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] ethIntstatus: Interrupts to be cleared
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntClear (
+    tmUnitSelect_t              ethUnitId ,    
+    UInt32                         ethIntstatus
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_PerfectAdrSetConfig (tmUnitSelect_t ethUnitId,UInt32 regNum,tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig);
+* This function is used to configure the perfect address filters of GMAC
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regNum: Perfect address filter register number
+* \param[in] pAdrConfig: Pointer to structure tmhwLIPP6100Eth_PerfectAdrConfig_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrSetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,
+    tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FilterSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_FilterConfig_Kpk_t pFilterConfig);
+* This function is used to set the filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFilterConfig: Pointer to tmhwLIPP6100Eth_FilterConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterSetConfig(
+    tmUnitSelect_t                          ethUnitId , 
+    tmhwLIPP6100Eth_FilterConfig_Kpk_t  pFilterConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GmacEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnTxfr_Kpk_t pEndir);
+* This function is used to enable or disable GMAC in transmit or receive or both the directions
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pEndir: Pointer to tmhwLIPP6100Eth_EnTxfr_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_GmacEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t      pEndir    
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_LpbkEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnableDisable_t enableDisable);
+* This function is used to enable loopback at the MAC level
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] enableDisable: Enum to enable or disable
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_LpbkEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t     enableDisable
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t pFlowCtrlCfg);
+* This function is used to do flow control configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFlowCtrlCfg: Pointer to tmhwLIPP6100Eth_FlowCtrlConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlSetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t        pFlowCtrlCfg
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnableDisable_t enableDisable);
+* This function is used to enable the generation of pause frame in full-duplex mode, and in half duplex
+* to activate/deactivate backpressure operation.
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] enableDisable: Enum to enable or disable
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlEnableDisable(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t enableDisable
+) ;
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlStatus (tmUnitSelect_t ethUnitId,pUInt32 pRegVal);
+* This function is used to check if the FCA/BP bit is cleared after a pause frame transmission
+* \param[in] ethUnitId : Ethernet unit number 
+* \param[out] pRegVal: Pointer to variable to store the status 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlStatus(
+    tmUnitSelect_t                          ethUnitId,
+    pUInt32                                    pRegVal
+); 
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_DmaCfg_Kpk_t pDmaConfig);
+* This function is used to do the DMA configuration.
+* \param[in] ethUnitId : Ethernet unit number
+* \param[in] pDmaConfig: Pointer to tmhwLIPP6100Eth_DmaCfg_t structure
+* \return TM_OK - successful
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaConfig(
+    tmUnitSelect_t                               ethUnitId ,
+    tmhwLIPP6100Eth_DmaCfg_Kpk_t        pDmaConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnTxfr_Kpk_t pTxfr);
+* This function is used to Enable/Disable DMA in a particular direction
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pTxfr: Pointer to structure tmhwLIPP6100Eth_EnTxfr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaEnableDisable(
+    tmUnitSelect_t  ethUnitId, 
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t pTxfr
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaPollDesc(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Dir_t dir);
+* This function is used to restart the DMA transmission/reception if it is in suspended state 
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] dir: Enum, which indicates the direction
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaPollDesc(
+    tmUnitSelect_t          ethUnitId,
+    tmhwLIPP6100Eth_Dir_t       dir
+);
+
+tmErrorCode_t tmhwLIPP6100Eth_get_phyInfo(tmUnitSelect_t  ethUnitId, UInt32* phyID, UInt32* phyAddr);
+
+/*! \} */ /*End of  group0*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH)
+/*! \addtogroup group2
+   *  Hash Filter APIs
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_HashFilterSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_HashFilter_Kpk_t pHashConfig);
+* This function is used to set the hash filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pHashConfig: Pointer to tmhwLIPP6100Eth_HashFilter_t structure
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterSetConfig(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_HashFilter_Kpk_t    pHashConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_HashFilterGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_HashFilter_t pHashConfig);
+* This function is used to get the hash filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pHashConfig: Pointer to tmhwLIPP6100Eth_HashFilter_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterGetConfig(
+    tmUnitSelect_t                                ethUnitId ,
+    ptmhwLIPP6100Eth_HashFilter_t          pHashConfig
+);
+
+/*! \} */ /*End of  group2 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC )
+
+/*! \addtogroup group3
+   *  APIs for MAC Management Counters 
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCConfig(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcCtrl_Kpk_t pCtrlConfig);
+* This function is used to configure the behaviour of MAC Management counters and also to reset counters
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pCtrlConfig: Pointer to structure tmhwLIPP6100Eth_MmcCtrl_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_MMCConfig(
+    tmUnitSelect_t                      ethUnitId,
+    tmhwLIPP6100Eth_MmcCtrl_Kpk_t           pCtrlConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntStatus(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_MmcIntStat_t pMmcStat);
+* This function is used to read the interrupt status register for transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcStat: Pointer to structure tmhwLIPP6100Eth_MmcIntStat_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntStatus(
+    tmUnitSelect_t                            ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcIntStat_t   pMmcStat
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntEnable(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcIntr_Kpk_t pMmcIntEn);
+* This function is used to enable the MMC interrupts in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcIntEn: Pointer to structure tmhwLIPP6100Eth_MmcIntr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntEnable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntEn
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntDisable(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcIntr_Kpk_t pMmcIntDis);
+* This function is used to disable the MMC interrupts in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcIntDis: Pointer to structure tmhwLIPP6100Eth_MmcIntr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntDisable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntDis
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCCountersRead(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg);
+* This function is used to read the Mac Management Counters in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcReg: Pointer to structure tmhwLIPP6100Eth_MmcRegVal_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCCountersRead(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg
+);
+
+/*! \} */ /* End of group 3*/
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_VLAN)
+
+/**
+ * \defgroup group4 VLAN Tag APIs
+ */
+/*\{*/
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetVLANTag(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This function is used to set the VLAN tag value.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: VLAN tag value
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetVLANTag (
+    tmUnitSelect_t    ethUnitId ,    
+    UInt32            regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetVLANTag(tmUnitSelect_t ethUnitId,pUInt32 pRegValue);
+* This function is used to get the VLAN tag value.
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegValue: Pointer to store the VLAN tag value read 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+);
+
+/*\}*/ /* end of group4 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/**
+ * \addtogroup group6
+ */
+/*\{*/
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetTsCtrlVal(tmUnitSelect_t ethUnitId,pUInt32 pRegValue);
+* This function returns the control value of the time stamp registers.
+* Below macros can be used to check if a corresponding bit is set/reset in 
+* the register: 
+* TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegValue: Pointer to store the control value read 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetTsCtrlVal(
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsCtrl(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This function enables/disables certain features of time stamp operation,depending on the value 
+* passed. 
+* Parameter to this function can be any of the below macros:
+* TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: Time stamp control value to set 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsCtrl(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsSubSecInc(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* API to set sub-second increment value
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: Sub-Second increment value
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsSubSecInc(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsAddend(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This API is used to set Time Stamp Addend value. This is used only when system time is configured 
+* for Fine Update mode.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue:  Addend value
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsAddend(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetSysTs(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_TsReg_t pRegs);
+* This API fetches the current system time stamp value. 
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegs: Pointer to structure to store the values read
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSysTs(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsUpdate(tmUnitSelect_t ethUnitId, ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate);
+* This API is used to set the values of Time Stamp update registers & the parameter passed to this 
+* function also indicates if the value is to be added to the system time or subracted from the system 
+* time.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pUpdate: Pointer to structure that stores the time stamp values & flag that indicates 
+*   whether to add or subtract this value from system time.
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsUpdate(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate   
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsTgtTime(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_TsReg_t pRegs);
+* This API is used to set the target time stamp register values.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pRegs: Pointer to structure which contains  target high & targe low register values
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsTgtTime(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+);
+
+/*\}*/ /* end of group6 */
+#endif
+
+/* End of function prototypes */
+
+#if defined(__cplusplus)
+}
+#endif  /* defined(__cplusplus) */
+
+#endif  /* TMHWLIPP6100ETH_H */
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,3172 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth.c %
+ * %pid_version:          1.7                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   Scalable HwApi Driver for Ethernet GMAC
+ *
+ *  DOCUMENT REF: Synopsys DesignWare Ethernet Universal Databook 
+ *                         Version 3.41a, February 7, 2008 
+  *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/*-----------------------------------------------------------------------------
+/ Standard include files:
+/-----------------------------------------------------------------------------
+*/
+
+#include <tmNxTypes.h>
+
+/*-----------------------------------------------------------------------------
+/ Project include files:
+/-----------------------------------------------------------------------------
+*/
+#include <tmhwLIPP6100Eth_Cfg.h>
+#include <tmhwLIPP6100Eth.h>
+#include <tmhwLIPP6100Eth_Vhip.h>
+
+#include <linux/kernel.h>
+
+/*-----------------------------------------------------------------------------
+/ Types and defines:
+/-----------------------------------------------------------------------------
+*/
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+    
+    #if ( IPVERSION_34_1_A)
+    #define MMC_RST_ON_RD_SAVE(_base_, _val_) \
+    {\
+        UInt32 _tmp_;\
+        TMVH_GEN_READ(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_val_);\
+        _tmp_ = _val_;\
+        _tmp_ &= ~TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;\
+        TMVH_GEN_WRITE(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_tmp_);\
+    }
+
+    #define MMC_RST_ON_RD_RESTORE(_base_,_val_) \
+        TMVH_GEN_WRITE(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_val_)
+    #else
+    #define MMC_RST_ON_RD_SAVE(_base_, _val_) 
+    #define MMC_RST_ON_RD_RESTORE(_base_,_val_) 
+    #endif
+
+#endif
+
+/*-----------------------------------------------------------------------------
+/ Global data:
+/-----------------------------------------------------------------------------
+*/
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+    #if ( IPVERSION_34_1_A)
+    static UInt32 gtmhwLIPP6100Eth_ActRegVal[14];
+    #endif
+
+#endif
+
+/*-----------------------------------------------------------------------------
+/ Internal Prototypes:
+/-----------------------------------------------------------------------------
+*/
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+    #if ( IPVERSION_34_1_A)
+    UInt32  compute_ipc_value (UInt32 pRegs,UInt32 regOffset,UInt32 index);
+    #endif
+
+#endif
+
+
+/*-----------------------------------------------------------------------------
+/ Exported functions:
+/-----------------------------------------------------------------------------
+*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetSWVersion:
+**
+** DESCRIPTION: This function returns the Ethernet HWAPI device interface software 
+** version information.Higher-level software layers to ensure that the 
+** Ethernet HWAPI exports the expected function interface version typically
+** call it.
+**
+** RETURN:      TM_OK
+**
+** NOTES:   This API can be called anytime i.e. before initializing the Ethernet 
+**          or in PowerOff state.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSWVersion (
+    ptmSWVersion_t  pEthGmacVersion    
+    )
+{
+    pEthGmacVersion->compatibilityNr = TMHW_LIPP6100ETH_COMPATIBILITY_NR;
+    pEthGmacVersion->majorVersionNr  = TMHW_LIPP6100ETH_MAJOR_VERSION_NR;
+    pEthGmacVersion->minorVersionNr  = TMHW_LIPP6100ETH_MINOR_VERSION_NR;
+    return (TM_OK);
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetHWVersion:
+**
+** DESCRIPTION: This function returns the hardware version number of the
+**                      Ethernet unit passed as parameter to this function.
+**
+** RETURN:      TM_OK
+**
+** NOTES:       This API can be called anytime i.e. before initializing the Ethernet
+**                   or in PowerOff state
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetHWVersion(
+    tmUnitSelect_t                    ethUnitId,  
+    pUInt32                             pHWVersion
+    ) 
+{
+    UInt32 pRegs; 
+    
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_VERSION_REG_OFFSET,*pHWVersion);
+
+    return (TM_OK);
+
+}        
+
+#endif
+
+static UInt32 gmac_read_phy_reg(UInt32 gmacAddr, UInt32 phyAddr, UInt32 reg, UInt16* pVal)
+{
+    UInt32 regVal, timeout=100000;
+    volatile UInt32* pAdrReg;
+    volatile UInt32* pDataReg;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(gmacAddr+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET) ;
+    pDataReg = (UInt32*)(gmacAddr+TMVH_LIPP6100ETH_GMII_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regVal = *pAdrReg;
+
+    /* Clear the earlier PHY Address value in Address register and write the new value */
+    regVal &= TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR;
+    regVal |= phyAddr << TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS;
+
+    /* Clear the earlier GMII reg value in Address register and write the new value */
+    regVal &= TMVH_LIPP6100ETH_GMII_GMII_REGISTER_CLR;
+    regVal |= (reg << TMVH_LIPP6100ETH_GMII_GMII_REGISTER_POS);
+
+    /* Clear the bit GMII write for read operation */
+    regVal &= TMVH_LIPP6100ETH_GMII_GMII_WRITE_CLR;
+
+    /* Enable the GMII Busy bit and write the Val */
+    *pAdrReg = regVal | 1;
+
+    /* Wait till the read operation is complete or timeout expires */
+    do
+    {
+        timeout--;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_GMII_BUSY_VAL) == TMHW_LIPP6100ETH_GMII_BUSY_VAL) &&
+                  (timeout > 0) );
+
+    if( (timeout == 0) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_GMII_BUSY_VAL) == TMHW_LIPP6100ETH_GMII_BUSY_VAL) )
+    {
+        return 1;
+    }
+
+    /* Read the data from the data register */
+    *pVal = (UInt16) *pDataReg;
+
+    return 0;
+
+}
+
+#define PHY_BMSR    1
+#define PHY_PHYID1  2
+#define PHY_PHYID2  3
+
+tmErrorCode_t tmhwLIPP6100Eth_get_phyInfo(tmUnitSelect_t  ethUnitId, UInt32* phyID, UInt32* phyAddr)
+{
+    UInt32 pEthRegs, phy_found=0, ret_val;
+    UInt16 i, phyBmsr, ID0Reg=0, ID1Reg=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+    *phyAddr = 0xFFFF;
+    *phyID = 0xFFFF;
+
+    /* Auto Detect for first available PHY */
+    for(i=0; i < 32; i++)
+    {
+        /* Read the PHY BMSR register */
+        ret_val = gmac_read_phy_reg(pEthRegs, i, PHY_BMSR, &phyBmsr);
+        if(ret_val)
+        {
+            printk("Error reading PHY register GMAC%d\n", ethUnitId);
+            phy_found=0;
+            break;
+        }
+
+        /* If the BMSR is valid, that means we found a PHY */
+        if(phyBmsr != 0xffff)
+        {
+            /* This is our PHY address */
+            *phyAddr = i;
+
+            /* Read the PHY ID0 */
+            ret_val = gmac_read_phy_reg(pEthRegs, i, PHY_PHYID1, &ID0Reg);
+            if(ret_val)
+            {
+                printk("Error reading PHY register GMAC%d\n", ethUnitId);
+                phy_found=0;
+                break;
+            }
+
+            /* Read the PHY ID1 */
+            ret_val = gmac_read_phy_reg(pEthRegs, i, PHY_PHYID2, &ID1Reg);            
+            if(ret_val)
+            {
+                printk("Error reading PHY register GMAC%d\n", ethUnitId);
+                phy_found=0;
+                break;
+            }
+
+            *phyID = (ID0Reg <<16) | ID1Reg;
+
+            /* PHY found marker */
+            phy_found = 1;
+            break;
+        }
+    }
+
+    /* We are OK if PHY is found */
+    if(phy_found)
+        return TM_OK;
+    else
+        return TM_ERR_INIT_FAILED;
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_Init:
+**
+** DESCRIPTION: This function initializes the Ethernet device hardware. 
+**                      It should be called before any access to the device is made. 
+**                      This function resets the MAC
+**
+** RETURN:      TM_OK
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+
+tmErrorCode_t
+tmhwLIPP6100Eth_Init(
+    tmUnitSelect_t  ethUnitId,
+    tmhwLIPP6100Eth_PhyInfo_Kpk_t pPhyinfo,
+    Bool miiSelect
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Reset the GMAC core */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,
+                                TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL);
+
+    /* Select the GMII or MII interface */
+    if(miiSelect == True)
+        regVal = TMVH_LIPP6100ETH_CONFIG_MII_VAL;
+    else
+        regVal = TMVH_LIPP6100ETH_CONFIG_GMII_VAL;
+
+    /* Program the MAC configuration register. Untouched values are in default state 
+    ** PS =1 : MII 10/100 Mbps 
+    ** FES = : 10 Mbps 
+    ** Half duplex
+    ** Automatic CRC padding/stripping
+    */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,
+                                regVal |
+                                TMVH_LIPP6100ETH_CONFIG_ACS_VAL);
+
+    /* Default values for PHY at address 2, MDIO clock is selected in 
+    ** GMII address register 
+    */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,
+                             regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR) & 
+                    TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR);
+
+
+    regVal |= (pPhyinfo->phyAddr << TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS) |
+                  (pPhyinfo->clkCsrVal << TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,
+                                regVal);    
+
+    /* Flow control settings 
+    ** Enable transmit and receive flow control in half duplex mode
+    */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,
+                                TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL |
+                                TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL);
+
+    /* Address filtering: Accept broadcast & Unicast packets. 
+    ** No special settings required 
+    */
+    /* All interrupts are disabled after reset */
+
+    return (TM_OK);
+   
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_Deinit:
+** 
+**  DESCRIPTION: This function deinitializes the Ethernet device. 
+**                      This function will perform following actions
+**                      Disables DMA tx & rx
+**                      Disables GMAC tx & rx state machines
+**                      Resets the GMAC
+** 
+**  RETURN:        TM_OK
+**  
+**  NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Deinit(
+    tmUnitSelect_t  ethUnitId   
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);        
+
+    /* Disable DMA transmission & reception */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                               regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) &
+                    TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                regVal);
+
+    /* Disable GMAC transmission & reception state machines */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                    TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    /* Reset the GMAC */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    regVal |=TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    return (TM_OK);
+
+}    
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_GetPowerState
+**
+** DESCRIPTION: Function will get the existing power state of the device
+**
+** RETURN       : TM_OK
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetPowerState(
+    tmUnitSelect_t    ethUnitId ,
+    ptmPowerState_t pEthPowerState
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+    regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK;
+
+    *pEthPowerState = ( (regVal == TMVH_LIPP6100ETH_POWER_OFF ) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+    
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetPowerState
+**
+** DESCRIPTION: Function will set the power state to the device to the specified value
+**
+** RETURN:      TM_OK
+**
+** NOTES:       Set the Power state to power down will do the following things
+**                  1. Disable the both the transmitt and receive DMA Manager
+**                  2. set the Power down bit by writing to the power down register
+**                  Set the power state of the device to the power up will do the following things
+**                  1. Reset the power down bit in the power down register
+**                  2. Reenable the both the transmitt and receive  channels
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t	
+tmhwLIPP6100Eth_SetPowerState(
+    tmUnitSelect_t   ethUnitId  , 
+    tmPowerState_t  ethPowerState
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+    regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK;
+
+    if( ((ethPowerState == tmPowerOff) && (regVal == TMVH_LIPP6100ETH_POWER_ON)) || 
+        ((ethPowerState == tmPowerOn) && (regVal == TMVH_LIPP6100ETH_POWER_OFF)) )
+    {
+
+        if(ethPowerState == tmPowerOff)
+        {
+            /* Disable DMA Transmission and reception */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                       regVal);
+
+            regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) &
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                        regVal);
+
+            /* Disable GMAC transmission & reception state machines */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            /* Turn off the port power */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+            regVal |=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_VAL;
+
+        }
+        else
+        {
+
+            /* Enable GMAC transmission & reception state machines */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            regVal |=(TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL|
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            /* Enable DMA Transmission and reception */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                       regVal);
+            regVal |= (TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL|
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                        regVal);
+
+            /* Clear the port power bit */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+            regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_CLR;
+           
+        }
+
+        TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);          
+
+    }
+
+    return (TM_OK);
+
+}   
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_WoLConfig
+**
+** DESCRIPTION: This function will set the wakeup procedure, required before going down 
+**                     to power down mode.
+**
+** RETURN:         TM_OK 
+**
+** NOTES:       See tmhwLIPP6100Eth_WkupCfg_t structure.
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t	
+tmhwLIPP6100Eth_WoLConfig(
+    tmUnitSelect_t   ethUnitId  , 
+    tmhwLIPP6100Eth_WkupCfg_Kpk_t  pWolConfig
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal = 0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pWolConfig->rstRegptr == True)
+    {
+        TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,TMVH_LIPP6100ETH_WKUP_FMFILTER_RSTREG_VAL);
+    }
+
+    if(pWolConfig->globalUnicastEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_PWRMGMT_GU_VAL;        
+    }
+
+    if(pWolConfig->magicPktEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_PWRMGMT_MAGIC_PKT_EN_VAL;
+    }
+
+    if(pWolConfig->wkupFrameEn == True)
+    {
+         regVal |= TMVH_LIPP6100ETH_PWRMGMT_WKUP_FM_EN_VAL;        
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);    
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[0]);
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[1]);   
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[2]);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[3]);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCommand);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterOffset);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCrcVal6);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCrcVal7);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetWakeupStatus
+**
+** DESCRIPTION: This function is used to find the cause of wakeup event when in power down
+**                     mode.
+**                     
+** RETURN:         TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetWakeupStatus(
+    tmUnitSelect_t       ethUnitId ,    
+    pUInt32                  pRegVal
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,*pRegVal);
+
+    return(TM_OK);    
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetConfig
+**
+** DESCRIPTION: This function will configure the general Ethernet configuration 
+**                     related Ethernet and PHY device with the parameters passed
+**
+** RETURN:         TM_OK 
+**
+** NOTES:       See tmhwLIPP6100Eth_DevConfig_t structure.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetConfig(
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+
+    if(pEthConfig->txConfiginfo == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL ;
+    }
+
+    if(pEthConfig->wdTimer == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_WD_VAL ;
+    }
+
+    if(pEthConfig->jabberTimer == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_JD_VAL;
+    }
+
+    if((pEthConfig->miiSelect == False ) && (pEthConfig->frameBurst == True)) 
+    {
+        regVal |=TMVH_LIPP6100ETH_CONFIG_FBE_VAL;
+    }
+
+    if (pEthConfig->jumboFrame == True)
+    {
+        regVal |=TMVH_LIPP6100ETH_CONFIG_JFE_VAL;
+    }
+
+    if (pEthConfig->disableCS == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DISCS_VAL;
+    }
+
+    regVal |= (UInt32)(pEthConfig->ifg << TMVH_LIPP6100ETH_CONFIG_IFG_POS);    
+
+    
+    if(pEthConfig->miiSelect == True)
+    {
+        /* Select the GMII or MII interface */
+        regVal |= TMVH_LIPP6100ETH_CONFIG_MII_VAL;
+
+        if(pEthConfig->speed100Mbps == True)
+        {
+            regVal |= TMVH_LIPP6100ETH_CONFIG_FES_VAL;
+        }
+    }
+    else
+        regVal |= TMVH_LIPP6100ETH_CONFIG_GMII_VAL;
+
+    if(pEthConfig->disableReceiveOwn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL;
+    }
+
+    if(pEthConfig->duplexMode == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL;
+    }
+
+    if(pEthConfig->ipChecksumOffload == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL;
+    }
+
+    if(pEthConfig->disableRetry == True)
+    {
+      regVal |= TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL;
+    }
+    
+    if(pEthConfig->autoPadCRC == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_ACS_VAL;
+    }
+
+    regVal |= (UInt32)(pEthConfig->backOffLim << TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS);
+
+    if(pEthConfig->deferralCheck == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL;
+    }
+
+    /* Write regVal to MAC config register */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    /* Write the PHY adress & Select MDC clock frequency in GMII address register */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR) &    
+                    TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR);
+
+    regVal |= pEthConfig->phyAddress << TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS;
+    regVal |= (UInt32)(pEthConfig->clockSelect << TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+        
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    /* Set the station Address */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET,
+                                pEthConfig->station.adrHigh); 
+    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET,
+                                pEthConfig->station.adrLow); 
+
+    return (TM_OK);
+    
+}    
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_GetConfig
+** 
+** DESCRIPTION: This function will get the present configure of the Ethernet and PHY device
+** RETURN:         TM_OK 
+** 
+** NOTES:       See ptmhwLIPP6100Eth_DevConfig_t structure.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetConfig(
+    tmUnitSelect_t                      ethUnitId ,    
+    ptmhwLIPP6100Eth_DevConfig_t    pEthConfig
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    pEthConfig->txConfiginfo = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL) > 0) ? True : False);
+
+    pEthConfig->wdTimer = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_WD_VAL) > 0) ? True : False);
+
+    pEthConfig->txConfiginfo = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL) > 0) ? True : False);    
+
+    pEthConfig->jabberTimer = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_JD_VAL) > 0) ? True : False);
+    
+    pEthConfig->frameBurst = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_FBE_VAL) > 0) ? True : False);
+    pEthConfig->jumboFrame = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_JFE_VAL) > 0) ? True : False);
+
+    pEthConfig->ifg = (tmhwLIPP6100Eth_IFG_t) ((regVal &TMVH_LIPP6100ETH_CONFIG_IFG_MSK) >>
+                                TMVH_LIPP6100ETH_CONFIG_IFG_POS);
+
+    pEthConfig->disableCS = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DISCS_VAL) > 0) ? True : False);        
+
+    pEthConfig->miiSelect = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_MII_VAL) > 0) ? True : False);
+    pEthConfig->speed100Mbps = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_FES_VAL) > 0) ? True : False);
+    
+    pEthConfig->duplexMode = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL) > 0) ? True : False);
+    pEthConfig->disableReceiveOwn = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL) > 0) ? True : False);
+    pEthConfig->ipChecksumOffload = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL) > 0) ? True : False);
+    pEthConfig->disableRetry = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL) > 0) ? True : False);
+    pEthConfig->linkup = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_LNKUP_VAL) > 0) ? True : False);
+    pEthConfig->autoPadCRC = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_ACS_VAL) > 0) ? True : False);
+    pEthConfig->backOffLim = (tmhwLIPP6100Eth_BackOffLimit_t) ((regVal & TMVH_LIPP6100ETH_CONFIG_BACKOFF_MSK) >> 
+                                            TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS);
+
+    pEthConfig->deferralCheck = (Bool)(regVal & TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL);
+
+    /* Get the MDC clock value */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    pEthConfig->clockSelect = (tmhwLIPP6100Eth_ClkDiv_t) ((regVal & TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_MSK) >> 
+                                            TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+
+    pEthConfig->phyAddress = (regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_MSK) >>TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS;
+
+    /* Read the station address into the structure member */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET,regVal);
+    
+    pEthConfig->station.adrHigh = regVal & TMVH_LIPP6100ETH_ADDR0_HIGH_REG_MSK;
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET,regVal);
+    
+    pEthConfig->station.adrLow = regVal;
+
+    return (TM_OK);
+    
+}    
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_IntGetStatus
+**
+** DESCRIPTION: The function returns the DMA interrupt status register value
+**
+** RETURN       :  TM_OK 
+** NOTES        :  
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntGetStatus (
+    tmUnitSelect_t   ethUnitId ,    
+    ptmhwLIPP6100Eth_Int_t pIntStat
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Read the DMA interrupt status register */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET,pIntStat->dmaIntVal);
+
+    /* Read the MMC, PMT, PCS, RGMII interrupt status */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_STATUS_REG_OFFSET,pIntStat->gmacIntVal);    
+
+    return (TM_OK);
+
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_IntEnable
+**
+** DESCRIPTION: Read the current interrupt register values & OR the value passed
+**
+** RETURN       : TM_OK 
+** NOTES        :       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntEnable (
+    tmUnitSelect_t              ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntEn
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Writing a 1 in the DMA interrupt enable register enables the interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);
+    
+    regVal |=pIntEn->dmaIntVal;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);    
+
+    /* Clearing the corresponding bit in the Interrupt mask register enables the interrupt, 
+    ** if previously masked 
+    */    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);
+
+    regVal &= ~(pIntEn->gmacIntVal);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);     
+
+    return (TM_OK);
+    
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwEthGmacIntDisable
+**
+** DESCRIPTION: This function will Disable the sources of interrupt(s) for DMA
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntDisable (
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntDis
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Writing a 0, disables the interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);
+
+    regVal &=~(pIntDis->dmaIntVal);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);    
+
+    /* Writing a 1 masks the corresponding interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);
+
+    regVal |=pIntDis->gmacIntVal;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);        
+
+    return (TM_OK);
+
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_IntClear
+**
+** DESCRIPTION: This function will clear the sources of interrupt(s) for DMA
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntClear (
+    tmUnitSelect_t              ethUnitId ,    
+    UInt32                         ethIntstatus
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET,ethIntstatus);
+
+    return (TM_OK);
+}    
+
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     ttmhwLIPP6100Eth_PerfectAdrSetConfig
+**
+** DESCRIPTION: This function Configures the perfect address filtering register 
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           There are 31 perfect address filter registers available. The register number (1-31)
+**                       is passed as the paramter to this function.
+**                       Station address register is not part of these 1-31 registers
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrSetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,
+    tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig
+)
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pAdrConfig->addressEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_ADDR_ENABLE_VAL;    
+    }
+
+    if(pAdrConfig->srcAddrCmp == True)
+    {
+        regVal |=TMVH_LIPP6100ETH_ADDR_SA_EN_VAL;    
+    }
+
+    /* Set the mask value */
+    regVal |= pAdrConfig->addrMask << TMVH_LIPP6100ETH_ADDR_MBC_POS;
+
+    regVal |= (pAdrConfig->macAddrHigh & TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK);
+
+    if (regNum < 16 )
+    {
+        /* Write into the perfect address High Register */        
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),regVal);        
+
+        /* Write into the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),pAdrConfig->macAddrlow);                
+    }
+    else
+    {
+        /* Write into the perfect address High Register */        
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),regVal);        
+
+        /* Write into the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),pAdrConfig->macAddrlow);                    
+    }
+
+    return (TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_PerfectAdrGetConfig
+**
+** DESCRIPTION: This function gets the current values of perfect address filtering register 
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           There are 32 perfect filter registers available. The register number (0-31)
+**                       is passed as the paramter to this function
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,    
+    ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig
+)
+{
+
+    UInt32 pEthRegs;
+    UInt32 regHigh=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if (regNum < 16 )
+    {
+        /* Read from the High Register */        
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),regHigh);        
+
+        /*Read from the perfect address low Register */            
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),pAdrConfig->macAddrlow);                
+    }
+    else
+    {
+        /* Read from the perfect address High Register */        
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),regHigh);        
+
+        /* Read from the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),pAdrConfig->macAddrlow);                    
+    }
+
+    pAdrConfig->addressEnable = (Bool)(((regHigh & TMVH_LIPP6100ETH_ADDR_ENABLE_VAL ) > 0) ? True: False); 
+
+    pAdrConfig->addrMask = (regHigh & TMVH_LIPP6100ETH_ADDR_MBC_MSK) >> 
+                                        TMVH_LIPP6100ETH_ADDR_MBC_POS;
+    
+    pAdrConfig->macAddrHigh = regHigh & TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK;
+
+    pAdrConfig->srcAddrCmp = (Bool) ( ((regHigh & TMVH_LIPP6100ETH_ADDR_SA_EN_VAL ) > 0) ? True: False); 
+
+    return (TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FilterSetConfig
+**
+** DESCRIPTION: This function configures the filters for incoming frames.
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterSetConfig(
+    tmUnitSelect_t                          ethUnitId , 
+    tmhwLIPP6100Eth_FilterConfig_Kpk_t  pFilterConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+    
+    if(pFilterConfig->receiveAllEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL;    
+    }
+
+    if(pFilterConfig->passAllFrames == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_PR_VAL;
+    }                
+
+    if(pFilterConfig->srcAdrFilterEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_SAF_VAL;     
+    }    
+
+    if(pFilterConfig->srcAdrInvFilterEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL;     
+    }    
+
+    if(pFilterConfig->destAdrInvFiltering == True)
+    {
+         regVal |= TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL;   
+    }        
+
+    if(pFilterConfig->filterBroadCastFrames == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_DBF_VAL;     
+    }        
+
+    if(pFilterConfig->recvAllMulticast == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_PM_VAL;    
+    }        
+
+    if(pFilterConfig->hashMulticastEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HMC_VAL;     
+    }        
+    
+    if(pFilterConfig->hashUnicastEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HUC_VAL;    
+    }        
+
+     /* Enable hash filtering as well as perfect address filtering simultaneously on a given frame.
+     i.e. Frame is dropped only when it fails the hash filtering as well as perfect address filtering.
+     To enable this bit 10 of Filter Frame Register has to be set. Also Hash Unicast & Hash Multicast
+     bits in Filter Frame Register should be set. The bit 10 when set ensures that perfect address
+     filtering is enabled for both Unicast as well as Multicast frames (irrespective of value of Hash
+     Unicast & Hash Multicast bits).
+     */
+    if(pFilterConfig->hashNPerfectFilterEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL;
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HMC_VAL;             
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HUC_VAL;            
+    }
+
+    regVal |= (UInt32)(pFilterConfig->pauseSetting << TMVH_LIPP6100ETH_FMFLTR_PCF_POS);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET,regVal);
+
+    return (TM_OK);    
+
+}
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FilterGetConfig
+**
+** DESCRIPTION: This function gets the current configuration of filters
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    ptmhwLIPP6100Eth_FilterConfig_t        pFilterConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET,regVal);
+
+    pFilterConfig->receiveAllEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL) > 0 )? True:False);
+    pFilterConfig->srcAdrFilterEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_SAF_VAL) > 0) ? True:False);
+    pFilterConfig->srcAdrInvFilterEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL) > 0) ? True:False);
+    pFilterConfig->hashNPerfectFilterEn = (Bool) (((regVal & TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL) > 0) ? True:False);
+    pFilterConfig->filterBroadCastFrames = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_DBF_VAL) > 0) ? True:False);    
+    pFilterConfig->recvAllMulticast = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_PM_VAL) > 0) ? True:False);    
+    pFilterConfig->destAdrInvFiltering = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL) > 0) ? True:False);    
+    pFilterConfig->hashMulticastEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_HMC_VAL) > 0) ? True:False);    
+    pFilterConfig->hashUnicastEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_HUC_VAL) > 0) ? True:False);    
+    pFilterConfig->passAllFrames = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_PR_VAL) > 0) ? True:False);    
+    pFilterConfig->pauseSetting = (tmhwLIPP6100Eth_PCF_t) ((regVal & TMVH_LIPP6100ETH_FMFLTR_PCF_MSK) >>
+                                                TMVH_LIPP6100ETH_FMFLTR_PCF_POS);
+    return (TM_OK);    
+    
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_HashFilterSetConfig
+**
+** DESCRIPTION: This function will configure the Hash Filter Table.
+**
+** RETURN:      TM_OK 
+**
+** NOTES:        Hash filtering (Multicast/Unicast) must be enabled by calling the function 
+**                   tmhwLIPP6100Eth_FilterSetConfig()
+** 
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterSetConfig(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_HashFilter_Kpk_t    pHashConfig
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET,
+                                pHashConfig->hashFilterH);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET,
+                                pHashConfig->hashFilterL);
+    
+    return (TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_HashFilterGetConfig
+**
+** DESCRIPTION: Function will get the present Hash Filter Table configuration.
+**
+** RETURN:      TM_OK 
+**                  
+** NOTES:        
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterGetConfig(
+    tmUnitSelect_t                                ethUnitId ,
+    ptmhwLIPP6100Eth_HashFilter_t          pHashConfig
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET,
+                                pHashConfig->hashFilterH);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET,
+                                pHashConfig->hashFilterL);
+    
+    return (TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GmacEnableDisable
+**
+** DESCRIPTION: Enables/Disables the GMAC state machine. 
+**
+** RETURN:      TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_GmacEnableDisable (
+    tmUnitSelect_t                              ethUnitId,
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t            pEndir    
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+        
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    if(pEndir->dirFlag == tmhwLIPP6100Eth_Dir_TxRx)
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL | 
+                          TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL;
+        }
+        else
+        {
+            regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);        
+        }
+
+    }
+    else if(pEndir->dirFlag == tmhwLIPP6100Eth_Dir_Tx)
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+             regVal |= TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL;
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR;        
+        }
+        
+    }
+    else
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+             regVal |= TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL;
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR;        
+        }
+
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_LpbkEnableDisable
+**
+** DESCRIPTION: Function will set the hardware in the loop back mode at the MAC interface
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_LpbkEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t     enableDisable
+    ) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    if(enableDisable == tmhwLIPP6100Eth_Enable)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_LPBK_VAL ;
+    }
+    else
+    {
+        regVal &=TMVH_LIPP6100ETH_CONFIG_LPBK_CLR;
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);    
+
+    return (TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_FlowCtrlSetConfig
+**
+** DESCRIPTION: Configures the flow control register.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlSetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t        pFlowCtrlCfg
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    regVal |= (UInt32)pFlowCtrlCfg->pauseTime << TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS;
+
+    if (pFlowCtrlCfg->zeroQuanta == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL;
+    }
+
+    regVal |= (UInt32)pFlowCtrlCfg->pauseLowThreshold << TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS;
+
+    if (pFlowCtrlCfg->unicastPsDetect == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL;
+    }
+
+    if (pFlowCtrlCfg->rxFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL;
+    }
+
+    if (pFlowCtrlCfg->txFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL;
+    }    
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);        
+
+    return(TM_OK);    
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlGetConfig
+**
+** DESCRIPTION: Gets the configured values in the the flow control register.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlGetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    ptmhwLIPP6100Eth_FlowCtrlConfig_t        pFlowCtrlCfg
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);
+
+    pFlowCtrlCfg->pauseLowThreshold = (tmhwLIPP6100Eth_PLT_t) ((regVal & TMVH_LIPP6100ETH_FLOWCTRL_PLT_MSK) >>
+                                                    TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS);
+
+    pFlowCtrlCfg->zeroQuanta = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL) >0) ? True: False);
+    
+    pFlowCtrlCfg->pauseTime = (regVal & TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_MSK) >> 
+                                                    TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS;
+
+    pFlowCtrlCfg->zeroQuanta = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL) >0) ? True: False);
+
+    pFlowCtrlCfg->rxFlowCtrlEn = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL) >0) ? True: False);
+    
+    pFlowCtrlCfg->txFlowCtrlEn = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL) > 0) ? True:False); 
+    
+    pFlowCtrlCfg->unicastPsDetect = (Bool)(((regVal &TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL) > 0) ? True:False);
+
+    return(TM_OK);    
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlEnableDisable
+**
+** DESCRIPTION: Enables flow control in Full Duplex and Half duplex modes
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlEnableDisable(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t enableDisable
+) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);    
+
+    if(enableDisable == tmhwLIPP6100Eth_Disable) 
+    {
+        regVal &=TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_CLR;
+    }
+    else
+    {
+        regVal |=TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL;
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlStatus
+**
+** DESCRIPTION: Gets the staus of FCA/BP bit 
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlStatus(
+    tmUnitSelect_t                          ethUnitId,
+    pUInt32                                    pRegVal
+) 
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,*pRegVal);    
+
+    return(TM_OK);
+
+}
+
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaConfig
+**
+** DESCRIPTION: This function does the general configuration of DMA
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaConfig(
+    tmUnitSelect_t                               ethUnitId ,
+    tmhwLIPP6100Eth_DmaCfg_Kpk_t        pDmaConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* General DMA configuration */
+    if(pDmaConfig->fixedBurstEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_FB_VAL; 
+    }
+
+    if(pDmaConfig->pBL4xmode == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_4XPBL_VAL; 
+    }
+
+    if(pDmaConfig->differentPBL == True)
+    {
+        /* Separate PBL for reception */
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_SEPPBL_VAL; 
+        regVal |= (UInt32)pDmaConfig->rxPBL << TMVH_LIPP6100ETH_BUS_MODE_RX_PBL_POS;        
+    }
+
+    regVal |= (UInt32)pDmaConfig->burstLen << TMVH_LIPP6100ETH_BUS_MODE_PBL_POS;
+    
+    regVal |= pDmaConfig->descSkipLen << TMVH_LIPP6100ETH_BUS_MODE_DSL_POS;
+
+    if(pDmaConfig->dmaArbitration == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_DA_VAL;
+    }
+    else
+    {
+        regVal |= (UInt32)pDmaConfig->priority << TMVH_LIPP6100ETH_BUS_MODE_PR_POS; 
+    }
+
+    if(pDmaConfig->addrAlignedBtsEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_AAL_VAL;
+    }
+
+    if(pDmaConfig->enableAltDescSize == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_EN_ALTDESC;
+    }    
+
+    /* Write to Bus mode register */
+     TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    regVal =0;
+
+    if(pDmaConfig->disableFrameFlush == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FRM_FLUSH_DIS_VAL; 
+    }
+
+    if(pDmaConfig->storeNforwardEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_SF_VAL;
+    }
+
+    if(pDmaConfig->rxStoreNforwardEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RSF_VAL;
+    }
+
+    if(pDmaConfig->recvTcpIpErrFrms == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_DT_VAL;
+    }
+
+    if(pDmaConfig->txSecondFrameEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_OSF_VAL;
+    }
+
+    regVal |= (UInt32) (pDmaConfig->txThreshold << TMVH_LIPP6100ETH_OPERN_MODE_TTC_POS);
+
+    regVal |= (UInt32) (pDmaConfig->rxThreshold << TMVH_LIPP6100ETH_OPERN_MODE_RTC_POS);
+
+    /* Receive side configuration */
+    if(pDmaConfig->hwFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_EFC_VAL;
+    }
+
+    if(pDmaConfig->errFramesEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FEF_VAL;
+    }
+    
+    if(pDmaConfig->underSizedGdFramesEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FUF_VAL;
+    }
+
+    if(pDmaConfig->actRxThreshold > tmhwLIPP6100Eth_RFA_4K)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RFA2_VAL;
+    }
+
+    regVal |= (UInt32)((((UInt32)pDmaConfig->actRxThreshold) & TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR) << 
+                    TMVH_LIPP6100ETH_OPERN_MODE_RFA_POS);
+
+    if(pDmaConfig->deactRxThreshold > tmhwLIPP6100Eth_RFD_4K)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RFD2_VAL;
+    }
+
+    regVal |= (UInt32) ((((UInt32)pDmaConfig->deactRxThreshold) & TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR) << 
+                    TMVH_LIPP6100ETH_OPERN_MODE_RFD_POS);
+
+    /* Write to Operation mode register */
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);    
+
+    /* Write the Transmit descriptor base address */
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXDESC_LISTADDR_REG_OFFSET,
+                                pDmaConfig->txDescListBaseAdr);
+
+    /* Write the receive descriptor base address */    
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RXDESC_LISTADDR_REG_OFFSET,
+                                pDmaConfig->rxDescListBaseAdr);
+
+    return(TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaFlushTxFifo
+**
+** DESCRIPTION: This function flushes the transmit fifo
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaFlushTxFifo(
+    tmUnitSelect_t  ethUnitId 
+) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);        
+
+    regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FTF_VAL;
+
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);            
+
+    return(TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaEnableDisable
+**
+** DESCRIPTION: This function enables/disables the DMA in Tx & Rx directions
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaEnableDisable(
+    tmUnitSelect_t                      ethUnitId, 
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t    pTxfr
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);        
+
+    if(pTxfr->dirFlag == tmhwLIPP6100Eth_Dir_TxRx) 
+    {
+    
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= (TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL |
+                           TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL);
+        }
+        else
+        {
+            /* If it is disable, clear the tx enable & rx enable bits */
+            regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+        }
+
+    }
+    else if(pTxfr->dirFlag == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL;                    
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR;
+        }
+
+    }
+    else
+    {
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL;                    
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR;
+        }
+
+    }
+
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);            
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaPollDesc
+**
+** DESCRIPTION: This function writes a dummy value into either Tx or Rx or both the registers
+**                     depending on the 'dir' value passed. This reenables DMA if it is suspended. 
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaPollDesc   (
+    tmUnitSelect_t          ethUnitId,
+    tmhwLIPP6100Eth_Dir_t       dir
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(dir == tmhwLIPP6100Eth_Dir_Tx)
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET,0xFF);        
+    }
+    else if (dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET,0xFF);            
+    }
+    else
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET,0xFF);            
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET,0xFF);            
+    }
+
+    return(TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaGetCurrentHostRegs
+**
+** DESCRIPTION: This function returns all the host register values.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetCurrentHostRegs(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaHostRegs_t     pDmaHostReg       
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_TX_DESC_REG_OFFSET,
+                                pDmaHostReg->curHostTxDesc);       
+    
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_RX_DESC_REG_OFFSET,
+                                pDmaHostReg->curHostRxDesc);       
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_TXBUFADR_REG_OFFSET,
+                                pDmaHostReg->curHostTxBufferAdr);       
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_RXBUFADR_REG_OFFSET,
+                                pDmaHostReg->curHostRxBufferAdr);       
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaGetMissedFrameCount
+**
+** DESCRIPTION: This function returns the number of missed frames during reception 
+**                     due to Receive FIFO overflow or due to host buffer being unavailable
+**                     This API can be used for debug purposes
+**
+** RETURN:        TM_OK 
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetMissedFrameCount(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET,
+                                regVal);       
+
+    pMissedFrmCnt->fifoOverflowCnt = (regVal & TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_MSK) >>
+                                                       TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_POS;
+
+    pMissedFrmCnt->buffNotAvlCnt = (regVal & TMVH_LIPP6100ETH_MISSFR_BUF_CNT_MSK);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaMissedFrameCounterClear
+**
+** DESCRIPTION: This function clears the missed frame counter values
+**                      This API can be used for debug purposes
+**
+** RETURN:        TM_OK 
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaMissedFrameCounterClear(
+    tmUnitSelect_t                                 ethUnitId
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET,0x1fffffff);       
+
+    return(TM_OK);
+}
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCConfig
+**
+** DESCRIPTION: Configures the behaviour of MAC statistics counters
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_MMCConfig(
+    tmUnitSelect_t                      ethUnitId,
+    tmhwLIPP6100Eth_MmcCtrl_Kpk_t           pCtrlConfig
+    
+)
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pCtrlConfig->freezeCntrs == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL;
+    }
+
+    if(pCtrlConfig->resetOnRdEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;
+    }
+
+    if(pCtrlConfig->rollOverDisable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL;
+    }
+
+    if(pCtrlConfig->resetCounters == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_CNTR_RESET_VAL;
+    }
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)     
+    #if ( IPVERSION_34_1_A)
+    if (pCtrlConfig->resetCounters == True )
+    {
+        UInt8 i;
+        for(i=0;i < 28;i++)
+        {
+            gtmhwLIPP6100Eth_ActRegVal[i]=0;
+        }
+    }
+    #endif    
+#endif
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET, regVal);
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntStatus
+**
+** DESCRIPTION: This function gets the current interrupt status on the MMC counters in Tx 
+** and Rx direction
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntStatus(
+    tmUnitSelect_t                            ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcIntStat_t   pMmcStat
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcStat->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RX_REG_OFFSET,pMmcStat->intStat);
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INT_REG_OFFSET,pMmcStat->rxCsumStatus);
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TX_REG_OFFSET,pMmcStat->intStat);    
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntEnable
+**
+** DESCRIPTION: This function enables MMC interrupts. The value passed is ORed with the 
+**                      already configured interrupts
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntEnable(
+    tmUnitSelect_t                           ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t  pMmcIntEn
+    )
+{
+
+    UInt32 pRegs;
+    UInt32 regVal;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcIntEn->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regVal);
+
+        regVal &=~(pMmcIntEn->intrVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regVal);
+
+        /* Checksum offload interrupt mask register */        
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regVal);
+
+        regVal &= ~(pMmcIntEn->rxCsumIntVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regVal);
+
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regVal);
+
+        regVal &=~(pMmcIntEn->intrVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regVal);
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntDisable
+**
+** DESCRIPTION: This function disables the MMC interrupts. Only the interrupts which 
+**                      needs to be disabled are cleared.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntDisable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntDis
+    )
+{
+
+    UInt32 pRegs;
+    UInt32 regValue;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcIntDis->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->intrVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regValue);
+
+        /* Checksum offload interrupt mask register */        
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->rxCsumIntVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regValue);
+
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->intrVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regValue);
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCCountersRead
+**
+** DESCRIPTION: This function reads the MMC counter and returns the value. 
+**               The counter to be read is passed as a parameter to this function
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+  
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCCountersRead(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg
+    )
+{
+    UInt32 pRegs;
+
+#if ( IPVERSION_34_1_A)
+    UInt32 regVal;
+#endif
+
+    pRegs = GET_BASE(ethUnitId);
+
+    switch(pMmcReg->regToRd)
+    {
+        case TMHW_LIPP6100ETH_TX_OCTET_CNT_GB:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXOCTET_CNT_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);
+                break;
+            
+        case TMHW_LIPP6100ETH_TX_FRAME_CNT_GB :
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXFRAME_CNT_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;
+            
+        case TMHW_LIPP6100ETH_TX_BRDCST_CNT_G:
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXBRDCST_CNT_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;
+
+        case TMHW_LIPP6100ETH_TX_MULTCST_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXMULTCST_CNT_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;
+
+        case TMHW_LIPP6100ETH_TX_64_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX64_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+
+        case TMHW_LIPP6100ETH_TX_65TO127_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX65TO127_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+
+        case TMHW_LIPP6100ETH_TX_128TO255_CNT_GB:    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX128TO255_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_256TO511_CNT_GB:    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX256TO511_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB:        
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX512TO1023_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB:            
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX1024TOMAX_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+                
+        case TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB:                
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_UNICAST_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+                
+        case TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB:                
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_MULTCST_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB:                
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_BRDCST_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT:                    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_UNNDERFLOW_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G:                    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_SINGLCOL_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_MULTICOL_COL_G:                        
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_MULTICOL_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_DEFERRED_CNT:                            
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_DEFERRED_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_LATECOL_CNT:                                
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_LATECOL_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT:                                    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_EXCESSCOL_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT:    
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_CARRIER_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_OCTET_CNT_G:        
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_OCTET_CNT_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                    
+                
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_FRAME_CNT_G:            
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_FRM_CNT_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT:                
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_EXCESS_DEF_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+        case TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT:                    
+            
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_PAUSE_FRAMES_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                
+            
+        case TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G:                        
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_VLAN_FRAMES_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+        case TMHW_LIPP6100ETH_RX_FRM_CNT_GB:
+            
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXFRM_CNT_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+           
+            break;                            
+            
+        case TMHW_LIPP6100ETH_RX_OCTET_CNT_GB:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);  
+
+            break;                            
+            
+        case TMHW_LIPP6100ETH_RX_OCTET_CNT_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);  
+
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_BRDCSTF_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_MULTCSTF_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_CRC_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_CRC_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_ALIGNMT_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_RUNT_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_JABBER_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_UNDERSIZE_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;                            
+
+        case TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_OVERSIZE_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_64_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_64_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_65TO127_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_65TO127_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_128TO255_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_128TO255_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_256TO511_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_256TO511_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_512TO1023_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_1024TOMAX_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_UNICAST_CNT_G:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_UNICAST_G_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_LEN_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_LEN_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_OUTOFRANGE_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_PAUSE_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_PAUSE_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_FIFO_OVERFLOW_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_VLAN_FRAMES_GB_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT:
+
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_WATCHDOG_ERR_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            break;            
+
+        /* IPC counters */
+        case TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G:
+
+            #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET,0);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif            
+
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT:
+
+            #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET,1);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT:
+
+            #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET,2);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif                
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT:
+
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET,3);
+            #else
+              TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET,\
+              pMmcReg->mmcRegVal);
+            #endif
+
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT:
+
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET,4);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET,5);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT:
+
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET,6);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET,7);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET,8);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET,9);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET,10);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif                
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET,11);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET,12);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif                
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT:
+           #if ( IPVERSION_34_1_A)
+            pMmcReg->mmcRegVal = \
+            compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET,13);
+            #else
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET,\
+            pMmcReg->mmcRegVal);
+            #endif
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_GD_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);               
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_HDRERR_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_OCTECTS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_GD_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);     
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_HDRERR_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_UDP_OCTETS_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_GD_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_ERR_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_TCP_OCTETS_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TCP_GD_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS:
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TCP_ERR_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_ICMP_GD_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+            
+            break;            
+
+        case TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS:
+
+            MMC_RST_ON_RD_SAVE(pRegs,regVal);
+            TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_ICMP_ERR_OCTETS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+            MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+
+            break;            
+
+        default:
+            break;
+
+    }
+
+    return(TM_OK);
+
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_VLAN)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetVLANTag
+**
+** DESCRIPTION: This function sets the VLAN tag value which is used for comparison with the
+**                     received VLAN frames.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    regValue &=TMVH_LIPP6100ETH_VLANTAG_MASK;
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_GetVLANTag
+**
+** DESCRIPTION: This function returns the VLAN tag value 
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET,*pRegValue);    
+    
+    *pRegValue &=TMVH_LIPP6100ETH_VLANTAG_MASK;
+
+    return(TM_OK);
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_GetTsCtrlVal
+**
+** DESCRIPTION: This function returns the control value of the time stamp registers.
+**
+**                         Below macros can be used to check if a corresponding bit is set/reset in 
+**                         the register: 
+**                          TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+**
+** RETURN :           TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetTsCtrlVal(
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET,*pRegValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_SetTsCtrl
+**
+** DESCRIPTION: This function enables/disables certain features of time stamp operation,
+**                         depending on the value passed.
+**
+**                         Parameter to this function can be any of the below macros
+**
+**                          TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsCtrl(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsSubSecInc
+**
+** DESCRIPTION:  API to set the value of sub-second increment register
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsSubSecInc(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_SUB_SECOND_INCR_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsAddend
+**
+** DESCRIPTION:  This API is used to set Time Stamp Addend value. This is used only when system 
+**                          time is configured for Fine Update mode.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsAddend(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                       regValue
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_ADDEND_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetSysTs
+**
+** DESCRIPTION:  This API fetches the current system time stamp value
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSysTs(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+)
+{
+
+    UInt32 regBase;
+
+    regBase = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(regBase+TMVH_LIPP6100ETH_TS_HIGH_REG_OFFSET,pRegs->highVal);    
+    TMVH_GEN_READ(regBase+TMVH_LIPP6100ETH_TS_LOW_REG_OFFSET,pRegs->lowVal);        
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsUpdate
+**
+** DESCRIPTION:  This API is used to set the values of Time Stamp update registers & the parameter
+**                          passed to this function also indicates if the value is to be added to the system time
+**                          or subracted from the system time.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsUpdate(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate   
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if(pUpdate->addSub == tmhwLIPP6100Eth_SubFromSysTime)
+    {
+        /*  Subtract this value from system time */    
+        pUpdate->updateReg.lowVal |= TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL;
+    }
+    else
+    {
+        /* Add this value to system time */
+        pUpdate->updateReg.lowVal &= (~TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL);            
+    }
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_HIGH_UPDATE_REG_OFFSET, \
+                                        pUpdate->updateReg.highVal);    
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_LOW_UPDATE_REG_OFFSET, \
+                                        pUpdate->updateReg.lowVal);        
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsTgtTime
+**
+** DESCRIPTION:  This API is used to schedule an interrupt event when the system time exceeds the
+**                          value programmed in the target registers.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsTgtTime(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+)
+{
+
+    UInt32 regBase;
+
+    regBase = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(regBase+TMVH_LIPP6100ETH_TS_TGT_TIME_HIGH_REG_OFFSET, \
+                                        pRegs->highVal);    
+    TMVH_GEN_WRITE(regBase+TMVH_LIPP6100ETH_TS_TGT_TIME_LOW_REG_OFFSET, \
+                                        pRegs->lowVal);        
+
+    return(TM_OK);
+
+}
+#endif /* End of timestamp routines */
+
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+     #if ( IPVERSION_34_1_A)
+
+UInt32  compute_ipc_value (UInt32 base,UInt32 regOffset,UInt32 index)
+{
+        UInt32 temp, org;
+        UInt32 sum;
+        UInt32 regVal;
+
+        /* Read the control & set clear on read */
+        TMVH_GEN_READ(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,org);
+
+        temp = org;
+
+        if((org & TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL) &&
+            ( (org & TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL)==0))
+        {
+
+            if(org & TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL)
+            {
+                return(gtmhwLIPP6100Eth_ActRegVal[index]);
+            }
+
+            /* Enable read clear */
+            temp |= TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;
+
+            TMVH_GEN_WRITE(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,temp); 
+
+            TMVH_GEN_READ(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,temp);
+
+            /* If you are reading after previously returning all Fs, reset the value to zero */            
+            if(gtmhwLIPP6100Eth_ActRegVal[index] == 0xFFFFFFFF)        
+            {
+                gtmhwLIPP6100Eth_ActRegVal[index] = 0;
+            }
+
+            /* Read the IPC counter value */        
+            TMVH_GEN_READ(base+regOffset,regVal);                
+
+            sum = gtmhwLIPP6100Eth_ActRegVal[index] + regVal;
+
+            /* Over flow case */
+            if(sum < regVal)
+            {
+                /* On overflow, return all Fs */
+                gtmhwLIPP6100Eth_ActRegVal[index] = 0xFFFFFFFF;                    
+            }
+            else
+            {
+                /* Accumulate into a variable... until it overflows */
+                gtmhwLIPP6100Eth_ActRegVal[index] += regVal;
+            }
+
+            /* Actual value to be returned */
+            regVal = gtmhwLIPP6100Eth_ActRegVal[index];
+
+            /* Restore the register settings */                
+            TMVH_GEN_WRITE(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,org);
+
+
+        }
+        else
+        {
+            /* When rollover disable is not set */
+            TMVH_GEN_READ(base+regOffset,regVal);       
+            
+            /* Store the value for returning, when freeze =1 */            
+             gtmhwLIPP6100Eth_ActRegVal[index] = regVal;
+        }
+
+        return(regVal);        
+
+
+}
+     #endif
+
+#endif /* __IPVERSION_34_1_A__ */
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth_Vhip.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth_Vhip.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth_Vhip.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth_Vhip.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,625 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Vhip.h %
+ * %pid_version:          1.5                           %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   vHAL file for ethernet HwApi driver
+ *
+ *  DOCUMENT REF: Synopsys DesignWare Ethernet Universal Databook 
+ *                         Version 3.41a, Feb 2008 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMHWLIPP6100ETH_VHIP_H
+#define TMHWLIPP6100ETH_VHIP_H
+
+/*-----------------------------------------------------------------------------
+* Standard include files:
+*-----------------------------------------------------------------------------
+*/
+#include <linux/io.h>
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+
+/* Registers offsets of GMAC */
+#define TMVH_LIPP6100ETH_CONFIG_REG_OFFSET (0x0000)
+
+#define TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_CONFIG_TXCONFIG_POS (24)
+
+#define TMVH_LIPP6100ETH_CONFIG_WD_VAL (0x800000U)
+#define TMVH_LIPP6100ETH_CONFIG_WD_POS (23)
+
+#define TMVH_LIPP6100ETH_CONFIG_JD_VAL (0x400000U)
+#define TMVH_LIPP6100ETH_CONFIG_JD_POS (22)
+
+#define TMVH_LIPP6100ETH_CONFIG_FBE_VAL (0x200000U)
+#define TMVH_LIPP6100ETH_CONFIG_FBE_POS (21)
+
+
+#define TMVH_LIPP6100ETH_CONFIG_JFE_VAL (0x100000U)
+#define TMVH_LIPP6100ETH_CONFIG_JFE_POS (20)
+
+#define TMVH_LIPP6100ETH_CONFIG_DISCS_VAL (0x10000U)
+#define TMVH_LIPP6100ETH_CONFIG_DISCS_POS (16)
+
+#define TMVH_LIPP6100ETH_CONFIG_IFG_MSK (0xE0000U)
+#define TMVH_LIPP6100ETH_CONFIG_IFG_POS (17)
+
+#define TMVH_LIPP6100ETH_CONFIG_GMII_VAL (0x0000U)
+#define TMVH_LIPP6100ETH_CONFIG_MII_VAL (0x8000U)
+#define TMVH_LIPP6100ETH_CONFIG_MII_POS (14)
+
+#define TMVH_LIPP6100ETH_CONFIG_FES_VAL (0x4000U)
+#define TMVH_LIPP6100ETH_CONFIG_FES_POS (14)
+
+/* Disable Receive Own */
+#define TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL (0x2000U)
+#define TMVH_LIPP6100ETH_CONFIG_DRXOWN_POS (13)
+
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_VAL (0x1000U)
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_POS (12)
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_CLR (0xFFFFEFFFU) 
+
+#define TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL (0x800U)
+#define TMVH_LIPP6100ETH_CONFIG_DUPLEX_POS (11)
+
+#define TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL (0x400U)
+#define TMVH_LIPP6100ETH_CONFIG_IPCCHK_POS (10)
+
+#define TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL (0x200U)
+#define TMVH_LIPP6100ETH_CONFIG_DRETRY_POS (9)
+
+#define TMVH_LIPP6100ETH_CONFIG_LNKUP_VAL (0x100U)
+
+/* Automatic PAD/CRC stripping */
+#define TMVH_LIPP6100ETH_CONFIG_ACS_VAL (0x80U)
+#define TMVH_LIPP6100ETH_CONFIG_ACS_POS (7)
+
+#define TMVH_LIPP6100ETH_CONFIG_BACKOFF_MSK (0x60U)
+#define TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS (5)
+
+#define TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL (0x10U)
+#define TMVH_LIPP6100ETH_CONFIG_DEFCHK_POS (4)
+
+#define TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL (0x8U)
+#define TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR (0xFFFFFFF7U)
+
+#define TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL (0x4U)
+#define TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR (0xFFFFFFFBU)
+
+#define TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET (0x0004)
+
+#define TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_FMFLTR_RX_ALL_POS (31)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL (0x400U)
+#define TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_POS (10)
+
+#define TMVH_LIPP6100ETH_FMFLTR_SAF_VAL (0x200U)
+#define TMVH_LIPP6100ETH_FMFLTR_SAF_POS (9)
+
+#define TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL (0x100U)
+#define TMVH_LIPP6100ETH_FMFLTR_SAIF_POS (8)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PCF_POS (6)
+#define TMVH_LIPP6100ETH_FMFLTR_PCF_MSK (0xC0U)
+
+
+#define TMVH_LIPP6100ETH_FMFLTR_DBF_VAL (0x20U)
+#define TMVH_LIPP6100ETH_FMFLTR_DBF_POS (5)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PM_VAL (0x10U)
+#define TMVH_LIPP6100ETH_FMFLTR_PM_POS (4)
+
+#define TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL (0x8U)
+#define TMVH_LIPP6100ETH_FMFLTR_DAIF_POS (3)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HMC_VAL (0x4U)
+#define TMVH_LIPP6100ETH_FMFLTR_HMC_POS (2)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HUC_VAL (0x2U)
+#define TMVH_LIPP6100ETH_FMFLTR_HUC_POS (1)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PR_VAL (0x1U)
+
+
+#define TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET (0x0008)
+#define TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET (0x000C)
+
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET (0x0010)
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR (0xffff07ffU)
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_MSK (0xF800)
+
+/* PHY address value is in  the configuraiton file */
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS (11)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS (2)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR (0xffffffe3U)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_MSK (0x1CU)
+/* CSR value is in the configuration file */
+
+#define TMVH_LIPP6100ETH_GMII_GMII_REGISTER_CLR (0xfffff83fU)
+#define TMVH_LIPP6100ETH_GMII_GMII_REGISTER_POS (6)
+
+#define TMVH_LIPP6100ETH_GMII_GMII_WRITE_CLR (0xfffffffdU)
+#define TMHW_LIPP6100ETH_GMII_BUSY_VAL 1
+
+#define TMVH_LIPP6100ETH_GMII_DATA_REG_OFFSET (0x0014)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET (0x0018)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_MSK (0xFFFF0000U)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS (16)
+#define TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL (0x40)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS (4)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PLT_MSK (0x30U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL (0x8U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL (0x4U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL (0x1U)
+#define TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_CLR (0xFFFFFFFEU)
+
+#define TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET (0x001C)
+#define TMVH_LIPP6100ETH_VLANTAG_MASK (0x1FFFFU)
+
+#define TMVH_LIPP6100ETH_VERSION_REG_OFFSET (0x0020)
+/*(0x0024) Reserved */
+#define TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET (0x0028)
+
+#define TMVH_LIPP6100ETH_WKUP_FMFILTER_RSTREG_VAL (0x80000000U)
+
+#if (TMFL_LIPP6100ETHSD_POWER || TMFL_SD_ALL)
+/* Power management register */
+#define TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET (0x002C)
+#define TMVH_LIPP6100ETH_PWRMGMT_GU_VAL (0x200U)
+#define TMVH_LIPP6100ETH_PWRMGMT_WKUP_FM_EN_VAL (0x4U)
+#define TMVH_LIPP6100ETH_PWRMGMT_MAGIC_PKT_EN_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_VAL (0x1U)
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK (0x1U)
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_CLR (0xFFFFFFFEU)
+
+#define TMVH_LIPP6100ETH_POWER_ON (0x0U)
+#define TMVH_LIPP6100ETH_POWER_OFF (0x1U)
+
+#endif
+
+/* 0x30 to 0x34, reserved */
+
+/* Interrupt status register */
+#define TMVH_LIPP6100ETH_INTR_STATUS_REG_OFFSET (0x0038)
+
+/* Interrupt mask register */
+#define TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET (0x003C)
+
+/* Perfect filter registers */
+#define TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET (0x0040)
+#define TMVH_LIPP6100ETH_ADDR0_HIGH_REG_MSK (0xFFFFU)
+#define TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET (0x0044)
+
+#define TMVH_LIPP6100ETH_ADDR_ENABLE_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_ADDR_SA_EN_VAL (0x40000000U)
+#define TMVH_LIPP6100ETH_ADDR_MBC_POS (24)
+#define TMVH_LIPP6100ETH_ADDR_MBC_MSK (0x3F000000U)
+#define TMVH_LIPP6100ETH_ADDR_MBC_CLR (0xc0ffffffU)
+#define TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK (0xFFFFU)
+
+#define TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET (0x0048)
+#define TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET (0x004C)
+
+#define TMVH_LIPP6100ETH_ADDR2_HIGH_REG_OFFSET (0x0050)
+#define TMVH_LIPP6100ETH_ADDR2_LOW_REG_OFFSET (0x0054)
+
+#define TMVH_LIPP6100ETH_ADDR3_HIGH_REG_OFFSET (0x0058)
+#define TMVH_LIPP6100ETH_ADDR3_LOW_REG_OFFSET (0x005C)
+
+#define TMVH_LIPP6100ETH_ADDR4_HIGH_REG_OFFSET (0x0060)
+#define TMVH_LIPP6100ETH_ADDR4_LOW_REG_OFFSET (0x0064)
+
+#define TMVH_LIPP6100ETH_ADDR5_HIGH_REG_OFFSET (0x0068)
+#define TMVH_LIPP6100ETH_ADDR5_LOW_REG_OFFSET (0x006C)
+
+
+#define TMVH_LIPP6100ETH_ADDR6_HIGH_REG_OFFSET (0x0070)
+#define TMVH_LIPP6100ETH_ADDR6_LOW_REG_OFFSET (0x0074)
+
+#define TMVH_LIPP6100ETH_ADDR7_HIGH_REG_OFFSET (0x0078)
+#define TMVH_LIPP6100ETH_ADDR7_LOW_REG_OFFSET (0x007C)
+
+#define TMVH_LIPP6100ETH_ADDR8_HIGH_REG_OFFSET (0x0080)
+#define TMVH_LIPP6100ETH_ADDR8_LOW_REG_OFFSET (0x0084)
+
+#define TMVH_LIPP6100ETH_ADDR9_HIGH_REG_OFFSET (0x0088)
+#define TMVH_LIPP6100ETH_ADDR9_LOW_REG_OFFSET (0x008C)
+
+#define TMVH_LIPP6100ETH_ADDR10_HIGH_REG_OFFSET (0x0090)
+#define TMVH_LIPP6100ETH_ADDR10_LOW_REG_OFFSET (0x0094)
+
+
+#define TMVH_LIPP6100ETH_ADDR11_HIGH_REG_OFFSET (0x0098)
+#define TMVH_LIPP6100ETH_ADDR11_LOW_REG_OFFSET (0x009C)
+
+#define TMVH_LIPP6100ETH_ADDR12_HIGH_REG_OFFSET (0x00A0)
+#define TMVH_LIPP6100ETH_ADDR12_LOW_REG_OFFSET (0x00A4)
+
+#define TMVH_LIPP6100ETH_ADDR13_HIGH_REG_OFFSET (0x00A8)
+#define TMVH_LIPP6100ETH_ADDR13_LOW_REG_OFFSET (0x00AC)
+
+
+#define TMVH_LIPP6100ETH_ADDR14_HIGH_REG_OFFSET (0x00B0)
+#define TMVH_LIPP6100ETH_ADDR14_LOW_REG_OFFSET (0x00B4)
+
+#define TMVH_LIPP6100ETH_ADDR15_HIGH_REG_OFFSET (0x00B8)
+#define TMVH_LIPP6100ETH_ADDR15_LOW_REG_OFFSET (0x00BC)
+
+#define TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET (0x0800)
+#define TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET (0x0804)
+
+
+/* Auto negotiation registers */
+#define TMVH_LIPP6100ETH_AN_CTRL_REG_OFFSET (0x00C0)
+#define TMVH_LIPP6100ETH_AN_STAT_REG_OFFSET (0x00C4)
+
+#define TMVH_LIPP6100ETH_AN_ADV_REG_OFFSET (0x00C8)
+#define TMVH_LIPP6100ETH_AN_LPA_REG_OFFSET (0x00CC)
+
+#define TMVH_LIPP6100ETH_AN_XPAN_REG_OFFSET (0x00D0)
+
+#define TMVH_LIPP6100ETH_TBI_EXTD_STAT_REG_OFFSET (0x00D4)
+#define TMVH_LIPP6100ETH_SGMII_RGMII_STAT_REG_OFFSET (0x00D8)
+
+
+/* DMA register offsets */
+#define TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET (0x1000)
+#define TMVH_LIPP6100ETH_BUS_MODE_4XPBL_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_BUS_MODE_SEPPBL_VAL (0x800000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_RX_PBL_POS (17)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_AAL_VAL (0x2000000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_EN_ALTDESC (0x0000080U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_FB_VAL (0x10000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_PR_POS (14)
+#define TMVH_LIPP6100ETH_BUS_MODE_PBL_POS (8)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_DSL_POS (2)
+#define TMVH_LIPP6100ETH_BUS_MODE_DSL_MSK (0x7CU)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_DA_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL (0x1U)
+
+#define TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET (0x1004)
+#define TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET (0x1008)
+
+#define TMVH_LIPP6100ETH_RXDESC_LISTADDR_REG_OFFSET (0x100C) 
+
+#define TMVH_LIPP6100ETH_TXDESC_LISTADDR_REG_OFFSET (0x1010) 
+
+#define TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET (0x1014) 
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET (0x1018) 
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_DT_VAL (0x4000000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RSF_VAL (0x2000000U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_FRM_FLUSH_DIS_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL (0x2000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR (0xFFFFDFFFU)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL (0x2U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR (0xFFFFFFFDU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_SF_VAL (0x200000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_FTF_VAL (0x100000U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_POS (14)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_MSK (0x1C000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_CLR (0xFFFE3FFFU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_POS (11)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD2_POS (22)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD2_VAL (0x400000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_MSK (0x1800U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_CLR (0xFFFFE7FFU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_POS (9)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA2_POS (23)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA2_VAL (0x800000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_MSK (0x600U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_CLR (0xFFFFF9FFU)
+#define TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR (0x3)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_EFC_VAL (0x100U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_FEF_VAL (0x80U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_FUF_VAL (0x40U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_POS (3)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_MSK (0x18U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_CLR (0xFFFFFFE7U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_OSF_VAL (0x4U)
+
+#define TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET (0x101C)
+
+/*
+Offsets 0x1024 to 0x1044 are reserved.
+*/
+#if (TMFL_LIPP6100ETHSD_OTHERS || TMFL_SD_ALL)
+
+#define TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET (0x1020)
+#define TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_POS (17)
+#define TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_MSK (0xffe0000U)
+#define TMVH_LIPP6100ETH_MISSFR_BUF_CNT_MSK (0xFFFF)
+
+#define TMVH_LIPP6100ETH_CUR_HOST_TX_DESC_REG_OFFSET (0x1048)
+#define TMVH_LIPP6100ETH_CUR_HOST_RX_DESC_REG_OFFSET (0x104C)
+
+#define TMVH_LIPP6100ETH_CUR_HOST_TXBUFADR_REG_OFFSET (0x1050)
+#define TMVH_LIPP6100ETH_CUR_HOST_RXBUFADR_REG_OFFSET (0x1054)
+
+#endif
+
+#if (TMFL_LIPP6100ETHSD_MMC || TMFL_SD_ALL)
+/* Mac Management Counter register offsets */
+#define TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET (0x100)
+#define TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL (0x8U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL (0x4U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL (0x2U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_CNTR_RESET_VAL (0x1U)
+
+#define TMVH_LIPP6100ETH_MMC_INTR_RX_REG_OFFSET (0x104)
+#define TMVH_LIPP6100ETH_MMC_INTR_TX_REG_OFFSET (0x108)
+
+#define TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET (0x10C)
+#define TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET (0x110)
+
+/* Counters  on Transmission side */
+
+#define TMVH_LIPP6100ETH_MMC_TXOCTET_CNT_GB_REG_OFFSET (0x114)
+
+#define TMVH_LIPP6100ETH_MMC_TXFRAME_CNT_GB_REG_OFFSET (0x118)
+
+#define TMVH_LIPP6100ETH_MMC_TXBRDCST_CNT_G_REG_OFFSET (0x11C)
+
+#define TMVH_LIPP6100ETH_MMC_TXMULTCST_CNT_G_REG_OFFSET (0x120)
+
+#define TMVH_LIPP6100ETH_MMC_TX64_GB_REG_OFFSET (0x124)
+
+#define TMVH_LIPP6100ETH_MMC_TX65TO127_GB_REG_OFFSET (0x128)
+
+#define TMVH_LIPP6100ETH_MMC_TX128TO255_GB_REG_OFFSET (0x12C)
+
+#define TMVH_LIPP6100ETH_MMC_TX256TO511_GB_REG_OFFSET (0x130)
+
+#define TMVH_LIPP6100ETH_MMC_TX512TO1023_GB_REG_OFFSET (0x134)
+
+#define TMVH_LIPP6100ETH_MMC_TX1024TOMAX_GB_REG_OFFSET (0x138)
+
+#define TMVH_LIPP6100ETH_MMC_TX_UNICAST_GB_REG_OFFSET (0x13C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_MULTCST_GB_REG_OFFSET (0x140)
+
+#define TMVH_LIPP6100ETH_MMC_TX_BRDCST_GB_REG_OFFSET (0x144)
+
+#define TMVH_LIPP6100ETH_MMC_TX_UNNDERFLOW_ERR_REG_OFFSET (0x148)
+
+#define TMVH_LIPP6100ETH_MMC_TX_SINGLCOL_G_REG_OFFSET (0x14C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_MULTICOL_G_REG_OFFSET (0x150)
+
+#define TMVH_LIPP6100ETH_MMC_TX_DEFERRED_REG_OFFSET (0x154)
+
+#define TMVH_LIPP6100ETH_MMC_TX_LATECOL_REG_OFFSET (0x158)
+
+#define TMVH_LIPP6100ETH_MMC_TX_EXCESSCOL_REG_OFFSET (0x15C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_CARRIER_ERR_REG_OFFSET (0x160)
+
+#define TMVH_LIPP6100ETH_MMC_TX_OCTET_CNT_G_REG_OFFSET (0x164)
+
+#define TMVH_LIPP6100ETH_MMC_TX_FRM_CNT_G_REG_OFFSET (0x168)
+
+#define TMVH_LIPP6100ETH_MMC_TX_EXCESS_DEF_REG_OFFSET (0x16C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_PAUSE_FRAMES_REG_OFFSET (0x170)
+
+#define TMVH_LIPP6100ETH_MMC_TX_VLAN_FRAMES_G_REG_OFFSET (0x174)
+
+/*
+0x1078 --0x107C reserved
+*/
+
+/* Received frames */
+#define TMVH_LIPP6100ETH_MMC_RXFRM_CNT_GB_REG_OFFSET (0x180)
+#define TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_GB_REG_OFFSET (0x184)
+#define TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_G_REG_OFFSET (0x188)
+
+#define TMVH_LIPP6100ETH_MMC_RX_BRDCSTF_G_REG_OFFSET (0x18C)
+
+#define TMVH_LIPP6100ETH_MMC_RX_MULTCSTF_G_REG_OFFSET (0x190)
+
+#define TMVH_LIPP6100ETH_MMC_RX_CRC_ERR_REG_OFFSET (0x194)
+
+#define TMVH_LIPP6100ETH_MMC_RX_ALIGNMT_ERR_REG_OFFSET (0x198)
+
+#define TMVH_LIPP6100ETH_MMC_RX_RUNT_ERR_REG_OFFSET (0x19C)
+
+#define TMVH_LIPP6100ETH_MMC_RX_JABBER_ERR_REG_OFFSET (0x1A0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_UNDERSIZE_G_REG_OFFSET (0x1A4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_OVERSIZE_G_REG_OFFSET (0x1A8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_64_GB_REG_OFFSET (0x1AC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_65TO127_GB_REG_OFFSET (0x1B0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_128TO255_GB_REG_OFFSET (0x1B4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_256TO511_GB_REG_OFFSET (0x1B8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_512TO1023_GB_REG_OFFSET (0x1BC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_1024TOMAX_GB_REG_OFFSET (0x1C0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_UNICAST_G_REG_OFFSET (0x1C4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_LEN_ERR_REG_OFFSET (0x1C8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_OUTOFRANGE_REG_OFFSET (0x1CC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_PAUSE_REG_OFFSET (0x1D0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_FIFO_OVERFLOW_REG_OFFSET (0x1D4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_VLAN_FRAMES_GB_REG_OFFSET (0x1D8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_WATCHDOG_ERR_REG_OFFSET (0x1DC)
+
+
+/* IPv4, IPv6, TCP, UDP, ICMP statistics counters */
+
+/* 0x01E0 -- 0x01FC reserved */
+
+#define TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET (0x200)
+
+/* 0x204  reserved */
+
+#define TMVH_LIPP6100ETH_MMC_IPC_INT_REG_OFFSET (0x208)
+
+/* 0x020C reserved */
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET (0x210)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET (0x214)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET (0x218)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET (0x21C)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET (0x220)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET (0x224)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET (0x228)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET (0x22C)
+
+#define TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET (0x230)
+#define TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET (0x234)
+
+#define TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET (0x238)
+#define TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET (0x23C)
+
+#define TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET (0x240)
+#define TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET (0x244)
+
+/* 0x248 -- 0x24C reserved */
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_GD_OCTETS_REG_OFFSET (0x250)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_HDRERR_OCTETS_REG_OFFSET (0x254)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_OCTETS_REG_OFFSET (0x258)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_OCTETS_REG_OFFSET (0x25C)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_OCTECTS_REG_OFFSET (0x260)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_GD_OCTETS_REG_OFFSET (0x264)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_HDRERR_OCTETS_REG_OFFSET (0x268)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_OCTETS_REG_OFFSET (0x26C)
+
+#define TMVH_LIPP6100ETH_MMC_RXUDP_GD_OCTETS_REG_OFFSET (0x270)
+#define TMVH_LIPP6100ETH_MMC_RXUDP_ERR_OCTETS_REG_OFFSET (0x274)
+
+#define TMVH_LIPP6100ETH_MMC_TCP_GD_OCTETS_REG_OFFSET (0x278)
+#define TMVH_LIPP6100ETH_MMC_TCP_ERR_OCTETS_REG_OFFSET (0x27C)
+
+#define TMVH_LIPP6100ETH_MMC_ICMP_GD_OCTETS_REG_OFFSET (0x280)
+#define TMVH_LIPP6100ETH_MMC_ICMP_ERR_OCTETS_REG_OFFSET (0x284)
+#endif
+
+#if (TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP || TMFL_SD_ALL)
+/* IEEE 1588  Time stamp registers */
+#define TMVH_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL (0x20U)
+#define TMVH_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_POS (5)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL (0x10U)
+#define TMVH_LIPP6100ETH_TS_CTRL_INT_TRIG_POS (4)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL (0x8U)
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_UPDATE_POS (3)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_INIT_VAL (0x4U)
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_INIT_POS (2)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL (0x2U)
+#define TMVH_LIPP6100ETH_TS_CTRL_FINE_UPDATE_POS (1)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL (0x1U)
+#define TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET (0x700)
+
+#define TMVH_LIPP6100ETH_TS_SUB_SECOND_INCR_REG_OFFSET (0x704)
+#define TMVH_LIPP6100ETH_TS_HIGH_REG_OFFSET (0x708)
+#define TMVH_LIPP6100ETH_TS_LOW_REG_OFFSET (0x70C)
+
+#define TMVH_LIPP6100ETH_TS_HIGH_UPDATE_REG_OFFSET (0x710)
+
+#define TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_TS_LOW_UPDATE_REG_OFFSET (0x714)
+
+#define TMVH_LIPP6100ETH_TS_ADDEND_REG_OFFSET (0x718)
+
+#define TMVH_LIPP6100ETH_TS_TGT_TIME_HIGH_REG_OFFSET (0x71C)
+#define TMVH_LIPP6100ETH_TS_TGT_TIME_LOW_REG_OFFSET (0x720)
+
+#endif
+
+/* Macro to compute perfect address filter register offset value */
+#define TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(_regnum_) (((_regnum_)-1)*8) 
+#define TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(_regnum_) (((_regnum_)-16)*8) 
+
+/* Register Read Write Macro's  */
+
+#ifndef TMVH_GEN_READ
+
+#define TMVH_GEN_READ(_address_,_result_) {_result_ = readl(_address_);}
+#endif
+
+#ifndef TMVH_GEN_WRITE
+
+#define TMVH_GEN_WRITE(_address_,_value_) writel(_value_,_address_)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmFlags.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmFlags.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmFlags.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmFlags.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,47 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmFlags.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+ #ifndef TMFLAGS_H                                    
+ #define TMFLAGS_H                                                   
+
+ #define TMFL_OS_IS_NULLOS             1
+ #define TMFL_ENDIAN                   0
+ #define TMFL_ENDIAN_BIG               1
+ #define TMFL_ENDIAN_LITTLE            0
+ #define TMFL_REL_TRACE                0x00000003
+ #define TMFL_REL_ASSERT               0x00000002
+ #define TMFL_REL_DEBUG                0x00000001
+ #define TMFL_REL_RETAIL               0x00000000
+
+#define TMFL_REL  TMFL_REL_RETAIL
+
+ #endif   /* TMFLAGS_H*/
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxCompId.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxCompId.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxCompId.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxCompId.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,70 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxCompId.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXCOMPID_H
+#define TMNXCOMPID_H
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*   Standard include files:                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define CID_IID_FLAG_BITSHIFT    31
+#define CID_ID_BITSHIFT          12
+
+#define TM_OK                     0U         /* Global success return status   */
+
+#define CID_ID(number)           ((number) << CID_ID_BITSHIFT)
+#define CID_FLAG                 (0x1U << CID_IID_FLAG_BITSHIFT)
+
+
+#define CID_BSL_PHY                 (CID_ID(0x80deU) | CID_FLAG)
+
+#define TM_ERR_INIT_FAILED              0x014U /* Initialization failed        */
+#define TM_ERR_BAD_UNIT_NUMBER          0x005U /* Invalid device unit number   */
+#define TM_ERR_NOT_SUPPORTED            0x013U /* Function is not supported    */
+#define TM_ERR_TIMEOUT                  0x01FU /* Timeout error                */
+#define TM_ERR_HW_RESET_FAILED          0x04BU /* Hardware reset failed        */
+#define TM_ERR_READ                     0x017U /* Read error                   */
+#define TM_ERR_WRITE                    0x018U /* Write error                  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMNXCOMPID_H ----------------- */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxModId.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxModId.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxModId.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxModId.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,48 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxModId.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXMODID_H
+#define TMNXMODID_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* TMNXMODID_H */ 
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxTypes.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxTypes.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxTypes.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1/tmNxTypes.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,173 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxTypes.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXTYPES_H
+#define TMNXTYPES_H
+
+/*-----------------------------------------------------------------------------
+** Standard include files:
+**-----------------------------------------------------------------------------
+*/
+
+#include "tmFlags.h"          
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*-----------------------------------------------------------------------------
+** Types and defines:
+**-----------------------------------------------------------------------------
+*/
+
+#define TM_FALSE            0       /* replaces legacy False macro */
+#define TM_TRUE             1       /* replaces legacy True  macro */
+
+#define TM_ENDIAN_BIG       0       /* replaces legacy BigEndian    macro */
+#define TM_ENDIAN_LITTLE    1       /* replaces legacy LittleEndian macro */
+
+#ifndef False
+#define False         (TM_FALSE)  /* NOTE: Legacy - use TM_FALSE instead */
+#endif
+
+#ifndef True
+#define True          (TM_TRUE)   /* NOTE: Legacy - use TM_TRUE  instead */
+#endif
+
+#ifdef __cplusplus
+#define Null          0
+#else
+#define Null          ((Void *) 0)
+#endif
+
+#define HAL_DEVICE_NAME_LENGTH  16
+
+/*
+** Standard Types
+*/
+typedef void            Void;       /* Void (typeless) */
+typedef signed   char   Int8;       /*  8-bit   signed integer */
+typedef signed   short  Int16;      /* 16-bit   signed integer */
+typedef signed   long   Int32;      /* 32-bit   signed integer */
+typedef unsigned char   UInt8;      /*  8-bit unsigned integer */
+typedef unsigned short  UInt16;     /* 16-bit unsigned integer */
+typedef unsigned long   UInt32;     /* 32-bit unsigned integer */
+typedef float           Float;      /* 32-bit floating point */
+typedef unsigned int    Bool;       /* Boolean (True/False) */
+typedef char            Char;       /* character, character array ptr */
+typedef int             Int;        /* machine-natural integer */
+typedef unsigned int    UInt;       /* machine-natural unsigned integer */
+typedef char           *String;     /* Null-terminated 8-bit char str */
+
+
+typedef struct tmVersion
+{
+    UInt8   majorVersion;
+    UInt8   minorVersion;
+    UInt16  buildVersion;
+}   tmVersion_t, *ptmVersion_t;
+
+
+typedef signed   int    IBits32;    /* 32-bit   signed integer bitfields */
+typedef unsigned int    UBits32;    /* 32-bit unsigned integer bitfields */
+
+typedef Int8    *pInt8;             /*  8-bit   signed integer ptr */
+typedef Int16   *pInt16;            /* 16-bit   signed integer ptr */
+typedef Int32   *pInt32;            /* 32-bit   signed integer ptr */
+typedef IBits32 *pIBits32;          /* 32-bit   signed integer bitfield ptr */
+typedef UBits32 *pUBits32;          /* 32-bit unsigned integer bitfield ptr */
+typedef UInt8   *pUInt8;            /*  8-bit unsigned integer ptr */
+typedef UInt16  *pUInt16;           /* 16-bit unsigned integer ptr */
+typedef UInt32  *pUInt32;           /* 32-bit unsigned integer ptr */
+typedef Void    *pVoid;             /* Void (typeless) ptr */
+typedef Float   *pFloat;            /* 32-bit floating point, float ptr */
+typedef double  Double, *pDouble;   /* 32/64-bit floating point, double ptr */
+typedef Bool    *pBool;             /* Boolean (True/False) ptr */
+typedef Char    *pChar;             /* character, character array ptr */
+typedef Int     *pInt;              /* machine-natural integer ptr */
+typedef UInt    *pUInt;             /* machine-natural unsigned integer ptr */
+typedef String  *pString;           /* Null-terminated 8-bit char str ptr */
+
+
+
+typedef UInt32 tmErrorCode_t;
+
+
+/*-----------------------------------------------------------------------------
+** Hardware device power states
+*/
+typedef enum tmPowerState
+{
+    tmPowerOn,                          /* Device powered on      (D0 state) */
+    tmPowerStandby,                     /* Device power standby   (D1 state) */
+    tmPowerSuspend,                     /* Device power suspended (D2 state) */
+    tmPowerOff                          /* Device powered off     (D3 state) */
+}   tmPowerState_t, *ptmPowerState_t;
+
+/*-----------------------------------------------------------------------------
+** Software Version Structure
+*/
+typedef struct tmSWVersion
+{
+    UInt32      compatibilityNr;        /* Interface compatibility number */
+    UInt32      majorVersionNr;         /* Interface major version number */
+    UInt32      minorVersionNr;         /* Interface minor version number */
+
+}   tmSWVersion_t, *ptmSWVersion_t;
+
+typedef Int tmInstance_t, *ptmInstance_t;
+
+/*-----------------------------------------------------------------------------
+
+** HW Unit Selection
+*/
+
+typedef Int tmUnitSelect_t, *ptmUnitSelect_t;
+
+#define tmUnitNone (-1)
+#define tmUnit0    0
+#define tmUnit1    1
+#define tmUnit2    2
+#define tmUnit3    3
+#define tmUnit4    4
+#define tmUnit5    5
+#define tmUnit6    6
+#define tmUnit7    7
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* ifndef TMNXTYPES_H */
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/intfs/ItmbslPhy/inc/tmbslPhy.h linux-2.6.34/drivers/net/LIPP_6300ETH/intfs/ItmbslPhy/inc/tmbslPhy.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/intfs/ItmbslPhy/inc/tmbslPhy.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/intfs/ItmbslPhy/inc/tmbslPhy.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,725 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:               tmbslPhy.h %
+ * %pid_version:                 1.2      %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#ifndef  TMBSLPHY_H
+#define  TMBSLPHY_H
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+#include <tmNxTypes.h>  // DVP standard types/defines/structs
+#include <tmNxCompId.h> // DVP system wide component IDs
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+
+
+#define TMBSL_PHY_COMPATIBILITY_NR       1
+#define TMBSL_PHY_MAJOR_VERSION_NR       1
+#define TMBSL_PHY_MINOR_VERSION_NR       0
+
+
+
+#define TMBSL_ERR_PHY_BASE          	CID_BSL_PHY
+#define TMBSL_ERR_PHY_COMP          	(CID_BSL_PHY | \
+                                        	 TM_ERR_COMP_UNIQUE_START)
+//PHY unit not supported                                         	 
+#define TMBSL_ERR_PHY_NOT_SUPPORTED 	(TMBSL_ERR_PHY_BASE+TM_ERR_NOT_SUPPORTED)
+// Invalid device unit number
+#define TMBSL_ERR_PHY_BAD_UNIT_NUM  	(TMBSL_ERR_PHY_BASE+TM_ERR_BAD_UNIT_NUMBER)
+// AutoNegotiation Time out occured
+#define TMBSL_ERR_PHY_AUTONEG_TIMEOUT   (TMBSL_ERR_PHY_BASE+TM_ERR_TIMEOUT)
+//PHY unit register read failed
+#define TMBSL_ERR_PHY_READ_FAILED       (TMBSL_ERR_PHY_BASE + TM_ERR_READ)
+//PHY unit register write failed
+#define TMBSL_ERR_PHY_WRITE_FAILED      (TMBSL_ERR_PHY_BASE + TM_ERR_WRITE)
+//PHY Initialisation failed
+#define TMBSL_ERR_PHY_INIT_FAILED       (TMBSL_ERR_PHY_BASE + TM_ERR_INIT_FAILED)
+//PHY unit reset failed
+#define TMBSL_ERR_PHY_RESET_FAILED      (TMBSL_ERR_PHY_BASE + TM_ERR_HW_RESET_FAILED)
+
+#if 0
+#define tmbslPhyRegisterComponent(unitNumber, pIntInterface)            \
+         tmbslCoreRegisterComponent(TMBSL_ERR_PHY_BASE,                  \
+                                    unitNumber,                          \
+                                    (ptmbslCompInterface_t) pIntInterface)
+
+
+#define tmbslPhyGetInterface(unitNumber, ppIntInterface)                \
+         tmbslCoreGetInterface(TMBSL_ERR_PHY_BASE,                       \
+                               unitNumber,                               \
+                               (tmbslCompInterface_t **) ppIntInterface)
+                               
+#endif
+
+// PHY DUPLEX MODE
+typedef enum	_tmbslPhyDuplexMode_t
+{
+	tmbslPhyHalfDuplex	=0,
+	tmbslPhyFullDuplex	=1
+} tmbslPhyDuplexMode_t, *ptmbslPhyDuplexMode_t;
+
+// PHY SPEED
+typedef enum	_tmbslPhySpeed_t
+{
+	tmbslPhySpeed10Mbps	=0,
+	tmbslPhySpeed100Mbps	=1,
+	tmbslPhySpeed1Gbps	= 2	
+} tmbslPhySpeed_t, *ptmbslPhySpeed_t;
+
+// ENABLE DISABLE MODE
+typedef enum	_tmbslPhyEnableDisable_t
+{
+	tmbslPhyDisable		=0,
+	tmbslPhyEnable		=1
+} tmbslPhyEnableDisable_t, *ptmbslPhyEnableDisable_t;
+
+// PHY BASIC MODE CONTROL
+typedef struct	_tmbslPhyBasicModeControl_t
+{
+	Bool					enableCollisionTest; 
+	tmbslPhyDuplexMode_t	duplexMode;
+	tmbslPhySpeed_t			speed;
+} tmbslPhyBasicModeControl_t, *ptmbslPhyBasicModeControl_t;
+
+// PHY BASIC MODE STATUS
+typedef struct	_tmbslPhyBasicModeStatus_t
+{
+	Bool					jabberDetect; // This applies only in 10Mbps : value 1 - jabber condition detected
+	Bool					remoteFaultDetected; 
+	Bool					autoNegotiationComplete;
+	Bool					receiverErrorLatch;
+	Bool					invertedPolarityDetected; // Detects link polarity
+	Bool					falseCarrierEverntOccured;
+	Bool					linkCodeWordPageReceived;
+	Bool					loopBackEnabled; //loopback status
+	tmbslPhyDuplexMode_t	duplexMode; // deplex mode status
+	tmbslPhySpeed_t			speed;
+	Bool					linkpartnerAcknolwedged ; // Link partner acknolwedged
+	Bool					parallelDetectFaultDetected ; // Parallel detect fault is deteced
+
+} tmbslPhyBasicModeStatus_t, *ptmbslPhyBasicModeStatus_t;
+
+// PHY PROTOCOL SELECTION
+typedef enum	_tmbslPhyProtocol_t
+{
+	tmbslPhyProtocolNone		= 0,
+	tmbslPhyIEEE8023			= 1
+} tmbslPhyProtocol_t, *ptmbslPhyProtocol_t;
+
+/* PHY auto negotiation mask 
+** When the below flags are true, that particular option is disabled/not advertised
+*/
+typedef struct	_tmbslPhyAutoNegotiationMask_t
+{
+    Bool				      masknextPageDesired;
+    Bool				      maskRemoteFault; // advertise remote fault detection
+    Bool					mask100BaseT4;  //advertise/mask 100BaseT4 capability 
+    Bool					mask100BaseTxFullDuplexSupport; 
+    Bool					mask100BaseTxSupport;
+    Bool					mask10BaseTFullDuplexSupport; //advertise/mask 10BaseTFullDuplex support
+    Bool					mask10BaseTSupport;
+    tmbslPhyProtocol_t		protocolSel;			//(0x0001 IEEE802.3 CSMA/Cd)
+    Bool                             maskAsymmetricPause;
+    Bool                             maskPauseFrame;    
+    /* 1G related enum  start */
+    Bool                            maskMSConfigEn;
+    Bool                            maskMasterEn;
+    Bool                            maskMultiPortEn;
+    Bool                            mask1000BaseTFullDuplexSupport;
+    Bool                            mask1000BaseTHalfDuplexSupport;    
+    /* 1G related ends*/
+} tmbslPhyAutoNegotiationMask_t, *ptmbslPhyAutoNegotitationMask_t;
+
+
+// PHY IDENTIFIER
+typedef struct	_tmbslPhyIdentifier_t
+{
+	UInt32		oui; //PHY Organizationally Unique Identifier
+	UInt32		vendorModelNr; 
+	UInt32		modelRevNr;
+	UInt32		siliconRevisionNr; 
+} tmbslPhyIdentifier_t, *ptmbslPhyIdentifier_t;
+
+
+// PHY CAPABILITIES
+typedef struct	_tmbslPhyCapabilities_t
+{
+    Bool			T4Support100Base;
+    Bool			Tx_FullDuplexSupport100Base;
+    Bool			Tx_HalfDuplexSupport100Base;
+    Bool			Tx_FullDuplexSupport10Base;
+    Bool			Tx_HalfDuplexSupport10Base;
+    Bool		 	preAmbleSuppresionCapability;
+    Bool		 	autoNegotiationAbility;
+    Bool		 	nextPageIndication;
+    Bool			force100MbpsTxOff; 
+    Bool			bypassSymbolAlignment; 
+    Bool			badSSDDetectionConfig; 
+    Bool		 	ledStatusSupport;	   
+
+    /* 1G related capabilities */
+    Bool		 	X1000BaseFDSupport;	       
+    Bool		 	X1000BaseHDSupport;	           
+    Bool		 	T1000BaseFDSupport;	       
+    Bool		 	T1000BaseHDSupport;	               
+
+} tmbslPhyCapabilities_t, *ptmbslPhyCapabilities_t;
+
+
+// PHY LINK PARTNER CAPABILITIES
+
+typedef struct	_tmbslPhyLinkPartnerCapabilities_t
+{
+
+	tmbslPhyProtocol_t			protocolSel;
+	Bool						TSupport10Base;
+	Bool						TFullDuplexSupport10Base;
+	Bool						TxSupport100Base;
+	Bool						TxFullDuplexSupport100Base;
+	Bool						T4Support100Base;
+	Bool						flowControl;
+	Bool						remoteFault;
+	Bool						acknoweledges;
+	Bool						nextPageIndication;
+	Bool						autoNegotiation;	
+} tmbslPhyLinkPartnerCapabilities_t, *ptmbslPhyLinkPartnerCapabilities_t;
+
+
+// PHY PCS(PHYSICAL SUBBAND CODING
+typedef struct	_tmbslPhyPcsConfig_t
+{
+    /* 1 - force good link condition
+         0 - normal operation  */
+    Bool forceGoodLink100Mbps; 
+    Bool force100MbpsTxOff;
+    Bool bypassSymbolAlignment;
+    /* 1 - Enable bad SSD detection */
+    tmbslPhyEnableDisable_t badSSDDetection; 
+} tmbslPhyPcsConfig_t, *ptmbslPhyPcsConfig_t;
+
+// PHY COUNTERS
+typedef struct 	_tmbslPhyCounters_t
+{
+	UInt32			disconnectCounter;		
+	UInt32			falseCarrierEventCounter;//Gives the number of false carrier events 
+	UInt32			rxErrorCounter;	//Gives the number of Receive error occured 		
+} tmbslPhyCounters_t, *ptmbslPhyCounters_t;
+
+
+// PSEUDO RANDOM SEQUENCES
+typedef enum	_tmbslPhyPseudoRandomSeq_t
+{
+	tmbslPhyPseudoRandomSequenc9bit	=0,
+	tmbslPhyPseudoRandomSequenc15bit	=1
+} tmbslPhyPseudoRandomSeq_t, *ptmbslPhyPseudoRandomSeq_t;
+
+
+// PHY BYPASS OPTIONS
+typedef struct	_tmbslPhyBypass_t
+{
+	Bool		bypass4B5BCodec; //Bypass 4B 5B Encoding / Decoding
+	Bool		bypassNrzi;      //Bypass NRZI Encoding / Decoding
+	Bool		bypassScrambler; 
+	Bool		bypassDescrambler;
+} tmbslPhyBypass_t, *ptmbslPhyBypass_t;  
+
+
+
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetSWVersion_t) (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetCapabilities_t) (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+    
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyInit_t)(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyDeinit_t)(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhySetPowerState_t)(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetPowerState_t)(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t 
+(*tmbslPhyGetBasicModeControl_t) (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t 
+(*tmbslPhySetBasicModeControl_t) (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetBasicModeStatus_t) (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyAutoNegotiate_t) (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetIdentifier_t) (
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetLinkPartnerCapabilities_t) (
+    tmUnitSelect_t                         phyUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetCounters_t) (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyPcsSetConfig_t) (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyPcsGetConfig_t) (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result 
+//				will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//              pBistState  --> result of BIST (Built in self test) Test 
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyBist_t) (		
+    tmUnitSelect_t  						phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    			phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyConfigBypass_t) (
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyLoopBack_t) (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhySoftReset_t) (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetLinkStatus_t) (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+);
+
+typedef struct _tmbslPhyConfig_t 
+{
+	char     phyName[HAL_DEVICE_NAME_LENGTH];
+    UInt32   phyID;    
+	UInt32   lanClkSrc; // To select Clock source
+	UInt32   lanClkSpeed; // To select the speed
+	
+	tmbslPhyGetSWVersion_t            getSWVersionFunc; 
+	tmbslPhyGetCapabilities_t         getCapabilitiesFunc;
+	tmbslPhyInit_t                    initFunc;
+	tmbslPhyDeinit_t                  deinitFunc;  
+	tmbslPhySetPowerState_t           setPowerStateFunc;
+	tmbslPhyGetPowerState_t           getPowerStateFunc;
+	tmbslPhyGetBasicModeControl_t     getBasicModeControlFunc;
+	tmbslPhySetBasicModeControl_t     setBasicModeControlFunc;
+	tmbslPhyGetBasicModeStatus_t      getBasicModeStatusFunc;
+	tmbslPhyAutoNegotiate_t           autoNegotiateFunc;
+	tmbslPhyGetIdentifier_t           getIdentifier_tFunc;
+	tmbslPhyGetLinkPartnerCapabilities_t  getLinkPartnerCapabilitiesFunc;
+	tmbslPhyGetCounters_t                 getCountersFunc;
+	tmbslPhyPcsSetConfig_t                   pcsConfigFunc;
+	tmbslPhyPcsGetConfig_t                pcsGetConfigFunc;
+	tmbslPhyBist_t                        bistFunc;
+	tmbslPhyConfigBypass_t                configBypassFunc;
+	tmbslPhyLoopBack_t                    loopBackFunc;
+	tmbslPhySoftReset_t                   softResetFunc;
+	tmbslPhyGetLinkStatus_t               getLinkStatusFunc;
+
+} tmbslPhyConfig_t,*ptmbslPhyConfig_t;
+
+typedef struct {
+UInt32 phyID;
+tmbslPhyConfig_t *interface_fns;
+}phyID_interface_tbl;
+
+void tmbslPhyGetInterface(int unitno, UInt32 phyID, UInt32 isExternal, tmbslPhyConfig_t**pPhyInterface);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus) 
+#endif //#ifndef  TMBSLPHYDP83847_H
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Kconfig linux-2.6.34/drivers/net/LIPP_6300ETH/Kconfig
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/Kconfig	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,44 @@
+#
+# Ethernet GMAC driver configuration
+config USING_APOLLO_SOC_GMAC0
+	bool "Apollo GMAC0 Controller"
+	depends on LIPP_6300ETH
+	help 
+           LIPP_6100ETH MAC0 and PHYs for GMAC0
+
+config GMAC0_MODE_RGMII
+	bool "GMAC0 in RGMII mode"
+	depends on USING_APOLLO_SOC_GMAC0
+	help
+	   GMAC0 will be configured as RGMII, otherwise MII
+
+config USING_APOLLO_SOC_GMAC1
+        bool "Apollo GMAC1 Controller"
+	depends on LIPP_6300ETH
+        help
+           LIPP_6100ETH MAC1 and PHYs for GMAC1
+
+config GMAC1_MODE_RGMII
+        bool "GMAC1 in RGMII mode"
+        depends on USING_APOLLO_SOC_GMAC1
+        help
+           GMAC1 will be configured as RGMII, otherwise MII
+
+choice
+	prompt "Choose Entropic PHY version"
+        default EN2512_PHY
+	depends on USING_APOLLO_SOC_GMAC0 || USING_APOLLO_SOC_GMAC1
+	help
+		This option allows to select between EN2512 or EN2510 MoCA PHY driver.
+
+config EN2512_PHY
+	bool "Entropic MoCA EN2512 PHY"
+	help
+		Select MidRF EN2512 Entropic MoCA PHY driver
+
+config EN2510_PHY
+	bool "Entropic MoCA EN2510 PHY"
+	help
+		Select HiRF EN2510 Entropic MoCA PHY driver
+
+endchoice
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Makefile linux-2.6.34/drivers/net/LIPP_6300ETH/Makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,104 @@
+#
+# Makefile for drivers/net/LIPP_6300ETH
+#
+
+# All object files to be linked 
+
+obj-$(CONFIG_LIPP_6300ETH) += LIPP_6300ETH.o
+
+PHY_OBJS-$(CONFIG_USING_SMSC8700_PHY) = comps/tmbslPhySMSC8700/src/tmbslPhySMSC8700.o
+
+PHY_OBJS-$(CONFIG_USING_SMSC8710_PHY) += comps/tmbslPhySMSC8710/src/tmbslPhySMSC8710.o
+
+PHY_OBJS-$(CONFIG_USING_DP83848_PHY) += comps/tmbslPhyDP83848/src/tmbslPhyDP83848.o
+
+PHY_OBJS-$(CONFIG_USING_DP83865_PHY) += comps/tmbslPhyDP83865/src/tmbslPhyDP83865.o
+
+PHY_OBJS-y +=  	comps/tmbslPhyMYSTI110E/src/tmbslPhyMYSTI110E.o \
+		comps/tmbslPhyRTL8211BN/src/tmbslPhyRTL8211BN.o \
+		comps/tmbslPhyIntel972/src/tmbslPhyIntel972.o
+
+PHY_OBJS-$(CONFIG_EN2510_PHY) += comps/tmbslPhyEN2510/src/tmbslPhyEN2510.o \
+				 comps/tmbslPhyEN2510/en2510/Apollo/Src/Clnk_ctl_apollo.o \
+				 comps/tmbslPhyEN2510/en2510/Apollo/Src/ClnkBus_iface_apollo.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ClnkIo_common.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_call.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ClnkMbx_dvr.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ctx_abs.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/ctx_setup.o \
+				 comps/tmbslPhyEN2510/en2510/Common/Src/util_dvr.o \
+				 comps/tmbslPhyEN2510/en2510/GPL/Common/hostos_linux.o \
+				 comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_abs.o \
+				 comps/tmbslPhyEN2510/en2510/GPL/Common/gpl_ctx_setup.o \
+				 comps/tmbslPhyEN2510/en2510/GPL/Apollo/en2510.o \
+				 comps/tmbslPhyEN2510/en2510/GPL/Apollo/apollo_mdio.o
+
+PHY_OBJS-$(CONFIG_EN2512_PHY) += comps/tmbslPhyEN2512/src/tmbslPhyEN2512.o \
+				 comps/tmbslPhyEN2512/en2512/Apollo/Src/Clnk_ctl_apollo.o \
+				 comps/tmbslPhyEN2512/en2512/Apollo/Src/ClnkBus_iface_apollo.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ClnkIo_common.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_call.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ClnkMbx_dvr.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ctx_abs.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/ctx_setup.o \
+				 comps/tmbslPhyEN2512/en2512/Common/Src/util_dvr.o \
+				 comps/tmbslPhyEN2512/en2512/GPL/Common/hostos_linux.o \
+				 comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_abs.o \
+				 comps/tmbslPhyEN2512/en2512/GPL/Common/gpl_ctx_setup.o \
+				 comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.o \
+				 comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.o
+
+LIPP_6300ETH-objs = src/gmac_drv.o src/remap.o src/tmbslPhyAccess.o \
+		    comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.o \
+		    comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.o $(PHY_OBJS-y)
+
+# Macros definitions & include paths
+
+EXTRA_PHY_FLAGS-$(CONFIG_USING_PNX85500_M1_BOARD) += -DTMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL=0x0U -D__PNX85500_M1_SOC__ 
+EXTRA_PHY_FLAGS-$(CONFIG_USING_PNX85500_M0_BOARD) += -DTMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL=0x1U -D__PNX85500_M0_SOC__ 
+
+EXTRA_PHY_FLAGS-$(CONFIG_USING_SMSC8700_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8700/inc \
+			-DTMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL=0x16U \
+			-D__USING_SMSC8700_PHY__
+
+EXTRA_PHY_FLAGS-$(CONFIG_USING_SMSC8710_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhySMSC8710/inc \
+			-DTMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL=0x0U \
+			-D__USING_SMSC8710_PHY__
+
+EXTRA_PHY_FLAGS-$(CONFIG_USING_DP83848_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyDP83848/inc \
+			-DTMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL=0x1U \
+			-D__USING_DP83848_PHY__
+
+EXTRA_PHY_FLAGS-$(CONFIG_USING_DP83865_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyDP83865/inc \
+			-DTMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL=0x1U \
+ 			-D__USING_DP83865_PHY__
+
+EXTRA_PHY_FLAGS-$(CONFIG_EN2510_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Apollo/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/Common/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Common \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2510/en2510/GPL/Apollo \
+					-DAPOLLO_DRVR_SUPPORT
+
+EXTRA_PHY_FLAGS-$(CONFIG_EN2512_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Apollo/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/Common/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Common \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo \
+					-DAPOLLO_DRVR_SUPPORT
+
+EXTRA_PHY_FLAGS-y += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc \
+		     -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc \
+		     -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc
+
+EXTRA_CFLAGS := -Idrivers/net/LIPP_6300ETH/src \
+		-Idrivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/inc \
+		-Idrivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/tst/Tst1/inc1 \
+		-Idrivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/src \
+		-Idrivers/net/LIPP_6300ETH/comps/tmhwLIPP6100Eth/cfg \
+		-Idrivers/net/LIPP_6300ETH/intfs/ItmbslPhy/inc \
+		-Iinclude/net/LIPP_6300ETH \
+		-D__LIPP_6300ETH__ -D__LIPP_6300ETH_DEBUG__ $(EXTRA_PHY_FLAGS-y)
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,4288 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          gmac_drv.c %
+ * %pid_version:           1.2        %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:      Linux driver source file for LIPP_6100ETH ethernet subsystem
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/*--------------------------------------------------------------------------*/
+/* Standard include files:                                                  */
+/*--------------------------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/sockios.h>
+#include <linux/delay.h>
+#include <gmac_ioctl.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/highmem.h>
+#include <linux/dma-mapping.h>
+#include <linux/if_ether.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include "tmNxTypes.h"   /* Common include for HwApi & PHY device */
+#include "tmbslPhy.h"    /* Generic PHY header file */
+#include "tmhwLIPP6100Eth_Cfg.h" /* GMAC HwApi configuration header file */
+#include "tmhwLIPP6100Eth.h" /* GMAC HwApi header file */
+#include <gmac_drv.h>  /* Driver header & configuration file */
+#include <remap.h>
+#include <mach/gmac_eth_drv.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* Ethernet defines:                                                        */
+/*--------------------------------------------------------------------------*/
+
+#define DRV_NAME "LIPP_6300ETH"
+#define DRV_VERSION "1.2"
+#define DRV_RELDATE "2008/05/27"
+
+MODULE_AUTHOR("Library and IP Partnership");
+MODULE_DESCRIPTION("LIPP_6300ETH GMAC driver for Ethernet Subsystem" DRV_VERSION " " DRV_RELDATE);
+MODULE_LICENSE("GPL");
+
+/* Macros */
+#define NETDEV_PRIV( dev ) ( ( lipp_6300Eth_PRIV_t * ) netdev_priv( dev ) )
+
+#define SIZEOF_TX_DESCS(x) ( sizeof( TX_DESCR_t ) * (x) )
+
+#define SIZEOF_RX_DESCS(x) ( sizeof( RX_DESCR_t ) * (x) )
+
+spinlock_t moca_spinlock;
+void *moca_data_kernel_content ;
+extern int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+extern void Clnk_exit_dev( void *vdgcp );
+extern int ioctl_operation_work( void *moca_data_kernel_content, struct ifreq *ifr, unsigned cmd );
+extern void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr);
+extern tmbslPhyConfig_t gtmbslMoCAPhyInterface;
+/*--------------------------------------------------------------------------*/
+/* Function prototypes:                                                     */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_probe(struct platform_device *pdev);
+
+static __s32 lipp_6300Eth_remove(struct platform_device *pdev);
+
+static __s32 __init lipp_6300Eth_init_module( void ) ;
+
+static void __exit lipp_6300Eth_cleanup_module( void );
+
+/*--------------------------------------------------------------------------*/
+/* Standard driver handlers:                                                     */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_open(struct net_device *dev);
+
+static __s32 lipp_6300Eth_stop(struct net_device *dev);
+
+static __s32 lipp_6300Eth_hard_start_xmit(struct sk_buff *skb, \
+                                                struct net_device *dev);
+
+static void lipp_6300Eth_multicast_list(struct net_device *dev);
+
+//static __s32 lipp_6300Eth_set_mac_address(struct net_device *dev, void *addr);
+//static int lipp_6300Eth_change_mtu (struct net_device *dev, int new_mtu);
+static __s32 lipp_6300Eth_do_ioctl(struct net_device *dev, struct ifreq *ifr, \
+                                        __s32 cmd);
+
+static void lipp_6300Eth_tx_timeout_isr(struct net_device *dev);
+
+static void lipp_6300Eth_work_reset_link(struct work_struct *pWork);
+
+static struct net_device_stats* lipp_6300Eth_get_stats(struct net_device *dev);
+
+static void lipp_6300Eth_timer( unsigned long data ) ;
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+static __s32 lipp_6300Eth_napi(struct napi_struct *pNapi, __s32 budget);
+#endif
+
+#ifdef LIPP_6300ETH_VLAN_TAG
+static void lipp_6300eth_vlan_rx_register(struct net_device *dev, struct vlan_group *grp);
+#endif
+
+irqreturn_t lipp_6300Eth_isr( __s32 irq, void *dev_id) ;
+
+#ifdef ENABLE_ETH_TOOL
+/*--------------------------------------------------------------------------*/
+/* Extended Ethtool driver handlers:                                        */
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_ethtool_get_settings(struct net_device *dev, \
+                                                      struct ethtool_cmd *cmd);
+
+static __s32 lipp_6300Eth_ethtool_set_settings(struct net_device *dev, \
+                                                      struct ethtool_cmd *cmd);
+
+static void lipp_6300Eth_ethtool_get_drvinfo(struct net_device *dev, \
+                                                    struct ethtool_drvinfo *drvinfo);
+
+static void lipp_6300Eth_ethtool_get_pauseparam(struct net_device *dev, \
+                                            struct ethtool_pauseparam* pauseparam);
+
+static __s32 lipp_6300Eth_ethtool_set_pauseparam(struct net_device *dev, \
+                                             struct ethtool_pauseparam* pauseparam);
+
+static __u32 lipp_6300Eth_ethtool_get_link_status(struct net_device *dev);
+
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+static __u32 lipp_6300Eth_ethtool_get_rx_csum(struct net_device *dev);
+#endif
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* Internal functions prototypes:                                           */
+/*--------------------------------------------------------------------------*/
+static __s32 alloc_dma_descriptors( struct net_device *dev );
+static void free_dma_descriptors( lipp_6300Eth_PRIV_t * priv );
+static __s32 setup_dma_descriptors( lipp_6300Eth_PRIV_t * priv );
+static __s32 down_lipp_6300Eth( struct net_device *dev );
+static __s32 up_lipp_6300Eth( struct net_device *dev );
+static __s32 setup_phy( struct net_device *dev );
+static __s32 setup_mac( struct net_device *dev );
+static __s32 setup_filter_config( struct net_device *dev );
+static __s32 generate_crc(char *data, __s32 data_len);
+static void perfect_hash_filter_config( struct net_device *dev, \
+                                     ptmhwLIPP6100Eth_HashFilter_t rx_hash_filter );
+static __s32 is_mc_filtered_packet( struct net_device * dev, __u32 idx );
+static __s32 handle_receive_packets( struct net_device * dev, __s32 *pBudget);
+static void handle_tx_packets( struct net_device * dev);
+static __s32 check_n_enable_tx_flow_control( struct net_device *dev );
+static __s32 disable_tx_flow_control( struct net_device *dev );
+
+#ifdef __LIPP_6300ETH_DEBUG__
+/* Manipulate ARP & UDP data to run the UDP client/server application  in loopback mode */
+static void man_arp_udp_data(struct sk_buff * skb,__u32 len );
+#endif /* __LIPP_6300ETH_DEBUG__ */
+
+#ifdef CONFIG_PM
+/* Power Management functions */
+static int lipp_6300Eth_resume(struct platform_device *pdev);
+static int lipp_6300Eth_suspend(struct platform_device *pdev, pm_message_t state);
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* global variables used :                                                  */
+/*--------------------------------------------------------------------------*/
+
+/* Ethernet MAC address */
+static __u8 mac_addr[TMHWLIPP6100ETH_NUM_UNITS][6]={{0,0}};
+extern unsigned char stb_mac_address[2][6];
+
+/* Timer structure, for PHYs which doesnot support interrupt mechanism */
+static struct timer_list lipp_6300Eth_timer_struct[TMHWLIPP6100ETH_NUM_UNITS];
+
+#ifdef ENABLE_ETH_TOOL
+/* ethtool ioctl handlers. Refer Ethtool.h for other ioctls */
+static struct ethtool_ops lipp_6300Eth_ethtool_ops =
+{
+    .get_settings = lipp_6300Eth_ethtool_get_settings,
+    .set_settings = lipp_6300Eth_ethtool_set_settings,
+    .get_drvinfo = lipp_6300Eth_ethtool_get_drvinfo,
+    .get_pauseparam = lipp_6300Eth_ethtool_get_pauseparam,
+    .set_pauseparam = lipp_6300Eth_ethtool_set_pauseparam,
+    .get_link = lipp_6300Eth_ethtool_get_link_status,
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+    .get_rx_csum = lipp_6300Eth_ethtool_get_rx_csum,
+    .get_tx_csum = ethtool_op_get_tx_csum,
+#endif
+} ;
+#endif
+
+static const struct net_device_ops lipp_6300Eth_netdev_ops = {
+	.ndo_open		= lipp_6300Eth_open,
+	.ndo_stop		= lipp_6300Eth_stop,
+	.ndo_start_xmit		= lipp_6300Eth_hard_start_xmit,
+	.ndo_tx_timeout         = lipp_6300Eth_tx_timeout_isr,
+//	.ndo_change_mtu		= lipp_6300Eth_change_mtu,
+	.ndo_set_multicast_list	= lipp_6300Eth_multicast_list,
+//	.ndo_set_mac_address	= lipp_6300Eth_set_mac_address,
+	.ndo_do_ioctl		= lipp_6300Eth_do_ioctl,
+	.ndo_get_stats		= lipp_6300Eth_get_stats,
+#ifdef LIPP_6300ETH_VLAN_TAG
+	.ndo_vlan_rx_register = lipp_6300eth_vlan_rx_register,
+#endif	
+};
+
+/* Global pointer to get the PHY function pointers */
+static tmbslPhyConfig_t * gpPhyInterface[TMHWLIPP6100ETH_NUM_UNITS];
+
+/**
+* Ethernet LIPP_6300ETH driver registration
+*/
+static struct platform_driver lipp_6300eth_driver =
+{
+    .probe      = lipp_6300Eth_probe,
+    .remove     = lipp_6300Eth_remove,
+#ifdef CONFIG_PM
+	.suspend	= lipp_6300Eth_suspend,
+	.resume		= lipp_6300Eth_resume,
+#endif
+    .driver     =   {
+                        .name   = "LIPP_6300ETH",
+                        .owner  = THIS_MODULE,
+                    }
+
+};
+
+/* Flag to check if the MAC address is chosen from kernel command line */
+static __u32 mac_addr_set[TMHWLIPP6100ETH_NUM_UNITS]={0};
+
+static int macIdx=0;
+
+/* FUNCTION: lipp_6300Eth_init_mac0:
+ * DESCRIPTION: For accepting the MAC address from kernel command line
+ * RETURN:
+ *
+ * NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+
+static int __init lipp_6300Eth_init_mac0(char *line)
+{
+    unsigned int mac_temp[6];
+    int i;
+    sscanf (line, "%x:%x:%x:%x:%x:%x",
+    &mac_temp[0], &mac_temp[1], &mac_temp[2],
+    &mac_temp[3], &mac_temp[4], &mac_temp[5]);
+
+    for (i = 0; i < 6; i++)
+    {
+        mac_addr[macIdx][i] = mac_temp[i];
+    }
+
+    /* Static value to copy the next MAC addrress from cmd line */
+    mac_addr_set[macIdx++] = 1;
+
+    return 1;
+
+}
+
+/* FUNCTION: lipp_6300Eth_init_mac1:
+ * DESCRIPTION: For accepting the MAC address from kernel command line
+ * RETURN:
+ *
+ * NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+
+static int __init lipp_6300Eth_init_mac1(char *line)
+{
+    unsigned int mac_temp[6];
+    int i;
+
+    sscanf (line, "%x:%x:%x:%x:%x:%x",
+    &mac_temp[0], &mac_temp[1], &mac_temp[2],
+    &mac_temp[3], &mac_temp[4], &mac_temp[5]);
+
+    for (i = 0; i < 6; i++)
+    {
+        mac_addr[macIdx][i] = mac_temp[i];
+    }
+
+    /* Static value to copy the next MAC addrress from cmd line */
+    mac_addr_set[macIdx++] = 1;
+
+    return 1;
+}
+
+__setup("6300mac0=",lipp_6300Eth_init_mac0);
+__setup("6300mac1=",lipp_6300Eth_init_mac1);
+
+
+/* FUNCTION: lipp_6300Eth_init_module:
+ * DESCRIPTION: Register ethernet driver as platform driver
+ * RETURN:
+ *  0 on  Success, Non-zero value on Error
+ *
+ * NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 __init lipp_6300Eth_init_module( void )
+{
+
+    return platform_driver_register(&lipp_6300eth_driver);
+
+}
+
+/* FUNCTION:	lipp_6300Eth_cleanup_module:
+ * DESCRIPTION:  This function is called wth the driver is unloaded
+ * RETURN:
+ *	 None
+ *
+ * NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+static void __exit lipp_6300Eth_cleanup_module( void )
+{
+    platform_driver_unregister(&lipp_6300eth_driver);
+
+}
+
+/*--------------------------------------------------------------------------*/
+/* Control functions:                                                                                              */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * FUNCTION:	lipp_6300Eth_probe:
+ *  DESCRIPTION:	This function will initializes the hardware and registers the
+ *	device with the kernel, stores the corresponding device paramter information in private
+ *     structure.
+ * RETURN:
+ *	0	- success
+ *	ENXIO	- IO error
+ *	ENOMEM	- Memory allocation failure
+ *	EINVAL	- Invalid arguments
+ *
+ * NOTES:
+ **
+ */
+
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_probe(struct platform_device *pdev)
+{
+    struct net_device *	      dev = NULL;
+    lipp_6300Eth_PRIV_t *    priv ;
+    __s32                      ret_val ;
+    __u32 unitNum = pdev->id;
+	pgmac_platform_data_t pPlatData=NULL;
+	tmhwLIPP6100Eth_PhyInfo_t phyInfo;
+	__u8 *pMacAdr=NULL;
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+    __u32 hwVer;
+#endif
+
+    dev = alloc_etherdev(sizeof( lipp_6300Eth_PRIV_t));
+
+    if( NULL == dev )
+    {
+        GMAC_PRINT_ERR("Unable to allocate etherdev, aborting\n");
+        ret_val = -ENOMEM ;
+        goto _dev_alloc_failed;
+    }
+
+    SET_NETDEV_DEV(dev, &pdev->dev);
+
+    /* Store the network device structure */
+    platform_set_drvdata(pdev, dev);
+
+    /* To fetch platform data like clk_csr, phy addr & MAC address */
+    pPlatData = pdev->dev.platform_data;
+
+    /* Remap base addresses for HwApi base addresses */
+    ret_val = remapBaseAdrs(pdev);
+
+    if(0 != ret_val)
+    {
+        GMAC_PRINT_ERR("Error in Remapped Base Addresses\n");
+        goto _abort_init;
+    }
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+    tmhwLIPP6100Eth_GetHWVersion(unitNum,(pUInt32)&hwVer);
+    GMAC_PRINT_DBG("HwVersion: %x\n",hwVer);
+#endif
+
+    phyInfo.clkCsrVal = pPlatData->clk_csr_val;
+    if ( tmhwLIPP6100Eth_get_phyInfo(unitNum, &phyInfo.phyID, &phyInfo.phyAddr) != TM_OK)
+    {
+        GMAC_PRINT_ERR("Ethernet PHY H/W not found, aborting GMAC%d\n", unitNum);
+        ret_val = -ENXIO ;
+        goto _abort_init;
+    }
+
+    pMacAdr = &pPlatData->mac_addr[0];
+
+    /* Initialize the ethernet MAC, do a reset */
+    if( tmhwLIPP6100Eth_Init(unitNum,&phyInfo, unitNum? GMAC1_MII_SEL:GMAC0_MII_SEL) != TM_OK )
+    {
+        GMAC_PRINT_ERR("Error in Ethernet MAC H/W initialization, aborting\n");
+        ret_val = -ENXIO ;
+        goto _abort_init;
+    }
+
+    /* Get the PHY interface function pointers */
+    tmbslPhyGetInterface(unitNum, phyInfo.phyID, pPlatData->isExternal , &gpPhyInterface[unitNum]);
+
+    GMAC_STAT_PRINT("%s PHY being used with GMAC%d\n",
+                    gpPhyInterface[unitNum]->phyName,unitNum);
+
+    /* Register interrupts, after MAC is reset. PHY is reset in open fun */
+    ret_val = registerInterrupts(pdev);
+
+    if(0 != ret_val)
+    {
+        GMAC_PRINT_ERR("Error while registering ethernet ISRs\n");
+        goto _abort_init_int;
+    }
+
+    /* If MAC address is set from the command line, change the ptr */
+    if(mac_addr_set[unitNum] == 1U )
+    {
+         pMacAdr = &mac_addr[unitNum][0];
+    }
+    else /* If the MAC address is not in command line, look for ATAG list */
+    {
+         pMacAdr = &stb_mac_address[unitNum][0];
+    }
+
+    /* MAC address is not set in kernel cmd line.Set the default ones*/
+    memcpy(dev->dev_addr,pMacAdr,ETH_ALEN);
+
+    if (!is_valid_ether_addr(dev->dev_addr))
+	    GMAC_PRINT_ERR("\tNo valid MAC address;"
+		    "please, use ifconfig or fix MAC Address!\n");
+
+    /* Get pointer to private structure */
+    priv = netdev_priv(dev);
+
+    /* zero out the private structure */
+    memset(priv, 0x00, sizeof(lipp_6300Eth_PRIV_t )) ;
+
+    /* Fill in the fields of the device structure with Ethernet-generic values. */
+    ether_setup(dev);
+
+    /*
+    * Initialize the timer, that checks the status of the link for every 500 ms
+    * report any error to the kernel
+    */
+    lipp_6300Eth_timer_struct[unitNum].function = lipp_6300Eth_timer;
+
+    lipp_6300Eth_timer_struct[unitNum].data = (__u32)dev;
+
+    lipp_6300Eth_timer_struct[unitNum].expires = jiffies + TIMEOUT_VALUE;
+
+    /* Store the hardware device unit number */
+    priv->hwUnitNum = unitNum;
+
+    priv->phy_timer = &lipp_6300Eth_timer_struct[unitNum];
+
+    init_timer(&lipp_6300Eth_timer_struct[unitNum]);
+
+    spin_lock_init( &priv->lock ) ;
+
+    priv->u_autoneg = ETH_AUTO_NEGOTIATION;
+    priv->u_speed = pPlatData->max_speed;
+    priv->clk_csr_val = pPlatData->clk_csr_val;
+    priv->phy_addr_val = phyInfo.phyAddr;
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+    priv->enable_mac_loopback=0;
+    priv->enable_phy_loopback =0;
+    #endif
+
+    priv->u_mode = ETH_LINK_MODE ;
+    priv->u_flow_control = ETH_FLOW_CTRL ;
+    priv->u_rx_tx_fc = ETH_FLOW_CTRL_DIR;
+
+    /* Rx Frame size should be multiple of 4/8/16 depending on bus width */
+    priv->u_rx_buf_size = MAX_ETH_FRAME_SIZE ;
+
+    /* When set, doesnot pass through the multicast filtering */
+    priv->u_all_multi = MULTICAST_FILTER ;
+
+    /* Hardware or software filtering */
+    priv->u_mc_filter_type = ETH_FILTER_TYPE ;
+
+    priv->dma_enabled = 0;
+    dev->if_port = PORT_MII;
+
+    /* Set this macro to enable/disable */
+    priv->enable_jumbo = ETH_ENABLE_JUMBO_FRAME;
+
+    if(priv->enable_jumbo == 1U)
+    {
+        /* Set the receive buffer size to multiple of bus-width */
+        if ( (LIPP_6300ETH_JUMBO_MTU & (~DMA_DESC_ALIGNMENT))
+            != LIPP_6300ETH_JUMBO_MTU )
+        {
+            priv->u_rx_buf_size =
+                        (LIPP_6300ETH_JUMBO_MTU & (~DMA_DESC_ALIGNMENT)) +
+                         DMA_DESC_ALIGNMENT +1;
+        }
+
+    }
+
+    /* assign the driver handlers */
+	dev->netdev_ops = &lipp_6300Eth_netdev_ops;
+
+    dev->watchdog_timeo = TX_TIMEOUT;
+
+    priv->autoNegWork.pNetDev = dev;
+
+    INIT_WORK(&priv->autoNegWork.workq,lipp_6300Eth_work_reset_link);
+
+    priv->wdTimeoutTxWork.pNetDev = dev;
+    INIT_WORK(&priv->wdTimeoutTxWork.workq,lipp_6300Eth_work_reset_link);
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+    priv->napiInfo.pDev = dev;
+
+    netif_napi_add(dev,&priv->napiInfo.napi,lipp_6300Eth_napi,NAPI_DEV_WEIGHT);
+#endif
+
+#ifdef LIPP_6300ETH_VLAN_TAG
+    /* Supports receive VLAN Tag filtering */
+    dev->features = NETIF_F_HW_VLAN_RX;
+#endif
+
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+    /* Can checksum TCP/UDP packets over IPv4 & IPv6 */
+    //dev->features |= NETIF_F_ALL_CSUM | NETIF_F_SG ;
+    dev->features |= NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;
+#endif /* CONFIG_LIPP_6300ETH_CSUMOFFLOAD */
+
+#ifdef ENABLE_ETH_TOOL
+    dev->ethtool_ops = &lipp_6300Eth_ethtool_ops;
+#endif
+
+    /* Receive all multicast packets */
+    dev->flags |= IFF_ALLMULTI;
+
+    /* Pass all frames */
+    if( ETH_PROMISC_MODE == LX_PROMISC_ENABLED )
+    {
+        dev->flags |= IFF_PROMISC ;
+    }
+    else
+    {
+        dev->flags &= ~(IFF_PROMISC) ;
+    }
+
+    dev->base_addr = 0 ;
+
+    if (register_netdev(dev) != 0)
+    {
+
+        GMAC_PRINT_ERR("Unable to register the network device, aborting\n");
+        ret_val = -ENXIO ;
+        goto _abort_init;
+    }
+
+    /* For woL support */
+    init_waitqueue_head(&priv->waitQ);
+
+    if (!memcmp(gpPhyInterface[priv->hwUnitNum]->phyName,gtmbslMoCAPhyInterface.phyName, sizeof(gtmbslMoCAPhyInterface.phyName)))
+    {       
+        dk_context_t *dkcp ;
+        dd_context_t *ddcp ;
+
+        moca_data_kernel_content = kzalloc(sizeof(dk_context_t) + sizeof(dd_context_t), GFP_KERNEL);
+        if( moca_data_kernel_content ) {
+            dkcp = (dk_context_t *)moca_data_kernel_content ;
+            ddcp = (dd_context_t *)(((char *)moca_data_kernel_content)+sizeof(dk_context_t)) ;
+            dkcp->priv = (void *)ddcp ;
+            dkcp->name = DRV_NAME ;    // like net_device
+
+            spin_lock_init(&moca_spinlock);
+            Clink_update_unitnum_phyaddr(priv->hwUnitNum, priv->phy_addr_val);
+	    if(dkcp && ddcp)
+            {
+               ret_val = Clnk_init_dev( &(ddcp->p_dg_ctx), ddcp, dkcp, (unsigned long)NULL );
+               if ( ret_val )
+               {
+                   GMAC_PRINT_ERR("EMAC Clnk_init_dev err=%d.\n", ret_val);
+               }
+            }
+        }
+    }
+
+    GMAC_STAT_PRINT("Ethernet interface %s registered\n",dev->name);
+
+    return 0 ;
+
+_abort_init_int:
+    unregisterInterrupts(pdev);
+
+_abort_init:
+
+    GMAC_PRINT_ERR("Aborting Driver Initialization\n");
+
+    unmapBaseAdrs(pdev);
+
+    /* Free the netdevice structure */
+    free_netdev(dev);
+
+_dev_alloc_failed:
+
+    return ret_val;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:    lipp_6300Eth_remove:
+ * DESCRIPTION: This function will un-initialize the hardware and unregisters the net_device structure
+ *                      and frees the memory for device structure
+ *
+ * RETURN:      None
+ *
+ * NOTES: This function is called when the driver needs to be unloaded from the system.
+ *            Ex: Call to 'rmmod' removes the loadable module from the system and this function
+ *             is invoked at that point.
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_remove(struct platform_device *pdev)
+
+{
+    __u32 unitNum = pdev->id ;
+    struct net_device * dev;
+    lipp_6300Eth_PRIV_t *    priv ;
+
+    dev = dev_get_drvdata(&pdev->dev);
+    priv = NETDEV_PRIV(dev);
+
+    /* Deinit the PHY device */
+    gpPhyInterface[unitNum]->deinitFunc(unitNum);
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+    tmhwLIPP6100Eth_Deinit(unitNum);
+#endif
+
+    if (!memcmp(gpPhyInterface[unitNum]->phyName,gtmbslMoCAPhyInterface.phyName, sizeof(gtmbslMoCAPhyInterface.phyName)))
+    {
+        dk_context_t *dkcp ;
+        dd_context_t *ddcp ;
+
+        if( moca_data_kernel_content ) {
+            dkcp = (dk_context_t *)moca_data_kernel_content ;
+            ddcp = (dd_context_t *)(((char *)moca_data_kernel_content)+sizeof(dk_context_t)) ;
+            Clnk_exit_dev( &ddcp->p_dg_ctx );
+	    kfree(moca_data_kernel_content);
+        }
+    }
+
+    netif_carrier_off(dev);
+
+    /* Unregister the network device */
+    unregister_netdev(dev) ;
+
+    /* Unmap base address */
+    unmapBaseAdrs(pdev);
+
+    unregisterInterrupts(pdev);
+
+    /* Free the memory for device structure */
+    free_netdev(dev);
+
+    return 0;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:	alloc_dma_descriptors
+ * DESCRIPTION: This function allocates the memory required for transmit and receive descriptors,
+ * allocates SKBs to store received ethernet frames . If memory is not allocated successfully,
+ * it frees the memory allocated.
+ *
+ * PARAMETERS:
+ * 	priv	- lipp_6300Eth_PRIV_t private structure
+ * RETURN:	0 - success
+ *                -ENOMEM - on failure
+ * NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 alloc_dma_descriptors( struct net_device *dev )
+{
+    __s32 i=0;
+    lipp_6300Eth_PRIV_t * priv = netdev_priv(dev) ;
+
+    /* Virtual Adr for transmission */
+    priv->p_vtx = dma_alloc_coherent( NULL,
+    					SIZEOF_TX_DESCS( HW_DESCR_QUEUE_LEN_TX) + DMA_DESC_ALIGNMENT,
+    					&priv->p_tx, /* Physical address for transmission */
+    					GFP_KERNEL ) ;
+
+    /* Virtual Adr for reception */
+    priv->p_vrx = dma_alloc_coherent( NULL,
+    					SIZEOF_RX_DESCS( HW_DESCR_QUEUE_LEN_RX) + DMA_DESC_ALIGNMENT,
+    					&priv->p_rx, /* Physical address for reception */
+    					GFP_KERNEL ) ;
+
+    if( ( NULL ==  priv->p_vtx ) || ( NULL ==  priv->p_vrx ) )
+    {
+        goto _free_txrx_mem ;
+    }
+
+    GMAC_PRINT_DBG("p_vtx:%08x p_tx: %08x\n",(unsigned int)priv->p_vtx, priv->p_tx);
+    GMAC_PRINT_DBG("p_vrx:%08x p_rx: %08x\n",(unsigned int)priv->p_vrx, priv->p_rx);
+
+    /* memory is allocated, just align the physical addresses and assign.
+        ** it to lipp_6300Eth_PRIV_t->p_[rt]x_* members
+        */
+
+    /* The descriptors need to be aligned to the bus width. The descriptors are aligned to
+        **  128bits. ( Descriptor Address should be divisible by 16)
+        */
+    priv->p_vtx_descr = (TX_DESCR_t *)(((__u32)priv->p_vtx + DMA_DESC_ALIGNMENT) & \
+                                        (~DMA_DESC_ALIGNMENT));
+    priv->p_tx_descr  = (dma_addr_t)(((__u32)priv->p_tx + DMA_DESC_ALIGNMENT) & \
+                                        (~DMA_DESC_ALIGNMENT));
+    priv->p_vrx_descr = (RX_DESCR_t *)(((__u32)priv->p_vrx + DMA_DESC_ALIGNMENT) & \
+                                        (~DMA_DESC_ALIGNMENT));
+    priv->p_rx_descr = (dma_addr_t)(((__u32)priv->p_rx + DMA_DESC_ALIGNMENT) & \
+                                        (~DMA_DESC_ALIGNMENT));
+
+    GMAC_PRINT_DBG("priv->p_vtx_descr:%08x p_tx: %08x\n",(unsigned int)priv->p_vtx_descr, priv->p_tx);
+    GMAC_PRINT_DBG("priv->p_vrx_descr:%08x p_rx: %08x\n",(unsigned int)priv->p_vrx_descr, priv->p_rx);
+
+  /*
+    * Now allocate memory for RX ethernet buffers
+    * for poll mode : RX ethernet buffer with size of 1536 bytes using dma_alloc_coherent()
+    * and store the physical address into RX_DESCR_t[index]->packet, and store the virtual address
+    * into priv->rx_skb_list[index].
+    * [for interrupt mode] : Rx SKBs with MTU size of 1536+2 bytes using alloc_skb()
+    * and store the physical address of SKB->data() into RX_DESCR_t[index]->packet, and store the
+    * SKB address into priv->rx_skb_list[index].
+    */
+
+    /* Interrupt Mode */
+    /* Allocate SKB memory buffers and store them in the arry priv->p_vrx_skb_list[] */
+	for( i =0  ; i < HW_DESCR_QUEUE_LEN_RX ; i++ )
+	{
+		priv->p_vrx_skb_list[ i ] = netdev_alloc_skb_ip_align(dev, priv->u_rx_buf_size);
+
+		if( NULL == priv->p_vrx_skb_list[ i ] )
+		{
+			/* free up the memory allocated for SKBs */
+			goto _free_rx_skb_list ;
+		}
+		
+
+	}
+
+	return 0 ;
+
+_free_rx_skb_list:
+
+    for( --i ; i >= 0 ; i-- )
+    {
+        dev_kfree_skb( priv->p_vrx_skb_list[ i ] ) ;
+    }
+
+_free_txrx_mem:
+
+    if( priv->p_vtx != NULL )
+    {
+        dma_free_coherent( NULL,
+                                SIZEOF_TX_DESCS( HW_DESCR_QUEUE_LEN_TX),
+                                priv->p_vtx,
+                                priv->p_tx ) ;
+    }
+
+    if( priv->p_vrx != NULL )
+    {
+        dma_free_coherent( NULL,SIZEOF_RX_DESCS( HW_DESCR_QUEUE_LEN_RX),
+                                    priv->p_vrx,
+                                    priv->p_rx ) ;
+    }
+
+    return -ENOMEM ;
+
+}
+
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:    free_dma_descriptors
+ * DESCRIPTION: This function frees the memory allocated for transmit and receive descriptors,
+ * SKBs allocated for receiving ethernet frames, transmit frames queued but not yet transmitted.
+ *
+ * PARAMETERS:
+ * 	priv	- lipp_6300Eth_PRIV_t private structure
+ * RETURN:	None
+ * NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static void free_dma_descriptors( lipp_6300Eth_PRIV_t * priv )
+{
+
+    __s32 i =	0 ;
+
+    /* free the SKBs allocated and the ethernet buffers */
+
+    for( i = 0 ; i < HW_DESCR_QUEUE_LEN_RX ; i++ )
+    {
+        if(priv->p_vrx_skb_list[i] != NULL )
+        {
+            dev_kfree_skb_any(priv->p_vrx_skb_list[ i ]) ;
+        }
+    }
+
+    /* free the SKBs which are pending for transmission */
+    for( i = 0 ; i < HW_DESCR_QUEUE_LEN_TX ; i++ )
+    {
+        if( priv->p_vtx_skb_list[ i ] )
+        {
+            dev_kfree_skb_any( priv->p_vtx_skb_list[ i ] ) ;
+        }
+    }
+
+    /* free the memory allocated to RX, TX descriptors */
+    if( priv->p_vtx != NULL )
+    {
+        dma_free_coherent( NULL,
+        SIZEOF_TX_DESCS( HW_DESCR_QUEUE_LEN_TX),
+        priv->p_vtx,
+        priv->p_tx ) ;
+    }
+
+    if( priv->p_vrx != NULL )
+    {
+        dma_free_coherent( NULL,
+        SIZEOF_RX_DESCS( HW_DESCR_QUEUE_LEN_RX),
+        priv->p_vrx,
+        priv->p_rx ) ;
+    }
+
+    return  ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION: setup_dma_descriptors
+ * DESCRIPTION:	This function initializes Transmit and Receive descriptors for DMA
+ * PARAMETERS:
+ * 	priv	- lipp_6300Eth_PRIV_t private structure
+ * RETURN:
+ * 0 - success
+ * NOTES: Forms TX & RX DMA descriptor ring, enables/disables interrupt on
+ * frame transmission/ reception.
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 setup_dma_descriptors( lipp_6300Eth_PRIV_t * priv )
+{
+
+     __s32 i;
+
+    /* Initialize the Tx & Rx Descriptor indices */
+    priv->tx_produce_index = 0;
+    priv->tx_consume_index = 0;
+    priv->rx_consume_index = 0;
+    priv->tx_submit_count =0;
+
+    /*Clear the TX descriptors */
+    memset(priv->p_vtx_descr,0,sizeof(TX_DESCR_t)*HW_DESCR_QUEUE_LEN_TX);
+
+    /* Set the Transmit End of Ring bit */
+    #ifdef __ENHANCED_DESCRIPTOR__
+    priv->p_vtx_descr[HW_DESCR_QUEUE_LEN_TX-1].TDES0|= TXDESC_TDES0_END_OF_RING_VAL;
+    #else
+    priv->p_vtx_descr[HW_DESCR_QUEUE_LEN_TX-1].TDES1 |= TXDESC_TDES1_END_OF_RING_VAL;
+    #endif /* __ENHANCED_DESCRIPTOR__ */
+
+    /*Clear the RX descriptors */
+    memset(priv->p_vrx_descr,0,sizeof(RX_DESCR_t)*HW_DESCR_QUEUE_LEN_RX);
+
+    for(i=0;i<HW_DESCR_QUEUE_LEN_RX;i++)
+    {
+
+        /* Only Buffer1 is utilized. Assign the physical address of the buffer
+        ** to descriptor
+        */
+        priv->p_vrx_descr[i].RDES2 = (__u32) dma_map_single( NULL,
+        					(priv->p_vrx_skb_list[i])->data,
+        					priv->u_rx_buf_size,
+        					DMA_FROM_DEVICE );
+
+        /* Set the own bit. DMA can process the descriptors only with own bit set */
+        priv->p_vrx_descr[i].RDES0 |= RXDESC_RDES0_OWN_VAL;
+        priv->p_vrx_descr[i].RDES1 |= priv->u_rx_buf_size;
+    }
+
+    /* Set the end of ring bit & length field */
+    priv->p_vrx_descr[i-1].RDES1 |= RXDESC_RDES1_END_OF_RING_VAL;
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------
+ * FUNCTION: down_lipp_6300Eth:
+ * DESCRIPTION: This function disables the TX and RX path and frees up the SKBs
+ * which are not transmitted and zeros out all TX status and RX status for all DMA descriptors
+ * PARAMETERS:
+ *    dev - net_device structure for the device
+ * RETURN:
+ *  0 - success
+ * -1 - Failure
+ * NOTES: netif_carrier_off() and netif_stop_queue() should be called before invoking the function
+ *
+ *--------------------------------------------------------------------------*/
+ static __s32 down_lipp_6300Eth( struct net_device *dev )
+{
+    __s32 i = 0 ;
+    unsigned long flags ;
+    tmhwLIPP6100Eth_EnTxfr_t txfr;
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+    tmhwLIPP6100Eth_Int_t IntDis;
+
+    GMAC_PRINT_DBG("down_lipp_6300Eth called for %s\n", dev->name);
+
+    local_irq_save( flags );
+
+    IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntDis.gmacIntVal = GMAC_INT_MASK_VAL;
+
+    /* Disable all the interrupts */
+    tmhwLIPP6100Eth_IntDisable( priv->hwUnitNum,&IntDis);
+
+    local_irq_restore( flags ) ;
+
+    txfr.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+    txfr.enFlag = tmhwLIPP6100Eth_Disable;
+
+    /* Disable DMA and GMAC state machines */
+    tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfr);
+    tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfr);
+
+    /* This flag is set to 1 during transmission once */
+    priv->dma_enabled =0;
+
+    for( i = 0 ; i < HW_DESCR_QUEUE_LEN_TX ; i++ )
+    {
+        /* Free all the Tx SKB buffers */
+        if( priv->p_vtx_skb_list[ i ] != NULL )
+        {
+            dev_kfree_skb( priv->p_vtx_skb_list[ i ] ) ;
+            priv->p_vtx_skb_list[ i ] = NULL ;
+            priv->stats.tx_dropped ++ ;
+        }
+
+        /* Clear the transmit status */
+        priv->p_vtx_descr[ i ].TDES0 = 0;
+    }
+
+    #ifdef __ENHANCED_DESCRIPTOR__
+    /* Set the end of ring bit */
+    priv->p_vtx_descr[ i-1 ].TDES0 |= TXDESC_TDES0_END_OF_RING_VAL;
+    #endif /* __ENHANCED_DESCRIPTOR__ */
+
+    for( i = 0 ; i < HW_DESCR_QUEUE_LEN_RX ; i++ )
+    {
+        /* Clear the receive status, dont clear the OWN bit */
+        priv->p_vrx_descr[ i ].RDES0 = RXDESC_RDES0_OWN_VAL;
+
+    }
+
+    /* Reset all the indices */
+    priv->rx_consume_index = 0;
+    priv->tx_consume_index = 0;
+    priv->tx_produce_index = 0;
+    priv->tx_submit_count = 0;
+
+    /* Delete the timer */
+    del_timer( priv->phy_timer );
+
+    return 0 ;
+
+}
+
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION: up_lipp_6300Eth
+ *DESCRIPTION: This function sets up the hardware (PHY and MAC) and enables it for
+ * reception of ethernet frames
+ *PARAMETERS:
+ * dev - net_device structure for the device
+ *RETURN:
+ * 0 - success
+ * -1 - Failure
+ *NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 up_lipp_6300Eth( struct net_device *dev )
+{
+    unsigned long flags ;
+    tmhwLIPP6100Eth_EnTxfr_t Txfer;
+    __s32 ret_val;
+    __u32 Status;
+    tmhwLIPP6100Eth_Int_t IntEn;
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+
+    GMAC_PRINT_DBG("up_lipp_6300Eth called for %s\n", dev->name);
+
+    /* Normal operation of the driver  */
+    /* Do autonegotiation or setup the PHY parameters to fixed values */
+    if( setup_phy(dev) != 0 )
+    {
+        GMAC_PRINT_ERR("Error while Setting up PHY\n");
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    /* depending upon the options set in the dev structure, set the device parameters */
+    if( setup_mac( dev ) != 0 )
+    {
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    /* setup the filter configuration */
+    if( setup_filter_config( dev ) != 0 )
+    {
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    local_irq_save( flags ) ;
+
+    if( tmhwLIPP6100Eth_IntClear( priv->hwUnitNum, DMA_CLR_ALL_INTS )  != TM_OK )
+    {
+        local_irq_restore( flags ) ;
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    IntEn.dmaIntVal =  TX_INTR_VAL | RX_INTR_VAL;
+    IntEn.gmacIntVal =0x0;
+
+    if(tmhwLIPP6100Eth_IntEnable(priv->hwUnitNum,&IntEn) != TM_OK )
+    {
+        local_irq_restore( flags ) ;
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    /* Disable unnecessary interrupts */
+    IntEn.dmaIntVal = ERE_ETE_INT_VAL;
+    IntEn.gmacIntVal = GMAC_INT_MASK_VAL;
+    tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntEn);
+
+    local_irq_restore( flags ) ;
+
+    Txfer.dirFlag = tmhwLIPP6100Eth_Dir_Rx;
+    Txfer.enFlag = tmhwLIPP6100Eth_Enable;
+
+    /* Reads the register and sets the corresponding bit */
+    ret_val = tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&Txfer);
+
+    if(ret_val != TM_OK)
+    {
+        local_irq_restore( flags ) ;
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    ret_val = tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&Txfer);
+
+    if(ret_val != TM_OK)
+    {
+        goto _err_up_lipp_6300Eth ;
+    }
+
+    /* If the receive process is in suspended state, write to receive poll demand register
+        ** to start reception
+        */
+    tmhwLIPP6100Eth_IntGetStatus(priv->hwUnitNum,&IntEn);
+
+    Status = IntEn.dmaIntVal;
+
+    if(((Status & TMHW_LIPP6100ETH_DMA_STATUS_RS_NO_RXDESC_VAL) >> 17) == 0x4)
+    {
+        tmhwLIPP6100Eth_DmaPollDesc(priv->hwUnitNum,tmhwLIPP6100Eth_Dir_Rx);
+    }
+
+    /* Set the link to up state. Used in timer for checking link status */
+    priv->linkStatus = 1;
+
+    /* Initialize timer to check the link status */
+    priv->phy_timer->expires = jiffies + TIMEOUT_VALUE ;
+
+    add_timer( priv->phy_timer) ;
+
+    return(0);
+
+_err_up_lipp_6300Eth:
+
+    Txfer.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+    Txfer.enFlag = tmhwLIPP6100Eth_Disable;
+
+    /* error in hardware.. Try to disable the hardware and return an error */
+    tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&Txfer);
+    tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&Txfer);
+
+    IntEn.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntEn.gmacIntVal = GMAC_INT_MASK_VAL;
+
+    tmhwLIPP6100Eth_IntDisable( priv->hwUnitNum,&IntEn) ;
+
+    GMAC_PRINT_ERR("Unable to setup the hardware, disabling the hardware and aborting\n");
+
+    return -1 ;
+
+}
+
+/*--------------------------------------------------------------------------
+ * FUNCTION: setup_phy:
+ * DESCRIPTION: This function sets up the PHY hardware depending on the options
+ * chosen and performs autonegotiation or forced usage of a particular speed and duplex mode
+ * PARAMETERS:
+ * dev - net_device structure for the device
+ * RETURN:
+ *  0 - success
+ * -1 - Failure
+ * NOTES:       None
+ *--------------------------------------------------------------------------
+ */
+
+static __s32 setup_phy( struct net_device *dev )
+{
+    __s32 i = 0 ;
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+    tmbslPhyBasicModeStatus_t  bms ;
+    tmbslPhyBasicModeControl_t bmc ;
+    tmbslPhyAutoNegotiationMask_t auto_neg_mask ;
+    tmErrorCode_t ret_val;
+
+    GMAC_PRINT_DBG("setup_phy called for %s\n", dev->name);
+
+    memset(&auto_neg_mask,0,sizeof(tmbslPhyAutoNegotiationMask_t));
+
+    /* Bring the PHY out of reset / do software reset / enable clocks to MAC */
+    ret_val = gpPhyInterface[priv->hwUnitNum]->initFunc(priv->hwUnitNum);
+
+    if(ret_val != TM_OK )
+    {
+        GMAC_PRINT_ERR("Error in PHY H/W init,ERR:%x\n\n",(__u32)ret_val);
+        ret_val = -ENXIO ;
+    }
+
+    /*
+    * Now check the parameters that are stored in private structure and
+    * accordingly configure the Phy and Mac
+    */
+
+    /* Common parameters. Enabling the mask disables the feature */
+    auto_neg_mask.mask100BaseT4 = tmbslPhyEnable;
+    auto_neg_mask.masknextPageDesired = tmbslPhyEnable;
+    auto_neg_mask.protocolSel = tmbslPhyIEEE8023;
+    auto_neg_mask.maskRemoteFault = tmbslPhyEnable;
+
+    /* Disable 1Gig Support */
+    auto_neg_mask.mask1000BaseTFullDuplexSupport = tmbslPhyEnable;
+    auto_neg_mask.mask1000BaseTHalfDuplexSupport = tmbslPhyEnable;
+
+    priv->autoneg_adv = ADVERTISED_Autoneg |
+                        ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half |
+                        ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half;
+
+    if( priv->u_autoneg == LX_AUTONEG_ENABLE )
+    {
+#if 0
+
+        if(LX_SPEED_10 == priv->u_speed)
+        {
+            auto_neg_mask.mask100BaseTxFullDuplexSupport = tmbslPhyEnable;
+            auto_neg_mask.mask100BaseTxSupport = tmbslPhyEnable;
+            priv->autoneg_adv &= ~(ADVERTISED_100baseT_Full |
+                                   ADVERTISED_100baseT_Half );
+        }
+        if(LX_MODE_HALF_DUPLEX == priv->u_mode)
+        {
+
+            if(LX_SPEED_10 == priv->u_speed)
+            {
+                /* Mask 10Mbps Full duplex */
+                auto_neg_mask.mask10BaseTFullDuplexSupport = tmbslPhyEnable;
+                priv->autoneg_adv &= ~ADVERTISED_10baseT_Full;
+            }
+            else if(LX_SPEED_100 == priv->u_speed)
+            {
+                /* Mask 100Mbps Full duplex */
+                auto_neg_mask.mask100BaseTxFullDuplexSupport = tmbslPhyEnable;
+                priv->autoneg_adv &= ~ADVERTISED_100baseT_Full;
+
+            }
+            else
+            {
+            }
+        }
+#endif
+
+
+        /* autonegotiate for three times. If every time it fails, then set fixed values */
+        for( i = 0 ; i < AUTO_NEG_RETRY_COUNT ; i++ )
+        {
+            ret_val =  gpPhyInterface[priv->hwUnitNum]->autoNegotiateFunc( priv->hwUnitNum, &auto_neg_mask);
+
+            if(TM_OK ==  ret_val || TMBSL_ERR_PHY_NOT_SUPPORTED == ret_val)
+            {
+                break;
+            }
+            GMAC_PRINT_ERR("Retrying Auto-Negotiation\n");
+
+        }
+
+        if((TM_OK != ret_val) && (TMBSL_ERR_PHY_NOT_SUPPORTED != ret_val))
+        {
+            GMAC_PRINT_ERR("Auto Negotiation Failed\n");
+        }
+        else if( TMBSL_ERR_PHY_NOT_SUPPORTED == ret_val )
+        {
+            GMAC_PRINT_ERR("Auto Negotiation Not Supported by PHY\n");
+        }
+
+    }
+
+    if( ( priv->u_autoneg == LX_AUTONEG_DISABLE ) || ( ret_val == TMBSL_ERR_PHY_NOT_SUPPORTED) )
+    {
+        /* auto negotiation is disabled or auto negotiation is failed, then set the parameters
+        ** into phy register
+        */
+        priv->autoneg_adv = 0;
+
+        switch(priv->u_speed)
+        {
+        case LX_SPEED_1000:
+            bmc.speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case LX_SPEED_100:
+            bmc.speed = tmbslPhySpeed100Mbps;
+            break;
+        case LX_SPEED_10:
+            bmc.speed = tmbslPhySpeed10Mbps;
+            break;
+        default:
+            bmc.speed = tmbslPhySpeed100Mbps;
+            break;
+        }
+
+        bmc.duplexMode = ( priv->u_mode == LX_MODE_FULL_DUPLEX )? tmbslPhyFullDuplex : tmbslPhyHalfDuplex ;
+
+        bmc.enableCollisionTest = tmbslPhyDisable ;
+
+        /* Write into basic mode control register, the speed and mode values. This function
+        ** disables auto negotiation
+        */
+        if( gpPhyInterface[priv->hwUnitNum]->setBasicModeControlFunc(priv->hwUnitNum,&bmc ) != TM_OK )
+        {
+            GMAC_PRINT_ERR("PHY link setup failed\n");
+            goto _err_setup_phy ;
+        }
+
+    }
+    else
+    {
+
+        /* read the status register to get the speed/duplex mode */
+        if( gpPhyInterface[priv->hwUnitNum]->getBasicModeStatusFunc( priv->hwUnitNum, &bms) != TM_OK )
+        {
+            GMAC_PRINT_ERR("Get Basic Mode status failed\n");
+            goto _err_setup_phy ;
+        }
+
+        /* store the updated results into the priv structure */
+        priv->u_mode = bms.duplexMode ;
+
+        switch(bms.speed)
+        {
+            case tmbslPhySpeed1Gbps:
+                priv->u_speed = LX_SPEED_1000;
+                break;
+
+            case tmbslPhySpeed100Mbps:
+                priv->u_speed = LX_SPEED_100;
+                break;
+
+            case tmbslPhySpeed10Mbps:
+                priv->u_speed = LX_SPEED_10;
+                break;
+
+            default:
+                priv->u_speed = LX_SPEED_100;
+                break;
+        }
+    }
+    
+    #ifdef __LIPP_6300ETH_DEBUG__
+    if(priv->enable_phy_loopback == 1U)
+    {
+        if( gpPhyInterface[priv->hwUnitNum]->loopBackFunc(priv->hwUnitNum,tmbslPhyEnable) != TM_OK )
+        {
+            GMAC_PRINT_ERR("Enable PHY loopback failed\n");
+            goto _err_setup_phy ;
+        }
+
+    }
+    #endif
+
+    return 0 ;
+
+_err_setup_phy:
+
+    return -1 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION : setup_mac:
+ *DESCRIPTION : This function sets up the MAC hardware depending on the options chosen
+ *PARAMETERS:
+ * dev - net_device structure for the device
+ *RETURN:
+ *  0 - success
+ * -1 - Failure
+ *NOTES: None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 setup_mac( struct net_device *dev )
+{
+    lipp_6300Eth_PRIV_t * 		priv = NETDEV_PRIV( dev ) ;
+    tmhwLIPP6100Eth_DevConfig_t	eth_cfg ;
+    tmhwLIPP6100Eth_DmaCfg_t dmaCfg;
+    tmhwLIPP6100Eth_FlowCtrlConfig_t flowCtrl;
+    tmhwLIPP6100Eth_Int_t IntDis;
+
+    #if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+    tmhwLIPP6100Eth_MmcIntr_t MmcIntDis;
+    #endif
+
+    GMAC_PRINT_DBG("setup_mac called for %s\n", dev->name);
+
+    /* Clear the structure */
+    memset(&eth_cfg,0,sizeof(tmhwLIPP6100Eth_DevConfig_t));
+    memset(&dmaCfg,0,sizeof(tmhwLIPP6100Eth_DmaCfg_t));
+    memset(&flowCtrl,0,sizeof(tmhwLIPP6100Eth_FlowCtrlConfig_t));
+
+    /* Do the ethernet MAC configuration */
+    eth_cfg.autoPadCRC = True;
+    eth_cfg.backOffLim = tmhwLIPP6100Eth_BackoffVal0;
+    eth_cfg.clockSelect = priv->clk_csr_val;
+    eth_cfg.ifg = tmhwLIPP6100Eth_IFG96bits;
+    eth_cfg.phyAddress = priv->phy_addr_val;
+
+    if(priv->enable_jumbo == 1U)
+    {
+        /* Disable jabber on tx & watchdog on rx, for jumbo frames */
+        eth_cfg.jabberTimer = True;
+        eth_cfg.wdTimer = True;
+    }
+
+    /* TODO: A new HwAPI API need to be called here to set the interface type */
+    if(priv->hwUnitNum == 0)
+        eth_cfg.miiSelect = GMAC0_MII_SEL;
+    else
+        eth_cfg.miiSelect = GMAC1_MII_SEL;
+
+    /* After auto negotiation/PHY configuration, the values were stored in the Private data structure.
+    ** Use those values and configure MAC
+    */
+    if( priv->u_mode == LX_MODE_FULL_DUPLEX )
+    {
+        eth_cfg.duplexMode = True;
+    }
+
+    if( priv->u_speed == LX_SPEED_100 )
+    {
+        eth_cfg.speed100Mbps = True;
+    }
+
+    eth_cfg.station.adrLow =  ( dev->dev_addr[0])     |
+                              (dev->dev_addr[1] << 8) |
+                              (dev->dev_addr[2] << 16)|
+                              (dev->dev_addr[3] << 24);
+
+    eth_cfg.station.adrHigh =(dev->dev_addr[4]) |
+                             (dev->dev_addr[5] << 8);
+
+    #ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+    /* Enables IPv4 checksum checking for received frame payloads,
+    ** TCP/UDP/ICMP headers
+    */
+    eth_cfg.ipChecksumOffload = True;
+    #endif /* CONFIG_LIPP_6300ETH_CSUMOFFLOAD */
+
+    tmhwLIPP6100Eth_SetConfig( priv->hwUnitNum, &eth_cfg);
+
+    /* Set loopback, only after doing basic configuration */
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+    if(priv->enable_mac_loopback == 1U)
+    {
+        tmhwLIPP6100Eth_LpbkEnableDisable(priv->hwUnitNum,tmhwLIPP6100Eth_Enable);
+    }
+    #endif
+
+   if( priv->u_flow_control == LX_FLOW_CONTROL_ENABLED )
+    {
+
+        if( priv->u_rx_tx_fc & LX_TX_FLOW_CONTROL )
+        {
+            flowCtrl.txFlowCtrlEn = True;
+
+            /* Do the flow control configuration for TX  */
+            flowCtrl.pauseTime = LX_PAUSE_TIMER_VALUE;
+            flowCtrl.pauseLowThreshold = LX_4SLOT_TIMES;
+        }
+
+        if( priv->u_rx_tx_fc & LX_RX_FLOW_CONTROL )
+        {
+            flowCtrl.rxFlowCtrlEn = True;
+
+            /* For FIFO size greater than 4K */
+            if(1 == ENABLE_HW_FLOW_CONTROL)
+            {
+                dmaCfg.hwFlowCtrlEn = True;
+                dmaCfg.actRxThreshold = RFA_THRESHOLD;
+                dmaCfg.deactRxThreshold = RFD_THRESHOLD;
+            }
+
+        }
+
+        /* Flow control settings */
+        tmhwLIPP6100Eth_FlowCtrlSetConfig(priv->hwUnitNum,&flowCtrl);
+
+    }
+
+    /* DMA transmits packets in store and forward mode */
+    dmaCfg.storeNforwardEn = ETH_STORE_FWD_ENABLE;
+
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+
+    /* For checksum offload, this is true always */
+    dmaCfg.storeNforwardEn = True;
+
+    /* When enableAltDescSize is set, DMA descriptor size is 32 bytes
+    ** rather than 16 bytes
+    */
+    dmaCfg.enableAltDescSize = True;
+
+#endif /*CONFIG_LIPP_6300ETH_CSUMOFFLOAD */
+
+    dmaCfg.rxThreshold = ETH_RX_THRESHOLD;
+    dmaCfg.txThreshold = ETH_TX_THRESHOLD;
+
+    dmaCfg.disableFrameFlush  = ETH_DISABLE_FRAME_FLUSH;
+    dmaCfg.fixedBurstEn = ETH_FIXED_BURST_ENABLE;
+
+    dmaCfg.differentPBL = ETH_DIFF_PBL_ENABLE;
+    dmaCfg.pBL4xmode = ETH_4XPBL_ENABLE;
+    dmaCfg.burstLen = ETH_TX_PBL_VAL;
+    dmaCfg.rxPBL = ETH_RX_PBL_VAL;
+
+    dmaCfg.txSecondFrameEn = ETH_ENABLE_OSF;
+
+    dmaCfg.dmaArbitration = ETH_DMA_ARBITRATION;
+    dmaCfg.priority = ETH_DMA_PRIORITY;
+
+    /* Set the base addresses in the DMA registers */
+    dmaCfg.txDescListBaseAdr = priv->p_tx_descr;
+    dmaCfg.rxDescListBaseAdr = priv->p_rx_descr;
+
+    tmhwLIPP6100Eth_DmaConfig(priv->hwUnitNum,&dmaCfg);
+
+    IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntDis.gmacIntVal = GMAC_INT_MASK_VAL;
+    tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntDis);
+
+   #if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+    /* Disable MMC interrupts */
+    MmcIntDis.dir = tmhwLIPP6100Eth_Dir_Tx;
+    MmcIntDis.intrVal = 0x1FFFFFF;
+    tmhwLIPP6100Eth_MMCIntDisable(priv->hwUnitNum,&MmcIntDis);
+
+    MmcIntDis.dir = tmhwLIPP6100Eth_Dir_Rx;
+    MmcIntDis.intrVal = 0xFFFFFF;
+    MmcIntDis.rxCsumIntVal = 0x3FFF3FFF;
+    tmhwLIPP6100Eth_MMCIntDisable(priv->hwUnitNum,&MmcIntDis);
+   #endif
+
+#ifdef LIPP_6300ETH_VLAN_TAG
+    /* Setup VLAN Tag without filtering */
+    tmhwLIPP6100Eth_SetVLANTag(priv->hwUnitNum, 0);
+#endif
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:	setup_filter_config:
+ * DESCRIPTION:	This function sets up the filter configuration for the MAC
+ * depending upon the options present in priv structure
+ * PARAMETERS:
+ * dev - net_device structure for the device
+ * RETURN:
+ * 0 - success
+  * NOTES: This function utilizes all the perfect address filter registers in GMAC
+  *             to program multicast addresses. If all the multicast addresses doesnot fit
+  *             into these, it uses multicast hash table high/low registers.
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 setup_filter_config( struct net_device *dev )
+{
+
+    lipp_6300Eth_PRIV_t *   priv = NETDEV_PRIV( dev ) ;
+    tmhwLIPP6100Eth_HashFilter_t rx_hash_filter ;
+    tmhwLIPP6100Eth_FilterConfig_t filterCfg;
+
+    /* Default, the hw receives Unicast and broadcast packets */
+    memset(&rx_hash_filter,0,sizeof(tmhwLIPP6100Eth_HashFilter_t));
+
+    memset(&filterCfg,0,sizeof(tmhwLIPP6100Eth_FilterConfig_t));
+
+    if( dev->flags & IFF_PROMISC )
+    {
+        /* It is enabled to receive all packets. Just enable the promiscous mode and return */
+        filterCfg.passAllFrames = True;
+        /* Skip mulitcast frame filtering in reception */
+        priv->u_all_multi = 1 ;
+    }
+    else if( dev->flags & IFF_ALLMULTI )
+    {
+        /* allow all multicast packets to receive */
+        filterCfg.recvAllMulticast = True;
+
+        /* Skip mulitcast frame filtering in reception */
+        priv->u_all_multi = 1;
+    }
+    else if( dev->flags & IFF_MULTICAST )
+    {
+        /*
+        *  Unless the driver sets this flag in dev->flags, the interface wont be asked to handle
+        *  multicast packets.
+        */
+
+        /* Pass the received multicast frames via a  filter */
+        priv->u_all_multi = 0 ;
+
+        if( priv->u_mc_filter_type == LX_FILTER_TYPE_HW )
+        {
+            /*
+            * It is an hardware filter. So, just generate the hash value for the
+            * multicast addresses and write into the hash filter register
+            */
+            perfect_hash_filter_config( dev, &rx_hash_filter ) ;
+
+            /* If the Hash table registers have been programmed */
+            if((0 != rx_hash_filter.hashFilterH) || (0 != rx_hash_filter.hashFilterL))
+            {
+                filterCfg.hashMulticastEnable = True;
+            }
+
+        }
+        else
+        {
+            /* Enable software filtering */
+            priv->u_mc_filter_type = LX_FILTER_TYPE_SW;
+        }
+
+    }
+
+    /* Write into filter control register */
+    tmhwLIPP6100Eth_FilterSetConfig( priv->hwUnitNum,&filterCfg);
+
+    return 0 ;
+
+}
+
+static __u32 crc_table[256];
+static __s32 first =0;
+
+static void gen_table(void)                /* build the crc table */
+{
+    __u32 crc, poly;
+    __s32	i, j;
+
+    poly = 0xEDB88320L;
+    for (i = 0; i < 256; i++)
+        {
+        crc = i;
+        for (j = 8; j > 0; j--)
+            {
+            if (crc & 1)
+                crc = (crc >> 1) ^ poly;
+            else
+                crc >>= 1;
+            }
+        crc_table[i] = crc;
+        }
+}
+
+/* Bitwise reversal of CRC obtained */
+static __u32 reverse_crc(__u32 crc)
+{
+    __s32 i;
+    __u32 val=0;
+
+    for(i=0;i<32;i++)
+    {
+        if((crc & 0x1) > 0)
+        {
+            val |= 1 << (31-i);
+        }
+
+        crc >>=1;
+    }
+
+    return val;
+
+}
+
+__u32 get_crc32( unsigned char *fp,__s32 data_len)    /* calculate the crc value */
+{
+    register __u32 crc;
+    __s32 i;
+
+    crc = 0xFFFFFFFF;
+
+    if(first == 0)
+    {
+        gen_table();
+        first =1;
+    }
+
+    for(i=0;i<data_len; i++)
+    {
+        crc = (crc>>8) ^ crc_table[ (crc^(*fp++)) & 0xFF ];
+    }
+
+
+    crc ^=0xFFFFFFFF;
+    crc = reverse_crc(crc);
+
+    return(crc);
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:    generate_crc
+ *DESCRIPTION:	This function generates the CRC using CRC-32 for Ethernet GMAC core
+ *PARAMETERS:
+ *	data - data for the crc calculation. Here it is 6 byte destination address
+ *	data_len	- length of the data in bytes
+ *RETURN:
+ * 	CRC value
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 generate_crc(char *data, __s32 data_len)
+{
+     __s32 crc;
+
+    crc = get_crc32(data,data_len);
+
+    return crc;
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+* FUNCTION:	perfect_hash_filter_config
+* DESCRIPTION: This function programs the multicast addresses in the perfect address registers.
+* If the multicast addresses exceed the perfect address registers, then hash table is programmed.
+*
+* PARAMETERS:
+* dev - net_device structure for the device
+* pRx_HashVal - Hash value to be written to hash table high and hash table low registers
+* RETURN: None
+* NOTES:
+*/
+/*--------------------------------------------------------------------------*/
+static void perfect_hash_filter_config(
+    struct net_device *dev,
+    ptmhwLIPP6100Eth_HashFilter_t pRx_HashVal
+)
+{
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+    __s32  crc ;
+    u32 filtercnt;
+    tmhwLIPP6100Eth_PerfectAdrConfig_t perAdrFilter;
+    struct dev_mc_list * p_mc_list = dev->mc_list ;
+    __s32 mc_count = dev->mc_count ;
+
+    memset(&perAdrFilter,0,sizeof(tmhwLIPP6100Eth_PerfectAdrConfig_t));
+
+    perAdrFilter.addressEnable = False;
+
+    /* Disable all the perfect address filters. For (1-31) for an IP with 32 perfect address filters */
+    for(filtercnt = 1; filtercnt < ETH_NUM_OF_PER_ADR_FILTERS;filtercnt++)
+    {
+        tmhwLIPP6100Eth_PerfectAdrSetConfig(priv->hwUnitNum,filtercnt,&perAdrFilter);
+    }
+
+    /* Set the enable flag again */
+    perAdrFilter.addressEnable = True;
+
+    for( filtercnt = 1; (( (mc_count > 0) && ( p_mc_list != NULL )) && (filtercnt < ETH_NUM_OF_PER_ADR_FILTERS)) ; \
+            p_mc_list = p_mc_list->next, mc_count--,filtercnt++ )
+    {
+
+        /* Upper 2 bytes of address */
+        perAdrFilter.macAddrHigh = (p_mc_list->dmi_addr[5] << 8) |
+                                             (p_mc_list->dmi_addr[4]);
+
+        /* Lower 4 bytes of address */
+        perAdrFilter.macAddrlow = (p_mc_list->dmi_addr[3] << 24) |
+                                            (p_mc_list->dmi_addr[2] << 16) |
+                                            (p_mc_list->dmi_addr[1] << 8) |
+                                            (p_mc_list->dmi_addr[0]);
+
+        tmhwLIPP6100Eth_PerfectAdrSetConfig(priv->hwUnitNum,filtercnt,&perAdrFilter);
+
+    }
+
+    /* Program the remaining multicast address in the hash filter. Calculate the bit values */
+    for( ;(mc_count > 0) && ( p_mc_list != NULL); p_mc_list = p_mc_list->next, mc_count--)
+    {
+
+        crc = generate_crc( &p_mc_list->dmi_addr[0], ETH_ALEN ) ;
+
+        /* Upper most 6 bits are valid for hash filter */
+        crc>>= 26;
+
+        if( crc < 32 )
+        {
+            /* set the bit corresponding to crc value in to lsw */
+             pRx_HashVal->hashFilterL |= ( 1 << crc ) ;
+        }
+        else
+        {
+            /* set the bit corresponding to crc value in to lsw */
+            pRx_HashVal->hashFilterH |= ( 1 << crc ) ;
+        }
+
+    }
+
+    /* Write the hash value into the two registers */
+    tmhwLIPP6100Eth_HashFilterSetConfig(priv->hwUnitNum,pRx_HashVal);
+
+    return ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	is_mc_filtered_packet
+ *DESCRIPTION: This function checks if the given packet is in the list of multicast addresses
+ * in the net_device structure.
+ *
+ *PARAMETERS:
+ *	dev - net_device structure for the device
+ *	idx - index to the descriptor from where the receive buffer is to be obtained
+ *
+ *RETURN:
+ *	0	- if packet is not in the list of multicast address
+ *	1	- if packet is in the list of multicast address
+ *NOTES: This is a software method of filtering multicast frames
+ *
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 is_mc_filtered_packet( struct net_device * dev, __u32 idx )
+{
+
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+    struct ethhdr          * p_eth_hdr ;
+    __s32				   mc_count ;
+    struct dev_mc_list * p_mc_list ;
+
+    /*
+    * search the multicast address list and find out whether the received packet
+    * is one of the list of multicast addresses to be filtered out to submit kernel
+    */
+
+    /* Ethernet header is present in SKB->data */
+    p_eth_hdr = ( struct ethhdr * ) (priv->p_vrx_skb_list[ idx ])->data ;
+    mc_count = dev->mc_count ;
+    p_mc_list = dev->mc_list ;
+
+    for( ; p_mc_list && mc_count > 0 ; p_mc_list = p_mc_list->next, --mc_count )
+    {
+		/* compare the source MAC addresses */
+        if( memcmp( &p_mc_list->dmi_addr[0], p_eth_hdr->h_dest, ETH_ALEN ) == 0 )
+        {
+            /* yep! this address is on the list of multicast addresses to receive */
+            return 1 ;
+        }
+
+    }
+
+    /* received multicast packet does not have address in the multicast filter list. return error */
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION: lipp_6300Eth_open
+ *
+ * DESCRIPTION: 'open' driver handler for ethernet device. This function
+ *                     will set up the hardware allocates memory and enables the hardware
+ *                     for reception.
+ * PARAMETERS:
+ *  dev - net_device structure for the device
+ *  RETURN:
+ *  0 - success
+ *  ENOMEM - memory allocation error
+ *  ENXIO - IO error
+ *  NOTES:   This function is called when the interface is brought up
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_open(struct net_device *dev)
+{
+    __s32 ret_val = -ENXIO ;
+    tmhwLIPP6100Eth_EnTxfr_t    txfr;
+    tmhwLIPP6100Eth_Int_t IntDis;
+    lipp_6300Eth_PRIV_t *priv = NETDEV_PRIV( dev ) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_open called for %s\n", dev->name);
+
+    /* Check that the MAC address is valid.  If its not, refuse
+     * to bring the device up. The user must specify an
+     * address using the following linux command:
+     *      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+    if (!is_valid_ether_addr(dev->dev_addr)) {
+            random_ether_addr(dev->dev_addr);
+            GMAC_PRINT_ERR("%s: generated random MAC address %pM\n", dev->name,
+                    dev->dev_addr);
+    }
+
+    /*
+    * Allocate memory buffer for TX, RX descriptor and allocate buffers for all the descriptors
+    *  in the receive side.
+    */
+    if( alloc_dma_descriptors( dev ) != 0 )
+    {
+        GMAC_PRINT_ERR("Unable to allocate memory, aborting\n");
+        return -ENOMEM ;
+    }
+
+    /* Initialize Rx descriptors, assign buffers to each rx descriptor.
+    ** Since ring mode is used, the descriptors should be contiguous
+    ** and the addresses should be aligned to bus width.
+    */
+    if( setup_dma_descriptors( priv ) != 0 )
+    {
+        goto _err_free_mem ;
+    }
+
+    GMAC_PRINT_DBG("lipp_6300Eth_open: setup_dma_descriptors Done\n");
+
+    /* reset the stats structure */
+    memset( &priv->stats, 0, sizeof( struct net_device_stats ) ) ;
+
+    /* Bring up the interface */
+    if( up_lipp_6300Eth( dev ) != 0 )
+    {
+        goto _err_free_intr ;
+    }
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+        napi_enable(&priv->napiInfo.napi);
+#endif
+
+    netif_carrier_on(dev);
+    netif_start_queue( dev);
+
+    GMAC_PRINT_DBG("lipp_6300Eth_open: up_lipp_6300Eth Done\n");
+
+    /* Print the speed, duplex, flow control etc.. of successfull connection */
+    GMAC_STAT_PRINT("%s Up : Speed: %s Mbps %s Duplex\n", dev->name,
+               ((priv->u_speed == LX_SPEED_100) ? "100":((priv->u_speed == LX_SPEED_1000) ? "1000":"10")),
+               ((priv->u_mode == LX_MODE_FULL_DUPLEX)? "Full": "Half") );
+
+    return 0;
+
+_err_free_intr :
+
+    GMAC_PRINT_ERR("lipp_6300Eth_open:unable to setup the hardware, aborting\n");
+
+    tmhwLIPP6100Eth_IntClear( priv->hwUnitNum, DMA_CLR_ALL_INTS );
+
+    IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntDis.gmacIntVal = GMAC_INT_MASK_VAL;
+    tmhwLIPP6100Eth_IntDisable( priv->hwUnitNum,&IntDis) ;
+
+    txfr.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+    txfr.enFlag = tmhwLIPP6100Eth_Disable;
+    tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfr) ;
+    tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfr) ;
+
+    /* free the interrupt */
+    free_irq( dev->irq, dev ) ;
+
+_err_free_mem :
+
+    /* free the memory */
+    free_dma_descriptors( priv ) ;
+
+    return ret_val ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_stop
+ *
+ *DESCRIPTION:	'stop' driver handler for ethernet device. This function will
+ *  disable the hardware frees the memory allocated
+ *PARAMETERS:
+ *  dev - net_device structure for the device
+ *RETURN:
+ *  0	- success
+ *
+ *NOTES: This function is called when the interface is brought down
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_stop(struct net_device *dev)
+{
+
+    tmhwLIPP6100Eth_EnTxfr_t txfr;
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev);
+    tmhwLIPP6100Eth_Int_t IntDis;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_stop called for %s\n", dev->name);
+
+    netif_stop_queue(dev);
+    netif_carrier_off(dev);
+
+    (void)down_lipp_6300Eth(dev);
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+    napi_disable(&priv->napiInfo.napi);
+#endif
+
+    /* disable the Rx/Tx and disable the interrupts */
+    IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntDis.gmacIntVal = GMAC_INT_MASK_VAL;
+    tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntDis);
+
+    txfr.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+    txfr.enFlag = tmhwLIPP6100Eth_Disable;
+    tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfr);
+    tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfr);
+
+    priv->dma_enabled = 0;
+
+    /* free the memory */
+    free_dma_descriptors( priv ) ;
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:    lipp_6300Eth_hard_start_xmit
+ *
+ * DESCRIPTION: 'hard_start_xmit' driver handler for ethernet device. This
+ *	function will add the given SKB into the TX descriptor list if it has
+ *	a place for a TX packet. If TX descriptor ring is Full it returns a 1.
+ *
+ *PARAMETERS:
+ *	skb	-packet to be transmitted
+ *	dev	-net_device structure for the device
+ *RETURN:
+ *	   0 - success
+ *      1 - If the packet is not successfully queued
+ *
+ *   NOTES : None
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    lipp_6300Eth_PRIV_t * 	priv = NETDEV_PRIV(dev) ;
+    tmhwLIPP6100Eth_EnTxfr_t txfer;
+    __u32 EthStatus;
+    tmhwLIPP6100Eth_Int_t IntEn;
+    unsigned long flags;
+
+    dev->trans_start = jiffies;
+
+    GMAC_PRINT_INT("lipp_6300Eth_hard_start_xmit:%s\n", dev->name);
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+            if((priv->enable_mac_loopback == 1U) ||
+               (priv->enable_phy_loopback == 1U))
+            {
+                man_arp_udp_data(skb,skb->len);
+            }
+    #endif
+
+    /* Check if the own bit is cleared for the current transmit index.
+        ** Transmit index loops back after reaching the max descriptor length
+        ** For transmit descriptor, only end of ring is set in setup_descriptors()
+        */
+
+    if(0 == (priv->p_vtx_descr[priv->tx_produce_index].TDES0 & TXDESC_TDES0_OWN_VAL))
+    {
+
+        /* Buffer pointer to the frame */
+        priv->p_vtx_descr[priv->tx_produce_index].TDES2 =
+                            dma_map_single( NULL, skb->data, skb->len, DMA_TO_DEVICE );
+
+        /* Store the buffers transmitted, so that it can be freed once the
+                ** transmit process is complete
+                */
+        priv->p_vtx_skb_list[priv->tx_produce_index] = skb;
+
+        local_irq_save(flags);
+        priv->tx_submit_count++;
+        local_irq_restore(flags);
+
+        /* Clear the length field */
+        priv->p_vtx_descr[priv->tx_produce_index].TDES1 &= TXDESC_TDES1_TX_BUF1_SIZE_CLR;
+
+        #ifdef __ENHANCED_DESCRIPTOR__
+        priv->p_vtx_descr[priv->tx_produce_index].TDES0 |=
+                                                        #ifndef CONTROL_INTR_FREQ
+                                                        TXDESC_TDES0_INT_VAL |
+                                                        #endif
+                                                        TXDESC_TDES0_LASTSEG_VAL |
+                                                        TXDESC_TDES0_FIRSTSEG_VAL;
+
+        #ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD                                                                                                                     
+        if(skb->ip_summed == CHECKSUM_PARTIAL)
+        {
+            priv->p_vtx_descr[priv->tx_produce_index].TDES0 |= TXDESC_TDES0_CSUM_WITH_PSEUDO;
+        }
+        else
+        {
+            /* Clear CIC bits, as CSUM is not reqd. END OF RING is set in isr */
+            priv->p_vtx_descr[priv->tx_produce_index].TDES0 &= TXDESC_TDES0_CIC_CLR;            
+        }
+        #endif
+
+        priv->p_vtx_descr[priv->tx_produce_index].TDES1 = skb->len;
+        #else
+        /*Enable interrupt after pkt txmn. This is the first and last segment of the frame.
+                ** Set the length field passed from upper layers
+                */
+        priv->p_vtx_descr[priv->tx_produce_index].TDES1 |=
+                                                        #ifndef CONTROL_INTR_FREQ
+                                                        TXDESC_TDES1_INT_VAL |
+                                                        #endif
+                                                        TXDESC_TDES1_LASTSEG_VAL |
+                                                        TXDESC_TDES1_FIRSTSEG_VAL |
+                                                        skb->len;
+        #endif /* __ENHANCED_DESCRIPTOR__ */
+
+        /* Set the own bit value as the last statement. Otherwise, there could be a race condition */
+        priv->p_vtx_descr[priv->tx_produce_index].TDES0 |= TXDESC_TDES0_OWN_VAL;
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+        /* Interrupts to be enabled for transmit operation */
+        IntEn.dmaIntVal = TX_INTR_VAL;
+
+        IntEn.gmacIntVal =0;
+        tmhwLIPP6100Eth_IntEnable(priv->hwUnitNum,&IntEn);
+
+        /* Disable unwanted interrupts */
+        IntEn.dmaIntVal = ERE_ETE_INT_VAL;
+        IntEn.gmacIntVal = GMAC_INT_MASK_VAL;
+        /* Disable unnecessary interrupts */
+        tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntEn);
+#endif
+        /* If DMA is in suspended state, write to Transmit poll demand register
+        ** Otherwise, enable GMAC and DMA
+        */
+        tmhwLIPP6100Eth_IntGetStatus(priv->hwUnitNum,&IntEn);
+        EthStatus = IntEn.dmaIntVal;
+
+        if( (EthStatus & TMHW_LIPP6100ETH_DMA_STATUS_TS_MSK) == TMHW_LIPP6100ETH_DMA_STATUS_TS_SUSP_VAL)
+        {
+            tmhwLIPP6100Eth_DmaPollDesc(priv->hwUnitNum, tmhwLIPP6100Eth_Dir_Tx);
+        }
+
+        if(priv->dma_enabled == 0)
+        {
+            txfer.dirFlag = tmhwLIPP6100Eth_Dir_Tx;
+            txfer.enFlag = tmhwLIPP6100Eth_Enable;
+            tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfer);
+            tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfer);
+            priv->dma_enabled = 1;
+        }
+
+       /* Get the next produce index to set to */
+        if( priv->tx_produce_index >= ( HW_DESCR_QUEUE_LEN_TX - 1 ))
+        {
+            priv->tx_produce_index = 0 ;
+        }
+        else
+        {
+            priv->tx_produce_index++;
+        }
+
+    }
+    else
+    {
+        GMAC_PRINT_DBG("lipp_6300Eth_hard_start_xmit: Pkt Dropped");
+
+        netif_stop_queue(dev);
+
+        /* Drop the packet, keep the index constant */
+        priv->stats.tx_dropped++ ;
+        return NETDEV_TX_BUSY;
+    }
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------
+*
+* FUNCTION:	lipp_6300Eth_multicast_list
+* DESCRIPTION: 'set_multicast_list' driver handler for ethernet device.
+*                    This function will program the hardware for multicast filtering
+*                    This function is called when there is a change in flags. Any corresponding
+*                    action is to be taken in this function.
+*
+* PARAMETERS:
+*	dev	- net_device structure for the device
+* RETURN:	None
+* NOTES:	None
+*
+*--------------------------------------------------------------------------
+*/
+
+static void lipp_6300Eth_multicast_list(struct net_device *dev)
+{
+	lipp_6300Eth_PRIV_t *		priv = NETDEV_PRIV( dev ) ;
+	/* lock the spinlock */
+	spin_lock( &priv->lock ) ;
+
+	setup_filter_config( dev ) ;
+
+	/* unlock the spinlock */
+	spin_unlock( &priv->lock ) ;
+
+	return ;
+}
+
+#if 0
+/*--------------------------------------------------------------------------*/
+/*
+ *  FUNCTION:	lipp_6300Eth_set_mac_address
+ *  DESCRIPTION:	'set_mac_address' driver handler for ethernet device. This
+ *	function will assign the given MAC address to the hardware
+ *  PARAMETERS:
+ *	dev	- net_device structure for the device
+ *	addr	-address of MAC
+ *  RETURN:
+ *	0	- success
+ *	ENXIO	- IO error
+ *  NOTES:		None
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_set_mac_address(struct net_device *dev, void *addr)
+{
+    struct  sockaddr *	hw_addr = ( struct  sockaddr * ) addr ;
+
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+
+    /* lock the spinlock */
+    spin_lock( &priv->lock );
+
+    /* If the interface is not in running state */
+    if (0 == netif_running(dev))
+    {
+        /* new MAC address will be valid only when the device starts next time */
+        memcpy(dev->dev_addr, hw_addr->sa_data, dev->addr_len);
+        return 0;
+    }
+
+    /* Inform upper layer that link is down */
+    netif_stop_queue( dev );
+    netif_carrier_off(dev);
+
+
+    /* bring down the interface */
+    down_lipp_6300Eth( dev ) ;
+
+    /* copy the MAC address onto dev structure */
+    memcpy(dev->dev_addr, hw_addr->sa_data, dev->addr_len);
+
+    /* bring up the interface */
+    if( up_lipp_6300Eth( dev ) != 0 )
+    {
+        goto _err_set_mac_address ;
+    }
+
+    /* start accepting the packets from n/w stack */
+    netif_carrier_on(dev);
+    netif_start_queue( dev );
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return 0 ;
+
+    _err_set_mac_address:
+    GMAC_PRINT_ERR("Error in setting up the ethernet hardware\n") ;
+
+    /* start accepting the packets from n/w stack */
+    netif_carrier_on(dev);
+    netif_start_queue( dev );
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return -ENXIO ;
+
+}
+
+static int lipp_6300Eth_change_mtu (struct net_device *dev, int new_mtu)
+{
+
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+
+
+    if (new_mtu > LIPP_6300ETH_JUMBO_MTU)
+        return -EINVAL;
+
+    spin_lock( &priv->lock ) ;
+
+    if (!netif_running(dev))
+    {
+        printk(KERN_INFO "%s:not up",dev->name);
+        /* If device is not in running state, return */
+        spin_unlock( &priv->lock ) ;
+        return 0;
+    }
+
+    netif_stop_queue( dev );
+
+    netif_carrier_off(dev);
+
+    /* Delay to close the transactions */
+    mdelay(10);
+
+    /* bring down the interface */
+    down_lipp_6300Eth(dev) ;
+
+    if (new_mtu > ETH_DATA_LEN)
+    {
+
+        if (priv->enable_jumbo == 0U)
+        {
+            printk(KERN_INFO "%s: Enabling Jumbo frame "
+                             "support\n", dev->name);
+
+            priv->enable_jumbo = 1U;
+
+        }
+        else
+        {
+            /* Change in jumbo frame size ? */
+        }
+
+    }
+    else
+    {
+        /* Standard size of 1500 bytes or less */
+        priv->enable_jumbo = 0U;
+    }
+
+    /* Reallocate buffers only if jumbo frame size is greater than
+    ** previous value OR there is a switch from jumbo to normal frames
+    */
+    if( (( new_mtu > dev->mtu ) && (priv->enable_jumbo == 1U)) ||
+        (( dev->mtu > ETH_DATA_LEN ) && (priv->enable_jumbo == 0)))
+    {
+
+        free_dma_descriptors(priv);
+
+        /* Receive buffer size should be multiple of bus width (4,8,16 - bytes)
+        ** Round off to next size, which is divisible by bus width
+        */
+        priv->u_rx_buf_size = new_mtu;
+
+        if ( (new_mtu & (~DMA_DESC_ALIGNMENT)) != new_mtu )
+        {
+            priv->u_rx_buf_size = (new_mtu & (~DMA_DESC_ALIGNMENT)) +
+                                   DMA_DESC_ALIGNMENT +1;
+        }
+
+        /* Allocate receive buffers, with new size */
+        alloc_dma_descriptors(priv);
+
+        /* Assign the new buffers to DMA descriptors */
+        setup_dma_descriptors(priv);
+
+    }
+
+    /* Let stack know the new MTU */
+    dev->mtu = new_mtu;
+
+    /* bring up the interface */
+    if( up_lipp_6300Eth( dev ) != 0 )
+    {
+
+    }
+
+    /* start accepting the packets */
+    netif_carrier_on(dev);
+    netif_start_queue( dev ) ;
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return 0;
+}
+#endif
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:	lipp_6300Eth_do_ioctl
+ * DESCRIPTION:	'do_ioctl' driver handler for ethernet device. It is used for the following two
+ * purposes:
+ *                             1. To set the ethernet core to power down mode
+ *                             2. To access registers of MAC for debug purposes (Compile option)
+ *
+ * PARAMETERS:
+ *	dev	- net_device structure for the device
+ *	ifr	-interface structure
+ *	cmd	-IOCTL command
+ * RETURN:
+ *	 0	- success, -1 on Error
+ *
+ * NOTES:		None
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_do_ioctl(struct net_device *dev, struct ifreq *ifr, __s32 cmd)
+{
+
+    __s32 retVal = 0;
+
+    /* See section 3.8.4 of the GMAC datasheet 3.40a */
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+    tmhwLIPP6100Eth_WkupCfg_t wolCfg;
+    tmhwLIPP6100Eth_EnTxfr_t txfer;
+    gmacWoLinfo_t wolInfoApp;
+    rmonRegsRd_t mmcInfo;
+    #if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+    rmonCtrl_t mmcCtrl;
+    #endif
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+    gmacRegs_t gmacRegs;
+    __u32 regBase;
+    volatile __u32* pReg;
+    volatile __u32* pAdrReg;
+    volatile __u32* pDataReg;
+    gmacDrvConfig_t drvConfig;
+    unsigned long flags ;
+
+    #endif /*__LIPP_6300ETH_DEBUG__ */
+
+    if (dev != NULL)
+    {
+        switch(cmd)
+        {
+
+            case  ETH_POWER_DOWN:
+
+                if(copy_from_user(&wolInfoApp,ifr->ifr_data,sizeof(gmacWoLinfo_t)))
+                {
+                    GMAC_PRINT_ERR("Copy from user failed");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                memset(&wolCfg,0,sizeof(tmhwLIPP6100Eth_WkupCfg_t));
+
+                /* Stop the data from the application & disable tx watchdog */
+                netif_stop_queue(dev);
+                netif_carrier_off(dev);
+
+                if(wolInfoApp.magicPktEn == True)
+                {
+                    wolCfg.magicPktEn = True;
+                }
+                else if (wolInfoApp.globalUnicastEn == True)
+                {
+                    wolCfg.globalUnicastEn = True;;
+                }
+                else if (wolInfoApp.wkupFrameEn == True)
+                {
+                    wolCfg.wkupFrameEn = True;
+
+                    wolCfg.filterMask[0] = wolInfoApp.wkupinfo.filterMask[0];
+                    wolCfg.filterMask[1] = wolInfoApp.wkupinfo.filterMask[1];
+                    wolCfg.filterMask[2] = wolInfoApp.wkupinfo.filterMask[2];
+                    wolCfg.filterMask[3] = wolInfoApp.wkupinfo.filterMask[3];
+
+                    wolCfg.filterCommand = wolInfoApp.wkupinfo.filterCommand;
+
+                    wolCfg.filterOffset = wolInfoApp.wkupinfo.filterOffset;
+                    wolCfg.filterCrcVal6 = wolInfoApp.wkupinfo.filterCrcVal6;
+                    wolCfg.filterCrcVal7 = wolInfoApp.wkupinfo.filterCrcVal7;
+
+                }
+                else
+                {
+                    /* None of the wakeup procedure is set. Just return error */
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                tmhwLIPP6100Eth_WoLConfig(priv->hwUnitNum,&wolCfg);
+
+                /* Disable tx & rx operations & Power down the IP */
+                tmhwLIPP6100Eth_SetPowerState(priv->hwUnitNum,tmPowerOff);
+
+                /* Wait for a second to complete receiving of data from FIFOs*/
+                msleep(1000);
+
+                txfer.dirFlag = tmhwLIPP6100Eth_Dir_Rx;
+                txfer.enFlag = tmhwLIPP6100Eth_Enable;
+
+                /* Enable the receiver & put the core in power down mode */
+                tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfer);
+                tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfer);
+
+                /* Check if the link is up & running  */
+                if(priv->linkStatus != 0)
+                {
+
+                    /* Block for interrupt event */
+                    priv->wolFlag = 1;
+
+                    retVal = wait_event_interruptible(priv->waitQ,(priv->wolFlag !=1));
+
+                    /* If retVal is 0, the call was successful.
+                                          * If a signal is received, retVal is -ve */
+                    if(priv->wolFlag == 3)
+                    {
+                        GMAC_PRINT_ERR("Cable Unplugged or Link is down");
+                        /* Cable unplugged or link down */
+                        retVal = -EIO;
+                    }
+
+                }
+                else
+                {
+                    GMAC_PRINT_ERR("priv->linkStatus is 0");
+                    /* Link is down */
+                    retVal = -EIO;
+                }
+
+                break;
+
+            #ifdef __LIPP_6300ETH_DEBUG__
+            case  ETH_GMAC_DEBUG:
+
+
+                memset(&gmacRegs,0,sizeof(gmacRegs_t));
+
+                if(copy_from_user(&gmacRegs,ifr->ifr_data,sizeof(gmacRegs_t)))
+                {
+                    GMAC_PRINT_ERR("Copy from user failed");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                /* Base address of GMAC */
+                regBase = gtmhwLIPP6100Eth_Base[priv->hwUnitNum].baseAddress;
+
+                if(gmacRegs.rwPhyRegs == 0)
+                {
+
+                    pReg = (__u32*) (gmacRegs.regOffset+regBase);
+
+                    if(gmacRegs.rwFlag == 0)
+                    {
+                       /* GMAC Register Read operation */
+                       gmacRegs.regValue = *pReg;
+
+                    }
+                    else
+                    {
+                        /* GMAC Register Write operation */
+                        *pReg = gmacRegs.regValue;
+                    }
+
+
+                }
+                else
+                {
+                    /* Get the Address register */
+                    pAdrReg = (__u32*)(regBase+0x10) ;
+                    pDataReg = (__u32*)(regBase+0x14) ;
+
+                    if(gmacRegs.rwFlag == 0)
+                    {
+                        /* PHY read operation */
+                        spin_lock_irqsave(&priv->lock,flags);
+                        *pAdrReg = PHY_RW_MASK(gmacRegs.regOffset,0,
+							priv->phy_addr_val,priv->clk_csr_val);
+                         while(*pAdrReg & 0x1);
+                         gmacRegs.regValue = *pDataReg;
+                         spin_unlock_irqrestore(&priv->lock,flags);
+
+                    }
+                    else
+                    {
+                        /* PHY write operation */
+                        spin_lock_irqsave(&priv->lock,flags);
+                        *pDataReg = gmacRegs.regValue;
+                        *pAdrReg = PHY_RW_MASK(gmacRegs.regOffset,1,
+							priv->phy_addr_val,priv->clk_csr_val);
+                        while(*pAdrReg & 0x1);
+                        spin_unlock_irqrestore(&priv->lock,flags);
+                    }
+
+                }
+
+                if(gmacRegs.rwFlag == 0)
+                {
+                   /* For read operation, copy to user */
+                   if(copy_to_user(ifr->ifr_data,&gmacRegs,sizeof(gmacRegs_t)))
+                   {
+                       GMAC_PRINT_ERR("Copy to user failed");
+                       retVal = -1;
+                       goto _ioctl_exit;
+                   }
+                }
+
+                break;
+
+            case ETH_DRV_CONFIG:
+
+                memset(&drvConfig,0,sizeof(gmacDrvConfig_t));
+
+                if(copy_from_user(&drvConfig,ifr->ifr_data,sizeof(gmacDrvConfig_t)))
+                {
+                    GMAC_PRINT_ERR("ETH_DRV_CONFIG: Copy from user failed");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                if( (drvConfig.enableMacLoopback > 1U) ||
+                    (drvConfig.enablePhyLoopback > 1U) ||
+                    (drvConfig.enableAutoNeg > 1U) ||
+                    (drvConfig.enableFullduplex > 1U ) ||
+                    ( (drvConfig.speed != LX_SPEED_10) &&
+                      (drvConfig.speed != LX_SPEED_100)) ||
+                    ((drvConfig.enableMacLoopback == 1U) &&
+                     (drvConfig.enablePhyLoopback == 1U)))
+                {
+                    GMAC_PRINT_ERR("Invalid configuration, check the settings");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                priv->u_mode = 1U;    /* Full duplex mode */
+                priv->u_autoneg = 0U; /* Autonegotiation disabled for loopback */
+
+                if(drvConfig.enableMacLoopback == 1U)
+                {
+                    priv->enable_phy_loopback = 0U;
+                    priv->enable_mac_loopback = 1U;
+                }
+                else if(drvConfig.enablePhyLoopback == 1U)
+                {
+                    priv->enable_mac_loopback = 0U;
+                    priv->enable_phy_loopback = 1U  ;
+                }
+                else
+                {
+
+                    /* Disable loopback flags in the driver */
+                    priv->enable_phy_loopback = 0U;
+                    priv->enable_mac_loopback = 0U;
+
+                    /* Non Loopback mode. So set auto negotiation flag accordingly */
+                    if(drvConfig.enableAutoNeg == 1U)
+                    {
+                        priv->u_autoneg = 1U;
+
+                    }
+                    else
+                    {
+                        priv->u_autoneg = 0U;
+                    }
+
+                    if(drvConfig.enableFullduplex  == 1U)
+                    {
+                        /* Enable full duplex */
+                        priv->u_mode = 1U;
+
+                    }
+                    else
+                    {
+                        /* Disable full duplex */
+                        priv->u_mode = 0U;
+                    }
+
+
+                }
+
+                /* Speed setting */
+                if(drvConfig.speed== LX_SPEED_10)
+                {
+                    priv->u_speed= LX_SPEED_10;
+                }
+                else
+                {
+                    priv->u_speed= LX_SPEED_100;
+                }
+
+                if (!netif_running(dev))
+                {
+                    GMAC_PRINT_ERR("Device not running");
+                    retVal = -1;
+                    goto _ioctl_exit;
+
+                }
+
+                /* Inform upper layer that link is down */
+                netif_stop_queue( dev );
+                netif_carrier_off(dev);
+
+                /* bring down the interface */
+                down_lipp_6300Eth( dev ) ;
+
+                /* bring up the interface with new settings */
+                if( up_lipp_6300Eth( dev ) != 0 )
+                {
+                    GMAC_PRINT_ERR("Error in up_lipp_6300Eth");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                /* start accepting the packets from n/w stack */
+                netif_carrier_on(dev);
+                netif_start_queue( dev );
+                msleep(1000);
+                break;
+
+            #endif /* __LIPP_6300ETH_DEBUG__ */
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+
+        case ETH_DRV_RMON_CONFIG :
+
+                memset(&mmcCtrl,0,sizeof(rmonCtrl_t));
+
+                if(copy_from_user(&mmcCtrl,ifr->ifr_data,sizeof(rmonCtrl_t)))
+                {
+                    GMAC_PRINT_ERR("Copy from user failed");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                tmhwLIPP6100Eth_MMCConfig(priv->hwUnitNum,
+                    (tmhwLIPP6100Eth_MmcCtrl_Kpk_t)&mmcCtrl);
+
+            break;
+
+        case ETH_DRV_RMON_READ:
+
+                memset(&mmcInfo,0,sizeof(rmonRegsRd_t));
+
+                if(copy_from_user(&mmcInfo,ifr->ifr_data,sizeof(rmonRegsRd_t)))
+                {
+                    GMAC_PRINT_ERR("Copy from user failed");
+                    retVal = -1;
+                    goto _ioctl_exit;
+                }
+
+                tmhwLIPP6100Eth_MMCCountersRead(priv->hwUnitNum,
+                                    (ptmhwLIPP6100Eth_MmcRegVal_t)&mmcInfo);
+
+               if(copy_to_user(ifr->ifr_data,&mmcInfo,sizeof(rmonRegsRd_t)))
+               {
+                   GMAC_PRINT_ERR("Copy to user failed");
+                   retVal = -1;
+                   goto _ioctl_exit;
+               }
+
+            break;
+
+#endif
+
+        case SIOCGMIIPHY:       // Get PHY address
+        case SIOCHDRCMD:        // Resets the SoC , Control the diplexer switch etc
+        case SIOCGMIIREG:       // PHY read request
+        case SIOCSMIIREG:       // PHY write request
+        case SIOCCLINKDRV :     // Control plane commands for the driver
+        case SIOCGCLINKMEM :    // Reads registers/memory in c.LINK address space
+        case SIOCSCLINKMEM :    // Sets registers/memory in c.LINK address space
+        case SIOCGCLNKCMD :     // mbox cmmds: request with response
+        case SIOCSCLNKCMD :     // mbox cmmds: request with no response
+        case SIOCLNKDRV :       // mbox cmmds: retrieve unsol messages
+            retVal = ioctl_operation_work( moca_data_kernel_content, ifr, cmd ) ;
+            break ;
+
+        default:
+            GMAC_PRINT_ERR("Unknown IOCTL = %x\n", cmd);
+            retVal = -1;
+            break;
+
+        }
+
+    }
+    else
+    {
+
+        GMAC_PRINT_ERR("device ptr is NULL");
+        /*Device does not exist */
+        return -ENODEV;
+
+    }
+
+_ioctl_exit:
+
+    return retVal;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_tx_timeout_isr
+ *DESCRIPTION:	'tx_timeout' watchdog isr for ethernet device.
+ * This function schedules a thread for restarting the interface in case of transmission timeout
+ * given  by macro 'TX_TIMEOUT'. Typically this value is (5*HZ)
+ *
+ *PARAMETERS:
+ *	dev	- net_device structure for the device
+ *
+ *RETURN:	None
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+
+static void lipp_6300Eth_tx_timeout_isr(struct net_device *dev)
+{
+    __s32 ret_val;
+    lipp_6300Eth_PRIV_t *		priv = NETDEV_PRIV( dev ) ;
+
+    /* Queue the work */
+    ret_val = schedule_work(&priv->wdTimeoutTxWork.workq);
+
+    if(0 == ret_val)
+    {
+        GMAC_PRINT_INT("WdTxTimeout Work Not Queued\n");
+    }
+
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_work_reset_link
+ *DESCRIPTION:	'tx_timeout' driver handler for ethernet device.
+ * This function restarts the interface in process context
+ *
+ *PARAMETERS:
+ *	dev	- net_device structure for the device
+ *
+ *RETURN:	None
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+
+static void lipp_6300Eth_work_reset_link(struct work_struct *pWork)
+{
+
+    /* Parameters to container_of are as follows:
+       1.Ptr to variable inside structure
+       2.Parent structure type, in which (1) is embedded
+       3.Exact variable name inside the structure. The pointer to this
+         is in step 1.
+       4. The result would be a pointer to the parent structure, where (1)
+         is a member
+    */
+
+    plipp_6300Eth_WorkQ_t pLippWorkq = container_of(pWork,lipp_6300Eth_WorkQ_t,workq);
+
+    struct net_device * dev = pLippWorkq->pNetDev;
+
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+	tmhwLIPP6100Eth_PhyInfo_t phyInfo;
+
+    __s32 ret_val =0;
+    unsigned long flags;
+
+    netif_stop_queue(dev);
+    netif_carrier_off(dev);
+
+    GMAC_PRINT_DBG("lipp_6300Eth_work_reset_link: Start\n");
+
+    spin_lock_irqsave(&priv->lock,flags);
+
+    /* Bring down the interface */
+    down_lipp_6300Eth(dev);
+
+    /* Bring back the interface again */
+    gpPhyInterface[priv->hwUnitNum]->softResetFunc(priv->hwUnitNum);
+    phyInfo.clkCsrVal = priv->clk_csr_val;
+    phyInfo.phyAddr = priv->phy_addr_val;
+
+    tmhwLIPP6100Eth_Init(priv->hwUnitNum,&phyInfo, priv->hwUnitNum? GMAC1_MII_SEL:GMAC0_MII_SEL);
+    /* If autonegotiation is enabled, negotiate
+    ** to the highest speed & mode, when cable is unplugged & plugged back
+    */
+    priv->u_autoneg = ETH_AUTO_NEGOTIATION;
+    priv->u_mode = ETH_LINK_MODE;
+    ret_val = up_lipp_6300Eth(dev);
+
+    spin_unlock_irqrestore(&priv->lock,flags);
+
+    if(ret_val < 0 )
+    {
+        GMAC_PRINT_ERR("lipp_6300Eth_work_reset_link: Bringing back interface failed\n");
+       goto  _err_tx_timeout;
+    }
+
+    netif_carrier_on(dev);
+    netif_start_queue(dev);
+
+    /* For reset & autonegotiation. Dont allow wol ioctl until link is up & running */
+    priv->linkStatus = 1;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_work_reset_link: End\n");
+
+    GMAC_STAT_PRINT("%s: Up Speed : %s Mbps %s Duplex\n", dev->name,
+               ((priv->u_speed == LX_SPEED_100) ? "100":"10"),
+               ((priv->u_mode == LX_MODE_FULL_DUPLEX)? "Full": "Half") );
+
+    GMAC_PRINT_DBG("lipp_6300Eth_work_reset_link: End\n");
+
+    return ;
+
+_err_tx_timeout:
+
+    GMAC_PRINT_ERR("lipp_6300Eth_work_reset_link: Error in setting up of hardware\n" );
+
+    return ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_get_stats
+ *DESCRIPTION:	'get_stats' driver handler for ethernet device. This function
+ *	returns the address of net_device_stats structure that contains the
+ *	statistics for the ethernet device
+ *PARAMETERS:
+ *	dev	- net_device structure for the device
+ *RETURN:	Address of the net_device_stats structre
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static struct net_device_stats* lipp_6300Eth_get_stats(struct net_device *dev)
+{
+	lipp_6300Eth_PRIV_t *	priv = NETDEV_PRIV(dev) ;
+
+	/* return the address priv->stats structure that contain the counters */
+	return &(priv->stats) ;
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION: lipp_6300Eth_timer
+ *DESCRIPTION: This function will inform the kernel about the link status every
+ *                   'TIMEOUT_VALUE' seconds. Typically (2*HZ) seconds
+ *PARAMETERS:
+ *      data	- net_device structure for the device
+ *RETURN: None
+ *NOTES:
+ */
+/*--------------------------------------------------------------------------*/
+static void lipp_6300Eth_timer( unsigned long data)
+{
+
+    struct net_device* dev = (struct net_device*)data;
+    tmbslPhyEnableDisable_t curr_link_status;
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev);
+
+    #ifdef __NULL_PHY__
+        return; /* No LANR register present */
+    #endif
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+    if(priv->enable_mac_loopback || priv->enable_phy_loopback)
+    {
+        return;
+    }
+    #endif/* __LIPP_6300ETH_DEBUG__ */
+    
+    spin_lock(&priv->lock);
+
+    /*This function checks whether the carrier is present for the phy or not and depending
+    * upon the status of carrier, it informs kernel about the link
+    */
+
+    if(gpPhyInterface[priv->hwUnitNum]->getLinkStatusFunc(priv->hwUnitNum,
+                                                          &curr_link_status)
+                                                          != TM_OK )
+    {
+        goto _err_timer;
+    }
+
+    if(tmbslPhyEnable == curr_link_status)
+    {
+        if(!netif_carrier_ok(dev))
+        {
+            priv->linkStatus = 1;            
+            /* Bring up the interface */
+            if( up_lipp_6300Eth( dev ) != 0 )
+            {
+                GMAC_PRINT_ERR("Error in Timer up_lipp_6300Eth");
+                goto _err_timer;
+            }
+            
+            netif_carrier_on(dev);
+            netif_wake_queue(dev);
+            GMAC_STAT_PRINT("%s : Link is Up\n",dev->name);
+
+        }
+    }
+    else
+    {
+        if (netif_carrier_ok(dev))
+        {
+            priv->linkStatus = 0;
+            
+            netif_stop_queue(dev);
+            netif_carrier_off(dev);
+
+            /* Bring down the interface */
+            down_lipp_6300Eth(dev);
+            
+            if(priv->wolFlag == 1)
+            {
+                priv->wolFlag = 3;
+                wake_up_interruptible_all(&priv->waitQ);
+            }
+            
+            GMAC_STAT_PRINT("%s: Link is down\n",dev->name );
+        }
+     }
+
+    priv->phy_timer = &lipp_6300Eth_timer_struct[priv->hwUnitNum];
+    
+    priv->phy_timer->expires = round_jiffies(jiffies + TIMEOUT_VALUE);
+    
+    mod_timer(priv->phy_timer,priv->phy_timer->expires);
+    spin_unlock(&priv->lock);
+
+    return;
+
+_err_timer :
+
+        GMAC_PRINT_ERR("Link Status Error\n") ;
+
+    return;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*FUNCTION:	handle_receive_packets
+ *DESCRIPTION: This function handles the received packets and if valid submits
+ *	                 to the kernel
+ *PARAMETERS:
+ *	dev - net_device structure for the device
+ *	pBudget - number of packets to be received (valid only if NAPI is enabled )
+ *RETURN:
+ *	0	- Success
+ *	1	- Still some packets are present in queue to handle (valid only
+ *		   if NAPI is enabled)
+ *	-1	- error
+ *NOTES: None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 handle_receive_packets( struct net_device * dev, __s32 *pBudget )
+{
+    struct sk_buff * skb = NULL;
+    __s32 frameSize=0;
+    __s32 ret_val =0;
+    lipp_6300Eth_PRIV_t*priv = NETDEV_PRIV(dev);
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+    __s32 npackets = 0 ;
+#else
+    unsigned long flags;
+    __u32 max_rx_pkts =0;
+    tmhwLIPP6100Eth_Int_t IntEn ={0,0};    
+#endif
+
+	(void) pBudget;
+    /* If there is not enough free space, transmit a pause frame
+    ** or enable back pressure.
+    */
+    if( check_n_enable_tx_flow_control( dev ) != 0 )
+    {
+        goto _err_handle_receive_packets ;
+    }
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+    /* Interrupts to be disabled for receive operation */
+    IntEn.dmaIntVal = TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL;
+    IntEn.gmacIntVal =0;
+    tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntEn);
+#endif
+        while(1)
+        {
+
+            /* If the descriptor is not processed by DMA then break */
+            if((priv->p_vrx_descr[priv->rx_consume_index].RDES0 & RXDESC_RDES0_OWN_VAL) != 0)
+            {
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+                if(max_rx_pkts >= MAX_RX_PKTS_TO_PROCESS)
+                {
+                    break;
+                }
+#endif
+                break;
+            }
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+            if(*pBudget <=0)
+            {   /* Met the quota, return */
+                goto _return_from_napi;
+            }            
+#endif
+            /* If the error summary bit is set, check for overflow and CRC errors */
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_ERR_SUM_VAL)
+            {
+                if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 & RXDESC_RDES0_EXTDSTAT_DAMATCH)
+                {
+                    /* If IP checksum & TCP/UDP checksum is successful */
+                    if((priv->p_vrx_descr[priv->rx_consume_index].RDES4 & TCPIP_CSUM_ERRCHK) == 0)
+                    {
+                        GMAC_PRINT_ERR("IP CSUM Error: Index %d\n",priv->rx_consume_index);
+                        priv->stats.rx_crc_errors++ ;
+                    }
+                }
+                
+                if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                    RXDESC_RDES0_OVERFLOW_ERR_VAL)
+                {
+                    GMAC_PRINT_ERR("OverFlow Error: Index %d\n",priv->rx_consume_index);
+                    priv->stats.rx_over_errors++ ;
+                }
+                if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                    RXDESC_RDES0_CRC_ERR_VAL)
+                {
+                    GMAC_PRINT_ERR("CRC Error\n");
+                    priv->stats.rx_crc_errors++ ;
+                }
+                //else
+                //    GMAC_PRINT_ERR("handle_receive_packets err = 0x%08x\n", priv->p_vrx_descr[priv->rx_consume_index].RDES4);
+
+                goto _err_drop_packet ;
+
+            }
+
+            /* If length Error bit is set */
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_LEN_ERR_VAL )
+            {
+                priv->stats.rx_length_errors++ ;
+                GMAC_PRINT_ERR("Handle_receive_packets: Length Errors\n");
+                goto _err_drop_packet ;
+            }
+
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_DRIBBLE_VAL)
+            {
+                priv->stats.rx_frame_errors++ ;
+                GMAC_PRINT_ERR("Handle_receive_packets: Dribble Error\n");
+                goto _err_drop_packet ;
+            }
+
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_SRC_ADR_FAIL_VAL)
+            {
+                priv->stats.rx_frame_errors++ ;
+                GMAC_PRINT_ERR("Handle_receive_packets: SAF Error\n");
+                goto _err_drop_packet ;
+            }
+
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_DST_ADR_FAIL_VAL)
+            {
+                priv->stats.rx_frame_errors++ ;
+                GMAC_PRINT_ERR("Handle_receive_packets: DAF Error\n");
+                goto _err_drop_packet ;
+            }
+
+#ifdef LIPP_6300ETH_VLAN_TAG
+            if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_VLAN_TAG_VAL)
+            {
+                GMAC_PRINT_DBG("Handle_receive_packets: VLAN TAG detected at %s\n", dev->name);
+            }            
+#endif
+
+            /* If first and last bit are set for the frame, it is a valid frame.
+            ** Otherwise, discard the frame
+            */
+            if((priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_FIRST_DESC_VAL) &&
+                (priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                RXDESC_RDES0_LAST_DESC_VAL))
+            {
+
+                /* Get the pointer to SKB */
+                skb = priv->p_vrx_skb_list[priv->rx_consume_index];
+                
+                if(priv->p_vrx_descr[priv->rx_consume_index].RDES2)
+                    dma_unmap_single(NULL, priv->p_vrx_descr[priv->rx_consume_index].RDES2, priv->u_rx_buf_size, DMA_FROM_DEVICE);
+
+                #ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+
+                /* Check if the frames passes the IP & TCP/UDP/ICMP checksum test */
+                if(priv->p_vrx_descr[priv->rx_consume_index].RDES0 & RXDESC_RDES0_EXTDSTAT_DAMATCH)
+                {
+
+                    /* If IP checksum & TCP/UDP checksum is successful */
+                    if((priv->p_vrx_descr[priv->rx_consume_index].RDES4 & TCPIP_CSUM_ERRCHK) == 0)
+                    {
+                        /* Passed the checksum test done by IP, inform not repeat again in stack */
+                        skb->ip_summed = CHECKSUM_UNNECESSARY;
+                    }
+                    else if(priv->p_vrx_descr[priv->rx_consume_index].RDES4 & RXDESC_RDES4_IPCSUM_BYPASS)
+                    {
+                        /* Bypassed checksum test, inform stack to do the necessary processing */
+                        skb->ip_summed = CHECKSUM_NONE;
+
+                    }
+                    else
+                    {
+                        GMAC_PRINT_ERR("csum failed:Dropped pkt\n");
+                        /* Drop the frame, as it failed checksum test */
+                        goto _err_drop_packet ;
+
+                    }
+
+                }
+                else /* Frame type value is 0 & other conditions, let kernel handle */
+                {
+                    skb->ip_summed = CHECKSUM_NONE;
+                }
+
+                #endif /* CONFIG_LIPP_6300ETH_CSUMOFFLOAD*/
+            }
+            else
+            {
+                GMAC_PRINT_INT("handle_receive_packets: Dropped Pkt..EOF not set\n");
+                priv->stats.rx_errors++ ;
+                goto _err_drop_packet ;
+            }
+
+            /* Submit the frame to the Kernel */
+            frameSize = (priv->p_vrx_descr[priv->rx_consume_index].RDES0 &
+                        RXDESC_RDES0_FRM_LEN_MSK) >> RXDESC_RDES0_FRM_LEN_POS;
+
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+            frameSize -=4;/* Exclude ethernet CRC */
+#endif
+            
+            priv->p_vrx_skb_list[priv->rx_consume_index]=NULL;
+            skb_put( skb,frameSize);            
+
+            #ifndef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+            skb->ip_summed = CHECKSUM_COMPLETE;
+            #endif /* CONFIG_LIPP_6300ETH_CSUMOFFLOAD */
+
+            skb->len = frameSize;
+            skb->dev = dev ;
+            skb->protocol = eth_type_trans(skb,dev) ;
+
+            if(skb->pkt_type == PACKET_MULTICAST)
+            {
+                if( priv->u_all_multi == 0)
+                {
+                    priv->stats.multicast++ ;
+
+                    if( priv->u_mc_filter_type == LX_FILTER_TYPE_SW )
+                    {
+                        /* Check the validity of the packet by filtering through software filtering */
+                        if( is_mc_filtered_packet( dev, priv->rx_consume_index ) )
+                        {
+                            /* valid multicast packet, submit to kernel */
+                        }
+                        else
+                        {
+                            /* Invalid multicast packet, just drop it */
+                            priv->stats.rx_dropped++ ;
+                            goto _clear_rx_status;
+                        }
+
+                    }
+
+                }
+
+            }
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+            /* Submit the packet to the kernel */
+            ret_val = netif_receive_skb(skb);
+            npackets++;
+            (*pBudget)--;
+            dev->last_rx = jiffies;
+            priv->stats.rx_packets++ ;
+            priv->stats.rx_bytes += frameSize;
+#else
+            /* submit the packet to kernel */
+            ret_val = netif_rx(skb);
+            dev->last_rx = jiffies;
+            priv->stats.rx_packets++ ;
+            priv->stats.rx_bytes += frameSize;
+#endif  /* #ifdef CONFIG_ETH_LIPP_6300ETH_NAPI */
+
+            /*
+            * Now packet is submitted, just allocate a new SKB with maximum frame size and update
+            * relevant descr, status and skb_list
+            */
+            skb = netdev_alloc_skb_ip_align(dev, priv->u_rx_buf_size);
+            if( skb == NULL )
+            {
+                /* error in memory allocation. set the descriptor to NULL. */
+                priv->p_vrx_descr[priv->rx_consume_index ].RDES2 = 0 ;
+                goto _err_drop_packet ;
+            }
+
+            /* Store the SKB in the rx SKB list array */
+            priv->p_vrx_skb_list[priv->rx_consume_index] = skb;
+
+            /* Assign buffer address to descriptor */
+            priv->p_vrx_descr[priv->rx_consume_index].RDES2= \
+                                          dma_map_single(NULL,
+                                                         skb->data,
+                                                         priv->u_rx_buf_size,
+                                                         DMA_FROM_DEVICE);
+
+            /* packet is submitted to kernel, now clear the status and continue processing
+                          * remaining packets */
+            goto _clear_rx_status ;
+
+            /* invalid packet, drop the packet */
+    _err_drop_packet :
+
+            priv->stats.rx_errors++ ;
+
+    _clear_rx_status :
+            priv->p_vrx_descr[priv->rx_consume_index].RDES0 = RXDESC_RDES0_OWN_VAL;
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+            spin_lock_irqsave(&priv->lock,flags);
+#endif
+            if(priv->rx_consume_index >= (HW_DESCR_QUEUE_LEN_RX-1))
+            {
+                priv->rx_consume_index = 0;
+            }
+            else
+            {
+                priv->rx_consume_index++;
+            }
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+            spin_unlock_irqrestore(&priv->lock,flags);
+            max_rx_pkts++;
+#endif
+        }
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+      /* Re-enable receive interrupts */
+      IntEn.dmaIntVal = TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL;
+      IntEn.gmacIntVal =0;
+      tmhwLIPP6100Eth_IntEnable(priv->hwUnitNum,&IntEn);
+#endif
+
+    /*
+    * If TX flow control is enabled, just disable it as now enough space is present in
+    * RX descriptor chain to receive packets
+    */
+	disable_tx_flow_control( dev ) ;
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+_return_from_napi:
+    return npackets ;
+#else
+    return 0;
+#endif /* CONFIG_ETH_LIPP_6300ETH_NAPI */
+
+_err_handle_receive_packets :
+	/*
+	 * if TX flow control is enabled, just disable it as now enough space is present in
+	 * RX descriptor chain to receive packets
+	 */
+	disable_tx_flow_control( dev ) ;
+
+	return -1 ;
+
+}
+
+
+#ifdef __LIPP_6300ETH_DEBUG__
+/* Manipulate ARP & UDP data to run the UDP client/server application */
+static void man_arp_udp_data(struct sk_buff * skb, __u32 framelen )
+{
+    __u8 *data = skb->data;
+    __u16 proto;
+    __u8 pcip[4];
+    __u8 tgtip[4];
+    __u8 pcmac[6] = {0xaa,0xbb,0xcc,0xdd,0xee,0xf0};
+    __u8 tgtmac[6];
+
+    proto = (*(data+12) << 8) | *(data+13);
+
+    /* If ARP packet, create ARP reply */
+    if(proto == 0x806)
+    {
+         /* Sent by this IP address */
+        memcpy(tgtip,data+0x1C,4);
+
+        /* Sent to this IP address */
+        memcpy(pcip,data+0x26,4);
+
+        /* Store tgt mac address */
+        memcpy(tgtmac,data+6,6); /* 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff */
+
+        /* Replace broadcast adr with tgtmac */
+        memcpy(data,tgtmac,6);
+
+        /* Replace the from address with pc mac  */
+        memcpy(data+6,pcmac,6);
+
+        /* Set code to ARP reply */
+        *(data+0x15)=2;
+
+        /* Sender is a pc now. Copy PC mac address  */
+        memcpy(data+0x16,pcmac,6);
+
+        /* Sender IP address : IP address of imaginary PC */
+        memcpy(data+0x1c,pcip,4);
+
+        /* Sent to Target ip mac & ip address */
+        memcpy(data+0x20,tgtmac,6);
+        memcpy(data+0x26,tgtip,4);
+
+    }
+    else if(proto == 0x800)
+    {
+
+        /* Swap the MAC addresses as well */
+        memcpy(tgtmac,data,6);
+        memcpy(data,data+6,6);
+        memcpy(data+6,tgtmac,6);
+
+        /* Just swap the IP address for UDP packets & Port number */
+        memcpy(tgtip,data+0x1a,4);
+        memcpy(data+0x1a,data+0x1e,4);
+        memcpy(data+0x1e,tgtip,4);
+
+        /* Server port = 9999 */
+        *(skb->data+0x25) = 0x0F;
+
+        /* Reset UDP checksum. Is there a sock api to do this ? */
+        *(skb->data+0x28) =0;
+        *(skb->data+0x29) =0;
+
+    }
+    else
+    {
+    }
+
+}
+
+#endif /* __LIPP_6300ETH_LOOPBACK__ */
+
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	handle_tx_packets
+ *DESCRIPTION: This function handles the packets transmitted and frees the
+ *	SKB of the transmitted packet
+ *PARAMETERS:
+ *	priv	- lipp_6300Eth_PRIV_t structure
+ *RETURN:	None
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static void handle_tx_packets( struct net_device * dev)
+{
+
+    lipp_6300Eth_PRIV_t * 		priv = NETDEV_PRIV( dev ) ;
+    TX_DESCR_t *		ptx_descr ;
+    struct sk_buff *	skb ;
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+    unsigned long flags;
+    __u32 max_tx_pkts =0;
+    tmhwLIPP6100Eth_Int_t IntEn;
+#endif
+    
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+    /* Interrupts to be disabled for transmit operation */
+    IntEn.dmaIntVal = TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL;
+    IntEn.gmacIntVal =0;
+    tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntEn);
+#endif
+
+    do
+    {
+        /* Loop till the consume index is not equal to produce index AND own bit is zero
+                ** When there are no packets to transmit, at that time, all own bits will be zero
+                ** Compare against produce index also
+                */
+
+        /* If OWN bit is set OR no packets were submitted for transmission, break */
+        if((priv->p_vtx_descr[priv->tx_consume_index].TDES0 & TXDESC_TDES0_OWN_VAL) ||
+            (priv->tx_submit_count == 0)
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+            )
+#else            
+            ||(max_tx_pkts >= MAX_TX_PKTS_TO_PROCESS))
+#endif
+        {
+            break;
+        }
+
+        /* Decrement number of packets transmitted */
+        if(priv->tx_submit_count > 0)
+        {
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI        
+            spin_lock_irqsave(&priv->lock,flags);
+#endif
+            priv->tx_submit_count--;
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+            spin_unlock_irqrestore(&priv->lock,flags);
+#endif
+        }
+        else
+        {
+            break;
+        }
+
+        ptx_descr = &(priv->p_vtx_descr[ priv->tx_consume_index]);
+
+        /* Buffer transmitted */
+        skb = priv->p_vtx_skb_list[priv->tx_consume_index];
+
+        /* Check whether any error is present for transmitted frames by
+        ** checking the status
+        */
+        if( ptx_descr->TDES0 & TXDESC_TDES0_ES_VAL)
+        {
+            GMAC_PRINT_INT("handle_tx_packets:Tx Error\n");
+            priv->stats.tx_errors++;
+
+            if( ptx_descr->TDES0 & TXDESC_TDES0_IPPAYLD_VAL)
+            {
+                GMAC_PRINT_INT("handle_tx_packets:IP Payload Error\n");
+            }
+
+            if( ptx_descr->TDES0 & TXDESC_TDES0_IHE_VAL)
+            {
+                GMAC_PRINT_INT("handle_tx_packets:IP Header Error\n");
+            }
+
+        }
+        else
+        {           
+            /* packet is transmitted. Update the counter and free the skb */
+            priv->stats.tx_packets++;
+            priv->stats.tx_bytes += ptx_descr->TDES1 & TXDESC_TDES1_TX_BUF1_SIZE_MSK ;
+        }
+
+        priv->stats.collisions += ((ptx_descr->TDES0 & TXDESC_TDES0_COLCNT_MSK) >>
+                                              TXDESC_TDES0_COLCNT_POS) ;
+
+        if(ptx_descr->TDES2 != 0)
+        {
+            /* Buffer 1 address pointer */
+            dma_unmap_single( NULL,ptx_descr->TDES2,skb->len,DMA_TO_DEVICE ) ;
+        }
+
+        if(skb != NULL)
+        {
+            dev_kfree_skb_any(skb);
+        }
+
+        priv->p_vtx_skb_list[priv->tx_consume_index] = NULL ;
+
+        /* Dont clear TDES1 as it contains end of ring set */
+        /* Clear the buffer1 pointer */
+        ptx_descr->TDES2 =0;
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+        spin_lock_irqsave(&priv->lock,flags);
+#endif
+        /* Get the next descriptor index to be processed */
+        if(priv->tx_consume_index  >= (HW_DESCR_QUEUE_LEN_TX-1))
+        {
+            #ifdef __ENHANCED_DESCRIPTOR__
+            /* Set the end of ring value again */
+            ptx_descr->TDES0 |= TXDESC_TDES0_END_OF_RING_VAL;
+            #endif /* __ENHANCED_DESCRIPTOR__ */
+
+            priv->tx_consume_index = 0;
+        }
+        else
+        {
+
+            priv->tx_consume_index++;
+        }
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI        
+        spin_unlock_irqrestore(&priv->lock,flags);
+        max_tx_pkts++;
+#endif
+   }while( 1 ) ;
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+    /* Re-enable transmit interrupts */
+    IntEn.dmaIntVal = TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL;
+    IntEn.gmacIntVal =0;
+    tmhwLIPP6100Eth_IntEnable(priv->hwUnitNum,&IntEn);
+#endif
+
+    /* Free space is available. Enable the tx queue */
+	if(netif_queue_stopped(dev))
+	{
+		netif_wake_queue(dev);
+	}
+
+    return ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	check_n_enable_tx_flow_control
+ *DESCRIPTION: This function checks if there are enough descriptors available for the DMA.
+ * If the number of descriptors has fallen below the configured threshold, it activates
+ * flow control mechanism.
+ *
+ *PARAMETERS:
+ *	dev	- net_device structure for the device
+ *RETURN:
+ *	 0	 - Success
+ *	-1	 - failure
+ *NOTES: None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 check_n_enable_tx_flow_control( struct net_device *dev )
+{
+    lipp_6300Eth_PRIV_t *priv = NETDEV_PRIV( dev );
+    __u32 probeIdx = 0;
+
+    /* Check if flow control is enabled */
+    if( ( priv->u_flow_control == 0 ) ||
+        ((priv->u_rx_tx_fc & LX_TX_FLOW_CONTROL) == 0) )
+    {
+        return 0 ;
+    }
+
+    /* If all the descriptors are full, enable tx Flow control.
+    ** Check if the isr is too slow in processing & enable flow control
+    ** If the own bit is not set in the descriptor pointing to probeIdx,
+    ** enable flow control.
+    */
+
+    if(priv->rx_consume_index >= LX_DESC_GAP)
+    {
+        probeIdx = priv->rx_consume_index - LX_DESC_GAP;
+    }
+    else if ( priv->rx_consume_index < LX_DESC_GAP)
+    {
+        probeIdx = (HW_DESCR_QUEUE_LEN_RX - LX_DESC_GAP) + priv->rx_consume_index;
+    }
+
+    if( 0 == (priv->p_vrx_descr[probeIdx].RDES0 & RXDESC_RDES0_OWN_VAL))
+    {
+        /* Enable flow control */
+        tmhwLIPP6100Eth_FlowCtrlEnableDisable(priv->hwUnitNum, tmhwLIPP6100Eth_Enable);
+    }
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	disable_tx_flow_control
+ *DESCRIPTION:	This function disables the TX flow control mechanism by disabling the
+ *                       backpressure in half duplex operation.
+ *PARAMETERS:
+ *	dev	- net_device structure for the device
+ *RETURN:
+ *	0	- Success
+ *	-1	- failure
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 disable_tx_flow_control( struct net_device *dev )
+{
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV( dev ) ;
+
+    if( ( priv->u_flow_control == 0 ) ||
+        ((priv->u_rx_tx_fc & LX_TX_FLOW_CONTROL) == 0) )
+    {
+		return 0 ;
+    }
+
+    /* The bit is self clearing in Full Duplex mode. For half duplex, explicitly clear the bit */
+
+    if(LX_MODE_HALF_DUPLEX == priv->u_mode )
+    {
+        tmhwLIPP6100Eth_FlowCtrlEnableDisable(priv->hwUnitNum,tmhwLIPP6100Eth_Disable);
+    }
+
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ * FUNCTION:	lipp_6300Eth_isr
+ * DESCRIPTION:	This function handles the interrupt events from GMAC hardware for
+ *	the packets transmitted or received
+ * PARAMETERS:
+ *	irq	- interrupt number
+ *	dev_id	- net_device structure for the device
+ *	regs	- registers structure
+ * RETURN:
+ *	IRQ_HANDLED	- interrupt handled
+ *	IRQ_NONE	- invalid interrupt
+ * NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+irqreturn_t lipp_6300Eth_isr( __s32 irq, void *dev_id)
+{
+
+    struct net_device * dev = (struct net_device*) dev_id ;
+    lipp_6300Eth_PRIV_t *priv = NETDEV_PRIV(dev);
+    __u32                          intr_status;
+    tmhwLIPP6100Eth_Int_t   IntDis;
+    __u32 wolStatus;
+    tmhwLIPP6100Eth_WkupCfg_t wolCfg;
+    tmhwLIPP6100Eth_EnTxfr_t txfer;
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+    struct napi_struct * pNapi = &priv->napiInfo.napi;
+#else
+    /* In loop process all interrupts */
+    while( 1 )
+    {
+#endif	
+        /* Read the interrupt status */
+        tmhwLIPP6100Eth_IntGetStatus( priv->hwUnitNum, &IntDis);
+
+        intr_status = IntDis.dmaIntVal;
+
+        /* Check if there is update on necessary interrupts. If not break from loop  */
+        tmhwLIPP6100Eth_IntClear(priv->hwUnitNum,intr_status);
+        if((INT_STATUS_CHECK & intr_status) == 0)
+        {
+            return IRQ_NONE;
+        }
+
+        /* Check if it is a power management interrupt */
+        if(intr_status & TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL)
+        {
+
+            /* This is due to reception of wake up frame. Clear the status. Its read on clear reg */
+            tmhwLIPP6100Eth_GetWakeupStatus(priv->hwUnitNum,(pUInt32)&wolStatus);
+            wolCfg.globalUnicastEn = False;
+            wolCfg.magicPktEn = False;
+            wolCfg.wkupFrameEn = False;
+            wolCfg.rstRegptr = False;
+
+            /* Disable recognizing any further magic/wakeup frames received */
+            tmhwLIPP6100Eth_WoLConfig(priv->hwUnitNum,&wolCfg);
+
+            txfer.dirFlag = tmhwLIPP6100Eth_Dir_Tx;
+            txfer.enFlag = tmhwLIPP6100Eth_Enable;
+
+            /* Enable transmission again */
+            tmhwLIPP6100Eth_GmacEnableDisable(priv->hwUnitNum,&txfer);
+            tmhwLIPP6100Eth_DmaEnableDisable(priv->hwUnitNum,&txfer);
+
+            netif_wake_queue(dev);
+            netif_carrier_on(dev);
+            priv->wolFlag = 2;
+            wake_up_interruptible_all(&priv->waitQ);
+            return IRQ_HANDLED ;
+
+        }
+
+        /* Due to MAC Management counters */
+        if(intr_status & TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL)
+        {
+            GMAC_PRINT_INT("MMC Int not supported by driver\n");
+        }
+
+        if(intr_status & TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL)
+        {
+            GMAC_PRINT_INT("ERROR: FATAL BUS ERROR Interrupt\n");
+        }
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+        /* NAPI mode of operation */
+        if(napi_schedule_prep(pNapi))
+        {
+            // Mask all interrupts DMA & GMAC, even PMT interrupt 
+            IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+            IntDis.gmacIntVal = 0x20F;
+            tmhwLIPP6100Eth_IntDisable(priv->hwUnitNum,&IntDis);
+        
+            /* Schedule a polling routine */
+            __napi_schedule(pNapi);
+        }
+#else
+        /* Handle receive interrupts if  any */
+        if( intr_status & ( TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL |
+                            TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL |
+                            TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL ))
+        {
+
+           /* Handle the received packets in interrupt mode */
+            if( handle_receive_packets( dev, NULL ) )
+            {
+                goto _err_isr ;
+            }
+        }
+
+        if( intr_status & (TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL |
+                           TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL ))
+        {
+                handle_tx_packets(dev) ;
+        }
+    }
+#endif
+
+#ifndef CONFIG_ETH_LIPP_6300ETH_NAPI
+_err_isr :
+    GMAC_PRINT_INT("Error in handling the interrupt for ethernet\n") ;
+#endif
+
+    return IRQ_HANDLED ;
+}
+
+#ifdef LIPP_6300ETH_VLAN_TAG
+static void lipp_6300eth_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+    lipp_6300Eth_PRIV_t*priv = netdev_priv(dev);
+
+    spin_lock(&priv->lock);
+    priv->vlgrp = grp;
+    spin_unlock(&priv->lock);
+
+}
+#endif /* LIPP_6300ETH_VLAN_TAG */
+
+#ifdef CONFIG_ETH_LIPP_6300ETH_NAPI
+static __s32 lipp_6300Eth_napi(struct napi_struct *pNapi, __s32 budget)
+{
+
+    tmhwLIPP6100Eth_Int_t   IntDis;
+    
+    plipp_6300Eth_Napi_t pNapiInfo = container_of(pNapi,lipp_6300Eth_Napi_t,napi);
+    struct net_device * dev = pNapiInfo->pDev;
+    lipp_6300Eth_PRIV_t *priv = NETDEV_PRIV(dev) ;
+    __u32 intr_status;
+    __u32 unitNum = priv->hwUnitNum;
+    unsigned long flags;
+    __s32 ret_val=0;
+
+    /* Read the interrupt status & clear it */
+    tmhwLIPP6100Eth_IntGetStatus( unitNum, &IntDis);
+    intr_status = IntDis.dmaIntVal;
+    tmhwLIPP6100Eth_IntClear(unitNum,intr_status);
+
+    ret_val = handle_receive_packets(dev,&budget);
+
+    #ifdef LIPP_6300ETH_LRO_SUPPORT
+    if(ret_val == 0)
+    {
+        lro_flush_all(&priv->lro_mgr);
+    }
+    #endif /* LIPP_6300ETH_LRO_SUPPORT */
+
+    handle_tx_packets(dev);
+
+    if(ret_val < budget)
+    {   
+        /* Exit condition
+        ** 1. Submitted budget no. frames. So stop polling. OR
+        ** 2. There are no interrupts to process
+        */
+
+        #ifdef LIPP_6300ETH_LRO_SUPPORT
+        lro_flush_all(&priv->lro_mgr);
+        #endif
+        tmhwLIPP6100Eth_IntGetStatus( unitNum, &IntDis);
+
+        spin_lock_irqsave(&priv->lock, flags);
+        napi_complete(pNapi);
+
+        /* Enable  interrupts, for next schedule */
+        IntDis.dmaIntVal = TX_INTR_VAL | RX_INTR_VAL;
+        IntDis.gmacIntVal = TMHW_LIPP6100ETH_PMT_INT_MSK_VAL;
+
+        tmhwLIPP6100Eth_IntEnable(priv->hwUnitNum,&IntDis);  
+        spin_unlock_irqrestore(&priv->lock,flags);
+
+    }
+    
+    return ret_val;
+
+}
+#endif
+
+#ifdef ENABLE_ETH_TOOL
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_get_settings
+ *DESCRIPTION:	'get_settings" ethtool driver handler. This function returns
+ *	the current settings of the link.
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *	cmd	- ethtool command and data
+ *RETURN:
+ *	0	- success
+ *NOTES: This function is used for debug purposes
+ */
+/*--------------------------------------------------------------------------*/
+
+static __s32 lipp_6300Eth_ethtool_get_settings(struct net_device *dev,
+                                               struct ethtool_cmd *cmd)
+{
+
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_get_settings called for %s\n", dev->name);
+
+    spin_lock( &priv->lock ) ;
+
+    cmd->autoneg = priv->u_autoneg ;
+    cmd->speed = priv->u_speed ; /* 10, 100 */
+    cmd->duplex = priv->u_mode ;
+
+    cmd->supported = ( SUPPORTED_10baseT_Half |
+                       SUPPORTED_10baseT_Full |
+                       SUPPORTED_100baseT_Half |
+                       SUPPORTED_100baseT_Full |
+                       SUPPORTED_Autoneg |
+                       SUPPORTED_MII ) ;
+
+    cmd->advertising = priv->autoneg_adv |
+                        ADVERTISED_MII;
+
+    cmd->phy_address = priv->phy_addr_val;
+    cmd->port = dev->if_port;
+
+    cmd->transceiver = XCVR_EXTERNAL;
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+    return 0 ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_set_settings
+ *DESCRIPTION:	'set_settings" ethtool driver handler. This function sets the
+ *	link parameters
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *	cmd	- ethtool command and data
+ *RETURN:
+ *	0	- success
+ *	ENXIO	- IO error
+ *NOTES: This function is used for debug purposes
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_ethtool_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+    lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_set_settings called for %s\n", dev->name);
+
+    /* lock the spinlock */
+    spin_lock( &priv->lock ) ;
+
+    priv->u_speed = cmd->speed ;
+    priv->u_mode = cmd->duplex ;
+    priv->u_autoneg = cmd->autoneg ;
+
+    /* process parameters */
+    if( !netif_running( dev ) )
+    {
+        /* interface is not up, just return */
+        goto __success_ethtool_set_settings ;
+    }
+
+    /* Inform upper layer that link is down */
+    netif_stop_queue( dev );
+    netif_carrier_off(dev);
+
+    /* interface is up and running, bring down the interface, change settings
+    ** and bring up the interface
+    */
+    if( down_lipp_6300Eth( dev ) != 0 )
+    {
+        goto _err_ethtool_set_settings ;
+    }
+
+    /* bring up the interface */
+    if( up_lipp_6300Eth( dev ) != 0 )
+    {
+        goto _err_ethtool_set_settings ;
+    }
+
+    /* start accepting the packets from n/w stack */
+    netif_carrier_on(dev);
+    netif_start_queue( dev );
+
+    __success_ethtool_set_settings :
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return 0 ;
+
+    _err_ethtool_set_settings:
+    GMAC_PRINT_ERR("Unable to setup the hardware\n");
+
+    /* start accepting the packets from n/w stack */
+    netif_carrier_on(dev);
+    netif_start_queue( dev );
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return -ENXIO ;
+
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_get_drvinfo
+ *DESCRIPTION:	'get_drvinfo" ethtool driver handler. This function returns
+ *	the driver information
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *	cmd	- ethtool command and data
+ *RETURN:	None
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+
+static void lipp_6300Eth_ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
+{
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_get_drvinfo called for %s\n", dev->name);
+
+	strcpy(drvinfo->driver,  DRV_NAME);
+	strcpy(drvinfo->version, DRV_VERSION) ;
+	drvinfo->fw_version[0] = '\0';
+	drvinfo->n_stats = 0 ;
+	drvinfo->testinfo_len = 0 ;
+	drvinfo->regdump_len = 0 ;
+	drvinfo->eedump_len = 0 ;
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_get_link_status
+ *DESCRIPTION:	Returns the link status
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *RETURN:	1 if ethernet link is up, 0 if ethernet link is down
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+
+static __u32 lipp_6300Eth_ethtool_get_link_status(struct net_device *dev)
+{
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_get_link_status called for %s\n", dev->name);
+
+    return netif_carrier_ok(dev) ? 1 : 0;
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_get_pauseparam
+ *DESCRIPTION:	'get_pauseparam" ethtool driver handler. This function returns
+ * the flow control parameters to the caller
+ *PARAMETERS:
+ * dev	- net_device structure
+ * pauseparam	- ethtool flow control strucutre
+ *RETURN:	None
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static void lipp_6300Eth_ethtool_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam* pauseparam)
+{
+	/* - need to implement the flow control */
+	lipp_6300Eth_PRIV_t *		priv = NETDEV_PRIV( dev ) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_get_pauseparam called for %s\n", dev->name);
+
+	pauseparam->autoneg = priv->u_autoneg ;
+	pauseparam->tx_pause = priv->u_flow_control == ( LX_FLOW_CONTROL_ENABLED ) && ( priv->u_rx_tx_fc & LX_TX_FLOW_CONTROL ) ;
+	pauseparam->rx_pause = priv->u_flow_control == ( LX_FLOW_CONTROL_ENABLED ) && ( priv->u_rx_tx_fc & LX_RX_FLOW_CONTROL ) ;
+	return ;
+}
+
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:    lipp_6300Eth_ethtool_set_pauseparam
+ *DESCRIPTION: 'set_pauseparam" ethtool driver handler. This function sets
+ *	the flow control parameters to the hardware
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *	pauseparam	- ethtool flow control strucutre
+ *RETURN:
+ *	0	- success
+ *	-ENXIO	- IO error
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+static __s32 lipp_6300Eth_ethtool_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam* pauseparam)
+{
+
+    lipp_6300Eth_PRIV_t *		priv = NETDEV_PRIV( dev ) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_set_pauseparam called for %s\n", dev->name);
+
+    /* lock the spinlock */
+    spin_lock( &priv->lock ) ;
+
+    priv->u_autoneg = pauseparam->autoneg ;
+
+    if( priv->u_autoneg == LX_AUTONEG_ENABLE )
+    {
+        priv->u_flow_control = LX_FLOW_CONTROL_ENABLED ;
+    }
+
+    priv->u_rx_tx_fc |= ( pauseparam->tx_pause ) ? LX_TX_FLOW_CONTROL : 0 ;
+    priv->u_rx_tx_fc |= ( pauseparam->rx_pause ) ? LX_RX_FLOW_CONTROL : 0 ;
+
+    if( priv->u_rx_tx_fc )
+    {
+        priv->u_flow_control = LX_FLOW_CONTROL_ENABLED ;
+    }
+
+    if (!netif_running(dev))
+    {
+        /* new settings will be used when device starts netxt time */
+        /* unlock the spinlock */
+        spin_unlock( &priv->lock ) ;
+        return 0;
+    }
+
+    netif_stop_queue( dev );
+    netif_carrier_off(dev);
+    /* bring down the interface */
+    down_lipp_6300Eth( dev ) ;
+
+    /* bring up the interface */
+    if( up_lipp_6300Eth( dev ) != 0 )
+    {
+        goto _err_set_pauseparam ;
+    }
+
+
+    /* start accepting the packets */
+    netif_carrier_on(dev);
+    netif_start_queue( dev ) ;
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return 0 ;
+
+    _err_set_pauseparam:
+    GMAC_PRINT_ERR("Error in setting up the ethernet hardware\n") ;
+
+    /* start accepting the packets from n/w stack */
+    netif_carrier_on(dev);
+    netif_start_queue( dev );
+
+    /* unlock the spinlock */
+    spin_unlock( &priv->lock ) ;
+
+    return -ENXIO ;
+
+}
+
+#ifdef CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+/*--------------------------------------------------------------------------*/
+/*
+ *FUNCTION:	lipp_6300Eth_ethtool_get_rx_csum
+ *DESCRIPTION:	Returns the rx csum
+ *PARAMETERS:
+ *	dev	- net_device structure
+ *RETURN:	1 if ethernet rx csum is enable, 0 if ethernet rx csum is disabled
+ *NOTES:	None
+ */
+/*--------------------------------------------------------------------------*/
+
+static __u32 lipp_6300Eth_ethtool_get_rx_csum(struct net_device *dev)
+{
+    GMAC_PRINT_DBG("lipp_6300Eth_ethtool_get_rx_csum called for %s\n", dev->name);
+
+    return 1;
+}
+
+#endif
+#endif
+
+#ifdef CONFIG_PM
+static int lipp_6300Eth_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device * dev = dev_get_drvdata(&pdev->dev);
+	lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev) ;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_suspend called for %s\n", dev->name);
+    
+	if (!dev || !netif_running(dev))
+    	return 0;
+    
+    spin_lock(&priv->lock);
+
+	if (state.event == PM_EVENT_SUSPEND)
+	{
+		netif_device_detach(dev);
+
+		napi_disable(&priv->napiInfo.napi);
+
+		/* Inform upper layer that link is down */
+		netif_stop_queue( dev );
+		netif_carrier_off(dev);
+                
+		/* Power down PHY here. PHY is not accessible, if GMAC is disabled
+		** in next step
+		*/
+		gpPhyInterface[priv->hwUnitNum]->setPowerStateFunc(priv->hwUnitNum,tmPowerOff);
+
+		/*Below operation also disables GMAC & DMA */
+		tmhwLIPP6100Eth_SetPowerState(priv->hwUnitNum,tmPowerOff);
+
+		/* Free all the tx & rx buffers,DMA descriptors, deletes the PHY timer,
+		** disables GMAC, GMAC DMA
+		*/
+		(void)down_lipp_6300Eth(dev);
+
+	}
+	else
+	{
+		priv->shutdown = 1;
+		lipp_6300Eth_stop(dev);
+	}
+
+	spin_unlock(&priv->lock);
+
+	return 0;
+
+}
+
+static int lipp_6300Eth_resume(struct platform_device *pdev)
+{
+	struct net_device * dev = dev_get_drvdata(&pdev->dev);
+	lipp_6300Eth_PRIV_t * priv = NETDEV_PRIV(dev);
+	tmhwLIPP6100Eth_PhyInfo_t phyInfo;
+
+    GMAC_PRINT_DBG("lipp_6300Eth_resume called for %s\n", dev->name);
+
+	if (!netif_running(dev))
+		return 0;
+
+	spin_lock(&priv->lock);
+
+    if(priv->shutdown)
+    {
+        lipp_6300Eth_open(dev);
+        goto out_resume;
+    }
+
+    netif_device_attach(dev);
+
+	phyInfo.clkCsrVal = priv->clk_csr_val;
+	phyInfo.phyAddr = priv->phy_addr_val;
+
+	/* Reset MAC. Resetting will bring the MAC out of power down.
+	** PHY is also reset in setup_phy, to come out of powerdown mode
+	*/
+	tmhwLIPP6100Eth_Init(priv->hwUnitNum,&phyInfo, priv->hwUnitNum? GMAC1_MII_SEL:GMAC0_MII_SEL);
+
+	/* Allocates DMA descriptors, receive buffers, adds the PHY timer,
+	** enables GMAC, GMAC DMA
+	*/
+	if( up_lipp_6300Eth(dev) != 0 )
+	{
+		goto _err_lipp_6300Eth_resume;
+	}
+
+    napi_enable(&priv->napiInfo.napi);
+
+	/* start accepting the packets from n/w stack */
+	netif_carrier_on(dev);
+	netif_start_queue( dev );
+
+out_resume:
+	spin_unlock(&priv->lock);
+	return 0;
+
+_err_lipp_6300Eth_resume:
+	spin_unlock(&priv->lock);
+	return 1;
+}
+#endif  /* CONFIG_PM */
+
+module_init(lipp_6300Eth_init_module);
+module_exit(lipp_6300Eth_cleanup_module);
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.h linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,667 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:           gmac_drv.h  %
+ * %pid_version:       1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Header file for Linux Driver for LIPP_6100ETH ethernet subsystem
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _GMAC_DRV_H_
+#define _GMAC_DRV_H_
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#endif
+
+/* Macros to define speed of the link */
+#define LX_SPEED_1000  (1000)
+#define LX_SPEED_100 (100)
+#define LX_SPEED_10 (10)
+
+#define LX_MODE_FULL_DUPLEX (1)
+#define LX_MODE_HALF_DUPLEX (0)
+
+/* Autonegotiation enable/disable macros */
+#define LX_AUTONEG_ENABLE (1)
+#define LX_AUTONEG_DISABLE (0)
+
+#define LX_FLOW_CONTROL_ENABLED (1)
+#define LX_FLOW_CONTROL_DISABLED (0)
+
+#define LX_RX_FLOW_CONTROL (0x02)
+#define LX_TX_FLOW_CONTROL (0x04)
+
+#define LX_FILTER_TYPE_SW (0)
+#define LX_FILTER_TYPE_HW (1)
+
+#define LX_PROMISC_ENABLED (1)
+#define LX_PROMISC_DISABLED (0)
+
+#define LX_4SLOT_TIMES (0)
+#define LX_28SLOT_TIMES (1)
+#define LX_144SLOT_TIMES (2)
+#define LX_256SLOT_TIMES (3)
+
+/* Fill level of receive FIFO for activating/deactivating
+** hardware flow control. Used when the macro ENABLE_HW_FLOW_CONTROL
+** is set to 1.
+*/
+#define FIFO_FILL_LEVEL_1K (0)
+#define FIFO_FILL_LEVEL_2K (1)
+#define FIFO_FILL_LEVEL_3K (2)
+#define FIFO_FILL_LEVEL_4K (3)
+#define FIFO_FILL_LEVEL_5K (4)
+#define FIFO_FILL_LEVEL_6K (5)
+#define FIFO_FILL_LEVEL_7K (6)
+
+/* Programmable burst length values */
+#define BURST_LENGTH_1 (1)
+#define BURST_LENGTH_2 (2)
+#define BURST_LENGTH_4 (4)
+#define BURST_LENGTH_8 (8)
+#define BURST_LENGTH_16 (16)
+#define BURST_LENGTH_32 (32)
+
+/* DMA transmit threshold values */
+#define TX_DMA_THRESHOLD_VAL_64 (0)
+#define TX_DMA_THRESHOLD_VAL_128 (1)
+#define TX_DMA_THRESHOLD_VAL_192 (2)
+#define TX_DMA_THRESHOLD_VAL_256 (3)
+#define TX_DMA_THRESHOLD_VAL_40 (4)
+#define TX_DMA_THRESHOLD_VAL_32 (5)
+#define TX_DMA_THRESHOLD_VAL_24 (6)
+#define TX_DMA_THRESHOLD_VAL_16 (7)
+
+/* DMA receive threshold values */
+#define RX_DMA_THRESHOLD_VAL_64 (0)
+#define RX_DMA_THRESHOLD_VAL_32 (1)
+#define RX_DMA_THRESHOLD_VAL_96 (2)
+#define RX_DMA_THRESHOLD_VAL_128 (3)
+
+/* DMA priorities in Rx:Tx ratio */
+#define DMA_RX1_TX1 (0)
+#define DMA_RX2_TX1 (1)
+#define DMA_RX3_TX1 (2)
+#define DMA_RX4_TX1 (3)
+
+/*********************** configuration options **********************/
+
+/* Rx Frame size should be multiple of 4/8/16 depending on bus width.
+ * The frame size should be at least (MTU+14) bytes after meeting the above
+ * condition
+ */
+#define MAX_ETH_FRAME_SIZE (1536)
+
+/* Descriptor alignment required. 4/8/16 for 32/64/128 bit buses respectively */
+
+/* Set the alignment value to (alignment - 1)
+*   Ex: For 16, set to 15,
+*          For   8, set to 7,
+*          For 4 set to 3
+*/
+#define DMA_DESC_ALIGNMENT (15) /* 16-1 */
+
+#ifdef CONFIG_GMAC0_MODE_RGMII
+#define GMAC0_MII_SEL False
+#else
+#define GMAC0_MII_SEL True
+#endif
+
+#ifdef CONFIG_GMAC1_MODE_RGMII
+#define GMAC1_MII_SEL False
+#else
+#define GMAC1_MII_SEL True
+#endif
+
+/* Speed of the ethernet link */
+#define ETH_LINK_SPEED (LX_SPEED_100)
+
+/* Mode of the ethernet link */
+#define ETH_LINK_MODE (LX_MODE_FULL_DUPLEX)
+
+/* Macro to enable/disable autonegotiation */
+#define ETH_AUTO_NEGOTIATION (LX_AUTONEG_ENABLE)
+
+/* HW or SW filtering */
+#define ETH_FILTER_TYPE (LX_FILTER_TYPE_HW)
+
+#define MULTICAST_FILTER_DISABLE (1)
+#define MULTICAST_FILTER_ENABLE (0)
+
+#define MULTICAST_FILTER (MULTICAST_FILTER_DISABLE)
+
+/* Software based flow control -Enable/Disable */
+#define ETH_FLOW_CTRL (LX_FLOW_CONTROL_ENABLED)
+
+/* Macro to enable hardware flow control if the receive FIFO size
+ * is greater than 4K. When set to 1 it is enabled.
+ */
+#define ENABLE_HW_FLOW_CONTROL (1)
+
+/* Activate flow control when the empty space falls below this value */
+#define RFA_THRESHOLD (tmhwLIPP6100Eth_RFA_1K)
+
+/* Deactivate flow control when FIFO fill level is less than this value */
+#define RFD_THRESHOLD (tmhwLIPP6100Eth_RFA_2K)
+
+/* Disable frame flushing on rx side */
+#define ETH_DISABLE_FRAME_FLUSH (0)
+
+/* Enable Operate on second frame. 1-Enable, 0-Disable */
+#define ETH_ENABLE_OSF (1)
+
+/* Store & forward mode for transmit side */
+#define ETH_STORE_FWD_ENABLE (1)
+
+#define ETH_TX_THRESHOLD (TX_DMA_THRESHOLD_VAL_256)
+
+#define ETH_RX_THRESHOLD (RX_DMA_THRESHOLD_VAL_128)
+
+/* 4*X PBL mode enable/disable */
+#define ETH_4XPBL_ENABLE (0)
+
+/* Separate PBL for Tx & Rx */
+#define ETH_DIFF_PBL_ENABLE (0)
+
+#define ETH_FIXED_BURST_ENABLE (0)
+
+/* Programmable burst length value */
+#define ETH_TX_PBL_VAL (BURST_LENGTH_32)
+
+#define ETH_RX_PBL_VAL (BURST_LENGTH_32)
+
+/* Enable/Disable DMA arbitration scheme */
+#define ETH_DMA_ARBITRATION (0)
+
+/* When DA bit is reset, the values are valid */
+#define ETH_DMA_PRIORITY (DMA_RX1_TX1)
+
+/* Flow control direction Tx/Rx or Both */
+#define ETH_FLOW_CTRL_DIR (LX_RX_FLOW_CONTROL | LX_TX_FLOW_CONTROL)
+
+/* Promiscuous mode enable/disable */
+#define ETH_PROMISC_MODE (LX_PROMISC_DISABLED)
+
+/* Time sent in a pause frame in slot times. Max value is 0xFFFF slot time
+** Each slot time is 512 bit times in GMII/MII mode
+*/
+#define LX_PAUSE_TIMER_VALUE (256)
+
+/* Pause low threshold value  */
+#define ETH_PLT_VALUE (LX_4SLOT_TIMES)
+
+/* To find if there are enough descriptors are available to receive frames */
+#define LX_DESC_GAP (10)
+
+/* Ethtool API selection */
+#define ENABLE_ETH_TOOL
+
+/* Number of descriptors for transmit side */
+#define HW_DESCR_QUEUE_LEN_TX  (80)
+
+/* Number of descriptors for receive side */
+#define HW_DESCR_QUEUE_LEN_RX  (80)
+
+/* At a time, the txmt isr processes these many tx desc */
+#define MAX_TX_PKTS_TO_PROCESS (80)
+
+/* At a time, the receive isr processes these many rx desc */
+#define MAX_RX_PKTS_TO_PROCESS (80)
+
+/* NAPI driver for reception */
+#define CONFIG_ETH_LIPP_6300ETH_NAPI
+
+/* Global flag to be set to enable checksum offload */
+#define CONFIG_LIPP_6300ETH_CSUMOFFLOAD
+
+#define ETH_ENABLE_JUMBO_FRAME (0)
+
+/* Maximum jumbo frame size in bytes */
+#define LIPP_6300ETH_JUMBO_MTU (2000)
+
+#define NAPI_DEV_WEIGHT (64)
+
+/* For periodic data, define this macro */
+#undef  CONTROL_INTR_FREQ
+
+/*To support enhanced DMA descriptor of the IP */
+#define __ENHANCED_DESCRIPTOR__
+
+/* VLAN TAGGING 8021Q */
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define LIPP_6300ETH_VLAN_TAG
+#endif
+
+/* Frequency at which the transmit side is interrupted */
+#define ETH_TX_INTR_FREQ (1)
+
+/* Frequency at which the receive side is interrupted */
+#define ETH_RX_INTR_FREQ (1)
+
+/* Autonegotiation retry count */
+#define AUTO_NEG_RETRY_COUNT (3)
+
+/* Periodic status check for ethernet link */
+#define TIMEOUT_VALUE   (2*HZ)
+
+/* Watch dog timeout for transmission  */
+#define TX_TIMEOUT (5*HZ)
+
+/* Number of perfect address filters available on the hardware
+** Perfect Filter register 0 is used for MAC address
+** Remaining Perfect Filter registers (1-31) are used for programming multicast addresses
+*/
+#define ETH_NUM_OF_PER_ADR_FILTERS (32)
+
+/* Debug and error messages */
+#define ENABLE_PRINT (1)
+
+/* Enable printing of error messages */
+#define ENABLE_PRINT_ERR (1)
+
+/* Enable printing of Debug messages  */
+#define ENABLE_PRINT_DBG (0)
+
+/* Messages from interrupt context  */
+#define ENABLE_PRINT_INT (0)
+
+/* For printing link up/down messages */
+#define ENABLE_LINK_STATUS_PRINT (1)
+
+#if (ENABLE_PRINT == 1)
+
+    #if ( ENABLE_PRINT_DBG == 1)
+    #define GMAC_PRINT_DBG(args...) printk(KERN_INFO"GMAC:" args)
+    #else
+    #define GMAC_PRINT_DBG(args...)
+    #endif
+
+    #if ( ENABLE_PRINT_ERR == 1)
+    #define GMAC_PRINT_ERR(args...) printk(KERN_ERR"GMAC:" args)
+    #else
+    #define GMAC_PRINT_ERR(args...)
+    #endif
+
+    #if (ENABLE_PRINT_INT == 1)
+    #define GMAC_PRINT_INT(args...) printk(KERN_INFO"GMAC:" args)
+    #else
+    #define GMAC_PRINT_INT(args...)
+    #endif
+
+    #if ( ENABLE_LINK_STATUS_PRINT == 1)
+    #define GMAC_STAT_PRINT(args...) printk(KERN_INFO"GMAC:" args)
+    #else
+    #define GMAC_STAT_PRINT(args...)
+    #endif
+
+#else
+    #define GMAC_PRINT_DBG(args...)
+    #define GMAC_PRINT_ERR(args...)
+    #define GMAC_PRINT_INT(args...)
+    #define GMAC_STAT_PRINT(args...)
+#endif /* #if (ENABLE_PRINT == 1) */
+
+/* configuration options ends */
+/***************************************************************/
+
+/* Transmit descriptor macros */
+#define TXDESC_TDES0_OWN_VAL (0x80000000)
+#define TXDESC_TDES0_IHE_VAL (0x10000)
+
+#define TXDESC_TDES0_ES_VAL (0x8000)
+#define TXDESC_TDES0_JABTIMEOUT_VAL (0x4000)
+#define TXDESC_TDES0_FRMFLUSH_VAL (0x2000)
+
+#define TXDESC_TDES0_IPPAYLD_VAL (0x1000)
+#define TXDESC_TDES0_LOSSOFCAR_VAL (0x800)
+#define TXDESC_TDES0_NOCAR_VAL (0x400)
+#define TXDESC_TDES0_LATECOL_VAL (0x200)
+#define TXDESC_TDES0_EXCOL_VAL (0x100)
+#define TXDESC_TDES0_VLAN_VAL (0x80)
+#define TXDESC_TDES0_COLCNT_MSK (0x78)
+#define TXDESC_TDES0_COLCNT_POS (3)
+#define TXDESC_TDES0_EXDEF_VAL (0x4)
+#define TXDESC_TDES0_UNDERFLOW_VAL (0x2)
+#define TXDESC_TDES0_DEF_BIT_VAL (0x1)
+#define TXDESC_TDES0_TTSS_VAL (0x20000)
+
+#ifdef __ENHANCED_DESCRIPTOR__
+/* Control  Bits 30:26 */
+#define TXDESC_TDES0_INT_VAL (0x40000000)
+#define TXDESC_TDES0_LASTSEG_VAL (0x20000000)
+#define TXDESC_TDES0_FIRSTSEG_VAL (0x10000000)
+#define TXDESC_TDES0_CRC_DISABLE_VAL (0x8000000)
+#define TXDESC_TDES0_PAD_DISABLE_VAL (0x4000000)
+
+/* Control  Bits  Bits 23:20 */
+#define TXDESC_TDES0_TTSE_EN_VAL (0x2000000)
+#define TXDESC_TDES0_CIC_CLR (0xFF3FFFFF)
+#define TXDESC_TDES0_CIC_POS (22)
+
+/* Different CIC options */
+#define TXDESC_TDES0_CIC_IPHDR_CSUM (0x400000)
+#define TXDESC_TDES0_CSUM_NO_PSEUDO (0x800000)
+#define TXDESC_TDES0_CSUM_WITH_PSEUDO (0xC00000)
+
+#define TXDESC_TDES0_END_OF_RING_VAL (0x200000)
+#define TXDESC_TDES0_SEC_ADR_CHAIN_VAL (0x100000)
+
+#endif /*__ENHANCED_DESCRIPTOR__*/
+
+#ifdef __ENHANCED_DESCRIPTOR__
+/* Enhanced descriptor format */
+#define TXDESC_TDES1_TX_BUF2_SIZE_CLR (0xE000FFFF)
+#define TXDESC_TDES1_TX_BUF2_SIZE_POS (16)
+#define TXDESC_TDES1_TX_BUF1_SIZE_CLR (0xFFFFE000)
+#define TXDESC_TDES1_TX_BUF1_SIZE_MSK (0x1FFF)
+#else
+/* TDES1. Old format */
+#define TXDESC_TDES1_INT_VAL (0x80000000)
+#define TXDESC_TDES1_LASTSEG_VAL (0x40000000)
+#define TXDESC_TDES1_FIRSTSEG_VAL (0x20000000)
+#define TXDESC_TDES1_CRC_DISABLE_VAL (0x4000000)
+#define TXDESC_TDES1_END_OF_RING_VAL (0x2000000)
+#define TXDESC_TDES1_SEC_ADR_CHAIN_VAL (0x1000000)
+#define TXDESC_TDES1_PAD_DISABLE_VAL (0x800000)
+
+#define TXDESC_TDES1_TX_BUF2_SIZE_MSK (0x3ff800)
+#define TXDESC_TDES1_TX_BUF2_SIZE_POS (11)
+
+#define TXDESC_TDES1_TX_BUF1_SIZE_MSK (0x7ff)
+#define TXDESC_TDES1_TX_BUF1_SIZE_CLR (0xfffff800)
+#endif /* __ENHANCED_DESCRIPTOR__ */
+
+/* Receive descriptor macros */
+#define RXDESC_RDES0_OWN_VAL (0x80000000)
+#define RXDESC_RDES0_DST_ADR_FAIL_VAL (0x40000000)
+
+#define RXDESC_RDES0_FRM_LEN_MSK (0x3fff0000)
+#define RXDESC_RDES0_FRM_LEN_POS (16)
+
+#define RXDESC_RDES0_ERR_SUM_VAL (0x8000)
+#define RXDESC_RDES0_DESC_ERR_VAL (0x4000)
+#define RXDESC_RDES0_SRC_ADR_FAIL_VAL (0x2000)
+#define RXDESC_RDES0_LEN_ERR_VAL (0x1000)
+#define RXDESC_RDES0_OVERFLOW_ERR_VAL (0x800)
+#define RXDESC_RDES0_VLAN_TAG_VAL (0x400)
+#define RXDESC_RDES0_FIRST_DESC_VAL (0x200)
+#define RXDESC_RDES0_LAST_DESC_VAL (0x100)
+#define RXDESC_RDES0_TS_IPC_GIANT_VAL (0x80)
+#define RXDESC_RDES0_LATE_COL_VAL (0x40)
+#define RXDESC_RDES0_FRM_TYP_VAL (0x20)
+#define RXDESC_RDES0_WDOG_VAL (0x10)
+#define RXDESC_RDES0_RX_ERR_VAL (0x8)
+#define RXDESC_RDES0_DRIBBLE_VAL (0x4)
+#define RXDESC_RDES0_CRC_ERR_VAL (0x2)
+#define RXDESC_RDES0_EXTDSTAT_DAMATCH (0x1)
+
+/* RDES1 */
+#define RXDESC_RDES1_DIS_IOC_VAL (0x80000000)
+#define RXDESC_RDES1_DIS_IOC_CLR (0x7FFFFFFF)
+
+#ifdef __ENHANCED_DESCRIPTOR__
+/* Enhanced descriptor */
+#define RXDESC_RDES1_END_OF_RING_VAL (0x8000)
+#define RXDESC_RDES1_SEC_ADR_CHN_VAL (0x4000)
+#define RXDESC_RDES1_BUF2_LEN_CLR (0xE000FFFF)
+#define RXDESC_RDES1_BUF2_LEN_POS (16)
+#define RXDESC_RDES1_BUF1_LEN_MSK (0x1FFF)
+#define RXDESC_RDES1_BUF1_LEN_CLR (0xFFFFE000)
+#else
+/* Old format */
+#define RXDESC_RDES1_END_OF_RING_VAL (0x2000000)
+#define RXDESC_RDES1_SEC_ADR_CHN_VAL (0x1000000)
+#define RXDESC_RDES1_BUF2_LEN_MSK (0x3ff800)
+#define RXDESC_RDES1_BUF2_LEN_POS (11)
+#define RXDESC_RDES1_BUF1_LEN_MSK (0x7ff)
+#endif
+
+/* RDES4 -- When Type 2 checksum engine or Time Stamp feature is enabled
+** From version 3.50a onwards
+*/
+#define RXDESC_RDES4_IPV6_PKT (0x00000080)
+#define RXDESC_RDES4_IPV4_PKT (0x00000040)
+#define RXDESC_RDES4_IPCSUM_BYPASS (0x00000020)
+#define RXDESC_RDES4_IPPAYLD_ERR (0x00000010)
+#define RXDESC_RDES4_IPHDR_ERR (0x00000008)
+
+/* Descriptor size is 32 bytes */
+#define TCPIP_CSUM_ERRCHK (RXDESC_RDES4_IPPAYLD_ERR | RXDESC_RDES4_IPHDR_ERR)
+
+#define RXDESC_RDES4_IPPAYLD_TYPE_MSK (0x00000007)
+#define RXDESC_RDES4_PKT_BYPASS (0x0)
+#define RXDESC_RDES4_PKT_UDP (0x1)
+#define RXDESC_RDES4_PKT_TCP (0x2)
+#define RXDESC_RDES4_PKT_ICMP (0x3)
+#define RXDESC_RDES4_PKT_RSVD (0x8)
+
+/* Macro to mask all the DMA interrupts */
+#define DMA_MASK_ALL_INTS (0xFFFF)
+
+#define GMAC_MASK_ALL_INTS (0xF)
+
+/* Macro to clear the status bits. Bits are clear on write */
+#define DMA_CLR_ALL_INTS (0xE7FF)
+
+#define INT_STATUS_CHECK (TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL | \
+                            TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL )
+
+/* Macro for clearing receive status */
+#define RX_STAT_MSK (TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL)
+
+/* Receive interrupts macro for disabling interrupts for NAPI */
+#define RX_INT_MSK (TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL |  \
+                                TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL | \
+                                TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL )
+
+/* Desired transmit interrupts */
+/* Fatal bus error interrupt, Normal Interrupt summary,Abnormal Interrupt summary
+** Underflow interrupt enable, Transmit interrupt enable
+*/
+#define TX_INTR_VAL (TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL  | \
+                     TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL  | \
+                     TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL )
+
+/* Fatal Bus Error Interrupt, Over run error interrupt, Normal Interrupt Summary,
+** Abnormal Interrupt Summary, Receive Interrupt Enable
+*/
+#define RX_INTR_VAL (TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL )
+
+/* Early Transmit and Early Receive Interrupts */
+#define ERE_ETE_INT_VAL ( TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL | \
+                          TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL )
+
+
+/* Interrupt mask register of GMAC. Enable PMT interrupt  */
+#define TMHW_LIPP6100ETH_TS_INT_MSK_VAL (0x200)
+
+#define TMHW_LIPP6100ETH_PMT_INT_MSK_VAL (0x8)
+
+#define TMHW_LIPP6100ETH_PCSAN_INT_MSK_VAL (0x4)
+#define TMHW_LIPP6100ETH_PCSLS_INT_MSK_VAL (0x2)
+#define TMHW_LIPP6100ETH_RGMII_INT_MSK_VAL (0x1)
+
+#define GMAC_INT_MASK_VAL (TMHW_LIPP6100ETH_TS_INT_MSK_VAL | \
+                                                     TMHW_LIPP6100ETH_PCSAN_INT_MSK_VAL | \
+                                                     TMHW_LIPP6100ETH_PCSLS_INT_MSK_VAL | \
+                                                     TMHW_LIPP6100ETH_RGMII_INT_MSK_VAL)
+
+
+#define PHY_RW_MASK(_regno_,_rw_,_phy_adr_,_csr_val_) ((_phy_adr_ << 11) | \
+                                  (_regno_ << 6) | \
+                                  (_csr_val_ << 2) | \
+                                  (_rw_<< 1) | 1 )
+
+/* structure for TX descriptors */
+typedef struct TX_DESCR
+{
+    volatile __u32 TDES0;
+    volatile __u32 TDES1;
+    volatile __u32 TDES2;
+    volatile __u32 TDES3;
+
+    volatile __u32 TDES4;
+    volatile __u32 TDES5;
+    volatile __u32 TDES6;
+    volatile __u32 TDES7;
+
+} TX_DESCR_t ;
+
+typedef struct RX_DESCR
+{
+    volatile __u32 RDES0;
+    volatile __u32 RDES1;
+    volatile __u32 RDES2;
+    volatile __u32 RDES3;
+
+    volatile __u32 RDES4;
+    volatile __u32 RDES5;
+    volatile __u32 RDES6;
+    volatile __u32 RDES7;
+
+} RX_DESCR_t ;
+
+typedef struct lipp_6300Eth_WorkQ
+{
+    struct work_struct workq;       /* Work queue structure */
+    struct net_device* pNetDev; /* Pointer to network device */
+} lipp_6300Eth_WorkQ_t,*plipp_6300Eth_WorkQ_t;
+
+
+typedef struct lipp_6300Eth_Napi
+{
+    struct napi_struct napi;
+    struct net_device* pDev; /* Pointer to network device */
+} lipp_6300Eth_Napi_t,*plipp_6300Eth_Napi_t;
+
+/*
+ * GMAC private structure
+ */
+typedef struct lipp_6300Eth_PRIV
+{
+
+    void *  p_vtx ; /* allocated memory address for TX virtual address */
+    dma_addr_t  p_tx; /* physical address for TX  */
+    TX_DESCR_t *p_vtx_descr ; /* Tx descriptor array virtual address, bus width aligned */
+    dma_addr_t p_tx_descr ;/* Physical Tx descriptor array address, bus width aligned */
+    void * p_vrx ; /* allocated memory address for RX virtual address */
+    dma_addr_t p_rx ; /* allocated memory address for RX physical address */
+    RX_DESCR_t * p_vrx_descr ;	/* Rx descriptor array virtual desc address, bus width aligned */
+    dma_addr_t  p_rx_descr ; /* Rx descriptor array physical desc address, bus width aligned */
+    struct sk_buff * p_vtx_skb_list[ HW_DESCR_QUEUE_LEN_TX ] ;
+    struct sk_buff * p_vrx_skb_list[ HW_DESCR_QUEUE_LEN_RX ] ; /* SKB buffers corresponding to RX descriptors */
+    dma_addr_t p_eth_buf; /* allocated memory for Ethernet buffers physical address */
+    __s8 * p_veth_buf ; /* allocated memory for Ethernet buffers virtual address */
+    __u32 tx_produce_index ; /* Pointer to keep track of pkts submitted from application */
+    __u32 tx_consume_index ; /* Pointer to keep track of pkts processed*/
+    __u32 tx_submit_count; /* Pkts submitted for transmission on the wire */
+    __u32 rx_consume_index ; /* Pointer to keep track of receive descriptors */
+    __u32 u_speed ; /* speed setting 10/100/1000 */
+    __u32 u_mode ; /* mode setting Full Duplex, Half Duplex */
+    __u32 u_autoneg ; /* auto negotiation enable/disable */
+    __u32 u_flow_control; /* flow control enabled/disabled */
+    __u32 u_mc_filter_type ; /* multicast address filter type HW_FILTER, SW_FILTER */
+    __u32 u_all_multi ; /* allow all multicast packets */
+    __u32 u_rx_buf_size ; /* holds the maximum RX buf size */
+    __u32 u_rx_tx_fc ; /* specifies RX and TX  flow control enabled/disabled */
+    struct timer_list *phy_timer ; /* timer for probing the link status */
+    __u32 linkStatus; /* Physical link status */
+    wait_queue_head_t waitQ; /* For WoL  ioctl */
+    __u32 wolFlag; /* For WoL  ioctl */
+    struct net_device_stats stats; /* status (counters) structure */
+    spinlock_t lock ; /* serialize access to this structure */
+    __u32 hwUnitNum; /* Hardware unit  < Combination of GMAC & PHY >*/
+    lipp_6300Eth_WorkQ_t autoNegWork; /* For autonegotiating when the cable is connected/disconnected */
+    lipp_6300Eth_WorkQ_t wdTimeoutTxWork; /* Watchdog timeout  */
+    __u32 dma_enabled;
+
+    lipp_6300Eth_Napi_t napiInfo;
+    __u32 autoneg_adv; /* Current fields advertized during autonegotiation */
+
+    #ifdef __LIPP_6300ETH_DEBUG__
+    __u32 enable_mac_loopback;
+    __u32 enable_phy_loopback;
+    #endif
+
+    __u32 enable_jumbo;
+    #ifdef  CONTROL_INTR_FREQ
+    __u32 tx_int_enable_cnt; /* Frequency at which the interrupt should be generated by MAC for tx */
+    __u32 rx_intr_freq; /* Frequency at which the interrupt should be generated by MAC for rx*/
+    #endif
+
+    #ifdef LIPP_6300ETH_VLAN_TAG
+    struct vlan_group *vlgrp;
+    #endif
+
+    __u32 phy_addr_val; /* PHY address value */
+
+    __u32 clk_csr_val;  /* Clock used for reading & writing PHY registers */
+
+    __u32 shutdown;
+
+} lipp_6300Eth_PRIV_t ;
+
+//
+// driver kernel context - simulating the way a net driver works
+//
+struct _driver_kernel_context_
+{
+    char *name ;
+    void *priv ;    // pointer to data context
+};
+typedef struct _driver_kernel_context_ dk_context_t ;
+
+//
+// driver data context - simulating the way an ethernet driver works
+//
+struct _driver_data_context_
+{
+    void *p_dg_ctx ;    // pointer to driver gpl context
+};
+typedef struct _driver_data_context_ dd_context_t ;
+
+extern irqreturn_t lipp_6300Eth_isr( __s32 irq, void *dev_id) ;
+
+#endif /* _GMAC_DRV_H_ */
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/remap.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/remap.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/remap.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/remap.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,141 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:         remap.c    %
+ * %pid_version:     1.2          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  This file contains functions for remapping and unmapping 
+ *               device base addresses, for registering interrupt routines
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "remap.h"
+#include <asm/io.h>
+#include <linux/netdevice.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include "gmac_drv.h"
+
+/* Remap base addresses and assign to the global variables for 
+** accessing the device registers
+*/
+__s32 remapBaseAdrs(struct platform_device *pdev)
+{
+    struct resource *r1;
+
+    r1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!r1)
+        return -ENODEV;
+
+    if (r1->flags == IORESOURCE_MEM)
+    {
+        gtmhwLIPP6100Eth_Base[pdev->id].baseAddress = r1->start;
+    }
+    else
+    {
+        GMAC_PRINT_ERR("Error in mem address for unit %d\n", pdev->id);
+    }
+    return 0;
+}
+
+/* Register interrupt service routines for ethernet IP */
+__s32 registerInterrupts(struct platform_device *pdev)
+{
+    struct resource *r1;
+
+    struct net_device *dev = dev_get_drvdata(&pdev->dev);
+
+    /* Process the IO resources */
+    r1 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!r1)
+        return -ENODEV;
+        
+        if(r1->flags == IORESOURCE_IRQ)
+        {
+            /* This is not used in the driver. This stores the ethernet 
+            ** power mgmt interrupt only not the ethernet interrupt line.
+            */
+            dev->irq = (__u32) (r1->start);
+
+            GMAC_PRINT_ERR("Registering Ethernet ISR number %d\n",dev->irq);
+
+            if( request_irq( dev->irq, lipp_6300Eth_isr,IRQF_DISABLED,"Ethernet-LIPP_6300ETH", dev) < 0) 
+            {
+                GMAC_PRINT_ERR("Error while installing the ISR, aborting\n");
+                return -1 ;
+            }
+
+        }
+        else
+        {
+            GMAC_PRINT_ERR("Error in IO resiurce, aborting\n");
+        }
+
+    return 0;
+
+}
+
+void unmapBaseAdrs(struct platform_device *pdev)       
+{
+    struct resource *r1;
+
+    /* Process the memory resources */
+    r1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!r1)
+        return;
+                
+    if (r1->flags == IORESOURCE_MEM)
+    {
+        gtmhwLIPP6100Eth_Base[pdev->id].baseAddress = 0;
+    }
+    else
+    {
+        GMAC_PRINT_ERR("Error while unmapping the Base, aborting\n");
+    }
+}
+
+void unregisterInterrupts(struct platform_device *pdev)       
+{
+    struct resource *r1;
+
+    struct net_device *dev = dev_get_drvdata(&pdev->dev);
+
+    /* Free the IO resources */
+    r1 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!r1)
+        return;
+   
+    if (r1->flags == IORESOURCE_IRQ)
+    {
+        dev->irq = (__u32) (r1->start);
+        free_irq(dev->irq,dev);
+    }
+    else
+    {
+        GMAC_PRINT_ERR("Error while unregistering the ISR, aborting\n");
+    }
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/remap.h linux-2.6.34/drivers/net/LIPP_6300ETH/src/remap.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/remap.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/remap.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:      remap.h       %
+ * %pid_version:     1.2           %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Header file for exporting remap functions
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+#ifndef _REMAP_H_
+#define _REMAP_H_
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+
+#define REMAP_MEM_SIZE (8*1024)
+
+extern __s32 remapBaseAdrs(struct platform_device *pdev);
+extern void unmapBaseAdrs(struct platform_device * pdev);
+
+extern __s32 registerInterrupts(struct platform_device *pdev);
+extern void unregisterInterrupts(struct platform_device *pdev);
+
+
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,442 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:             tmbslPhyAccess.c %
+ * %pid_version:             1.2                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  PHY interface file for Linux Ethernet driver
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        This is to be updated if there is change in PHY hardware
+ *               Appropriate APIs are to be repopulated in the array.
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+#include "tmbslPhy.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+#define LAN_CLK_SEL        0
+#define LAN_CLK_SPEED_SEL  0
+
+#ifdef __USING_SMSC8700_PHY__
+#include "tmbslPhySMSC8700.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "SMSC8700",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhySMSC8700GetSWVersion,
+        tmbslPhySMSC8700GetCapabilities,
+        tmbslPhySMSC8700Init,
+        tmbslPhySMSC8700Deinit,
+        tmbslPhySMSC8700SetPowerState,
+        tmbslPhySMSC8700GetPowerState,
+        tmbslPhySMSC8700GetBasicModeControl,
+        tmbslPhySMSC8700SetBasicModeControl,
+        tmbslPhySMSC8700GetBasicModeStatus,
+        tmbslPhySMSC8700AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhySMSC8700LoopBack,
+        tmbslPhySMSC8700SoftReset,
+        tmbslPhySMSC8700GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef __USING_SMSC8710_PHY__
+#include "tmbslPhySMSC8710.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "SMSC8710",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhySMSC8710GetSWVersion,
+        tmbslPhySMSC8710GetCapabilities,
+        tmbslPhySMSC8710Init,
+        tmbslPhySMSC8710Deinit,
+        tmbslPhySMSC8710SetPowerState,
+        tmbslPhySMSC8710GetPowerState,
+        tmbslPhySMSC8710GetBasicModeControl,
+        tmbslPhySMSC8710SetBasicModeControl,
+        tmbslPhySMSC8710GetBasicModeStatus,
+        tmbslPhySMSC8710AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhySMSC8710LoopBack,
+        tmbslPhySMSC8710SoftReset,
+        tmbslPhySMSC8710GetLinkStatus
+    }
+
+};
+#endif
+
+#ifdef  __USING_DP83848_PHY__
+#include "tmbslPhyDP83848.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "DP83848",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyDP83848GetSWVersion,
+        tmbslPhyDP83848GetCapabilities,
+        tmbslPhyDP83848Init,
+        tmbslPhyDP83848Deinit,
+        tmbslPhyDP83848SetPowerState,
+        tmbslPhyDP83848GetPowerState,
+        tmbslPhyDP83848GetBasicModeControl,
+        tmbslPhyDP83848SetBasicModeControl,
+        tmbslPhyDP83848GetBasicModeStatus,
+        tmbslPhyDP83848AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyDP83848LoopBack,
+        tmbslPhyDP83848SoftReset,
+        tmbslPhyDP83848GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef __USING_DP83865_PHY__
+#include "tmbslPhyDP83865.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "DP83865",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyDP83865GetSWVersion,
+        tmbslPhyDP83865GetCapabilities,
+        tmbslPhyDP83865Init,
+        tmbslPhyDP83865Deinit,
+        tmbslPhyDP83865SetPowerState,
+        tmbslPhyDP83865GetPowerState,
+        tmbslPhyDP83865GetBasicModeControl,
+        tmbslPhyDP83865SetBasicModeControl,
+        tmbslPhyDP83865GetBasicModeStatus,
+        tmbslPhyDP83865AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyDP83865LoopBack,
+        tmbslPhyDP83865SoftReset,
+        tmbslPhyDP83865GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef __USING_APOLLO_EMU_PHY__
+#include "tmbslPhyEmu.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "EMULATOR",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEmuGetSWVersion,
+        tmbslPhyEmuGetCapabilities,
+        tmbslPhyEmuInit,
+        tmbslPhyEmuDeinit,
+        tmbslPhyEmuSetPowerState,
+        tmbslPhyEmuGetPowerState,
+        tmbslPhyEmuGetBasicModeControl,
+        tmbslPhyEmuSetBasicModeControl,
+        tmbslPhyEmuGetBasicModeStatus,
+        tmbslPhyEmuAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEmuLoopBack,
+        tmbslPhyEmuSoftReset,
+        tmbslPhyEmuGetLinkStatus
+    },
+	{  "EMULATOR",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEmuGetSWVersion,
+        tmbslPhyEmuGetCapabilities,
+        tmbslPhyEmuInit,
+        tmbslPhyEmuDeinit,
+        tmbslPhyEmuSetPowerState,
+        tmbslPhyEmuGetPowerState,
+        tmbslPhyEmuGetBasicModeControl,
+        tmbslPhyEmuSetBasicModeControl,
+        tmbslPhyEmuGetBasicModeStatus,
+        tmbslPhyEmuAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEmuLoopBack,
+        tmbslPhyEmuSoftReset,
+        tmbslPhyEmuGetLinkStatus
+    }
+
+};
+#endif
+
+#ifdef __USING_EMU_PHY__
+#include "tmbslPhyEmu.h"
+/* PHY interface structure to store PHY register access functions */
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] =
+{
+    {  "EMULATOR",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEmuGetSWVersion,
+        tmbslPhyEmuGetCapabilities,
+        tmbslPhyEmuInit,
+        tmbslPhyEmuDeinit,
+        tmbslPhyEmuSetPowerState,
+        tmbslPhyEmuGetPowerState,
+        tmbslPhyEmuGetBasicModeControl,
+        tmbslPhyEmuSetBasicModeControl,
+        tmbslPhyEmuGetBasicModeStatus,
+        tmbslPhyEmuAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEmuLoopBack,
+        tmbslPhyEmuSoftReset,
+        tmbslPhyEmuGetLinkStatus
+    }
+
+};
+
+#endif
+
+#include "tmbslPhyRTL8211BN.h"
+#include "tmbslPhyMYSTI110E.h"
+#include "tmbslPhyIntel972.h"
+#ifdef CONFIG_EN2510_PHY
+#include "tmbslPhyEN2510.h"
+#else
+#include "tmbslPhyEN2512.h"
+#endif
+
+tmbslPhyConfig_t gtmbslRTL8211BNPhyInterface =
+{
+       "RTL-8211BN",
+        0x001cc912,
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyRTL8211BNGetSWVersion,
+        tmbslPhyRTL8211BNGetCapabilities,
+        tmbslPhyRTL8211BNInit,
+        tmbslPhyRTL8211BNDeinit,
+        tmbslPhyRTL8211BNSetPowerState,
+        tmbslPhyRTL8211BNGetPowerState,
+        tmbslPhyRTL8211BNGetBasicModeControl,
+        tmbslPhyRTL8211BNSetBasicModeControl,
+        tmbslPhyRTL8211BNGetBasicModeStatus,
+        tmbslPhyRTL8211BNAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyRTL8211BNLoopBack,
+        tmbslPhyRTL8211BNSoftReset,
+        tmbslPhyRTL8211BNGetLinkStatus
+};
+
+tmbslPhyConfig_t gtmbslMYSTIPhyInterface =
+{       
+        "Internal",
+        0x0,
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyMYSTI110EGetSWVersion,
+        tmbslPhyMYSTI110EGetCapabilities,
+        tmbslPhyMYSTI110EInit,
+        tmbslPhyMYSTI110EDeinit,
+        tmbslPhyMYSTI110ESetPowerState,
+        tmbslPhyMYSTI110EGetPowerState,
+        tmbslPhyMYSTI110EGetBasicModeControl,
+        tmbslPhyMYSTI110ESetBasicModeControl,
+        tmbslPhyMYSTI110EGetBasicModeStatus,
+        tmbslPhyMYSTI110EAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyMYSTI110ELoopBack,
+        tmbslPhyMYSTI110ESoftReset,
+        tmbslPhyMYSTI110EGetLinkStatus
+};
+
+#ifdef CONFIG_EN2510_PHY
+tmbslPhyConfig_t gtmbslMoCAPhyInterface =
+{
+       "EN2510",
+        0x0,
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEN2510BNGetSWVersion,
+        tmbslPhyEN2510BNGetCapabilities,
+        tmbslPhyEN2510BNInit,
+        tmbslPhyEN2510BNDeinit,
+        tmbslPhyEN2510BNSetPowerState,
+        tmbslPhyEN2510BNGetPowerState,
+        tmbslPhyEN2510BNGetBasicModeControl,
+        tmbslPhyEN2510BNSetBasicModeControl,
+        tmbslPhyEN2510BNGetBasicModeStatus,
+        tmbslPhyEN2510BNAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEN2510BNLoopBack,
+        tmbslPhyEN2510BNSoftReset,
+        tmbslPhyEN2510BNGetLinkStatus
+        
+};
+#else
+tmbslPhyConfig_t gtmbslMoCAPhyInterface =
+{
+       "EN2512",
+        0x0,
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEN2512BNGetSWVersion,
+        tmbslPhyEN2512BNGetCapabilities,
+        tmbslPhyEN2512BNInit,
+        tmbslPhyEN2512BNDeinit,
+        tmbslPhyEN2512BNSetPowerState,
+        tmbslPhyEN2512BNGetPowerState,
+        tmbslPhyEN2512BNGetBasicModeControl,
+        tmbslPhyEN2512BNSetBasicModeControl,
+        tmbslPhyEN2512BNGetBasicModeStatus,
+        tmbslPhyEN2512BNAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEN2512BNLoopBack,
+        tmbslPhyEN2512BNSoftReset,
+        tmbslPhyEN2512BNGetLinkStatus
+};
+#endif
+
+tmbslPhyConfig_t gtmbslLXT972APhyInterface =
+{
+    "LXT972A/RTL8201",
+    0x001378e2,
+    LAN_CLK_SEL,
+    LAN_CLK_SPEED_SEL,
+    tmbslPhyIntel972GetSWVersion,
+    tmbslPhyIntel972GetCapabilities,
+    tmbslPhyIntel972Init,
+    tmbslPhyIntel972Deinit,
+    tmbslPhyIntel972SetPowerState,
+    tmbslPhyIntel972GetPowerState,
+    tmbslPhyIntel972GetBasicModeControl,
+    tmbslPhyIntel972SetBasicModeControl,
+    tmbslPhyIntel972GetBasicModeStatus,
+    tmbslPhyIntel972AutoNegotiate,
+    Null,
+    Null,
+    Null,
+    Null,
+    Null,
+    Null,
+    Null,
+    tmbslPhyIntel972LoopBack,
+    tmbslPhyIntel972SoftReset,
+    tmbslPhyIntel972GetLinkStatus
+};
+
+phyID_interface_tbl phy_tbl[]={
+{0x0, &gtmbslMYSTIPhyInterface},
+{0x001cc912, &gtmbslRTL8211BNPhyInterface},
+{0x0, &gtmbslMoCAPhyInterface},
+{0x00008201, &gtmbslLXT972APhyInterface},
+{0x001378e2, &gtmbslLXT972APhyInterface}
+};
+
+void tmbslPhyGetInterface(int unitnumber, UInt32 phyID, UInt32 isExternal, tmbslPhyConfig_t ** pPhyInterface)
+{
+    UInt32 i;
+
+    if(!isExternal)
+    {
+        *(pPhyInterface) = phy_tbl[0].interface_fns;
+        return;
+    }
+    else
+    {
+        for(i=1 ; i< sizeof(phy_tbl)/sizeof(phyID_interface_tbl); i++)
+            if(phy_tbl[i].phyID == phyID)
+                *(pPhyInterface) = phy_tbl[i].interface_fns;
+    }
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,187 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          crc.c %
+ * %pid_version:           1.1         %
+ *---------------------------------------------------------------------------  
+ * DESCRIPTION:      CRC 32 & 16 calculation
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+
+static unsigned long crc_table[256];
+static int first =0;
+
+static void gen_table(void)                /* build the crc table */
+{
+    unsigned long crc, poly;
+    int	i, j;
+
+    poly = 0xEDB88320L;
+    for (i = 0; i < 256; i++)
+        {
+        crc = i;
+        for (j = 8; j > 0; j--)
+            {
+            if (crc & 1)
+                crc = (crc >> 1) ^ poly;
+            else
+                crc >>= 1;
+            }
+        crc_table[i] = crc;
+        }
+}
+
+/* Bitwise reversal of CRC obtained */
+static unsigned long reverse_crc(unsigned long crc)
+{
+	int i;
+      unsigned long val=0;
+	for(i=0;i<32;i++)
+	{
+	   if((crc & 0x1) > 0)
+		{
+		val |= 1 << (31-i);
+		}	         		
+	  crc >>=1;
+	}
+	
+	return val;
+}
+
+unsigned long get_crc32( unsigned char *fp)    /* calculate the crc value */
+{
+    register unsigned long crc;
+    int i;
+
+    crc = 0xFFFFFFFF;
+
+    if(first == 0)
+    {
+        gen_table();
+        first =1;
+    }
+
+    for(i=0;i<6; i++)
+    {
+        crc = (crc>>8) ^ crc_table[ (crc^(*fp++)) & 0xFF ];
+    }
+
+
+    crc ^=0xFFFFFFFF;
+    crc = reverse_crc(crc);
+
+    return(crc);
+
+}
+
+
+/**************************************************************/
+                                               /* CRC16  */
+/**************************************************************/
+/*
+ *      crc16.c
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2. See the file COPYING for more details.
+ */
+
+
+/** CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */
+static unsigned short crc16_table[256] = {
+	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
+	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
+	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
+	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
+	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
+	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
+	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
+	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
+	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
+	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
+	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
+	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
+	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
+	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
+	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
+	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
+	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
+	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
+	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
+	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
+	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
+	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
+	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
+	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
+	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
+	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
+	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
+	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
+	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
+	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
+	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
+	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
+};
+
+unsigned short crc16_byte(unsigned short crc, unsigned char data);
+
+/**
+ * Compute the CRC-16 for the data buffer
+ *
+ * @param crc     previous CRC value
+ * @param buffer  data pointer
+ * @param len     number of bytes in the buffer
+ * @return        the updated CRC value
+ */
+unsigned short get_crc16(unsigned short crc, unsigned char*buffer, unsigned int len)
+{
+    while (len--)
+        crc = crc16_byte(crc, *buffer++);
+    return crc;
+}
+
+unsigned short crc16_byte(unsigned short crc, unsigned char data)
+{
+    return (crc >> 8) ^ crc16_table[(crc ^ data) & 0xff];
+}
+
+
+unsigned short reverse_crc16(unsigned short crc)
+{
+	int i;
+      unsigned short val=0;
+	for(i=0;i< 16 ;i++)
+	{
+	   if((crc & 0x1) > 0)
+		{
+		val |= 1 << (15-i);
+		}	         		
+	   crc >>=1;
+      	}
+	
+	return val;
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.h linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/crc.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,45 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          crc.h %
+ * %pid_version:           1.1         %
+ *---------------------------------------------------------------------------  
+ * DESCRIPTION:      CRC 32 & 16 calculation
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#ifndef _CRC_H_
+#define _CRC_H_
+
+/*------------------------------ crc.h ----------------------*/
+unsigned long get_crc32(unsigned char *fp);   /* calculate the crc32 value */
+/*-----------------------------------------------------------*/
+
+unsigned short  get_crc16(unsigned short crc,  unsigned char *buffer, unsigned int len);
+unsigned short reverse_crc16(unsigned short crc);
+
+#endif
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/ioctlsTest.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/ioctlsTest.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/ioctlsTest.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/ioctlsTest.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,845 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          ioctlsTest.c %
+ * %pid_version:           1.0         %
+ *---------------------------------------------------------------------------  
+ * DESCRIPTION:      Test application to test the wol & debug ioctls of LIPP_6300ETH driver
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#include <stdio.h> /* perror/printf functions */
+#include <stdlib.h> /* exit calls */ 
+#include <unistd.h> /* close */
+#include <errno.h>
+#include <string.h> /* strncpy */
+#include <linux/types.h>
+#include <sys/socket.h> /* For sockets */ 
+#include <netinet/in.h> /* sockaddr_in */
+#include <arpa/inet.h>
+
+#include <linux/if.h>  /* def of ifr */
+#include <sys/ioctl.h> /* ioctl call */
+#include <linux/errno.h>
+
+
+#include <gmac_ioctl.h>
+
+#include <crc.h>
+
+/* Local macros */
+#define WKUP_OFFSET (14)
+#define TX_BUFF1_SIZE (1024)
+#define ETH_ADR_LEN (6)
+
+#define DATA_SIZE (1472) // max number of bytes we can get at once 
+unsigned char gTxDataBuffer[DATA_SIZE];
+
+/* Local  Function prototypes */
+void construct_ethernet_pkt(
+    __u8* pSrc_adr,
+    __u8* pDest_adr,
+    __u16 type,
+    __u8 *pDataBuffer,
+    __u32 BufSize,
+    __u8 *pEthernetFrame
+);
+
+void SetupWakeupFrameFilter(
+    pwakeupinfo_t pWolCfg,
+    __u32 filterNo,
+    bool frameType); /* True => Multicast or False =>Unicast frame */
+
+void test_wol(void);
+void test_regs(void);
+void rmonIoctl(void);
+
+
+int main(void)
+{
+
+//    test_wol();
+
+//    test_regs();    
+    rmonIoctl();
+
+    return 0;
+
+}
+
+void test_wol(void)
+{
+
+    __u32 loopCnt;
+    gmacWoLinfo_t wol;
+    bool multicastFlag = True;
+    __s32 sockfd;
+    struct ifreq ifr;    
+    __u8*ifname = "eth0";
+    __s32 ret;
+    struct sockaddr_in to_addr;
+    unsigned int i;
+    unsigned int totalTxBytes;
+
+    to_addr.sin_family = AF_INET;    // host byte order 
+    to_addr.sin_port = htons(9999);  // short, network byte order 
+    inet_aton("10.0.0.2", &(to_addr.sin_addr));
+    
+    memset(&(to_addr.sin_zero), '\0', 8);  // zero the rest of the struct 
+
+    if ((sockfd = socket(PF_INET,SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    printf("\nSending UDP frames\n");       
+
+    /* Keep sending until all the data is sent */
+    for(i=0;i < 100;i++)    
+    {
+
+        /* Send the UDP frames  */        
+        totalTxBytes = sendto(sockfd,&gTxDataBuffer[0],DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+
+    }
+
+    strncpy(ifr.ifr_name,ifname,sizeof(ifr.ifr_name));
+
+    for(loopCnt=0; loopCnt < 10; loopCnt++)
+    {
+
+        memset(&wol,0,sizeof(gmacWoLinfo_t));
+
+         /* Set the wake up procedure before going to power down mode */
+        if(loopCnt == 0)
+        {
+            printf("\nWoL with Magic Packet : Select Option 9 on WoL Menu\n");
+            /* Wakeup on Magic packet */
+            wol.magicPktEn = True;
+        }
+        else if(loopCnt == 1)
+        {
+            printf("\nWoL with Global Unicast Frame : Select Option 10 on WoL Menu\n");
+            /* Wakeup on Unicast frame reception */
+            wol.magicPktEn = False;
+            wol.globalUnicastEn = True;
+        }
+        else
+        {
+
+            /* Wake on reception of Wakeup Frame */
+            wol.globalUnicastEn = False;
+            wol.wkupFrameEn = True;
+
+            if(loopCnt > 5)
+            {
+                multicastFlag = False;
+                /* Select option 5 for first Unicast wakeup frame, 6 for the 2nd ... 8th for the last frame */
+                printf("\nWoL with Unicast Wakeup Frame : Choose Option %u on WoL Menu",(loopCnt-1));
+            }
+            else
+            {
+                /* Select option 1 for first Multicast wakeup frame, 2 for the 2nd ... 4th for the last frame */
+                printf("\nWoL with Multicast Wakeup Frame:Choose Option %u on WoL Menu",(loopCnt-1));
+            }
+
+            /* Program the wakeup filter register, for Multicast frame */
+            SetupWakeupFrameFilter(&wol.wkupinfo,(loopCnt-2),multicastFlag);
+
+        }
+
+        /* Call the ioctl to put the core in power down mode */
+        ifr.ifr_data = &wol;
+
+        printf("\nPower Down Mode:Enter\n");
+
+        ret = ioctl(sockfd,ETH_POWER_DOWN,&ifr);  
+        
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+        }
+        
+        printf("\nPower Down Mode :Exit\n");
+
+   }
+
+    printf("\nSending UDP frames...\n");       
+
+    /* Keep sending until all the data is sent */
+    for(i=0;i < 100;i++)    
+    {
+
+        /* Send the UDP frames  */        
+        totalTxBytes = sendto(sockfd,&gTxDataBuffer[0],DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+
+    }
+
+    printf("\nWoL Test Complete\n");           
+
+    close(sockfd);
+
+}
+
+void SetupWakeupFrameFilter(
+    pwakeupinfo_t pWolCfg,
+    __u32 filterNo,
+    bool frameType) /* True => Multicast or False =>Unicast frame */
+{
+
+    /* Initialize the CRC variable */
+    __u16  crc = 0xFFFF;
+
+    __u32 i;
+    __u8 ethData[1500];
+    __u8 ethernetFrame[1500];
+    __u8* pEthFrame;
+
+    /* Dummy address for frame construction. Actual frame is generated from Libnet.
+    ** DUT is the one which receives the wakeup frame
+    */
+    __u8 dst_adr[6] = {0x01,0x5e,0xcc,0xdd,0xee,0xff}; /* Multicast address */
+    __u8 src_adr[6] = {0xa0,0xb0,0xc0,0xd0,0xe0,0xf0};
+
+    __u16 type = 1024;
+
+    if (filterNo >= 4)
+    {
+        filterNo -=4;
+    }
+
+    for(i=0;i<1024;i++)
+    {
+        /* Change the pattern for different filter */
+        ethData[i] = filterNo+i+1;
+    }
+
+    construct_ethernet_pkt(src_adr,dst_adr,type,ethData,
+                           TX_BUFF1_SIZE,&ethernetFrame[0]);
+
+    pEthFrame = &ethernetFrame[0];
+
+    /* Test with one wakeup frame filter register 0.
+    ** Untouched values are assumed to be zero
+    ** Change the mask for each filter, for testing
+    */
+    pWolCfg->filterMask[0] = 0xF;
+    pWolCfg->filterMask[1] = 0xF;
+    pWolCfg->filterMask[2] = 0xF;
+    pWolCfg->filterMask[3] = 0xF;
+
+    /* Bit 3 specifies the address type, when 1, it is a multicast frame
+    ** is checked for this pattern else it is a unicast
+    ** Bit 0 when set, enables the filter
+    */
+
+    /* True => multicast wakeup frame */
+    if(frameType == True)
+    {
+        /* Set the Multicast bit and filter enable bit for corresponding filter */
+        pWolCfg->filterCommand = (0x9 << (filterNo *8));
+    }
+    else
+    {
+        /* Unicast wakeup frame */
+        pWolCfg->filterCommand = (0x1 << (filterNo *8));
+    }
+
+    /* Range is 12 to 255. */
+    pWolCfg->filterOffset = (WKUP_OFFSET << (filterNo*8)) ;
+
+    /* Calculate CRC-16 to be programmed */
+    for (i=0;i < 31; i++)
+    {
+        /* Calculate the CRC-16 for the byte mask specified */
+        if(pWolCfg->filterMask[filterNo] & (1 << i))
+        {
+            crc = get_crc16(crc,&pEthFrame[WKUP_OFFSET+i],1);
+        }
+
+    }
+
+    crc = reverse_crc16(crc);
+
+    if(filterNo > 1 )
+    {
+        /* Filter 2 & 3 */
+        pWolCfg->filterCrcVal7 =  (crc << ((filterNo-2)*16));
+    }
+    else
+    {
+        /* Filter 0 & 1 */
+        pWolCfg->filterCrcVal6 =  (crc << (filterNo*16));
+    }
+
+
+}
+
+
+void construct_ethernet_pkt(
+    __u8* pSrc_adr,
+    __u8* pDest_adr,
+    __u16 type,
+    __u8 *pDataBuffer,
+    __u32 BufSize,
+    __u8 *pEthernetFrame
+)
+{
+
+    memcpy(pEthernetFrame,pDest_adr,ETH_ADR_LEN);
+    memcpy(pEthernetFrame+6,pSrc_adr,ETH_ADR_LEN);
+
+    /* Type field 2 bytes */
+    *(pEthernetFrame+12) =  (type & 0xFF00) >> 8; /* MSB  */
+    *(pEthernetFrame+13) = type & 0xFF;           /* LSB */
+
+    memcpy(pEthernetFrame+14,pDataBuffer,BufSize);
+
+    return;
+
+}
+
+void test_regs(void)
+{
+
+    gmacRegs_t gmac;
+    
+    struct ifreq ifr;    
+    
+    __u8*ifname = "eth0";
+    
+    __u32 i,phyadr;
+
+    __s32 sockfd,ret;
+    
+
+    if ((sockfd = socket(PF_INET,SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    strncpy(ifr.ifr_name,ifname,sizeof(ifr.ifr_name));
+
+    ifr.ifr_data = &gmac;    
+
+    /* 1 for write, 0 for read */
+    gmac.rwFlag = 0;
+
+    /* Print DMA regs */
+    printf("\n\nDMA REGISTERS");
+
+    for(i= 0x1000; i <= 0x1020;i=i+4)
+    {
+
+        gmac.regOffset = i;     
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+        
+        printf("\n %08x %08x ",gmac.regOffset,gmac.regValue);
+
+    }
+
+    for(i= 0x1048; i <= 0x1054;i=i+4)
+    {
+        gmac.regOffset = i;     
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+        
+        printf("\n %08x %08x ",gmac.regOffset,gmac.regValue);
+
+    }
+
+    printf("\n\nGMAC REGISTERS");
+    for(i= 0x0; i <= 0x20;i=i+4)
+    {
+        gmac.regOffset = i;     
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+        
+        printf("\n %08x %08x ",gmac.regOffset,gmac.regValue);
+
+    }
+
+    printf("\n\nRemote Wakeup frame filter");
+
+    gmac.regOffset = 0x28;     
+
+    for(i= 0x0; i <= 0x7; i++)
+    {
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+
+        printf("\n %08x %08x ",gmac.regOffset,gmac.regValue);
+
+    }
+
+    printf("\n\nPMT Control & Status");
+    
+    gmac.regOffset = 0x2C;     
+
+    ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\n %08x %08x \n",gmac.regOffset,gmac.regValue);
+
+    printf("\n\nGMAC REGISTERS contd...");
+
+    for(i= 0x38; i <= 0xD8;i=i+4)
+    {
+        gmac.regOffset = i;
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+
+        printf("\n %08x %08x ",gmac.regOffset,gmac.regValue);
+
+    }
+
+    printf("\n\nPHY REGISTERS");
+
+    gmac.rwFlag = False; /* Read or write operation */
+
+    gmac.rwPhyRegs = True; /*Set to True, to access PHY registers */
+
+#ifdef __DP83848PHY__
+    for (phyadr=0; phyadr <=7;phyadr++) 
+#endif
+
+    for (phyadr=0; phyadr <=6;phyadr++) 
+    {
+        gmac.regOffset = phyadr; 
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+
+        printf("\n %08x %08x \n",phyadr,gmac.regValue);
+
+    }
+
+    for (phyadr=16; phyadr <=18;phyadr++) 
+    {
+        gmac.regOffset = phyadr; 
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+
+        printf("\n %08x %08x \n",phyadr,gmac.regValue);
+
+    }
+    
+
+    for (phyadr=26; phyadr <=31;phyadr++) 
+    {
+
+        gmac.rwFlag = 0;
+        gmac.regOffset = phyadr; 
+
+        ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+        if (ret == -1) 
+        {
+            printf("\nIoctl Error: errno :%d\n",errno);
+            return;
+        }
+
+        printf("\n %08x %08x \n",phyadr,gmac.regValue);
+
+    }
+
+    printf("\nWRITE OPERATION GMAC \n");
+
+    gmac.rwFlag = True;  /* write operation */
+
+    gmac.rwPhyRegs = False; /* Set to True, to access PHY registers */
+
+    gmac.regOffset = 0x08;  /* Hash table High */
+    gmac.regValue = 0xFFFFFFFF;
+
+    ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\n Written HTH reg %08x %08x\n",gmac.regOffset,gmac.regValue);
+
+    gmac.rwFlag = False;  /* Read  operation */
+
+    ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\n Read from HTH reg %08x %08x\n",gmac.regOffset,gmac.regValue);
+
+
+    printf("\nWRITE OPERATION to PHY \n");
+    gmac.rwFlag = True;  /* Read or write operation */
+
+    gmac.rwPhyRegs = True; /*Set to True, to access PHY registers */
+
+    gmac.regOffset = 30;  /* Interrupt mask register of PHY */
+
+    gmac.regValue = 0xFE;
+
+    ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\n Written value to Int reg of PHY %08x %08x\n",gmac.regOffset,gmac.regValue);
+
+    gmac.rwFlag = False;  /* Read or write operation */
+
+    ret = ioctl(sockfd,ETH_GMAC_DEBUG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\n Read value to Int reg of PHY %08x %08x\n",gmac.regOffset,gmac.regValue);
+
+    printf("\n");   
+
+    return;
+
+}
+
+
+void rmonIoctl(void)
+{
+
+    rmonRegsRd_t rmonReg;
+    rmonCtrl_t rmonCtrl;
+    
+    struct ifreq ifr;    
+    
+    __u8*ifname = "eth0";
+    
+    __s32 sockfd,ret;
+    
+    if ((sockfd = socket(PF_INET,SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    strncpy(ifr.ifr_name,ifname,sizeof(ifr.ifr_name));
+    
+    ifr.ifr_data = &rmonCtrl; 
+
+    rmonCtrl.rollOverDisable = True;
+    rmonCtrl.resetOnRdEn = False;
+    rmonCtrl.freezeCntrs = False;
+    rmonCtrl.resetCounters = False;
+    
+    ret = ioctl(sockfd,ETH_DRV_RMON_CONFIG,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    ifr.ifr_data = &rmonReg; 
+    
+    //etherStatsDropEvents Counter,     
+    rmonReg.regToRd = RX_OCTET_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_OCTET_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+
+    rmonReg.regToRd = RX_FRM_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_FRM_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+
+    rmonReg.regToRd = RX_BRDCSTF_CNT_G;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_BRDCSTF_CNT_G:%08x \n",rmonReg.mmcRegVal);
+
+    rmonReg.regToRd = RX_MULTCSTF_CNT_G;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_MULTCSTF_CNT_G:%08x \n",rmonReg.mmcRegVal);
+
+
+    rmonReg.regToRd = RX_CRC_ERR_CNT;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_CRC_ERR_CNT:%08x \n",rmonReg.mmcRegVal);
+
+    rmonReg.regToRd = RX_ALIGNMT_ERR_CNT;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+        return;
+    }
+
+    printf("\nRX_ALIGNMT_ERR_CNT:%08x \n",rmonReg.mmcRegVal);
+
+
+    rmonReg.regToRd = RX_UNDERSIZE_CNT_G;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_UNDERSIZE_CNT_G:%08x \n",rmonReg.mmcRegVal);
+
+
+    rmonReg.regToRd = RX_OVERSIZE_CNT_G;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_OVERSIZE_CNT_G:%08x \n",rmonReg.mmcRegVal);
+    
+
+    rmonReg.regToRd = RX_RUNT_ERR_CNT;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_RUNT_ERR_CNT:%08x \n",rmonReg.mmcRegVal);
+    
+
+    rmonReg.regToRd = RX_JABBER_ERR_CNT;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_JABBER_ERR_CNT:%08x \n",rmonReg.mmcRegVal);
+    
+
+//etherStatsCollisions ?? TX_EXCESSCOL_CNT TX_LATECOL_CNT TX_MULTICOL_COL_G
+
+
+    rmonReg.regToRd = RX_64_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_64_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+
+
+    rmonReg.regToRd = RX_65TO127_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_65TO127_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+    
+
+    rmonReg.regToRd = RX_128TO255_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_128TO255_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+    
+
+    rmonReg.regToRd = RX_256TO511_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_256TO511_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+    
+
+    rmonReg.regToRd = RX_512TO1023_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_512TO1023_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+
+
+    rmonReg.regToRd = RX_1024TOMAX_CNT_GB;
+
+    ret = ioctl(sockfd,ETH_DRV_RMON_READ,&ifr);  
+
+    if (ret == -1) 
+    {
+    printf("\nIoctl Error: errno :%d\n",errno);
+    return;
+    }
+
+    printf("\nRX_1024TOMAX_CNT_GB:%08x \n",rmonReg.mmcRegVal);
+    
+
+
+
+}
+
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/makefile	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,22 @@
+
+CC= $(CROSS_COMPILE)gcc
+
+export KERN_DIR = ../../../../../../
+export HDR_PATH = ../../../../../../include/net/LIPP_6300ETH/
+
+CFLAGS = -c -EL -I$(HDR_PATH) -I. -I$(KERN_DIR)  -Wall
+
+all: ioctls.out
+
+ioctls.out : ioctlsTest.o crc.o
+	$(CC) -EL -Bstatic ioctlsTest.o crc.o -o ioctls.out
+
+ioctlsTest.o : ioctlsTest.c
+	$(CC) $(CFLAGS) ioctlsTest.c
+
+crc.o : crc.c
+	$(CC) $(CFLAGS) crc.c
+
+clean:
+	rm -rf *o wol *.out
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/wolpkts.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/wolpkts.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ioctl/wolpkts.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ioctl/wolpkts.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,183 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2008-2009,  NXP Semiconductors
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:           wolpkts.c      %
+ * %pid_version:         1.0             %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   Wakeup frame generation file for WoL test run on target
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#include "/usr/include/linux/config.h"
+#include "stdio.h"
+#include "/usr/include/libnet.h"
+#include "/usr/include/libnet/libnet-structures.h"
+  
+void PktGen_WakeupFrame(void);
+
+/* Macro definitions */
+char  err_buf[LIBNET_ERRBUF_SIZE] ;
+
+/**************************Main****************************/
+int main(void)
+{
+
+    PktGen_WakeupFrame();
+
+    return (EXIT_SUCCESS);
+}
+
+void PktGen_WakeupFrame(void)
+{
+    u_int32_t input,i;
+    libnet_t* pLibNetContext;
+    libnet_ptag_t  ptag; 
+    int length;
+    char* device = NULL;    
+    u_int8_t ethernetframe[1500]={0};
+    u_int8_t MultDestAdr[6] = {0x01,0x5e,0x10,0x20,0x30,0x40};
+    u_int8_t DstAdr[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
+    u_int8_t*pDstAdr = DstAdr;
+    u_int8_t SrcAdr[6] = {0x11,0x22,0x33,0x44,0x55,0x66};
+    u_int16_t Type = 1024;
+    u_int8_t* bufAdr;
+
+__pwr_mgt_menu__ :
+    printf("\nSelect the Wakeup Frame from the Menu");
+    printf("\n      1:  Multicast Wakeup Frame for Filter 0");        
+    printf("\n      2:  Multicast Wakeup Frame for Filter 1");
+    printf("\n      3:  Multicast Wakeup Frame for Filter 2");                            
+    printf("\n      4:  Multicast Wakeup Frame for Filter 3");
+    printf("\n      5:  Unicast Wakeup Frame for Filter 0");            
+    printf("\n      6:  Unicast Wakeup Frame for Filter 1");            
+    printf("\n      7:  Unicast Wakeup Frame for Filter 2");
+    printf("\n      8:  Unicast Wakeup Frame for Filter 3");                            
+    printf("\n      9:  Generate Magic Packet");    
+    printf("\n      10: Generate Global Unicast Frame\n");
+    printf("\n      Enter 0 (zero) to Quit\n");                            
+    scanf("%d",&input);
+
+    switch(input)
+    {
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+        if((input >= 1) && (input <= 4) )
+        {
+            pDstAdr = MultDestAdr;            
+        }
+        else
+        {
+            input-=4; /*Same data pattern for Unicast frames also */        
+            pDstAdr = DstAdr;                    
+        }
+
+        for(i=0;i<1024;i++)
+        {
+            /* Change the pattern for different filter */    
+            ethernetframe[i] = i+input;
+        }
+
+        break;
+
+    case 9:
+        /*  Construct a magic packet 
+        ** 6 bytes of  all 1s 
+        */
+        bufAdr = ethernetframe;
+        pDstAdr = DstAdr;                            
+        
+        memset(ethernetframe,0xFF,6);
+        
+        /* Destination address repeated 16 times */
+        for(i=0;i<16;i++)
+        {
+            bufAdr+= 6;
+            memcpy(bufAdr,DstAdr,6);
+        }
+        Type = 102;
+
+        break;            
+
+    case 10:
+            /* Payload data */
+        memset(ethernetframe,0x39,1024);        
+        break;                    
+
+    default:
+        return;
+        break;
+    }
+
+    /* Initialize Libnet for packet transmission on wire */
+    pLibNetContext =  libnet_init(LIBNET_LINK,
+                                  device,  /* Ethernet interface string or IP address ("10.0.0.5")*/
+                                  err_buf ); 
+    if (NULL == pLibNetContext)
+    {
+        printf("\nLibNet Init failed. Error Code =%s",err_buf);
+        return;
+    }
+
+    ptag = libnet_build_ethernet(pDstAdr, 
+                                           SrcAdr,
+                                           Type,
+                                           ethernetframe,
+                                           Type,
+                                           pLibNetContext,
+                                           LIBNET_PTAG_INITIALIZER);
+    if(-1 == ptag)
+    {
+        printf("\nlibnet_build_ethernet Failed");
+        return;        
+    }
+
+    length = libnet_write(pLibNetContext);
+    
+    if (length == -1)
+    {
+        printf("\nWrite error");
+    }
+    else
+    {
+        printf("\nPkt %u of Length %d Txmted",i+1,length);
+    }
+
+    libnet_destroy(pLibNetContext);
+
+    printf("\n");
+
+    goto __pwr_mgt_menu__;    
+
+}
+
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpclient.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpclient.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpclient.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpclient.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,137 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:            tcpclient.c %
+ * %pid_version:          1.2         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  TCP client application which loops back data received
+ *               without memory comparison.
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+#define PORT 3490 /*  the port client will be connecting to */
+
+#define DATA_SIZE (1024) /* max number of bytes we can get at once */
+unsigned char gRxDataBuffer[DATA_SIZE];
+unsigned char *gRxDataptr = gRxDataBuffer;
+unsigned int dataCnt;
+
+int main(void)
+{
+    int sockfd, numbytes;  
+
+    struct sockaddr_in their_addr; /* connector's address information */
+    unsigned int offset,sentCnt,txferSize;
+    unsigned int totalRxBytes;
+
+    printf("Client App\n");
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) 
+    {
+        perror("socket");
+        printf("Socket Failed\n");
+        exit(1);
+    }
+
+    their_addr.sin_family = AF_INET;    /* host byte order */
+    their_addr.sin_port = htons(PORT);  /* short, network byte order */
+    inet_aton("10.0.0.7", &(their_addr.sin_addr));
+    memset(&(their_addr.sin_zero), '\0', 8); /* zero the rest of the struct */
+
+    if (connect(sockfd, (struct sockaddr *)&their_addr,
+                                          sizeof(struct sockaddr)) == -1) 
+    {
+        perror("connect");
+        printf("Connection Failed\n");
+        exit(1);
+    }
+
+    offset =0;	
+    totalRxBytes = DATA_SIZE;
+
+    printf("\n");        
+
+    /* Keep reading until you receive all the data from Server */
+    while(totalRxBytes > 0)
+    {
+        numbytes = recv(sockfd,(gRxDataptr+offset),totalRxBytes,0);
+        if(-1 == numbytes ) 
+        {
+            perror("recv");
+            printf("Recv Error\n");        
+            exit(1);
+        }
+
+        printf("Rx Bytes: %d\n",numbytes);        
+
+        offset += numbytes;
+        totalRxBytes -= numbytes;         
+    }
+
+    printf("\n");            
+
+    for(dataCnt =0; dataCnt < DATA_SIZE; dataCnt++)
+    {    	
+        printf("%x ",gRxDataBuffer[dataCnt]);
+    }
+    
+    /* Send back the same data to server */	
+    sentCnt =0;
+    offset =0;
+    txferSize = DATA_SIZE;
+
+    while(txferSize > 0)
+    {            
+        sentCnt = send(sockfd,(gRxDataptr+offset),txferSize,0);
+        if (-1 == sentCnt)
+        {
+             perror("Error in Send\n");
+             printf("Tx Error\n");        
+             break;
+        }
+
+        offset+= sentCnt;
+        txferSize -= sentCnt;
+    }
+
+    close(sockfd);
+
+    printf("Closing Data Connection\n");        
+
+    return 0;
+  
+} 
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpserver.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpserver.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpserver.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/tcp/tcpserver.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,233 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:        tcpserver.c    %
+ * %pid_version:         1.2           %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   TCP server application which starts sending data once 
+ *                a client connects to it, and waits for the reception of 
+ *                from client
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/wait.h>
+#include <signal.h>
+
+#define MYPORT 3490    /* the port users will be connecting to */
+
+#define BACKLOG 10     /* how many pending connections queue will hold */
+
+#define DATA_SIZE (1024)
+
+unsigned char gTxDataBuffer[DATA_SIZE+1];
+unsigned char gRxDataBuffer[DATA_SIZE+1];
+unsigned char *gTxDataptr = gTxDataBuffer;
+unsigned char *gRxDataptr = gRxDataBuffer;
+
+unsigned int gTxCount = 0;
+
+void sigchld_handler(int s)
+{
+    while(waitpid(-1, NULL, WNOHANG) > 0);
+}
+
+int main(void)
+{
+    int sockfd, new_fd;  /*  listen on sock_fd, new connection on new_fd */
+    struct sockaddr_in my_addr;    /* my address information */
+    struct sockaddr_in their_addr; /* connector's address information */
+    socklen_t sin_size;
+    struct sigaction sa;
+    int yes=1;
+    unsigned int dataCnt,offset,txferSize;
+    ssize_t sentCnt;
+    ssize_t rxCnt;
+    int cmpStat;    
+
+    /* Initialize Data buffer with a sequential pattern */	
+    for(dataCnt=0; dataCnt < DATA_SIZE; dataCnt++)
+    {	
+        gTxDataBuffer[dataCnt]=dataCnt;
+    }
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) 
+    {
+        perror("setsockopt");
+        exit(1);
+    }
+
+    my_addr.sin_family = AF_INET;         /* host byte order */
+    my_addr.sin_port = htons(MYPORT);     /* short, network byte order */
+    my_addr.sin_addr.s_addr = INADDR_ANY; /* automatically fill with my IP */
+    memset(&(my_addr.sin_zero), '\0', 8); /* zero the rest of the struct */
+
+    if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
+                                                                   == -1) 
+    {
+        perror("bind");
+        exit(1);
+    }
+
+    if (listen(sockfd, BACKLOG) == -1) 
+    {
+        perror("listen");
+        exit(1);
+    }
+
+    sa.sa_handler = sigchld_handler; /* reap all dead processes */
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_RESTART;
+    if (sigaction(SIGCHLD, &sa, NULL) == -1) 
+    {
+        perror("sigaction");
+        exit(1);
+    }
+
+    sin_size = sizeof(struct sockaddr_in);
+
+    printf("\nServer waiting for connections...\n");    
+
+    while(1) 
+    {  
+
+        if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr,
+                                                       &sin_size)) == -1) 
+        {
+            perror("accept");
+            printf("Error in accept\n");
+            continue;
+        }
+
+        printf("server: got connection from %s\n",
+                                           inet_ntoa(their_addr.sin_addr));
+        if (!fork()) 
+        { 
+            /* this is the child process */
+            close(sockfd); /* child doesn't need the listener */
+
+            sentCnt =0;
+
+            offset =0;
+
+            txferSize = DATA_SIZE;
+
+            while(txferSize > 0)
+            {            
+                sentCnt = send(new_fd,(gTxDataptr+offset),txferSize,0);
+
+                if (-1 == sentCnt)
+                {
+                    perror("Error in Send\n");
+                    printf("Error in Send\n");
+                    break;
+                }
+
+                printf("Sent:%d bytes\n",sentCnt);
+
+                offset+= sentCnt;
+                txferSize -= sentCnt;
+            }
+
+            
+            goto __end;
+            
+	        /* All the data has been sent to client.
+                        ** Get back the same data from client
+                        */  
+            txferSize = DATA_SIZE;
+
+            offset =0;
+
+            while(txferSize > 0)
+            {            
+                rxCnt = recv(new_fd,(gRxDataptr+offset),txferSize,0);
+
+                if (-1 == rxCnt)
+                {
+                    perror("Error in recv\n");
+                    printf("Error in recv\n");
+                    break;
+                }
+
+                printf("Recv:%d bytes\n",rxCnt);
+            
+                txferSize -= rxCnt;
+                offset+= rxCnt;
+            }
+
+            close(new_fd); /* Child has finished its operation */
+
+            cmpStat = memcmp(gRxDataBuffer,gTxDataBuffer,DATA_SIZE);
+
+            if(0 == cmpStat)
+            {
+                printf("\nTest Successful");
+                return 0;
+            }
+            else
+            { 
+                printf("\nTest Failed");
+                for(dataCnt =0; dataCnt < DATA_SIZE; dataCnt++)
+                {
+                    if(gRxDataBuffer[dataCnt] != gTxDataBuffer[dataCnt])
+                    {
+                        printf("Tx = %d Rx = %d\n",gTxDataBuffer[dataCnt],gRxDataBuffer[dataCnt]);
+
+                    } 
+                }
+
+                return 0; 
+            }
+
+
+        }
+        
+        break;
+
+    }
+
+__end:
+    /* Right now, accepts only single connection */    
+    close(new_fd);  
+    close(sockfd); 
+
+    return 0;
+} 
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclient.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclient.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclient.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclient.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,99 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          udpclient.c    %
+ * %pid_version:          1.2          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+/* From PC(UDP client) to target(UDP server) data transmission, adjust the usleep() value 
+** Currently it is set to 6000 usec
+** Similarly for target (UDP client) & PC (UDP server) delay is set to 1000usec
+*/
+
+#define DATA_SIZE (1472) /* max number of bytes we can get at once.In short, MTU for the link */
+#define TRANSFER_SIZE (10000)
+
+unsigned char gTxDataBuffer[DATA_SIZE];
+
+int main(void)
+{
+
+    int sockfd;
+    unsigned int i;
+
+    struct sockaddr_in to_addr;
+
+    unsigned int totalTxBytes;
+
+    printf("\nUDP App");
+
+    if ((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        printf("Socket Failed\n");
+        exit(1);
+    }
+
+    to_addr.sin_family = AF_INET;    // host byte order 
+    to_addr.sin_port = htons(9999);  // short, network byte order 
+    inet_aton("10.0.0.7", &(to_addr.sin_addr));
+    memset(&(to_addr.sin_zero), '\0', 8);  // zero the rest of the struct 
+
+    /* Keep sending until all the data is sent */
+    for(i=0;i < TRANSFER_SIZE; i++)    
+    {
+
+        /* Send the UDP frames  */        
+        totalTxBytes = sendto(sockfd,&gTxDataBuffer[0],DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+	  usleep(1000);
+
+	  if((i%50)==0)
+	  printf("Iteration: %u, Tx Bytes %u \n",i,totalTxBytes);		
+    }
+
+    close(sockfd);
+
+    printf("\nClosing Data Connection");        
+
+    return 0;
+
+} 
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclientserver.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclientserver.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclientserver.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpclientserver.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,178 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:            udpclientserver.c %
+ * %pid_version:                1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:     This file acts as both client as well as server, 
+ *                             using fork system call
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        Adjust the delay with which the client transmits the data to avoid loss of UDP
+ *                     packets
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <resolv.h>
+#include <unistd.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+ 
+#define DEFAULT_PORT	9990
+
+/* For udp client */
+#define DATA_SIZE (1472)
+
+/* #define DATA_SIZE (800)  for lowend */
+
+#define TRANSFER_SIZE (10000)
+
+unsigned char gTxDataBuffer[DATA_SIZE];
+
+void udp_server(void);
+
+void udp_client(void);
+
+int main(void)
+{
+
+    pid_t process_id; 
+    unsigned int dataCnt;
+    int status;
+
+    /* Do the common initialization for client and server */
+ 
+    for(dataCnt=0; dataCnt < DATA_SIZE; dataCnt++)
+    {	
+        gTxDataBuffer[dataCnt]=dataCnt;
+    }
+
+    process_id = fork();
+
+    if(-1 == process_id)    
+    {
+        printf("\nFork Failed");        
+    }
+    else if(0 == process_id)
+    {
+        /* Call client function here */
+        printf("\nPress any key when 10.0.0.7 server is running");
+        getchar();
+        printf("\nClient sending the data...");        
+        udp_client();        
+        exit(0); 
+    }
+    else
+    {
+        /* Call server function here */    
+        printf("\nUDP server ready to receive data" );
+        udp_server();        
+        wait(&status); 
+    }
+
+}
+
+void udp_server(void)        
+{
+    int sd;
+    int port=DEFAULT_PORT;
+    struct sockaddr_in addr;
+    char buffer[1472];
+    int bytes, addr_len=sizeof(addr);    
+    unsigned int count1=0;
+
+    sd = socket(PF_INET, SOCK_DGRAM, 0);
+
+    bzero(&addr, sizeof(addr));
+
+    addr.sin_family = AF_INET;
+
+    addr.sin_port = htons(port);
+
+    addr.sin_addr.s_addr = INADDR_ANY;
+
+    if ( bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0 )
+        perror("bind");
+
+    printf("\nWaiting to receive data from client");       
+
+    while (count1 < TRANSFER_SIZE)
+    {
+        bytes = recvfrom(sd, buffer, sizeof(buffer), 0, (struct sockaddr*)&addr,
+                         (socklen_t*)&addr_len);
+        count1++;
+    }
+
+    printf("\nReceived complete data from client\n");       
+
+    close(sd);
+
+}
+
+void udp_client(void)
+{
+
+    int sockfd;
+    unsigned int i;
+
+    struct sockaddr_in to_addr;
+
+    unsigned int totalTxBytes;
+
+    if ((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    to_addr.sin_family = AF_INET;    /*  host byte order */
+    to_addr.sin_port = htons(DEFAULT_PORT);  /*  short, network byte order  */
+    inet_aton("10.0.0.7", &(to_addr.sin_addr));
+    memset(&(to_addr.sin_zero), '\0', 8);  /* zero the rest of the struct  */
+
+    /* Keep sending until all the data is sent */
+    for(i=0;i < TRANSFER_SIZE;i++)    
+    {
+
+        /* Send the UDP frames to server */        
+        totalTxBytes = sendto(sockfd,&gTxDataBuffer[0],DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+                         
+        usleep(10000); /* Working */
+    }
+
+    close(sockfd);
+
+    printf("\nTxmted complete data to server\n");        
+
+    return;
+
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpserver.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpserver.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpserver.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv4/udp/udpserver.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,82 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          udpserver.c    %
+ * %pid_version:          1.2           %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  UDP server receives data sent by UDP client for known number of packets 
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+*/
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <resolv.h>
+
+#define DEFAULT_PORT	9999
+
+int main(void)
+{    
+int sd;
+    int port=DEFAULT_PORT;
+
+    struct sockaddr_in addr;
+
+    char buffer[1472];
+
+    int bytes, addr_len=sizeof(addr);    
+
+    unsigned int count1=0;
+
+    sd = socket(PF_INET, SOCK_DGRAM, 0);
+
+    bzero(&addr, sizeof(addr));
+
+    addr.sin_family = AF_INET;
+
+    addr.sin_port = htons(port);
+
+    addr.sin_addr.s_addr = INADDR_ANY;
+
+
+    if ( bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0 )
+        perror("bind");
+
+    printf("\n Server ready to receive data\n");                   
+
+    while (count1 < 10000)
+    {
+        bytes = recvfrom(sd, buffer, sizeof(buffer), 0, (struct sockaddr*)&addr, &addr_len);
+        count1++;
+        printf("\n bytes : %u Count  = %u",bytes,count1);                   
+
+     }
+
+     printf("\nReceived complete data" );       
+
+    close(sd);
+
+}
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpclient.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpclient.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpclient.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpclient.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,173 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:            ipv6tcpclient.c %
+ * %pid_version:            1.2             %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  TCP client application which loops back data received
+ *               without memory comparison.
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include "netinet/in.h"          /* struct sockaddr_in6 */
+#include <arpa/inet.h>
+#include <net/if.h>
+
+/* The Dynamic and/or Private Ports are those from 49152 through 65535 */
+
+#define PORT 0xFFF0 // the port client will be connecting to 
+
+#define DATA_SIZE (1024) // max number of bytes we can get at once 
+unsigned char gRxDataBuffer[DATA_SIZE];
+unsigned char *gRxDataptr = gRxDataBuffer;
+unsigned int dataCnt;
+
+int main(void)
+{
+    int sockfd, numbytes;  
+
+    struct sockaddr_in6 their_addr; // connector's address information 
+    unsigned int offset,sentCnt,txferSize;
+    unsigned int totalRxBytes;
+    int errVal;
+    int on = 1;    
+
+    printf("Client App\n");
+
+    if ((sockfd = socket(PF_INET6,SOCK_STREAM,0)) == -1) 
+    {
+        perror("socket");
+        printf("Socket Failed\n");
+        exit(1);
+    }
+
+/*
+    if (setsockopt(sockfd,IPPROTO_IPV6,IPV6_V6ONLY,(char *)&on,sizeof(on)) == -1)
+    {
+        perror("setsockoptIPV6_V6ONLY"); 
+    }
+    else 
+    {
+        printf("IPV6_V6ONLY set\n");    
+    }
+    */
+
+    memset(&their_addr,0,sizeof(struct sockaddr_in6));
+
+    their_addr.sin6_family=AF_INET6;
+    their_addr.sin6_port=htons(PORT);
+    their_addr.sin6_flowinfo=0;
+
+    /* Through eth1 */
+    their_addr.sin6_scope_id= if_nametoindex("eth1");
+
+    /* Through eth0 */
+//    their_addr.sin6_scope_id= if_nametoindex("eth0");
+    errVal = inet_pton(AF_INET6,"fe80::213:72ff:fe9c:3c26",&(their_addr.sin6_addr));
+
+     if((errVal == 1)  || (errVal == 0))
+     {	
+        printf("inet_pton Failed %d \n",errVal);
+        return 0;
+     }
+
+    if (connect(sockfd, (struct sockaddr *)&their_addr,
+                                          sizeof(their_addr)) == -1) 
+    {
+        perror("connect");
+        printf("Error No: %d\n",errno);
+
+        exit(1);
+    }
+
+    offset =0;
+    
+    totalRxBytes = DATA_SIZE;
+
+    printf("\n");        
+
+    /* Keep reading until you receive all the data from Server */
+    while(totalRxBytes > 0)
+    {
+        numbytes = recv(sockfd,(gRxDataptr+offset),totalRxBytes,0);
+        if(-1 == numbytes ) 
+        {
+            perror("recv");
+            printf("Recv Error\n");        
+            exit(1);
+        }
+
+        printf("Rx Bytes: %d\n",numbytes);        
+
+        offset += numbytes;
+        totalRxBytes -= numbytes;         
+    }
+
+    printf("\n");            
+
+    for(dataCnt =0; dataCnt < DATA_SIZE; dataCnt++)
+    {
+        printf("%x ",gRxDataBuffer[dataCnt]);
+    }
+    
+    #if 1
+    /* Send back the same data to server */	
+    sentCnt =0;
+    offset =0;
+    txferSize = DATA_SIZE;
+ 
+    while(txferSize > 0)
+    {            
+        sentCnt = send(sockfd,(gRxDataptr+offset),txferSize,0);
+        if (-1 == sentCnt)
+        {
+             perror("Error in Send\n");
+             printf("Tx Error\n");        
+             break;
+        }
+
+        offset+= sentCnt;
+        txferSize -= sentCnt;
+    }
+
+#endif
+
+    close(sockfd);
+
+    printf("Closing Data Connection\n");        
+
+    return 0;
+} 
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpserver.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpserver.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpserver.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/tcp/ipv6tcpserver.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,257 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:        ipv6tcpserver.c    %
+ * %pid_version:          1.2         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   TCP server application which starts sending data once 
+ *                a client connects to it, and waits for the reception of  data
+ *                from client & compares the transmitted & received data
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <stdlib.h>  /* For exit */
+#include <unistd.h>  /* For  fork */
+#include <string.h> 
+#include "netdb.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <wait.h> 
+#include "netinet/in.h"          /* struct sockaddr_in6 */
+#include <arpa/inet.h>
+#include <net/if.h>
+
+#define MYPORT 0xFFF0    // the port users will be connecting to
+
+#define BACKLOG 10     // how many pending connections queue will hold
+
+#define DATA_SIZE (1024)
+
+unsigned char gTxDataBuffer[DATA_SIZE+1];
+unsigned char gRxDataBuffer[DATA_SIZE+1];
+unsigned char *gTxDataptr = gTxDataBuffer;
+unsigned char *gRxDataptr = gRxDataBuffer;
+
+unsigned int gTxCount = 0;
+
+
+void sigchld_handler(int s)
+{
+    while(waitpid(-1, NULL, WNOHANG) > 0);
+}
+
+int main(void)
+{
+
+    struct protoent *protocol;
+
+    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
+    
+    struct sockaddr_in6 my_addr;    // my address information
+    struct sockaddr_in6 their_addr; // connector's address information
+   
+    socklen_t sin_size;
+    
+    struct sigaction sa;
+    
+    int yes=1;
+    
+    unsigned int dataCnt,offset,txferSize;
+   
+    ssize_t sentCnt;
+    ssize_t rxCnt;
+    int cmpStat;    
+
+    /* Initialize Data buffer with a sequential pattern */	
+    for(dataCnt=0; dataCnt < DATA_SIZE; dataCnt++)
+    {	
+        gTxDataBuffer[dataCnt]=dataCnt;
+    }
+
+    if (!(protocol = getprotobyname("tcp")))
+    {
+        printf("Error in getprotobyname\n");
+        exit(1);
+
+    }
+
+    if ((sockfd = socket(PF_INET6, SOCK_STREAM,protocol->p_proto)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) 
+    {
+        perror("setsockopt");
+        exit(1);
+    }
+
+    memset(&my_addr,0,sizeof(struct sockaddr_in6));
+
+    my_addr.sin6_family=AF_INET6;
+    my_addr.sin6_port=htons(MYPORT);
+    my_addr.sin6_flowinfo=0;
+
+    /* For eth1 */    
+    my_addr.sin6_scope_id= if_nametoindex("eth1") ;
+    inet_pton(AF_INET6,"fe80::a8bb:ccff:fedd:eeff",&(my_addr.sin6_addr));
+
+    /* For eth0 */    
+//    my_addr.sin6_scope_id= if_nametoindex("eth0") ;
+//    inet_pton(AF_INET6,"fe80::202:f7ff:fe00:1e43",&(my_addr.sin6_addr));
+
+    if (bind(sockfd,(struct sockaddr *)&my_addr,sizeof(struct sockaddr_in6)) == -1) 
+    {
+        perror("bind");
+        exit(1);
+    }
+
+    if (listen(sockfd, BACKLOG) == -1) 
+    {
+        perror("listen");
+        exit(1);
+    }
+
+    sa.sa_handler = sigchld_handler; // reap all dead processes
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_RESTART;
+    
+    if (sigaction(SIGCHLD, &sa, NULL) == -1) 
+    {
+        perror("sigaction");
+        exit(1);
+    }
+
+    sin_size = sizeof(struct sockaddr_in6);
+
+    printf("\nServer waiting for connections...\n");    
+
+    while(1) 
+    {  
+
+        if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr,
+                                                       &sin_size)) == -1) 
+        {
+            perror("accept");
+            printf("Error in accept\n");
+            continue;
+        }
+
+        printf("server: got connection from client" );
+
+        if (!fork()) 
+        { 
+            // this is the child process
+            close(sockfd); // child doesn't need the listener
+
+            sentCnt =0;
+
+            offset =0;
+
+            txferSize = DATA_SIZE;
+
+            while(txferSize > 0)
+            {            
+                sentCnt = send(new_fd,(gTxDataptr+offset),txferSize,0);
+
+                if (-1 == sentCnt)
+                {
+                    perror("Error in Send\n");
+                    break;
+                }
+
+                printf("Sent:%d bytes\n",sentCnt);
+
+                offset+= sentCnt;
+                txferSize -= sentCnt;
+            }
+
+
+        /* All the data has been sent to client.
+            ** Get back the same data from client
+            */  
+            txferSize = DATA_SIZE;
+
+            offset =0;
+
+            while(txferSize > 0)
+            {            
+                rxCnt = recv(new_fd,(gRxDataptr+offset),txferSize,0);
+
+                if (-1 == rxCnt)
+                {
+                    perror("Error in recv\n");
+                    printf("Error in recv\n");
+                    break;
+                }
+
+                printf("Recv:%d bytes\n",rxCnt);
+            
+                txferSize -= rxCnt;
+                offset+= rxCnt;
+            }
+
+            close(new_fd); //Child has finished its operation
+
+            cmpStat = memcmp(gRxDataBuffer,gTxDataBuffer,DATA_SIZE);
+
+            if(0 == cmpStat)
+            {
+                printf("\nTest Successful");
+                return 0;
+            }
+            else
+            { 
+                printf("\nTest Failed");
+                for(dataCnt =0; dataCnt < DATA_SIZE; dataCnt++)
+                {
+                    if(gRxDataBuffer[dataCnt] != gTxDataBuffer[dataCnt])
+                    {
+                        printf("Tx = %d Rx = %d\n",gTxDataBuffer[dataCnt],gRxDataBuffer[dataCnt]);
+
+                    } 
+                }
+
+                return 0; 
+            }
+
+
+        }
+        
+        break;
+
+    }
+
+
+    /* Right now, accepts only single connection */    
+    close(new_fd);  
+    close(sockfd); 
+
+    return 0;
+} 
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpclient.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpclient.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpclient.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpclient.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,198 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:        ipv6udpclient.c    %
+ * %pid_version:          1.2         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   Sends know number of UDP packets to UDP server
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+
+#define DATA_SIZE (100) // max number of bytes we can get at once
+#define PORT_NUM (0xFFF0) /* Destination port number */
+unsigned char gRxDataBuffer[DATA_SIZE];
+unsigned char gTxDataBuffer[DATA_SIZE];
+
+unsigned char *gRxDataptr = gRxDataBuffer;
+unsigned char *gTxDataptr = gTxDataBuffer;
+
+unsigned int dataCnt;
+
+int main(void)
+{
+
+    int sockfd, numbytes;  
+    unsigned int i;
+
+    struct sockaddr_in6 to_addr; // connector's address information 
+
+    unsigned int offset,sentCnt,txferSize;
+
+    unsigned int totalRxBytes,totalTxBytes;
+    
+    memset(gTxDataBuffer,99,DATA_SIZE);
+
+    printf("UDP App\n");
+
+    if ((sockfd = socket(PF_INET6, SOCK_DGRAM, 0)) == -1) 
+    {
+        perror("socket");
+        printf("Socket Failed\n");
+        exit(1);
+    }
+
+    to_addr.sin6_family = AF_INET6;    // host byte order 
+    to_addr.sin6_port = htons(PORT_NUM);// short, network byte order 
+    to_addr.sin6_flowinfo=0;
+
+    /* With inbuild driver */    
+//    to_addr.sin6_scope_id= if_nametoindex("eth0") ;
+
+    to_addr.sin6_scope_id= if_nametoindex("eth1") ;
+      /* Linux PC */
+    inet_pton(AF_INET6,"fe80::213:72ff:fe9c:3c26",&(to_addr.sin6_addr));
+      
+    /* server 3 PC */
+//    inet_pton(AF_INET6,"fe80::20f:1fff:fe88:52cd",&(to_addr.sin6_addr));
+//    inet_pton(AF_INET6,"3ffe:b80:17e2::3",&(to_addr.sin6_addr));
+
+    #if 0
+    if (connect(sockfd, (struct sockaddr *)&to_addr,
+                                          sizeof(to_addr)) == -1) 
+    {
+        perror("connect");
+        printf("Error No: %d\n",errno);
+
+        exit(1);
+    }
+
+    sentCnt =0;
+    offset =0;
+    txferSize = DATA_SIZE;
+ 
+    while(txferSize > 0)
+    {            
+        sentCnt = send(sockfd,(gRxDataptr+offset),txferSize,0);
+        if (-1 == sentCnt)
+        {
+             perror("Error in Send\n");
+             printf("Tx Error\n");        
+             break;
+        }
+
+        offset+= sentCnt;
+        txferSize -= sentCnt;
+    }
+
+    printf("\nData transfer done");  
+
+    return 0;    
+    #endif    
+
+    /* Keep sending until all the data is sent */
+    for(i=0;i < 0x5; i++)    
+    {
+
+        /* Send the UDP frames  */        
+        numbytes = sendto(sockfd,&gTxDataptr[0],DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+
+        if(numbytes == -1 )
+        {
+            printf("\nsendto Error:%d\n",numbytes);        
+            
+            perror("sendto");
+            printf("sendto failed, ErrNo:%d\n",errno);
+            close(sockfd);        
+            return 0;            
+        }
+            
+//        usleep(4000); //Working
+//        usleep(1000); //Working
+//          usleep(500000);
+ 
+ /*        perror("sendto");
+
+        if(-1 == numbytes ) 
+        {
+            perror("sendto");
+            printf("sendto: %d\n",numbytes);        
+            exit(1);
+        }
+*/
+        printf("Iter: %u, TxBytes : %u\n",i,numbytes);        
+
+    }
+
+    /*   
+    for(dataCnt =0; dataCnt < DATA_SIZE; dataCnt++)
+    {    	
+        printf("Rx :%d\n",gRxDataBuffer[dataCnt]);
+    }
+
+    //Send back the same data to server 	
+    sentCnt =0;
+    offset =0;
+    txferSize = DATA_SIZE;
+
+    while(txferSize > 0)
+    {            
+        sentCnt = send(sockfd,(gRxDataptr+offset),txferSize,0);
+        if (-1 == sentCnt)
+        {
+             perror("Error in Send\n    ");
+             printf("Tx Error\n");        
+             break;
+        }
+
+        offset+= sentCnt;
+        txferSize -= sentCnt;
+    }        numbytes = sendto(sockfd,gTxDataptr,DATA_SIZE,0,
+                          (struct sockaddr*)&to_addr,
+                          sizeof(to_addr)
+                          );   
+
+    */
+
+    close(sockfd);
+
+    printf("Closing Data Connection\n");        
+
+    return 0;
+} 
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpserver.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpserver.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpserver.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/ipv6/udp/ipv6udpserver.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,112 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:        ipv6udpserver.c    %
+ * %pid_version:          1.2         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   Receives complete data from UDP client & sends back same data to UDP client  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <resolv.h>
+
+#define DEFAULT_PORT	(0xFFF0)
+#define DATA_SIZE (1472)   
+int main(void)
+{	int sd,dataCnt;
+	int port=DEFAULT_PORT;
+	struct sockaddr_in6 addr;
+	char buffer[DATA_SIZE];
+	int bytes, addr_len=sizeof(addr);    
+    unsigned int count1=0;
+
+	sd = socket(PF_INET6, SOCK_DGRAM, 0);
+    
+	bzero(&addr, sizeof(addr));
+    
+	addr.sin6_family = AF_INET6;
+    
+	addr.sin6_port = htons(port);
+    addr.sin6_flowinfo=0;
+    addr.sin6_scope_id= if_nametoindex("eth1") ;
+
+//    inet_pton(AF_INET6,"3ffe:b80:17e2::2",&(addr.sin6_addr));    
+    inet_pton(AF_INET6,"fe80::a8bb:ccff:fedd:eeff",&(addr.sin6_addr));    
+
+    printf("\nBefore bind");            
+
+	if ( bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0 )
+        
+	perror("bind");
+    
+    count1 =0;
+
+    printf("\nBefore recvfrom");            
+
+    /* Receive data from UDP client */
+    while (count1 < 100)
+    {
+        bytes = recvfrom(sd, buffer, DATA_SIZE, 0, (struct sockaddr*)&addr, &addr_len);
+        printf("\nIter: %d,Rcvd = %u",count1,bytes);            
+        count1++;
+    }      
+
+    printf("\nReceive Complete\n");        
+
+    /* Send data to UDP client */    
+    for(count1=0;count1 < 100; count1++)    
+    {
+
+        /* Send the UDP frames  */        
+        bytes = sendto(sd,buffer,DATA_SIZE,0,
+          (struct sockaddr*)&addr,
+          sizeof(addr)
+          );   
+    
+        if(bytes == -1 )
+        {
+            printf("\nsendto Error:%d\n",bytes);        
+
+            perror("sendto");
+            printf("sendto failed, ErrNo:%d\n",errno);
+            close(sd);        
+            return 0;            
+        }
+
+        printf("Iter: %u, TxBytes : %u\n",count1,bytes);        
+    
+    }
+
+    printf("\nData transfer complete\n");        
+
+    close(sd);
+
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/loopback/loopback.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/loopback/loopback.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/loopback/loopback.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/loopback/loopback.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,315 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          loopback.c %
+ * %pid_version:           1.0         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:    UDP loopback application. Loopbacks data in the following sequence:
+ *
+ *                           UDP app -> Linux stack-> LIPP_6300ETH driver -> MAC H/W Tx ->
+ *                           MAC Rx -> LIPP_6300ETH driver->Linux stack->UDP app
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <resolv.h>
+#include <unistd.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <arpa/inet.h> /* inet_aton */
+
+#include <linux/if.h>  /* def of ifr */
+#include <sys/ioctl.h> /* ioctl call */
+#include <sys/wait.h> /* For wait() call */
+
+#include <linux/errno.h>
+
+#include <gmac_ioctl.h>
+
+#define CLIENT_PORT	9990
+#define SERVER_PORT	9999
+
+/* For udp client */
+#define DATA_SIZE (1472) // max number of bytes we can get at once
+//#define DATA_SIZE (800) // max number of bytes we can get at once for lowend
+#define TRANSFER_SIZE (100)
+
+unsigned char gTxDataBuffer[DATA_SIZE];
+
+void udp_server(void);
+
+void udp_client(void);
+
+int main(void)
+{
+
+    pid_t process_id;
+    unsigned int dataCnt;
+    int status;
+
+    /* Do the common initialization for client and server */
+
+    for(dataCnt=0; dataCnt < DATA_SIZE; dataCnt++)
+    {
+        gTxDataBuffer[dataCnt]=dataCnt;
+    }
+
+    process_id = fork();
+
+    if(-1 == process_id)
+    {
+        printf("\nFork Failed");
+    }
+    else if(0 == process_id)
+    {
+        /* Call client function here */
+        printf("\nPress any key when 10.0.0.10 server is running\n");
+        getchar();
+        udp_client();
+
+    }
+    else
+    {
+        /* Call server function here */
+        udp_server();
+        wait(&status);
+    }
+
+    return 0;
+
+}
+
+void udp_server(void)
+{
+    int sd;
+    struct sockaddr_in addr;
+    char buffer[1472];
+    int bytes, addr_len=sizeof(addr);
+    unsigned int count1=0;
+
+
+    /* UDP server socket */
+    sd = socket(PF_INET, SOCK_DGRAM, 0);
+
+    bzero(&addr, sizeof(addr));
+
+    addr.sin_family = AF_INET;
+
+    addr.sin_port = htons(SERVER_PORT);
+
+    addr.sin_addr.s_addr = INADDR_ANY;
+
+    if ( bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0 )
+        perror("bind");
+
+    printf("\nUDP server running\n");
+
+
+    while (count1 < (TRANSFER_SIZE*4))
+    {
+        bytes = recvfrom(sd, buffer, sizeof(buffer), 0, (struct sockaddr*)&addr,\
+                        (socklen_t*)&addr_len);
+        count1++;
+
+        printf("\nServer# Iter: %u Size:%u\n",count1,bytes);
+
+        if(bytes == -1)
+        {
+            perror("recvfrom");
+            break;
+        }
+
+    }
+
+    printf("\nUDP server exit\n");
+
+    close(sd);
+
+}
+
+void udp_client(void)
+{
+
+    int sockfd,sd;
+    unsigned int i,j,count;
+
+    struct sockaddr_in to_addr;
+
+    unsigned int totalTxBytes;
+
+    gmacDrvConfig_t drvCfg;
+    struct ifreq ifr;
+    __s32 ret;
+
+    __u8*ifname = "eth0";
+
+
+    printf("\nUDP client running\n");
+
+    if ((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) == -1)
+    {
+        perror("socket");
+        printf("Socket Failed\n");
+        exit(1);
+    }
+
+    to_addr.sin_family = AF_INET;    // host byte order
+    to_addr.sin_port = htons(CLIENT_PORT);  // short, network byte order
+    inet_aton("10.0.0.2", &(to_addr.sin_addr));
+    memset(&(to_addr.sin_zero), '\0', 8);  // zero the rest of the struct
+
+    if ((sd = socket(PF_INET,SOCK_DGRAM, 0)) == -1)
+    {
+    perror("socket");
+    exit(1);
+    }
+
+    memset(&drvCfg,0,sizeof(gmacDrvConfig_t));
+
+    //char *strncpy(char *dest, const char *src, size_t n);
+    /* Fill the structure to be passed to ioctl */
+    strncpy(ifr.ifr_name,(const char*)ifname,sizeof(ifr.ifr_name));
+
+    ifr.ifr_data = &drvCfg;
+
+    /* Configure the driver for MAC loopback mode */
+    drvCfg.enableMacLoopback = 1;
+    drvCfg.enablePhyLoopback = 0;
+
+    drvCfg.enableAutoNeg = 0;
+    drvCfg.enableFullduplex = 1;
+    drvCfg.speed = 10;
+
+    ret = ioctl(sockfd,ETH_DRV_CONFIG,&ifr);
+
+    if (ret == -1)
+    {
+        printf("\nIoctl Error: errno :%d,retVal:%x\n",errno,ret);
+        goto __restore;
+    }
+
+    /* Loopback loop*/
+    for(i=0;i < 2; i++)
+    {
+    
+        /* Speed loop 10 & 100 */
+        for(j=0; j < 2; j++)
+        {
+
+            printf("\nRunning %s Test for ",
+                ((drvCfg.enableMacLoopback > 0) ? "MAC Loopback" : "PHY Loopback"));
+            printf(" %dMbps\n",drvCfg.speed);
+
+            sleep(5);/* To see the message */
+
+            /* Keep sending until all the data is sent */
+            for(count=0; count < TRANSFER_SIZE;count++)
+            {
+
+                /* Send the UDP frames to server */
+                totalTxBytes = sendto(sd,&gTxDataBuffer[0],DATA_SIZE,0,
+                                        (struct sockaddr*)&to_addr,
+                                        sizeof(to_addr)
+                                        );
+
+                if(totalTxBytes == -1)
+                {
+                    perror("sendto");
+                    break;
+                }
+                printf("\nClient# Iter: %u Size:%u\n",count+1,totalTxBytes);
+                sleep(1);
+
+            }
+
+            drvCfg.speed = 100;
+            ret = ioctl(sockfd,ETH_DRV_CONFIG,&ifr);
+
+            if (ret == -1)
+            {
+                printf("\nIoctl Error: errno :%d,retVal:%x\n",errno,ret);
+                goto __restore;
+            }
+
+
+        }
+
+        if(drvCfg.enablePhyLoopback)
+        {
+            break;
+        }
+
+        /* Set the speed back to 10 Mbps */
+        drvCfg.speed = 10;
+
+        /* Configure the driver for PHY loopback mode */
+        drvCfg.enablePhyLoopback = 1;
+        drvCfg.enableMacLoopback = 0;
+
+        ret = ioctl(sockfd,ETH_DRV_CONFIG,&ifr);
+
+        if (ret == -1)
+        {
+            printf("\nIoctl Error: errno :%d,retVal:%x\n",errno,ret);
+            goto __restore;
+        }
+
+
+    }/* End of loop */
+
+    printf("\nCompleted MAC/PHY loopback Tests\n");
+
+__restore:
+
+    drvCfg.enablePhyLoopback = 0;
+    drvCfg.enableMacLoopback = 0;
+    drvCfg.enableAutoNeg = 1;
+    drvCfg.speed = 100;
+
+    ret = ioctl(sockfd,ETH_DRV_CONFIG,&ifr);
+
+    if (ret == -1)
+    {
+        printf("\nIoctl Error: errno :%d\n",errno);
+
+    }
+
+    printf("\nSetting PHY to Non-Loopback mode:%d\n", drvCfg.speed);
+
+    printf("\nClient Exit\n" );
+
+    close(sd);
+    close(sockfd);
+
+    exit(0);
+
+}
+
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/loopback/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/loopback/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/loopback/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/loopback/makefile	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,18 @@
+
+CC= $(CROSS_COMPILE)gcc
+
+export KERN_DIR = ../../../../../../
+export HDR_PATH = ../../../../../../include/net/LIPP_6300ETH/
+
+CFLAGS = -c -EL -I$(HDR_PATH) -I. -I$(KERN_DIR)  -Wall
+
+all: loopback.out
+
+loopback.out : loopback.o
+	$(CC) -EL -Bstatic loopback.o -o loopback.out
+
+loopback.o : loopback.c
+	$(CC) $(CFLAGS) loopback.c
+clean:
+	rm -rf *o *.out
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/sendfile/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/sendfile/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/sendfile/makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/sendfile/makefile	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,18 @@
+
+CC= $(CROSS_COMPILE)gcc
+
+export KERN_DIR = ../../../../../../
+export HDR_PATH = ../../../../../../include/net/LIPP_6300ETH/
+
+CFLAGS = -c -EL -I$(HDR_PATH) -I. -I$(KERN_DIR)  -Wall
+
+all: sendfile.out
+
+sendfile.out : sendfile.o
+	$(CC) -EL -Bstatic sendfile.o -o sendfile.out
+
+sendfile.o : sendfile.c
+	$(CC) $(CFLAGS) sendfile.c
+clean:
+	rm -rf *o *.out
+
diff -Naurp linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/sendfile/sendfile.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/sendfile/sendfile.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tst/sendfile/sendfile.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tst/sendfile/sendfile.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,169 @@
+#include <stdio.h>          /* printf, perror */
+#include <fcntl.h>          /* open */
+#include <unistd.h>         /* close */
+#include <errno.h>          /* errno */
+#include <string.h>         /* memset */
+#include <sys/socket.h>     /* socket */
+#include <netinet/in.h>     /* sockaddr_in */
+#include <sys/sendfile.h>   /* sendfile */
+#include <arpa/inet.h>      /* inet_addr */
+#include <signal.h>
+#include <sys/wait.h>
+
+//#include <sys/types.h>
+#include <sys/stat.h>
+
+#define MYPORT 3490    /* the port users will be connecting to */
+
+#define BACKLOG 10     /* how many pending connections queue will hold */
+
+    
+void sigchld_handler(int s)
+{
+    while(waitpid(-1, NULL, WNOHANG) > 0);
+}
+
+int main(void)
+{
+    int sockfd, new_fd;  /*  listen on sock_fd, new connection on new_fd */
+    struct sockaddr_in my_addr;    /* my address information */
+    struct sockaddr_in their_addr; /* connector's address information */
+    socklen_t sin_size;
+    struct sigaction sa;
+    int yes=1;
+    ssize_t sentCnt;
+
+    int read_fd;
+    struct stat stat_buf;
+    off_t offset = 0;
+    
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) 
+    {
+        perror("socket");
+        exit(1);
+    }
+
+    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) 
+    {
+        perror("setsockopt");
+        exit(1);
+    }
+
+    my_addr.sin_family = AF_INET;         /* host byte order */
+    my_addr.sin_port = htons(MYPORT);     /* short, network byte order */
+    my_addr.sin_addr.s_addr = INADDR_ANY; /* automatically fill with my IP */
+    memset(&(my_addr.sin_zero), '\0', 8); /* zero the rest of the struct */
+
+    if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
+                                                                   == -1) 
+    {
+        perror("bind");
+        exit(1);
+    }
+
+    if (listen(sockfd, BACKLOG) == -1) 
+    {
+        perror("listen");
+        exit(1);
+    }
+
+    sa.sa_handler = sigchld_handler; /* reap all dead processes */
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_RESTART;
+    
+    if (sigaction(SIGCHLD, &sa, NULL) == -1) 
+    {
+        perror("sigaction");
+        exit(1);
+    }
+
+    sin_size = sizeof(struct sockaddr_in);
+
+    /* Open the input file for reading */
+    read_fd = open ("/ethTest/numbers.txt",O_RDONLY);
+
+    /* Stat the input file to obtain its size. */
+    fstat (read_fd, &stat_buf);
+
+    printf("\nServer waiting for connections...\n");    
+
+    while(1) 
+    {  
+
+        if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr,
+                                                       &sin_size)) == -1) 
+        {
+            perror("accept");
+            printf("Error in accept\n");
+            continue;
+        }
+
+        printf("server: got connection from %s\n",
+                                           inet_ntoa(their_addr.sin_addr));
+        if (!fork()) 
+        { 
+            /* this is the child process */
+            close(sockfd); /* child doesn't need the listener */
+
+
+            /* Blast the bytes from one file to the other. */
+            if((sentCnt = sendfile(new_fd,read_fd,&offset,
+                                      stat_buf.st_size)) < 0)
+            {
+
+                printf("sendfile failed:%x\n",errno);
+            
+                perror("sendfile");
+                exit(errno);
+            }
+
+            printf("\nBytes sent:%u\n",sentCnt);
+
+            close(new_fd); /* Child has finished its operation */
+
+        }
+        
+        break;
+
+    }
+
+    /* Right now, accepts only single connection */    
+    close(new_fd);  
+    close(sockfd); 
+    close(read_fd); 
+
+    return 0;
+
+} 
+
+#if 0
+int main (int argc, char* argv[])
+{
+
+    int read_fd;
+    int write_fd;
+    struct stat stat_buf;
+    off_t offset = 0;
+
+    /* Open the input file. */
+    read_fd = open (argv[1], O_RDONLY);
+    
+    /* Stat the input file to obtain its size. */
+    fstat (read_fd, &stat_buf);
+    
+    /* Open the output file for writing, with the same permissions as the
+    source file. */
+    write_fd = open (argv[2], O_WRONLY | O_CREAT, stat_buf.st_mode);
+    
+    /* Blast the bytes from one file to the other. */
+    sendfile (write_fd, read_fd, &offset, stat_buf.st_size);
+    
+    /* Close up. */
+    close (read_fd);
+    close (write_fd);
+
+    return 0;
+
+}
+#endif
diff -Naurp linux-2.6.34.orig/drivers/net/Makefile linux-2.6.34/drivers/net/Makefile
--- linux-2.6.34.orig/drivers/net/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/net/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -290,6 +290,7 @@ obj-$(CONFIG_NETXEN_NIC) += netxen/
 obj-$(CONFIG_NIU) += niu.o
 obj-$(CONFIG_VIRTIO_NET) += virtio_net.o
 obj-$(CONFIG_SFC) += sfc/
+obj-$(CONFIG_LIPP_6300ETH) += LIPP_6300ETH/
 
 obj-$(CONFIG_WIMAX) += wimax/
 
diff -Naurp linux-2.6.34.orig/drivers/rtc/Kconfig linux-2.6.34/drivers/rtc/Kconfig
--- linux-2.6.34.orig/drivers/rtc/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/rtc/Kconfig	2010-09-07 22:16:41.000000000 -0500
@@ -410,6 +410,13 @@ endif # SPI_MASTER
 
 comment "Platform RTC drivers"
 
+config RTC_DRV_APOLLO
+	tristate "Apollo RTC"
+	depends on ARCH_APOLLO
+	help
+	  If you say Y here you will get support for the RTC found on
+	  Apollo systems.
+
 # this 'CMOS' RTC driver is arch dependent because <asm-generic/rtc.h>
 # requires <asm/mc146818rtc.h> defining CMOS_READ/CMOS_WRITE, and a
 # global rtc_lock ... it's not yet just another platform_device.
diff -Naurp linux-2.6.34.orig/drivers/rtc/Makefile linux-2.6.34/drivers/rtc/Makefile
--- linux-2.6.34.orig/drivers/rtc/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/rtc/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -17,6 +17,7 @@ rtc-core-$(CONFIG_RTC_INTF_SYSFS) += rtc
 
 # Keep the list ordered.
 
+obj-$(CONFIG_RTC_DRV_APOLLO)    += rtc-apollo.o
 obj-$(CONFIG_RTC_DRV_AB3100)	+= rtc-ab3100.o
 obj-$(CONFIG_RTC_DRV_AT32AP700X)+= rtc-at32ap700x.o
 obj-$(CONFIG_RTC_DRV_AT91RM9200)+= rtc-at91rm9200.o
diff -Naurp linux-2.6.34.orig/drivers/rtc/rtc-apollo.c linux-2.6.34/drivers/rtc/rtc-apollo.c
--- linux-2.6.34.orig/drivers/rtc/rtc-apollo.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/rtc/rtc-apollo.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,245 @@
+/*
+ *  linux/drivers/rtc/rtc_apollo.c
+ *
+ *  Copyright 2010 Trident Microsystems (Far East) Ltd. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#define TIMER_VALUE(n)      (n*0x10)
+#define TIMER_LIMIT(n)      ((n*0x10) + 0x4)
+#define TIMER_MODE(n)       ((n*0x10) + 0x8)
+#define TIMER_TIMEBASE(n)   ((n*0x10) + 0xC)
+#define TIMER_IRQ           0x200
+
+#define RTC_TIMER	1
+
+struct apollo_rtc_device {
+    struct rtc_device   *rtc;
+    void __iomem        *base;
+};
+
+static irqreturn_t rtc_apollo_interrupt(int irq, void *dev_id)
+{
+    unsigned long events = RTC_IRQF | RTC_UF;
+    struct rtc_device *rtc = dev_id;
+
+    rtc_update_irq(rtc, 1, events);
+
+    return IRQ_HANDLED;
+}
+
+static int rtc_apollo_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0, read_reg;
+    struct apollo_rtc_device *rtc = dev_get_drvdata(dev);
+
+    switch (cmd) {
+        case RTC_UIE_ON:
+            read_reg = __raw_readl(rtc->base + TIMER_MODE(RTC_TIMER));
+            __raw_writel(read_reg|0x4, rtc->base + TIMER_MODE(RTC_TIMER));
+                break;
+
+        case RTC_UIE_OFF:
+            read_reg = __raw_readl(rtc->base + TIMER_MODE(RTC_TIMER));
+            __raw_writel(read_reg&(~0x40), rtc->base + TIMER_MODE(RTC_TIMER));
+                break;
+
+        default:
+             ret = -ENOIOCTLCMD;
+             break;
+    }
+
+    return ret;
+}
+
+static int rtc_apollo_read_time(struct device *dev, struct rtc_time *tm)
+{
+    struct apollo_rtc_device *rtc = dev_get_drvdata(dev);
+
+    rtc_time_to_tm(__raw_readl(rtc->base + TIMER_VALUE(RTC_TIMER)), tm);
+
+#ifdef DEBUG
+    printk("Apollo RTC Read Time done\n");
+#endif
+    return 0;
+}
+
+/*
+ * Set the RTC time.  Unfortunately, we can't accurately set
+ * the point at which the counter updates.
+ *
+ */
+static int rtc_apollo_set_time(struct device *dev, struct rtc_time *tm)
+{
+    struct apollo_rtc_device *rtc = dev_get_drvdata(dev);
+    unsigned long time;
+    int ret;
+    int read_reg;
+
+    /* Timer Counter Value Reg can be written only when counter is Enabled, so enable it*/
+    read_reg = __raw_readl(rtc->base + TIMER_MODE(RTC_TIMER));
+    __raw_writel(read_reg|0x1 , rtc->base + TIMER_MODE(RTC_TIMER));
+
+    ret = rtc_tm_to_time(tm, &time);
+    if (ret == 0)
+        __raw_writel(time, rtc->base + TIMER_VALUE(RTC_TIMER));
+
+#ifdef DEBUG
+    printk("Apollo RTC Set Time done\n");
+#endif
+
+    return ret;
+}
+
+static const struct rtc_class_ops rtc_apollo_ops = {
+    .ioctl      = rtc_apollo_ioctl,
+    .read_time  = rtc_apollo_read_time,
+    .set_time   = rtc_apollo_set_time,
+};
+
+static int apollo_rtc_timer;
+
+static int rtc_apollo_probe(struct platform_device *pdev)
+{
+    struct resource         *res;
+    struct apollo_rtc_device *rtc;
+    int ret;
+
+    apollo_rtc_timer = platform_get_irq(pdev, 0);
+    if (apollo_rtc_timer <= 0) {
+        pr_debug("%s: no update irq?\n", pdev->name);
+        return -ENOENT;
+    }
+
+    rtc = kmalloc(sizeof(struct apollo_rtc_device), GFP_KERNEL);
+    if (!rtc) {
+        return -ENOMEM;
+    }
+
+    /* NOTE:  using static mapping for RTC registers */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (res && res->start != APOLLO_RTC_BASE) {
+        pr_debug("%s: RTC registers at %08x, expected %08x\n",
+                    pdev->name, (unsigned) res->start, APOLLO_RTC_BASE);
+        return -ENOENT;
+    }
+
+    rtc->base = (void *)res->start;
+
+    rtc->rtc =  rtc_device_register(pdev->name, &pdev->dev, &rtc_apollo_ops,
+                                   THIS_MODULE);
+    if (IS_ERR(rtc->rtc)) {
+        pr_debug("%s: can't register RTC device, err %ld\n",
+                    pdev->name, PTR_ERR(rtc->rtc));
+        goto err_reg;
+    }
+    platform_set_drvdata(pdev, rtc);
+    dev_set_drvdata(&rtc->rtc->dev, res);
+
+    /* Set the Mode to 0, Limit to Max and Time base to 50Mhz to get 1sec resolution */
+    __raw_writel(0, rtc->base + TIMER_MODE(RTC_TIMER));
+    __raw_writel(0xFFFFFFFF, rtc->base + TIMER_LIMIT(RTC_TIMER));
+    __raw_writel(0x2FAF080, rtc->base + TIMER_TIMEBASE(RTC_TIMER));
+
+    ret = request_irq(apollo_rtc_timer, rtc_apollo_interrupt, IRQF_DISABLED,
+                      dev_name(&rtc->rtc->dev), rtc);
+    if (ret)
+        goto err_irq;
+
+    /* Enable the timer here */
+    __raw_writel(1, rtc->base + TIMER_MODE(RTC_TIMER));
+
+#ifdef DEBUG
+    printk("Apollo RTC Driver Probe complete\n");
+#endif
+    return 0;
+
+err_irq:
+    rtc_device_unregister(rtc->rtc);
+    free_irq(apollo_rtc_timer, rtc);
+err_reg:
+    return -EIO;
+}
+
+static int rtc_apollo_remove(struct platform_device *pdev)
+{
+    struct apollo_rtc_device *rtc = platform_get_drvdata(pdev);
+
+    __raw_writel(0, rtc->base + TIMER_MODE(RTC_TIMER));
+
+    free_irq(apollo_rtc_timer, rtc);
+
+    release_resource(dev_get_drvdata(&rtc->rtc->dev));
+    rtc_device_unregister(rtc->rtc);
+    platform_set_drvdata(pdev, NULL);
+    kfree(rtc);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int rtc_apollo_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    struct apollo_rtc_device *rtc = platform_get_drvdata(pdev);
+
+    if (state.event == PM_EVENT_SUSPEND)
+    {
+        __raw_writel(0, rtc->base + TIMER_MODE(RTC_TIMER));
+    }
+
+    return 0;
+}
+
+static int rtc_apollo_resume(struct platform_device *pdev)
+{
+    struct apollo_rtc_device *rtc = platform_get_drvdata(pdev);
+
+    __raw_writel(1, rtc->base + TIMER_MODE(RTC_TIMER));
+    return 0;
+}
+#else
+# define rtc_apollo_suspend NULL
+# define rtc_apollo_resume  NULL
+#endif
+
+static struct platform_driver rtc_apollo_driver = {
+    .driver     = {
+        .name   = "rtc_apollo",
+        .owner  = THIS_MODULE,
+    },
+    .probe      = rtc_apollo_probe,
+    .remove     = rtc_apollo_remove,
+#ifdef CONFIG_PM
+    .suspend        = rtc_apollo_suspend,
+    .resume         = rtc_apollo_resume,
+#endif
+};
+
+int __init rtc_apollo_init(void)
+{
+#ifdef DEBUG
+    printk("Registering Apollo RTC Driver\n");
+#endif
+    return platform_driver_register(&rtc_apollo_driver);
+}
+
+static void __exit rtc_apollo_exit(void)
+{
+    platform_driver_unregister(&rtc_apollo_driver);
+}
+
+module_init(rtc_apollo_init);
+module_exit(rtc_apollo_exit);
+
+MODULE_AUTHOR("Nitin Garg <nitin.garg@tridentmicro.com>");
+MODULE_DESCRIPTION("APOLLO RTC Driver");
+MODULE_LICENSE("GPL");
diff -Naurp linux-2.6.34.orig/drivers/serial/ip3106.c linux-2.6.34/drivers/serial/ip3106.c
--- linux-2.6.34.orig/drivers/serial/ip3106.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/serial/ip3106.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,1518 @@
+/*
+ * linux/drivers/serial/ip3106.c
+ *
+ *  Copyright(C) 2006, 2007 NXP BV, All rights reserved.
+ *  Author: Jean-Paul Saman, Mischa Jonker <m.d.s.x.jonker@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/slab.h>
+
+#include <linux/types.h>
+
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/pnx8492.h>
+#include <mach/timex.h>
+#include <mach/irqs.h>
+
+#include <asm/hardware/ip3106.h>
+
+
+#define PORT_UARTIP3106		(0x13)
+
+#define UART_DUMMY_RSR_RX	(0)
+#define UART_PORT_SIZE		(4096)
+
+#ifdef CONFIG_EXECUTE_ON_EMULATOR
+#define BASE_BAUD		(4800)
+#else
+#ifdef CONFIG_EXECUTE_ON_SIMULATOR
+#define BASE_BAUD		(38400)
+#else
+#define BASE_BAUD		(115200)
+#endif
+#endif
+#define UART_NR			4
+
+/*---------------------------------------------------------------------------
+ * Access macros for the UART IP_3106
+ *---------------------------------------------------------------------------*/
+#define UART_GET_LSR(p)		__raw_readl((p)->membase + IP3106_UART_LSR_REG)
+#define UART_GET_MCR(p) 	__raw_readl((p)->membase + IP3106_UART_MCR_REG)
+#define UART_SET_MCR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_MCR_REG)
+#define UART_GET_MSR(p)		__raw_readl((p)->membase + IP3106_UART_MSR_REG)
+#define UART_SET_IER(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_IER_REG)
+#define UART_GET_IER(p)		__raw_readl((p)->membase + IP3106_UART_IER_REG)
+#define UART_GET_LCR(p)		__raw_readl((p)->membase + IP3106_UART_LCR_REG)
+#define UART_SET_LCR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_LCR_REG)
+#define UART_GET_CFG(p)		__raw_readl((p)->membase + IP3106_UART_CFG_REG)
+#define UART_SET_DLL(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_DLL_REG)
+#define UART_SET_DLM(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_DLM_REG)
+#define UART_GET_DLL(p)		__raw_readl((p)->membase + IP3106_UART_DLL_REG)
+#define UART_GET_DLM(p)		__raw_readl((p)->membase + IP3106_UART_DLM_REG)
+#define UART_SET_FCR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_FCR_REG)
+#define UART_GET_RBR(p)		__raw_readl((p)->membase + IP3106_UART_RBR_REG)
+#define UART_PUT_THR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_THR_REG)
+#define UART_GET_IIR(p)		__raw_readl((p)->membase + IP3106_UART_IIR_REG)
+#define UART_GET_MOD(p)		__raw_readl((p)->membase + IP3106_UART_MID_REG)
+#define UART_GET_CFG(p)		__raw_readl((p)->membase + IP3106_UART_CFG_REG)
+#define UART_GET_OSR(p)		__raw_readl((p)->membase + IP3106_UART_OSR_REG)
+#define UART_SET_OSR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_OSR_REG)
+#define UART_SET_MODE(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_MODE_REG)
+#define UART_SET_FDR(p,c)	__raw_writel((c),(p)->membase + IP3106_UART_FDR_REG)
+
+/*--------------------------------------------------------------------------*
+ * UART IP_3106 port structure                                              *
+ *--------------------------------------------------------------------------*/
+struct ip3106_port
+{
+	struct uart_port  port;
+	unsigned int      old_status;
+	int               flowctrl;
+	int               autortscts;
+};
+
+/* Added for serial modem notification to edwards layer */
+/* Driver notification events*/
+typedef enum
+{
+   IP3106_TERM = 0,
+   IP3106_TIMEOUT,
+   IP3106_READ_COMPLETE,
+   IP3106_WRITE_COMPLETE,
+   IP3106_RXCHAR,
+   IP3106_TXEMPTY,
+   IP3106_RXOVERFLOW,
+   IP3106_CTS,
+   IP3106_DSR,
+   IP3106_RLSD,
+   IP3106_RING,
+   IP3106_DDCD,
+   IP3106_PARITY_ERROR,
+   IP3106_FRAMING_ERROR,
+   IP3106_RX_BREAK,
+   IP3106_LAST = IP3106_RX_BREAK
+} IP3106_EVENT;
+
+
+typedef void (*pfnnotify)(unsigned int, bool*, bool*, bool*, unsigned int);
+
+pfnnotify modem_notify = NULL;
+EXPORT_SYMBOL(modem_notify);
+
+int ip3106_set_modem_notification(pfnnotify pfn)
+{
+	if (!pfn)
+		return -1;
+	if (pfn)
+		modem_notify = pfn;
+	return 0;
+}
+EXPORT_SYMBOL(ip3106_set_modem_notification);
+
+static struct ip3106_port ip3106_ports[UART_NR];
+
+static int ip3106_line = 0;
+
+/*--------------------------------------------------------------------------*
+ * Control functions:                                                       *
+ *--------------------------------------------------------------------------*/
+
+static unsigned int ip3106_tx_empty (struct uart_port *port)
+{
+	unsigned int status = 0;
+
+	/* Get the UART status */
+	if (UART_GET_LSR(port) & IP3106_UART_LSR_TEMT_MSK)
+		status = TIOCSER_TEMT;
+	else
+		status = 0;
+
+	return (status);
+}
+
+static void ip3106_set_modem_ctrl(struct uart_port *port, unsigned int mctrl)
+{
+	unsigned int mcr = 0;
+	unsigned int ctrls = 0;
+	unsigned int ctrlc = 0;
+
+	if (mctrl & TIOCM_RTS)
+		ctrls |= IP3106_UART_MCR_RTS_MSK;
+	else
+		ctrlc |= IP3106_UART_MCR_RTS_MSK;
+
+	if (mctrl & TIOCM_DTR)
+		ctrls |= IP3106_UART_MCR_DTR_MSK;
+	else
+		ctrlc |= IP3106_UART_MCR_DTR_MSK;
+
+	if (mctrl & (TIOCM_OUT1 | TIOCM_OUT2))
+		ctrls |= IP3106_UART_MCR_OUT_MSK;
+	else
+		ctrlc |= IP3106_UART_MCR_OUT_MSK;
+
+	/* Get the modem control */
+	mcr = UART_GET_MCR(port);
+	mcr |= ctrls;
+	mcr &= ~ctrlc;
+
+	/* Set the new modem control value */
+	UART_SET_MCR(port, mcr);
+}
+
+static unsigned int ip3106_get_modem_ctrl(struct uart_port *port)
+{
+	unsigned int msr = 0;
+	unsigned int status = 0;
+
+	/* Get the modem status */
+	msr = UART_GET_MSR(port);
+
+	if (msr & IP3106_UART_MSR_DCD_MSK)
+		status |= TIOCM_CAR;
+
+	if (msr & IP3106_UART_MSR_DSR_MSK)
+		status |= TIOCM_DSR;
+
+	if (msr & IP3106_UART_MSR_CTS_MSK)
+		status |= TIOCM_CTS;
+
+	if (msr & IP3106_UART_MSR_RI_MSK)
+		status |= TIOCM_RI;
+
+	return status;
+}
+
+static void ip3106_stop_tx(struct uart_port *port)
+{
+	unsigned int ier = 0;
+	unsigned int lcr = 0;
+
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Disable the Tx channel interrupt */
+	ier = UART_GET_IER(port);
+	ier &= ~IP3106_UART_IER_THREI_E_MSK;
+	UART_SET_IER(port, ier);
+}
+
+static void ip3106_start_tx(struct uart_port *port)
+{
+	unsigned int ier = 0;
+	unsigned int lcr = 0;
+	unsigned char ch;
+	unsigned int status = 0;
+	struct circ_buf *xmit = &port->state->xmit;
+
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Start the transmission by transmitting first character */
+	if (port->x_char) {
+		ch = port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+	} else {
+		ch = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	/* Wait till the Tx FIFO is empty */
+	do {
+		status = UART_GET_LSR(port);
+	} while (!(status & IP3106_UART_LSR_THRE_MSK));
+
+	/* Write the character */
+	UART_PUT_THR(port,ch);
+
+	/* Enable the Tx channel interrupt */
+	ier = UART_GET_IER(port);
+	ier |= IP3106_UART_IER_THREI_E_MSK;
+	UART_SET_IER(port, ier);
+}
+
+static void ip3106_stop_rx(struct uart_port *port)
+{
+	unsigned int ier = 0;
+	unsigned int lcr = 0;
+
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Diasble the Rx channel interrupt */
+	ier = UART_GET_IER(port);
+	ier &= ~(IP3106_UART_IER_RDAI_E_MSK | IP3106_UART_IER_RLSI_E_MSK);
+	UART_SET_IER(port, ier);
+}
+
+static void ip3106_enable_modem_status(struct uart_port *port)
+{
+	unsigned int      ier = 0;
+	unsigned int      lcr = 0;
+	struct ip3106_port *uport = NULL;
+
+	/* Get the UART IP_3106 port*/
+	uport = (struct ip3106_port *) port;
+	if (!uport)
+		return;
+
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Enable the modem status interrupt */
+	ier = UART_GET_IER(port);
+	ier |= (IP3106_UART_IER_MSI_E_MSK);
+
+	/* If auto CTS is present, enable the auto CTS interrupt also */
+	if (uport->autortscts == 1)
+		ier |= IP3106_UART_IER_CTSI_E_MSK;
+
+	UART_SET_IER(port, ier);
+}
+
+static void ip3106_break_ctrl(struct uart_port *port, int break_state)
+{
+	unsigned long flags = 0;
+	unsigned int lcr = 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+	lcr = UART_GET_LCR(port);
+	if (break_state == -1)
+		lcr |= IP3106_UART_LCR_BRK_CTL_MSK;
+	else
+		lcr &= ~IP3106_UART_LCR_BRK_CTL_MSK;
+	UART_SET_LCR(port, lcr);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void ip3106_rx_chars(struct uart_port *port)
+{
+	unsigned int      lcr = 0, status = 0, ch = 0, rsr = 0;
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned int      max_count = 256;
+	unsigned int	  flag = 0;
+
+	/* To access RBR,  set DLAB bit in LCR to 0 */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Read the status of the Rx FIFO */
+	status = UART_GET_LSR(port);
+	/* Read till the FIFO is empty or max_count is 0 */
+	while ( ((status & IP3106_UART_LSR_DR_MSK) != 0) && max_count--) {
+		/* Read the character from Rx FIFO */
+		ch = UART_GET_RBR(port);
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		/* Note that the error handling code is
+		 *  out of the main execution path
+		 */
+		rsr = (UART_GET_LSR(port) | UART_DUMMY_RSR_RX);
+		if (rsr & IP3106_UART_LSR_REG_MSK) {
+			if (rsr & IP3106_UART_LSR_BI_MSK) {
+				rsr &= ~(IP3106_UART_LSR_FE_MSK |
+					 IP3106_UART_LSR_PE_MSK);
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					goto ignore_char;
+			} else if (rsr & IP3106_UART_LSR_PE_MSK) {
+				port->icount.parity++;
+			} else if (rsr & IP3106_UART_LSR_FE_MSK) {
+				port->icount.frame++;
+			}
+
+			if (rsr & IP3106_UART_LSR_OE_MSK) {
+				port->icount.overrun++;
+			}
+
+			rsr &= port->read_status_mask;
+			if (rsr & IP3106_UART_LSR_BI_MSK) {
+				flag = TTY_BREAK;
+			} else if (rsr & IP3106_UART_LSR_PE_MSK) {
+				flag = TTY_PARITY;
+			} else if (rsr & IP3106_UART_LSR_FE_MSK) {
+				flag = TTY_FRAME;
+			}
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, rsr, IP3106_UART_LSR_OE_MSK, ch, flag);
+
+		if ((rsr & port->ignore_status_mask) == 0)
+			tty_flip_buffer_push(tty);
+
+ignore_char:
+		status = UART_GET_LSR(port);
+	}
+	tty_flip_buffer_push(tty);
+	
+	if (modem_notify) 
+	{
+		modem_notify (IP3106_RXCHAR, 
+					NULL, 
+					NULL, 
+					NULL, 
+					port->line);
+	}
+}
+
+static void ip3106_tx_chars(struct uart_port *port)
+{
+	int             count = 0;
+	unsigned int    lcr = 0;
+	struct circ_buf *xmit = &port->state->xmit;
+
+//	/* To access THR,  set DLAB bit in LCR to 0 */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	if (port->x_char) {
+		UART_PUT_THR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		ip3106_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		UART_PUT_THR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		ip3106_stop_tx(port);
+
+	if (modem_notify) 
+	{
+		modem_notify (IP3106_TXEMPTY, 
+					NULL, 
+					NULL, 
+					NULL, 
+					port->line);
+	}	
+}
+
+
+static void ip3106_modem_status_mdm(struct uart_port *port)
+{
+	unsigned int status = 0, delta = 0;
+	struct ip3106_port *uap = NULL;
+	struct uart_state *info = NULL;
+	bool cts = false;
+	bool dsr = false;
+	bool dcd = false;
+	IP3106_EVENT event;
+
+	uap = (struct ip3106_port *) port;
+	if( !uap )
+		return;
+
+	/* Added for event notification */
+	status = UART_GET_MSR(port);
+
+	if (status & IP3106_UART_MSR_CTS_MSK)
+	{
+		cts = true;
+		event = IP3106_CTS;
+	}
+	if (status & IP3106_UART_MSR_DDSR_MSK)
+	{
+		dsr = true;
+		event = IP3106_DSR;
+	}
+	if (status & IP3106_UART_MSR_TERI_MSK)
+	{
+		event = IP3106_RING;
+	}
+	if (status & IP3106_UART_MSR_DDCD_MSK) 
+	{
+		dcd = true;
+		event = IP3106_DDCD;
+	}
+
+	if (modem_notify)
+	{
+		modem_notify((unsigned int)event, 
+					&cts, 
+					&dsr, 
+					&dcd, 
+					port->line);
+	}
+
+	status &= (IP3106_UART_MSR_DCD_MSK |
+	                IP3106_UART_MSR_DSR_MSK |
+	                IP3106_UART_MSR_CTS_MSK );
+	delta = status ^ uap->old_status;
+	uap->old_status = status;
+	//printk ("uap->old_statue = 0x%x, status=0x%x", uap->old_status, status);
+	if (!delta)
+		return;
+
+	if (delta & IP3106_UART_MSR_DCD_MSK) {
+		info = port->state;
+
+		if(status & IP3106_UART_MSR_DCD_MSK)
+		{
+			port->icount.dcd++;
+			wake_up_interruptible(&info->port.open_wait);
+			dcd = true;		
+		}
+		else
+			dcd = false;		
+		if (modem_notify)
+		{
+			modem_notify(IP3106_DDCD, 
+						NULL, 
+						NULL, 
+						&dcd, 
+						port->line);
+		}
+	}
+	if (delta & IP3106_UART_MSR_DSR_MSK) {
+		uap->port.icount.dsr++;
+
+		if(status & IP3106_UART_MSR_DCD_MSK)
+			dsr = true;
+		else
+			dsr = false;
+		if (modem_notify)
+		{
+			modem_notify(IP3106_DSR, 
+						NULL, 
+						&dsr, 
+						NULL, 
+						port->line);
+		}
+	}
+	if (delta & IP3106_UART_MSR_CTS_MSK) {
+		uart_handle_cts_change(&uap->port,
+			status & IP3106_UART_MSR_CTS_MSK);
+		
+		if (status & IP3106_UART_MSR_CTS_MSK)
+			cts = true;
+		else
+			cts = false;
+		if (modem_notify)
+		{
+			modem_notify(IP3106_CTS, 
+						&cts, 
+						NULL, 
+						NULL, 
+						port->line);
+		}
+	}
+	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
+}
+
+
+static void ip3106_modem_status(struct uart_port *port)
+{
+	unsigned int status = 0, delta = 0;
+	struct ip3106_port *uap = NULL;
+	bool cts = false;
+	bool dsr = false;
+	bool dcd = false;
+	IP3106_EVENT event;
+
+	uap = (struct ip3106_port *) port;
+	if( !uap )
+		return;
+
+	/* Added for event notification */
+	status = UART_GET_MSR(port);
+
+	if (status & IP3106_UART_MSR_CTS_MSK)
+	{
+		cts = true;
+		event = IP3106_CTS;
+	}
+	if (status & IP3106_UART_MSR_DDSR_MSK)
+	{
+		dsr = true;
+		event = IP3106_DSR;
+	}
+	if (status & IP3106_UART_MSR_TERI_MSK)
+	{
+		event = IP3106_RING;
+	}
+	if (status & IP3106_UART_MSR_DDCD_MSK) 
+	{
+		dcd = true;
+		event = IP3106_DDCD;
+	}
+
+	if (modem_notify)
+	{
+		modem_notify((unsigned int)event, 
+					&cts, 
+					&dsr, 
+					&dcd, 
+					port->line);
+	}
+
+	status &= (IP3106_UART_MSR_DCD_MSK |
+	                IP3106_UART_MSR_DSR_MSK |
+	                IP3106_UART_MSR_CTS_MSK );
+	delta = status ^ uap->old_status;
+	uap->old_status = status;
+	if (!delta)
+		return;
+
+	if (delta & IP3106_UART_MSR_DCD_MSK) {
+		uart_handle_dcd_change(&uap->port,
+			status & IP3106_UART_MSR_DCD_MSK);
+
+		if(status & IP3106_UART_MSR_DCD_MSK)
+			dcd = true;		
+		else
+			dcd = false;		
+		if (modem_notify)
+		{
+			modem_notify(IP3106_DDCD, 
+						NULL, 
+						NULL, 
+						&dcd, 
+						port->line);
+		}
+	}
+	if (delta & IP3106_UART_MSR_DSR_MSK) {
+		uap->port.icount.dsr++;
+
+		if(status & IP3106_UART_MSR_DCD_MSK)
+			dsr = true;
+		else
+			dsr = false;
+		if (modem_notify)
+		{
+			modem_notify(IP3106_DSR, 
+						NULL, 
+						&dsr, 
+						NULL, 
+						port->line);
+		}
+	}
+	if (delta & IP3106_UART_MSR_CTS_MSK) {
+		uart_handle_cts_change(&uap->port,
+			status & IP3106_UART_MSR_CTS_MSK);
+		
+		if (status & IP3106_UART_MSR_CTS_MSK)
+			cts = true;
+		else
+			cts = false;
+		if (modem_notify)
+		{
+			modem_notify(IP3106_CTS, 
+						&cts, 
+						NULL, 
+						NULL, 
+						port->line);
+		}
+	}
+	wake_up_interruptible(&uap->port.state->port.delta_msr_wait);
+}
+
+static irqreturn_t ip3106_int(int irq, void *dev_id)
+{
+	struct ip3106_port *uap = (struct ip3106_port *) dev_id;
+	struct uart_port *port = (struct uart_port *) &(uap->port);
+	unsigned int 	 irq_status = 0;
+	unsigned int     status = 0;
+	unsigned int	 mcr = 0;
+	int              handled = 0;
+
+	spin_lock_irq(&uap->port.lock);
+	status = UART_GET_IIR(port);
+	if (!(status & IP3106_UART_IIR_PENDING_MSK)) {
+		irq_status = (status & IP3106_UART_IIR_INT_MASK) >> 1;
+
+		if ((irq_status  == IP3106_UART_IIR_RLS_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_RLSI_E_MSK)) {
+			UART_GET_LSR(port);
+		}
+		if (((irq_status == IP3106_UART_IIR_CTI_INT_ID) ||
+			(irq_status == IP3106_UART_IIR_RDA_INT_ID)) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_RDAI_E_MSK)) {
+			if (uap->flowctrl == CRTSCTS) {
+				if (uap->autortscts == 0) {
+					/* Deassert the RTS */
+					mcr = UART_GET_MCR(port);
+					mcr &= ~IP3106_UART_MCR_RTS_MSK;
+					UART_SET_MCR(port,mcr);
+				}
+			}
+			if(uap->flowctrl == (IXON|IXOFF)) {
+				UART_PUT_THR(port,0x13);
+			}
+			ip3106_rx_chars(port);
+
+			if(uap->flowctrl == CRTSCTS) {
+				if(uap->autortscts == 0) {
+					/* Assert the RTS */
+					mcr = UART_GET_MCR(port);
+					mcr |= IP3106_UART_MCR_RTS_MSK;
+					UART_SET_MCR(port,mcr);
+				}
+			}
+			if(uap->flowctrl == (IXON|IXOFF)) {
+				UART_PUT_THR(port,0x11);
+			}
+		}
+		if ((irq_status == IP3106_UART_IIR_THRE_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_THREI_E_MSK)) {
+			ip3106_tx_chars(port);
+		}
+		if ((irq_status == IP3106_UART_IIR_MSI_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_MSI_E_MSK )) {
+			ip3106_modem_status(port);
+		}
+		status = UART_GET_IIR(port);
+		handled = 1;
+	}
+	spin_unlock_irq(&uap->port.lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+
+
+static irqreturn_t ip3106_modem_int(int irq, void *dev_id)
+{
+	struct ip3106_port *uap = (struct ip3106_port *) dev_id;
+	struct uart_port *port = (struct uart_port *) &(uap->port);
+	unsigned int 	 irq_status = 0;
+	unsigned int     status = 0;
+	unsigned int	 mcr = 0;
+	int              handled = 0;
+
+	spin_lock_irq(&uap->port.lock);
+	status = UART_GET_IIR(port);
+	if (!(status & IP3106_UART_IIR_PENDING_MSK)) {
+		irq_status = (status & IP3106_UART_IIR_INT_MASK) >> 1;
+
+		if ((irq_status  == IP3106_UART_IIR_RLS_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_RLSI_E_MSK)) {
+			UART_GET_LSR(port);
+		}
+		if (((irq_status == IP3106_UART_IIR_CTI_INT_ID) ||
+			(irq_status == IP3106_UART_IIR_RDA_INT_ID)) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_RDAI_E_MSK)) {
+			if (uap->flowctrl == CRTSCTS) {
+				if (uap->autortscts == 0) {
+					/* Deassert the RTS */
+					mcr = UART_GET_MCR(port);
+					mcr &= ~IP3106_UART_MCR_RTS_MSK;
+					UART_SET_MCR(port,mcr);
+				}
+			}
+			if(uap->flowctrl == (IXON|IXOFF)) {
+				UART_PUT_THR(port,0x13);
+			}
+			ip3106_rx_chars(port);
+
+			if(uap->flowctrl == CRTSCTS) {
+				if(uap->autortscts == 0) {
+					/* Assert the RTS */
+					mcr = UART_GET_MCR(port);
+					mcr |= IP3106_UART_MCR_RTS_MSK;
+					UART_SET_MCR(port,mcr);
+				}
+			}
+			if(uap->flowctrl == (IXON|IXOFF)) {
+				UART_PUT_THR(port,0x11);
+			}
+		}
+		if ((irq_status == IP3106_UART_IIR_THRE_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_THREI_E_MSK)) {
+			ip3106_tx_chars(port);
+		}
+		if ((irq_status == IP3106_UART_IIR_MSI_INT_ID) &&
+			(UART_GET_IER(port) & IP3106_UART_IER_MSI_E_MSK )) {
+			ip3106_modem_status_mdm(port);
+		}
+		status = UART_GET_IIR(port);
+		handled = 1;
+	}
+	spin_unlock_irq(&uap->port.lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+static int ip3106_startup(struct uart_port *port)
+{
+	unsigned int       retval = 0;
+	unsigned int       divisor = 0;
+	__u8               dll = 0;
+	__u8		   dlm = 0;
+	unsigned int       lcr = 0;
+	unsigned int	   fcr = 0;
+	unsigned int	   ier = 0;
+	unsigned int       baud = BASE_BAUD;
+	unsigned int	   osr = 0;
+	struct ip3106_port *uport = (struct ip3106_port *)port;
+
+	/* Initilize the Line Control Settings
+	 * 8- data bits, 1- stop bits, No Parity
+	 * DLAB bit in the LineControl Register is set to zero
+	 */
+	lcr = ((IP3106_UART_LCR_WORDLEN_8BIT << IP3106_UART_LCR_WORD_LEN_POS)|
+		(IP3106_UART_LCR_1_STOP_BIT << IP3106_UART_LCR_STOPB_POS)    |
+		(IP3106_UART_LCR_NO_PARITY << IP3106_UART_LCR_PAR_EN_POS)    |
+		(IP3106_UART_LCR_NO_BREAK_TR << IP3106_UART_LCR_BRK_CTL_POS) |
+		(IP3106_UART_LCR_DIV_LAB << IP3106_UART_LCR_DLAB_POS) );
+	UART_SET_LCR(port, lcr);
+
+	/* Set the Baud Rate to BASE_BAUD
+	 * To access the Baud Rate Register DLAB bit in LineControl = 1
+	 * after setting the Baud Rate, RESET the DLAB Bit again to Zero.
+	 */
+	divisor = ((port->uartclk) + (8 * baud)) / (baud * 16);
+    if (divisor == 0)
+    {
+        /* The baud rate is higher than the UART clock using
+         * the divider latch.  Setup the over-sampling register.
+         */
+        divisor = 1;
+        osr = (((port->uartclk / baud) - 1) << 4);
+        osr |= (((port->uartclk % baud) / (baud / 8)) << 1);
+        UART_SET_OSR(port, osr);
+    }
+	dll = (__u8) divisor;
+	dlm = (__u8) (divisor >> 8);
+	UART_SET_DLL(port, dll);
+	UART_SET_DLM(port, dlm);
+
+	/* Enable the RBR and THR for transmitt and Receive
+	 * by Disabling the DLAB bit in LCR */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Enable the RX and TX FIFO's and Reset to 1
+	 * set the Trigger level to 56
+	 */
+	fcr =((IP3106_UART_FCR_FIF_ENA_MSK)	|		/* Bit 0 FIFO Enable */
+		(IP3106_UART_FCR_RXF_RES_MSK)	|		/* RX FIFO Reset */
+		(IP3106_UART_FCR_TXF_RES_MSK)	|		/* TX FIFO Reset */
+		(IP3106_UART_FCR_RX_TRIG_LEVEL_3
+			<< IP3106_UART_FCR_RX_TRIGGER_POS));
+	UART_SET_FCR(port,fcr);
+
+	/* Clear the Interrupt status signals */
+	UART_GET_MSR(port);
+	UART_GET_LSR(port);
+	UART_GET_IIR(port);
+
+	/* Set the Modem Control Register to ZERO */
+	UART_SET_MCR(port, 0);
+
+	/* Store modem status signals */
+	uport->old_status = UART_GET_MSR(port) &
+	                          (IP3106_UART_MSR_DCD_MSK |
+	                           IP3106_UART_MSR_DSR_MSK |
+	                           IP3106_UART_MSR_CTS_MSK );
+	
+#if 0 /* FIX_IT:: Removed to use different hander for modem and other UARTs */
+	/* Allocate the IRQ */
+	retval = request_irq(port->irq, ip3106_int, 0, "uart-ip3106", port);
+	if (retval > 0) {
+		return retval;
+	}
+#endif
+
+	/* Allocate the IRQ */
+	if (port->irq == ip3106_ports[0].port.irq)
+		retval = request_irq(port->irq, ip3106_modem_int, 0, "uart-ip3106", port);
+	else
+		retval = request_irq(port->irq, ip3106_int, 0, "uart-ip3106", port);
+
+	if (retval > 0) {
+		return retval;
+	}
+
+	/* Finally enable the receive interrupts interrupts */
+	ier = (IP3106_UART_IER_RDAI_E_MSK | IP3106_UART_IER_RLSI_E_MSK );
+	UART_SET_IER(port, ier);
+	return 0;
+}
+
+static void ip3106_shutdown(struct uart_port *port)
+{
+	unsigned int lcr = 0;
+
+	/* Free the interrupt */
+	free_irq(port->irq, port);
+
+	/* disable all interrupts, disable the port */
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Disable the port */
+	UART_SET_IER(port, 0);
+
+	/* disable break condition and fifos */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_BRK_CTL_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Disable the FIFOs */
+	UART_SET_FCR(port, 0);
+}
+
+static void ip3106_set_termios(struct uart_port *port,
+		struct ktermios *termios, struct ktermios *old)
+{
+	unsigned int      lcr = 0;
+	unsigned int	  lcr1 = 0;
+	unsigned int	  old_ier = 0;
+	unsigned long     flags = 0;
+	unsigned int      baud = 0;
+	unsigned int	  quot = 0;
+	unsigned int      mcr = 0;
+	unsigned int      osr = 0;
+	struct ip3106_port *uport = NULL;
+	unsigned int      fcr = 0;
+
+	uport = (struct ip3106_port *)port; /* Get the UART IP_3106 port*/
+
+	/* Ask the core to calculate the divisor for us. */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk);
+	quot = uart_get_divisor(port, baud);
+    if (quot == 0)
+    {
+        /* The baud rate is set faster than the UART clock using
+         * the divider latch.  Setup the over-sampling register.
+         */
+        quot = 1;
+        osr = (((port->uartclk / baud) - 1) << 4);
+        osr |= (((port->uartclk % baud) / (baud / 8)) << 1);
+	    UART_SET_OSR(port, osr);
+    }
+
+	switch (termios->c_cflag & CSIZE) {
+		case CS5:
+			lcr = IP3106_UART_LCR_WORDLEN_5BIT
+				<< IP3106_UART_LCR_WORD_LEN_POS;
+			break;
+		case CS6:
+			lcr = IP3106_UART_LCR_WORDLEN_6BIT
+				<< IP3106_UART_LCR_WORD_LEN_POS;
+			break;
+		case CS7:
+			lcr = IP3106_UART_LCR_WORDLEN_7BIT
+				<< IP3106_UART_LCR_WORD_LEN_POS;
+			break;
+		default: /* CS8 */
+			lcr = IP3106_UART_LCR_WORDLEN_8BIT
+				<< IP3106_UART_LCR_WORD_LEN_POS;
+			break;
+	}
+
+	if (termios->c_cflag & CSTOPB) {
+		lcr |= (IP3106_UART_LCR_2_STOP_BIT
+			<< IP3106_UART_LCR_STOPB_POS);
+	}
+	if (termios->c_cflag & PARENB) {
+		lcr |= (IP3106_UART_LCR_PARITY << IP3106_UART_LCR_PAR_EN_POS);
+		if (!(termios->c_cflag & PARODD)) {
+			lcr |= (IP3106_UART_LCR_PARITY_EVEN
+				<< IP3106_UART_LCR_PAR_SEL_POS) ;
+		}
+	}
+	if (port->fifosize > 1) {
+		fcr =((IP3106_UART_FCR_FIF_ENA_MSK)	|	/* Bit 0 FIFO Enable */
+			(IP3106_UART_FCR_RXF_RES_MSK)	|	/* RX FIFO Reset */
+			(IP3106_UART_FCR_TXF_RES_MSK)	|	/* TX FIFO Reset */
+			(IP3106_UART_FCR_RX_TRIG_LEVEL_3
+				<< IP3106_UART_FCR_RX_TRIGGER_POS));
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Update the per-port timeout */
+	uart_update_timeout(port, termios->c_cflag, baud);
+	port->read_status_mask = IP3106_UART_LSR_OE_MSK;
+
+	if (termios->c_iflag & INPCK) {
+		port->read_status_mask |= IP3106_UART_LSR_FE_MSK |
+						IP3106_UART_LSR_PE_MSK;
+	}
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		port->read_status_mask |= IP3106_UART_LSR_BI_MSK;
+	}
+
+	/* Characters to ignore  */
+	port->ignore_status_mask = 0;
+
+	if (termios->c_iflag & IGNPAR) {
+		port->ignore_status_mask |= IP3106_UART_LSR_FE_MSK |
+						IP3106_UART_LSR_PE_MSK;
+	}
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= IP3106_UART_LSR_BI_MSK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= IP3106_UART_LSR_OE_MSK;
+	}
+	/* Ignore all characters if CREAD is not set */
+	if ((termios->c_cflag & CREAD) == 0) {
+		port->ignore_status_mask |= UART_DUMMY_RSR_RX;
+	}
+	lcr1 = UART_GET_LCR(port);
+	lcr1 &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port,lcr1);
+
+	/* first, disable everything */
+	old_ier = UART_GET_IER(port) & ~IP3106_UART_IER_MSI_E_MSK;
+	if (UART_ENABLE_MS(port, termios->c_cflag)) {
+		old_ier |= IP3106_UART_IER_MSI_E_MSK;
+		/* If Auto RTSCTS present, use it */
+		if (uport->autortscts == 1) {
+			old_ier  |=  IP3106_UART_IER_CTSI_E_MSK;
+			mcr = UART_GET_MCR(port);
+			mcr |= IP3106_UART_MCR_ARTS_EN_MSK |
+					IP3106_UART_MCR_ACTS_EN_MSK;
+			UART_SET_MCR(port,mcr);
+		}
+		if (uport->flowctrl != 0)
+			uport->flowctrl = CRTSCTS;
+	} else if ( (termios->c_iflag & (IXON|IXOFF)) &&
+			(uport->flowctrl = 0) ) {
+		uport->flowctrl = IXON|IXOFF;
+	} else {
+		uport->flowctrl = 0;
+	}
+
+	UART_SET_IER(port,0);
+	UART_SET_FCR(port,0);
+
+	/* Set baud rate */
+	/* To access DLL,DLM registers, DLab bit in LCR must be set */
+	lcr1 = UART_GET_LCR(port);
+	lcr1 |= IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr1);
+	UART_SET_DLM(port, ((quot & 0xf00) >> 8));
+	UART_SET_DLL(port, (quot & 0xff));
+
+	/* To access Interrupt Enable Register,
+	 * DLab bit in LCR must be ZERO
+	 */
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+	UART_SET_FCR(port, fcr);
+	UART_SET_IER(port, old_ier);
+
+	/* Enable Modem Status interrupt for UART0 Always */
+	if (port->line == ip3106_ports[0].port.line)
+	{
+		old_ier  = UART_GET_IER(port);
+		if (!(old_ier & IP3106_UART_IER_MSI_E_MSK)) {
+			old_ier |= IP3106_UART_IER_MSI_E_MSK;
+			UART_SET_IER(port, old_ier);	
+		}
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *ip3106_type(struct uart_port *port)
+{
+	return (port->type == PORT_UARTIP3106) ? "uart-ip3106" : NULL;
+}
+
+static void ip3106_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+}
+
+static int ip3106_request_port(struct uart_port *port)
+{
+	return request_mem_region( port->mapbase, UART_PORT_SIZE,
+			"uart-ip3106") != NULL ? 0 : -EBUSY;
+}
+
+static void ip3106_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_UARTIP3106;
+		ip3106_request_port(port);
+	}
+}
+
+static int
+ip3106_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+
+	if ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_UARTIP3106))
+		ret = -EINVAL;
+	if ((ser->irq < 0) || (ser->irq >= NR_IRQS))
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+/*--------------------------------------------------------------------------*
+ * Port Control Functions for UART IP3106                                   *
+ *--------------------------------------------------------------------------*/
+static struct uart_ops ip3106_pops =
+{
+	.tx_empty     = ip3106_tx_empty,
+	.set_mctrl    = ip3106_set_modem_ctrl,
+	.get_mctrl    = ip3106_get_modem_ctrl,
+	.stop_tx      = ip3106_stop_tx,
+	.start_tx     = ip3106_start_tx,
+	.stop_rx      = ip3106_stop_rx,
+	.enable_ms    = ip3106_enable_modem_status,
+	.break_ctl    = ip3106_break_ctrl,
+	.startup      = ip3106_startup,
+	.shutdown     = ip3106_shutdown,
+	.set_termios  = ip3106_set_termios,
+	.type	      = ip3106_type,
+	.release_port = ip3106_release_port,
+	.request_port = ip3106_request_port,
+	.config_port  = ip3106_config_port,
+	.verify_port  = ip3106_verify_port,
+};
+
+#if defined(CONFIG_SERIAL_IP3106_CONSOLE)
+/*--------------------------------------------------------------------------*
+ * Console functions for UART IP3106                                        *
+ *--------------------------------------------------------------------------*/
+
+static struct ip3106_port ip3106_ports[UART_NR] =
+{
+	{
+		.port   =
+		{
+			.membase        = __IOMEM(IP3106_UART_PORT_0),
+			.mapbase        = IP3106_UART_PORT_0,
+			.iotype         = SERIAL_IO_MEM,
+			.irq            = IRQ_UART_0,
+			.uartclk        = UART_CLOCK_RATE,
+			.fifosize       = 64,
+			.ops            = &ip3106_pops,
+			.flags          = UPF_BOOT_AUTOCONF,
+			.line           = 0,
+		},
+		.autortscts = 0,
+		/* FIX_IT:: Always enable flowctrl for modem port
+		.flowctrl   = 0, 
+		*/
+		.flowctrl   = CRTSCTS, /* Flow control should be enabled for modem port */
+
+	},
+#ifndef CONFIG_EXECUTE_ON_SIMULATOR
+	{
+		.port   =
+		{
+			.membase        = __IOMEM(IP3106_UART_PORT_1),
+			.mapbase        = IP3106_UART_PORT_1,
+			.iotype         = SERIAL_IO_MEM,
+			.irq            = IRQ_UART_1,
+			.uartclk        = UART_CLOCK_RATE,
+			.fifosize       = 64,
+			.ops            = &ip3106_pops,
+			.flags          = UPF_BOOT_AUTOCONF,
+			.line           = 1,
+		},
+		.autortscts = 0,
+		.flowctrl   = 0, /* Flow control is not supported on our target */
+	},
+	{
+		.port   =
+		{
+			.membase        = __IOMEM(IP3106_UART_PORT_2),
+			.mapbase        = IP3106_UART_PORT_2,
+			.iotype         = SERIAL_IO_MEM,
+			.irq            = IRQ_UART_2, /* LET OP IRQ_UART-nbr !! */
+			.uartclk        = UART_CLOCK_RATE,
+			.fifosize       = 64,
+			.ops            = &ip3106_pops,
+			.flags          = UPF_BOOT_AUTOCONF,
+			.line           = 2,
+		},
+		.autortscts = 0,
+		.flowctrl   = 0, /* Flow control is not supported on our target */
+	},
+	{
+		.port   =
+		{
+			.membase        = __IOMEM(IP3106_UART_PORT_3),
+			.mapbase        = IP3106_UART_PORT_3,
+			.iotype         = SERIAL_IO_MEM,
+			.irq            = IRQ_UART_3, /* LET OP IRQ_UART-nbr !! */
+			.uartclk        = UART_CLOCK_RATE,
+			.fifosize       = 64,
+			.ops            = &ip3106_pops,
+			.flags          = UPF_BOOT_AUTOCONF,
+			.line           = 3,
+		},
+		.autortscts = 0,
+		.flowctrl   = 0, /* Flow control is not supported on our target */
+	},
+#endif
+};
+
+static void ip3106_console_write(struct console *co,
+	const char *s, unsigned int count)
+{
+	unsigned int 	status = 0;
+	unsigned int	lcr = 0;
+	unsigned int	old_ier = 0;
+	struct ip3106_port *uap = NULL;
+	int i = 0;
+
+	uap = &ip3106_ports[co->index];
+
+	/* To access Interrupt Enable Register,
+	 * DLab bit in LCR must be ZERO
+	 */
+	lcr = __raw_readl(uap->port.membase + IP3106_UART_LCR_REG);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	__raw_writel(lcr,uap->port.membase + IP3106_UART_LCR_REG);
+
+	/* First save the CR then disable the interrupts */
+	old_ier = __raw_readl(uap->port.membase + IP3106_UART_IER_REG);
+	__raw_writel(0,uap->port.membase + IP3106_UART_IER_REG);
+
+	/* Now write the each character */
+	for (i = 0; i < count; i++) {
+		/* Wait till the Tx FIFO is ready */
+		do {
+			status = __raw_readl(uap->port.membase +
+					IP3106_UART_LSR_REG);
+		} while (!(status & IP3106_UART_LSR_THRE_MSK));
+
+		__raw_writel(s[i],uap->port.membase + IP3106_UART_THR_REG);
+		if (s[i] == '\n') {
+			do {
+				status = __raw_readl(uap->port.membase +
+						IP3106_UART_LSR_REG);
+			} while (!(status & IP3106_UART_LSR_THRE_MSK));
+			__raw_writel('\r',uap->port.membase +
+					IP3106_UART_THR_REG);
+		}
+	}
+	/* Wait for transmitter to become empty
+	 *	and restore the IER */
+	do {
+		status = __raw_readl(uap->port.membase + IP3106_UART_LSR_REG);
+	} while (!(status & IP3106_UART_LSR_THRE_MSK));
+	__raw_writel(old_ier, uap->port.membase + IP3106_UART_IER_REG);
+}
+
+static void __init ip3106_console_get_options(struct uart_port *port,
+	int *baud, int *parity, int *bits)
+{
+	unsigned int lcr = 0;
+	unsigned int quot = 0;
+	unsigned int word_len = 0;
+
+	lcr = UART_GET_LCR(port);
+	*parity = 'n';
+
+	if (lcr & IP3106_UART_LCR_PAR_EN_MSK) {
+		if (lcr & IP3106_UART_LCR_PAR_SEL_MSK)
+			*parity = 'e';
+		else
+			*parity = 'o';
+	}
+	word_len = lcr & IP3106_UART_LCR_WORD_LEN_MSK;
+	switch (word_len) {
+		case IP3106_UART_LCR_WORDLEN_5BIT:
+			*bits = 5;
+			break;
+		case IP3106_UART_LCR_WORDLEN_6BIT:
+			*bits = 6;
+			break;
+		case IP3106_UART_LCR_WORDLEN_7BIT:
+			*bits = 7;
+			break;
+		default:
+			*bits = 8;
+			break;
+	}
+
+	/* To access DLL,DLM, DLab bit in LCR must be 1 */
+	lcr = UART_GET_LCR(port);
+	lcr |= IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	/* Calculate the baud rate from DLL,DLM values */
+	quot = UART_GET_DLL(port) | UART_GET_DLM(port) << 8;
+	*baud = port->uartclk / (quot + 1);
+
+	/* Disable the access to DLL,DLM */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+}
+
+static int __init ip3106_console_setup(struct console *co, char *options)
+{
+	struct ip3106_port *uap = NULL;
+	int baud = BASE_BAUD;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/* Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if ((co->index >= UART_NR) || (co->index < 0)) {
+		co->index = 0;
+	}
+	uap = &ip3106_ports[co->index];
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else {
+		ip3106_console_get_options(&uap->port, &baud, &parity, &bits);
+	}
+
+	return uart_set_options(&uap->port, co, baud, parity, bits, flow);
+}
+
+/*--------------------------------------------------------------------------*
+ * Console strcuture for UART IP3106                                        *
+ *--------------------------------------------------------------------------*/
+static struct uart_driver ip3106_uart; /* Forward declaration */
+static struct console ip3106_console = {
+	.name		= "ttyS",
+	.write		= ip3106_console_write,
+	.device		= uart_console_device,
+	.setup		= ip3106_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ip3106_uart,
+};
+
+static int __init ip3106_console_init(void)
+{
+	register_console(&ip3106_console);
+	return 0;
+}
+console_initcall(ip3106_console_init);
+
+static int __init ip3106_late_console_init(void)
+{
+	if (!(ip3106_console.flags & CON_ENABLED)) {
+		register_console(&ip3106_console);
+	}
+	return 0;
+}
+late_initcall(ip3106_late_console_init);
+
+#endif /* CONFIG_SERIAL_IP3106_CONSOLE */
+
+/*--------------------------------------------------------------------------*
+ * Driver Registration structure for UART IP3106                            *
+ *--------------------------------------------------------------------------*/
+static struct uart_driver ip3106_uart = {
+	.owner			= THIS_MODULE,
+	.driver_name	= "ttyS",
+	.dev_name		= "ttyS",
+	.major			= 4,	/* Major device number */
+	.minor			= 64,	/* Minor device number */
+	.nr				= UART_NR,
+#if defined(CONFIG_SERIAL_IP3106_CONSOLE)
+	.cons			= &ip3106_console,
+#else
+	.cons			= NULL;
+#endif
+};
+
+/*
+ * Amba device driver
+ */
+static int ip3106_probe(struct platform_device *dev)
+{
+	struct ip3106_port *uap = NULL;
+	struct resource *res;
+	void __iomem *base;
+	int ret = -ENODEV;
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	uap = kmalloc(sizeof(struct ip3106_port), GFP_KERNEL);
+	if (uap == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	memset(uap, 0, sizeof(struct ip3106_port));
+
+	base = ioremap(res->start, res->end - res->start + 1);
+	if (!base) {
+		ret = -ENOMEM;
+		goto free;
+	}
+
+	uap->port.dev = &dev->dev;
+	uap->port.ops = &ip3106_pops;
+	uap->port.membase = base;
+	uap->port.mapbase = res->start;
+	uap->port.iotype  = SERIAL_IO_MEM;
+	uap->port.irq     = platform_get_irq(dev, 0);
+	uap->port.uartclk = UART_CLOCK_RATE;
+	uap->port.fifosize= 64;
+	uap->port.flags = UPF_BOOT_AUTOCONF;
+	uap->port.line  = ip3106_line;
+	uap->autortscts = 0;
+	uap->flowctrl   = 0;
+
+	spin_lock_init(&uap->port.lock);
+	platform_set_drvdata(dev, uap);
+	ip3106_line++;
+
+	ret = uart_add_one_port(&ip3106_uart, &uap->port);
+	if (ret) {
+		platform_set_drvdata(dev, NULL);
+		iounmap(base);
+ free:
+		kfree(uap);
+	}
+ out:
+	return ret;
+}
+
+static int ip3106_remove(struct platform_device *dev)
+{
+	struct ip3106_port *uap = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+	ip3106_line--;
+	uart_remove_one_port(&ip3106_uart, &uap->port);
+	iounmap(uap->port.membase);
+	kfree(uap);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ip3106_suspend(struct platform_device *dev, pm_message_t msg)
+{
+	struct ip3106_port *uap = platform_get_drvdata(dev);
+
+	if (uap)
+		uart_suspend_port(&ip3106_uart, &uap->port);
+
+	return 0;
+}
+
+static int ip3106_resume(struct platform_device *dev)
+{
+	struct ip3106_port *uap = platform_get_drvdata(dev);
+
+	if (uap)
+		uart_resume_port(&ip3106_uart, &uap->port);
+	return 0;
+}
+#else
+#define ip3106_suspend	NULL
+#define ip3106_resume	NULL
+#endif
+
+static struct platform_driver ip3106_driver = {
+	.driver		= {
+		.name	= "uart-ip3106",
+		.bus	= &platform_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ip3106_probe,
+	.remove		= ip3106_remove,
+	.suspend	= ip3106_suspend,
+	.resume		= ip3106_resume,
+};
+
+/* Added for Linux native serial wrapper */
+struct uart_driver *serial_wrapper_ip3106_uart = &ip3106_uart;
+EXPORT_SYMBOL(serial_wrapper_ip3106_uart);
+
+static int __init ip3106_init(void)
+{
+	int ret = 0;
+
+	ret = uart_register_driver(&ip3106_uart);
+	if (ret == 0) {
+		ret = platform_driver_register(&ip3106_driver);
+		if (ret)
+			uart_unregister_driver(&ip3106_uart);
+	} else {
+		printk (KERN_ALERT "IP3106: failed to register UART driver!! ret = %d\n", ret);
+	}
+	return ret;
+}
+
+static void __exit ip3106_exit(void)
+{
+	platform_driver_unregister(&ip3106_driver);
+	uart_unregister_driver(&ip3106_uart);
+}
+
+module_init(ip3106_init);
+module_exit(ip3106_exit);
+
+MODULE_AUTHOR("Jean-Paul Saman");
+MODULE_DESCRIPTION("ip3106 serial port driver");
+MODULE_LICENSE("GPL");
diff -Naurp linux-2.6.34.orig/drivers/serial/Kconfig linux-2.6.34/drivers/serial/Kconfig
--- linux-2.6.34.orig/drivers/serial/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/serial/Kconfig	2010-09-07 22:16:41.000000000 -0500
@@ -1506,4 +1506,27 @@ config SERIAL_GRLIB_GAISLER_APBUART_CONS
 	help
 	Support for running a console on the GRLIB APBUART
 
+config IP3106
+        bool "Support for Generic UART (IP3106)"
+        depends on ( ARCH_ENERGIZER2 )
+        select SERIAL_CORE
+        help
+          Say Y here if you wish to use a IP3106 UART as the system uart driver.
+          The IP3106 is a generic UART of NXP Semiconductors
+          and is a NS16550 compatible UART.
+config SERIAL_IP3106_CONSOLE
+        bool "IP3106 serial console port support"
+        select SERIAL_CORE_CONSOLE
+        depends on IP3106
+        help
+          Say Y here if you wish to use a IP3106 UART as the system console
+          (the system console is the device which receives all kernel messages
+          and warnings and which allows logins in single user mode). The UART
+          is NS16550 compatible.
+          Even if you say Y here, the currently visible framebuffer console
+          (/dev/tty0) will still be used as the system console by default, but
+          you can alter that using a kernel command line option such as
+          "console=ttyS0". (Try "man bootparam" or see the documentation of
+          your boot loader (lilo or loadlin) about how to pass options to the
+          kernel at boot time.)
 endmenu
diff -Naurp linux-2.6.34.orig/drivers/serial/Makefile linux-2.6.34/drivers/serial/Makefile
--- linux-2.6.34.orig/drivers/serial/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/serial/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -82,4 +82,5 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
+obj-$(CONFIG_SERIAL_IP3106_CONSOLE) += ip3106.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
diff -Naurp linux-2.6.34.orig/drivers/spi/Kconfig linux-2.6.34/drivers/spi/Kconfig
--- linux-2.6.34.orig/drivers/spi/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/spi/Kconfig	2010-09-07 22:16:41.000000000 -0500
@@ -53,6 +53,27 @@ if SPI_MASTER
 
 comment "SPI Master Controller Drivers"
 
+config SPI_NX
+	select SPI_DEV
+	tristate "NXP SPI Controller for IP_3409"
+	depends on (ARCH_APOLLO)
+	help
+	 This selects a driver for the NXP SPI Controller, present on
+	 Apollo (ARM) chips.
+
+config SPI_NX_DEBUG
+	boolean "Debug support for SPI IP_3409"
+	depends on SPI_NX
+	help
+	  Say "yes" to enable debug messaging (printk),
+          
+config SPI_NX_DMAC_1902
+	bool "DMA support"
+	depends on (SPI_NX && DMA_ENGINE && NX_DMAC_1902)
+	help
+	 Say Y here if you want to enable DMA support for SPI transfers.
+	 If DMA is enabled, all transfers will happen via DMA IP_1902
+
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on (ARCH_AT91 || AVR32)
diff -Naurp linux-2.6.34.orig/drivers/spi/Makefile linux-2.6.34/drivers/spi/Makefile
--- linux-2.6.34.orig/drivers/spi/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/spi/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -43,6 +43,7 @@ obj-$(CONFIG_SPI_XILINX_OF)		+= xilinx_s
 obj-$(CONFIG_SPI_XILINX_PLTFM)		+= xilinx_spi_pltfm.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
+obj-$(CONFIG_SPI_NX)                    += spidev.o nx_spi.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
 
diff -Naurp linux-2.6.34.orig/drivers/spi/nx_spi.c linux-2.6.34/drivers/spi/nx_spi.c
--- linux-2.6.34.orig/drivers/spi/nx_spi.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/spi/nx_spi.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,1536 @@
+/*
+ * SPI Controller Driver for SPI HW IP_3409
+ *
+ * Author : Sangeeta Mutgi <sangeeta.mutgi@nxp.com>
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version      Author           Date          Remarks
+ * 0.0.1        Sangeeta Mutgi   20090530      Draft-Initial version
+ * 0.1.0        Sangeeta Mutgi   20090612      Rework-review comments
+ * 1.0.0        Sangeeta Mutgi   20090626      Accepted after testing on FPGA9448
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#ifdef CONFIG_SPI_NX_DMAC_1902
+#include <linux/dmaengine.h>
+#include <linux/scatterlist.h>
+#include <linux/nx_dmac_1902.h>
+#endif
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <asm/io.h>
+
+#include <mach/nx_spi_dev.h>
+#include "nx_spi_local.h"
+
+
+/*This enumeration is for describing the action
+that will be taken by the work queue handler*/
+enum nx_spi_action
+{
+  nx_spi_next_xfer =0,
+  nx_spi_msg_done = 1,
+  nx_spi_err_timeout =2,
+  nx_spi_err_overrun =3
+};
+
+/* structure nx_spi
+ *Description : This structure maintains required information for a SPI unit
+ *@work : work structure for workqueue
+ *@lock : spinlock to protect this datastructure from corruption.
+ *        Adv: Kernel doesnt pre-empt while holding the spin_lock.
+ *@regs : virtual register base address for the SPI unit
+ *@irq : IRQ line number
+ *@pdev : platform_device data structure for the SPI Master controller.
+ *@active_spidev : active spi-device for the current transfer if any.
+ *@closing : indicates the driver is under exit state
+ *@queue : maintains a queue of messages
+ *@current_transfer : pointer to current transfer
+ *@curr_remaining_bytes : remaining bytes for current transfer
+ *@control_word : Control word required for enhanced mode transfer
+ *@control_word_done : Boolean to indicate if Control word is transmitted
+ *@enhanced_ip : 1: indicates enhanced master mode IP
+ *@action : next action to be taken in the work queue for the current transfer
+ *@flag_newmsg : indicates if it is a new message for this SPI unit
+ *@buffer :  virtual address for DMA buffer
+ *@dma_buffer : dma physical address for buffer
+ *@waitq : waitqueue to synchronize allocation of dma channel
+ *@dmacha_tx : pointer to dma_chan data struture for TX in the current transfer
+ *@dmacha_rx : pointer to dma_chan data struture for RX in the current transfer
+ *@client_tx : This is for TX client of DMA
+ *@client_rx : This is for RX client of DMA
+ *@chantx_alloted : 1-indicates channel tx is allocated; to synchronize allocation of channel
+ *@chanrx_alloted : 1- Indicates channel rx is allocated; to synchronize allocation of channel
+ *@scratchbuffer : scratch buffer to be used when tx or rx buffers not specified
+ */
+struct nx_spi
+{
+    struct work_struct work;
+    spinlock_t  lock;
+    void __iomem *regs;
+    int irq;
+    struct platform_device *pdev;
+    struct nx_spi_controller_data *ctrldata;
+    struct spi_device *active_spidev;
+
+    __u8 closing;
+    struct list_head queue;
+    struct spi_transfer *current_transfer;
+    unsigned long curr_remaining_bytes;
+    __u32 control_word;
+    __u8 control_word_done;
+    __u8 enhanced_ip;
+    enum nx_spi_action action;
+	__u8 flag_newmsg;
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    void *buffer;
+    dma_addr_t dma_buffer;
+    wait_queue_head_t waitq;
+    struct dma_chan  *dmachan_tx;
+    struct dma_chan  *dmachan_rx;
+    struct dma_client client_tx;
+    struct dma_client client_rx;
+	__u8 chantx_alloted;
+	__u8 chanrx_alloted;
+#endif
+    u32 *scratchbuffer;
+};
+
+//global worker thread variable
+static struct workqueue_struct *nx_spi_wq;
+
+#define INT_EN_MSK (NX_SPI_INT_OV_MSK | \
+                     NX_SPI_INT_TO_MSK | \
+                     NX_SPI_INT_RX_MSK | \
+                     NX_SPI_INT_TX_MSK )
+
+/* Division Factor limits in master mode
+ */
+#define MIN_DIVISION_FACTOR 2       /**< Minimum division factor as Master */
+#define MAX_DIVISION_FACTOR 65024   /**< Maximum division factor as Master */
+
+/* Mask*/
+#define MASK_BUFFER 0xFFFFFFFF
+
+#ifdef CONFIG_SPI_NX_DEBUG
+#define dbg_print(str...) printk(str)
+#else
+#define dbg_print(str...)
+#endif
+
+/*--------------------------------------------------------------------*/
+/* SPI Controller driver local functions*/
+
+/* nxspi_hw_reset - To reset the SPI unit
+ * @nxspi : pointer to nx_spi data structure
+ * Resets the SPI unit.
+ * Called during initialization & de-init of SPI unit
+ */
+static void nxspi_hw_reset(struct nx_spi *nxspi)
+{
+    int val;
+
+    nx_spi_writel(nxspi->regs + NX_SPI_CONFIG_OFFSET,
+                    NX_SPI_SOFTWARE_RESET_MSK);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_HARDWARE_INFO_OFFSET);
+    if ( (val & NX_SPI_EN_ENHANCED_MASTER_MODE_MSK) != 0 ){
+        nxspi->enhanced_ip = 1;
+
+        val = nx_spi_readl(nxspi->regs + NX_SPI_CONFIG_OFFSET);
+        val |= NX_SPI_RESET_QUEUE_MSK;
+        nx_spi_writel(nxspi->regs + NX_SPI_CONFIG_OFFSET, val);
+    }
+}
+
+/* nxspi_enabledisable - To enable/disable the SPI unit
+ * @nxspi : pointer to nx_spi data structure
+ * Enablesthe SPI unit.
+ * Called during setting up a transfer on the SPI unit
+ */
+static void nxspi_enabledisable(struct nx_spi *nxspi, u8 enable)
+{
+    u32 val;
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_CONFIG_OFFSET);
+    if ( enable )
+    {
+#ifdef CONFIG_SPI_NX_DMAC_1902
+        nx_spi_writel(nxspi->regs + NX_SPI_DMA_SETTING_OFFSET,3);
+#endif    
+        nx_spi_writel(nxspi->regs + NX_SPI_CONFIG_OFFSET, val | NX_SPI_SPI_ENABLE_MSK); //enable
+    }
+    else
+    {
+#ifdef CONFIG_SPI_NX_DMAC_1902
+        nx_spi_writel(nxspi->regs + NX_SPI_DMA_SETTING_OFFSET,0);
+#endif        
+        nx_spi_writel(nxspi->regs + NX_SPI_CONFIG_OFFSET, val & ~(NX_SPI_SPI_ENABLE_MSK)); //disable
+    }
+    
+}
+
+
+/* nxspi_cs_set - To enable/disable SPI slave device
+ * @nxspi : pointer to nx_spi data structure
+ * @spi : pointer to required spi device
+ * @enable : 1- Enable, 0 - Disable
+ * This function shall enable or disbale the SPI slave by programming
+ * the SLAVE_ENABLE register (for Normalmode ip config ) or by programming
+ * CSx_SETTINGS register (for enhance_mode ip config)
+ *
+ */
+static void nxspi_cs_set(struct nx_spi *nxspi,
+                            struct spi_device *spi, u8 enable)
+{
+    u32 val;
+    u8 slv = spi->chip_select;
+
+    if(nxspi->enhanced_ip){
+      if(!enable){
+       val = 0;
+       nx_spi_writel(nxspi->regs + \
+                        NX_SPI_CHIPSELECTx_SETTING_OFFSET(slv), val);
+      }
+      else{
+       val = 1 << slv ;
+       /* set CSx_Settings register*/
+       nx_spi_writel(nxspi->regs + NX_SPI_CHIPSELECTx_SETTING_OFFSET(slv), val);
+       /* program the chip select polarity and default value */
+       if(!(spi->mode & SPI_3WIRE)) /* SSI format*/
+         nx_spi_writel(nxspi->regs + NX_SPI_CS_POLARITY_OFFSET, val);
+       if(spi->mode & SPI_3WIRE) /* Microwire format*/
+        nx_spi_writel(nxspi->regs + NX_SPI_CS_DEFAULT_VAL_OFFSET, val);
+      }
+    }
+    else{/* NORMAL IP configuration*/
+        if(!enable)
+          val = 0;
+        else{
+        /* set value 01 (2bits) for the corresponding slave*/
+          val = 1 << (slv << 1) ;
+        }
+        nx_spi_writel(nxspi->regs + NX_SPI_SLAVE_ENABLE_OFFSET, val);
+    }
+
+}
+
+/* nxspi_pgm_speed - To program the speed for the SPI unit
+ * @nxspi : pointer to nx_spi data structure
+ * @speedhz : This is either device default speed or transfer based speed in HZ.
+ * Programs the clkdivisor1 & clkdivisor2 of SLVx_Settings register
+ * Called during setting up a transfer on the SPI unit
+ */
+static void nxspi_pgm_speed(struct nx_spi *nxspi,
+                int slv, u32 speedhz)
+{
+    /* Calculate the required division factor */
+    u32 divfactor=0;
+    u8  prescaleval=0;   /* 2..254, even numbers */
+    u8  serialclkrate=0; /* 0..255 (for 1..256) */
+    u32 val;
+    struct nx_spi_controller_data* driverdata = nxspi->ctrldata;
+    u32 ipclk = driverdata->spi_ip_clk;
+    divfactor = ((ipclk) + (speedhz/2)) / speedhz;
+
+    /* Limit the division factor */
+    if(divfactor > MAX_DIVISION_FACTOR)
+    {
+        divfactor = MAX_DIVISION_FACTOR;
+    }
+    if(divfactor < MIN_DIVISION_FACTOR)
+    {
+        divfactor = MIN_DIVISION_FACTOR;
+    }
+
+    /* Calculate the values for prescaler (2..254) and serial clockrate (0..255) */
+    prescaleval   = (u8)(((divfactor-1)/512) + 1 ) * 2; /* Always even ! */
+
+    serialclkrate = (u8)((divfactor + prescaleval/2)/prescaleval);
+    if(serialclkrate >= 1)
+    {
+        serialclkrate -=1;
+    }
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_SLAVEx_SETTING1_OFFSET(slv));
+
+    if(prescaleval>=2 && prescaleval <=254)
+    	val |= (prescaleval << NX_SPI_CLK_DIVISOR2_POS);
+    else
+    	val |= (2 << NX_SPI_CLK_DIVISOR2_POS);
+ 
+    if(serialclkrate >= 0 && serialclkrate <=255)
+       val |= serialclkrate;
+    else
+	val &= 0xFFFFFF00;
+
+    nx_spi_writel(nxspi->regs + NX_SPI_SLAVEx_SETTING1_OFFSET(slv),val);
+
+}
+
+/* nxspi_hw_setup - To program the registers of the SPI unit
+ * @nxspi : pointer to nx_spi data structure
+ * Programs the SLVx_Settings(1)&(2) registers, SPI_CONFIG reg,
+ * Interrupt reg, & Enables the SPI unit.
+ * Called during setting up a transfer on the SPI unit
+ */
+static void nxspi_hw_setup(struct nx_spi *nxspi)
+{
+    u32 val;
+    struct spi_device *spi = nxspi->active_spidev;
+    int spislave = spi->chip_select;
+    struct nx_spi_controller_data* driverdata = nxspi->ctrldata;
+    u8 txint_th = driverdata->tx_int_threshold;
+    u8 rxint_th = driverdata->rx_int_threshold;
+    u32 speedhz;
+
+    /* set slave settings(1) register*/
+    speedhz = (nxspi->current_transfer->speed_hz == 0)? \
+                spi->max_speed_hz : nxspi->current_transfer->speed_hz;
+
+    nxspi_pgm_speed(nxspi, spislave, speedhz);
+
+    /* set slave settings(2) register*/
+	val = 0;
+    if (spi->mode & SPI_CPHA)
+        val = NX_SPI_CLK_PHASE_MSK;
+
+    if (spi->mode & SPI_CPOL)
+        val |= NX_SPI_CLK_POLARITY_MSK;
+
+    /*  3wire -> SPIMicrowire */
+    if (!(spi->mode & SPI_3WIRE))
+        val |= NX_SPI_XFER_FORMAT_MSK;
+
+    if(spi->mode & SPI_CS_HIGH)
+        val |= NX_SPI_CHIP_SEL_VAL_MSK;
+    if(spi->mode & SPI_LSB_FIRST)
+        val |= NX_SPI_LSB_FIRST_ENABLE_MSK;
+
+    val |= 1 << NX_SPI_PROG_DELAY_POS;
+
+    if (!nxspi->current_transfer->bits_per_word){
+        val |= ((spi->bits_per_word - 1) & 0x1f); //fetch settings from device
+        nxspi->current_transfer->bits_per_word = spi->bits_per_word;
+    	}
+    else
+        val |= ((nxspi->current_transfer->bits_per_word - 1) & 0x1f);
+
+    nx_spi_writel(nxspi->regs + NX_SPI_SLAVEx_SETTING2_OFFSET(spislave),val);
+
+    if (nxspi->enhanced_ip){
+        /* form the control word*/
+        nxspi->control_word = (spislave << NX_SPI_CONTROL_WORD_TXPARAM_PTR_POS) |
+                             (spislave << NX_SPI_CONTROL_WORD_CHIPSELECT_POS) |
+                             (nxspi->current_transfer->len);
+        /* 1 transfer set*/
+        nx_spi_writel(nxspi->regs + NX_SPI_NUM_TXFERS_CMD_OFFSET, 1);
+    }
+ 
+    /* Enable the Slave*/
+    nxspi_cs_set(nxspi, spi, 1);
+
+    /* set  config reg*/
+    val = nx_spi_readl(nxspi->regs + NX_SPI_CONFIG_OFFSET);
+
+    if (spi->mode & SPI_LOOP)
+        val |= NX_SPI_LOOPBACK_MODE_MSK;
+
+    val |= NX_SPI_UPDATE_SLAVE_ENABLE_MSK;
+	val |= NX_SPI_SLAVE_DISABLE_MSK;
+    nx_spi_writel(nxspi->regs + NX_SPI_CONFIG_OFFSET, val);
+
+#ifdef CONFIG_SPI_NX_DEBUG
+    val = nx_spi_readl(nxspi->regs + NX_SPI_CONFIG_OFFSET);
+    dbg_print("Value in Config register= 0x%x\n",val);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_SLAVEx_SETTING2_OFFSET(spislave));
+    dbg_print("Value in SLV2 register= 0x%x\n",val);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_SLAVEx_SETTING1_OFFSET(spislave));
+    dbg_print("Value in SLV1 register= 0x%x\n",val);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_SLAVE_ENABLE_OFFSET);
+    dbg_print("Value in SLV_EN register= 0x%x\n",val);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_HARDWARE_INFO_OFFSET);
+    dbg_print("Value in HW info register= 0x%x\n",val);
+
+    val = nx_spi_readl(nxspi->regs + NX_SPI_HARDWARE_INFO2_OFFSET);
+    dbg_print("Value in HW info2 register= 0x%x\n",val);
+#endif
+    /* enable both TX & RX*/
+    /* Prgm Interrupt threshold*/
+    val = (txint_th << 8) | rxint_th;
+    nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_THRESHOLD_OFFSET,val);
+
+}
+
+/* nxspi_xfer_is_last - To check is last transfer in the msg
+ * @nxspi : pointer to nx_spi data structure
+ * @spi : pointer to required spi device
+ * @enable : 1- Enable, 0 - Disable
+ * This function shall enable or disbale the SPI slave by programming
+ * the SLAVE_ENABLE register (for Normalmode ip config ) or by programming
+ * CSx_SETTINGS register (for enhance_mode ip config)
+ */
+ static inline int nxspi_xfer_is_last(struct spi_message *msg,
+                    struct spi_transfer *xfer)
+{
+    return msg->transfers.prev == &xfer->transfer_list;
+}
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+/* nxspi_prep_sg - To prepare scattergather for DMA transfer
+ * sg_tx - Pointer to scatterlist for tx
+ * sg_rx - Pointer to scatterlist for rx
+ * @nxspi : pointer to nx_spi data structure
+ * This function prepares a scatter-gather list for
+ * DMA transfer depending on number of entries "nents"
+ * required. Nents =2 if enhanced mode, 1 otherwise
+ */
+static int nxspi_prep_sg(struct scatterlist **sg_tx,
+                            struct scatterlist **sg_rx,
+                            struct nx_spi *nxspi)
+{
+    int nents = 1;
+    int index=0;
+    struct spi_transfer *xfer = nxspi->current_transfer;
+
+    if ( nxspi->enhanced_ip )
+        nents = 2;
+
+    *sg_tx = kcalloc(nents, sizeof(struct scatterlist),GFP_KERNEL);
+    if(!(*sg_tx))
+        return -ENOMEM;
+    *sg_rx = kcalloc(nents, sizeof(struct scatterlist),GFP_KERNEL);
+    if(!(*sg_rx))
+        return -ENOMEM;
+
+    sg_init_table(*sg_tx, nents);
+    sg_init_table(*sg_rx, nents);
+
+    if ( nxspi->enhanced_ip) {
+        sg_set_buf(&(*sg_tx)[index], &nxspi->control_word, sizeof(nxspi->control_word));
+        sg_set_buf(&(*sg_rx)[index], &nxspi->control_word, sizeof(nxspi->control_word));
+        index++;
+    }
+    
+    /* use scratch buffer in case */
+    if ( xfer->tx_buf == NULL ){
+        xfer->tx_buf = nxspi->buffer;
+        memzero(nxspi->buffer, xfer->len);
+        sg_set_buf(&(*sg_tx)[index], xfer->tx_buf, (xfer->len));
+        sg_set_buf(&(*sg_rx)[index], xfer->rx_buf, (xfer->len));
+    }
+    else if (xfer->rx_buf == NULL){
+        xfer->rx_buf = nxspi->buffer;
+        memzero(nxspi->buffer, xfer->len);
+        sg_set_buf(&(*sg_tx)[index], xfer->tx_buf, (xfer->len));
+        sg_set_buf(&(*sg_rx)[index], xfer->rx_buf, (xfer->len));        
+    }
+    else
+    {
+        sg_set_buf(&(*sg_tx)[index], xfer->tx_buf, (xfer->len));
+        sg_set_buf(&(*sg_rx)[index], xfer->rx_buf, (xfer->len));
+    }
+
+    return 0;
+}
+
+/* nxspi_getwidth - To get FIFO width for DMA transfer
+ * @val - 8,16,32 bits
+ * This function returns enumeration based on the FIFO width
+ */
+static enum dma_slave_width nxspi_getwidth(u32 val)
+{
+    if (val <= 8)
+        return DMA_SLAVE_WIDTH_8BIT;
+    else if (val <= 16)
+        return DMA_SLAVE_WIDTH_16BIT;
+    else
+        return DMA_SLAVE_WIDTH_32BIT;
+}
+
+/* nxspi_dma_txeventcallback -  To process event callback from DMA for TX
+ * @client : pointer to dma_client
+ * @chan : pointer to dma_chan
+ * @state : status of DMA channel
+ * This function is registered during client channel allocation and
+ * invoked by the DMAC driver to indicate the status of allocation of
+ * channel for SPI TX peripheral
+ */
+static enum dma_state_client
+nxspi_dma_txeventcallback(
+        struct dma_client *client,
+        struct dma_chan *chan,
+        enum dma_state state)
+{
+    enum dma_state_client status;
+    unsigned long flags;
+    struct nx_spi *nxspi =
+        container_of(client, struct nx_spi, client_tx);
+
+    spin_lock_irqsave(&nxspi->lock, flags);
+    status = DMA_NAK;
+    /* Only ACK if the channel num is the desired one*/
+	if ( state == DMA_RESOURCE_AVAILABLE )
+	{
+		if ( nxspi->ctrldata->txchan_num == chan->chan_id ){
+			if (nxspi->chantx_alloted != true){
+	        status = DMA_ACK;
+			nxspi->chantx_alloted = true;
+	        nxspi->dmachan_tx = chan;
+			}
+		}
+	}
+
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+
+    /* wakeup*/
+    wake_up(&(nxspi->waitq));
+    return status;
+
+}
+
+/* nxspi_dma_txeventcallback -  To process event callback from DMA for RX
+ * @client : pointer to dma_client
+ * @chan : pointer to dma_chan
+ * @state : status of DMA channel
+ * This function is registered during client channel allocation and
+ * invoked by the DMAC driver to indicate the status of allocation of
+ * channel for SPI RX peripheral
+ */
+static enum dma_state_client
+nxspi_dma_rxeventcallback(
+        struct dma_client *client,
+        struct dma_chan *chan,
+        enum dma_state state)
+{
+    enum dma_state_client status;
+    unsigned long flags;
+    struct nx_spi *nxspi =
+        container_of(client, struct nx_spi, client_rx);
+
+    spin_lock_irqsave(&nxspi->lock, flags);
+    /* Only ACK if the channel num is the desired one*/
+    status = DMA_NAK;
+    /* Only ACK if the channel num is the desired one*/
+	if ( state == DMA_RESOURCE_AVAILABLE )
+	{
+		if ( nxspi->ctrldata->rxchan_num == chan->chan_id ){
+			if (nxspi->chanrx_alloted != true){
+	        status = DMA_ACK;
+			nxspi->chanrx_alloted = true;
+	        nxspi->dmachan_rx = chan;
+			}
+		}
+	}
+
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+    /* wakeup*/
+    wake_up(&(nxspi->waitq));
+    return status;
+}
+
+/* nxspi_dma_txcallback -  To process transfer callback from DMA for TX
+ * @dma_async_param : pointer to nx_spi
+ * This function is registered during channel transfer submit to DMA and
+ * invoked by the DMAC driver to indicate the status of transfer
+ * for SPI TX peripheral. This function then schedules work queue to
+ * process the status of transfer
+ */
+static void nxspi_dma_txcallback(void *dma_async_param)
+{
+    struct nx_spi *nxspi = (struct nx_spi *)dma_async_param;
+    enum dma_status status;
+    struct dma_device *dmadev = nxspi->dmachan_tx->device;
+
+    /* Check if any error status*/
+    status = dma_async_is_tx_complete(nxspi->dmachan_tx, 0, 0,0);
+    if (status == DMA_ERROR){
+     /* go to msg done*/
+     nxspi->action = nx_spi_msg_done;
+     /* stop or discard RX  */
+     dmadev->device_terminate_all(nxspi->dmachan_rx);
+    /*schedule the work queue*/
+    queue_work(nx_spi_wq, &nxspi->work);
+    }
+}
+
+/* nxspi_dma_txcallback -  To process transfer callback from DMA for RX
+ * @dma_async_param : pointer to nx_spi
+ * This function is registered during channel transfer submit to DMA and
+ * invoked by the DMAC driver to indicate the status of transfer
+ * for SPI RX peripheral. This function then schedules work queue to
+ * process the status of transfer
+ */
+static void nxspi_dma_rxcallback(void *dma_async_param)
+{
+    struct nx_spi *nxspi = (struct nx_spi *)dma_async_param;
+    enum dma_status status;
+    struct spi_message *msg;
+
+    msg = list_entry(nxspi->queue.next, struct spi_message, queue );
+    /* Check if any error status*/
+    status = dma_async_is_tx_complete(nxspi->dmachan_tx, 0, 0,0);
+    if (status == DMA_ERROR){
+        nxspi->action = nx_spi_msg_done;
+    }
+    else if (status == DMA_SUCCESS){
+        if (nxspi_xfer_is_last(msg, nxspi->current_transfer))
+        nxspi->action = nx_spi_msg_done;
+        else
+        nxspi->action = nx_spi_next_xfer;
+
+    }
+    /*schedule the work queue*/
+    queue_work(nx_spi_wq, &nxspi->work);
+}
+
+
+
+/* nxspi_dmasetup - To program the DMA registers
+ * @nxspi : pointer to nx_spi data structure
+ * @xfer : pointer to current transfer
+ * Programs DMA register. Setup & start DMA transfer
+ * by interfacing with DMAC Framework
+ * Called during setting up a transfer on the SPI unit
+ */
+static void nxspi_dmasetup(struct nx_spi *nxspi,
+                            struct spi_transfer *xfer)
+{
+    u32 val;
+    int ret=0;
+    struct scatterlist *sg_rx=0, *sg_tx=0;
+    struct dma_async_tx_descriptor *txdesc,*rxdesc;
+    struct nx_spi_controller_data* driverdata = nxspi->ctrldata;
+    u8 txdma_burst = driverdata->dma_tx_burst;
+    u8 rxdma_burst = driverdata->dma_rx_burst;
+    struct  dma_device *dmadev;
+    unsigned long flags;
+    int nents = (nxspi->enhanced_ip)? 2 : 1;
+    struct resource *regs;
+
+    /* Setup DMA burst registers */
+    /* check if full duplex or half duplex*/
+    if ( (xfer->tx_buf) && (xfer->rx_buf == NULL) ){
+    val = txdma_burst << NX_SPI_TX_DMA_BURST_POS;
+    val |= NX_SPI_TX_DMA_ENABLE_MSK;
+    }
+    else if( (xfer->rx_buf) && (xfer->tx_buf == NULL) ){
+    val = rxdma_burst << NX_SPI_RX_DMA_BURST_POS;
+    val |= NX_SPI_RX_DMA_ENABLE_MSK;
+    }
+    else{
+    val = (txdma_burst << NX_SPI_TX_DMA_BURST_POS) | (rxdma_burst << NX_SPI_RX_DMA_BURST_POS);
+    val |= (NX_SPI_TX_DMA_ENABLE_MSK | NX_SPI_RX_DMA_ENABLE_MSK);
+    }
+    spin_lock_irqsave(&nxspi->lock, flags);
+    /* Interface with DMA framework to setup DMA transfer*/
+    regs = platform_get_resource ( nxspi->pdev, IORESOURCE_MEM, 0);
+
+    nxspi->client_tx.slave->tx_reg =  (u32)(NX_SPI_FIFO_DATA_OFFSET);//FIFO_DATA offset
+    nxspi->client_rx.slave->rx_reg =  (u32)(NX_SPI_FIFO_DATA_OFFSET);//FIFO_DATA offset
+    val = nx_spi_readl(nxspi->regs + NX_SPI_HARDWARE_INFO_OFFSET);
+
+    nxspi->client_tx.slave->reg_width =
+            nxspi_getwidth((val & NX_SPI_TX_FIFO_WIDTH_MSK) >> NX_SPI_TX_FIFO_WIDTH_POS);
+    nxspi->client_rx.slave->reg_width =
+            nxspi_getwidth((val & NX_SPI_RX_FIFO_WIDTH_MSK) >> NX_SPI_RX_FIFO_WIDTH_POS);
+
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+
+    if(!nxspi->chantx_alloted)
+    {
+        dma_async_client_chan_request(&nxspi->client_tx);
+        /* wait with timeout of 500ms*/
+        wait_event_timeout(nxspi->waitq,
+            (nxspi->chantx_alloted == true),
+            (500*HZ)/1000);
+
+        if ( nxspi->chantx_alloted != true ){
+           dbg_print("SPI transfer timeout on DMA %d\n\n\n",nxspi->pdev->id);
+        /* handle error*/
+        return;
+        }
+    }
+
+    if(!nxspi->chanrx_alloted)
+    {
+        dma_async_client_chan_request(&nxspi->client_rx);
+
+        /* wait with timeout of 500ms*/
+        wait_event_timeout(nxspi->waitq,
+            (nxspi->chanrx_alloted == true),
+            (500*HZ)/1000);
+
+        if ( nxspi->chantx_alloted != true ){
+           dbg_print("SPI transfer timeout on DMA %d\n\n\n",nxspi->pdev->id);
+            /* handle error*/
+            return;
+        }
+    }
+    
+    /* Now prepare sg for both TX & RX*/
+    ret = nxspi_prep_sg(&sg_tx, &sg_rx,nxspi);
+    if (ret < 0 ){
+        dev_err(&nxspi->active_spidev->dev, "Mem Alloc error\n");
+    }
+
+    dmadev = nxspi->dmachan_tx->device;
+    txdesc = dmadev->device_prep_slave_sg(nxspi->dmachan_tx, sg_tx,
+                        nents, DMA_TO_DEVICE,(DMA_PREP_INTERRUPT|DMA_CTRL_ACK));
+    rxdesc = dmadev->device_prep_slave_sg(nxspi->dmachan_rx, sg_rx,
+                        nents, DMA_FROM_DEVICE,(DMA_PREP_INTERRUPT|DMA_CTRL_ACK));
+
+    txdesc->callback = nxspi_dma_txcallback;
+    txdesc->callback_param = nxspi;
+    rxdesc->callback = nxspi_dma_rxcallback;
+    rxdesc->callback_param = nxspi;
+
+    /* submit for transfer.
+    First RX and then TX*/
+    rxdesc->tx_submit(rxdesc);
+    txdesc->tx_submit(txdesc);
+
+    /* Now wait for DMA transfer callback to be invoked*/
+	do{
+	val = dma_async_is_tx_complete(nxspi->dmachan_tx, 0, NULL, NULL);
+	}while(val != DMA_SUCCESS );
+	do{
+	val = dma_async_is_tx_complete(nxspi->dmachan_rx, 0, NULL, NULL);
+	}while(val != DMA_SUCCESS );
+
+	nxspi_dma_txcallback(nxspi);
+	nxspi_dma_rxcallback(nxspi);
+}
+
+
+#endif
+/* nxspi_hw_datawrite - To write data into FIFO
+ * @nxspi : pointer to nx_spi data structure
+ * @xfer : pointer to current transfer
+ * This function shall write the data to the TX_FIFO
+ * The transfer is in terms of word.
+ * Returns num of bytes written
+ * Called from the work queue when TX interrupt has occured
+ */
+static int nxspi_hw_datawrite(struct nx_spi *nxspi,
+            struct spi_transfer *xfer)
+{
+    u32 status;
+    u32 datacount=0;
+    u32 remaining_bytes = nxspi->curr_remaining_bytes;
+    u32 pos = (xfer->len - nxspi->curr_remaining_bytes);
+
+    /* Read the status Register */
+    status = nx_spi_readl(nxspi->regs + NX_SPI_STATUS_OFFSET);
+
+    while(((status & NX_SPI_TX_FIFO_FULL_MSK) == 0) &&
+            (datacount < remaining_bytes))
+    {
+        if((nxspi->enhanced_ip) && !(nxspi->control_word_done)){
+            /*first transfer control word*/
+        nx_spi_writel(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET,
+                        nxspi->control_word);
+        nxspi->control_word_done = 1;
+        continue;
+        }
+		switch(nxspi->current_transfer->bits_per_word)
+		{
+		case 32: nx_spi_writel(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET,
+                         ((u32*) xfer->tx_buf)[pos++]);
+		         datacount += 4;
+				 break;
+		case 16: nx_spi_writel(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET,
+                         ((u16*) xfer->tx_buf)[pos++]);
+		         datacount += 2;
+				 break;
+		case 8:
+		default: nx_spi_writel(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET,
+                         ((u8*) xfer->tx_buf)[pos++]);
+		         datacount++;
+				 break;
+		}
+        status = nx_spi_readl(nxspi->regs + NX_SPI_STATUS_OFFSET);
+    }
+
+    /* return num of bytes transmitted*/
+    return (datacount);
+}
+
+/* nxspi_hw_dataread - To read data from FIFO
+ * @nxspi : pointer to nx_spi data structure
+ * @xfer : pointer to current transfer
+ * This function shall read the data from the RX_FIFO
+ * The transfer is in terms of word.
+ * Returns num of bytes read
+ * Called from the work queue when RX interrupt has occured
+ */
+static int nxspi_hw_dataread(struct nx_spi *nxspi,
+            struct spi_transfer *xfer)
+{
+    u32 status;
+    u32 datacount=0;
+    u32 remaining_bytes = nxspi->curr_remaining_bytes;
+    u32 pos = (xfer->len - nxspi->curr_remaining_bytes);
+
+    /* Read the status Register */
+    status = nx_spi_readl(nxspi->regs + NX_SPI_STATUS_OFFSET);
+
+    while(((status & NX_SPI_RX_FIFO_EMPTY_MSK) == 0) &&
+            (datacount < remaining_bytes))
+    {
+        if((nxspi->enhanced_ip) && !(nxspi->control_word_done)){
+            /*first transfer control word*/
+        nxspi->control_word = nx_spi_readl(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET);
+        nxspi->control_word_done = 1;
+        continue;
+        }
+		switch(nxspi->current_transfer->bits_per_word)
+		{
+		case 32:((u32*)xfer->rx_buf)[pos++] =
+						 nx_spi_readl(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET);
+		         datacount += 4;
+				 break;
+		case 16: ((u16*)xfer->rx_buf)[pos++] =
+						 nx_spi_readl(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET);
+		         datacount += 2;
+				 break;
+		case 8:
+		default: ((u8*)xfer->rx_buf)[pos++] =
+						 nx_spi_readl(nxspi->regs + NX_SPI_FIFO_DATA_OFFSET);
+		         datacount++;
+				 break;
+		}
+        status = nx_spi_readl(nxspi->regs + NX_SPI_STATUS_OFFSET);
+    }
+
+    /* return num of bytes read*/
+    return (datacount);
+}
+
+
+/* nxspi_unqueue_xfer -  To get the next transfer from msg list
+ * @master : pointer to spi_master
+ * @nxspi : pointer to nx_spi data structure
+ * @msg : pointer to spi_message
+ * This function unqueue's the next transfer from msglist and initializes the
+ * SPI unit for transfer. DMA is initialized if DMA configuration is chosen
+ * Either called from workqueue or from spi transfer API.
+ */
+static void nxspi_unqueue_xfer(
+    struct spi_master *master,
+    struct nx_spi *nxspi,
+    struct spi_message *msg)
+{
+    struct spi_transfer *xfer;
+    unsigned long flags;
+
+    spin_lock_irqsave(&nxspi->lock, flags);
+
+    /* check if this is the first xfer from the message list*/
+    if(!nxspi->current_transfer)
+        xfer = list_entry(msg->transfers.next,
+                struct spi_transfer,transfer_list);
+    else
+        xfer = list_entry(nxspi->current_transfer->transfer_list.next,
+                struct spi_transfer,transfer_list);
+
+    nxspi->current_transfer = xfer;
+    nxspi->curr_remaining_bytes =xfer->len;
+    nxspi->control_word_done = 0;
+
+    /* Setup the config, slavesettings registers now*/
+    /* make sure the SPI unit is disabled before touching the
+    settings. The hwsetup is performed only once for a new message
+    & not for new transfers of the same message */
+if(nxspi->flag_newmsg == true){
+    nxspi_enabledisable(nxspi, 0);
+    nxspi_hw_setup(nxspi);
+	nxspi->flag_newmsg=false;
+}
+
+#ifndef CONFIG_SPI_NX_DMAC_1902
+    /* free any previous scratchbuffer*/
+    if (nxspi->scratchbuffer != NULL)
+        kfree(nxspi->scratchbuffer);
+
+    if (xfer->rx_buf == NULL){
+	    nxspi->scratchbuffer = (u32*)kmalloc(xfer->len, GFP_KERNEL);
+        if(!nxspi->scratchbuffer){
+            dev_err(&nxspi->active_spidev->dev, "Mem Alloc error\n");
+            return;
+        }
+
+        xfer->rx_buf = nxspi->scratchbuffer;
+    }
+    else if (xfer->tx_buf == NULL){
+        nxspi->scratchbuffer = (u32*)kmalloc(xfer->len, GFP_KERNEL);
+        if(!nxspi->scratchbuffer){
+            dev_err(&nxspi->active_spidev->dev, "Mem Alloc error\n");
+            return;
+        }
+
+        xfer->tx_buf = nxspi->scratchbuffer;
+    }
+    if ( nxspi->scratchbuffer )
+        memset(nxspi->scratchbuffer, 0, xfer->len);
+#endif
+    /*Non-DMA Wait for interrupt.
+    transfer happens in the interrupt*/
+
+#ifndef CONFIG_SPI_NX_DMAC_1902
+   nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_SET_ENABLE_OFFSET, INT_EN_MSK);
+#endif
+    nxspi_enabledisable(nxspi,1);
+	spin_unlock_irqrestore(&nxspi->lock, flags);
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    /*Get channel and submit transfer here */
+    /* setup dma hw regs*/
+    nxspi_dmasetup(nxspi, xfer);
+#endif
+
+}
+
+/* nxspi_process_message -  To get the next message from msg list
+ * @master : pointer to spi_master
+ * @nxspi : pointer to nx_spi data structure
+ * This function gets the next message for processing.
+ */
+static void nxspi_process_message(
+    struct spi_master *master,
+    struct nx_spi *nxspi)
+{
+
+    struct spi_message *msg;
+    unsigned long flags;
+
+    spin_lock_irqsave(&nxspi->lock, flags);
+    msg = list_entry(nxspi->queue.next, struct spi_message, queue);
+
+    dev_dbg(master->dev.parent, "start message %p for %d\n",
+            msg, nxspi->pdev->id);
+
+    /* enable the device on the spiunit*/
+    if(nxspi->active_spidev){
+    if( nxspi->active_spidev != msg->spi){
+        nxspi_cs_set(nxspi,nxspi->active_spidev,0);
+    }
+    }
+    nxspi_cs_set(nxspi,msg->spi,1);
+    nxspi->active_spidev = msg->spi;
+	nxspi->flag_newmsg = true;
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+
+    nxspi_unqueue_xfer(master,nxspi,msg);
+
+}
+
+/* nxspi_work -  To take action based on the transfer status
+ * @work : pointer to work_struct in nx_spi
+ * Based on the transfer status, either processes next transfer in message list
+ * or takes the next message. Informs about message complete to SPI
+ * framework incase of error / message done. Disables the SPI unit.
+ * Scheduled from interrut routine or DMA processing
+ */
+static void nxspi_work(struct work_struct *work)
+{
+     struct nx_spi *nxspi = container_of(work, struct nx_spi, work);
+     struct spi_transfer *xfer = nxspi->current_transfer;
+     struct spi_message *msg;
+     struct spi_master *master = platform_get_drvdata(nxspi->pdev);
+     unsigned long flags;
+
+     spin_lock_irqsave(&nxspi->lock, flags);
+     msg = list_entry(nxspi->queue.next,struct spi_message,queue);
+
+     if(xfer->delay_usecs)
+        udelay(xfer->delay_usecs);
+
+     if (nxspi->action == nx_spi_next_xfer) {
+        /*before unqeueing the next tranfer,
+        put delay if required & disable slave bit if required*/
+        udelay(xfer->delay_usecs);
+        if(xfer->cs_change)
+            nxspi_cs_set(nxspi,msg->spi,0);
+        spin_unlock_irqrestore(&nxspi->lock, flags);
+        nxspi_unqueue_xfer(master,nxspi, msg);
+        return;
+     }
+
+     else{ /*either it is error or msg done*/
+        if ( nxspi->action == nx_spi_msg_done ){
+            dev_dbg(master->dev.parent,"Transfer complete: %u words transferred\n",
+            msg->actual_length);
+            msg->status = 0;
+        }
+        else if (nxspi->action == nx_spi_err_overrun) {
+            dev_dbg(master->dev.parent,"Overrun Error in tranfer: %u words transferred\n",
+            msg->actual_length);
+            msg->status = -EOVERFLOW;
+        }
+        else{
+            dev_dbg(master->dev.parent,"Timeout Error in tranfer: %u words transferred\n",
+            msg->actual_length);
+            /* Transfer is completed*/
+            if (nxspi_xfer_is_last(msg, xfer))
+                msg->status = 0;
+            else{
+                /*before unqeueing the next tranfer,
+                put delay if required & disable slave bit if required*/
+                udelay(xfer->delay_usecs);
+                if(xfer->cs_change)
+                    nxspi_cs_set(nxspi,msg->spi,0);
+                spin_unlock_irqrestore(&nxspi->lock, flags);
+                nxspi_unqueue_xfer(master,nxspi, msg);
+                return;
+                }
+        }
+        nxspi_cs_set(nxspi,msg->spi,0);
+        spin_unlock_irqrestore(&nxspi->lock, flags);
+		msg->complete(msg->context);
+        spin_lock_irqsave(&nxspi->lock, flags);
+
+        list_del(&msg->queue);
+        nxspi->current_transfer = NULL;
+        nxspi->curr_remaining_bytes = 0;
+
+        /* Disable the SPI unit */
+		nxspi_enabledisable(nxspi, 0); //disable SPI unit
+
+        /* take next message from the queue*/
+        if (! (list_empty(&nxspi->queue) || (nxspi->closing)) ){
+            spin_unlock_irqrestore(&nxspi->lock, flags);
+            nxspi_process_message(master, nxspi);
+            return;
+        }
+     }
+     spin_unlock_irqrestore(&nxspi->lock, flags);
+}
+
+/*--------------------------------------------------------------------*/
+/* SPI Controller driver interface functions*/
+
+/* nx_spi_setup -  To setup the speed, mode for SPI device
+ * @spi : pointer to spi_device
+ * However, no settings are adapted here. The settings are
+ * programed into register only during transfer
+ */
+static int nx_spi_setup(struct spi_device *spi)
+{
+
+    struct nx_spi *nxspi = spi_master_get_devdata(spi->master);
+
+    if(nxspi->closing)
+        return -ESHUTDOWN;
+
+    /* NOTE: these settings take effect only when activating the
+    transfer . So, nothing shall be setup here.
+    When msg is unqueued, spi_device settings saved will be
+    progrmmed in the register*/
+
+    return 0;
+}
+
+/* nx_spi_interrupt -  To process the interrupt status
+ * @irq : interrupt line number
+ * @dev_id : pointer to spi_master
+ * Shall process the Trasnmit,Recieve related interrupt status.
+ * Shall perform data transfer and record the num of bytes transferred.
+ * Schedules the workqueue depending on the status of transfer/interrupt
+ */
+
+static irqreturn_t
+nx_spi_interrupt(int irq, void *dev_id)
+{
+    struct spi_master *master = dev_id;
+    struct nx_spi *nxspi = spi_master_get_devdata(master);
+    struct spi_message *msg;
+    u32 intstatus,val;
+    struct spi_transfer *xfer;
+    int datacount;
+
+    msg = list_entry(nxspi->queue.next,struct spi_message, queue);
+
+    intstatus = nx_spi_readl(nxspi->regs + NX_SPI_INTERRUPT_STATUS_OFFSET);
+    val = nx_spi_readl(nxspi->regs + NX_SPI_INTERRUPT_ENABLE_OFFSET);
+	intstatus &= val;
+	dbg_print( "interrupt status = %x & inten = %x\n",intstatus,val);
+
+    spin_lock(&nxspi->lock);
+    xfer = nxspi->current_transfer;
+
+    if (intstatus & NX_SPI_INT_TO_MSK)
+    {
+        nxspi->action = nx_spi_err_timeout;
+        /* Perhaps the Threshold value for RX was more than bytes to be received
+         So read from FIFO the data */
+        if(nxspi->curr_remaining_bytes){
+        /* read the remaining data*/
+        datacount = nxspi_hw_dataread(nxspi, xfer);
+        nxspi->curr_remaining_bytes -= datacount;
+        msg->actual_length += datacount;
+        }
+
+        /* disable  int*/
+        val = NX_SPI_INT_TO_MSK | NX_SPI_INT_RX_MSK;
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_ENABLE_OFFSET, val);
+
+        /* clear the status*/
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET,
+                        (NX_SPI_INT_TO_MSK|NX_SPI_INT_RX_MSK));
+        /*schedule the work queue*/
+        queue_work(nx_spi_wq, &nxspi->work);
+        spin_unlock(&nxspi->lock);
+
+        return IRQ_HANDLED;
+    }
+
+    if (intstatus & NX_SPI_INT_OV_MSK)
+    {
+        nxspi->action = nx_spi_err_overrun;
+
+        /* disable  int*/
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_ENABLE_OFFSET,
+                            NX_SPI_INT_OV_MSK);
+        /*clear the interrupt*/
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET,
+                        NX_SPI_INT_OV_MSK);
+            /*schedule the work queue*/
+        queue_work(nx_spi_wq, &nxspi->work);
+        spin_unlock(&nxspi->lock);
+        return IRQ_HANDLED;
+    }
+
+    if (intstatus & NX_SPI_INT_TX_MSK)
+    {
+        if(nxspi->curr_remaining_bytes){
+            /* transfer the remaining data*/
+            datacount = nxspi_hw_datawrite(nxspi, xfer);
+            nxspi->curr_remaining_bytes -= datacount;
+			if(nxspi->curr_remaining_bytes == 0) {
+                /*reset & process for RX*/
+                nxspi->curr_remaining_bytes = xfer->len;
+                nxspi->control_word_done = 0;
+                /* disable TX int*/
+                nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_ENABLE_OFFSET,
+                        NX_SPI_INT_TX_MSK);
+            }
+        }
+        /*clear the interrupt*/
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET,
+                        NX_SPI_INT_TX_MSK);
+
+    }
+
+    if (intstatus & NX_SPI_INT_RX_MSK)
+    {
+        if(nxspi->curr_remaining_bytes){
+            /* read the remaining data*/
+            datacount = nxspi_hw_dataread(nxspi, xfer);
+            nxspi->curr_remaining_bytes -= datacount;
+            msg->actual_length += datacount;
+            if(nxspi->curr_remaining_bytes == 0) {
+            /*reset */
+            nxspi->control_word_done = 0;
+
+            /* disable RX int*/
+            nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_ENABLE_OFFSET,
+                            NX_SPI_INT_RX_MSK);
+
+            /* Transfer is completed*/
+            if (nxspi_xfer_is_last(msg, xfer))
+                nxspi->action = nx_spi_msg_done;
+            else
+                nxspi->action = nx_spi_next_xfer;
+
+            /*schedule the work queue*/
+            queue_work(nx_spi_wq, &nxspi->work);
+            }
+
+        }
+        /* clear the interrupt*/
+        nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET,
+                        NX_SPI_INT_RX_MSK);
+    }
+
+    /* any other interrupt.. just clear*/
+    nx_spi_writel(nxspi->regs + NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET,
+                        ~(INT_EN_MSK) );
+    spin_unlock(&nxspi->lock);
+
+    return IRQ_HANDLED;
+}
+
+/* nx_spi_transfer -  To setup the transfer for SPI unit
+ * @spi : pointer to spi_device
+ * @msg : pointer to spi_message
+ * Messages are submitted for transfer and are queued into the
+ * SPI unit data structure nx_spi.
+ */
+static int nx_spi_transfer(struct spi_device *spi,
+                                struct spi_message *msg)
+{
+    struct nx_spi *nxspi;
+    struct spi_transfer *xfer;
+    unsigned long flags;
+
+    nxspi = spi_master_get_devdata(spi->master);
+    /* validate input msg*/
+    if (unlikely(list_empty(&msg->transfers)
+                 || !spi->max_speed_hz)){
+                 return -EINVAL;
+    	}
+
+    if ( nxspi->closing )
+            return -ESHUTDOWN;
+
+    list_for_each_entry(xfer,&msg->transfers,transfer_list){
+        if( !(xfer->rx_buf || xfer->tx_buf) && (xfer->len) ){
+            dev_dbg(&spi->dev, "missing rx or tx buf\n");
+            return -EINVAL;
+        }
+
+        /* NOTE### we dont check if bit_per_word,speed input as they can be set from
+        spi_device. Need not be from transfer. But take from transfer if
+        provided*/
+    }
+
+    dev_dbg(&spi->dev, "new message submitted for %s\n",
+                 spi->dev.bus_id);
+
+    msg->status = -EINPROGRESS;
+    msg->actual_length = 0;
+
+    spin_lock_irqsave(&nxspi->lock, flags);
+    list_add_tail(&msg->queue, &nxspi->queue);
+    /* Check if currently active transfer. Orelse process message*/
+    if (!nxspi->current_transfer){
+        spin_unlock_irqrestore(&nxspi->lock, flags);
+        nxspi_process_message(spi->master,nxspi);
+    }
+	else{
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+	}
+    return 0;
+}
+
+/* nx_spi_cleanup -  called on spi release() to free memory
+                        provided by spi_master
+ * @spi : pointer to spi_device
+ * This is called when the SPI Master release is invoked when the
+ * SPI unit resource is removed. Just disable the SPI slaves here
+ * Rest of the action can be taken when remove for SPI controller is
+ * invoked
+ */
+static void nx_spi_cleanup(struct spi_device *spi)
+{
+    struct nx_spi *nxspi = spi_master_get_devdata(spi->master);
+    unsigned long flags;
+
+    if (!spi->controller_state)
+        return;
+
+    /* disable the SPI slave device*/
+    spin_lock_irqsave(&nxspi->lock, flags);
+    if (nxspi->active_spidev == spi) {
+        nxspi_cs_set(nxspi, spi,0);
+        nxspi->active_spidev = NULL;
+    }
+
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+}
+
+/*---------------------------------------------------------------------*/
+/*Platform driver interface functions*/
+
+/* nx_spi_probe -  called by platform when the SPI Master is found on the bus.
+ * @pdev : pointer to platform_device for SPI
+ * This function shall allocate & register SPI master & initalize the data
+ * based on platform details. Shall register irq line. Shall intialize
+ * DMA client. Private data structure for SPI unit is initialized
+ */
+ #define SIZE_AARAY(x) (sizeof(x)/sizeof(x[0]))
+
+static int __init nx_spi_probe (struct platform_device *pdev)
+{
+    struct resource *regs;
+    int irq;
+    struct spi_master *master;
+    struct nx_spi *nxspi;
+    int status = -ENOMEM;
+    struct spi_board_info *spidevices;
+    struct  nx_spi_controller_data *ctrldata;
+    struct nx_spi_platform_data *plfdata;
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    struct nx_dmac_1902_slave *slave_rx, *slave_tx;
+#endif
+
+    /* Save the platform data pointer addresses
+    as pdev->dev gets overwritten by spi_master & nx_spi structures*/
+    ctrldata =  dev_get_drvdata(&pdev->dev);
+
+    plfdata = (struct nx_spi_platform_data*)pdev->dev.platform_data;
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    slave_rx = plfdata->slave_rx;
+    slave_tx = plfdata->slave_tx;
+#endif
+    spidevices = plfdata->spi_devices;
+
+    /* first register SPI slave devices*/
+    /*spi_register_board_info(spidevices, plfdata->plfdatasize); No Need to register for device 0 */
+
+    regs = platform_get_resource(pdev,IORESOURCE_MEM,0);
+    if(!regs){
+        kfree(ctrldata);
+        return -ENODEV;
+    }
+
+    irq = platform_get_irq(pdev,0);
+    if(irq < 0){
+        kfree(ctrldata);
+        return irq;
+    }
+
+    master = spi_alloc_master(&pdev->dev,sizeof(struct nx_spi));
+    if(!master)
+        goto err_free;
+
+    master->bus_num = pdev->id;
+    master->num_chipselect = NXP_SPI_NUM_CHIPSELECTS;
+    master->setup = nx_spi_setup;
+    master->transfer = nx_spi_transfer;
+    master->cleanup = nx_spi_cleanup;
+    platform_set_drvdata(pdev,master);
+
+    nxspi = spi_master_get_devdata(master);
+
+    nxspi->pdev = pdev;
+    nxspi->ctrldata = ctrldata;
+
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    /* Scratch buffer for DMA. To be used when rx/tx is unspecified
+    especially in half duplex transfers*/
+    nxspi->buffer = kzalloc(PAGE_SIZE, GFP_KERNEL);
+    if(!nxspi->buffer)
+        goto err_free;
+
+    init_waitqueue_head(&nxspi->waitq);
+	nxspi->chanrx_alloted = false;
+	nxspi->chanrx_alloted = false;
+    /* register SPI Controller driver as DMA client
+    with DMA Framework for both TX & RX lines*/
+
+    dma_cap_set(DMA_SLAVE,nxspi->client_tx.cap_mask);
+    dma_cap_set(DMA_SLAVE,nxspi->client_rx.cap_mask);
+    nxspi->client_tx.event_callback = nxspi_dma_txeventcallback;
+    nxspi->client_rx.event_callback = nxspi_dma_rxeventcallback;
+    /* Refer the DMA slave pointer */
+    nxspi->client_tx.slave = (struct dma_slave *)slave_tx;
+    nxspi->client_tx.slave->dev = &(nxspi->pdev->dev);
+    nxspi->client_rx.slave = (struct dma_slave *)slave_rx;;
+    nxspi->client_rx.slave->dev = &(nxspi->pdev->dev);
+
+
+    /* Register for TX peripheral line of SPI to DMAC*/
+    dma_async_client_register(&nxspi->client_tx);
+
+    /* Register for RX peripheral line of SPI to DMAC*/
+    dma_async_client_register(&nxspi->client_rx);
+
+#endif
+
+    spin_lock_init(&nxspi->lock);
+    INIT_LIST_HEAD(&nxspi->queue);
+    INIT_WORK(&nxspi->work, nxspi_work);
+
+    if (!request_mem_region(regs->start,
+                        (regs->end - regs->start) + 1,
+                        "SPI"))
+        goto err_freedma;
+
+    nxspi->regs = devm_ioremap(&pdev->dev, regs->start,
+                                 ((regs->end - regs->start) + 1) );
+    if(!nxspi->regs)
+        goto err_freeregion;
+
+    nxspi->irq = irq;
+    status = request_irq(irq, nx_spi_interrupt,
+                         IRQF_DISABLED,
+                        pdev->name, master);
+    if(status < 0)
+        goto err_unmap;
+
+    /* initialize this SPI unit*/
+    nxspi_hw_reset(nxspi);
+
+    status = spi_register_master(master);
+    if(status < 0)
+        goto err_freeirq;
+
+
+    /* before exit from function free the unwanted pointers
+    as their contents are saved with nxspi*/
+    return 0;
+
+/* Error handling portion of nx_spi_probe function*/
+err_freeirq:
+    free_irq(nxspi->irq,master);
+err_unmap:
+    devm_iounmap(&pdev->dev, nxspi->regs);
+err_freeregion:
+    release_mem_region(regs->start, (regs->end - regs->start) + 1);
+err_freedma:
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    dma_async_client_unregister(&nxspi->client_tx);
+    dma_async_client_unregister(&nxspi->client_rx);
+    dma_free_coherent(&pdev->dev,PAGE_SIZE, nxspi->buffer,
+            nxspi->dma_buffer);
+#endif
+err_free:
+    spi_master_put(master);
+    return status;
+}
+
+/* nx_spi_probe -  called by platform when the SPI Master is removed.
+ * @pdev : pointer to platform_device for SPI
+ * This function shall flush all ongoing transfers &
+ * shall remove all resources allocated.
+ */
+static int __exit nx_spi_remove(struct platform_device *pdev)
+{
+    struct spi_master *master = platform_get_drvdata(pdev);
+    struct nx_spi *nxspi = spi_master_get_devdata(master);
+    unsigned long flags;
+    struct spi_message *msg;
+    struct resource *r;
+
+    /* flush the workqueue;
+    Wait on all pending work on the given worker thread:*/
+    flush_workqueue(nx_spi_wq);
+
+    /* Reset hardware.*/
+    spin_lock_irqsave(&nxspi->lock, flags);
+    nxspi->closing = 1;
+    nxspi_hw_reset(nxspi);
+    spin_unlock_irqrestore(&nxspi->lock, flags);
+
+    /* Exit from the queued transfers*/
+    list_for_each_entry(msg, &nxspi->queue, queue) {
+        msg->status = -ESHUTDOWN;
+        msg->complete(msg->context);
+    }
+#ifdef CONFIG_SPI_NX_DMAC_1902
+    dma_free_coherent(&pdev->dev,PAGE_SIZE, nxspi->buffer,
+            nxspi->dma_buffer);
+    dma_sync_wait(nxspi->dmachan_tx,0);
+    dma_sync_wait(nxspi->dmachan_rx,0);
+    dma_async_client_unregister(&nxspi->client_tx);
+    dma_async_client_unregister(&nxspi->client_rx);
+	nxspi->chantx_alloted = false;
+	nxspi->chanrx_alloted = false;
+
+#endif
+    if (nxspi->scratchbuffer != NULL)
+        kfree(nxspi->scratchbuffer);
+
+    free_irq(nxspi->irq,master);
+    r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    release_mem_region(r->start, (r->end - r->start) + 1);
+    devm_iounmap(&pdev->dev, nxspi->regs);
+    kfree(nxspi->ctrldata);
+
+    spi_unregister_master(master);
+    return 0;
+}
+
+static int nx_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    struct spi_master *master = platform_get_drvdata(pdev);
+    struct nx_spi *nxspi = spi_master_get_devdata(master);
+	/* just call a disable of SPI device*/
+	nxspi_enabledisable(nxspi, 0);
+	nxspi_hw_reset(nxspi);
+	return 0;
+}
+
+static int nx_spi_resume(struct platform_device *pdev)
+{
+    struct spi_master *master = platform_get_drvdata(pdev);
+    struct nx_spi *nxspi = spi_master_get_devdata(master);
+	/* just call a disable of SPI device*/
+	nxspi_enabledisable(nxspi, 1);
+	nxspi_hw_reset(nxspi);
+	return 0;
+}
+
+static struct platform_driver nx_spi_driver ={
+    .driver = {
+        .name = "nx_spi",
+        .owner = THIS_MODULE,
+        },
+    .probe = nx_spi_probe,
+    .suspend = nx_spi_suspend,
+    .resume = nx_spi_resume,
+    .remove = __exit_p(nx_spi_remove),
+};
+
+static int __init nx_spi_init(void)
+{
+    nx_spi_wq = create_singlethread_workqueue(
+                    nx_spi_driver.driver.name);
+    if(!nx_spi_wq)
+        return -ENOMEM;
+
+    return platform_driver_register(&nx_spi_driver);
+}
+module_init(nx_spi_init);
+
+static void __exit nx_spi_exit(void)
+{
+    destroy_workqueue(nx_spi_wq);
+    platform_driver_unregister(&nx_spi_driver);
+}
+module_exit(nx_spi_exit);
+
+MODULE_DESCRIPTION("SPI Controller Driver for NXP SPI IP_3409");
+MODULE_AUTHOR("Sangeeta Mutgi <sangeeta.mutgi@nxp.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nx_spi");
+
+
diff -Naurp linux-2.6.34.orig/drivers/spi/nx_spi_local.h linux-2.6.34/drivers/spi/nx_spi_local.h
--- linux-2.6.34.orig/drivers/spi/nx_spi_local.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/spi/nx_spi_local.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,386 @@
+/*
+ * Register definitions (macros) for SPI Controller HW IP_3409
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version      Author           Date          Remarks
+ * 0.0.1        Sangeeta Mutgi   20090530      Draft-Initial version
+ *
+ */
+
+#ifndef NX_SPI_LOCAL_H
+#define NX_SPI_LOCAL_H
+
+
+/* --------------------------------------------------------------------------
+*  Register offsets from base address
+*  --------------------------------------------------------------------------*/
+#define NX_SPI_CONFIG_OFFSET              0x000
+#define NX_SPI_SLAVE_ENABLE_OFFSET        0x004
+#define NX_SPI_TX_FIFO_FLUSH_OFFSET       0x008
+#define NX_SPI_FIFO_DATA_OFFSET           0x00c
+#define NX_SPI_NHP_POP_OFFSET             0x010
+#define NX_SPI_NHP_MODE_OFFSET            0x014
+#define NX_SPI_DMA_SETTING_OFFSET         0x018
+#define NX_SPI_STATUS_OFFSET              0x01c
+#define NX_SPI_HARDWARE_INFO_OFFSET       0x020
+
+
+#define NX_SPI_SLAVEx_SETTING1_OFFSET(slv)   (0x024 + (8*slv))
+#define NX_SPI_SLAVEx_SETTING2_OFFSET(slv)   (0x028 + (8*slv))
+
+
+#define NX_SPI_CHIPSELECTx_SETTING_OFFSET(slv)   (0x224 + (4*slv))
+
+
+#define NX_SPI_HARDWARE_INFO2_OFFSET        0x324
+#define NX_SPI_FIFO_ADDR_OFFSET             0x328
+#define NX_SPI_CS_POLARITY_OFFSET           0x32C
+#define NX_SPI_NUM_TXFERS_CMD_OFFSET        0x330
+#define NX_SPI_INC_NUM_TXFERS_CMD_OFFSET    0x334
+#define NX_SPI_CS_DEFAULT_VAL_OFFSET        0x338
+#define NX_SPI_SMS_LIST_SA_OFFSET           0x33C
+#define NX_SPI_PRESET_RX_RD_PTR_OFFSET      0x340
+
+#define NX_SPI_INTERRUPT_THRESHOLD_OFFSET       0xfd4
+#define NX_SPI_INTERRUPT_CLEAR_ENABLE_OFFSET    0xfd8
+#define NX_SPI_INTERRUPT_SET_ENABLE_OFFSET      0xfdc
+#define NX_SPI_INTERRUPT_STATUS_OFFSET          0xfe0
+#define NX_SPI_INTERRUPT_ENABLE_OFFSET          0xfe4
+#define NX_SPI_INTERRUPT_CLEAR_STATUS_OFFSET    0xfe8
+#define NX_SPI_INTERRUPT_SET_STATUS_OFFSET      0xfec
+
+#define NX_SPI_MODULE_IDENTIFICATION_OFFSET 0xffc
+
+
+/* --------------------------------------------------------------------------
+*  Configuration register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_INTER_SLAVE_DLY_POS  16
+#define NX_SPI_INTER_SLAVE_DLY_MSK  0xffff0000U
+
+/* For Enhanced Master Mode */
+#define NX_SPI_SMS_LIST_SA_UPDATE_POS  11
+#define NX_SPI_SMS_LIST_SA_UPDATE_MSK  0x800
+
+#define NX_SPI_SPI_CONF_DET_EN_POS  10
+#define NX_SPI_SPI_CONF_DET_EN_MSK  0x400
+
+#define NX_SPI_CS_IN_IGNORE_POS  9
+#define NX_SPI_CS_IN_IGNORE_MSK  0x200
+
+#define NX_SPI_RESET_QUEUE_POS  8
+#define NX_SPI_RESET_QUEUE_MSK  0x100
+
+#define NX_SPI_UPDATE_SLAVE_ENABLE_POS 7
+#define NX_SPI_UPDATE_SLAVE_ENABLE_MSK 0x80
+
+#define NX_SPI_SOFTWARE_RESET_POS  6
+#define NX_SPI_SOFTWARE_RESET_MSK  0x40
+
+#define NX_SPI_TIMER_TRIGGER_POS  5
+#define NX_SPI_TIMER_TRIGGER_MSK 0x20
+
+#define NX_SPI_SLAVE_DISABLE_POS  4
+#define NX_SPI_SLAVE_DISABLE_MSK  0x10
+
+#define NX_SPI_TRANSMIT_MODE_POS  3
+#define NX_SPI_TRANSMIT_MODE_MSK 0x8
+
+#define NX_SPI_LOOPBACK_MODE_POS  2
+#define NX_SPI_LOOPBACK_MODE_MSK 0x4
+
+#define NX_SPI_MASTERSLAVE_MODE_POS  1
+#define NX_SPI_MASTERSLAVE_MODE_MSK  0x2
+
+#define NX_SPI_SPI_ENABLE_POS  0
+#define NX_SPI_SPI_ENABLE_MSK 0x1
+
+
+/* --------------------------------------------------------------------------
+*  Slave Enable register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_SLAVE_ENABLE_MSK 0x3
+
+
+/* --------------------------------------------------------------------------
+*  Tx FIFO Flush register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_TX_FIFO_FLUSH_POS  0
+#define NX_SPI_TX_FIFO_FLUSH_MSK 0x1
+
+
+/* --------------------------------------------------------------------------
+*  DMA Setting register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_TX_DMA_BURST_POS 5
+#define NX_SPI_TX_DMA_BURST_MSK 0xE0
+
+
+#define NX_SPI_RX_DMA_BURST_POS 2
+#define NX_SPI_RX_DMA_BURST_MSK 0x1c
+
+#define NX_SPI_TX_DMA_ENABLE_POS 1
+#define NX_SPI_TX_DMA_ENABLE_MSK 0x2
+
+#define NX_SPI_RX_DMA_ENABLE_POS 0
+#define NX_SPI_RX_DMA_ENABLE_MSK 0x1
+
+
+/* --------------------------------------------------------------------------
+*  Status register
+*  --------------------------------------------------------------------------*/
+#define NX_SPI_NUM_PEND_TXFERS_POS 16
+#define NX_SPI_NUM_PEND_TXFERS_MSK 0xFF0000
+
+#define NX_SPI_NUM_PEND_WORDS_POS 8
+#define NX_SPI_NUM_PEND_WORDS_MSK 0xFF00
+
+#define NX_SPI_SMS_MODE_BUSY_POS 5
+#define NX_SPI_SMS_MODE_BUSY_MSK 0x20
+
+#define NX_SPI_SPI_BUSY_POS 4
+#define NX_SPI_SPI_BUSY_MSK 0x10
+
+#define NX_SPI_RX_FIFO_FULL_POS 3
+#define NX_SPI_RX_FIFO_FULL_MSK 0x8
+
+#define NX_SPI_RX_FIFO_EMPTY_POS 2
+#define NX_SPI_RX_FIFO_EMPTY_MSK 0x4
+
+#define NX_SPI_TX_FIFO_FULL_POS 1
+#define NX_SPI_TX_FIFO_FULL_MSK 0x2
+
+#define NX_SPI_TX_FIFO_EMPTY_POS 0
+#define NX_SPI_TX_FIFO_EMPTY_MSK 0x1
+
+
+/* --------------------------------------------------------------------------
+*  Hardware Information register
+*  --------------------------------------------------------------------------*/
+#define NX_SPI_EN_ENHANCED_MASTER_MODE_POS 31
+#define NX_SPI_EN_ENHANCED_MASTER_MODE_MSK 0x80000000U
+
+#define NX_SPI_FIFO_IMPL_POS 30
+#define NX_SPI_FIFO_IMPL_MSK 0x40000000
+
+#define NX_SPI_NUM_SLAVES_POS 26
+#define NX_SPI_NUM_SLAVES_MSK 0x3C000000
+
+#define NX_SPI_TX_FIFO_WIDTH_POS 21
+#define NX_SPI_TX_FIFO_WIDTH_MSK 0x3E00000
+
+#define NX_SPI_RX_FIFO_WIDTH_POS 16
+#define NX_SPI_RX_FIFO_WIDTH_MSK 0x1f0000
+
+#define NX_SPI_TX_FIFO_DEPTH_POS 8
+#define NX_SPI_TX_FIFO_DEPTH_MSK 0xff00
+
+#define NX_SPI_RX_FIFO_DEPTH_POS 0
+#define NX_SPI_RX_FIFO_DEPTH_MSK 0xff
+
+
+/* --------------------------------------------------------------------------
+*  Slave Setting1 register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_INTER_XFER_DLY_POS 24
+#define NX_SPI_INTER_XFER_DLY_MSK 0xff000000U
+
+#define NX_SPI_NUM_WORDS_POS 16
+#define NX_SPI_NUM_WORDS_MSK 0xff0000
+
+#define NX_SPI_CLK_DIVISOR2_POS 8
+#define NX_SPI_CLK_DIVISOR2_MSK 0xff00
+
+#define NX_SPI_CLK_DIVISOR1_POS 0
+#define NX_SPI_CLK_DIVISOR1_MSK 0xff
+
+
+/* --------------------------------------------------------------------------
+*  Slave Setting2 register
+*  --------------------------------------------------------------------------*/
+#define NX_SPI_LSB_FIRST_ENABLE_POS 17
+#define NX_SPI_LSB_FIRST_ENABLE_MSK 0x20000
+
+#define NX_SPI_PROG_DELAY_POS 9
+#define NX_SPI_PROG_DELAY_MSK 0x1FE00
+
+#define NX_SPI_CHIP_SEL_VAL_POS 8
+#define NX_SPI_CHIP_SEL_VAL_MSK 0x100
+
+#define NX_SPI_XFER_FORMAT_POS 7
+#define NX_SPI_XFER_FORMAT_MSK 0x80
+
+#define NX_SPI_CLK_POLARITY_POS 6
+#define NX_SPI_CLK_POLARITY_MSK 0x40
+
+#define NX_SPI_CLK_PHASE_POS 5
+#define NX_SPI_CLK_PHASE_MSK 0x20
+
+#define NX_SPI_XFER_WORDSIZE_POS 0
+#define NX_SPI_XFER_WORDSIZE_MSK 0x1f
+
+
+/* --------------------------------------------------------------------------
+*  Hardware Info register2
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_HW_INFO2_NUM_CS_SETTINGS_POS 1
+#define NX_SPI_HW_INFO2_NUM_CS_SETTINGS_MSK 0x1E
+
+#define NX_SPI_HW_INFO2_SEL_INV_EDGE_POS 0
+#define NX_SPI_HW_INFO2_SEL_INV_EDGE_MSK 0x01
+
+
+/* --------------------------------------------------------------------------
+*  FIFO Addr Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_FIFO_ADDR_POS                     0
+#define NX_SPI_FIFO_ADDR_MSK            0x000000FF
+
+/* --------------------------------------------------------------------------
+*  Chip Select Polarity Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_CS_POLARITY_POS                     0
+#define NX_SPI_CS_POLARITY_MSK            0x00000001
+
+/* --------------------------------------------------------------------------
+*  Num transfers Command Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_NUM_TXFERS_CMD_POS                     0
+#define NX_SPI_NUM_TXFERS_CMD_MSK            0x000000FF
+
+/* --------------------------------------------------------------------------
+* Inc Num transfers Command Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_INC_NUM_TXFERS_CMD_POS                     0
+#define NX_SPI_INC_NUM_TXFERS_CMD_MSK            0x000000FF
+
+/* --------------------------------------------------------------------------
+*  Chip Select Default Val Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_CS_DEF_POS                     0
+#define NX_SPI_CS_DEF_MSK            0x00000001
+
+/* --------------------------------------------------------------------------
+*  SMS List Start Address Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_SMS_LIST_SA_POS                     0
+#define NX_SPI_SMS_LIST_SA_MSK            0x000000FF
+
+/* --------------------------------------------------------------------------
+*  Preset RX RD Ptr Register
+*  -------------------------------------------------------------------------- */
+
+#define NX_SPI_PRESET_RX_RD_PTR_POS                     0
+#define NX_SPI_PRESET_RX_RD_PTR_MSK            0x00000001
+
+
+
+
+/* --------------------------------------------------------------------------
+*   Interrupt  Register
+*  -------------------------------------------------------------------------- */
+
+
+#define NX_SPI_INT_CMD_OV_POS           9
+#define NX_SPI_INT_CMD_OV_MSK  0x00000200
+
+#define NX_SPI_INT_QE_SPI_BUSY_POS           8
+#define NX_SPI_INT_QE_SPI_BUSY_MSK  0x00000100
+
+#define NX_SPI_INT_QE_RXFIFO_EMPTY_POS           7
+#define NX_SPI_INT_QE_RXFIFO_EMPTY_MSK  0x00000080
+
+#define NX_SPI_INT_QE_TXFIFO_FULL_POS           6
+#define NX_SPI_INT_QE_TXFIFO_FULL_MSK  0x00000040
+
+#define NX_SPI_INT_CONF_DET_POS           5
+#define NX_SPI_INT_CONF_DET_MSK  0x00000020
+
+#define NX_SPI_INT_SMS_POS           4
+#define NX_SPI_INT_SMS_MSK  0x00000010
+
+#define NX_SPI_INT_TX_POS            3
+#define NX_SPI_INT_TX_MSK   0x00000008
+
+#define NX_SPI_INT_RX_POS            2
+#define NX_SPI_INT_RX_MSK   0x00000004
+
+#define NX_SPI_INT_TO_POS            1
+#define NX_SPI_INT_TO_MSK   0x00000002
+
+#define NX_SPI_INT_OV_POS            0
+#define NX_SPI_INT_OV_MSK   0x00000001
+
+/* --------------------------------------------------------------------------
+*  Interrupt Threshold register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_TX_THRESHOLD_POS 8
+#define NX_SPI_TX_THRESHOLD_MSK 0xff00
+
+#define NX_SPI_RX_THRESHOLD_POS 0
+#define NX_SPI_RX_THRESHOLD_MSK 0xff
+
+
+/* --------------------------------------------------------------------------
+*  Module Identification register
+*  --------------------------------------------------------------------------*/
+
+#define NX_SPI_MOD_ID_REG_MOD_POS 16
+#define NX_SPI_MOD_ID_REG_MOD_MSK 0xFFFF0000U
+
+#define NX_SPI_MOD_ID_REG_MAJOR_POS 12
+#define NX_SPI_MOD_ID_REG_MAJOR_MSK 0xF000
+
+#define NX_SPI_MOD_ID_REG_MINOR_POS 8
+#define NX_SPI_MOD_ID_REG_MINOR_MSK 0xF00
+
+#define NX_SPI_MOD_ID_REG_APERTURE_POS 0
+#define NX_SPI_MOD_ID_REG_APERTURE_MSK 0xff
+
+
+/* --------------------------------------------------------------------------
+*  Control Word bits ( Enhanced mode only)
+*  --------------------------------------------------------------------------*/
+#define NX_SPI_CONTROL_WORD_NUM_WORDS_POS     0
+#define NX_SPI_CONTROL_WORD_NUM_WORDS_MASK    0xff
+#define NX_SPI_CONTROL_WORD_CHIPSELECT_POS    8
+#define NX_SPI_CONTROL_WORD_TXPARAM_PTR_POS     12
+
+
+/* Register access macros */
+#define nx_spi_readl(reg) \
+    __raw_readl(reg)
+#define nx_spi_writel(reg,value) \
+    __raw_writel((value), reg)
+
+#endif //NX_SPI_LOCAL_H
diff -Naurp linux-2.6.34.orig/drivers/usb/host/ehci-hcd.c linux-2.6.34/drivers/usb/host/ehci-hcd.c
--- linux-2.6.34.orig/drivers/usb/host/ehci-hcd.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/ehci-hcd.c	2010-09-07 22:16:41.000000000 -0500
@@ -44,6 +44,10 @@
 #include <asm/system.h>
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_USB_EHCI_IP9028
+#include <asm/hardware/ip9028.h>
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -692,6 +696,11 @@ static int ehci_run (struct usb_hcd *hcd
 	ehci_writel(ehci, INTR_MASK,
 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
 
+#ifdef CONFIG_USB_EHCI_IP9028
+	__raw_writel(PNX8XXX_USB_IP9028_USB_SBUSCFG_VAL,
+	hcd->regs + PNX8XXX_USB_IP9028_USB_SBUSCFG_OFFSET);
+#endif
+
 	/* GRR this is run-once init(), being done every time the HC starts.
 	 * So long as they're part of class devices, we can't do it init()
 	 * since the class device isn't created that early.
@@ -1104,6 +1113,11 @@ MODULE_LICENSE ("GPL");
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_IP9028
+#include "ehci-ip9028.c"
+#define	PLATFORM_DRIVER		ehci_hcd_ip9028_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_FSL
 #include "ehci-fsl.c"
 #define	PLATFORM_DRIVER		ehci_fsl_driver
diff -Naurp linux-2.6.34.orig/drivers/usb/host/ehci-hub.c linux-2.6.34/drivers/usb/host/ehci-hub.c
--- linux-2.6.34.orig/drivers/usb/host/ehci-hub.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/ehci-hub.c	2010-09-07 22:16:41.000000000 -0500
@@ -188,7 +188,10 @@ static int ehci_bus_suspend (struct usb_
 			}
 		} else
 			t2 &= ~PORT_WAKE_BITS;
-
+#ifdef CONFIG_USB_EHCI_IP9028
+      /* Bit number 23 in port control register in IP9028 controls the low power mode of the IP9028 controller */
+     /*  t2 |= PORT_PHCD; Setting PHCD here affects the usb complaince electrical testing and PHCD is non ehci deviation has to be handled in platform specific code */
+#endif
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -> %08x\n",
 				port + 1, t1, t2);
@@ -298,6 +301,10 @@ static int ehci_bus_resume (struct usb_h
 		temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &ehci->bus_suspended) &&
 				(temp & PORT_SUSPEND)) {
+#ifdef CONFIG_USB_EHCI_IP9028
+         /* Bit number 23 in port control register in IP9028 controls the low power mode of the IP9028 controller */
+        /* temp &= ~PORT_PHCD; Setting PHCD here affects the usb complaince electrical testing and PHCD is non ehci deviation has to be handled in platform specific code */
+#endif
 			temp |= PORT_RESUME;
 			resume_needed = 1;
 		}
diff -Naurp linux-2.6.34.orig/drivers/usb/host/ehci-ip9028.c linux-2.6.34/drivers/usb/host/ehci-ip9028.c
--- linux-2.6.34.orig/drivers/usb/host/ehci-ip9028.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/usb/host/ehci-ip9028.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,390 @@
+/*
+ * PNX85xx on chip USB controller (IP9028) bus glue
+ *
+ * (C) Copyright 2007 NXP BV
+ * by Mischa Jonker, <m.d.s.x.jonker@nxp.com>
+ *
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * Bus Glue for AMD Alchemy Au1xxx
+ *
+ * Based on "ohci-au1xxx.c" by Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Modified for AMD Alchemy Au1200 EHC
+ *  by K.Boge <karsten.boge@amd.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#ifdef CONFIG_ARM
+#include <asm/hardware/ip9028.h>
+#include <mach/cm.h>
+#else
+#include <platform.h>
+#include <cm.h>
+#endif
+
+extern int usb_disabled(void);
+
+/**
+ * usb_ehci_ip9028_probe - initialize IP9028-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_ehci_ip9028_probe(const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out, struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		printk("resource[1] is not IORESOURCE_IRQ\n");
+		retval = -ENOMEM;
+	}
+	hcd = usb_create_hcd(driver, &dev->dev, "ip9028");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	/* IRQ is allocated later, in usb_add_hcd */
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		printk (KERN_ALERT "request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		printk (KERN_ALERT "ioremap failed\n");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+
+	/* put USB OTG block into HOST mode */
+	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start,
+		IRQF_SHARED | IRQF_DISABLED);
+
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------
+ * if OTG -> usb_ehci_ip9028_otg_host_setup
+ * else (ordinary USB HOST behaviour) -> usb_ehci_ip9028_setup
+ */
+
+#ifdef CONFIG_USB_OTG
+/**
+ *
+ */
+int usb_ehci_ip9028_otg_host_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	/* put USB OTG block into HOST mode */
+	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
+
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_ehci_ip9028_otg_host_setup);
+
+#endif	/* CONFIG_USB_OTG */
+
+static int usb_ehci_ip9028_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+	int		retval;
+
+	printk(" usb_ehci_ip9028_setup IN \n");
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+/*  
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	printk(" usb_ehci_ip9028_setup ehci_halt \n");
+*/
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+
+	printk(" usb_ehci_ip9028_setup ehci_init \n");
+
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+
+	printk(" usb_ehci_ip9028_setup ehci_reset \n");
+
+	/* put USB OTG block into HOST mode */
+	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
+
+
+
+	ehci_port_power(ehci, 0);
+
+	printk(" usb_ehci_ip9028_setup OUT \n");
+
+	return 0;
+}
+
+/* ----------
+ * may be called without controller electrically present
+ * may be called with controller, bus, and devices active
+ */
+
+/**
+ * usb_ehci_hcd_ip9028_remove - shutdown processing for IP9028-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_hcd_au1xxx_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_ehci_ip9028_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	unsigned long usb_ahb_clockreg = 0;
+
+	switch(hcd->rsrc_start)
+	{
+	   case IP9028_USB_PORT_0:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_0;
+			break;
+	   case IP9028_USB_PORT_1:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_1;
+			break;
+	   case IP9028_USB_PORT_2:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_2;
+			break;
+		default:
+			return;
+	}
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+#if defined(CONFIG_SOC_PNX85500) || \
+	(defined(CONFIG_SOC_PNX8492) && defined(CONFIG_EXECUTE_ON_SILICON))
+	/* Switch AHB clock to XTAL */
+	SET_CLOCKSRC(usb_ahb_clockreg, USB_AHB_SRC_XTAL);
+#endif
+}
+
+#ifdef CONFIG_PM
+int ehci_9208_bus_suspend(struct usb_hcd *hcd)
+{
+	int i;
+	unsigned long usb_ahb_clockreg = 0;
+
+	switch(hcd->rsrc_start)
+	{
+	   case IP9028_USB_PORT_0:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_0;
+			break;
+	   case IP9028_USB_PORT_1:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_1;
+			break;
+	   case IP9028_USB_PORT_2:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_2;
+			break;
+		default:
+			return -1;
+	}
+
+	i = ehci_bus_suspend(hcd);
+
+#if defined(CONFIG_SOC_PNX85500) || \
+	(defined(CONFIG_SOC_PNX8492) && defined(CONFIG_EXECUTE_ON_SILICON))
+	/* Slow down AHB clock */
+	SET_CLOCKSRC(usb_ahb_clockreg, USB_AHB_SRC_XTAL);
+#endif
+	return i;
+}
+
+int ehci_9208_bus_resume(struct usb_hcd *hcd)
+{
+	unsigned long usb_ahb_clockreg = 0;
+
+	switch(hcd->rsrc_start)
+	{
+	   case IP9028_USB_PORT_0:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_0;
+			break;
+	   case IP9028_USB_PORT_1:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_1;
+			break;
+	   case IP9028_USB_PORT_2:
+			usb_ahb_clockreg = (unsigned long)PNX8XXX_CLK_USB_AHB_CTL_2;
+			break;
+		default:
+			return -1;
+	}
+#if defined(CONFIG_SOC_PNX85500) || \
+	(defined(CONFIG_SOC_PNX8492) && defined(CONFIG_EXECUTE_ON_SILICON))
+	/* Switch to PLL for AHB clock */
+	SET_CLOCKSRC(usb_ahb_clockreg, USB_AHB_SRC_PLL);
+#endif
+	return ehci_bus_resume(hcd);
+}
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * hc driver structures ifo. ordanary USB -> ehci_ip9028_hc_driver
+ * or OTG behaviour (setup) -> ehci_ip9028_otgc_driver
+ */
+/*static */ const struct hc_driver ehci_ip9028_hc_driver = {
+	.description   = hcd_name,
+	.product_desc  = "IP9028 embedded EHCI USB controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq   = ehci_irq,
+	.flags = HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset    = usb_ehci_ip9028_setup,
+	.start    = ehci_run,
+	.stop     = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue      = ehci_urb_enqueue,
+	.urb_dequeue      = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data  = ehci_hub_status_data,
+	.hub_control      = ehci_hub_control,
+	.relinquish_port  = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+#ifdef CONFIG_PM
+	.bus_suspend      = ehci_9208_bus_suspend,
+	.bus_resume       = ehci_9208_bus_resume,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ehci_hcd_ip9028_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	int ret;
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_ehci_ip9028_probe(&ehci_ip9028_hc_driver, &hcd, pdev);
+	return ret;
+}
+
+static int ehci_hcd_ip9028_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ehci_ip9028_remove(hcd, pdev);
+	return 0;
+}
+
+#ifdef CONFIG_ARM
+MODULE_ALIAS("usb-ip9028");
+#else
+MODULE_ALIAS("pnx8xxx-usb-ip9028");
+#endif
+static struct platform_driver ehci_hcd_ip9028_driver = {
+	.probe = ehci_hcd_ip9028_drv_probe,
+	.remove = ehci_hcd_ip9028_drv_remove,
+	.driver = {
+#ifdef CONFIG_ARM
+		.name = "usb-ip9028",
+#else
+		.name = "pnx8xxx-usb-ip9028",
+#endif
+		.bus = &platform_bus_type
+	}
+};
diff -Naurp linux-2.6.34.orig/drivers/usb/otg/ip9028-otg.c linux-2.6.34/drivers/usb/otg/ip9028-otg.c
--- linux-2.6.34.orig/drivers/usb/otg/ip9028-otg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/usb/otg/ip9028-otg.c	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,1139 @@
+/*
+ * IP9028 OTG transceiver glue
+ * (c) 2009 Virage Logic B.V.
+ *
+ * Mischa Jonker <mischa.jonker@viragelogic.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*#define DEBUG_ON_TV550  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/ip9028-otg.h>
+#include <linux/err.h>
+
+#include <linux/proc_fs.h>
+#include <linux/kthread.h>
+
+#define  OTG_PROC_IF  1
+#define OTG_SRP_THREAD 1
+#define OTG_A_HOST_POWER_OFF_THREAD 1
+#define IDLE_DETECTNESS_TIMER 1
+#define IDLE_DETECTNESS_TIMER_VAL 3
+#define USB_OTG_HNP_EN  1
+#define USB_OTG_HNP_A_DEVICE 1
+#define USB_OTG_HNP_B_HOST 1
+
+
+
+/************   GLOBAL Variable START **************************/
+
+struct task_struct  *srp_thread,*pwr_off_thread;
+static struct semaphore	srp_sema ,pwr_off_sema;
+//jun24 volatile int id_is_b=0; /* ID is b-device */
+unsigned int Is_A_host =0; /* OTG device has taken  A -Host role */
+volatile int  b_connect =0;
+int IsPowerOff =0,IsDeviceConnected=0;
+volatile  unsigned int Is_B_Device=0;
+struct work_struct	 *wq_host_probe_g;
+
+#ifdef IDLE_DETECTNESS_TIMER
+
+struct timer_list A_device_idle_timer;
+
+#endif
+
+
+/************   GLOBAL Variable END **************************/
+
+
+
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * calling otg_put_transceiver() to release that count.
+ *
+ * For use by USB host and peripheral drivers.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+/**
+ * otg_put_transceiver - release the (single) OTG transceiver
+ * @x: the transceiver returned by otg_get_transceiver()
+ *
+ * Releases a refcount the caller received from otg_get_transceiver().
+ *
+ * For use by USB host and peripheral drivers.
+ */
+void otg_put_transceiver(struct otg_transceiver *x)
+{
+	if (x)
+		put_device(x->dev);
+}
+EXPORT_SYMBOL(otg_put_transceiver);
+
+/**
+ * otg_set_transceiver - declare the (single) OTG transceiver
+ * @x: the USB OTG transceiver to be used; or NULL
+ *
+ * This call is exclusively for use by transceiver drivers, which
+ * coordinate the activities of drivers for host and peripheral
+ * controllers, and in some cases for VBUS current regulation.
+ */
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+
+
+#ifdef IDLE_DETECTNESS_TIMER
+static void a_device_idle_timer_fn(unsigned long data)
+{
+
+	struct ip9028_otg_usb *ip9028_otg=  (struct ip9028_otg_usb *) data;
+		
+	unsigned int tmp,flag=0;
+
+	//printk(" Check for A-device idlenes for every 10s ****** \n");
+
+	
+	tmp = readl (ip9028_otg->regs + IP9028_USBCMD);
+	//printk(" ASE-PSE tmp = %x \n",tmp);
+
+	if( (tmp &  0x10) == (0x10) )
+	{
+		printk(" PSE is set \n");
+		flag=1;
+	}
+	if( (tmp &  0x20) == (0x20) )
+	{
+		printk(KERN_DEBUG" ASE  is set  ******USB BUS IS BUSY**** \n");
+		flag=1;
+
+	}else
+	{
+		IsPowerOff=1;
+		printk(KERN_DEBUG" **************USB BUS is IDLE **************\n");
+
+
+		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+		
+		if (( tmp  & IP9028_PRTSC_CCS_MASK) == (IP9028_PRTSC_CCS_MASK) )
+		{
+			printk(KERN_DEBUG"DEVICE connected turn off the VBUS \n");
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp & IP9028_PRTSC_PP_OFF_MASK;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+		
+		}else{
+
+			printk(KERN_DEBUG" BUS IS IDLE  but no device is connected \n");
+		}
+		
+		
+		
+
+
+	}
+/*
+	if(!flag)
+	{
+		
+			
+		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+		tmp = tmp & 0xFFFFEFFF;
+		writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
+		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+
+		printk( " a_device_idle_timer_fn : Turn off the port power  =%x \n",tmp);
+		
+	}
+*/
+	mod_timer(&A_device_idle_timer, jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ));
+
+	
+//	tmp = tmp | IP9028_PRTSC_PP;
+//	writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
+
+	
+}
+
+
+#endif
+
+
+/* internal define on top of container_of */
+#define xceiv_to_ip9028_otg(x)		container_of((x), struct ip9028_otg_usb, otg);
+
+
+#ifdef  USB_OTG_HNP_EN
+
+void  start_hw_assit_hnp(struct ip9028_otg_usb	*ip9028_otg);
+
+
+/* Call from usb host stack for HNP initiation */
+
+void  start_hw_assit_hnp(struct ip9028_otg_usb	*ip9028_otg)
+{
+	uint32_t otgsc;
+
+	printk(" start_hw_assit_hnp \n");
+	
+	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);
+	otgsc  |= IP9028_OTGSC_HABA;
+	writel (otgsc, ip9028_otg->regs + IP9028_OTGSC);
+
+}
+
+extern void dr_controller_run_otg_wr(void);
+
+static int ip9028_otg_start_hnp(struct otg_transceiver *x)
+{
+	struct ip9028_otg_usb *ip9028_otg;
+	uint32_t tmp ,delay=100000/* ,retval*/;
+
+	printk("  ip9028_otg_start_hnp 1\n");
+
+	if (!x)
+		return -ENODEV;
+
+	ip9028_otg = xceiv_to_ip9028_otg(x);
+
+
+	tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+	tmp = tmp | IP9028_PRTSC_SUSP;
+	writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
+	tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+	printk("  ip9028_otg_start_hnp tmp=%x 2\n",tmp);
+
+	//usb_remove_hcd(ip9028_otg->hcd);
+
+
+	Is_A_host = 0; //
+		
+	start_hw_assit_hnp(ip9028_otg);
+
+	for(;delay > 0 ;delay--);
+
+	printk( "ip9028_otg_start_hnp: roothub graceful disconnect\n");
+//	spin_lock_irq (&hcd_root_hub_lock);
+	ip9028_otg->hcd->rh_registered = 0;
+//	spin_unlock_irq (&hcd_root_hub_lock);
+
+	dr_controller_run_otg_wr();
+
+	
+	return 0;
+}
+
+static void start_hnp(/*struct ehci_hcd *ehci*,*/struct usb_hcd		*hcd)
+{
+	printk(" ip9028_otgc. : start_hnp \n");
+	otg_start_hnp(hcd->transceiver);
+
+}
+
+
+#endif
+
+
+extern int ip9028_otg_register_peripheral(struct platform_device *peripheral_driver)
+{
+	//ip9028_otg->peripheral_driver = peripheral_driver;
+
+	return 0;
+}
+
+static int ip9028_otg_set_suspend(struct otg_transceiver *x, int suspend)
+{
+
+	return 0;
+}
+
+static int ip9028_otg_set_peripheral(struct otg_transceiver *x,
+		struct usb_gadget *gadget)
+{
+	struct ip9028_otg_usb *ip9028_otg;
+
+	if (!x)
+		return -ENODEV;
+
+	ip9028_otg = xceiv_to_ip9028_otg(x);
+	ip9028_otg->otg.gadget = gadget;
+	if (!gadget)
+		ip9028_otg->otg.state = OTG_STATE_UNDEFINED;
+
+	if (ip9028_otg->otg.state == OTG_STATE_B_PERIPHERAL)
+		usb_gadget_vbus_connect(ip9028_otg->otg.gadget);
+
+	return 0;
+}
+
+static int ip9028_otg_set_host(struct otg_transceiver *x, struct usb_bus *host)
+{
+	struct ip9028_otg_usb *ip9028_otg;
+
+	if (!x)
+		return -ENODEV;
+
+	ip9028_otg = xceiv_to_ip9028_otg(x);
+	ip9028_otg->otg.host = host;
+	if (!host)
+		ip9028_otg->otg.state = OTG_STATE_UNDEFINED;
+
+	return 0;
+}
+
+void ip9028_otg_wq_host_probe(struct work_struct *work)
+{
+	struct ip9028_otg_usb *ip9028_otg = container_of((work), struct ip9028_otg_usb,
+							 wq_host_probe);
+
+	uint32_t usbmode;
+
+	printk (KERN_ALERT "ip9028_otg_wq_host_probe: starting host mode...\n");
+
+	if (ip9028_otg->otg.gadget)
+		usb_gadget_vbus_disconnect(ip9028_otg->otg.gadget);
+
+	
+	 ip9028_otg->hcd = usb_create_hcd(&ehci_ip9028_hc_driver/*&ehci_ip9028_otg_hc_driver*/,
+					 &ip9028_otg->usb_host,"ip9028_udc_udc"/* "ip9028_host"*/);
+	if (ip9028_otg->hcd) {
+		ip9028_otg->hcd->rsrc_start = ip9028_otg->pdev->resource[0].start;
+		ip9028_otg->hcd->rsrc_len = ip9028_otg->pdev->resource[0].end - 
+					    ip9028_otg->pdev->resource[0].start + 1;
+		ip9028_otg->hcd->regs = ip9028_otg->regs;
+
+		usbmode = readl (ip9028_otg->regs + IP9028_USBMODE);
+		usbmode = (usbmode & ~IP9028_USBMODE_MASK) | IP9028_USBMODE_HOST;
+		writel (usbmode, ip9028_otg->regs + IP9028_USBMODE);
+
+		ip9028_otg->hcd->self.otg_port = 1;
+		
+		if (usb_add_hcd(ip9028_otg->hcd, ip9028_otg->pdev->resource[1].start, 
+				IRQF_SHARED | IRQF_DISABLED)) {
+			printk (KERN_ALERT "ip9028_otg_wq_host_probe: could not add hcd! irq=%d \n",ip9028_otg->pdev->resource[0].start);
+		}
+	} else {
+		printk (KERN_ALERT "ip9028_otg_wq_host_probe: could not create hcd!\n");
+	}
+
+#ifdef USB_OTG_HNP_A_DEVICE
+
+//jun24	id_is_b=0;
+	Is_A_host=1;
+
+#endif
+
+#ifdef USB_OTG_HNP_EN
+	ip9028_otg->hcd->transceiver = otg_get_transceiver();
+
+	if(ip9028_otg->hcd->transceiver)
+	{
+		
+		int	status = otg_set_host(ip9028_otg->hcd->transceiver,
+						&ip9028_otg->hcd->self);
+		/*  printk("  otg_set_host \nip9028_otg->hcd =%x ip9028_otg->hcd->transceiver =%x ",ip9028_otg->hcd,ip9028_otg->hcd->transceiver); */
+			if (status) {
+				if (ip9028_otg->hcd->transceiver)
+					put_device(ip9028_otg->hcd->transceiver->dev);
+				/* return status; */
+			
+		}
+		ip9028_otg->hcd->start_hnp = start_hnp;
+		/* printk(" ip9028_otg->hcd->transceiver->start_hnp = %x \n ",ip9028_otg->hcd->transceiver->start_hnp); */
+
+
+	}
+
+#endif	
+
+#ifdef  IDLE_DETECTNESS_TIMER
+	init_timer(&A_device_idle_timer);
+	A_device_idle_timer.expires = jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ);
+	A_device_idle_timer.function =a_device_idle_timer_fn;
+	A_device_idle_timer.data = (unsigned long)ip9028_otg;
+/* 	setup_timer(&A_device_idle_timer, a_device_idle_timer_fn, (unsigned long)ip9028_otg);  */
+	add_timer(&A_device_idle_timer);
+	printk(" A_host_idle_detectness_timer added ****END \n");
+#endif	
+
+
+	
+}
+
+void ip9028_otg_wq_host_remove(struct work_struct *work)
+{
+	struct ip9028_otg_usb *ip9028_otg = container_of((work), struct ip9028_otg_usb,
+							 wq_host_remove);
+
+	usb_remove_hcd(ip9028_otg->hcd);
+	usb_put_hcd(ip9028_otg->hcd);
+
+	if (ip9028_otg->otg.gadget)
+		usb_gadget_vbus_connect(ip9028_otg->otg.gadget);
+}
+
+
+
+
+
+	
+
+
+
+/* original */
+static irqreturn_t ip9028_otg_usb_irq(int irq, void *_otg)
+{
+        struct ip9028_otg_usb *ip9028_otg = _otg;
+        uint32_t otgsc,otgsc1, tmp, retval;
+	static uint32_t timeout = 0;
+
+	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);
+
+	//printk(" ip9028_otg_usb_irq otgsc=%x   \n",otgsc);
+	
+#ifdef DEBUG_ON_TV550	/* enable this to hardwire ID pin to A (host) for TV550 debugging */
+	/* Although TV550 is Host-only support, the ID pin is floating, which 
+	 * results in USB ID 'B-status' (device) because of the internal
+	 * pull-up resistor. To test host functionality on TV550, we need to
+	 * fake as if the ID pin was connected correctly (i.e. to GND) */
+	otgsc = otgsc & ~0x100;
+	otgsc = otgsc | 0x400;
+#endif
+
+	if(Is_B_Device)
+		return IRQ_NONE;
+
+//	if(id_is_b)
+//	{
+//		return IRQ_NONE;
+//	}
+
+
+	/* Added senthil  */
+	if(otgsc  &  IP9028_OTGSC_DPIS)
+	{
+		
+		printk(KERN_DEBUG"ip9028_otg_usb_irq : SRP is detected   \n");
+		tmp = ( otgsc  &  0xFF00FFFF) | IP9028_OTGSC_DPIS ;
+		writel (tmp,ip9028_otg->regs + IP9028_OTGSC);
+		
+
+		if(IsPowerOff)
+		{
+			printk(KERN_DEBUG"Is this   Poweroff event ?  DO Nothing \n");
+			IsPowerOff =0;
+		}
+		else
+		{
+			
+			
+			printk("Enable port power  \n");
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp | IP9028_PRTSC_PP;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+			
+		}
+		
+		
+
+
+		
+	}	
+		
+/* JUNE 23rd
+	if( IP9028_OTGSC_ID  & otgsc)
+	{
+		id_is_b=1;
+
+		printk(" id_is_b is set to 1 \n");
+		return IRQ_NONE;
+		
+	}
+*/	
+
+	if( b_connect)
+	{
+		printk(" ip9028_otg_usb_irq b_connect \n"); //
+		return IRQ_NONE;
+	}	
+
+//	printk (KERN_ALERT "ip9028_otg_usb_irq, otgsc = %08x, state = %d\n", otgsc, ip9028_otg->otg.state);
+
+	switch (ip9028_otg->otg.state) {
+	case OTG_STATE_UNDEFINED:
+		printk(" OTG_STATE_UNDEFINED \n");
+		writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |IP9028_OTGSC_IDPU,
+	   		ip9028_otg->regs + IP9028_OTGSC);
+		if (otgsc & IP9028_OTGSC_ID) {
+			
+			ip9028_otg->otg.state = OTG_STATE_B_IDLE;
+			Is_B_Device = 1;
+
+			/* Close previous session if any */
+
+			if( (otgsc & IP9028_OTGSC_INT_BSEIS) == (IP9028_OTGSC_INT_BSEIS))
+			{
+
+			 	printk(" Cleared IP9028_OTGSC_INT_BSEIS \n");
+				writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_INT_BSEIS , 
+		   		ip9028_otg->regs + IP9028_OTGSC);
+			}
+			
+			
+			printk(" OTG_STATE_UNDEFINED -> OTG_STATE_B_IDLE Is_B_Device=%d  \n",Is_B_Device);
+		} else {
+			writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |
+				IP9028_OTGSC_ASVIE | IP9028_OTGSC_BSVIE, 
+		   		ip9028_otg->regs + IP9028_OTGSC);
+			printk(" OTG_STATE_UNDEFINED -> OTG_STATE_A_IDLE \n");
+			ip9028_otg->otg.state = OTG_STATE_A_IDLE;
+
+			writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |IP9028_OTGSC_AVVIE |IP9028_OTGSC_BSVIE
+				, ip9028_otg->regs + IP9028_OTGSC);
+				
+			/* enable port power */
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp | IP9028_PRTSC_PP;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+			timeout = 10;
+			
+		}
+		if (otgsc & IP9028_OTGSC_IDIS) {
+			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			return IRQ_HANDLED;
+		}
+		break;
+	case OTG_STATE_A_IDLE:
+
+		printk(KERN_DEBUG"  OTG_STATE_A_IDLE IN \n");
+		if (otgsc & IP9028_OTGSC_ID) {
+			ip9028_otg->otg.state = OTG_STATE_B_IDLE;
+			if (otgsc & IP9028_OTGSC_IDIS) {
+				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				return IRQ_HANDLED;
+			}
+			break;
+		}else
+			{
+
+			if (otgsc & IP9028_OTGSC_IDIS) {
+				writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIS,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				
+			}
+			schedule_work(&ip9028_otg->wq_host_probe); 
+			printk(KERN_DEBUG"  OTG_STATE_A_IDLE  \n");
+
+
+			}
+
+		
+		if (otgsc & ((IP9028_OTGSC_ASV) | (IP9028_OTGSC_BSV))) {
+			retval = IRQ_NONE;
+			if (otgsc & IP9028_OTGSC_ASVIS) {
+				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_ASVIS,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				retval = IRQ_HANDLED;
+			}
+			if (otgsc & IP9028_OTGSC_BSVIS) {
+				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_BSVIS,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				retval = IRQ_HANDLED;
+			}
+			/* enable port power */
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp | IP9028_PRTSC_PP;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+			writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE | IP9028_OTGSC_1msE |
+				IP9028_OTGSC_AVVIE, ip9028_otg->regs + IP9028_OTGSC);
+			timeout = 10;
+			ip9028_otg->otg.state = OTG_STATE_A_WAIT_VRISE;
+			printk("  OTG_STATE_A_IDLE -> OTG_STATE_A_WAIT_VRISE\n");
+			return retval;
+		}
+		break;
+	case OTG_STATE_B_IDLE:
+		if (!(otgsc & IP9028_OTGSC_ID)) {
+			ip9028_otg->otg.state = OTG_STATE_A_IDLE;
+			if (otgsc & IP9028_OTGSC_IDIS) {
+				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				return IRQ_HANDLED;
+			}
+		}
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		printk("  OTG_STATE_A_WAIT_VRISE \n"); 
+#ifdef DEBUG_ON_TV550 /* enable this for TV550 debugging! */
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE | IP9028_OTGSC_1msE,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				ip9028_otg->otg.state = OTG_STATE_A_WAIT_BCON;
+				break;
+#endif
+		if (otgsc & IP9028_OTGSC_IDIS) {
+			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			if (otgsc & IP9028_OTGSC_ID) {
+				timeout = 10;
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msE, 
+					ip9028_otg->regs + IP9028_OTGSC);
+				ip9028_otg->otg.state = OTG_STATE_A_WAIT_VFALL;
+			} else {
+				printk (KERN_ALERT "IP9028 OTG: unexpected transition " \
+					"of ID pin in OTG_STATE_A_WAIT_VRISE\n");
+			}
+			return IRQ_HANDLED;
+		}
+		if (otgsc & IP9028_OTGSC_AVVIS) {
+			writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_AVVIS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			if (otgsc & IP9028_OTGSC_AVV) {
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE | IP9028_OTGSC_1msE,
+				   	ip9028_otg->regs + IP9028_OTGSC);
+				ip9028_otg->otg.state = OTG_STATE_A_WAIT_BCON;
+				printk("  OTG_STATE_A_WAIT_VRISE -> OTG_STATE_A_WAIT_BCON \n");
+			} else {
+				printk (KERN_ALERT "IP9028 OTG: unexpected transition " \
+					"of Vbus_valid signal in OTG_STATE_A_WAIT_VRISE\n");
+			}
+			return IRQ_HANDLED;
+		}
+		if (otgsc & IP9028_OTGSC_1msS) {
+			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_1msS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			if (timeout) {
+				timeout--;
+			} else {
+				timeout = 10;
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msE,
+			   		ip9028_otg->regs + IP9028_OTGSC);
+				ip9028_otg->otg.state = OTG_STATE_A_WAIT_VFALL;
+			}
+			return IRQ_HANDLED;
+		}
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (otgsc & IP9028_OTGSC_1msS) {
+			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_1msS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			if (timeout) {
+				timeout--;
+			} else {
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE,
+			   		ip9028_otg->regs + IP9028_OTGSC);
+				if (otgsc & IP9028_OTGSC_ID) {
+					ip9028_otg->otg.state = OTG_STATE_A_IDLE;
+				} else {
+					ip9028_otg->otg.state = OTG_STATE_B_IDLE;
+				}
+			}
+			return IRQ_HANDLED;
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+
+		//OTG_STATE_A_WAIT_BCON
+
+	//jun24	printk(" OTG_STATE_A_WAIT_BCON id_is_b =%d \n",id_is_b );
+
+		
+
+		
+		if (otgsc & IP9028_OTGSC_1msS) {
+			writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msS | IP9028_OTGSC_IDIE,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			ip9028_otg->otg.state = OTG_STATE_A_HOST;
+
+			schedule_work(&ip9028_otg->wq_host_probe);  ////jun24 uncommented
+
+		/*	
+			if(!id_is_b)
+			{
+					schedule_work(&ip9028_otg->wq_host_probe);
+
+			}
+
+			if(id_is_b)
+			{
+				b_connect = 1;
+				printk(" OTG_STATE_A_WAIT_BCON  b_connect set to 1 \n");
+			}
+		*/	
+
+		    otgsc1= readl (ip9028_otg->regs + IP9028_OTGSC);
+		    writel (otgsc1 | IP9028_OTGSC_DPIE |IP9028_OTGSC_DPIS/*  | IP9028_OTGSC_IDIE  | IP9028_OTGSC_IDPU | IP9028_OTGSC_ASVIE | IP9028_OTGSC_BSVIE*/,
+			ip9028_otg->regs + IP9028_OTGSC);
+			
+			return IRQ_HANDLED;
+		}
+		/* intentional break-through */
+	case OTG_STATE_A_HOST:
+		if (otgsc & IP9028_OTGSC_IDIS) {
+			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
+			   	ip9028_otg->regs + IP9028_OTGSC);
+			if (otgsc & IP9028_OTGSC_ID) {
+				timeout = 10;
+				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msE, 
+					ip9028_otg->regs + IP9028_OTGSC);
+				schedule_work(&ip9028_otg->wq_host_remove);
+				ip9028_otg->otg.state = OTG_STATE_A_WAIT_VFALL;
+			} else {
+				printk (KERN_ALERT "IP9028 OTG: unexpected transition " \
+					"of ID pin in OTG_STATE_A_WAIT_BCON\n");
+			}
+			return IRQ_HANDLED;
+		}
+			
+		break;
+	case OTG_STATE_B_SRP_INIT:
+	case OTG_STATE_B_PERIPHERAL:
+	case OTG_STATE_B_WAIT_ACON:
+	case OTG_STATE_B_HOST:
+	case OTG_STATE_A_SUSPEND:
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_A_VBUS_ERR:
+		break;
+	}
+	
+	return IRQ_NONE;
+	
+}
+
+
+
+
+
+static uint64_t ehci_dmamask = 0x1fffffff;
+
+static int __exit ip9028_otg_usb_remove(struct platform_device *pdev);
+/*static */int __devinit ip9028_otg_usb_probe(struct platform_device *pdev);
+
+static struct platform_driver ip9028_otg_usb_driver = {
+	.probe		= ip9028_otg_usb_probe,
+	.remove		= __exit_p(ip9028_otg_usb_remove),
+	.driver		= {
+		//.name	= "ip9028_otg",		// USB_UDC_CHECK: same as in pnx8492.c struct usb0_device.name
+		.name	= "ip9028_udc_udc /*ip9028_otg_usb*/",	// USB_UDC_CHECK: same as in pnx8492.c struct usb0_device.name
+		.owner	= THIS_MODULE,
+		.bus	= &platform_bus_type,
+	},
+};
+
+#ifdef OTG_A_HOST_POWER_OFF_THREAD
+
+
+static int pwr_off_main_thread(void *_pwr_off_otg)
+{
+//	struct fsg_dev		*fsg = fsg_;
+        struct ip9028_otg_usb *ip9028_otg = _pwr_off_otg;
+	 unsigned int tmp;
+
+
+	
+		for (;;) 
+		{
+			printk("pwr_off_main_thread: Before down_interruptible on pwr_off_sema\n");
+			while  (down_interruptible(&pwr_off_sema));			
+			
+
+			printk("  **Power off the A-host **\n");
+
+			IsPowerOff=1;
+
+
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp & IP9028_PRTSC_PP_OFF_MASK;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
+		
+
+		}
+
+	
+
+	
+	
+
+	return 0;
+
+}
+
+
+
+#endif
+
+
+#ifdef OTG_SRP_THREAD
+
+static int srp_main_thread(void *_srp_otg)
+{
+//	struct fsg_dev		*fsg = fsg_;
+        struct ip9028_otg_usb *ip9028_otg = _srp_otg;
+	 unsigned int tmp;
+
+
+	
+		for (;;) 
+		{
+			printk("srp_main_thread: Before down_interruptible on srp_sema\n");
+			while  (down_interruptible(&srp_sema));			
+			
+			/* Intiate SRP */
+			printk(" Intiated SRP ****\n");
+
+
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp & IP9028_PRTSC_PP_OFF_MASK;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
+
+			tmp = readl (ip9028_otg->regs + IP9028_OTGSC);
+			tmp  |= (IP9028_OTGSC_OT |IP9028_OTGSC_DP |IP9028_OTGSC_HADP);
+			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
+			
+/*
+			tmp = readl (ip9028_otg->regs + IP9028_OTGSC);
+			tmp  |= IP9028_OTGSC_DP;
+			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
+			
+		
+			tmp = readl (ip9028_otg->regs + IP9028_OTGSC);
+			tmp  |= IP9028_OTGSC_HADP;
+			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
+*/
+
+			
+
+			printk("  SRP Intialization  done \n");
+		
+			
+
+		}
+
+	
+
+	
+	
+
+	return 0;
+
+}
+
+
+#endif
+
+
+#ifdef OTG_PROC_IF
+
+int proc_usb_otg_start_srp(char *buffer,char **buffer_location,off_t offset,
+                             int buffer_length, int *eof, void *data)
+{
+
+		printk(KERN_INFO "proc_usb_otg_start_srp \n");
+		up(&srp_sema);
+
+		return 0;
+		
+}
+
+int proc_usb_otg_host_poweroff(char *buffer,char **buffer_location,off_t offset,
+                             int buffer_length, int *eof, void *data)
+{
+
+		printk(KERN_INFO "proc_usb_otg_host_poweroff\n");
+
+		up(&pwr_off_sema);
+
+		return 0;
+		
+}
+
+void usb_otg_create_proc_entry(void)
+{
+    static struct proc_dir_entry *gadget_proc_file ;
+
+
+    gadget_proc_file = create_proc_entry("usb_otg_start_srp", 0644, NULL);
+    if (gadget_proc_file == NULL) {
+           //  remove_proc_entry("usb_gadget1", &gadget_proc_file);
+             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_start_srp");
+             return;
+    }
+    gadget_proc_file->read_proc = proc_usb_otg_start_srp;
+    gadget_proc_file->owner = THIS_MODULE;
+    gadget_proc_file->mode = S_IFREG | S_IRUGO;
+    gadget_proc_file->uid = 0;
+    gadget_proc_file->gid = 0;
+    gadget_proc_file->size = 100;
+
+    gadget_proc_file = create_proc_entry("proc_usb_otg_host_poweroff", 0644, NULL);
+    if (gadget_proc_file == NULL) {
+            // remove_proc_entry("usb_gadget2", &gadget_proc_file);
+             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","proc_usb_otg_host_poweroff");
+             return;
+    }
+    gadget_proc_file->read_proc = proc_usb_otg_host_poweroff;
+    gadget_proc_file->owner = THIS_MODULE;
+    gadget_proc_file->mode = S_IFREG | S_IRUGO;
+    gadget_proc_file->uid = 0;
+    gadget_proc_file->gid = 0;
+    gadget_proc_file->size = 100;
+
+
+
+}
+
+
+#endif
+
+
+
+/*static */ int __devinit ip9028_otg_usb_probe(struct platform_device *pdev)
+{
+	struct ip9028_otg_usb	*ip9028_otg;
+	int			status, retval,err;
+	uint32_t otgsc;
+	
+
+
+	printk(" SENTHIL   ip9028_otg_usb_probe \n");
+
+/*	
+
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
+		printk("resource[1] is not IORESOURCE_IRQ\n");
+		return -EINVAL;
+	}
+
+
+
+	if (!request_mem_region(pdev->resource[0].start, pdev->resource[0].end - 
+	    pdev->resource[0].start + 1, "ip9028_otg")) {
+		printk (KERN_ALERT "request_mem_region failed\n");
+		return -EBUSY;
+	}
+*/
+	ip9028_otg = kzalloc(sizeof *ip9028_otg, GFP_KERNEL);
+	if (!ip9028_otg)
+		return -ENOMEM;
+
+	ip9028_otg->regs = ioremap(pdev->resource[0].start, pdev->resource[0].end -
+				   pdev->resource[0].start + 1);
+	if (!ip9028_otg->regs) {
+		printk (KERN_ALERT "ip9028_otg: ioremap failed\n");
+		kfree (ip9028_otg);
+		return -ENOMEM;
+	}
+
+	ip9028_otg->dev			= &pdev->dev;
+	// USB_UDC_CHECK ip9028_otg->irq = platform_get_irq(pdev, 1);	// (pdev, 0);
+	ip9028_otg->irq			= pdev->resource[1].start;
+	ip9028_otg->otg.dev		= ip9028_otg->dev;
+	ip9028_otg->otg.label		= "ip9028_otg";
+	ip9028_otg->otg.set_host	= ip9028_otg_set_host;
+	ip9028_otg->otg.set_peripheral	= ip9028_otg_set_peripheral;
+	ip9028_otg->otg.set_suspend	= ip9028_otg_set_suspend;
+	ip9028_otg->otg.start_hnp =  ip9028_otg_start_hnp;
+	ip9028_otg->usb_host.dma_mask	= &ehci_dmamask;
+	ip9028_otg->usb_host.coherent_dma_mask = 0x1fffffff;
+	ip9028_otg->usb_peripheral.dma_mask = &ehci_dmamask;
+	ip9028_otg->usb_peripheral.coherent_dma_mask = 0x1fffffff;
+
+	INIT_WORK(&ip9028_otg->wq_host_probe, ip9028_otg_wq_host_probe);
+	INIT_WORK(&ip9028_otg->wq_host_remove, ip9028_otg_wq_host_remove);
+
+	wq_host_probe_g = &ip9028_otg->wq_host_probe;
+
+	//INIT_WORK(&wq_host_probe_g, ip9028_otg_wq_host_probe);
+	
+	
+
+	/* init spinlock for workqueue */
+	spin_lock_init(&ip9028_otg->lock);
+
+	err =  otg_set_transceiver(&ip9028_otg->otg);
+	if (err) {
+		dev_err(&pdev->dev, "can't register transceiver, err: %d\n",
+			err);
+		
+	}
+
+	platform_set_drvdata(pdev, ip9028_otg);
+
+	ip9028_otg->irq_enabled = true;
+	ip9028_otg->pdev = pdev;
+
+	dev_set_name(&ip9028_otg->usb_host, "ip9028_host");
+	dev_set_name(&ip9028_otg->usb_peripheral, "ip9028_peripheral");
+	ip9028_otg->usb_host.parent = &pdev->dev;
+	ip9028_otg->usb_host.driver = &ip9028_otg_usb_driver.driver;
+	ip9028_otg->usb_peripheral.parent = &pdev->dev;
+	ip9028_otg->usb_peripheral.driver = &ip9028_otg_usb_driver.driver;
+
+	retval = device_register (&ip9028_otg->usb_host);
+	retval = device_register (&ip9028_otg->usb_peripheral);
+
+
+	// USB_UDC_CHECK: check for probe success/fail. incase fail, subsequent controller operations cause Kernel crash.
+//	#ifdef FSL_PORT
+	//retval = fsl_otg_udc_probe (pdev /*&ip9028_otg->usb_peripheral*/, ip9028_otg->regs,  ip9028_otg->irq);	// Use FSL PORT...
+//	 retval = fsl_otg_udc_probe (&ip9028_otg->usb_peripheral, ip9028_otg->regs, ip9028_otg->irq);
+//	printk("===== SENTHIL ******fsl_otg_udc_probe done: irq %d, iobase 0x%x\n", ip9028_otg->irq, pdev->resource[0].start);
+//	#else
+//	retval = cnxt_udc_probe(&udc_device0);	// Use NOCONA PORT...
+//	printk("===== SENTHIL ******cnxt_udc_probe done: irq %d, iobase 0x%x\n", ip9028_otg->irq, pdev->resource[0].start);
+//	#endif
+
+//	if (retval != 0) 
+//	{
+//		dev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",
+//			ip9028_otg->irq, retval);
+//		kfree(ip9028_otg);
+//		return retval;
+//	}
+	
+//	#ifdef FSL_PORT
+//	fsl_udc_otg_suspend ();		// Use FSL PORT...
+//	#else
+//	cnxt_udc_suspend();			// Use NOCONA PORT...
+//	#endif
+//*/	
+	status = request_irq(ip9028_otg->irq, ip9028_otg_usb_irq,
+			IRQF_SHARED /* | IRQF_DISABLED */,
+			/* "ip9028_otg_usb"*/"ip9028_udc_udc", ip9028_otg);
+	if (status < 0) {
+		dev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",
+			ip9028_otg->irq, status);
+		kfree(ip9028_otg);
+		return status;
+	}
+
+	//mode= readl (ip9028_otg->regs + IP9028_USBMODE);
+
+	//writel (mode |IP9028_USBMODE_IDLE_MASK ,
+	//ip9028_otg->regs + IP9028_USBMODE);
+
+	ip9028_otg->otg.state = OTG_STATE_UNDEFINED; //
+	/* ip9028_otg_usb_irq(ip9028_otg->irq, ip9028_otg);  */
+
+	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);  //
+	writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |IP9028_OTGSC_IDPU|IP9028_OTGSC_ASVIE  |IP9028_OTGSC_BSVIE | IP9028_OTGSC_AVVIE  | IP9028_OTGSC_BSEIE,
+	   		ip9028_otg->regs + IP9028_OTGSC); //
+	
+#ifdef OTG_PROC_IF
+	usb_otg_create_proc_entry();
+#endif
+
+#ifdef OTG_SRP_THREAD
+
+	srp_thread = kthread_create(srp_main_thread, ip9028_otg, "srp_thread");	
+	if (IS_ERR(srp_thread))
+	{	
+		printk("Unable to start the srp_main_thread\n");		
+		return PTR_ERR(srp_thread);	
+	}
+
+	wake_up_process(srp_thread);
+	init_MUTEX_LOCKED(&(srp_sema));
+	
+
+#endif
+
+#ifdef OTG_A_HOST_POWER_OFF_THREAD
+
+	pwr_off_thread = kthread_create(pwr_off_main_thread, ip9028_otg, "A_host_pwr_off_thread");	
+	if (IS_ERR(pwr_off_thread))
+	{	
+		printk("Unable to start the A_host_pwr_off_thread\n");		
+		return PTR_ERR(pwr_off_thread);	
+	}
+
+	wake_up_process(pwr_off_thread);
+	init_MUTEX_LOCKED(&(pwr_off_sema));
+	
+
+#endif
+
+	
+	printk (KERN_INFO "Initialized IP9028 OTG USB module\n");
+	return 0;
+}
+
+static int __exit ip9028_otg_usb_remove(struct platform_device *pdev)
+{
+	struct ip9028_otg_usb *ip9028_otg = platform_get_drvdata(pdev);
+
+	free_irq(ip9028_otg->irq, ip9028_otg);
+
+	fsl_otg_udc_remove();
+
+	kfree(ip9028_otg);
+
+	return 0;
+}
+
+static int __init ip9028_otg_usb_init(void)
+{
+	printk("otg_init ===>>> ip9028_otg_usb_init \n" );
+	return platform_driver_register(&ip9028_otg_usb_driver);
+}
+module_init(ip9028_otg_usb_init);	// USB_UDC_CHECK
+//USB_UDC_CHECK subsys_initcall(ip9028_otg_usb_init);
+
+static void __exit ip9028_otg_usb_exit(void)
+{
+	platform_driver_unregister(&ip9028_otg_usb_driver);
+}
+module_exit(ip9028_otg_usb_exit);
+
+MODULE_ALIAS("platform:ip9028_otg_usb");
+MODULE_AUTHOR("NXP Semiconductors");
+MODULE_DESCRIPTION("IP9028 USB OTG transceiver driver");
+MODULE_LICENSE("GPL");
diff -Naurp linux-2.6.34.orig/drivers/usb/otg/Kconfig linux-2.6.34/drivers/usb/otg/Kconfig
--- linux-2.6.34.orig/drivers/usb/otg/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/otg/Kconfig	2010-09-07 22:16:41.000000000 -0500
@@ -61,6 +61,9 @@ config TWL4030_USB
 	  This transceiver supports high and full speed devices plus,
 	  in host mode, low speed.
 
+config IP9028_OTG
+	tristate "IP9028 OTG"
+
 config NOP_USB_XCEIV
 	tristate "NOP USB Transceiver Driver"
 	select USB_OTG_UTILS
diff -Naurp linux-2.6.34.orig/drivers/usb/otg/Makefile linux-2.6.34/drivers/usb/otg/Makefile
--- linux-2.6.34.orig/drivers/usb/otg/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/otg/Makefile	2010-09-07 22:16:41.000000000 -0500
@@ -11,6 +11,7 @@ obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_om
 obj-$(CONFIG_TWL4030_USB)	+= twl4030-usb.o
 obj-$(CONFIG_NOP_USB_XCEIV)	+= nop-usb-xceiv.o
 obj-$(CONFIG_USB_ULPI)		+= ulpi.o
+obj-$(CONFIG_IP9028_OTG)	+= ip9028-otg.o
 
 ccflags-$(CONFIG_USB_DEBUG)	+= -DDEBUG
 ccflags-$(CONFIG_USB_GADGET_DEBUG) += -DDEBUG
diff -Naurp linux-2.6.34.orig/include/HwAPI/phExtraTypes.h linux-2.6.34/include/HwAPI/phExtraTypes.h
--- linux-2.6.34.orig/include/HwAPI/phExtraTypes.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/phExtraTypes.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,113 @@
+/*
+ * Copyright Koninklijke Philips Electronics N.V. 2003
+ * All rights reserved.
+ *
+ *          %name: phExtraTypes.h %
+ *       %version: 1 %
+ * %date_modified: %
+ *          Owner: %
+ */
+
+
+#ifndef _PHEXTRATYPES_H_
+#define _PHEXTRATYPES_H_
+
+#if 0
+
+#if defined(__TCS__)			/* Trimedia compilation System */
+
+#@include "phExtraTypesTcs.h"
+
+#elif defined(TORNADO_GNU) || defined(VIPER)   /* Viper Mips VxWorks (SDE4: TORNADO_GNU, SDE1: VIPER) */
+
+#@include "phExtraTypesTornadoMips.h"
+
+#elif defined(STBUP_TASKING) /* 8051 Standby Controller */
+
+#@include "phExtraTypesTasking8051.h"
+
+#elif defined(__WIN32)       /* Windows X86 simulation */
+
+#@include "phExtraTypesMsvcX86.h"
+
+#else
+
+#error undefined toolchain, please add a new phExtraTypes instance for this toolchain to osapi
+
+#endif
+
+#endif
+
+
+#ifndef TMOAPTMTYPESINCLUDED
+
+#define	False		0
+#define	Null		0
+#define	True		1
+
+typedef void            Void;
+typedef char       *    Address;
+typedef char const *	ConstAddress;
+typedef void       *	Pointer;	/* pointer to anonymous object */
+typedef void const *	ConstPointer;
+typedef char const *	ConstString;
+
+typedef unsigned char   Byte;		/* raw byte */
+typedef int		Int;		/* machine-natural integer */
+typedef unsigned int	UInt;		/* machine-natural unsigned integer */
+typedef float		Float;		/* fast float */
+typedef float		Float32;	/* single-precision float */
+#if	!defined(__MWERKS__)
+typedef double		Float64;	/* double-precision float */
+#endif
+
+#if defined(__KERNEL__) && defined(__linux__)
+# include <linux/types.h>
+
+typedef unsigned long   Flags;
+#else
+typedef UInt32          Flags;
+
+#if	defined(_WIN32)
+#define	LL_CONST(c)	(c##i64)
+#define	ULL_CONST(c)	(c##ui64)
+#define LL_MOD		"I64"
+#else	/* !defined(_WIN32) */
+#define	LL_CONST(c)	(c##LL)
+#define	ULL_CONST(c)	(c##ULL)
+#define LL_MOD		"ll"
+#endif	/* !defined(_WIN32) */
+
+#endif	/* !defined(KERNEL) */
+
+
+#if defined (TMFL_DVP4_BUILD) || defined(SDE4_BUILD)
+typedef Int		Endian;
+#define	BigEndian	0
+#define	LittleEndian	1  /* type clashes with winperf.h declaration */
+#endif
+
+typedef enum { TM32 = 0, TM3260, TM5250, TM2270, TM3270,
+	       TM64=100 } TMArch;
+/* TM32 = 0 for compatibility!, allow many tm32 versions before TM64 */
+extern char* TMArch_names[];
+/* LTS 601673 - To determnie the TMArch value from the name, we need this
+                array because TMArch values are not consecutive */
+extern TMArch TMArch_values[];
+
+typedef struct {
+  UInt8  majorVersion;
+  UInt8  minorVersion;
+  UInt16 buildVersion;
+} tmVersion_t, *ptmVersion_t;
+
+extern char *get_TMArch_name(TMArch arch) ;
+
+#endif
+
+
+
+
+
+
+#endif /* _PHEXTRATYPES_H_ */
diff -Naurp linux-2.6.34.orig/include/HwAPI/phStdTypesGccMipsLinux.h linux-2.6.34/include/HwAPI/phStdTypesGccMipsLinux.h
--- linux-2.6.34.orig/include/HwAPI/phStdTypesGccMipsLinux.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/phStdTypesGccMipsLinux.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,124 @@
+/*
+ * Copyright Koninklijke Philips Electronics N.V. 2003
+ * All rights reserved.
+ *
+ *          %name: phStdTypesGccMipsLinux.h %
+ *       %version: 2 %
+ * %date_modified: %
+ *          Owner: %
+ */
+
+
+#ifndef _PHSTDTYPESGCCMIPSLINUX_H_
+#define _PHSTDTYPESGCCMIPSLINUX_H_
+
+
+#ifndef TMOAPTMTYPESINCLUDED
+
+typedef char                *String;
+typedef unsigned int         Bool;
+typedef char                 Char;
+
+typedef signed char          Int8;
+typedef short                Int16;
+typedef long                 Int32;
+typedef long long            Int64;
+
+typedef unsigned char        UInt8;
+typedef unsigned short       UInt16;
+typedef unsigned long        UInt32;
+typedef unsigned long long   UInt64;
+
+#ifdef MIPSEL        /* SDE1 & SDE4 Build */
+/* Default */
+#elif TMFL_ENDIAN    /* SDE2 Build */
+#ifdef TMFL_ENDIAN && (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+#define MIPSEB
+#else
+#define MIPSEL
+#endif
+#else
+#error Endianess unknown
+#endif
+
+typedef struct                          /* Int64: 64-bit signed integer */
+{
+        /* Get the correct endianness (this has no impact on any other part of
+            the system, but it may make memory dumps easier to understand). */
+#ifdef MIPSEB
+        Int32 hi; UInt32 lo;
+#else
+        UInt32 lo; Int32 hi;
+#endif
+}   _Int64;
+
+typedef struct                          /* UInt64: 64-bit unsigned integer */
+{
+#ifdef MIPSEB
+        UInt32 hi; UInt32 lo;
+#else
+        UInt32 lo; UInt32 hi;
+#endif
+}   _UInt64;
+
+
+#endif /* TMOAPTMTYPESINCLUDED */
+
+typedef UInt32               tmErrorCode_t;
+
+typedef Int8               * pInt8;
+typedef Int16              * pInt16;
+typedef Int32              * pInt32;
+typedef Int64              * pInt64;
+
+typedef UInt8              * pUInt8;
+typedef UInt16             * pUInt16;
+typedef UInt32             * pUInt32;
+typedef UInt64             * pUInt64;
+
+typedef Bool               * pBool;
+typedef Char               * pChar;
+typedef String             * pString;
+
+#if 0
+typedef int		     wchar_t;
+typedef unsigned int         size_t;
+typedef int                  intptr_t;
+typedef unsigned int         uintptr_t;
+
+
+#define INT8_MIN    (-127-1)
+#define INT8_MAX      127
+
+#define INT16_MIN   (-32767-1)
+#define INT16_MAX     32767
+
+#define INT32_MIN   (-2147483647-1)          /* minimum long int value */
+#define INT32_MAX     2147483647             /* maximum long int value */
+
+#define INT64_MIN   (-9223372036854775807-1) /* minimum long long int value */
+#define INT64_MAX     9223372036854775807    /* maximum long long int value */
+
+#define UINT8_MAX      255U
+#define UINT16_MAX     65535U
+#define UINT32_MAX     4294967295U           /* maximum long int value */
+#define UINT64_MAX     18446744073709551615U /* maximum long long int value */
+#endif
+
+
+#ifdef  TRUE
+#undef  TRUE
+#endif
+#define TRUE        1
+
+#ifdef  FALSE
+#undef  FALSE
+#endif
+#define FALSE       0
+
+#undef  NULL
+#define NULL        (0)  /* Not cast to void*, because it should also work for ROM pointers */
+
+#define TM_OK       0
+
+#endif /* _PHSTDTYPESGCCMIPSLINUX_H_ */
diff -Naurp linux-2.6.34.orig/include/HwAPI/phStdTypes.h linux-2.6.34/include/HwAPI/phStdTypes.h
--- linux-2.6.34.orig/include/HwAPI/phStdTypes.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/phStdTypes.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright Koninklijke Philips Electronics N.V. 2003
+ * All rights reserved.
+ *
+ *          %name: phStdTypes.h %
+ *       %version: 1 %
+ * %date_modified: %
+ *          Owner: %
+ */
+
+
+#ifndef _PHSTDTYPES_H_
+#define _PHSTDTYPES_H_
+
+
+
+#if defined(__TCS__)			               /* Trimedia compilation System */
+#include "phStdTypesTcs.h"
+
+#elif defined(TORNADO_GNU) || defined(VIPER) || ( defined (TMFL_OS_IS_VXWORKS) && (TMFL_OS_IS_VXWORKS==1) )  /* Viper Mips VxWorks (SDE4: TORNADO_GNU, SDE1: VIPER) */
+#include "phStdTypesGccMipsVxWorks.h"
+
+#elif defined(STBUP_TASKING)                   /* 8051 Standby Controller */
+#include "phStdTypesTasking8051.h"
+
+#elif defined(_WIN32)                          /* Windows X86 simulation */
+#include "phStdTypesMsvcX86.h"
+
+#elif defined(LINUX) && defined(MONTAVISTA_GNU)/* Linux MIPS build */
+#include "phStdTypesGccMipsLinux.h"
+
+#elif defined(LINUX)
+#include "phStdTypesGccX86Linux.h"             /* Linux X86 build */
+
+#else
+
+#error undefined toolchain, please add a new phStdTypes instance for this toolchain to osapi
+
+#endif
+
+
+#endif /* _PHSTDTYPES_H_ */
+
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmFlags.h linux-2.6.34/include/HwAPI/tmFlags.h
--- linux-2.6.34.orig/include/HwAPI/tmFlags.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmFlags.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,220 @@
+/*  MoReUse 2002-09-13 Continuus Version 2                                      */
+/*                                                                              */
+/* Changes: made ansi compliant                                                 */
+/*--------------------------------------------------------------------------    */
+ /* (C) Copyright 2002 Koninklijke Philips Electronics N.V., All Rights Reserved*/
+ /*                                                                             */
+ /* This source code and any compilation or derivative thereof is the sole      */
+ /* property of Philips Corporation and is provided pursuant to a Software      */
+ /* License Agreement.  This code is the proprietary information of             */
+ /* Philips Corporation and is confidential in nature.  Its use and             */
+ /* dissemination by any party other than Philips Corporation is strictly       */
+ /* limited by the confidential information provisions of the Agreement         */
+ /* referenced above.                                                           */
+ /*-------------------------------------------------------------------------    */
+ /* FILENAME:     tmFlags.h                                                     */
+ /*                                                                             */
+ /* DESCRIPTION:  Platform dependent build flags (typically generated by the    */
+ /*               SDE build process if it doesn't already exist).               */
+ /*                                                                             */
+ /* DOCUMENT REF: DVP Build Process Specification                               */
+ /*                                                                             */
+ /* NOTES:        This file defines the TMFL_xxx build flags configuration.     */
+ /*               It does not include specific component diversity flags that   */
+ /*               are defined in the component makefiles (e.g., TMFL_SCOPE      */
+ /*               defined in BSL board files)                                   */
+ /*                                                                             */
+ /*               This file is based on SDE Version 1.2 generated output.       */
+ /*-------------------------------------------------------------------------    */
+ /*                                                                             */
+ #if     !defined(TM_FLAGS_H)
+ #define TM_FLAGS_H
+
+/* Configurable build flags                                                     */
+/* NOTE: The following flags are configurable (typically generated by SDE       */
+/*          based on _TMXXX build environment variables).  See individual flags */
+/*         for comments about the settings and consistency requirements.        */
+
+/* TMFL_BUILD_VERSION: <Major>.<Minor>.<BuildNumber> as decimal digits. This    */
+/*   number is product/release dependent and not standardized as of now.        */
+ #define TMFL_BUILD_VERSION            00.00.00
+
+/* TMFL_CPU: CPU type/model numbers: (TMFL_CPU_TYPE_XXX | TMFL_CPU_MODEL_XXX).  */
+/*   Example: (TMFL_CPU_TYPE_X86 | TMFL_CPU_MODEL_I486) or (TMFL_CPU_I486) for  */
+/*   an x86 i486 CPU.                                                           */
+ #define TMFL_CPU                      (TMFL_CPU_IS_HP | TMFL_CPU_MODEL_HP)
+
+/* TMFL_ENDIAN: CPU endianness: <TMFL_ENDIAN_BIG | TMFL_ENDIAN_LITTLE>          */
+ #define TMFL_ENDIAN                   (TMFL_ENDIAN_LITTLE)
+
+/* TMFL_OS: Operating system type/version where the version number should be    */
+/*   included if defined: (TMFL_OS_<TTT>[VVV]).  Example: TMFL_OS_PSOS250       */
+/*   indicates that the target OS is pSOS Version 2.50.                         */
+ #define TMFL_OS                       (TMFL_OS_LINUX)
+
+/* TMFL_CPU_IS_XXX: These are boolean flags that reflects the CPU type and      */
+/*   must be consistent with the TMFL_CPU setting (i.e., if TMFL_CPU =          */
+/*   TMFL_CPU_I486, then TMFL_CPU_IS_X86 = 1) and all other TMFL_CPU_IS_XXX     */
+/*	 flags are 0.                                                               */
+ #define TMFL_CPU_IS_X86               0
+ #define TMFL_CPU_IS_MIPS              1
+ #define TMFL_CPU_IS_HP                0
+ #define TMFL_CPU_IS_TM                0
+ #define TMFL_CPU_IS_ARM               0
+ #define TMFL_CPU_IS_REAL              0
+
+/* TMFL_OS_IS_XXX: These are boolean flags that reflects the OS type and        */
+/*   must be consistent with the TMFL_OS setting (i.e., if TMFL_OS =            */
+/*   TMFL_OS_PSOS250, then TMFL_OS_IS_PSOS = 1) and all other TMFL_OS_IS_XXX    */
+/*   flags are 0.                                                               */
+ #define TMFL_OS_IS_BTM                0
+ #define TMFL_OS_IS_CE                 0
+ #define TMFL_OS_IS_NT                 0
+ #define TMFL_OS_IS_PSOS               0
+ #define TMFL_OS_IS_NULLOS             0
+ #define TMFL_OS_IS_ECOS               0
+ #define TMFL_OS_IS_VXWORKS            0
+ #define TMFL_OS_IS_MTOS               0
+ #define TMFL_OS_IS_HPUNIX             0
+ #define TMFL_OS_IS_LINUX              1
+
+
+/* Non-configurable constants                                                   */
+/* NOTE: These values do not change and should not be modified !                */
+ #define TMFL_CPU_TYPE_MASK            0xffff0000
+ #define TMFL_CPU_TYPE_X86             0x00010000
+ #define TMFL_CPU_TYPE_MIPS            0x00020000
+ #define TMFL_CPU_TYPE_TM              0x00030000
+ #define TMFL_CPU_TYPE_HP              0x00040000
+ #define TMFL_CPU_TYPE_ARM             0x00050000
+ #define TMFL_CPU_TYPE_REAL            0x00060000
+ #define TMFL_CPU_MODEL_MASK           0x0000ffff
+ #define TMFL_CPU_MODEL_I486           0x00000001
+ #define TMFL_CPU_MODEL_R3940          0x00000002
+ #define TMFL_CPU_MODEL_R4300          0x00000003
+ #define TMFL_CPU_MODEL_TM1100         0x00000004
+ #define TMFL_CPU_MODEL_TM1300         0x00000005
+ #define TMFL_CPU_MODEL_TM32           0x00000006
+ #define TMFL_CPU_MODEL_HP             0x00000007
+ #define TMFL_CPU_MODEL_R4640          0x00000008
+ #define TMFL_CPU_MODEL_ARM7           0x00000009
+ #define TMFL_CPU_MODEL_ARM920T        0x0000000a
+ #define TMFL_CPU_MODEL_ARM940T        0x0000000b
+ #define TMFL_CPU_MODEL_ARM10          0x0000000c
+ #define TMFL_CPU_MODEL_STRONGARM      0x0000000d
+ #define TMFL_CPU_MODEL_RD24120        0x0000000e
+ #define TMFL_CPU_MODEL_ARM926EJS      0x0000000f
+ #define TMFL_CPU_MODEL_ARM946         0x00000010
+ #define TMFL_CPU_MODEL_R1910          0x00000011
+ #define TMFL_CPU_MODEL_R4450          0x00000012
+ #define TMFL_CPU_MODEL_TM3260         0x00000013
+ #define TMFL_ENDIAN_BIG               1
+ #define TMFL_ENDIAN_LITTLE            0
+ #define TMFL_OS_MASK                  0xff000000
+ #define TMFL_OS_VERSION_MASK          0x00ffffff
+ #define TMFL_OS_BTM                   0x00000000
+ #define TMFL_OS_CE                    0x01000000
+ #define TMFL_OS_CE212                 0x01020102
+ #define TMFL_OS_CE300                 0x01030000
+ #define TMFL_OS_NT                    0x02000000
+ #define TMFL_OS_NT4                   0x02040000
+ #define TMFL_OS_PSOS                  0x03000000
+ #define TMFL_OS_PSOS250               0x03020500
+ #define TMFL_OS_PSOS200               0x03020000
+ #define TMFL_OS_NULLOS                0x04000000
+ #define TMFL_OS_ECOS                  0x05000000
+ #define TMFL_OS_VXWORKS               0x06000000
+ #define TMFL_OS_MTOS                  0x07000000
+ #define TMFL_OS_LINUX                 0x08000000
+ #define TMFL_SCOPE_SP                 0
+ #define TMFL_SCOPE_MP                 1
+ #define TMFL_REL_ASSERT               0x00000002
+ #define TMFL_REL_DEBUG                0x00000001
+ #define TMFL_REL_RETAIL               0x00000000
+ #define TMFL_CPU_I486                 0x00010001
+ #define TMFL_CPU_R3940                0x00020002
+ #define TMFL_CPU_R4300                0x00020003
+ #define TMFL_CPU_TM1100               0x00030004
+ #define TMFL_CPU_TM1300               0x00030005
+ #define TMFL_CPU_TM32                 0x00030006
+ #define TMFL_CPU_HP                   0x00040007
+ #define TMFL_CPU_R4640                0x00020008
+ #define TMFL_CPU_ARM7                 0x00050009
+ #define TMFL_CPU_ARM920T              0x0005000a
+ #define TMFL_CPU_ARM940T              0x0005000b
+ #define TMFL_CPU_ARM10                0x0005000c
+ #define TMFL_CPU_STRONGARM            0x0005000d
+ #define TMFL_CPU_RD24120              0x0006000e
+ #define TMFL_CPU_ARM926EJS            0x0005000f
+ #define TMFL_CPU_ARM946               0x00050010
+ #define TMFL_CPU_R1910                0x00020011
+ #define TMFL_CPU_R4450                0x00020012
+ #define TMFL_CPU_TM3260               0x00030013
+ #define TMFL_MODE_KERNEL              1
+ #define TMFL_MODE_USER                0
+
+
+/******************************************************************************/
+/* Preprocessor checks for invalid settings (if file is manually modified)    */
+/******************************************************************************/
+/*                                                                            */
+
+/* Check if TMFL_CPU flag changed from its default setting.                   */
+#if     (TMFL_CPU == (TMFL_CPU_TYPE_MASK | TMFL_CPU_MODEL_MASK))
+#error  ERROR: TMFL_CPU must be set (TMFL_CPU_TYPE_XXX | TMFL_CPU_MODEL_XXX) !
+#endif
+
+/* Check if TMFL_ENDIAN flag setting is valid.                                */
+#if     ((TMFL_ENDIAN != TMFL_ENDIAN_BIG) && (TMFL_ENDIAN != TMFL_ENDIAN_LITTLE))
+#error  ERROR: TMFL_ENDIAN must be set to a valid TMFL_ENDIAN_XXX value !
+#endif
+
+/* Check if TMFL_OS flag changed from its default setting.                    */
+#if     (TMFL_OS == (TMFL_OS_MASK | TMFL_OS_VERSION_MASK))
+#error  ERROR: TMFL_OS must be set to a valid value (TMFL_OS_<TYPE>[<VERSION>]) !
+#endif
+
+/* The TMFL_CPU_IS_XXX is a Boolean; one and only one flag can be true (=1).  */
+#if     ((TMFL_CPU_IS_X86 + TMFL_CPU_IS_MIPS + TMFL_CPU_IS_TM + TMFL_CPU_IS_HP + TMFL_CPU_IS_ARM + TMFL_CPU_IS_REAL) != 1)
+#error  ERROR: One or more TMFL_CPU_IS_XXX values are incorrect or missing !
+#endif
+
+/* TMFL_CPU and TMFL_CPU_IS_XXX must be consistent                            */
+#if     (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_X86)  && (TMFL_CPU_IS_X86 != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_X86 settings !
+#elif   (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_MIPS) && (TMFL_CPU_IS_MIPS != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_MIPS settings !
+#elif   (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_TM)   && (TMFL_CPU_IS_TM != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_TM settings !
+#elif   (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_HP)   && (TMFL_CPU_IS_HP != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_HP settings !
+#elif   (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_ARM)  && (TMFL_CPU_IS_ARM != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_ARM settings !
+#elif   (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_REAL) && (TMFL_CPU_IS_REAL != 1))
+#error  ERROR: Inconsistent TMFL_CPU and TMFL_CPU_IS_REAL settings !
+#endif /* (((TMFL_CPU & TMFL_CPU_TYPE_MASK) == TMFL_CPU_TYPE_X86) && ...      */
+
+/* The TMFL_OS_IS_XXX is a Boolean; one and only one flag can be true (=1).   */
+#if     ((TMFL_OS_IS_BTM + TMFL_OS_IS_CE + TMFL_OS_IS_NT + TMFL_OS_IS_PSOS + TMFL_OS_IS_NULLOS + TMFL_OS_IS_ECOS + TMFL_OS_IS_VXWORKS + TMFL_OS_IS_MTOS + TMFL_OS_IS_LINUX) != 1)
+#error  ERROR: One or more TMFL_OS_IS_XXX values are incorrect or missing !
+#endif
+
+#if     (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_BTM)     && (TMFL_OS_IS_BTM != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_BTM settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_CE)      && (TMFL_OS_IS_CE != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_CE settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_NT)      && (TMFL_OS_IS_NT != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_NT settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_PSOS)    && (TMFL_OS_IS_PSOS != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_PSOS settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_NULLOS)  && (TMFL_OS_IS_NULLOS != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_NULLOS settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_ECOS)    && (TMFL_OS_IS_ECOS != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_ECOS settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_VXWORKS) && (TMFL_OS_IS_VXWORKS != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_VXWORKS settings !
+#elif   (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_MTOS)    &&  (TMFL_OS_IS_MTOS != 1))
+#error  ERROR: Inconsistent TMFL_OS and TMFL_OS_IS_MTOS settings !
+#endif /* (((TMFL_OS & TMFL_OS_MASK) == TMFL_OS_XX) && (TMFL_OS_IS_XX != 1))  */
+
+#endif   /* !defined(TM_FLAGS_H)                                        */
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmNxCompId.h linux-2.6.34/include/HwAPI/tmNxCompId.h
--- linux-2.6.34.orig/include/HwAPI/tmNxCompId.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmNxCompId.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,1722 @@
+/* -------------------------------------------------------------------------- */
+/* (C) Copyright 2000-2005              Koninklijke Philips Electronics N.V., */
+/*     All rights reserved                                                    */
+/*                                                                            */
+/* This source code and any compilation or derivative thereof is the          */
+/* proprietary information of Konlinklijke Philips Electronics N.V. and is    */
+/* Confidential in nature.                                                    */
+/* Under no circumstances is this software to be exposed to or placed under an*/
+/* Open Source License of any type without the expressed written permission of*/
+/* Koninklijke Philips Electronics N.V.                                       */
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/* MoReUse - 2005-10-24   Version 118                                         */
+/*                                                                            */
+/* Added:                                                                     */
+/*    CID_AACPENC                                                             */
+/*                                                                            */
+/*                                                                            */
+/* Changed:                                                                   */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* Removed:                                                                   */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* General Error Codes Added                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+/* FILE NAME:    tmNxCompId.h                                                 */
+/*                                                                            */
+/* DESCRIPTION:  This header file identifies the standard component           */
+/*               identifiers (CIDs) and interface identifiers (IID) for       */
+/*               Nexperia platforms.                                          */
+/*               The objective of these identifiers is to enable unique       */
+/*               identification of software components and interfaces.        */
+/*               In addition, standard status values are also defined to make */
+/*               determination of typical error cases much easier.            */
+/*                                                                            */
+/*               Functional errors are not real errors in the sense of        */
+/*               unexpected behaviour but are part of the normal communication*/
+/*               between a client an a server component. They are linked to   */
+/*               an interface, rather than to a component. All implementations*/
+/*               of an interface must have the same behaviour with respect to */
+/*               functional errors. Functional erros are all positive         */
+/*               One global functional error is defined:  TM_OK 0x00000000    */
+/*                                                                            */
+/*               Non-functional errors (all negative numbers) indicate        */
+/*               unexpected behaviour. They are linked to concrete component  */
+/*               implementations                                              */
+/*                                                                            */
+/*               NOTE: The current implementation is different from the prev. */
+/*                     component identifier implementation, based on classes, */
+/*                     types and layers. However, the new system is backward  */
+/*                     compatitible with the old implementation.              */
+/*                                                                            */
+/*               tmNxCompId.h defines a number of general error codes that can*/
+/*               be used by all components. These error codes are concatenated*/
+/*               to the CID or IID value in the local component headerfile of */
+/*               the component that wants to (re-)use this general error code */
+/*               General error codes can be used for both functional and      */
+/*               non-functional errors. They should only be used if they      */
+/*               semantically fully match (if not, defined a new component or */
+/*               interface specific error code.                               */
+/*                                                                            */
+/* General Rules:                                                             */
+/*               A return value has a length of 32 bits. At the binary level, */
+/*               1 bit indicates the component or interface flag; 16 bits are */
+/*               used for the actual component id (CID) or interface id (IID) */
+/*               and 12 bits for the return status.                           */
+/*                     The component/interface flag is bit 31.                */
+/*                     Bits 30--28 are all 0.                                 */
+/*                     The component/interface id occupies bits 27--12.       */
+/*                     The return status occupies bits 11--0.                 */
+/*                                                                            */
+/*                     +--------+-----+-------+-----------+                   */
+/*                     | flag:1 | 0:3 | id:16 | status:12 |                   */
+/*                     +--------+-----+-------+-----------+                   */
+/*                                                                            */
+/*                     Format of interface ids:                               */
+/*                                                                            */
+/*                     +-----+-----+--------+-----------+                     */
+/*                     | 0:1 | 0:3 | iid:16 | status:12 |                     */
+/*                     +-----+-----+--------+-----------+                     */
+/*                                                                            */
+/*                     Format of component ids:                               */
+/*                                                                            */
+/*                     +-----+-----+--------+-----------+                     */
+/*                     | 1:1 | 0:3 | cid:16 | status:12 |                     */
+/*                     +-----+-----+--------+-----------+                     */
+/*                                                                            */
+/*               At the macro level, we use the prefix "CID_" for component   */
+/*               ids (previous version "CID_COMP_") and "IID_" for interface  */
+/*               ids.                                                         */
+/*                                                                            */
+/*               Each component id will be used by only one component; each   */
+/*               component will have its own component id.                    */
+/*               Each interface id will be used by only one interface; each   */
+/*               interface will have its own interface id.                    */
+/*                                                                            */
+/*               In order to avoid problems when promoting a UNIQUE interface */
+/*               to a SEPARATE interface, the ranges for CIDs and IIDS must   */
+/*               not overlap.                                                 */
+/*                                                                            */
+/*               Component names and component ids have to be registered      */
+/*               together; the same applies for interface names and ids.      */
+/*                                                                            */
+/*           NOTE about Compatibility                                         */
+/*               In the previous implementation the first four bits were      */
+/*               reserved for class, and there were separate fields for       */
+/*               type and tag, like this:                                     */
+/*                                                                            */
+/*                     +---------+--------+-------+---------+-----------+     */
+/*                     | class:4 | type:4 | tag:8 | layer:4 | status:12 |     */
+/*                     +---------+--------+-------+---------+-----------+     */
+/*                                                                            */
+/*               The values 0 or 8 are not valid classes, and this fact       */
+/*               can be used to distinguish a new-style IID (class == 0),     */
+/*               a new-style CID (class == 8), and an old-style CID           */
+/*               (otherwise).                                                 */
+/*                                                                            */
+/*           NOTE about error codes                                           */
+/*               The general error codes use the range 0x001 to 0x7FF.        */
+/*               The component specific error codes are defined in the        */
+/*               local component header file and can use 0x800 to 0xFFF.      */
+/*               TM_OK has the value 0x00000000.                              */
+/*               The proposed error code ranges (general and specific) are    */
+/*               the same for functional and non-functional errors.           */
+/*                                                                            */
+/*               The previously defined ranges for external customers,        */
+/*               assert errors and fatal errors have been dropped.            */
+/*               The previously defined range for general errors started      */
+/*               at 0x000 instead of 0x001                                    */
+/*                                                                            */
+/* DOCUMENT REF: Nexperia/MoReUse Naming Conventions                          */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+#ifndef TMNXCOMPID_H
+#define TMNXCOMPID_H
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*   Standard include files:                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#include "tmNxTypes.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*     General Defines                                                        */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#define CID_IID_FLAG_BITSHIFT    31
+#define CID_ID_BITSHIFT          12
+#define IID_ID_BITSHIFT          12
+
+#define CID_FLAG                 (0x1U << CID_IID_FLAG_BITSHIFT)
+#define IID_FLAG                 (0x0U << CID_IID_FLAG_BITSHIFT)
+
+#define CID_ID(number)           ((number) << CID_ID_BITSHIFT)
+#define CID_ID_BITMASK           (0x7FFFFU  << CID_ID_BITSHIFT)
+
+#define IID_ID(number)           ((number) << IID_ID_BITSHIFT)
+#define IID_ID_BITMASK           (0x7FFFFU  << IID_ID_BITSHIFT)
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*     Definition of the interface IDs                                        */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#define IID_IENUMUNKNOWN            (IID_ID(0x001U) | IID_FLAG)
+#define IID_IBIND                   (IID_ID(0x002U) | IID_FLAG)
+#define IID_IBINDINFO               (IID_ID(0x003U) | IID_FLAG)
+#define IID_IMEM                    (IID_ID(0x004U) | IID_FLAG)
+#define IID_IUNKNOWN                (IID_ID(0x005U) | IID_FLAG)
+#define IID_IIC                     (IID_ID(0x006U) | IID_FLAG)
+#define IID_ACHAN                   (IID_ID(0x007U) | IID_FLAG)
+#define IID_AFEAT                   (IID_ID(0x008U) | IID_FLAG)
+#define IID_AMIX                    (IID_ID(0x009U) | IID_FLAG)
+#define IID_ANAADEC                 (IID_ID(0x00aU) | IID_FLAG)
+#define IID_ANAVENC                 (IID_ID(0x00bU) | IID_FLAG)
+#define IID_ANAVENCRYPT             (IID_ID(0x00cU) | IID_FLAG)
+#define IID_ANAVDEC                 (IID_ID(0x00dU) | IID_FLAG)
+#define IID_BBARDETEXT              (IID_ID(0x00eU) | IID_FLAG)
+#define IID_BLEVELDETEXT            (IID_ID(0x00fU) | IID_FLAG)
+#define IID_BLEVELMODEXT            (IID_ID(0x010U) | IID_FLAG)
+#define IID_BSLSPDI                 (IID_ID(0x011U) | IID_FLAG)
+#define IID_BSLSPDO                 (IID_ID(0x012U) | IID_FLAG)
+#define IID_BSL_AI                  (IID_ID(0x013U) | IID_FLAG)
+#define IID_BSL_AO                  (IID_ID(0x014U) | IID_FLAG)
+#define IID_BSL_AVI                 (IID_ID(0X015U) | IID_FLAG)
+#define IID_BSL_AVO                 (IID_ID(0x016U) | IID_FLAG)
+#define IID_BSL_EEPROM              (IID_ID(0X017U) | IID_FLAG)
+#define IID_BSL_IDE                 (IID_ID(0X018U) | IID_FLAG)
+#define IID_BSL_NANDFLASH           (IID_ID(0X019U) | IID_FLAG)
+#define IID_BSL_NORFLASH            (IID_ID(0X01aU) | IID_FLAG)
+#define IID_BSL_PARPORT             (IID_ID(0X01bU) | IID_FLAG)
+#define IID_BSL_RTC                 (IID_ID(0X01cU) | IID_FLAG)
+#define IID_COLENH                  (IID_ID(0x01dU) | IID_FLAG)
+#define IID_COLENHEXT               (IID_ID(0x01eU) | IID_FLAG)
+#define IID_CONNMGR                 (IID_ID(0x01fU) | IID_FLAG)
+#define IID_CRT                     (IID_ID(0x020U) | IID_FLAG)
+#define IID_CTI                     (IID_ID(0X021U) | IID_FLAG)
+#define IID_CTIEXT                  (IID_ID(0X022U) | IID_FLAG)
+#define IID_DIGADEC                 (IID_ID(0X023U) | IID_FLAG)
+#define IID_DIGVDEC                 (IID_ID(0X024U) | IID_FLAG)
+#define IID_DMX                     (IID_ID(0X025U) | IID_FLAG)
+#define IID_DNR                     (IID_ID(0X026U) | IID_FLAG)
+#define IID_DNREXT                  (IID_ID(0X027U) | IID_FLAG)
+#define IID_DVBSUBTDEC              (IID_ID(0X028U) | IID_FLAG)
+#define IID_FATERR                  (IID_ID(0X029U) | IID_FLAG)
+#define IID_FREND                   (IID_ID(0X02aU) | IID_FLAG)
+#define IID_GAMMAEXT                (IID_ID(0X02bU) | IID_FLAG)
+#define IID_HISTOMEASEXT            (IID_ID(0X02cU) | IID_FLAG)
+#define IID_HISTOMODEXT             (IID_ID(0X02dU) | IID_FLAG)
+#define IID_MML                     (IID_ID(0X02eU) | IID_FLAG)
+#define IID_NOISEESTEXT             (IID_ID(0X02fU) | IID_FLAG)
+#define IID_OSAL                    (IID_ID(0X030U) | IID_FLAG)
+#define IID_PIPSTORE                (IID_ID(0X031U) | IID_FLAG)
+#define IID_SCANRATECONV            (IID_ID(0X032U) | IID_FLAG)
+#define IID_SCANRATECONVEXT         (IID_ID(0X033U) | IID_FLAG)
+#define IID_SHARPENH                (IID_ID(0X034U) | IID_FLAG)
+#define IID_SHARPENHEXT             (IID_ID(0X035U) | IID_FLAG)
+#define IID_SHARPMEASEXT            (IID_ID(0X036U) | IID_FLAG)
+#define IID_SPDIFIN                 (IID_ID(0X037U) | IID_FLAG)
+#define IID_SPDIFOUT                (IID_ID(0X038U) | IID_FLAG)
+#define IID_SPEAKER                 (IID_ID(0X039U) | IID_FLAG)
+#define IID_STCDEC                  (IID_ID(0X03aU) | IID_FLAG)
+#define IID_STREAMINJ               (IID_ID(0X03bU) | IID_FLAG)
+#define IID_SYNCTAG                 (IID_ID(0X03cU) | IID_FLAG)
+#define IID_TSSACOM                 (IID_ID(0X03dU) | IID_FLAG)
+#define IID_TXTDEC                  (IID_ID(0X03eU) | IID_FLAG)
+#define IID_UTILCRYPT               (IID_ID(0X03fU) | IID_FLAG)
+#define IID_UVBWDETEXT              (IID_ID(0X040U) | IID_FLAG)
+#define IID_VBIINSERT               (IID_ID(0X041U) | IID_FLAG)
+#define IID_VBISLICE                (IID_ID(0X042U) | IID_FLAG)
+#define IID_VDCC                    (IID_ID(0X043U) | IID_FLAG)
+#define IID_VDSTSCAN                (IID_ID(0X044U) | IID_FLAG)
+#define IID_VFEAT                   (IID_ID(0X045U) | IID_FLAG)
+#define IID_VMIX                    (IID_ID(0X046U) | IID_FLAG)
+#define IID_VSCALEEXT               (IID_ID(0X047U) | IID_FLAG)
+#define IID_VSRCPROP                (IID_ID(0X048U) | IID_FLAG)
+#define IID_VSRCSCANPROP            (IID_ID(0X049U) | IID_FLAG)
+#define IID_GENI2C                  (IID_ID(0X04aU) | IID_FLAG)
+#define IID_PLFINSTVIN              (IID_ID(0X04bU) | IID_FLAG)
+#define IID_PLFINSTAIN              (IID_ID(0X04cU) | IID_FLAG)
+#define IID_PLFINSTAOUT             (IID_ID(0X04dU) | IID_FLAG)
+#define IID_PLFINSTGFX              (IID_ID(0X04eU) | IID_FLAG)
+#define IID_CONNMGRATV              (IID_ID(0X04fU) | IID_FLAG)
+#define IID_IAMALIVE                (IID_ID(0X050U) | IID_FLAG)
+#define IID_BBARDET                 (IID_ID(0X051U) | IID_FLAG)
+#define IID_CONTRRESEXT             (IID_ID(0X052U) | IID_FLAG)
+#define IID_NOISEMEAS               (IID_ID(0X053U) | IID_FLAG)
+#define IID_SHARPMEAS               (IID_ID(0X054U) | IID_FLAG)
+#define IID_HISTOMOD                (IID_ID(0X055U) | IID_FLAG)
+#define IID_ANTIAGING               (IID_ID(0X056U) | IID_FLAG)
+#define IID_AMBIENTLEVEL            (IID_ID(0X057U) | IID_FLAG)
+#define IID_HAD_DRV_IIC             (IID_ID(0X058U) | IID_FLAG)
+#define IID_HAD_DRV_GPIO            (IID_ID(0X059U) | IID_FLAG)
+#define IID_HAD_DRV_CSM             (IID_ID(0X05aU) | IID_FLAG)
+#define IID_DRIVERHAL               (IID_ID(0X05bU) | IID_FLAG)
+#define IID_MUTISTR                 (IID_ID(0X05cU) | IID_FLAG)
+#define IID_MUTIVEC                 (IID_ID(0X05dU) | IID_FLAG)
+#define IID_MUTISTRX                (IID_ID(0X05eU) | IID_FLAG)
+#define IID_MUTICMD                 (IID_ID(0X05fU) | IID_FLAG)
+#define IID_TASK_CONDITION          (IID_ID(0X060U) | IID_FLAG)
+#define IID_PACKET_POOL             (IID_ID(0X061U) | IID_FLAG)
+#define IID_PACKET_QUEUE            (IID_ID(0X062U) | IID_FLAG)
+#define IID_UDSDCD                  (IID_ID(0X063U) | IID_FLAG)
+#define IID_DCSS_RL                 (IID_ID(0X064U) | IID_FLAG)
+#define IID_DCSS_DD                 (IID_ID(0X065U) | IID_FLAG)
+#define IID_DCSS_GD                 (IID_ID(0X066U) | IID_FLAG)
+#define IID_DCSS_RSC                (IID_ID(0X067U) | IID_FLAG)
+#define IID_DCSS_P                  (IID_ID(0X068U) | IID_FLAG)
+#define IID_DCSS                    (IID_ID(0X069U) | IID_FLAG)
+#define IID_CC_BURST_CUTTING_AREA   (IID_ID(0X06aU) | IID_FLAG)
+#define IID_CC_CONFIGURATION        (IID_ID(0X06bU) | IID_FLAG)
+#define IID_CC_CONTROL              (IID_ID(0X06cU) | IID_FLAG)
+#define IID_CC_DEBUG                (IID_ID(0X06dU) | IID_FLAG)
+#define IID_CC_DECODER              (IID_ID(0X06eU) | IID_FLAG)
+#define IID_CC_ENCODER              (IID_ID(0X06fU) | IID_FLAG)
+#define IID_CC_HF_PROCESSING        (IID_ID(0X070U) | IID_FLAG)
+#define IID_CC_INTERFACE            (IID_ID(0X071U) | IID_FLAG)
+#define IID_CC_NATLAB               (IID_ID(0X072U) | IID_FLAG)
+#define IID_CC_PIC                  (IID_ID(0X073U) | IID_FLAG)
+#define IID_CC_WOBBLE               (IID_ID(0X074U) | IID_FLAG)
+#define IID_CC_REGISTERMAP          (IID_ID(0X075U) | IID_FLAG)
+#define IID_CC_WOBBLE_REG           (IID_ID(0X076U) | IID_FLAG)
+#define IID_CC_PIC_REG              (IID_ID(0X077U) | IID_FLAG)
+#define IID_CC_NATLAB_REG           (IID_ID(0X078U) | IID_FLAG)
+#define IID_CC_INTERFACE_REG        (IID_ID(0X079U) | IID_FLAG)
+#define IID_CC_HF_PROCESSING_REG    (IID_ID(0X07aU) | IID_FLAG)
+#define IID_CC_ENCODER_REG          (IID_ID(0X07bU) | IID_FLAG)
+#define IID_CC_DECODER_REG          (IID_ID(0X07cU) | IID_FLAG)
+#define IID_CC_DEBUG_REG            (IID_ID(0X07dU) | IID_FLAG)
+#define IID_CC_CONTROL_REG          (IID_ID(0X07eU) | IID_FLAG)
+#define IID_CC_CONFIGURATION_REG    (IID_ID(0X07fU) | IID_FLAG)
+#define IID_CC_BURST_CUTTING_AREA_REG (IID_ID(0X080U) | IID_FLAG)
+#define IID_CC_PHYSICAL_VALUES      (IID_ID(0X081U) | IID_FLAG)
+#define IID_CC_GENERAL_SETTINGS     (IID_ID(0X082U) | IID_FLAG)
+#define IID_CC_COEFFICIENTS         (IID_ID(0X083U) | IID_FLAG)
+#define IID_REMOTE_CONTROL          (IID_ID(0X084U) | IID_FLAG)
+#define IID_TUNER                   (IID_ID(0X085U) | IID_FLAG)
+#define IID_MUTITST                 (IID_ID(0X086U) | IID_FLAG)
+#define IID_CHIP_CONTEXT            (IID_ID(0X087U) | IID_FLAG)
+#define IID_API                     (IID_ID(0X088U) | IID_FLAG)
+#define IID_CHANDEC                 (IID_ID(0X089U) | IID_FLAG)
+#define IID_TUNING                  (IID_ID(0X08aU) | IID_FLAG)
+#define IID_TUNINGAFC               (IID_ID(0X08bU) | IID_FLAG)
+#define IID_TUNINGAFCNTF            (IID_ID(0X08cU) | IID_FLAG)
+#define IID_TUNINGCHAN              (IID_ID(0X08dU) | IID_FLAG)
+#define IID_TUNINGSEARCHNTF         (IID_ID(0X08eU) | IID_FLAG)
+#define IID_ID3EXTR                 (IID_ID(0X08fU) | IID_FLAG)
+#define IID_ANAAVDEM                (IID_ID(0X090U) | IID_FLAG)
+#define IID_ANAAVDEMNTF             (IID_ID(0X091U) | IID_FLAG)
+#define IID_CCEXTR                  (IID_ID(0X092U) | IID_FLAG)
+#define IID_CHANDECDVBC             (IID_ID(0X093U) | IID_FLAG)
+#define IID_CHANDECDVBS             (IID_ID(0X094U) | IID_FLAG)
+#define IID_CHANDECDVBT             (IID_ID(0X095U) | IID_FLAG)
+#define IID_CHANDECNTF              (IID_ID(0X096U) | IID_FLAG)
+#define IID_OOB                     (IID_ID(0X097U) | IID_FLAG)
+#define IID_RFAMP                   (IID_ID(0X098U) | IID_FLAG)
+#define IID_SIGSTRENGTH             (IID_ID(0X099U) | IID_FLAG)
+#define IID_SIGSTRENGTHNTF          (IID_ID(0X09aU) | IID_FLAG)
+#define IID_IMAGEDEC                (IID_ID(0X09bU) | IID_FLAG)
+#define IID_TUNINGSEARCH            (IID_ID(0X09cU) | IID_FLAG)
+#define IID_PINOBJECTS              (IID_ID(0X09dU) | IID_FLAG)
+#define IID_URLSRC                  (IID_ID(0X09eU) | IID_FLAG)
+#define IID_OSDKERNELAPP            (IID_ID(0X09fU) | IID_FLAG)         
+#define IID_OSDKERNELMEM            (IID_ID(0X0a0U) | IID_FLAG)
+#define IID_OSDKERNELOSD            (IID_ID(0X0a1U) | IID_FLAG)
+#define IID_OSDKERNELOSDCONTROL     (IID_ID(0X0a2U) | IID_FLAG)
+#define IID_RTC                     (IID_ID(0X0a3U) | IID_FLAG)
+#define IID_FS                      (IID_ID(0X0a4U) | IID_FLAG)
+#define IID_BE                      (IID_ID(0X0a5U) | IID_FLAG)
+#define IID_CD_LIB                  (IID_ID(0X0a6U) | IID_FLAG)
+#define IID_DB                      (IID_ID(0X0a7U) | IID_FLAG)
+#define IID_AVIN                    (IID_ID(0X0a8U) | IID_FLAG)
+#define IID_AVOUT                   (IID_ID(0X0a9U) | IID_FLAG)
+#define IID_INT                     (IID_ID(0X0aaU) | IID_FLAG)
+#define IID_EVT                     (IID_ID(0X0abU) | IID_FLAG)
+#define IID_DMA                     (IID_ID(0X0acU) | IID_FLAG)
+#define IID_CLK                     (IID_ID(0X0adU) | IID_FLAG)
+#define IID_VMIXBORDERPAINTER       (IID_ID(0X0aeU) | IID_FLAG)
+#define IID_CPROCTVFLOW             (IID_ID(0X0afU) | IID_FLAG)
+#define IID_VTRANTIAGING            (IID_ID(0X0b0U) | IID_FLAG)
+#define IID_VTRFADE                 (IID_ID(0X0b1U) | IID_FLAG)
+#define IID_VTRSCALE                (IID_ID(0X0b2U) | IID_FLAG)
+#define IID_VTRSTROBE               (IID_ID(0X0b3U) | IID_FLAG)
+#define IID_HDMIIN                  (IID_ID(0X0b4U) | IID_FLAG)
+#define IID_ACHANSEL                (IID_ID(0X0b5U) | IID_FLAG)
+#define IID_SSP                     (IID_ID(0X0b6U) | IID_FLAG)
+#define IID_CONNMGR_STILL           (IID_ID(0X0b7U) | IID_FLAG)
+#define IID_CONNMGR_AUDIO           (IID_ID(0X0b8U) | IID_FLAG)
+#define IID_CONNMGR_MPEG2PS         (IID_ID(0X0b9U) | IID_FLAG)
+#define IID_SPI_SD                  (IID_ID(0X0baU) | IID_FLAG)
+#define IID_DECODERHALCST           (IID_ID(0X0bbU) | IID_FLAG)
+#define IID_SOD                     (IID_ID(0X0bcU) | IID_FLAG)
+#define IID_DCSS_AA                 (IID_ID(0X0bdU) | IID_FLAG)
+#define IID_DCSS_AVI                (IID_ID(0X0beU) | IID_FLAG)
+#define IID_DCSS_BC                 (IID_ID(0X0bfU) | IID_FLAG)
+#define IID_DCSS_CLUT               (IID_ID(0X0c0U) | IID_FLAG)
+#define IID_DCSS_COL                (IID_ID(0X0c1U) | IID_FLAG)
+#define IID_DCSS_DFC                (IID_ID(0X0c2U) | IID_FLAG)
+#define IID_DCSS_DOC                (IID_ID(0X0c3U) | IID_FLAG)
+#define IID_DCSS_GIO                (IID_ID(0X0c4U) | IID_FLAG)
+#define IID_DCSS_ISD                (IID_ID(0X0c5U) | IID_FLAG)
+#define IID_DCSS_KBI                (IID_ID(0X0c6U) | IID_FLAG)
+#define IID_DCSS_OSD                (IID_ID(0X0c7U) | IID_FLAG)
+#define IID_DCSS_PIF                (IID_ID(0X0c8U) | IID_FLAG)
+#define IID_DCSS_PVI                (IID_ID(0X0c9U) | IID_FLAG)
+#define IID_DCSS_SIS                (IID_ID(0X0caU) | IID_FLAG)
+#define IID_DCSS_TIG                (IID_ID(0X0cbU) | IID_FLAG)
+#define IID_DCSS_USC                (IID_ID(0X0ccU) | IID_FLAG)
+#define IID_DCSS_VCR                (IID_ID(0X0cdU) | IID_FLAG)
+#define IID_CONNMGR_MP4RTP_PLAYER   (IID_ID(0X0ceU) | IID_FLAG)
+#define IID_CONNMGR_AVIMP4_PLAYER   (IID_ID(0X0cfU) | IID_FLAG)
+#define IID_VDECANAEXT2             (IID_ID(0X0d0U) | IID_FLAG)
+#define IID_STBCOMMON               (IID_ID(0X0d1U) | IID_FLAG)
+#define IID_AVSYNCCTRL              (IID_ID(0X0d2U) | IID_FLAG)
+#define IID_PRIVNETSCHEMECONFIG     (IID_ID(0X0d3U) | IID_FLAG)
+#define IID_SHAREDVARIABLE          (IID_ID(0X0d4U) | IID_FLAG)
+#define IID_NETSCHEMECONFIG         (IID_ID(0X0d5U) | IID_FLAG)
+#define IID_AVSYNCTRICK             (IID_ID(0X0d6U) | IID_FLAG)
+#define IID_SETINTF                 (IID_ID(0X0d7U) | IID_FLAG)
+#define IID_URLDMXMONITOR           (IID_ID(0X0d8U) | IID_FLAG)
+#define IID_VDECMONITOR             (IID_ID(0X0d9U) | IID_FLAG)
+#define IID_STBVIDEOTYPES           (IID_ID(0X0daU) | IID_FLAG)
+
+#define IID_RESERVED                (CID_ID(0x7fffU) | CID_FLAG)
+/* ************************************************************************** */
+/* Interface Id's reserved for external organizations                         */
+/*                                                                            */
+/*  None                                                                      */
+/*                                                                            */
+/* ************************************************************************** */
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*     Definition of the component IDs                                        */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#define CID_MPMP1_GRINDER           (CID_ID(0x8001U) | CID_FLAG)
+#define CID_MUSB_GRINDER            (CID_ID(0x8002U) | CID_FLAG)
+#define CID_UOTGPFL                 (CID_ID(0x8003U) | CID_FLAG)
+#define CID_CHIPBUILDER_GRINDER     (CID_ID(0x8004U) | CID_FLAG)
+
+#define CID_AANALYZER               (CID_ID(0x8009U) | CID_FLAG)
+#define CID_ADEC_AAC4               (CID_ID(0x800aU) | CID_FLAG)
+#define CID_ADEC_ATV                (CID_ID(0x800bU) | CID_FLAG)
+#define CID_ADEC_CELP4              (CID_ID(0x800cU) | CID_FLAG)
+#define CID_ADEC_CORE               (CID_ID(0x800dU) | CID_FLAG)
+#define CID_ADEC_MP3PRO             (CID_ID(0x800eU) | CID_FLAG)
+#define CID_ADEC_PL2                (CID_ID(0x800fU) | CID_FLAG)
+#define CID_ADEC_STB                (CID_ID(0x8010U) | CID_FLAG)
+#define CID_ADEEMPH                 (CID_ID(0x8011U) | CID_FLAG)
+#define CID_AENCAAC4                (CID_ID(0x8012U) | CID_FLAG)
+#define CID_AREND_AO_MUX            (CID_ID(0x8013U) | CID_FLAG)
+#define CID_ASP_IIRZ2               (CID_ID(0x8014U) | CID_FLAG)
+#define CID_ASRC                    (CID_ID(0x8015U) | CID_FLAG)
+#define CID_ASYS_CORE               (CID_ID(0x8016U) | CID_FLAG)
+#define CID_ATV_PLF_BASIC           (CID_ID(0x8017U) | CID_FLAG)
+#define CID_ATV_STUBS               (CID_ID(0x8018U) | CID_FLAG)
+#define CID_AVI_READ_DIVX           (CID_ID(0x8019U) | CID_FLAG)
+#define CID_BOOTINFO                (CID_ID(0x801aU) | CID_FLAG)
+#define CID_BROWSE_EIS              (CID_ID(0x801bU) | CID_FLAG)
+#define CID_BSL_7113                (CID_ID(0x801cU) | CID_FLAG)
+#define CID_BSL_7113QT              (CID_ID(0x801dU) | CID_FLAG)
+#define CID_BSL_7114                (CID_ID(0x801eU) | CID_FLAG)
+#define CID_BSL_7118                (CID_ID(0x801fU) | CID_FLAG)
+#define CID_BSL_ANABEL              (CID_ID(0x8020U) | CID_FLAG)
+#define CID_BSL_ANABELQT            (CID_ID(0x8021U) | CID_FLAG)
+#define CID_BSL_AVIP                (CID_ID(0x8022U) | CID_FLAG)
+#define CID_BSL_BOARDS              (CID_ID(0x8023U) | CID_FLAG)
+#define CID_BSL_CORE                (CID_ID(0x8024U) | CID_FLAG)
+#define CID_BSL_DENC                (CID_ID(0x8025U) | CID_FLAG)
+#define CID_BSL_EEPROM_ATMEL        (CID_ID(0x8026U) | CID_FLAG)
+#define CID_BSL_IDEXIO              (CID_ID(0x8027U) | CID_FLAG)
+#define CID_BSL_NANDSAMSUNG         (CID_ID(0x8028U) | CID_FLAG)
+#define CID_BSL_NORINTEL            (CID_ID(0x8029U) | CID_FLAG)
+#define CID_BSL_RTCPCF8563          (CID_ID(0x802aU) | CID_FLAG)
+#define CID_BSL_UART_HWAPI          (CID_ID(0x802bU) | CID_FLAG)
+#define CID_BSL_UDA1344             (CID_ID(0x802cU) | CID_FLAG)
+#define CID_BT_1500                 (CID_ID(0x802dU) | CID_FLAG)
+#define CID_BT_API                  (CID_ID(0x802eU) | CID_FLAG)
+#define CID_BT_CORE                 (CID_ID(0x802fU) | CID_FLAG)
+#define CID_BT_CPU                  (CID_ID(0x8030U) | CID_FLAG)
+#define CID_BT_MIPS                 (CID_ID(0x8031U) | CID_FLAG)
+#define CID_BT_TRIMEDIA             (CID_ID(0x8032U) | CID_FLAG)
+#define CID_BT_V2PCI                (CID_ID(0x8033U) | CID_FLAG)
+#define CID_BT_VPCI                 (CID_ID(0x8034U) | CID_FLAG)
+#define CID_BT_VSTB                 (CID_ID(0x8035U) | CID_FLAG)
+#define CID_BUFFEREDREAD            (CID_ID(0x8036U) | CID_FLAG)
+#define CID_CONN_MGRAUDSYSSTB       (CID_ID(0x8037U) | CID_FLAG)
+#define CID_DEMUXMPEGTS_SW          (CID_ID(0x8038U) | CID_FLAG)
+#define CID_DIG_ADEC_AUDSYS_STB     (CID_ID(0x8039U) | CID_FLAG)
+#define CID_DL_AI                   (CID_ID(0x803aU) | CID_FLAG)
+#define CID_DL_AICP                 (CID_ID(0x803bU) | CID_FLAG)
+#define CID_DL_AO                   (CID_ID(0x803cU) | CID_FLAG)
+#define CID_DL_AVFS                 (CID_ID(0x803dU) | CID_FLAG)
+#define CID_DL_CLOCK                (CID_ID(0x803eU) | CID_FLAG)
+#define CID_DL_DFS                  (CID_ID(0x803fU) | CID_FLAG)
+#define CID_DL_DISKSCHED            (CID_ID(0x8040U) | CID_FLAG)
+#define CID_DL_DMA                  (CID_ID(0x8041U) | CID_FLAG)
+#define CID_DL_ETH_IP3902           (CID_ID(0x8042U) | CID_FLAG)
+#define CID_DL_GPIO                 (CID_ID(0x8043U) | CID_FLAG)
+#define CID_DL_I2C                  (CID_ID(0x8044U) | CID_FLAG)
+#define CID_DL_IDE                  (CID_ID(0x8045U) | CID_FLAG)
+#define CID_DL_IDESTUB              (CID_ID(0x8046U) | CID_FLAG)
+#define CID_DL_IIC                  (CID_ID(0x8047U) | CID_FLAG)
+#define CID_DL_IR                   (CID_ID(0x8048U) | CID_FLAG)
+#define CID_DL_MBS                  (CID_ID(0x8049U) | CID_FLAG)
+#define CID_DL_MBS2                 (CID_ID(0x804aU) | CID_FLAG)
+#define CID_DL_NANDFLASH            (CID_ID(0x804bU) | CID_FLAG)
+#define CID_DL_NORFLASH             (CID_ID(0x804cU) | CID_FLAG)
+#define CID_DL_PCI                  (CID_ID(0x804dU) | CID_FLAG)
+#define CID_DL_PROCESSOR            (CID_ID(0x804eU) | CID_FLAG)
+#define CID_DL_QTNR                 (CID_ID(0x804fU) | CID_FLAG)
+#define CID_DL_QVCP                 (CID_ID(0x8050U) | CID_FLAG)
+#define CID_DL_SEM                  (CID_ID(0x8051U) | CID_FLAG)
+#define CID_DL_SPDI                 (CID_ID(0x8052U) | CID_FLAG)
+#define CID_DL_SPDO                 (CID_ID(0x8053U) | CID_FLAG)
+#define CID_DL_TIMER                (CID_ID(0x8054U) | CID_FLAG)
+#define CID_DL_TSDMA                (CID_ID(0x8055U) | CID_FLAG)
+#define CID_DL_TSIO                 (CID_ID(0x8056U) | CID_FLAG)
+#define CID_DL_UDMA                 (CID_ID(0x8057U) | CID_FLAG)
+#define CID_DL_VID_MEAS             (CID_ID(0x8058U) | CID_FLAG)
+#define CID_DL_VIP                  (CID_ID(0x8059U) | CID_FLAG)
+#define CID_DL_VMPG                 (CID_ID(0x805aU) | CID_FLAG)
+#define CID_DL_XIO                  (CID_ID(0x805bU) | CID_FLAG)
+#define CID_DRAWTEXT                (CID_ID(0x805cU) | CID_FLAG)
+#define CID_DVPDEBUG                (CID_ID(0x805dU) | CID_FLAG)
+#define CID_FATALERROR              (CID_ID(0x805eU) | CID_FLAG)
+#define CID_FATALERROR_VT           (CID_ID(0x805fU) | CID_FLAG)
+#define CID_FREADAVPROP             (CID_ID(0x8060U) | CID_FLAG)
+#define CID_FWRITEAVPROP            (CID_ID(0x8061U) | CID_FLAG)
+#define CID_HELP                    (CID_ID(0x8062U) | CID_FLAG)
+#define CID_HTTP_IO_DRIVER          (CID_ID(0x8063U) | CID_FLAG)
+#define CID_HW_AICP                 (CID_ID(0x8064U) | CID_FLAG)
+#define CID_HW_CLOCK                (CID_ID(0x8065U) | CID_FLAG)
+#define CID_HW_DMA                  (CID_ID(0x8066U) | CID_FLAG)
+#define CID_HW_DRAW                 (CID_ID(0x8067U) | CID_FLAG)
+#define CID_HW_DRAWCOMMON           (CID_ID(0x8068U) | CID_FLAG)
+#define CID_HW_DRAWDE               (CID_ID(0x8069U) | CID_FLAG)
+#define CID_HW_DRAWREF              (CID_ID(0x806aU) | CID_FLAG)
+#define CID_HW_DRAWSHARED           (CID_ID(0x806bU) | CID_FLAG)
+#define CID_HW_DRAWTMH              (CID_ID(0x806cU) | CID_FLAG)
+#define CID_HW_DRAWTMT              (CID_ID(0x806dU) | CID_FLAG)
+#define CID_HW_DRAWTMTH             (CID_ID(0x806eU) | CID_FLAG)
+#define CID_HW_DSP                  (CID_ID(0x806fU) | CID_FLAG)
+#define CID_HW_ETH_IP3902           (CID_ID(0x8070U) | CID_FLAG)
+#define CID_HW_GIC                  (CID_ID(0x8071U) | CID_FLAG)
+#define CID_HW_GPIO                 (CID_ID(0x8072U) | CID_FLAG)
+#define CID_HW_I2C                  (CID_ID(0x8073U) | CID_FLAG)
+#define CID_HW_IIC                  (CID_ID(0x8074U) | CID_FLAG)
+#define CID_HW_MBS                  (CID_ID(0x8075U) | CID_FLAG)
+#define CID_HW_MMIARB               (CID_ID(0x8076U) | CID_FLAG)
+#define CID_HW_MMIARB1010           (CID_ID(0x8077U) | CID_FLAG)
+#define CID_HW_PCI                  (CID_ID(0x8078U) | CID_FLAG)
+#define CID_HW_PIC                  (CID_ID(0x8079U) | CID_FLAG)
+#define CID_HW_SMC                  (CID_ID(0x807aU) | CID_FLAG)
+#define CID_HW_TSDMA                (CID_ID(0x807bU) | CID_FLAG)
+#define CID_HW_UART                 (CID_ID(0x807cU) | CID_FLAG)
+#define CID_HW_UDMA                 (CID_ID(0x807dU) | CID_FLAG)
+#define CID_HW_VIP                  (CID_ID(0x807eU) | CID_FLAG)
+#define CID_HW_VMSP                 (CID_ID(0x807fU) | CID_FLAG)
+#define CID_HW_XIO                  (CID_ID(0x8080U) | CID_FLAG)
+#define CID_INFRA_MISC              (CID_ID(0x8081U) | CID_FLAG)
+#define CID_INTERRUPT               (CID_ID(0x8082U) | CID_FLAG)
+#define CID_IPC_DT                  (CID_ID(0x8083U) | CID_FLAG)
+#define CID_IPC_READ                (CID_ID(0x8084U) | CID_FLAG)
+#define CID_IPC_RPC                 (CID_ID(0x8085U) | CID_FLAG)
+#define CID_IPC_WRITE               (CID_ID(0x8086U) | CID_FLAG)
+#define CID_LIBLOAD_TM              (CID_ID(0x8087U) | CID_FLAG)
+#define CID_MEMDBG                  (CID_ID(0x8088U) | CID_FLAG)
+#define CID_MENU                    (CID_ID(0x8089U) | CID_FLAG)
+#define CID_MP4READ                 (CID_ID(0x808aU) | CID_FLAG)
+#define CID_MPEGCOLORBAR            (CID_ID(0x808bU) | CID_FLAG)
+#define CID_NETSTACK_FUSION         (CID_ID(0x808cU) | CID_FLAG)
+#define CID_NETSTACK_TARGET_TCP     (CID_ID(0x808dU) | CID_FLAG)
+#define CID_NETSTACK_UPNP_ALLEGRO   (CID_ID(0x808dU) | CID_FLAG)
+#define CID_NETSTACK_UPNP_INTEL     (CID_ID(0x808eU) | CID_FLAG)
+#define CID_NETWORKREAD             (CID_ID(0x8090U) | CID_FLAG)
+#define CID_NM_COMMON               (CID_ID(0x8091U) | CID_FLAG)
+#define CID_NM_DEI                  (CID_ID(0x8092U) | CID_FLAG)
+#define CID_NM_EST                  (CID_ID(0x8093U) | CID_FLAG)
+#define CID_NM_QFD                  (CID_ID(0x8094U) | CID_FLAG)
+#define CID_NM_UPC                  (CID_ID(0x8095U) | CID_FLAG)
+#define CID_NM_UPC_SPIDER           (CID_ID(0x8096U) | CID_FLAG)
+#define CID_OS                      (CID_ID(0x8097U) | CID_FLAG)
+#define CID_PROBE                   (CID_ID(0x8098U) | CID_FLAG)
+#define CID_PSIUTIL                 (CID_ID(0x8099U) | CID_FLAG)
+#define CID_REALNETWORKS_ENGINE     (CID_ID(0x809aU) | CID_FLAG)
+#define CID_SCAN_RATE_CONV_VSYS_TV  (CID_ID(0x809bU) | CID_FLAG)
+#define CID_SPOSAL                  (CID_ID(0x809cU) | CID_FLAG)
+#define CID_TIMEDOCTOR              (CID_ID(0x809dU) | CID_FLAG)
+#define CID_TSA_CLOCK               (CID_ID(0x809eU) | CID_FLAG)
+
+#define CID_TST_AVETC_SINK          (CID_ID(0x80a0U) | CID_FLAG)
+#define CID_TST_DEMUX               (CID_ID(0x80a1U) | CID_FLAG)
+#define CID_TST_DEMUX_FOR_MUX       (CID_ID(0x80a2U) | CID_FLAG)
+#define CID_TST_SPTS_SINK           (CID_ID(0x80a3U) | CID_FLAG)
+#define CID_TTI_UTIL                (CID_ID(0x80a4U) | CID_FLAG)
+#define CID_UART                    (CID_ID(0x80a5U) | CID_FLAG)
+#define CID_UPCONV100MC             (CID_ID(0x80a6U) | CID_FLAG)
+#define CID_UTILCPIREC              (CID_ID(0x80a7U) | CID_FLAG)
+#define CID_UTILCRYPTRIJNDAEL       (CID_ID(0x80a8U) | CID_FLAG)
+#define CID_VATV                    (CID_ID(0x80a9U) | CID_FLAG)
+#define CID_VATV_TR                 (CID_ID(0x80aaU) | CID_FLAG)
+#define CID_VBI_INSERT_VSYS_TV      (CID_ID(0x80abU) | CID_FLAG)
+#define CID_VCAP_VIP2               (CID_ID(0x80acU) | CID_FLAG)
+#define CID_VDEC_BMP                (CID_ID(0x80adU) | CID_FLAG)
+#define CID_VDEC_DIVX               (CID_ID(0x80aeU) | CID_FLAG)
+#define CID_VDEC_GIF                (CID_ID(0x80afU) | CID_FLAG)
+#define CID_VDEC_JPEG               (CID_ID(0x80b0U) | CID_FLAG)
+#define CID_VDEC_JPEG2K             (CID_ID(0x80b1U) | CID_FLAG)
+#define CID_VDEC_MP                 (CID_ID(0x80b2U) | CID_FLAG)
+#define CID_VDECMPEG4               (CID_ID(0x80b3U) | CID_FLAG)
+#define CID_VENC_MPEG4              (CID_ID(0x80b4U) | CID_FLAG)
+#define CID_VENCMJPEG               (CID_ID(0x80b5U) | CID_FLAG)
+#define CID_VENCMPEG2               (CID_ID(0x80b6U) | CID_FLAG)
+#define CID_VIDEOUTIL               (CID_ID(0x80b7U) | CID_FLAG)
+#define CID_VPACK                   (CID_ID(0x80b8U) | CID_FLAG)
+#define CID_VPIP_REC_PLAY           (CID_ID(0x80b9U) | CID_FLAG)
+#define CID_VPOST_ICP               (CID_ID(0x80baU) | CID_FLAG)
+#define CID_VREND_VCP               (CID_ID(0x80bbU) | CID_FLAG)
+#define CID_VRENDVO                 (CID_ID(0x80bcU) | CID_FLAG)
+#define CID_VSCHED                  (CID_ID(0x80bdU) | CID_FLAG)
+#define CID_VTBLBASE                (CID_ID(0x80beU) | CID_FLAG)
+#define CID_VTRANS_MBS2             (CID_ID(0x80bfU) | CID_FLAG)
+#define CID_VTRANS_QTNR             (CID_ID(0x80c0U) | CID_FLAG)
+#define CID_VXWORKS_BSP             (CID_ID(0x80c1U) | CID_FLAG)
+#define CID_WREAD                   (CID_ID(0x80c2U) | CID_FLAG)
+#define CID_CONNMGR_ATV             (CID_ID(0x80c3U) | CID_FLAG)
+#define CID_DL_VPK                  (CID_ID(0x80c4U) | CID_FLAG)
+#define CID_VTRANS_VPK              (CID_ID(0x80c5U) | CID_FLAG)
+#define CID_DL_VIP2                 (CID_ID(0x80c6U) | CID_FLAG)
+#define CID_VX_GEN_UART             (CID_ID(0x80c7U) | CID_FLAG)
+#define CID_VX_GPIO                 (CID_ID(0x80c8U) | CID_FLAG)
+#define CID_VX_GEN_TIMER            (CID_ID(0x80c9U) | CID_FLAG)
+#define CID_M4VENC_DIS              (CID_ID(0x80caU) | CID_FLAG)
+#define CID_VENC_ANA                (CID_ID(0x80cbU) | CID_FLAG)
+#define CID_BSL_VENC_ANA            (CID_ID(0x80ccU) | CID_FLAG)
+#define CID_BSL_VENC_ANA_EXT        (CID_ID(0x80cdU) | CID_FLAG)
+#define CID_BSL_VENC_ANAVBI_EXT     (CID_ID(0x80ceU) | CID_FLAG)
+#define CID_CMDX                    (CID_ID(0x80cfU) | CID_FLAG)
+#define CID_LL_GPIO                 (CID_ID(0x80d0U) | CID_FLAG)
+#define CID_LL_KEYPAD               (CID_ID(0x80d1U) | CID_FLAG)
+#define CID_LL_TIMER                (CID_ID(0x80d2U) | CID_FLAG)
+#define CID_LL_SPI                  (CID_ID(0x80d3U) | CID_FLAG)
+#define CID_LL_UART                 (CID_ID(0x80d4U) | CID_FLAG)
+#define CID_LL_I2C                  (CID_ID(0x80d5U) | CID_FLAG)
+#define CID_LL_TR                   (CID_ID(0x80d6U) | CID_FLAG)
+#define CID_HW_KEYPAD               (CID_ID(0x80d7U) | CID_FLAG)
+#define CID_HW_TIMER                (CID_ID(0x80d8U) | CID_FLAG)
+#define CID_HW_SPI                  (CID_ID(0x80d9U) | CID_FLAG)
+#define CID_HW_VATV_IOSYNC          (CID_ID(0x80daU) | CID_FLAG)
+#define CID_DL_VO                   (CID_ID(0x80dbU) | CID_FLAG)
+#define CID_DL_LVDS                 (CID_ID(0x80dcU) | CID_FLAG)
+#define CID_HW_DDR2031              (CID_ID(0x80ddU) | CID_FLAG)
+#define CID_BSL_PHY                 (CID_ID(0x80deU) | CID_FLAG)
+#define CID_ETH_TTCP                (CID_ID(0x80dfU) | CID_FLAG)
+#define CID_CDIGADEC_MP3PRO         (CID_ID(0x80e0U) | CID_FLAG)
+#define CID_CID3EXTR                (CID_ID(0x80e1U) | CID_FLAG)
+#define CID_IMAGEDEC_JPEG           (CID_ID(0x80e2U) | CID_FLAG)
+#define CID_CURLSRC_MP3PRO          (CID_ID(0x80e3U) | CID_FLAG)
+#define CID_CURLSRC_IMAGEDEC        (CID_ID(0x80e4U) | CID_FLAG)
+#define CID_DVP_MAIN                (CID_ID(0x80e5U) | CID_FLAG)
+#define CID_TMMAN32                 (CID_ID(0x80e6U) | CID_FLAG)
+#define CID_TMMAN_CRT               (CID_ID(0x80e7U) | CID_FLAG)
+#define CID_UHS_HAL_PCI             (CID_ID(0x80e8U) | CID_FLAG)
+#define CID_UHS_OSAL_VXWORKS        (CID_ID(0x80e9U) | CID_FLAG)
+#define CID_UHS_OSAL_PSOS           (CID_ID(0x80eaU) | CID_FLAG)
+#define CID_UHS_USBD                (CID_ID(0x80ebU) | CID_FLAG)
+#define CID_UHS_RBC                 (CID_ID(0x80ecU) | CID_FLAG)
+#define CID_UHS_UFI                 (CID_ID(0x80edU) | CID_FLAG)
+#define CID_UHS_SCSI                (CID_ID(0x80eeU) | CID_FLAG)
+#define CID_UHS_PRINTER             (CID_ID(0x80efU) | CID_FLAG)
+#define CID_UHS_MOUSE               (CID_ID(0x80f0U) | CID_FLAG)
+#define CID_UHS_KEYBOARD            (CID_ID(0x80f1U) | CID_FLAG)
+#define CID_UHS_HUB                 (CID_ID(0x80f2U) | CID_FLAG)
+#define CID_UHS_HCD_1561            (CID_ID(0x80f3U) | CID_FLAG)
+#define CID_CLEANUP                 (CID_ID(0x80f4U) | CID_FLAG)
+#define CID_ALLOCATOR               (CID_ID(0x80f5U) | CID_FLAG)
+#define CID_TCS_CORE_LIBDEV         (CID_ID(0x80f6U) | CID_FLAG)
+#define CID_VDI_VDO_ROUTER          (CID_ID(0x80f7U) | CID_FLAG)
+#define CID_CONNMGR_ATSC            (CID_ID(0x80f8U) | CID_FLAG)
+#define CID_ASPDIF                  (CID_ID(0x80f9U) | CID_FLAG)
+#define CID_APLL                    (CID_ID(0x80faU) | CID_FLAG)
+#define CID_ATVPLFINSTVIN           (CID_ID(0x80fbU) | CID_FLAG)
+#define CID_ATV_PLF                 (CID_ID(0x80fcU) | CID_FLAG)
+#define CID_DL_WATCHDOG             (CID_ID(0x80fdU) | CID_FLAG)
+#define CID_WMT_NET_READER          (CID_ID(0x80feU) | CID_FLAG)
+#define CID_DL_FGPO                 (CID_ID(0x80ffU) | CID_FLAG)
+#define CID_DL_FGPI                 (CID_ID(0x8100U) | CID_FLAG)
+#define CID_WMT_DECODER             (CID_ID(0x8101U) | CID_FLAG)
+#define CID_HAD_DRV_IIC             (CID_ID(0x8102U) | CID_FLAG)
+#define CID_HAD_DRV_GPIO            (CID_ID(0x8103U) | CID_FLAG)
+#define CID_HAD_GLOBAL              (CID_ID(0x8104U) | CID_FLAG)
+#define CID_HAD_SMM                 (CID_ID(0x8105U) | CID_FLAG)
+#define CID_HAD_DRV_CSM             (CID_ID(0x8106U) | CID_FLAG)
+#define CID_CARACASWDOG             (CID_ID(0x8107U) | CID_FLAG)
+#define CID_CARACASADC              (CID_ID(0x8108U) | CID_FLAG)
+#define CID_CARACASDMA              (CID_ID(0x8109U) | CID_FLAG)
+#define CID_CARACASFLASHCTRL        (CID_ID(0x810aU) | CID_FLAG)
+#define CID_CARACASGPTIMER          (CID_ID(0x810bU) | CID_FLAG)
+#define CID_CARACASGPIO             (CID_ID(0x810cU) | CID_FLAG)
+#define CID_CARACASI2CMO            (CID_ID(0x810dU) | CID_FLAG)
+#define CID_CARACASI2CMS            (CID_ID(0x810eU) | CID_FLAG)
+#define CID_CARACASRTC              (CID_ID(0x810fU) | CID_FLAG)
+#define CID_CARACASSPI              (CID_ID(0x8110U) | CID_FLAG)
+#define CID_CARACASTIMER            (CID_ID(0x8111U) | CID_FLAG)
+#define CID_CARACASUART             (CID_ID(0x8112U) | CID_FLAG)
+#define CID_TSSA40                  (CID_ID(0x8113U) | CID_FLAG)
+#define CID_PACKET_POOL             (CID_ID(0x8114U) | CID_FLAG)
+#define CID_TSSA15_WRAPPER          (CID_ID(0x8115U) | CID_FLAG)
+#define CID_TASK_SYNC               (CID_ID(0x8116U) | CID_FLAG)
+#define CID_TASK_CONDITION          (CID_ID(0x8117U) | CID_FLAG)
+#define CID_PACKET_QUEUE            (CID_ID(0x8118U) | CID_FLAG)
+#define CID_CONNECTION_TOOLKIT      (CID_ID(0x8119U) | CID_FLAG)
+#define CID_TSSA16                  (CID_ID(0x811aU) | CID_FLAG)
+#define CID_UDSDFU                  (CID_ID(0x811bU) | CID_FLAG)
+#define CID_BTH                     (CID_ID(0x811cU) | CID_FLAG)
+#define CID_DCDIP9021               (CID_ID(0x811dU) | CID_FLAG)
+#define CID_DCDIP3501V1X            (CID_ID(0x811eU) | CID_FLAG)
+#define CID_ISP1581                 (CID_ID(0x811fU) | CID_FLAG)
+#define CID_DCSS_TV                 (CID_ID(0x8120U) | CID_FLAG)
+#define CID_DCSS_MON                (CID_ID(0x8121U) | CID_FLAG)
+#define CID_DCSS_RSC_PC             (CID_ID(0x8122U) | CID_FLAG)
+#define CID_DCSS_RSC_INT            (CID_ID(0x8123U) | CID_FLAG)
+#define CID_DCSS_RSC_EXT            (CID_ID(0x8124U) | CID_FLAG)
+#define CID_DCSS_LIT                (CID_ID(0x8125U) | CID_FLAG)
+#define CID_DCSS_LIT_C              (CID_ID(0x8126U) | CID_FLAG)
+#define CID_DCSS_45A                (CID_ID(0x8127U) | CID_FLAG)
+#define CID_UDSCORE                 (CID_ID(0x8128U) | CID_FLAG)
+#define CID_HW_AUDIO7135            (CID_ID(0x8129U) | CID_FLAG)
+#define CID_DL_AUDIO3X              (CID_ID(0x812aU) | CID_FLAG)
+#define CID_REGACC                  (CID_ID(0x812bU) | CID_FLAG)
+#define CID_HW_MJPEG                (CID_ID(0x812cU) | CID_FLAG)
+#define CID_ISP1582                 (CID_ID(0x812dU) | CID_FLAG)
+#define CID_MUTI                    (CID_ID(0x812eU) | CID_FLAG)
+#define CID_CHANNEL_DECODER_ENCODER (CID_ID(0x812fU) | CID_FLAG)
+#define CID_RESMGR                  (CID_ID(0x8130U) | CID_FLAG)
+#define CID_WIDGET                  (CID_ID(0x8131U) | CID_FLAG)
+#define CID_FB                      (CID_ID(0x8132U) | CID_FLAG)
+#define CID_GFX                     (CID_ID(0x8133U) | CID_FLAG)
+#define CID_HPS_DISPATCHER          (CID_ID(0x8134U) | CID_FLAG)
+#define CID_DL_PLXGPIO              (CID_ID(0x8135U) | CID_FLAG)
+#define CID_HW_PLXGPIO              (CID_ID(0x8136U) | CID_FLAG)
+#define CID_DL_PLXPHI               (CID_ID(0x8137U) | CID_FLAG)
+#define CID_HW_PLXPHI_EVALUATOR     (CID_ID(0x8138U) | CID_FLAG)
+#define CID_DL_SCALER               (CID_ID(0x8139U) | CID_FLAG)
+#define CID_EFM                     (CID_ID(0x813aU) | CID_FLAG)
+#define CID_HW_TUNER_FM1236MK3      (CID_ID(0x813bU) | CID_FLAG)
+#define CID_HW_TUNER_FM1216MK3      (CID_ID(0x813cU) | CID_FLAG)
+#define CID_HW_TUNER_FM1216MK2      (CID_ID(0x813dU) | CID_FLAG)
+#define CID_ANALOG_CHANNEL_TABLE    (CID_ID(0x813eU) | CID_FLAG)
+#define CID_TUNER_CONTROL           (CID_ID(0x813fU) | CID_FLAG)
+#define CID_DL_UIMS                 (CID_ID(0x8140U) | CID_FLAG)
+#define CID_DL_RCTRANSMITTER        (CID_ID(0x8141U) | CID_FLAG)
+#define CID_HW_CST_RCRECEIVER       (CID_ID(0x8142U) | CID_FLAG)
+#define CID_HW_CST_RCTRANSMITTER    (CID_ID(0x8143U) | CID_FLAG)
+#define CID_DCDIP3506               (CID_ID(0x8144U) | CID_FLAG)
+#define CID_DCDIP3501V2X            (CID_ID(0x8145U) | CID_FLAG)
+#define CID_MTV_COORD               (CID_ID(0x8146U) | CID_FLAG)
+#define CID_MTV_IMG_ROT_CTRL        (CID_ID(0x8147U) | CID_FLAG)
+#define CID_TFE_TRACE               (CID_ID(0x8148U) | CID_FLAG)
+#define CID_TMCAL_SERVER            (CID_ID(0x8149U) | CID_FLAG)
+#define CID_BOOT_LOADER             (CID_ID(0x814aU) | CID_FLAG)
+#define CID_TD_SAVE_DATA            (CID_ID(0x814bU) | CID_FLAG)
+#define CID_TFE_TRACE_PROCESS_DATA  (CID_ID(0x814cU) | CID_FLAG)
+#define CID_VIDEOCTRL               (CID_ID(0x814dU) | CID_FLAG)
+#define CID_BOOT                    (CID_ID(0x814eU) | CID_FLAG)
+#define CID_EVENT                   (CID_ID(0x814fU) | CID_FLAG)
+#define CID_USERINPUT               (CID_ID(0x8150U) | CID_FLAG)
+#define CID_BSL_TUNER               (CID_ID(0x8151U) | CID_FLAG)
+#define CID_P5KIIC                  (CID_ID(0x8152U) | CID_FLAG)
+#define CID_HW_PMANSECURITY         (CID_ID(0x8153U) | CID_FLAG)
+#define CID_DRM_DIVX                (CID_ID(0x8154U) | CID_FLAG)
+#define CID_TMHWVIDEODEC7136        (CID_ID(0x8155U) | CID_FLAG)
+#define CID_TMDLVIDEODEC            (CID_ID(0x8156U) | CID_FLAG)
+#define CID_OSD_KERNEL              (CID_ID(0x8157U) | CID_FLAG)
+#define CID_HW_DCSNETWORK           (CID_ID(0x8158U) | CID_FLAG)
+#define CID_DL_RCRECEIVER           (CID_ID(0x8159U) | CID_FLAG)
+#define CID_INT                     (CID_ID(0x815aU) | CID_FLAG)
+#define CID_RTC                     (CID_ID(0x815bU) | CID_FLAG)
+#define CID_TIMER                   (CID_ID(0x815cU) | CID_FLAG)
+#define CID_IPC                     (CID_ID(0x815dU) | CID_FLAG)
+#define CID_P5KTELETEXT             (CID_ID(0x815eU) | CID_FLAG)
+#define CID_P5KAUDIOVIDEO           (CID_ID(0x815fU) | CID_FLAG)
+#define CID_P5KCONFIG               (CID_ID(0x8160U) | CID_FLAG)
+#define CID_HW_CST_TRANSPSTREAMIN   (CID_ID(0x8161U) | CID_FLAG)
+#define CID_HOMER_KERNEL            (CID_ID(0x8162U) | CID_FLAG)
+#define CID_HOMER_DRIVER            (CID_ID(0x8163U) | CID_FLAG)
+#define CID_CD_FILE_SYSTEM          (CID_ID(0x8164U) | CID_FLAG)
+#define CID_COBALT_APP              (CID_ID(0x8165U) | CID_FLAG)
+#define CID_COBALT_UI               (CID_ID(0x8166U) | CID_FLAG)
+#define CID_CD_SERVO                (CID_ID(0x8167U) | CID_FLAG)
+#define CID_CD_UTILS                (CID_ID(0x8168U) | CID_FLAG)
+#define CID_COBALT_SYSTEM           (CID_ID(0x8169U) | CID_FLAG)
+#define CID_CDSLIM                  (CID_ID(0x816aU) | CID_FLAG)
+#define CID_CD_DATABASE             (CID_ID(0x816bU) | CID_FLAG)
+#define CID_CANAVENC                (CID_ID(0x816cU) | CID_FLAG)
+#define CID_CANTIAGING              (CID_ID(0x816dU) | CID_FLAG)
+#define CID_CAUTOPICTCTRL           (CID_ID(0x816eU) | CID_FLAG)
+#define CID_CBBARCTRL               (CID_ID(0x816fU) | CID_FLAG)
+#define CID_CBBARDET                (CID_ID(0x8170U) | CID_FLAG)
+#define CID_CBBARDETEXT             (CID_ID(0x8171U) | CID_FLAG)
+#define CID_CBLEVELDETEXT           (CID_ID(0x8172U) | CID_FLAG)
+#define CID_CCOLENH                 (CID_ID(0x8173U) | CID_FLAG)
+#define CID_CCOLENHEXT              (CID_ID(0x8174U) | CID_FLAG)
+#define CID_CCONTRESEXT             (CID_ID(0x8175U) | CID_FLAG)
+#define CID_CCTI                    (CID_ID(0x8176U) | CID_FLAG)
+#define CID_CCTIEXT                 (CID_ID(0x8177U) | CID_FLAG)
+#define CID_CDNR                    (CID_ID(0x8178U) | CID_FLAG)
+#define CID_CDNREXT                 (CID_ID(0x8179U) | CID_FLAG)
+#define CID_CGAMMAEXT               (CID_ID(0x817aU) | CID_FLAG)
+#define CID_CHISTOMEASEXT           (CID_ID(0x817bU) | CID_FLAG)
+#define CID_CHISTOMOD               (CID_ID(0x817cU) | CID_FLAG)
+#define CID_CHISTOMODEXT            (CID_ID(0x817dU) | CID_FLAG)
+#define CID_CMBSXRAY                (CID_ID(0x817eU) | CID_FLAG)
+#define CID_CNOISE                  (CID_ID(0x817fU) | CID_FLAG)
+#define CID_CNOISEESTEXT            (CID_ID(0x8180U) | CID_FLAG)
+#define CID_CPFSPD                  (CID_ID(0x8181U) | CID_FLAG)
+#define CID_CQVCPXRAY               (CID_ID(0x8182U) | CID_FLAG)
+#define CID_CSCANRATECONV           (CID_ID(0x8183U) | CID_FLAG)
+#define CID_CSCANRATECONVEXT        (CID_ID(0x8184U) | CID_FLAG)
+#define CID_CSHARPENH               (CID_ID(0x8185U) | CID_FLAG)
+#define CID_CSHARPENHEXT            (CID_ID(0x8186U) | CID_FLAG)
+#define CID_CSHARPMEAS              (CID_ID(0x8187U) | CID_FLAG)
+#define CID_CSHARPMEASEXT           (CID_ID(0x8188U) | CID_FLAG)
+#define CID_CSYNCTAG                (CID_ID(0x8189U) | CID_FLAG)
+#define CID_CUVBWDETEXT             (CID_ID(0x818aU) | CID_FLAG)
+#define CID_CVBISLICE               (CID_ID(0x818bU) | CID_FLAG)
+#define CID_CVFEAT                  (CID_ID(0x818cU) | CID_FLAG)
+#define CID_CVFEAT2                 (CID_ID(0x818dU) | CID_FLAG)
+#define CID_CVIPXRAY                (CID_ID(0x818eU) | CID_FLAG)
+#define CID_CVIPXRAYDITHER          (CID_ID(0x818fU) | CID_FLAG)
+#define CID_CVMIX                   (CID_ID(0x8190U) | CID_FLAG)
+#define CID_CVTRSCALEEXT            (CID_ID(0x8191U) | CID_FLAG)
+#define CID_CVTRANTIAGING           (CID_ID(0x8192U) | CID_FLAG)
+#define CID_CVTRFADEVCP             (CID_ID(0x8193U) | CID_FLAG)
+#define CID_CVTRSCALEMBSVCP         (CID_ID(0x8194U) | CID_FLAG)
+#define CID_CVTRSTROBEMBS           (CID_ID(0x8195U) | CID_FLAG)
+#define CID_NM_UTILS                (CID_ID(0x8196U) | CID_FLAG)
+#define CID_VSEQSCHEDENGINE         (CID_ID(0x8197U) | CID_FLAG)
+#define CID_VCPSCHEDENGINE          (CID_ID(0x8198U) | CID_FLAG)
+#define CID_VGENTEST                (CID_ID(0x8199U) | CID_FLAG)
+#define CID_VMENU                   (CID_ID(0x819aU) | CID_FLAG)
+#define CID_VPROCCOMMON             (CID_ID(0x819bU) | CID_FLAG)
+#define CID_VPROCTV                 (CID_ID(0x819cU) | CID_FLAG)
+#define CID_VPROCTV505E             (CID_ID(0x819dU) | CID_FLAG)
+#define CID_SCHEDENGINE             (CID_ID(0x819eU) | CID_FLAG)
+#define CID_VSLNMCOMMON             (CID_ID(0x819fU) | CID_FLAG)
+#define CID_VSLVCAPVIP              (CID_ID(0x81a0U) | CID_FLAG)
+#define CID_VSLVCAPVIPVBI           (CID_ID(0x81a1U) | CID_FLAG)
+#define CID_VSLVINCONVERT           (CID_ID(0x81a2U) | CID_FLAG)
+#define CID_VSLIOSYNC               (CID_ID(0x81a3U) | CID_FLAG)
+#define CID_VSLVRENDVCP             (CID_ID(0x81a4U) | CID_FLAG)
+#define CID_VSLVRENDVCPVBI          (CID_ID(0x81a5U) | CID_FLAG)
+#define CID_VSLSYNCTAG              (CID_ID(0x81a6U) | CID_FLAG)
+#define CID_VSLVTRANSMBS            (CID_ID(0x81a7U) | CID_FLAG)
+#define CID_VSLVTRANSNM             (CID_ID(0x81a8U) | CID_FLAG)
+#define CID_VSLVTRANSQTNR           (CID_ID(0x81a9U) | CID_FLAG)
+#define CID_VSLVTRANSSWTNR          (CID_ID(0x81aaU) | CID_FLAG)
+#define CID_VTRANSSWTNR             (CID_ID(0x81abU) | CID_FLAG)
+#define CID_LL_DMA                  (CID_ID(0x81acU) | CID_FLAG)
+#define CID_BSL_PNX8550             (CID_ID(0x81adU) | CID_FLAG)
+#define CID_BSL_PNX1500             (CID_ID(0x81aeU) | CID_FLAG)
+#define CID_BSL_NULL                (CID_ID(0x81afU) | CID_FLAG)
+#define CID_BSL_PNX2015             (CID_ID(0x81b0U) | CID_FLAG)
+#define CID_HW_SCALER7136           (CID_ID(0x81b1U) | CID_FLAG)
+#define CID_SPI_IP3409              (CID_ID(0x81b2U) | CID_FLAG)
+#define CID_SPI_3409                (CID_ID(0x81b3U) | CID_FLAG)
+#define CID_SPISD_3409              (CID_ID(0x81b4U) | CID_FLAG)
+#define CID_CONNMGRMP4RTPPLAYER     (CID_ID(0x81b5U) | CID_FLAG)
+#define CID_DL_NANDFLASH2           (CID_ID(0x81b6U) | CID_FLAG)
+#define CID_HW_HOSTIF               (CID_ID(0x81b7U) | CID_FLAG)
+#define CID_LL_HOSTIF               (CID_ID(0x81b8U) | CID_FLAG)
+#define CID_LL_MJPEG                (CID_ID(0x81b9U) | CID_FLAG)
+#define CID_HW_SENSORIF             (CID_ID(0x81baU) | CID_FLAG)
+#define CID_LL_SENSORIF             (CID_ID(0x81bbU) | CID_FLAG)
+#define CID_HW_ECSP                 (CID_ID(0x81bcU) | CID_FLAG)
+#define CID_LL_ECSP                 (CID_ID(0x81bdU) | CID_FLAG)
+#define CID_HW_DOWNSCALER           (CID_ID(0x81beU) | CID_FLAG)
+#define CID_LL_DOWNSCALER           (CID_ID(0x81bfU) | CID_FLAG)
+#define CID_HW_UPSCALER             (CID_ID(0x81c0U) | CID_FLAG)
+#define CID_LL_UPSCALER             (CID_ID(0x81c1U) | CID_FLAG)
+#define CID_HW_JITTEREX             (CID_ID(0x81c2U) | CID_FLAG)
+#define CID_LL_JITTEREX             (CID_ID(0x81c3U) | CID_FLAG)
+#define CID_HW_NOISERED             (CID_ID(0x81c4U) | CID_FLAG)
+#define CID_LL_NOISERED             (CID_ID(0x81c5U) | CID_FLAG)
+#define CID_HW_JPEGENCODER          (CID_ID(0x81c6U) | CID_FLAG)
+#define CID_LL_JPEGENCODER          (CID_ID(0x81c7U) | CID_FLAG)
+#define CID_HW_FLASHLIGHT           (CID_ID(0x81c8U) | CID_FLAG)
+#define CID_LL_FLASHLIGHT           (CID_ID(0x81c9U) | CID_FLAG)
+#define CID_HW_TVCONVERTER          (CID_ID(0x81caU) | CID_FLAG)
+#define CID_LL_TVCONVERTER          (CID_ID(0x81cbU) | CID_FLAG)
+#define CID_HW_DVDOMATRIX           (CID_ID(0x81ccU) | CID_FLAG)
+#define CID_LL_DVDOMATRIX           (CID_ID(0x81cdU) | CID_FLAG)
+#define CID_HW_CLCD                 (CID_ID(0x81ceU) | CID_FLAG)
+#define CID_LL_CLCD                 (CID_ID(0x81cfU) | CID_FLAG)
+#define CID_HW_VDE                  (CID_ID(0x81d0U) | CID_FLAG)
+#define CID_LL_VDE                  (CID_ID(0x81d1U) | CID_FLAG)
+#define CID_HW_MCSPI                (CID_ID(0x81d2U) | CID_FLAG)
+#define CID_LL_MCSPI                (CID_ID(0x81d3U) | CID_FLAG)
+#define CID_HW_PWM                  (CID_ID(0x81d4U) | CID_FLAG)
+#define CID_LL_PWM                  (CID_ID(0x81d5U) | CID_FLAG)
+#define CID_OSAL_NXM                (CID_ID(0x81d6U) | CID_FLAG)
+#define CID_MEMPROF                 (CID_ID(0x81d7U) | CID_FLAG)
+#define CID_ALCONSTRETCH            (CID_ID(0x81d8U) | CID_FLAG)
+#define CID_AUTOFOCUS               (CID_ID(0x81d9U) | CID_FLAG)
+#define CID_LL_DVDO2DTL             (CID_ID(0x81daU) | CID_FLAG)
+#define CID_HW_DVDO2DTL             (CID_ID(0x81dbU) | CID_FLAG)
+#define CID_LL_DTL2DVDO             (CID_ID(0x81dcU) | CID_FLAG)
+#define CID_HW_DTL2DVDO             (CID_ID(0x81ddU) | CID_FLAG)
+#define CID_LL_COLORMATRIX          (CID_ID(0x81deU) | CID_FLAG)
+#define CID_HW_COLORMATRIX          (CID_ID(0x81dfU) | CID_FLAG)
+#define CID_UHSPDIFOUT_ASYSATV      (CID_ID(0x81e0U) | CID_FLAG)
+#define CID_DL_NANDFLASH1           (CID_ID(0x81e1U) | CID_FLAG)
+#define CID_NANDBOOTFFS             (CID_ID(0x81e2U) | CID_FLAG)
+#define CID_CONNMGR_APROCTV         (CID_ID(0x81e3U) | CID_FLAG)
+#define CID_CONNMGRSTILLPLAYER      (CID_ID(0x81e4U) | CID_FLAG)
+#define CID_CONNMGRAUDIOPLAYER      (CID_ID(0x81e5U) | CID_FLAG)
+#define CID_DCDIP9028               (CID_ID(0x81e6U) | CID_FLAG)
+#define CID_CURLSRC_AUDIO           (CID_ID(0x81e7U) | CID_FLAG)
+#define CID_CONNMGRAVIMP4PLAYER     (CID_ID(0x81e8U) | CID_FLAG)
+#define CID_AUDIOVIDEOSYNC          (CID_ID(0x81e9U) | CID_FLAG)
+#define CID_PACKETLIST              (CID_ID(0x81eaU) | CID_FLAG)
+#define CID_ASYNCSINK               (CID_ID(0x81ebU) | CID_FLAG)
+#define CID_VSYNCSINK               (CID_ID(0x81ecU) | CID_FLAG)
+#define CID_XSYNCSINK               (CID_ID(0x81edU) | CID_FLAG)
+#define CID_PCIEXP                  (CID_ID(0x81eeU) | CID_FLAG)
+#define CID_SOD_KERNEL              (CID_ID(0x81efU) | CID_FLAG)
+#define CID_SOD_EMULATE             (CID_ID(0x81f0U) | CID_FLAG)
+#define CID_SOD_MGR                 (CID_ID(0x81f1U) | CID_FLAG)
+#define CID_NANDPARTTABLE           (CID_ID(0x81f2U) | CID_FLAG)
+#define CID_HW_AUDIO7136            (CID_ID(0x81f3U) | CID_FLAG)
+#define CID_SPI3409                 (CID_ID(0x81f4U) | CID_FLAG)
+#define CID_DCSS_MATH               (CID_ID(0x81f5U) | CID_FLAG)
+#define CID_DCSS_LIT_CSD            (CID_ID(0x81f6U) | CID_FLAG)
+#define CID_DCSS_LIT_M              (CID_ID(0x81f7U) | CID_FLAG)
+#define CID_ADT                     (CID_ID(0x81f8U) | CID_FLAG)
+#define CID_ACS                     (CID_ID(0x81f9U) | CID_FLAG)
+#define CID_ACB                     (CID_ID(0x81faU) | CID_FLAG)
+#define CID_ACL                     (CID_ID(0x81fbU) | CID_FLAG)
+#define CID_AVEPP                   (CID_ID(0x81fcU) | CID_FLAG)
+#define CID_UDSSIC                  (CID_ID(0x81fdU) | CID_FLAG)
+#define CID_PROXYI2C                (CID_ID(0x81feU) | CID_FLAG)
+#define CID_PL081DMA                (CID_ID(0x81feU) | CID_FLAG)
+#define CID_DD_CPIPE                (CID_ID(0x81ffU) | CID_FLAG)
+#define CID_DD_MBVP                 (CID_ID(0x8200U) | CID_FLAG)
+#define CID_CARENDAOUT              (CID_ID(0x8201U) | CID_FLAG)
+#define CID_CADIGAIN                (CID_ID(0x8202U) | CID_FLAG)
+#define CID_CONNMGR_TV506E          (CID_ID(0x8203U) | CID_FLAG)
+#define CID_ASYNCHANDLER            (CID_ID(0x8204U) | CID_FLAG)
+#define CID_COMP_M4VENCPSC          (CID_ID(0x8205U) | CID_FLAG)
+#define CID_CONNMGRNETSCHEMECONFIG  (CID_ID(0x8206U) | CID_FLAG)
+#define CID_CARACASSPIAHB           (CID_ID(0x8207U) | CID_FLAG)
+#define CID_COMP_ADECLPCM           (CID_ID(0x8208U) | CID_FLAG)
+#define CID_CDIGADEC_MULTISTD       (CID_ID(0x8209U) | CID_FLAG)
+#define CID_ADB                     (CID_ID(0x820aU) | CID_FLAG)
+#define CID_ADR                     (CID_ID(0x820bU) | CID_FLAG)
+#define CID_AGN                     (CID_ID(0x820cU) | CID_FLAG)
+#define CID_ANT                     (CID_ID(0x820dU) | CID_FLAG)
+#define CID_APP                     (CID_ID(0x820eU) | CID_FLAG)
+#define CID_ASC                     (CID_ID(0x820fU) | CID_FLAG)
+#define CID_ASM                     (CID_ID(0x8210U) | CID_FLAG)
+#define CID_ASS                     (CID_ID(0x8211U) | CID_FLAG)
+#define CID_ATP                     (CID_ID(0x8212U) | CID_FLAG)
+#define CID_VDEC_MJPEG              (CID_ID(0x8213U) | CID_FLAG)
+#define CID_MOV_READ                (CID_ID(0x8214U) | CID_FLAG)
+#define CID_EWIFI                   (CID_ID(0x8215U) | CID_FLAG)
+#define CID_SCR                     (CID_ID(0x8216U) | CID_FLAG)
+#define CID_AEPP                    (CID_ID(0x8217U) | CID_FLAG)
+#define CID_VEPP                    (CID_ID(0x8218U) | CID_FLAG)
+#define CID_MP3ENC                  (CID_ID(0x8219U) | CID_FLAG)
+#define CID_TDFLOADER               (CID_ID(0x821aU) | CID_FLAG)
+#define CID_VIOSYNC                 (CID_ID(0x821bU) | CID_FLAG)
+#define CID_STBDP                   (CID_ID(0x821cU) | CID_FLAG)
+#define CID_STBEVENT                (CID_ID(0x821dU) | CID_FLAG)
+#define CID_STBFB                   (CID_ID(0x821eU) | CID_FLAG)
+#define CID_STBDEMUX                (CID_ID(0x821fU) | CID_FLAG)
+#define CID_STBFILE                 (CID_ID(0x8220U) | CID_FLAG)
+#define CID_STBGPIO                 (CID_ID(0x8221U) | CID_FLAG)
+#define CID_STBI2C                  (CID_ID(0x8222U) | CID_FLAG)
+#define CID_STBMMIOBUS              (CID_ID(0x8223U) | CID_FLAG)
+#define CID_STBPROC                 (CID_ID(0x8224U) | CID_FLAG)
+#define CID_STBROOT                 (CID_ID(0x8225U) | CID_FLAG)
+#define CID_STBRPC                  (CID_ID(0x8226U) | CID_FLAG)
+#define CID_STBRTC                  (CID_ID(0x8227U) | CID_FLAG)
+#define CID_STBTMLOAD               (CID_ID(0x8228U) | CID_FLAG)
+#define CID_STBSTREAMINGSYSTEM      (CID_ID(0x8229U) | CID_FLAG)
+#define CID_STBVIDEOSCALER          (CID_ID(0x822aU) | CID_FLAG)
+#define CID_STBANALOGBACKEND        (CID_ID(0x822bU) | CID_FLAG)
+#define CID_STBVIDEORENDERER        (CID_ID(0x822cU) | CID_FLAG)
+#define CID_DRV_MMU                 (CID_ID(0x822dU) | CID_FLAG)
+#define CID_COMP_AINJECTOR          (CID_ID(0x822eU) | CID_FLAG)
+#define CID_VDEC_ANA                (CID_ID(0x822fU) | CID_FLAG)
+#define CID_STBAC3AUD               (CID_ID(0x8230U) | CID_FLAG)
+#define CID_STBAUDIO                (CID_ID(0x8231U) | CID_FLAG)
+#define CID_PHMODARM11WRAPPER       (CID_ID(0x8232U) | CID_FLAG)
+#define CID_GPIO_IP4004             (CID_ID(0x8233U) | CID_FLAG)
+#define CID_TMCADIGSPDIFIN          (CID_ID(0x8234U) | CID_FLAG)
+#define CID_TMCARENDSPDIFOUT        (CID_ID(0x8235U) | CID_FLAG)
+#define CID_TMCPLFINSTAIN           (CID_ID(0x8236U) | CID_FLAG)
+#define CID_TMCPLFINSTAOUT          (CID_ID(0x8237U) | CID_FLAG)
+#define CID_TMCSPDIFIN              (CID_ID(0x8238U) | CID_FLAG)
+#define CID_TMCSPDIFOUT             (CID_ID(0x8239U) | CID_FLAG)
+#define CID_BSL_TDA9975             (CID_ID(0x823aU) | CID_FLAG)
+#define CID_AACPENC                 (CID_ID(0x823bU) | CID_FLAG)
+
+/*define CID_UART                   (CID_ID(0x80a5U) | CID_FLAG) already defined*/
+#define CID_CHIP                    (CID_ID(0x815bU) | CID_FLAG)
+
+#define CID_RESERVED                (CID_ID(0xff80U) | CID_FLAG)
+/* ************************************************************************** */
+/* Component Id's reserved for external organizations                         */
+/*                                                                            */
+/*                            0xff80 thru 0xffbf                              */
+/* Range of component ID's is reserved for the use of parties outside of      */
+/*  Philips that wish to use component ID's privately.                        */
+/*  If a component is going to be exchanged in the 'PS Ecosystem', then a     */
+/*  public component ID should be registered with MoReUse.                    */
+/*                                                                            */
+/* Range to be used by CE Television Systems                                  */
+/*                            0xffc0 thru 0xffff                              */
+/*                                                                            */
+/* ************************************************************************** */
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/* Component ID types are defined as unsigned 32 bit integers (UInt32)        */
+/* Interface ID types are defined as unsigned 32 bit integers (UInt32)        */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*  Obsolete Component ID values                                              */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------------- */
+/* Component Class definitions (bits 31:28, 4 bits)                           */
+/* NOTE: A class of 0x0 must not be defined to ensure that the overall 32 bit */
+/*       component ID/status combination is always non-0 (no TM_OK conflict). */
+/* -------------------------------------------------------------------------- */
+#define CID_CLASS_BITSHIFT  28
+#define CID_CLASS_BITMASK   (0xFU << CID_CLASS_BITSHIFT)
+#define CID_GET_CLASS(compId) ((compId & CID_CLASS_BITMASK) >> CID_CLASS_BITSHIFT)
+
+#define CID_CLASS_NONE      (0x1U << CID_CLASS_BITSHIFT)
+#define CID_CLASS_VIDEO     (0x2U << CID_CLASS_BITSHIFT)
+#define CID_CLASS_AUDIO     (0x3U << CID_CLASS_BITSHIFT)
+#define CID_CLASS_GRAPHICS  (0x4U << CID_CLASS_BITSHIFT)
+#define CID_CLASS_BUS       (0x5U << CID_CLASS_BITSHIFT)
+#define CID_CLASS_INFRASTR  (0x6U << CID_CLASS_BITSHIFT)
+
+#define CID_CLASS_CUSTOMER  (0xFU << CID_CLASS_BITSHIFT)
+
+/* -------------------------------------------------------------------------- */
+/* Component Type definitions (bits 27:24, 4 bits)                            */
+/* -------------------------------------------------------------------------- */
+#define CID_TYPE_BITSHIFT   24
+#define CID_TYPE_BITMASK    (0xFU << CID_TYPE_BITSHIFT)
+#define CID_GET_TYPE(compId)  ((compId & CID_TYPE_BITMASK) >> CID_TYPE_BITSHIFT)
+
+#define CID_TYPE_NONE       (0x0U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_SOURCE     (0x1U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_SINK       (0x2U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_ENCODER    (0x3U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_DECODER    (0x4U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_MUX        (0x5U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_DEMUX      (0x6U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_DIGITIZER  (0x7U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_RENDERER   (0x8U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_FILTER     (0x9U << CID_TYPE_BITSHIFT)
+#define CID_TYPE_CONTROL    (0xAU << CID_TYPE_BITSHIFT)
+#define CID_TYPE_DATABASE   (0xBU << CID_TYPE_BITSHIFT)
+#define CID_TYPE_SUBSYSTEM  (0xCU << CID_TYPE_BITSHIFT)
+#define CID_TYPE_CUSTOMER   (0xFU << CID_TYPE_BITSHIFT)
+
+/* -------------------------------------------------------------------------- */
+/* Component Tag definitions (bits 23:16, 8 bits)                             */
+/* NOTE: Component tags are defined in groups, dependent on the class and     */
+/* type.                                                                      */
+/* -------------------------------------------------------------------------- */
+#define CID_TAG_BITSHIFT    16
+#define CID_TAG_BITMASK     (0xFFU << CID_TAG_BITSHIFT)
+
+#define CID_TAG_NONE        (0x00U << CID_TAG_BITSHIFT)
+
+#define CID_TAG_CUSTOMER    (0xE0U << CID_TAG_BITSHIFT)
+
+#define TAG(number)         ((number) << CID_TAG_BITSHIFT)
+
+/* -------------------------------------------------------------------------- */
+/* General Component Layer definitions (bits 15:12, 4 bits)                   */
+/* -------------------------------------------------------------------------- */
+#define CID_LAYER_BITSHIFT  12
+#define CID_LAYER_BITMASK   (0xF << CID_LAYER_BITSHIFT)
+#define CID_GET_LAYER(compId) ((compId & CID_LAYER_BITMASK) >> CID_LAYER_BITSHIFT)
+
+#define CID_LAYER_NONE      (0x0U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_BTM       (0x1U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_HWAPI     (0x2U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_BSL       (0x3U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_DEVLIB    (0x4U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_TMAL      (0x5U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_TMOL      (0x6U << CID_LAYER_BITSHIFT)
+#define CID_LAYER_TMNL      (0xEU << CID_LAYER_BITSHIFT)
+
+/* -------------------------------------------------------------------------- */
+/*   "new" i.e. after 2002-01-31 layer definitions                            */
+/* "New" Component Layers depend on the component type and class              */
+/* So we can have an identical layer value for each type/class combination    */
+/* In order not to break existing code that assumes that layers are unique,   */
+/* we start new layers at 0x7                                                 */
+/* -------------------------------------------------------------------------- */
+
+/*------------------ CTYP_BUS_NOTYPE dependent layer definitions -------------*/
+#define CID_LAYER_UDS      (0x7U << CID_LAYER_BITSHIFT)  /* USB Device Stack   */
+#define CID_LAYER_UHS      (0x8U << CID_LAYER_BITSHIFT)  /* USB Host stack     */
+#define CID_LAYER_UOTG     (0x9U << CID_LAYER_BITSHIFT)  /* USB OTG stack      */
+
+#define CID_LAYER_CUSTOMER  (0xFU << CID_LAYER_BITSHIFT) /* Customer Defined   */
+
+/* -------------------------------------------------------------------------- */
+/* Component Identifier definitions (bits 31:12, 20 bits)                     */
+/* NOTE: These DVP platform component identifiers are designed to be unique   */
+/*       within the system.  The component identifier encompasses the class   */
+/*       (CID_CLASS_XXX), type (CID_TYPE_XXX), tag, and layer (CID_LAYER_XXX) */
+/*       fields to form the unique component identifier.  This allows any     */
+/*       error/progress status value to be identified as to its original      */
+/*       source, whether or not the source component s header file is present.*/
+/*       The standard error/progress status definitions should be used        */
+/*       whenever possible to ease status interpretation.  No layer           */
+/*       information is defined at this point; it should be ORed into the API */
+/*       status values defined in the APIs header file.                       */
+/* -------------------------------------------------------------------------- */
+#if     (CID_LAYER_NONE != 0)
+#error  ERROR: DVP component identifiers require the layer type 'NONE' = 0 !
+#endif
+
+/* -------------------------------------------------------------------------- */
+/* Classless Types/Components (don t fit into other class categories)         */
+/* -------------------------------------------------------------------------- */
+#define CTYP_NOCLASS_NOTYPE       (CID_CLASS_NONE | CID_TYPE_NONE)
+#define CTYP_NOCLASS_SOURCE       (CID_CLASS_NONE | CID_TYPE_SOURCE)
+#define CTYP_NOCLASS_SINK         (CID_CLASS_NONE | CID_TYPE_SINK)
+#define CTYP_NOCLASS_MUX          (CID_CLASS_NONE | CID_TYPE_MUX)
+#define CTYP_NOCLASS_DEMUX        (CID_CLASS_NONE | CID_TYPE_DEMUX)
+#define CTYP_NOCLASS_FILTER       (CID_CLASS_NONE | CID_TYPE_FILTER)
+#define CTYP_NOCLASS_CONTROL      (CID_CLASS_NONE | CID_TYPE_CONTROL)
+#define CTYP_NOCLASS_DATABASE     (CID_CLASS_NONE | CID_TYPE_DATABASE)
+#define CTYP_NOCLASS_SUBSYS       (CID_CLASS_NONE | CID_TYPE_SUBSYSTEM)
+
+#define CID_COMP_CLOCK            (TAG(0x01U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DMA              (TAG(0x02U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_PIC              (TAG(0x03U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NORFLASH         (TAG(0x04U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NANDFLASH        (TAG(0x05U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_GPIO             (TAG(0x06U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_SMARTCARD        (TAG(0x07U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_UDMA             (TAG(0x08U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DSP              (TAG(0x09U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TIMER            (TAG(0x0AU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TSDMA            (TAG(0x0BU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_MMIARB           (TAG(0x0CU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_EEPROM           (TAG(0x0DU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_PARPORT          (TAG(0x0EU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VSS              (TAG(0x0FU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TSIO             (TAG(0x10U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DBG              (TAG(0x11U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TTE              (TAG(0x12U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_AVPROP           (TAG(0x13U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_SERIAL_RAM       (TAG(0x14U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_SMARTMEDIA       (TAG(0x15U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_COMPACT_FLASH    (TAG(0x16U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_CI               (TAG(0x17U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_INT_ALARM        (TAG(0x18U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_TASK_ALARM       (TAG(0x19U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_XDMA             (TAG(0x1AU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_ICC              (TAG(0x1BU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_CONNMGR          (TAG(0x1CU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_CONNMGRVSYSTV    (TAG(0x1DU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VBISLICERVSYSTV  (TAG(0x1EU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VMIXVSYSTV       (TAG(0x1FU) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NTF              (TAG(0x20U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_NTY              CID_COMP_NTF  /* legacy */
+#define CID_COMP_FATERR           (TAG(0x21U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_DVBTDEMOD        (TAG(0x22U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_HYBRIDTUNER      (TAG(0x23U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_VLD              (TAG(0x24U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_GIC              (TAG(0x25U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_WEB              (TAG(0x26U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_ANAEPGDB         (TAG(0x27U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_HWSEM            (TAG(0x28U) | CTYP_NOCLASS_NOTYPE)
+#define CID_COMP_MMON             (TAG(0x29U) | CTYP_NOCLASS_NOTYPE)
+
+#define CID_COMP_FREAD            (TAG(0x01U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_CDRREAD          (TAG(0x02U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_VSB              (TAG(0x03U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_ANALOGTVTUNER    (TAG(0x04U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TPINMPEG2        (TAG(0x05U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_DREAD            (TAG(0x06U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TREAD            (TAG(0x07U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_RTC              (TAG(0x08U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_TOUCHC           (TAG(0x09U) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_KEYPAD           (TAG(0x0AU) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_ADC              (TAG(0x0BU) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_READLIST         (TAG(0x0CU) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_FROMDISK         (TAG(0x0DU) | CTYP_NOCLASS_SOURCE)
+#define CID_COMP_SOURCE           (TAG(0x0EU) | CTYP_NOCLASS_SOURCE)
+
+#define CID_COMP_FWRITE           (TAG(0x01U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_CDWRITE          (TAG(0x02U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_CHARLCD          (TAG(0x03U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_PWM              (TAG(0x04U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_DAC              (TAG(0x05U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_TSDMAINJECTOR    (TAG(0x06U) | CTYP_NOCLASS_SINK)
+#define CID_COMP_TODISK           (TAG(0x07U) | CTYP_NOCLASS_SINK)
+
+#define CID_COMP_MUXMPEGPS        (TAG(0x01U) | CTYP_NOCLASS_MUX)
+#define CID_COMP_MUXMPEG          (TAG(0x02U) | CTYP_NOCLASS_MUX)
+
+#define CID_COMP_DEMUXMPEGTS      (TAG(0x01U) | CTYP_NOCLASS_DEMUX)
+#define CID_COMP_DEMUXMPEGPS      (TAG(0x02U) | CTYP_NOCLASS_DEMUX)
+#define CID_COMP_DEMUXDV          (TAG(0x03U) | CTYP_NOCLASS_DEMUX)
+
+#define CID_COMP_COPYIO           (TAG(0x01U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_COPYINPLACE      (TAG(0x02U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_UART             (TAG(0x03U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_SSI              (TAG(0x04U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_MODEMV34         (TAG(0x05U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_MODEMV42         (TAG(0x06U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_HTMLPARSER       (TAG(0x07U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_VMSP             (TAG(0x08U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_X                (TAG(0x09U) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_TXTSUBTDECEBU    (TAG(0x0AU) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_CPI              (TAG(0x0BU) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_TRICK            (TAG(0x0CU) | CTYP_NOCLASS_FILTER)
+#define CID_COMP_FWRITEFREAD      (TAG(0x0DU) | CTYP_NOCLASS_FILTER)
+
+#define CID_COMP_REMCTL5          (TAG(0x01U) | CTYP_NOCLASS_CONTROL)
+#define CID_COMP_INFRARED         (TAG(0x02U) | CTYP_NOCLASS_CONTROL)
+
+#define CID_COMP_PSIP             (TAG(0x01U) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_IDE              (TAG(0x02U) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_DISKSCHED        (TAG(0x03U) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_AVFS             (TAG(0x04U) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_MDB              (TAG(0x05U) | CTYP_NOCLASS_DATABASE)
+#define CID_COMP_ATAPI_CMDS       (TAG(0x06U) | CTYP_NOCLASS_DATABASE)
+
+#define CID_COMP_IRDMMPEG         (TAG(0x01U) | CTYP_NOCLASS_SUBSYS)
+#define CID_COMP_STORSYS          (TAG(0x02U) | CTYP_NOCLASS_SUBSYS)
+#define CID_COMP_PMU              (TAG(0x03U) | CTYP_NOCLASS_SUBSYS)
+
+/* -------------------------------------------------------------------------- */
+/* Video Class Types/Components (video types handle video/graphics data)      */
+/* -------------------------------------------------------------------------- */
+#define CTYP_VIDEO_SINK            (CID_CLASS_VIDEO | CID_TYPE_SINK)
+#define CTYP_VIDEO_SOURCE          (CID_CLASS_VIDEO | CID_TYPE_SOURCE)
+#define CTYP_VIDEO_ENCODER         (CID_CLASS_VIDEO | CID_TYPE_ENCODER)
+#define CTYP_VIDEO_DECODER         (CID_CLASS_VIDEO | CID_TYPE_DECODER)
+#define CTYP_VIDEO_DIGITIZER       (CID_CLASS_VIDEO | CID_TYPE_DIGITIZER)
+#define CTYP_VIDEO_RENDERER        (CID_CLASS_VIDEO | CID_TYPE_RENDERER)
+#define CTYP_VIDEO_FILTER          (CID_CLASS_VIDEO | CID_TYPE_FILTER)
+#define CTYP_VIDEO_SUBSYS          (CID_CLASS_VIDEO | CID_TYPE_SUBSYSTEM)
+
+#define CID_COMP_LCD               (TAG(0x01U) | CTYP_VIDEO_SINK)
+
+#define CID_COMP_VCAPVI            (TAG(0x01U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VIP               (TAG(0x02U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VI                (TAG(0x03U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_VSLICER           (TAG(0x04U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_FBREAD            (TAG(0x05U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_QVI               (TAG(0x06U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_CAMERA            (TAG(0x07U) | CTYP_VIDEO_SOURCE)
+#define CID_COMP_CAM_SENSOR        (TAG(0x08U) | CTYP_VIDEO_SOURCE)
+
+#define CID_COMP_VENCM1            (TAG(0x01U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCM2            (TAG(0x02U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCMJ            (TAG(0x03U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCH263          (TAG(0x04U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_VENCH261          (TAG(0x05U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_M4VENC            (TAG(0x06U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_M4VENCME          (TAG(0x07U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_M4VENCTC          (TAG(0x08U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_M4VENCBSG         (TAG(0x09U) | CTYP_VIDEO_ENCODER)
+#define CID_COMP_M4VENCJPEG        (TAG(0x0AU) | CTYP_VIDEO_ENCODER)
+
+#define CID_COMP_VDECM1            (TAG(0x01U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECM2            (TAG(0x02U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECMPEG          (TAG(0x03U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECMJ            (TAG(0x04U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICSVCD    (TAG(0x05U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECH263          (TAG(0x06U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECH261          (TAG(0x07U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDEC              (TAG(0x08U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICDVD     (TAG(0x09U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICBMPDVD  (TAG(0x0AU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECSUBPICRENDDVD (TAG(0x0BU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4PP              (TAG(0x0CU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4MC              (TAG(0x0DU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_M4CSC             (TAG(0x0EU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECTXT           (TAG(0x0FU) | CTYP_VIDEO_DECODER)
+#define CID_COMP_VDECDV            (TAG(0x10U) | CTYP_VIDEO_DECODER)
+#define CID_COMP_BACKANIM          (TAG(0x11U) | CTYP_VIDEO_DECODER)
+
+#define CID_COMP_VDIG              (TAG(0x01U) | CTYP_VIDEO_DIGITIZER)
+#define CID_COMP_VDIGVIRAW         (TAG(0x02U) | CTYP_VIDEO_DIGITIZER)
+#define CID_COMP_VDIG_EXT          (TAG(0x03U) | CTYP_VIDEO_DIGITIZER)
+#define CID_COMP_VDIG_VBI          (TAG(0x04U) | CTYP_VIDEO_DIGITIZER)
+#define CID_COMP_VDIG_EXT_VBI      (TAG(0x05U) | CTYP_VIDEO_DIGITIZER)
+
+#define CID_COMP_VREND             (TAG(0x01U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_HDVO              (TAG(0x02U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDGFXVO        (TAG(0x03U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_AICP              (TAG(0x04U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDVORAW        (TAG(0x05U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VO                (TAG(0x06U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VRENDVOICP        (TAG(0x07U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VMIX              (TAG(0x08U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_QVCP              (TAG(0x09U) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VREND_EXT         (TAG(0x0AU) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_VENCANA           (TAG(0x0BU) | CTYP_VIDEO_RENDERER)
+#define CID_COMP_QVO               (TAG(0x0CU) | CTYP_VIDEO_RENDERER)
+
+#define CID_COMP_MBS               (TAG(0x01U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANS            (TAG(0x02U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_QNM               (TAG(0x03U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_ICP               (TAG(0x04U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSNM          (TAG(0x05U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_QFD               (TAG(0x06U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSDVD         (TAG(0x07U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSCRYSTAL     (TAG(0x08U) | CTYP_VIDEO_FILTER)
+#define CID_COMP_VTRANSUD          (TAG(0x09U) | CTYP_VIDEO_FILTER)
+/*#define CID_COMP_QTNR           (TAG(0x0AU) | CTYP_VIDEO_FILTER) Removed v17:  Replaced with CID_VTRANS_QTNR */
+
+#define CID_COMP_VSYSMT3           (TAG(0x01U) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VSYSSTB           (TAG(0x01U) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_DVDVIDSYS         (TAG(0x02U) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VDECUD            (TAG(0x03U) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VIDSYS            (TAG(0x04U) | CTYP_VIDEO_SUBSYS)
+#define CID_COMP_VSYSTV            (TAG(0x05U) | CTYP_VIDEO_SUBSYS)
+
+/* -------------------------------------------------------------------------- */
+/* Audio Class Types/Components (audio types primarily handle audio data)     */
+/* -------------------------------------------------------------------------- */
+#define CTYP_AUDIO_NOTYPE       (CID_CLASS_AUDIO | CID_TYPE_NONE)
+#define CTYP_AUDIO_SINK         (CID_CLASS_AUDIO | CID_TYPE_SINK)
+#define CTYP_AUDIO_SOURCE       (CID_CLASS_AUDIO | CID_TYPE_SOURCE)
+#define CTYP_AUDIO_ENCODER      (CID_CLASS_AUDIO | CID_TYPE_ENCODER)
+#define CTYP_AUDIO_DECODER      (CID_CLASS_AUDIO | CID_TYPE_DECODER)
+#define CTYP_AUDIO_DIGITIZER    (CID_CLASS_AUDIO | CID_TYPE_DIGITIZER)
+#define CTYP_AUDIO_RENDERER     (CID_CLASS_AUDIO | CID_TYPE_RENDERER)
+#define CTYP_AUDIO_FILTER       (CID_CLASS_AUDIO | CID_TYPE_FILTER)
+#define CTYP_AUDIO_SUBSYS       (CID_CLASS_AUDIO | CID_TYPE_SUBSYSTEM)
+
+#define CID_COMP_CODEC          (TAG(0x01U) | CTYP_AUDIO_NOTYPE)
+
+#define CID_COMP_SDAC           (TAG(0x01U) | CTYP_AUDIO_SINK)
+
+#define CID_COMP_ADIGAI         (TAG(0x01U) | CTYP_AUDIO_DIGITIZER)
+#define CID_COMP_ADIGSPDIF      (TAG(0x02U) | CTYP_AUDIO_DIGITIZER)
+
+#define CID_COMP_ARENDAO        (TAG(0x01U) | CTYP_AUDIO_RENDERER)
+#define CID_COMP_ARENDSPDIF     (TAG(0x02U) | CTYP_AUDIO_RENDERER)
+
+#define CID_COMP_NOISESEQ       (TAG(0x03U) | CTYP_AUDIO_SOURCE)
+
+#define CID_COMP_AENCAC3        (TAG(0x01U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCMPEG1      (TAG(0x02U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCAAC        (TAG(0x03U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCG723       (TAG(0x04U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCG728       (TAG(0x05U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCWMA        (TAG(0x06U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AVENCMPEG      (TAG(0x07U) | CTYP_AUDIO_ENCODER)
+#define CID_COMP_AENCMP3        (TAG(0x08U) | CTYP_AUDIO_ENCODER)
+
+#define CID_COMP_ADECPROLOGIC   (TAG(0x01U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECAC3        (TAG(0x02U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECMPEG1      (TAG(0x03U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECMP3        (TAG(0x04U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECAAC        (TAG(0x05U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECG723       (TAG(0x06U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECG728       (TAG(0x07U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECWMA        (TAG(0x08U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECTHRU       (TAG(0x09U) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADEC           (TAG(0x0AU) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECPCM        (TAG(0x0BU) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECDV         (TAG(0x0CU) | CTYP_AUDIO_DECODER)
+#define CID_COMP_ADECDTS        (TAG(0x0DU) | CTYP_AUDIO_DECODER)
+
+#define CID_COMP_ASPLIB         (TAG(0x01U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_IIR            (TAG(0x02U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ2         (TAG(0x03U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ5         (TAG(0x04U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPBASSREDIR   (TAG(0x05U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPLAT2        (TAG(0x06U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPPLUGIN      (TAG(0x07U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXDTV        (TAG(0x08U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXSIMPLE     (TAG(0x09U) | CTYP_AUDIO_FILTER)
+#define CID_COMP_AMIXSTB        (TAG(0x0AU) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ASPEQ          (TAG(0x0BU) | CTYP_AUDIO_FILTER)
+#define CID_COMP_ATESTSIG       (TAG(0x0CU) | CTYP_AUDIO_FILTER)
+#define CID_COMP_APROC          (TAG(0x0DU) | CTYP_AUDIO_FILTER)
+
+#define CID_COMP_AUDSUBSYS      (TAG(0x01U) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_AUDSYSSTB      (TAG(0x02U) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_AUDSYSDVD      (TAG(0x03U) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_MMC            (TAG(0x04U) | CTYP_AUDIO_SUBSYS)
+#define CID_COMP_COMP_MMC       CID_COMP_MMC  /* legacy */
+#define CID_COMP_ASYSATV        (TAG(0x05U) | CTYP_AUDIO_SUBSYS)
+
+/* -------------------------------------------------------------------------- */
+/* Graphics Class Types/Components                                            */
+/* -------------------------------------------------------------------------- */
+#define CTYP_GRAPHICS_RENDERER  (CID_CLASS_GRAPHICS | CID_TYPE_SINK)
+
+#define CID_COMP_WM             (TAG(0x01U) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_WIDGET         (TAG(0x02U) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_OM             (TAG(0x03U) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_HTMLRENDER     (TAG(0x04U) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_VRENDEIA708    (TAG(0x05U) | CTYP_GRAPHICS_RENDERER)
+#define CID_COMP_VRENDEIA608    (TAG(0x06U) | CTYP_GRAPHICS_RENDERER)
+
+#define CTYP_GRAPHICS_DRAW      (CID_CLASS_GRAPHICS | CID_TYPE_NONE)
+
+#define CID_COMP_DRAW           (TAG(0x10U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_UT        (TAG(0x11U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_DE        (TAG(0x12U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_REF       (TAG(0x13U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMH       (TAG(0x14U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMT       (TAG(0x15U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_DRAW_TMTH      (TAG(0x16U) | CTYP_GRAPHICS_DRAW)
+
+#define CID_COMP_3D             (TAG(0x30U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_JAWT           (TAG(0x31U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_JINPUT         (TAG(0x32U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_LWM            (TAG(0x33U) | CTYP_GRAPHICS_DRAW)
+#define CID_COMP_2D             (TAG(0x34U) | CTYP_GRAPHICS_DRAW)
+
+/* -------------------------------------------------------------------------- */
+/* Bus Class Types/Components (busses connect hardware components together)   */
+/* -------------------------------------------------------------------------- */
+#define CTYP_BUS_NOTYPE         (CID_CLASS_BUS | CID_TYPE_NONE)
+
+#define CID_COMP_XIO            (TAG(0x01U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_IIC            (TAG(0x02U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_PCI            (TAG(0x03U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_P1394          (TAG(0x04U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_ENET           (TAG(0x05U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_ATA            (TAG(0x06U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_CAN            (TAG(0x07U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UCGDMA         (TAG(0x08U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_I2S            (TAG(0x09U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_SPI            (TAG(0x0AU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_PCM            (TAG(0x0BU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_L3             (TAG(0x0CU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSPFL         (TAG(0x0DU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSRSL         (TAG(0x0EU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSMSBOT       (TAG(0x0FU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSMSCBI       (TAG(0x10U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSAUDIO       (TAG(0x11U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSHID         (TAG(0x12U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSCDC         (TAG(0x13U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSPRINTER     (TAG(0x14U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSSCSI        (TAG(0x15U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSMODEM       (TAG(0x16U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UDSETHERNET    (TAG(0x17U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UHSPFL         (TAG(0x18U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UHSMS          (TAG(0x19U) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UHSAUDIO       (TAG(0x1AU) | CTYP_BUS_NOTYPE)
+#define CID_COMP_UHSSCSI        (TAG(0x1BU) | CTYP_BUS_NOTYPE)
+
+/* -------------------------------------------------------------------------- */
+/* Infrastructure Class Types/Components                                      */
+/* -------------------------------------------------------------------------- */
+#define CTYP_INFRASTR_NOTYPE    (CID_CLASS_INFRASTR | CID_TYPE_NONE)
+#define CTYP_INFRASTR_DATABASE  (CID_CLASS_INFRASTR | CID_TYPE_DATABASE)
+
+#define CID_COMP_OSAL           (TAG(0x01U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_MML            (TAG(0x02U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_TSSA_DEFAULTS  (TAG(0x03U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_RPC            (TAG(0x04U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_THI            (TAG(0x05U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_REGISTRY       (TAG(0x06U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_TMMAN          (TAG(0x07U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_LDT            (TAG(0x08U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_CPUCONN        (TAG(0x09U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_COMMQUE        (TAG(0x0AU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_BSLMGR         (TAG(0x0BU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_CR             (TAG(0x0CU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_NODE           (TAG(0x0DU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_COM            (TAG(0x0EU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_UTIL           (TAG(0x0FU) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_SGLIST         (TAG(0x10U) | CTYP_INFRASTR_NOTYPE)
+#define CID_COMP_ARITH          (TAG(0x11U) | CTYP_INFRASTR_NOTYPE)
+
+#define CID_COMP_MULTIFS        (TAG(0x01U) | CTYP_INFRASTR_DATABASE)
+#define CID_COMP_SFS            (TAG(0x02U) | CTYP_INFRASTR_DATABASE)
+
+/* -------------------------------------------------------------------------- */
+/* Component Standard Error/Progress Status definitions (bits 11:0, 12 bits)  */
+/* NOTE: These status codes are ORed with the component identifier to create  */
+/*       component unique 32 bit status values.  The component status values  */
+/*       should be defined in the header files where the APIs are defined.    */
+/* -------------------------------------------------------------------------- */
+#define CID_ERR_BITMASK                 0xFFFU
+#define CID_ERR_BITSHIFT                0
+#define CID_GET_ERROR(compId)   ((compId & CID_ERR_BITMASK) >> CID_ERR_BITSHIFT)
+
+#define TM_ERR_COMPATIBILITY            0x001U /* SW Interface compatibility   */
+#define TM_ERR_MAJOR_VERSION            0x002U /* SW Major Version error       */
+#define TM_ERR_COMP_VERSION             0x003U /* SW component version error   */
+#define TM_ERR_BAD_MODULE_ID            0x004U /* SW - HW module ID error      */
+#define TM_ERR_BAD_UNIT_NUMBER          0x005U /* Invalid device unit number   */
+#define TM_ERR_BAD_INSTANCE             0x006U /* Bad input instance value     */
+#define TM_ERR_BAD_HANDLE               0x007U /* Bad input handle             */
+#define TM_ERR_BAD_INDEX                0x008U /* Bad input index              */
+#define TM_ERR_BAD_PARAMETER            0x009U /* Invalid input parameter      */
+#define TM_ERR_NO_INSTANCES             0x00AU /* No instances available       */
+#define TM_ERR_NO_COMPONENT             0x00BU /* Component is not present     */
+#define TM_ERR_NO_RESOURCES             0x00CU /* Resource is not available    */
+#define TM_ERR_INSTANCE_IN_USE          0x00DU /* Instance is already in use   */
+#define TM_ERR_RESOURCE_OWNED           0x00EU /* Resource is already in use   */
+#define TM_ERR_RESOURCE_NOT_OWNED       0x00FU /* Caller does not own resource */
+#define TM_ERR_INCONSISTENT_PARAMS      0x010U /* Inconsistent input params    */
+#define TM_ERR_NOT_INITIALIZED          0x011U /* Component is not initialized */
+#define TM_ERR_NOT_ENABLED              0x012U /* Component is not enabled     */
+#define TM_ERR_NOT_SUPPORTED            0x013U /* Function is not supported    */
+#define TM_ERR_INIT_FAILED              0x014U /* Initialization failed        */
+#define TM_ERR_BUSY                     0x015U /* Component is busy            */
+#define TM_ERR_NOT_BUSY                 0x016U /* Component is not busy        */
+#define TM_ERR_READ                     0x017U /* Read error                   */
+#define TM_ERR_WRITE                    0x018U /* Write error                  */
+#define TM_ERR_ERASE                    0x019U /* Erase error                  */
+#define TM_ERR_LOCK                     0x01AU /* Lock error                   */
+#define TM_ERR_UNLOCK                   0x01BU /* Unlock error                 */
+#define TM_ERR_OUT_OF_MEMORY            0x01CU /* Memory allocation failed     */
+#define TM_ERR_BAD_VIRT_ADDRESS         0x01DU /* Bad virtual address          */
+#define TM_ERR_BAD_PHYS_ADDRESS         0x01EU /* Bad physical address         */
+#define TM_ERR_TIMEOUT                  0x01FU /* Timeout error                */
+#define TM_ERR_OVERFLOW                 0x020U /* Data overflow/overrun error  */
+#define TM_ERR_FULL                     0x021U /* Queue (etc.) is full         */
+#define TM_ERR_EMPTY                    0x022U /* Queue (etc.) is empty        */
+#define TM_ERR_NOT_STARTED              0x023U /* Streaming function failed    */
+#define TM_ERR_ALREADY_STARTED          0x024U /* Start function failed        */
+#define TM_ERR_NOT_STOPPED              0x025U /* Non-streaming function failed*/
+#define TM_ERR_ALREADY_STOPPED          0x026U /* Stop function failed         */
+#define TM_ERR_ALREADY_SETUP            0x027U /* Setup function failed        */
+#define TM_ERR_NULL_PARAMETER           0x028U /* Null input parameter         */
+#define TM_ERR_NULL_DATAINFUNC          0x029U /* Null data input function     */
+#define TM_ERR_NULL_DATAOUTFUNC         0x02AU /* Null data output function    */
+#define TM_ERR_NULL_CONTROLFUNC         0x02BU /* Null control function        */
+#define TM_ERR_NULL_COMPLETIONFUNC      0x02CU /* Null completion function     */
+#define TM_ERR_NULL_PROGRESSFUNC        0x02DU /* Null progress function       */
+#define TM_ERR_NULL_ERRORFUNC           0x02EU /* Null error handler function  */
+#define TM_ERR_NULL_MEMALLOCFUNC        0x02FU /* Null memory alloc function   */
+#define TM_ERR_NULL_MEMFREEFUNC         0x030U /* Null memory free  function   */
+#define TM_ERR_NULL_CONFIGFUNC          0x031U /* Null configuration function  */
+#define TM_ERR_NULL_PARENT              0x032U /* Null parent data             */
+#define TM_ERR_NULL_IODESC              0x033U /* Null in/out descriptor       */
+#define TM_ERR_NULL_CTRLDESC            0x034U /* Null control descriptor      */
+#define TM_ERR_UNSUPPORTED_DATACLASS    0x035U /* Unsupported data class       */
+#define TM_ERR_UNSUPPORTED_DATATYPE     0x036U /* Unsupported data type        */
+#define TM_ERR_UNSUPPORTED_DATASUBTYPE  0x037U /* Unsupported data subtype     */
+#define TM_ERR_FORMAT                   0x038U /* Invalid/unsupported format   */
+#define TM_ERR_INPUT_DESC_FLAGS         0x039U /* Bad input  descriptor flags  */
+#define TM_ERR_OUTPUT_DESC_FLAGS        0x03AU /* Bad output descriptor flags  */
+#define TM_ERR_CAP_REQUIRED             0x03BU /* Capabilities required ???    */
+#define TM_ERR_BAD_TMALFUNC_TABLE       0x03CU /* Bad TMAL function table      */
+#define TM_ERR_INVALID_CHANNEL_ID       0x03DU /* Invalid channel identifier   */
+#define TM_ERR_INVALID_COMMAND          0x03EU /* Invalid command/request      */
+#define TM_ERR_STREAM_MODE_CONFUSION    0x03FU /* Stream mode config conflict  */
+#define TM_ERR_UNDERRUN                 0x040U /* Data underflow/underrun      */
+#define TM_ERR_EMPTY_PACKET_RECVD       0x041U /* Empty data packet received   */
+#define TM_ERR_OTHER_DATAINOUT_ERR      0x042U /* Other data input/output err  */
+#define TM_ERR_STOP_REQUESTED           0x043U /* Stop in progress             */
+#define TM_ERR_ASSERTION                0x049U /* Assertion failure            */
+#define TM_ERR_HIGHWAY_BANDWIDTH        0x04AU /* Highway bandwidth bus error  */
+#define TM_ERR_HW_RESET_FAILED          0x04BU /* Hardware reset failed        */
+#define TM_ERR_BAD_FLAGS                0x04DU /* Bad flags                    */
+#define TM_ERR_BAD_PRIORITY             0x04EU /* Bad priority                 */
+#define TM_ERR_BAD_REFERENCE_COUNT      0x04FU /* Bad reference count          */
+#define TM_ERR_BAD_SETUP                0x050U /* Bad setup                    */
+#define TM_ERR_BAD_STACK_SIZE           0x051U /* Bad stack size               */
+#define TM_ERR_BAD_TEE                  0x052U /* Bad tee                      */
+#define TM_ERR_IN_PLACE                 0x053U /* In place                     */
+#define TM_ERR_NOT_CACHE_ALIGNED        0x054U /* Not cache aligned            */
+#define TM_ERR_NO_ROOT_TEE              0x055U /* No root tee                  */
+#define TM_ERR_NO_TEE_ALLOWED           0x056U /* No tee allowed               */
+#define TM_ERR_NO_TEE_EMPTY_PACKET      0x057U /* No tee empty packet          */
+#define TM_ERR_NULL_PACKET              0x059U /* Null packet                  */
+#define TM_ERR_FORMAT_FREED             0x05AU /* Format freed                 */
+#define TM_ERR_FORMAT_INTERNAL          0x05BU /* Format internal              */
+#define TM_ERR_BAD_FORMAT               0x05CU /* Bad format                   */
+#define TM_ERR_FORMAT_NEGOTIATE_DATACLASS 0x05DU /* Format negotiate class     */
+#define TM_ERR_FORMAT_NEGOTIATE_DATATYPE 0x05EU /* Format negotiate type       */
+#define TM_ERR_FORMAT_NEGOTIATE_DATASUBTYPE 0x05FU /* Format negotiate subtype */
+#define TM_ERR_FORMAT_NEGOTIATE_DESCRIPTION 0x060U /* Format negotiate desc    */
+#define TM_ERR_NULL_FORMAT              0x061U /* Null format                  */
+#define TM_ERR_FORMAT_REFERENCE_COUNT   0x062U /* Format reference count       */
+#define TM_ERR_FORMAT_NOT_UNIQUE        0x063U /* Format not unique            */
+#define TM_NEW_FORMAT                   0x064U /* New format (not an error)    */
+#define TM_ERR_FORMAT_NEGOTIATE_EXTENSION 0x065U /* Format negotiate extension */
+#define TM_ERR_INVALID_STATE            0x066U /* Invalid state for function   */
+#define TM_ERR_NULL_CONNECTION          0x067U /* No connection to this pin    */
+#define TM_ERR_OPERATION_NOT_PERMITTED  0x068U /* corresponds to posix EPERM   */
+#define TM_ERR_NOT_CLOCKED              0x069U /* Power down - clocked off     */
+
+
+#define PH_ERR_COMPATIBILITY            0x001U /* SW Interface compatibility   */
+#define PH_ERR_MAJOR_VERSION            0x002U /* SW Major Version error       */
+#define PH_ERR_COMP_VERSION             0x003U /* SW component version error   */
+#define PH_ERR_BAD_MODULE_ID            0x004U /* SW - HW module ID error      */
+#define PH_ERR_BAD_UNIT_NUMBER          0x005U /* Invalid device unit number   */
+#define PH_ERR_BAD_INSTANCE             0x006U /* Bad input instance value     */
+#define PH_ERR_BAD_HANDLE               0x007U /* Bad input handle             */
+#define PH_ERR_BAD_INDEX                0x008U /* Bad input index              */
+#define PH_ERR_BAD_PARAMETER            0x009U /* Invalid input parameter      */
+#define PH_ERR_NO_INSTANCES             0x00AU /* No instances available       */
+#define PH_ERR_NO_COMPONENT             0x00BU /* Component is not present     */
+#define PH_ERR_NO_RESOURCES             0x00CU /* Resource is not available    */
+#define PH_ERR_INSTANCE_IN_USE          0x00DU /* Instance is already in use   */
+#define PH_ERR_RESOURCE_OWNED           0x00EU /* Resource is already in use   */
+#define PH_ERR_RESOURCE_NOT_OWNED       0x00FU /* Caller does not own resource */
+#define PH_ERR_INCONSISTENT_PARAMS      0x010U /* Inconsistent input params    */
+#define PH_ERR_NOT_INITIALIZED          0x011U /* Component is not initialized */
+#define PH_ERR_NOT_ENABLED              0x012U /* Component is not enabled     */
+#define PH_ERR_NOT_SUPPORTED            0x013U /* Function is not supported    */
+#define PH_ERR_INIT_FAILED              0x014U /* Initialization failed        */
+#define PH_ERR_BUSY                     0x015U /* Component is busy            */
+#define PH_ERR_NOT_BUSY                 0x016U /* Component is not busy        */
+#define PH_ERR_READ                     0x017U /* Read error                   */
+#define PH_ERR_WRITE                    0x018U /* Write error                  */
+#define PH_ERR_ERASE                    0x019U /* Erase error                  */
+#define PH_ERR_LOCK                     0x01AU /* Lock error                   */
+#define PH_ERR_UNLOCK                   0x01BU /* Unlock error                 */
+#define PH_ERR_OUT_OF_MEMORY            0x01CU /* Memory allocation failed     */
+#define PH_ERR_BAD_VIRT_ADDRESS         0x01DU /* Bad virtual address          */
+#define PH_ERR_BAD_PHYS_ADDRESS         0x01EU /* Bad physical address         */
+#define PH_ERR_TIMEOUT                  0x01FU /* Timeout error                */
+#define PH_ERR_OVERFLOW                 0x020U /* Data overflow/overrun error  */
+#define PH_ERR_FULL                     0x021U /* Queue (etc.) is full         */
+#define PH_ERR_EMPTY                    0x022U /* Queue (etc.) is empty        */
+#define PH_ERR_NOT_STARTED              0x023U /* Streaming function failed    */
+#define PH_ERR_ALREADY_STARTED          0x024U /* Start function failed        */
+#define PH_ERR_NOT_STOPPED              0x025U /* Non-streaming function failed*/
+#define PH_ERR_ALREADY_STOPPED          0x026U /* Stop function failed         */
+#define PH_ERR_ALREADY_SETUP            0x027U /* Setup function failed        */
+#define PH_ERR_NULL_PARAMETER           0x028U /* Null input parameter         */
+#define PH_ERR_NULL_DATAINFUNC          0x029U /* Null data input function     */
+#define PH_ERR_NULL_DATAOUTFUNC         0x02AU /* Null data output function    */
+#define PH_ERR_NULL_CONTROLFUNC         0x02BU /* Null control function        */
+#define PH_ERR_NULL_COMPLETIONFUNC      0x02CU /* Null completion function     */
+#define PH_ERR_NULL_PROGRESSFUNC        0x02DU /* Null progress function       */
+#define PH_ERR_NULL_ERRORFUNC           0x02EU /* Null error handler function  */
+#define PH_ERR_NULL_MEMALLOCFUNC        0x02FU /* Null memory alloc function   */
+#define PH_ERR_NULL_MEMFREEFUNC         0x030U /* Null memory free  function   */
+#define PH_ERR_NULL_CONFIGFUNC          0x031U /* Null configuration function  */
+#define PH_ERR_NULL_PARENT              0x032U /* Null parent data             */
+#define PH_ERR_NULL_IODESC              0x033U /* Null in/out descriptor       */
+#define PH_ERR_NULL_CTRLDESC            0x034U /* Null control descriptor      */
+#define PH_ERR_UNSUPPORTED_DATACLASS    0x035U /* Unsupported data class       */
+#define PH_ERR_UNSUPPORTED_DATATYPE     0x036U /* Unsupported data type        */
+#define PH_ERR_UNSUPPORTED_DATASUBTYPE  0x037U /* Unsupported data subtype     */
+#define PH_ERR_FORMAT                   0x038U /* Invalid/unsupported format   */
+#define PH_ERR_INPUT_DESC_FLAGS         0x039U /* Bad input  descriptor flags  */
+#define PH_ERR_OUTPUT_DESC_FLAGS        0x03AU /* Bad output descriptor flags  */
+#define PH_ERR_CAP_REQUIRED             0x03BU /* Capabilities required ???    */
+#define PH_ERR_BAD_TMALFUNC_TABLE       0x03CU /* Bad TMAL function table      */
+#define PH_ERR_INVALID_CHANNEL_ID       0x03DU /* Invalid channel identifier   */
+#define PH_ERR_INVALID_COMMAND          0x03EU /* Invalid command/request      */
+#define PH_ERR_STREAM_MODE_CONFUSION    0x03FU /* Stream mode config conflict  */
+#define PH_ERR_UNDERRUN                 0x040U /* Data underflow/underrun      */
+#define PH_ERR_EMPTY_PACKET_RECVD       0x041U /* Empty data packet received   */
+#define PH_ERR_OTHER_DATAINOUT_ERR      0x042U /* Other data input/output err  */
+#define PH_ERR_STOP_REQUESTED           0x043U /* Stop in progress             */
+#define PH_ERR_ASSERTION                0x049U /* Assertion failure            */
+#define PH_ERR_HIGHWAY_BANDWIDTH        0x04AU /* Highway bandwidth bus error  */
+#define PH_ERR_HW_RESET_FAILED          0x04BU /* Hardware reset failed        */
+#define PH_ERR_BAD_FLAGS                0x04DU /* Bad flags                    */
+#define PH_ERR_BAD_PRIORITY             0x04EU /* Bad priority                 */
+#define PH_ERR_BAD_REFERENCE_COUNT      0x04FU /* Bad reference count          */
+#define PH_ERR_BAD_SETUP                0x050U /* Bad setup                    */
+#define PH_ERR_BAD_STACK_SIZE           0x051U /* Bad stack size               */
+#define PH_ERR_BAD_TEE                  0x052U /* Bad tee                      */
+#define PH_ERR_IN_PLACE                 0x053U /* In place                     */
+#define PH_ERR_NOT_CACHE_ALIGNED        0x054U /* Not cache aligned            */
+#define PH_ERR_NO_ROOT_TEE              0x055U /* No root tee                  */
+#define PH_ERR_NO_TEE_ALLOWED           0x056U /* No tee allowed               */
+#define PH_ERR_NO_TEE_EMPTY_PACKET      0x057U /* No tee empty packet          */
+#define PH_ERR_NULL_PACKET              0x059U /* Null packet                  */
+#define PH_ERR_FORMAT_FREED             0x05AU /* Format freed                 */
+#define PH_ERR_FORMAT_INTERNAL          0x05BU /* Format internal              */
+#define PH_ERR_BAD_FORMAT               0x05CU /* Bad format                   */
+#define PH_ERR_FORMAT_NEGOTIATE_DATACLASS 0x05DU /* Format negotiate class     */
+#define PH_ERR_FORMAT_NEGOTIATE_DATATYPE 0x05EU /* Format negotiate type       */
+#define PH_ERR_FORMAT_NEGOTIATE_DATASUBTYPE 0x05FU /* Format negotiate subtype */
+#define PH_ERR_FORMAT_NEGOTIATE_DESCRIPTION 0x060U /* Format negotiate desc    */
+#define PH_ERR_NULL_FORMAT              0x061U /* Null format                  */
+#define PH_ERR_FORMAT_REFERENCE_COUNT   0x062U /* Format reference count       */
+#define PH_ERR_FORMAT_NOT_UNIQUE        0x063U /* Format not unique            */
+#define PH_NEW_FORMAT                   0x064U /* New format (not an error)    */
+#define PH_ERR_FORMAT_NEGOTIATE_EXTENSION 0x065U /* Format negotiate extension */
+#define PH_ERR_INVALID_STATE            0x066U /* Invalid state for function   */
+#define PH_ERR_NULL_CONNECTION          0x067U /* No connection to this pin    */
+#define PH_ERR_OPERATION_NOT_PERMITTED  0x068U /* corresponds to posix EPERM   */
+#define PH_ERR_NOT_CLOCKED              0x069U /* Power down - clocked off     */
+
+/* Add new standard error/progress status codes here                          */
+
+#define TM_ERR_COMP_UNIQUE_START    0x800U /* 0x800-0xBFF: Component unique    */
+#define PH_ERR_COMP_UNIQUE_START    0x800U /* 0x800-0xBFF: Component unique    */
+#define TM_ERR_CUSTOMER_START       0xC00U /* 0xC00-0xDFF: Customer defined    */
+#define PH_ERR_CUSTOMER_START       0xC00U /* 0xC00-0xDFF: Customer defined    */
+
+/* Legacy and withdrawn error codes */
+#define TM_ERR_FORMAT_NEGOTIATE_SUBCLASS TM_ERR_FORMAT_NEGOTIATE_DATACLASS
+#define TM_ERR_NEW_FORMAT                TM_NEW_FORMAT
+#define TM_ERR_PAUSE_PIN_REQUESTED       TM_ERR_STOP_REQUESTED
+#define TM_ERR_PIN_ALREADY_STARTED       TM_ERR_ALREADY_STARTED
+#define TM_ERR_PIN_ALREADY_STOPPED       TM_ERR_ALREADY_STOPPED
+#define TM_ERR_PIN_NOT_STARTED           TM_ERR_NOT_STARTED
+#define TM_ERR_PIN_NOT_STOPPED           TM_ERR_NOT_STOPPED
+#define TM_ERR_PIN_PAUSED                TM_ERR_NOT_STARTED
+
+/* -------------------------------------------------------------------------- */
+/* Standard assert error code start offset                                    */
+/* NOTE: These ranges are FOR LEGACY CODE ONLY and must not be used in new    */
+/*  components                                                                */
+/* -------------------------------------------------------------------------- */
+#define TM_ERR_ASSERT_START         0xE00U /* 0xE00-0xEFF: Assert failures     */
+#define TM_ERR_ASSERT_LAST          0xEFFU /* Last assert error range value    */
+#define CID_IS_ASSERT_ERROR(compId) ((CID_GET_ERROR(compId) >= TM_ERR_ASSERT_START) && (CID_GET_ERROR(compId) <= TM_ERR_ASSERT_LAST))
+
+/* -------------------------------------------------------------------------- */
+/* Standard fatal error code start offset                                     */
+/* NOTE: These ranges are FOR LEGACY CODE ONLY and must not be used in new    */
+/*  components                                                                */
+/* -------------------------------------------------------------------------- */
+
+#define TM_ERR_FATAL_START          0xF00U /* 0xF00-0xFFF: Fatal failures      */
+#define TM_ERR_FATAL_LAST           0xFFFU /* Last fatal error range value     */
+#define CID_IS_FATAL_ERROR(compId)  ((CID_GET_ERROR(compId) >= TM_ERR_FATAL_START) && (CID_GET_ERROR(compId) <= TM_ERR_FATAL_LAST))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMNXCOMPID_H ----------------- */
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmNxModId.h linux-2.6.34/include/HwAPI/tmNxModId.h
--- linux-2.6.34.orig/include/HwAPI/tmNxModId.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmNxModId.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,309 @@
+/*-----------------------------------------------------------------*/
+/*                                                                 */
+/* (C) Copyright 2000-2002 Koninklijke Philips Electronics N.V.,   */
+/* All rights reserved                                             */
+/* This source code and any compilation or derivative thereof is   */
+/* the proprietary informaton of Koninklijke Philips Electronics NV*/
+/* and is confidential in nature                                   */
+/* Under no circumstances is this software to be exposed to or     */
+/* placed under an Open Source License of any type without the     */
+/* expressed written permission of Koninklijke Philips Electronics */
+/* N.V.                                                            */
+/*                                                                 */
+/*-----------------------------------------------------------------*/
+/*                                                                 */
+/* FILE NAME:    tmNxModId.h                                       */
+/*                                                                 */
+/* Description: This header files contains the hardware module Ids */
+/*              It is generated automatically when a module id is  */
+/*              added or changed on the CoReUse web site           */
+/*                                                                 */
+/* File generated at 2005-07-27 00:07:32                           */
+/* File updated to include NDK legacy module ids                   */
+/*                                                                 */
+/*-----------------------------------------------------------------*/
+
+
+#ifndef TMNXMODID_H
+#define TMNXMODID_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+
+#define COLUMBUS_21_MOD_ID		0X00000021	/* 3D Comb and SWAN Filters */
+#define VMPG_100_MOD_ID			0X00000100	/* High Level MPEG Decoder */
+#define C1394_101_MOD_ID		0X00000101	/* 1394 */
+#define FPBC_102_MOD_ID			0X00000102	/* PI-Bus Controller @ 150 MHz */
+#define JTAG_103_MOD_ID			0X00000103	/* JTAG debug interface for TM  */
+#define EJTAG_104_MOD_ID		0X00000104	/* EJTAG debug interface for MIPS */
+#define IIC_105_MOD_ID			0X00000105	/* I2C */
+#define SMCARD_106_MOD_ID		0X00000106	/* SmartCard */
+#define UART_107_MOD_ID			0X00000107	/* UART, full DMA support */
+#define CLOCKS_108_MOD_ID		0X00000108	/* Clock Generation */
+#define USB_109_MOD_ID			0X00000109	/* USB */
+#define BOOT_10A_MOD_ID			0X0000010A	/* Boot logic/Reset */
+#define MPBC_10B_MOD_ID			0X0000010B	/* PI-Bus Controller @ 150 MHz */
+#define SSI_10C_MOD_ID			0X0000010C	/* SSI Synchronous Serial Interface */
+#define AI_10D_MOD_ID			0X0000010D	/* Audio In */
+#define VMSP_10E_MOD_ID			0X0000010E	/* MPEG-2 System Part */
+#define GPIO_10F_MOD_ID			0X0000010F	/* General Purpose I/O */
+#define SPDI_110_MOD_ID			0X00000110	/* SPDIF-in */
+#define AICP1_111_MOD_ID		0X00000111	/* Image Composition Processor (1st) */
+#define TPBC_112_MOD_ID			0X00000112	/* TM PI-Bus Controller @ 75 MHz */
+#define PCI_113_MOD_ID			0X00000113	/* PCI M/S Interface w/ XIO @ 33 MHz */
+#define MMI_114_MOD_ID			0X00000114	/* Memory Interface SDRAM 143MHz */
+#define ORCA3_115_MOD_ID		0X00000115	/* 3D engine */
+#define DBG_116_MOD_ID			0X00000116	/* Hardware Debug (SPY) */
+#define DE_117_MOD_ID			0X00000117	/*  */
+#define AICP2_118_MOD_ID		0X00000118	/* Image Composition Processor (2nd) */
+#define MBS_119_MOD_ID			0X00000119	/* Memory Based Scaler */
+#define VIP_11A_MOD_ID			0X0000011A	/* Video Input Processor */
+#define PIMI_11B_MOD_ID			0X0000011B	/* PI-DVP Memory Bus bridge (150-143) */
+#define PIB_11C_MOD_ID			0X0000011C	/* PI-PI bridge 150-75 MHz */
+#define PIC_11D_MOD_ID			0X0000011D	/* Interrupt Controller */
+#define AO_120_MOD_ID			0X00000120	/* AO (Audio Out) */
+#define SPDO_121_MOD_ID			0X00000121	/* SPDIF-out */
+#define FPIMI_122_MOD_ID		0X00000122	/* PI-DVP Memory Bus bridge (75-143) */
+#define RESET_123_MOD_ID		0X00000123	/*  */
+#define NULL_124_MOD_ID			0X00000124	/*  the response from the buscontroller indicating there is no module */
+#define TSDMA_125_MOD_ID		0X00000125	/*  */
+#define GLBREG1_126_MOD_ID		0X00000126	/*  */
+#define TMDBG_127_MOD_ID		0X00000127	/*  */
+#define GLBREG2_128_MOD_ID		0X00000128	/*  */
+#define DMA_130_MOD_ID			0X00000130	/*  */
+#define IR_131_MOD_ID			0X00000131	/*  */
+#define GFX2D_132_MOD_ID		0X00000132	/* Graphics Engine (2D) */
+#define P1284_133_MOD_ID		0X00000133	/* Video decoder */
+#define QNM_134_MOD_ID			0X00000134	/* Audio decoder */
+#define VIDDEC_140_MOD_ID		0X00000140	/* Video decoder */
+#define I2D_141_MOD_ID			0X00000141	/* Datalink Receiver (I2D Inter-Integrated Digital bus) */
+#define FEF_142_MOD_ID			0X00000142	/* Front End Features */
+#define MBF_143_MOD_ID			0X00000143	/* Memory Based Features */
+#define BEF_144_MOD_ID			0X00000144	/* Back End Features */
+#define DOP_145_MOD_ID			0X00000145	/* Digital Output Processor (Digital CRT driver) */
+#define CGFX_146_MOD_ID			0X00000146	/* Character Based Display */
+#define DCU_147_MOD_ID			0X00000147	/* Data Capture Unit */
+#define SND_148_MOD_ID			0X00000148	/* Multi Channel TV Sound Processor */
+#define FGPI_14B_MOD_ID			0X0000014B	/* Fast Generic Parallel Input DMA Block */
+#define FGPO_14C_MOD_ID			0X0000014C	/* Fast Generic Parallel Output DMA Block */
+#define VLD_14D_MOD_ID			0X0000014D	/* HD MPEG2 (and MPEG-1) VLD Decoder */
+#define LAN100_14F_MOD_ID		0X0000014F	/* 10/100 ethernet interface */
+#define PMARB_1010_MOD_ID		0X00001010	/* MTL memory bus arbiter */
+#define INT_1101_MOD_ID			0X00001101	/* PI Interrupt Controller */
+#define GIC_1106_MOD_ID			0X00001106	/* Generic interupt controller */
+#define MCU_2031_MOD_ID			0X00002031	/* MTL based multi-port DDS SDRAM controller */
+#define EFM_2111_MOD_ID			0X00002111	/* AHB/VPB Embedded Flash Module */
+#define PR1910_2B03_MOD_ID		0X00002B03	/* MIPS PR1910 CPU */
+#define PR33930_2B10_MOD_ID		0X00002B10	/* MIPS PR3930 */
+#define PR3940_2B11_MOD_ID		0X00002B11	/* MIPS PR3940 CPU 16K/8K 150 MHz */
+#define TM3218_2B80_MOD_ID		0X00002B80	/* TriMedia TM3218 CPU 200 MHz */
+#define TM5250_2B90_MOD_ID		0X00002B90	/* TriMedia processor Spitfire/TM5250 */
+#define LITE_2B91_MOD_ID		0X00002B91	/* TriMedia processor TM-Lite (TM2270) */
+#define TM3270_2B92_MOD_ID		0X00002B92	/* TriMedia Processor TM3270 (TM-Video) */
+#define TIMER_3002_MOD_ID		0X00003002	/* PI Timer */
+#define TIMER_3003_MOD_ID		0X00003003	/* VPB Timer Template (to be replaced by IP 3004) */
+#define TIMER_3004_MOD_ID		0X00003004	/* VPB Timer Template (to be replaced by IP 3012) */
+#define TIMER_3012_MOD_ID		0X00003012	/* VPB Timer Template */
+#define UART_3102_MOD_ID		0X00003102	/* Extended UART (DMA) */
+#define UART_3103_MOD_ID		0X00003103	/* 16C UART HDL Template (to be replaced by IP 3106) */
+#define UART_3106_MOD_ID		0X00003106	/* 16C UART HDL Template */
+#define I2C_3203_MOD_ID			0X00003203	/* High Speed IIC controller with DMA */
+#define I2C_3204_MOD_ID			0X00003204	/* I2C Template */
+#define GPIO_4001_MOD_ID		0X00004001	/* Configurable Multi Purpose IO Port */
+#define GPIO_4002_MOD_ID		0X00004002	/* VPB Flexible General Purpose I/O Template */
+#define GPIO_4004_MOD_ID		0X00004004	/* VPB Flexible General Purpose I/O Template */
+#define ACOMP_A000_MOD_ID		0X0000A000	/* Audio Encoder, e.g. MPEG2L1,DDC */
+#define VF_A001_MOD_ID			0X0000A001	/* Video Frontend, Video In, Color Conv,Noise Filter, Scaler */
+#define VCOMP_A002_MOD_ID		0X0000A002	/* MPEG2 Video Encoder */
+#define OIF_A003_MOD_ID			0X0000A003	/* Output Interface, basically DTL to 8bit parallel out + clk & sync) */
+#define SCR_A004_MOD_ID			0X0000A004	/* System Clock Reference */
+#define DVDD_A005_MOD_ID		0X0000A005	/* DTV-DVDD block adapted: register access via DTL-MMIO; data via DTL-DMA bus */
+#define EDMA_A006_MOD_ID		0X0000A006	/* enhanced stb_dma: data connected via DTL-DMA bus */
+#define DCU_NODMA_A007_MOD_ID	0X0000A007	/* PI-Bus VBI Data Capture Unit without DMA */
+#define TSIN_A00B_MOD_ID		0X0000A00B	/* Transport Stream input?! */
+#define QVCP5L_A014_MOD_ID		0X0000A014	/* QVCP */
+#define SFE_A016_MOD_ID			0X0000A016	/* Satellite Front End IP */
+#define QNM_A017_MOD_ID			0X0000A017	/* Condor: Natural Motion Coprocessor */
+#define QVCP2L_A019_MOD_ID		0X0000A019	/* QVCP */
+#define D3D_A01A_MOD_ID			0X0000A01A	/* 3D Setup and Rendering Engine */
+#define QTNR_A02A_MOD_ID		0X0000A02A	/* Quality Temporal Noise Reduction */
+#define VMIBC_A02B_MOD_ID		0X0000A02B	/* MMIO Interconnect Bus Controller (Viper PVR) */
+#define PATA_A02C_MOD_ID		0X0000A02C	/* Parallel ATA Host controller (all modes to UDMA 100). */
+#define GDMA_A02D_MOD_ID		0X0000A02D	/* Generic DMA physical interface (master/slave, 8-16-bit, etc.) */
+#define VIDDEC_SEC_A02E_MOD_ID	0X0000A02E	/* CVBS-only Video decoder (Stripped 0x0140) */
+#define M4PP_A02F_MOD_ID		0X0000A02F	/* Mpeg4 Post-processing HW accelerator (M4PP) */
+#define M4MC_A030_MOD_ID		0X0000A030	/* Mpeg4 Motion Compensation HW accelerator (M4MC) */
+#define M4CSC_A031_MOD_ID		0X0000A031	/* Mpeg4 Colour Space Conversion HW accelerator (M4CSC) */
+#define ATA_A032_MOD_ID			0X0000A032	/* ATA Host controller HW block */
+#define UCGDMA_A033_MOD_ID		0X0000A033	/* uController & Generic Dma interface */
+#define I2S_A034_MOD_ID			0X0000A034	/* i2s with integrated DMA & clock logic */
+#define AHB2PCI_A035_MOD_ID		0X0000A035	/* AHB to PCI Bridge */
+#define SDAC_A036_MOD_ID		0X0000A036	/* SDAC, serial DAC for audio out  */
+#define CAN_A037_MOD_ID			0X0000A037	/* CAN-bus interface (PeliCan ) */
+#define ADC_A038_MOD_ID			0X0000A038	/* ADC using SigmaDelta  'C18AD16B44K' from AMoS */
+#define CAMERA_A039_MOD_ID		0X0000A039	/*  Camera Interface (Capture block) */
+#define MJPEG_A03A_MOD_ID		0X0000A03A	/* motion jpeg codec */
+#define CLOCK_A03B_MOD_ID		0X0000A03B	/* MPMP1 clock generator (using C18PL160M) */
+#define WATCHDOG_A03C_MOD_ID		0X0000A03C	/* watchdog timer */
+#define CHARLCD_A03D_MOD_ID		0X0000A03D	/* character lcd interface */
+#define NF_A03E_MOD_ID			0X0000A03E	/* NAND flash interface */
+#define TOUCHC_A03F_MOD_ID		0X0000A03F	/* touch screen controller */
+#define KEYPAD_A040_MOD_ID		0X0000A040	/* keypad controller (36 keys) */
+#define SPI_A041_MOD_ID			0X0000A041	/* BlueBerry/S3 master / slave SPI  */
+#define PCM_A042_MOD_ID			0X0000A042	/* BlueBerry/S3 ipint PCM */
+#define PWM_A043_MOD_ID			0X0000A043	/* PWM/PDM controller */
+#define DAC_A044_MOD_ID			0X0000A044	/* DAC 10-bits 1-chan (AMoS) */
+#define ADC_A045_MOD_ID			0X0000A045	/* ADC 10-bits 8-chan (AMoS) */
+#define QMBS_A046_MOD_ID		0X0000A046	/* Quality Memory Based Scaler */
+#define MDCTL_A047_MOD_ID		0X0000A047	/* DCS Controller for Viper 2 MIPS Bus Segment */
+#define TDCTL_A048_MOD_ID		0X0000A048	/* DCS Controller for Viper 2 TM Bus Segment */
+#define BLMP_A049_MOD_ID		0X0000A049	/* DCS Controller for BLMP PNX1315 Project */
+#define TUNNEL_A04A_MOD_ID		0X0000A04A	/* A chip-to-chip interconnect supporting high bandwidth streaming data & low latency IO traffic */
+#define SIF_A04B_MOD_ID			0X0000A04B	/* Low-cost, High performance 16 bits SDRAM interface */
+#define MIU_A04C_MOD_ID			0X0000A04C	/* Low-cost Memory interface unit to connect 8 and 16 bits peripherals and memories */
+#define DISPLAY_A04D_MOD_ID		0X0000A04D	/* Display unit with scaling/extracting features. 2 taps vertical filter, 10 taps horizontal */
+#define VIEWCONTROL_A04E_MOD_ID	0X0000A04E	/* Cryptographic module to introduce a low-cost anti-piracy system in chips */
+#define DENC_A04F_MOD_ID		0X0000A04F	/* CVBS/Y and C  encoder used to  drive the  DACs */
+#define LCDC_A050_MOD_ID		0X0000A050	/* TFT LCD Power sequencing module */
+#define PCI_A051_MOD_ID			0X0000A051	/*  PCI  w/ 16bit XIO and DTL initiator/DTL targets */
+#define QVCP2L_A052_MOD_ID		0X0000A052	/* Two layer QVCP */
+#define RTC_A053_MOD_ID			0X0000A053	/* Real Time Clock MPMP1 */
+#define DOP_JAGUAR_A054_MOD_ID	0X0000A054	/* DOP Standalone Core for Jaguar Project */
+#define DOP_TOP_GPRU_A055_MOD_ID	0X0000A055	/* DOP Standalone Top Level */
+#define PMSEC_A056_MOD_ID		0X0000A056	/* Pipelined Memory Access Networks (PMAN) Security */
+#define DMAMON_A057_MOD_ID		0X0000A057	/* Pipelined Memory Access Networks (PMAN) monitor */
+#define MDSEC_A058_MOD_ID		0X0000A058	/* DCS controller Security module for the Viper2 MIPS network */
+#define TDSEC_A059_MOD_ID		0X0000A059	/* DCS controller Security module for the Viper2 Trimedia network  */
+#define GPIO_A05C_MOD_ID		0X0000A05C	/* General puprose IO 24 bit Bidirectional */
+#define INTERLACER_A05D_MOD_ID	0X0000A05D	/* Converts progressive video flow into interlaced video */
+#define ITU656F_A05F_MOD_ID		0X0000A05F	/* Psuedo ITU-656 text, video and colour burst data formatter */
+#define ESP_A060_MOD_ID			0X0000A060	/* Embedded Security Processor */
+#define STPP0_A061_MOD_ID		0X0000A061	/* HDLi template - streaming IP to IP connector */
+#define EDMA3_A062_MOD_ID		0X0000A062	/* Enhanced dvi_edma with 3DES functionality and connected to DTL_DMA Bus */
+#define CLOCKS_A063_MOD_ID		0X0000A063	/* clock block */
+#define RESET_A064_MOD_ID		0X0000A064	/* Reset Block for the PNX1500 */
+#define GPIO_A065_MOD_ID		0X0000A065	/* General Purpose I/O for PNX1500 */
+#define MMON_A066_MOD_ID		0X0000A066	/* memory system monitor used to monitor a PMAN (Pipelined Memory Access Network) system */
+#define SND_SYS_A067_MOD_ID		0X0000A067	/* TV Sound Core, containing Demodulator/Decoder and Audio DSPs */
+#define TCTRL_A068_MOD_ID		0X0000A068	/* Global control register for Tiger chip  */
+#define UPC_A069_MOD_ID			0X0000A069	/* Video frame up-converter on Tiger chip */
+#define VPK_A06A_MOD_ID			0X0000A06A	/* Vertical Peaking module on Tiger chip */
+#define TASK_A06B_MOD_ID		0X0000A06B	/* Task module on Tiger chip */
+#define QTUN_OUT_A06C_MOD_ID		0X0000A06C	/* The counterpart of sat_qtun_in supporting high bandwidth chip-to-chip communication and data traffic */
+#define DCSC_A06D_MOD_ID		0X0000A06D	/* DCS Controller Template (Configuration Aperture) */
+#define DCSC_SECURITY_A06E_MOD_ID	0X0000A06E	/* DCS Controller Template (Security Aperture) */
+#define QVCP2L_LITE_A06F_MOD_ID	0X0000A06F	/* QVCP-2L with no pool elements */
+#define ME_A070_MOD_ID			0X0000A070	/* Motion Estimator */
+#define TC_A071_MOD_ID			0X0000A071	/* Video Texture Codec for MPEG 2/4 */
+#define BSG_A072_MOD_ID			0X0000A072	/* Bit-stream Generator for MPEG video encoding */
+#define PAK_A073_MOD_ID			0X0000A073	/* Bit-stream packer */
+#define EVENT_ROUTER_A075_MOD_ID	0X0000A075	/* asynchronous event/interrupt capture and routing */
+#define PCCARD_A076_MOD_ID		0X0000A076	/* 16-bit PC-Card plus ATA-100 host.  (No Card-Bus.) */
+#define MTL_MONITOR_A077_MOD_ID	0X0000A077	/* The MTL Monitor observes traffic at a given point and stores bandwidth/latency information */
+#define RTC_A078_MOD_ID			0X0000A078	/* Real Time Clock */
+#define MDCTL_A079_MOD_ID		0X0000A079	/* DCS Controller for IRIS (BLBA) MIPS Bus Segment */
+#define EDMA_V2_A07A_MOD_ID		0X0000A07A	/* Enhanced DMA Engine */
+#define VO_A07B_MOD_ID			0X0000A07B	/* Simple Video Output and an external Sync slave */
+#define LVDS_LTX_A07C_MOD_ID		0X0000A07C	/* Low Voltage Differential Signaling(LVDS) Transmitter IP */
+#define MPIP_A07D_MOD_ID		0X0000A07D	/* (Multi-) Picture in Picture with CSM */
+#define HD_CLOCKS_A07E_MOD_ID	0X0000A07E	/* clock block for pnx2015 */
+#define QTUN_OUT_A07F_MOD_ID		0X0000A07F	/* The south chip interconnect supporting high bandwidth streaming data & low latency IO traffic */
+#define HOST_IF_A080_MOD_ID		0X0000A080	/* Host IF  */
+#define CPIPE_MVP_A081_MOD_ID	0X0000A081	/* Video Output Pipe for Monarch */
+#define EDMA_CA_A082_MOD_ID		0X0000A082	/* EDMA with conditional access */
+#define CDU_MMU_A083_MOD_ID		0X0000A083	/* Central Data Unit with Memory management */
+#define BMI_A084_MOD_ID			0X0000A084	/* Burst memory interface for connection to DVD+RW frontend */
+#define BM_A085_MOD_ID			0X0000A085	/* Buffer manager for optimized frontend-backend connection */
+#define UBAR_A086_MOD_ID		0X0000A086	/* Universal Block Artefact Removal (UBAR) */
+#define MSVD_A087_MOD_ID		0X0000A087	/* Multi-Standard Video Decoder (MSVD) */
+#define MSVD_CORE_A088_MOD_ID	0X0000A088	/* MSVD Core */
+#define EDA_A089_MOD_ID			0X0000A089	/* Entropy Decoding Accelerator (EDA) */
+#define TSU_A08A_MOD_ID			0X0000A08A	/* PNX2015 Time-Stamp Unit */
+#define HD_GLBREG_A08B_MOD_ID	0X0000A08B	/* Miscellaneous control register block for PNX2015 */
+#define AIO_A08C_MOD_ID			0X0000A08C	/* audio inout */
+#define AXI_MONITOR_A08D_MOD_ID	0X0000A08D	/* The AXI Monitor observes traffic at a given point and stores bandwidth/latency information */
+#define USB2_HS_OTG_A08E_MOD_ID	0X0000A08E	/* USB2 High speed OTG unit with DTL bus */
+#define CPIPE_PROPIC_A08F_MOD_ID	0X0000A08F	/* Composition Pipe for the Propic Project */
+#define MTLHUB_A090_MOD_ID		0X0000A090	/* configurable MTL hub template */
+#define ADC_IF_A091_MOD_ID		0X0000A091	/* Interface between VPB and C18AD10b400k  */
+#define MBVP_A092_MOD_ID		0X0000A092	/* Memory Based Video Processor */
+#define PNX8520_CLOCKS_A093_MOD_ID	0X0000A093	/* Clock block for PNX8520 device */
+#define TSU16_A094_MOD_ID		0X0000A094	/* Time stamp unit (16 time stamps) for PNX8520 */
+#define PNX8520_CI_A095_MOD_ID	0X0000A095	/* Conditional access block used on pnx8520 */
+#define PNX8520_GLBREG1_A096_MOD_ID	0X0000A096	/* Global registers for PNX8520 */
+#define ITU656F_A097_MOD_ID		0X0000A097	/* ITU Formatter for PNX8520 */
+#define RGU_A098_MOD_ID			0X0000A098	/* Reset Builder */
+#define SATA_HOST_A099_MOD_ID	0X0000A099	/* Serial ATA Host controller IP */
+#define DICFID_A09A_MOD_ID		0X0000A09A	/* Digital IVN Chip / Feature ID */
+#define SCU_A09B_MOD_ID			0X0000A09B	/* Digital IVN System Control Unit */
+#define PWM_A09C_MOD_ID			0X0000A09C	/* Digital IVN Pulse Width Modulator */
+#define CPIPE_V1_A09D_MOD_ID		0X0000A09D	/* Composition Pipe for the VSD Program */
+#define SVM_A09E_MOD_ID			0X0000A09E	/* scan velocity modulation */
+#define PNX8520_MDCN_A09F_MOD_ID	0X0000A09F	/* DCS Network for PNX8520 MIPS */
+#define PNX8520_MDCN_A0A0_MOD_ID	0X0000A0A0	/* DCS Network Security for PNX8520 MIPS */
+#define PNX8520_TDCN_A0A1_MOD_ID	0X0000A0A1	/* DCS Network for PNX8520 Trimedia */
+#define PNX8520_TDCN_A0A2_MOD_ID	0X0000A0A2	/* DCS Network Security for PNX8520 Trimedia */
+#define SYSCREG_A0A3_MOD_ID		0X0000A0A3	/* System configuration register */
+#define SND_SYS_A0A4_MOD_ID		0X0000A0A4	/* TV Sound Core Demodulator and Decoder, DemDec DSP */
+#define SND_SYS_A0A5_MOD_ID		0X0000A0A5	/* TV back-end audio processing, Audio DSP */
+#define OUT_A0A6_MOD_ID			0X0000A0A6	/* Generic Transport stream or byte output interface */
+#define FR_DLC_A0A7_MOD_ID		0X0000A0A7	/* FlexRay Data Link Controller */
+#define CGU_A0A8_MOD_ID			0X0000A0A8	/* Clock Builder */
+#define AHBMON_A0A9_MOD_ID		0X0000A0A9	/* AHB Bus Monitor */
+#define TVCLASSREG_A0AA_MOD_ID	0X0000A0AA	/* TV Tuner Class Register */
+#define EXTINT_A0AB_MOD_ID		0X0000A0AB	/* External Interrupts */
+#define IOCONF_A0AC_MOD_ID		0X0000A0AC	/* GPIO */
+#define MEM_DGEN_A0AD_MOD_ID		0X0000A0AD	/* DTL data generator, receiver and checker */
+#define CPIPE_L2_A0AE_MOD_ID		0X0000A0AE	/* Composition PIPE for Video Signals created for TV520 / PNX8535 */
+#define S2D_AS2D_A0AF_MOD_ID		0X0000A0AF	/* Audio stream to dtl converter */
+#define S2D_DS2D_A0B0_MOD_ID		0X0000A0B0	/* VBI stream to dtl converter */
+#define S2D_TS2D_A0B1_MOD_ID		0X0000A0B1	/* Transport stream to dtl converter */
+#define S2D_VS2D_A0B2_MOD_ID		0X0000A0B2	/* VTL stream to dtl converter */
+#define DRM_A0B3_MOD_ID			0X0000A0B3	/* Digital Right Management Module */
+#define LVDSTX10_A0B4_MOD_ID		0X0000A0B4	/* 10bit lvds transmitter interface */
+#define INTERRUPT_VA_A0B5_MOD_ID	0X0000A0B5	/* Interrupt collector */
+#define PMU_A0B6_MOD_ID			0X0000A0B6	/* Gallardo Power Management Unit */
+#define PNX8535_GLBREG_A0B7_MOD_ID	0X0000A0B7	/* Global register module for PNX8535 */
+#define RANDOM_GENERATOR_A0B8_MOD_ID	0X0000A0B8	/* True random generator based on an analog clock */
+#define SND_TOP_A0B9_MOD_ID		0X0000A0B9	/* TV Sound Core Demodulator and Decoder, DemDec DSP ASdec */
+#define SND_TOP_A0BA_MOD_ID		0X0000A0BA	/* TV back-end audio processing, Audio DSP APP */
+#define LVDS_DRX_A0BB_MOD_ID		0X0000A0BB	/* Dual LVDS reciever */
+#define CHAGALL_A0BD_MOD_ID		0X0000A0BD	/* Multi-standard video-compression IP */
+#define BLOB_A0BE_MOD_ID		0X0000A0BE	/* Wasabi "Yellow Blob" Level 2 Cache */
+
+/******************************************************************************
+* Compatibility names for historic misnomers
+* NOTE: This legacy hardware module ID name list addendum is not part of the
+*       tmNxModId.h automatically generated by the MoReUse website.  It is
+*       added by NDK to allow older components to build with the new header
+*       file.  When a new version of tmNxModId.h is downloaded from the
+*       MoReUse website, this section should be copied from this file into
+*       the new file before checking it into the NDK project (until all
+*       legacy module ID references have been removed from NDK).
+*******************************************************************************
+*/
+#define AICP_111_MOD_ID           AICP1_111_MOD_ID
+#define AICP_118_MOD_ID           AICP2_118_MOD_ID
+#define GLBREG_126_MOD_ID         GLBREG1_126_MOD_ID
+#define GLBREG_128_MOD_ID         GLBREG2_128_MOD_ID
+#define GFX2D_131_MOD_ID          GFX2D_132_MOD_ID
+#define PR3930_2B10_MOD_ID        PR33930_2B10_MOD_ID
+#define TM3260_2B80_MOD_ID        TM3218_2B80_MOD_ID
+#define TM64_2b81_MOD_ID          TM64_2B81_MOD_ID
+#define IIC_3203_MOD_ID           I2C_3203_MOD_ID
+#define DVDCSS_A005_MOD_ID        DVDD_A005_MOD_ID
+#define QVCP_A014_MOD_ID          QVCP5L_A014_MOD_ID
+#define QVCP_A019_MOD_ID          QVCP2L_A019_MOD_ID
+#define LVDS_A07C_MOD_ID          LVDS_LTX_A07C_MOD_ID
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* TMNXMODID_H */
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmNxTypes.h linux-2.6.34/include/HwAPI/tmNxTypes.h
--- linux-2.6.34.orig/include/HwAPI/tmNxTypes.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmNxTypes.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,750 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Koninklijke Philips Electronics N.V.
+ *  All Rights Reserved.
+ *
+ * This source code and any compilation or derivative thereof is the
+ * proprietary information of Koninklijke Philips Electronics N.V.
+ * and is confidential in nature.
+ * Under no circumstances is this software to be combined with any Open Source
+ * Software in any way or placed under an Open Source License of any type
+ * without the express written permission of Koninklijke Philips Electronics
+ * N.V.
+ *
+ *############################################################
+ *
+ * Module name  : tmNxTypes.h  %version: eh10#11 %
+ *
+ * Last Update  : %date_modified: Mon Feb 10 21:38:00 2003 %
+ *
+ * Description: MoReUse/Nexperia global type definitions.
+ *
+ * Document Ref: Nexperia/MoReUse Naming Conventions specification
+ *               DVP Software Versioning Specification
+ *               [ Copyright and Version Schemes for Software v3.20 ? ]
+ *
+ *############################################################
+ */
+
+#ifndef TMNXTYPES_H
+#define TMNXTYPES_H
+
+#ifdef	_TMtypes_h
+/* tmtypes.h was already included, skip defining the types already known */
+#define TMOAPTMTYPESINCLUDED
+#else
+#define	_TMtypes_h
+#endif
+
+/*-----------------------------------------------------------------------------
+** Project include files:
+**-----------------------------------------------------------------------------
+** NOTE: tmFlags.h
+**  The tmFlags.h header file defines CPU type/model, OS type/version,
+**  big/little endianness, and other platform-dependent settings.  The file
+**  is automatically generated by the SDE2 build process.  If not using the
+**  SDE2 build process, do the following:
+**  1)  Obtain a copy of tmFlagsExample.h file from the MoReUse website
+**      (URL: http://pww.rtg.sc.philips.com/cmd/html/global_files.html).
+**  2)  Rename the file to tmFlags.h and place it in the build include path.
+**  3)  Modify the file for your platform settings, using the comments in the
+**      file as a guide for the required modifications.
+*/
+#include "tmFlags.h"                /* DVP platform-dependent build flags */
+
+#include "phStdTypes.h"
+
+#include "phExtraTypes.h"
+
+
+/*-----------------------------------------------------------------------------
+** Standard include files:
+**-----------------------------------------------------------------------------
+*/
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*-----------------------------------------------------------------------------
+** Types and defines:
+**-----------------------------------------------------------------------------
+**
+** NOTE: Bool values
+**  TM_TRUE is defined as 1 (instead of !TM_FALSE) to utilize the Trimedia
+**  processor hardware architecture.  Two TM CPU registers are hardwired to
+**  represent the Bool values:  r0 = 0 (TM_FALSE) and r1 = 1 (TM_TRUE).
+*/
+#define TM_FALSE            0       /* replaces legacy False macro */
+#define TM_TRUE             1       /* replaces legacy True  macro */
+
+/*
+** NOTE: Runtime endian byte-order defines
+**  These defines are used for runtime little/big-endian byte-order checks
+**  (as compared with the TMFL_ENDIAN_XXX flags defined in tmFlags.h, which
+**  are only valid at build time and whose big/little-endian values are
+**  reversed compared with these defines).
+*/
+#define TM_ENDIAN_BIG       0       /* replaces legacy BigEndian    macro */
+#define TM_ENDIAN_LITTLE    1       /* replaces legacy LittleEndian macro */
+
+/* NOTE: Nexperia common data types
+**  The common data types used in Nexperia development (UInt32, Int8, etc.)
+**  are defined either directly by this file or indirectly through inclusion
+**  of the Trimedia Compilation and Simulation system (TCS) tmtypes.h header
+**  file.  If the build flag __TCS__ is defined, it indicates a TCS-based
+**  build, so the TCS-provided tmtypes.h file will be used (guaranteeing
+**  compatibility).  If the __TCS__ build flag is not defined, TCS may not
+**  be present and therefore the standard data types defined below will be
+**  used, if they have not already been defined.
+**
+** NOTE 2:  This version of tmNxTypes.h has not been tested with old versions
+**  of TCS.  (Potential problems may exist with TM applications that use
+**  (1) 64-bit types, (2) a very old version of TCS [i.e., one that does not
+**  define 64-bit types in tmtypes.h], and (3) this header file, for example.)
+*/
+#ifdef  __TCS__                     /* TCS present/TriMedia build target */
+
+#ifndef __linux__
+#define __linux__       0         /* avoid TCS undefined preproc. warning */
+#define TEMP__linux__             /* ...but undefine again after tmtypes.h */
+#endif
+
+
+#ifdef TEMP__linux__
+#undef __linux__                  /* don't break Linux-aware builds */
+#undef TEMP__linux__              /* don't pollute namespace unnecessarily */
+#endif
+
+#if (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))
+#define TMFL_NATIVE_INT64   1     /* don't typedef 64-bit types again */
+
+#define I64LIT(i) i##LL
+#define U64LIT(u) u##ULL
+#endif
+
+#else /* ifndef __TCS__ */
+
+#ifdef _TMtypes_h                   /* if TCS tmtypes.h was already included */
+
+#if (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))
+#define TMFL_NATIVE_INT64   1     /* don't typedef 64-bit types again */
+
+#define I64LIT(i) i##LL
+#define U64LIT(u) u##ULL
+#endif
+
+#else /* ifndef _TMtypes_h */       /* if TCS tmtypes.h not (yet) included */
+#define _TMtypes_h                  /* (typedefs defined below) */
+
+#ifndef False
+#define False         (TM_FALSE)  /* NOTE: Legacy - use TM_FALSE instead */
+#endif
+#ifndef True
+#define True          (TM_TRUE)   /* NOTE: Legacy - use TM_TRUE  instead */
+#endif
+
+#ifdef __cplusplus
+#define Null          0
+#else
+#define Null          ((Void *) 0)
+#endif
+
+/*
+** Standard Types
+*/
+typedef void            Void;       /* Void (typeless) */
+/*typedef signed   char   Int8;   *//*  8-bit   signed integer */                   /* Type already defined in phStdTypes.h */
+/*typedef signed   short  Int16;  *//* 16-bit   signed integer */                   /* Type already defined in phStdTypes.h */
+/*typedef signed   long   Int32;  *//* 32-bit   signed integer */                   /* Type already defined in phStdTypes.h */
+/*typedef unsigned char   UInt8;  *//*  8-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
+/*typedef unsigned short  UInt16; *//* 16-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
+/*typedef unsigned long   UInt32; *//* 32-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
+typedef float           Float;      /* 32-bit floating point */
+/* typedef unsigned int    Bool;  *//* Boolean (True/False) */                      /* Type already defined in phStdTypes.h */
+/*typedef char            Char;   *//* character, character array ptr */            /* Type already defined in phStdTypes.h */
+typedef int             Int;        /* machine-natural integer */
+typedef unsigned int    UInt;       /* machine-natural unsigned integer */
+/*typedef char           *String; *//* Null-terminated 8-bit char str */            /* Type already defined in phStdTypes.h */
+
+/*-----------------------------------------------------------------------------
+** Legacy TM Types/Structures (Not necessarily DVP Coding Guideline compliant)
+** NOTE: For Nexperia/DVP Coding Gudeline compliance, do not use these types.
+*/
+/* typedef char          *Address;   *//* Ready for address-arithmetic */          /* Type already defined in phStdTypes.h */
+typedef char const    *ConstAddress;
+typedef unsigned char  Byte;           /* Raw byte */
+typedef float          Float32;        /* Single-precision float */
+typedef double         Float64;        /* Double-precision float */
+typedef void          *Pointer;        /* Pointer to anonymous object */
+typedef void const    *ConstPointer;
+typedef char const    *ConstString;
+
+typedef Int             Endian;             /* NOTE: legacy - use tmEndian_t */
+#define BigEndian       (TM_ENDIAN_BIG)     /* NOTE: use TM_ENDIAN_BIG */
+#define LittleEndian    (TM_ENDIAN_LITTLE)  /* NOTE: use TM_ENDIAN_LITTLE */
+
+/* Required by TMDownloader.h */
+/* TM32 = 0 for compatibility!, allow many tm32 versions before TM64 */
+typedef enum { TM32 = 0, TM3260, TM5250, TM2270, TM64=100 } TMArch;
+extern char* TMArch_names[];
+
+typedef struct tmVersion
+{
+    UInt8   majorVersion;
+    UInt8   minorVersion;
+    UInt16  buildVersion;
+}   tmVersion_t, *ptmVersion_t;
+
+#endif /* ifndef _TMtypes_h */
+#endif /* ifdef  __TCS__ */
+
+/*
+** NOTE: Compiler version-dependent support
+**  C/C++ compiler versions C99 and later support 64-bit signed/unsigned
+**  integers and some special keywords (such as "restrict") natively.  As
+**  the compiler version used to compile this header file can vary, some
+**  preprocessor checks are done to determine if the features are supported,
+**  are not supported and must be emulated, or must be disabled altogether.
+**  The __STDC_VERSION__ compiler version number (if defined) is compared
+**  with the expected compiler version.  If the compiler version is not
+**  defined, it is assumed that the compiler does not support the features.
+**
+**  [Note:  this appears to be an overly strict assumption; many compilers do
+**  not define it by default, despite supporting many or most C99 features.
+**  GNU C 3.x defines it only with the command-line option "-std=c99".]
+*/
+#define TMFL_STDC_VERSION_C89   198912L /* C89 compiler version (simulated) */
+#define TMFL_STDC_VERSION_C95   199409L /* C95 compiler version number */
+#define TMFL_STDC_VERSION_C99   199901L /* C99 compliant if >= this version */
+
+#define TMFL_MSC_VERSION_600    1200    /* Microsoft Visual C Version 6.00 */
+
+#ifndef __STDC_VERSION__
+#define __STDC_VERSION__      (TMFL_STDC_VERSION_C89) /* assume old comp. */
+   /* FIXME:  should this be protected (i.e., undefined again later), too? */
+#endif
+
+#ifndef _MSC_VER
+#define _MSC_VER              (1)     /* prevent undefined preproc warning */
+#define TEMP_MSC_VER                  /* undefine again later! */
+#endif
+
+#ifndef __TCS_VERSION__
+#define __TCS_VERSION__       (1)     /* prevent undefined preproc warning */
+#define TEMP__TCS_VERSION__           /* undefine again later! */
+#endif
+
+/*-----------------------------------------------------------------------------
+** 64-bit native vs. 64-bit emulation (via struct).
+**
+** Use native 64-bit integer math for compilers that have it.
+** This can be enabled only when all explicit references to the hi and lo
+** structure members are eliminated from client code. [see MSVC comments below]
+**
+** [NOTE:  Native 64-bit via "long long" should probably be the default, as in
+** TCS's tmtypes.h, with 64-bit emulation triggered only by special ifdefs.]
+*/
+
+#ifndef TMFL_NATIVE_INT64  /* don't typedef 64-bit types if tmtypes.h did so */
+
+/*  o __STDC_VERSION__ used for C99 support (see discussion above)
+**  o __USE_ISOC99 and __GLIBC_HAVE_LONG_LONG added for Linux/GCC
+**     compatibility (TCS and tmman32 requirement)
+**  o sun/__SVR4 (a.k.a. Solaris/SPARC) and __hpux added for TCS (build-host)
+**     compatibility
+**  o _LONGLONG is defined by some older 64-bit compilers
+**  o LLONG_MAX would be defined in <limits.h> and is arguably the safest and
+**     most generic test ... should we go ahead and #include it above?
+*/
+#if     (__STDC_VERSION__ >= TMFL_STDC_VERSION_C99) ||                         \
+        defined(__USE_ISOC99) ||                                               \
+        defined(__GLIBC_HAVE_LONG_LONG) ||                                     \
+        (defined(sun) && defined(__SVR4)) ||                                   \
+        defined(__hpux) ||                                                     \
+        defined(_LONGLONG) ||                                                  \
+        defined(LLONG_MAX) ||                                                  \
+	    (__GNUC__ == 3)    ||                                                  \
+        (__GNUC__ == 4)
+
+#define TMFL_NATIVE_INT64   1           /* Native 64-bit integer support */
+
+#define I64LIT(i) i##LL
+#define U64LIT(u) u##ULL
+
+/* Type already defined in phStdTypes.h */
+//typedef signed   long long int Int64;   /* 64-bit signed   integer */
+//typedef unsigned long long int UInt64;  /* 64-bit unsigned integer */
+
+#elif   (defined (_MSC_VER) && (_MSC_VER >= TMFL_MSC_VERSION_600))
+/* NOTE: Microsoft Visual C 64-bit integer support
+**  The Microsoft Visual C compiler, version 6.0 (and later), has native 64-bit
+**  integer support.  As some code (legacy apps only) currently accesses the
+**  emulated 64-bit integer structure .hi/.lo members directly (rather than
+**  through macros), that code will not compile if the MSC 64-bit integer
+**  support is enabled.  For this reason, the MSC 64-bit integer support
+**  originally was disabled (commented out), but current NDK, TCS, and tmComm
+**  (TMC) shared-code considerations are considered to have precedence.
+*/
+
+#define TMFL_NATIVE_INT64   1           /* Native 64-bit integer support */
+
+#define I64LIT(i) i##i64
+#define U64LIT(u) u##ui64
+
+/* Type already defined in phStdTypes.h */
+//typedef signed   __int64 Int64;         /* 64-bit signed   integer */
+//typedef unsigned __int64 UInt64;        /* 64-bit unsigned integer */
+
+#elif   (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))
+
+        /* Native Int64/UInt64 integer types are unconditionally defined in
+         * newer versions of tmtypes.h, already included above when __TCS__
+         * is defined.
+         *
+         * [Note that this sub-block actually will NOT BE REACHED because
+         *  TMFL_NATIVE_INT64 is already defined to be 1 whenever we detect
+         *  (or force) the prior inclusion of tmtypes.h and have TCS >= 3.10;
+         *  this entire block is protected by #ifndef TMFL_NATIVE_INT64.] */
+
+#define TMFL_NATIVE_INT64 1           /* Native 64-bit integer support */
+
+#define I64LIT(i) i##LL
+#define U64LIT(u) u##ULL
+
+#else /* No native compiler support for long long int Int64/UInt64 data type */
+
+/* NOTE: Int64/UInt64 integer emulation data structures
+** The Int64/UInt64 data structures defined below are used to emulate 64-bit
+** integer support when used with older compilers that don't support them
+** natively.  The data structure members (hi/lo) should not be accessed
+** directly by software as this prevents the code from being portable when
+** being built by compilers that do support 64-bit integers natively.
+** Instead, code should use tmArith.h (tmArith infrastructure component)
+** which defines a set of macros for portable operations involving 64-bit
+** integers (e.g., I64ADD, U64GT, U8CASTI64, F32CASTI64, etc.).
+*/
+#define TMFL_NATIVE_INT64   0           /* No native 64-bit integer support */
+
+/*
+ * I64LIT(), U64LIT() not available in this case.
+ */
+
+/* Type already defined in phStdTypes.h */
+//typedef struct                          /* Int64: 64-bit signed integer */
+//{
+//        /* Get the correct endianness (this has no impact on any other part of
+//            the system, but it may make memory dumps easier to understand). */
+//#if     (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+//        Int32 hi; UInt32 lo;
+//#else
+//        UInt32 lo; Int32 hi;
+//#endif
+//}   Int64;
+
+//typedef struct                          /* UInt64: 64-bit unsigned integer */
+//{
+//#if     (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+//        UInt32 hi; UInt32 lo;
+//#else
+//        UInt32 lo; UInt32 hi;
+//#endif
+//}   UInt64;
+
+#endif /* (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310)) */
+       /* (defined (_MSC_VER) && (_MSC_VER >= TMFL_MSC_VERSION_600)) */
+       /* (__STDC_VERSION__ >= TMFL_STDC_VERSION_C99) ||
+          defined(__USE_ISOC99) ||
+          defined(__GLIBC_HAVE_LONG_LONG) ||
+          (defined(sun) && defined(__SVR4)) ||
+          defined(__hpux) ||
+          defined(_LONGLONG) ||
+          defined(LLONG_MAX) */
+
+#endif /* ifndef TMFL_NATIVE_INT64 */
+
+#ifdef TEMP_MSC_VER
+#undef _MSC_VER                       /* don't break MSVC-aware builds */
+#undef TEMP_MSC_VER
+#endif
+
+#ifdef TEMP__TCS_VERSION__
+#undef __TCS_VERSION__                /* don't break TCS-aware builds */
+#undef TEMP__TCS_VERSION__
+#endif
+
+/* Define DVP types that are not TCS types.
+** NOTE: IBits32/UBits32 types are defined for use with 32-bit bitfields.
+**       This is done because ANSI/ISO compliant compilers require bitfields
+**       to be of type "int" else a large number of compiler warnings will
+**       result.  To avoid the risks associated with redefining Int32/UInt32
+**       to type "int" instead of type "long" (which are the same size on 32-
+**       bit CPUs) separate 32-bit signed/unsigned bitfield types are defined.
+*/
+typedef signed   int    IBits32;    /* 32-bit   signed integer bitfields */
+typedef unsigned int    UBits32;    /* 32-bit unsigned integer bitfields */
+
+/*typedef Int8    *pInt8;         *//*  8-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef Int16   *pInt16;        *//* 16-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef Int32   *pInt32;        *//* 32-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef Int64   *pInt64;        *//* 64-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
+typedef IBits32 *pIBits32;          /* 32-bit   signed integer bitfield ptr */
+typedef UBits32 *pUBits32;          /* 32-bit unsigned integer bitfield ptr */
+/*typedef UInt8   *pUInt8;        *//*  8-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef UInt16  *pUInt16;       *//* 16-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef UInt32  *pUInt32;       *//* 32-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
+/*typedef UInt64  *pUInt64;       *//* 64-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
+typedef Void    *pVoid;             /* Void (typeless) ptr */
+typedef Float   *pFloat;            /* 32-bit floating point, float ptr */
+typedef double  Double, *pDouble;   /* 32/64-bit floating point, double ptr */
+/*typedef Bool    *pBool;         *//* Boolean (True/False) ptr */                  /* Type already defined in phStdTypes.h */
+/*typedef Char    *pChar;         *//* character, character array ptr */            /* Type already defined in phStdTypes.h */
+typedef Int     *pInt;              /* machine-natural integer ptr */
+typedef UInt    *pUInt;             /* machine-natural unsigned integer ptr */
+/*typedef String  *pString;       *//* Null-terminated 8-bit char str ptr */        /* Type already defined in phStdTypes.h */
+
+typedef Int     tmEndian_t, *ptmEndian_t;   /* replaces legacy Endian type */
+
+/* Maximum length of device name in all DVP BSL and capability structures */
+#define HAL_DEVICE_NAME_LENGTH  16
+
+/*typedef UInt32 tmErrorCode_t;*/                                                   /* Type already defined in phStdTypes.h */
+typedef UInt32 tmProgressCode_t;
+
+/* timestamp definition */
+typedef UInt64 tmTimeStamp_t, *ptmTimeStamp_t;
+
+/* for backwards compatibility with the older tmTimeStamp_t definition */
+#define ticks   lo
+#define hiTicks hi
+
+typedef union tmColor3                 /* 3-byte color structure */
+{
+    UBits32 u32;
+#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+    struct {
+        UBits32       : 8;
+        UBits32 red   : 8;
+        UBits32 green : 8;
+        UBits32 blue  : 8;
+    } rgb;
+    struct {
+        UBits32   : 8;
+        UBits32 y : 8;
+        UBits32 u : 8;
+        UBits32 v : 8;
+    } yuv;
+    struct {
+        UBits32   : 8;
+        UBits32 u : 8;
+        UBits32 m : 8;
+        UBits32 l : 8;
+    } uml;
+#else /* (TMFL_ENDIAN == TMFL_ENDIAN_LITTLE) */
+    struct {
+        UBits32 blue  : 8;
+        UBits32 green : 8;
+        UBits32 red   : 8;
+        UBits32       : 8;
+    } rgb;
+    struct {
+        UBits32 v : 8;
+        UBits32 u : 8;
+        UBits32 y : 8;
+        UBits32   : 8;
+    } yuv;
+    struct {
+        UBits32 l : 8;
+        UBits32 m : 8;
+        UBits32 u : 8;
+        UBits32   : 8;
+    } uml;
+#endif /* (TMFL_ENDIAN == TMFL_ENDIAN_BIG) */
+}   tmColor3_t, *ptmColor3_t;
+
+typedef union tmColor4                 /* 4-byte color structure */
+{
+    UBits32 u32;
+#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
+    struct {
+        UBits32 alpha    : 8;
+        UBits32 red      : 8;
+        UBits32 green    : 8;
+        UBits32 blue     : 8;
+    } argb;
+    struct {
+        UBits32 alpha    : 8;
+        UBits32 y        : 8;
+        UBits32 u        : 8;
+        UBits32 v        : 8;
+    } ayuv;
+    struct {
+        UBits32 alpha    : 8;
+        UBits32 u        : 8;
+        UBits32 m        : 8;
+        UBits32 l        : 8;
+    } auml;
+#else /* (TMFL_ENDIAN == TMFL_ENDIAN_LITTLE) */
+    struct {
+        UBits32 blue     : 8;
+        UBits32 green    : 8;
+        UBits32 red      : 8;
+        UBits32 alpha    : 8;
+    } argb;
+    struct {
+        UBits32 v        : 8;
+        UBits32 u        : 8;
+        UBits32 y        : 8;
+        UBits32 alpha    : 8;
+    } ayuv;
+    struct {
+        UBits32 l        : 8;
+        UBits32 m        : 8;
+        UBits32 u        : 8;
+        UBits32 alpha    : 8;
+    } auml;
+#endif /* (TMFL_ENDIAN == TMFL_ENDIAN_BIG) */
+}   tmColor4_t, *ptmColor4_t;
+
+/*-----------------------------------------------------------------------------
+** Hardware device power states
+*/
+typedef enum tmPowerState
+{
+    tmPowerOn,                          /* Device powered on      (D0 state) */
+    tmPowerStandby,                     /* Device power standby   (D1 state) */
+    tmPowerSuspend,                     /* Device power suspended (D2 state) */
+    tmPowerOff                          /* Device powered off     (D3 state) */
+
+}   tmPowerState_t, *ptmPowerState_t;
+
+/*-----------------------------------------------------------------------------
+** Software Version Structure
+*/
+typedef struct tmSWVersion
+{
+    UInt32      compatibilityNr;        /* Interface compatibility number */
+    UInt32      majorVersionNr;         /* Interface major version number */
+    UInt32      minorVersionNr;         /* Interface minor version number */
+
+}   tmSWVersion_t, *ptmSWVersion_t;
+
+/*-----------------------------------------------------------------------------
+** NOTE: This macro converts four characters into a UInt32 value.  It is used
+**       instead of multi-character constants (i.e. 'ABCD') to prevent some
+**       compiler warnings, especially with GNU-based compilers.
+*/
+#define TM_CHARS_TO_UINT32(a,b,c,d) ((UInt32) ((UInt8) (a) << 24 | (UInt8) (b) << 16 | (UInt8) (c) << 8 | (UInt8) (d)))
+
+/* NOTE: TCS tmBoardDef.h
+**  tmNxTypes.h duplicates many of the same typedefs that are defined in the
+**  Trimedia Compilation and Simulation system (TCS) tmBoardDef.h header file
+**  so there is no requirement that TCS be installed on a development system.
+**  To prevent type definition conflicts when both header files are used by a
+**  source file, the check for _TMBOARDDEF_H_ is done.  Whichever header file
+**  (tmNxTypes.h or TCS tmBoardDef.h) is included first will define the
+**  shared types and define _TMBOARDDEF_H_, thereby excluding the type
+**  definitions in the other header file.
+*/
+#ifndef _TMBOARDDEF_H_                  /* tmBoardDef.h not included (yet) */
+#define _TMBOARDDEF_H_                  /* exclude tmBoardDef.h defines */
+
+/*-----------------------------------------------------------------------------
+** HW Unit Selection
+*/
+typedef Int tmUnitSelect_t, *ptmUnitSelect_t;
+
+#define tmUnitNone (-1)
+#define tmUnit0    0
+#define tmUnit1    1
+#define tmUnit2    2
+#define tmUnit3    3
+#define tmUnit4    4
+
+/*+compatibility*/
+#define unitSelect_t       tmUnitSelect_t
+#define unit0              tmUnit0
+#define unit1              tmUnit1
+#define unit2              tmUnit2
+#define unit3              tmUnit3
+#define unit4              tmUnit4
+#define DEVICE_NAME_LENGTH HAL_DEVICE_NAME_LENGTH
+/*-compatibility*/
+
+#endif /* ifndef _TMBOARDDEF_H_ */
+
+/* Additional tmUnitSelect_t defines (not duplicated in TCS tmBoardDef.h) */
+#define tmUnit5    5
+#define tmUnit6    6
+#define tmUnit7    7
+
+/*-----------------------------------------------------------------------------
+** Instance handle
+*/
+typedef Int tmInstance_t, *ptmInstance_t;
+
+/* Callback function declaration */
+typedef Void (*ptmCallback_t) (UInt32 events, Void *pData, UInt32 userData);
+#define tmCallback_t ptmCallback_t /*compatibility*/
+
+#if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+
+/*-----------------------------------------------------------------------------
+** Shared data segment macro - Places shared data in named DLL data segment.
+** WinNT/WinCE: Use TMSHARED_DATA_BEGIN/TMSHARED_DATA_END for multiprocess
+**  shared data on a single CPU.  To define data variables that are shared
+**  across all processes for WinNT/WinCE, use the defined #pragma macros
+**  TMSHARED_DATA_BEGIN/TMSHARED_DATA_END and initialize the data variables
+**  as shown in the example below.  Data defined outside of the begin/end
+**  section or not initialized will not be shared across all processes for
+**  WinNT/WinCE; there will be a separate instance of the variable in each
+**  process.  Use WinNT Explorer "QuickView" on the target DLL or text edit
+**  the target DLL *.map file to verify the shared data section presence and
+**  size (shared/static variables will not be named in the MAP file but will
+**  be included in the shared section virtual size).
+** NOTE: All data variables in the multiprocess section _MUST_BE_INITIALIZED_
+**       to be shared across processes; if no explicit initialization is
+**       done, the data variables will not be shared across processes.  This
+**       shared data mechanism only applies to WinNT/WinCE multiprocess data
+**       on a single CPU (pSOS shares all data across tasks by default).  Use
+**       the TMML MP shared data region for shared data across multiple CPUs
+**       and multiple processes.  Example (note global variable naming):
+**
+**  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+**  #pragma TMSHARED_DATA_BEGIN         // Multiprocess shared data begin
+**  #endif
+**
+**  static g<Multiprocess shared data variable> = <Initialization value>;
+**         gtm<Multiprocess shared data variable> = <Initialization value>;
+**
+**  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+**  #pragma TMSHARED_DATA_END           // Multiprocess shared data end
+**  #endif
+**
+** NOTE: These pragma defines require that the DLL flags include the following
+**       line: "-section:.tmShare,RWS" in the makelib.mk and maketarget.mk
+**       (or equivalent) target OS makefiles for this mechanism to work.
+*/
+#define TMSHARED_DATA_BEGIN     data_seg(".tmShare")
+#define TMSHARED_DATA_END       data_seg()
+
+#endif /* (TMFL_OS_IS_CE || TMFL_OS_IS_NT) */
+
+#if     (!(defined __TCS__) && (__STDC_VERSION__ < TMFL_STDC_VERSION_C99))
+
+/*-----------------------------------------------------------------------------
+** 'C' language keywords
+** ---------------------
+**  [inline]
+**  The Trimedia Compilation and Simulation system (TCS) compiler and also
+**  C99 or later compilers support the "inline" keyword.  For non-TCS and
+**  pre-C99 compilant compilers, the "inline" keyword is mapped to the native
+**  compiler's equivalent keyword.  The inline keyword is excluded if this
+**  header file is being compiled in a C++ environment (__cplusplus defined).
+**
+**  [restrict]
+**  The "restrict" keyword (e.g., UInt32 * restrict pData) tells the 'C'
+**  compiler that within the scope of this pointer, no other pointer will
+**  alias to the same memory location (i.e., the only way to access the data
+**  is through this pointer), allowing the compiler to perform certain code
+**  optimizations.  The "restrict" keyword is supported by the Trimedia
+**  Compilation and Simulation system (TCS) tmcc compiler and by C99 and
+**  later compiler versions.  If the compiler doesn't support "restrict," the
+**  keyword is defined as blank (nothing).
+*/
+#if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
+
+#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
+#define inline      __inline
+#endif /* (!defined __cplusplus) */
+
+#define restrict    /**/
+
+#elif      TMFL_OS_IS_PSOS && TMFL_CPU_IS_MIPS
+
+/* NOTE regarding the keyword INLINE:
+**
+** Inline is not an ANSI-C keyword, hence every compiler can implement inlining
+** the way it wants to. When using the dcc compiler this might possibly lead to
+** redeclaration warnings when linking. For example:
+**
+**      dld: warning: Redeclaration of tmmlGetMemHandle
+**      dld:    Defined in root.o
+**      dld:    and        tmmlApi.o(../../lib/pSOS-MIPS/libtmml.a)
+**
+** For the dcc compiler inlining is not on by default. When building a retail
+** version ( _TMTGTREL=ret), inlining is turned on explicitly in the dvp1 pSOS
+** makefiles by specifying -XO, which enables all standard optimizations plus
+** some others, including inlining (see the Language User's Manual, D-CC and
+** D-C++ Compiler Suites p46). When building a debug version ( _TMTGTREL=dbg),
+** the optimizations are not turned on (and even if they were they would have
+** been overruled by -g anyway).
+**
+** When a .h file with inline function declarations gets included in multiple
+** source files, redeclaration warnings are issued.
+**
+** When building a retail version those functions are inlined, but in addition
+** the function is also declared within the .o file, resulting in redeclaration
+** warnings as the same function is also defined by including that same header
+** file in other source files. Defining the functions as static inline rather
+** than inline solves the problem, as now the additional function declaration
+** is omitted (as now the compiler realizes that there is no point in keeping
+** that declaration as it can only be called from within this specific file,
+** but it isn't, because all calls are already inline).
+**
+** When building a debug version no inlining is done, but the functions are
+** still defined within the .o file, again resulting in redeclaration warnings.
+** Again, defining the functions to be static inline rather than inline solves
+** the problem.
+**
+** Now if we would change the definition of the inline keyword for pSOS from
+** __inline__ to static __inline__, all inline function definitions throughout
+** the code would not issue redeclaration warnings anymore, but all static
+** inline definitions would.
+** If we don't change the definition of the inline keyword, all inline func-
+** tion definitions would return redeclaration warnings.
+**
+** As this is a pSOS linker bug, it was decided not to change the code but
+** rather to ignore the issued warnings.
+*/
+#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
+#define inline      __inline__
+#endif /* (!defined __cplusplus) */
+
+#define restrict    /**/
+
+#elif   (TMFL_OS_IS_PSOS && TMFL_CPU_IS_TM)
+/* TCS supports the "inline"   keyword */
+/* TCS supports the "restrict" keyword */
+
+#elif   (TMFL_OS_IS_VXWORKS || TMFL_OS_IS_HPUNIX || TMFL_OS_IS_NULLOS)
+/*
+** TMFL_OS_IS_HPUNIX is the HP Unix workstation target OS environment for the
+** DVP SDE2 using the GNU gcc toolset.  It is the same as TMFL_OS_IS_NULLOS
+** (which is inaccurately named because it is the HP Unix CPU/OS target
+** environment).
+** TMFL_OS_IS_VXWORKS is the VxWorks build which also uses the GNU toolset.
+** TMFL_OS_IS_LINUX is the Linux build which also used the GNU toolset.
+*/
+#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
+#define inline      __inline__
+#endif /* (!defined __cplusplus) */
+
+#define restrict    /**/
+
+#elif   (TMFL_OS_IS_LINUX)
+
+#else /* TMFL_OS_IS_??? */
+
+#error ERROR: Unrecognized/unsupported TMFL_OS_IS_XXX value !
+
+#endif /* TMFL_OS_IS_XXX */
+#endif /* (!(defined __TCS__) && (__STDC_VERSION__ < TMFL_STDC_VERSION_C99)) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef TMNXTYPES_H */
+
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmStdLib.h linux-2.6.34/include/HwAPI/tmStdLib.h
--- linux-2.6.34.orig/include/HwAPI/tmStdLib.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmStdLib.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,76 @@
+//-----------------------------------------------------------------------------
+// $Header: /nexperia/inc/tmStdLib.h    04/30/02 9:03a Glydon $
+// (C) Copyright 1999,2000,2001,2002 Philips Semiconductors, All rights reserved
+//
+// This source code and any compilation or derivative thereof is the sole
+// property of Philips Corporation and is provided pursuant to a Software
+// License Agreement.  This code is the proprietary information of Philips
+// Corporation and is confidential in nature.  Its use and dissemination by
+// any party other than Philips Corporation is strictly limited by the
+// confidential information provisions of the Agreement referenced above.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmStdLib.h
+//
+// DESCRIPTION:  DVP version of ANSI standard i/o, standard lib & string
+//               functions. The file contains the function prototypes that
+//               should be used for standard i/o, standard lib and string
+//               functions. Only a subset of the ANSI standard functions
+//               is provided.
+//
+// DOCUMENT REF: DVP Software Coding Guidelines
+//               DVP/MoReUse Naming Conventions specification
+//               DVP Software Versioning Specification
+//
+// NOTES:        None
+//-----------------------------------------------------------------------------
+//
+#ifndef TMSTDLIB_H //--------------------
+#define TMSTDLIB_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+//#include <tmFlags.h>
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+// Include or define "size_t" type based on target OS environment
+//
+#include <linux/types.h>
+
+// _DLL is defined if compiling for NT and -MDd
+#if        !defined(__CRTIMP)
+#if        defined(_DLL) || (defined(UNDER_CE) && !defined(COREDLL))
+#define __CRTIMP __declspec(dllimport)
+#else   // defined(_DLL) || (defined(UNDER_CE) && !defined(COREDLL))
+#define __CRTIMP
+#endif  // defined(_DLL) || (defined(UNDER_CE) && !defined(COREDLL))
+#endif  // !defined(__CRTIMP)
+
+#ifdef _MSC_VER
+#define __CDECL __cdecl
+#else   // TMFL_OS_IS_CE || TMFL_OS_IS_NT
+#define __CDECL
+#endif  // TMFL_OS_IS_CE || TMFL_OS_IS_NT
+
+// overload the __CRTIMP and __CDECL defines as 'empty'
+#if defined(__GNUC__) || defined(UNDER_CE)
+#undef __CRTIMP
+#define __CRTIMP
+#undef __CDECL
+#define __CDECL
+#endif
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// String/Mem functions:
+//
+#include <linux/string.h>
+
+#endif // TMSTDLIB_H //------------------
diff -Naurp linux-2.6.34.orig/include/HwAPI/tmSysCfg.h linux-2.6.34/include/HwAPI/tmSysCfg.h
--- linux-2.6.34.orig/include/HwAPI/tmSysCfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/HwAPI/tmSysCfg.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,112 @@
+//-----------------------------------------------------------------------------
+// $Header: /ds_ndk/inc/cfg/tmSysCfg.h  04/19/04 Glydon $
+// Copyright (C) 2000,2001,2002,2003,2004 
+// Koninklijke Philips Electronics N.V., All Rights Reserved.
+// This source code and any compilation or derivative thereof is the
+// proprietary information of Koninklijke Philips Electronics N.V.
+// and is confidential in nature.
+// Under no circumstances is this software to be exposed to or placed
+// under an Open Source License of any type without the expressed
+// written permission of Koninklijke Philips Electronics N.V.
+//-----------------------------------------------------------------------------
+// FILE NAME:    tmSysCfg.h
+//
+// DESCRIPTION:  This is the platform specific system configuration header
+//               file.  It's purpose is to provide a central place where 
+//               platform specific settings can be changed by the customer
+//               (or whoever is building the DVP platform software).  This 
+//               file is included into DVP component configuration source
+//               files (tmdl<Component>Cfg.c).  Values defined here will 
+//               override the values defined in the local source files.
+//
+//               This should be the only file modified by the end user for
+//               a specific platform (changing the individual DVP component 
+//               configuration source files will have an impact on all target
+//               platforms and operating systems using that component).  To
+//               override the default values in the component configuration
+//               file(s), just #define the new values in this file (refer to
+//               the DVP component configuration files for the #define'able
+//               settings):
+//
+//               #define TM[LAYER]_<COMP>_CFG_XXX   <NewDefault>
+//
+//               Values can be defined in tmSysCfg.h for specific CPU/OS 
+//               build configurations using the tmFlags.h build flags such 
+//               as this example for the tmbslV2Pci x86_nt host CPU debug 
+//               memory buffer size:
+//
+//               // Reserve 1MB debug memory buffer for x86_nt target builds
+//               #if   ((TMFL_CPU_IS_X86) && (TMFL_OS_IS_NT))
+//               #define TMBSL_V2PCI_HOSTDBG_SIZE   0x100000
+//               #endif // ((TMFL_CPU_IS_X86) && (TMFL_OS_IS_NT))
+//
+//               DVP component configuration file #define'd values should be
+//               MoReUse compliant so that there are no conflicts between 
+//               different components or between layers of the same component
+//               type.  DVP component configuration files should define all
+//               values surrounded by the #ifndef/#define/#endif preprocessor
+//               commands so that if values with the same name are defined in
+//               this file (tmSysCfg.h), they override the component header
+//               file values without generating compiler redefinition warnings:
+//
+//               #ifndef TM[LAYER]_<COMP>_CFG_XXX  // If !defined in tmSysCfg.h
+//               #define TM[LAYER]_<COMP>_CFG_XXX   <ComponentCfgDefault>
+//               #endif
+//
+// DOCUMENT REF: DVP Software Coding Guidelines specification
+//               MoReUse Naming Conventions specification
+//               DVP Software Architecture specification
+//               DVP Device Library specification
+//
+// NOTES:        System RAM region size defines for each board/OS combination
+//               are located in the BSL target board/OS specific files:
+//
+//  /DS_ndk/boards/comps/tmbsl<BoardComp>/src/<targetOS>/tmbslBoardOsSpecific.c
+//
+//               Refer to the specific BSL board files for more details about
+//               RAM configuration options in single and multiple processor
+//               hardware configurations.
+//-----------------------------------------------------------------------------
+//
+#ifndef TMSYSCFG_H //-------------------
+#define TMSYSCFG_H
+
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+#include <tmFlags.h>                    // DVP target environment build flags
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+// TODO: Define any values here that will be used to used to override default
+//       component configuration values (optionally using CPU/OS conditional
+//       flags from tmFlags.h).
+//
+
+
+// Possibility for customers (projects) to have their own addition/overrides on
+// values that are defined here.
+
+#ifdef TMFL_TMCUSTOMSYSCFG_H
+#include <tmCustomSysCfg.h>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // TMSYSCFG_H //-----------------
diff -Naurp linux-2.6.34.orig/include/linux/amba/pl08x.h linux-2.6.34/include/linux/amba/pl08x.h
--- linux-2.6.34.orig/include/linux/amba/pl08x.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/amba/pl08x.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,184 @@
+/*
+ * linux/amba/pl08x.h - ARM PrimeCell DMA Controller driver
+ *
+ * Copyright (C) 2005 ARM Ltd
+ * Copyright (C) 2010 ST-Ericsson SA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * pl08x information required by platform code
+ *
+ * Please credit ARM.com
+ * Documentation: ARM DDI 0196D
+ *
+ */
+
+#ifndef AMBA_PL08X_H
+#define AMBA_PL08X_H
+
+/* We need sizes of structs from this header */
+#include <linux/dmaengine.h>
+
+/**
+ * struct pl08x_channel_data - data structure to pass info between
+ * platform and PL08x driver regarding channel configuration
+ * @bus_id: name of this device channel, not just a device name since
+ * devices may have more than one channel e.g. "foo_tx"
+ * @min_signal: the minimum DMA signal number to be muxed in for this
+ * channel (for platforms supporting muxed signals). If you have
+ * static assignments, make sure this is set to the assigned signal
+ * number, PL08x have 16 possible signals in number 0 thru 15 so
+ * when these are not enough they often get muxed (in hardware)
+ * disabling simultaneous use of the same channel for two devices.
+ * @max_signal: the maximum DMA signal number to be muxed in for
+ * the channel. Set to the same as min_signal for
+ * devices with static assignments
+ * @muxval: a number usually used to poke into some mux regiser to
+ * mux in the signal to this channel
+ * @cctl_opt: default options for the channel control register
+ * @addr: source/target address in physical memory for this DMA channel,
+ * can be the address of a FIFO register for burst requests for example.
+ * This can be left undefined if the PrimeCell API is used for configuring
+ * this.
+ * @circular_buffer: whether the buffer passed in is circular and
+ * shall simply be looped round round (like a record baby round
+ * round round round)
+ * @single: the device connected to this channel will request single
+ * DMA transfers, not bursts. (Bursts are default.)
+ */
+struct pl08x_channel_data {
+	char *bus_id;
+	int min_signal;
+	int max_signal;
+	u32 muxval;
+	u32 cctl;
+	u32 ccfg;
+	dma_addr_t addr;
+	bool circular_buffer;
+	bool single;
+};
+
+/**
+ * Struct pl08x_bus_data - information of source or destination
+ * busses for a transfer
+ * @addr: current address
+ * @maxwidth: the maximum width of a transfer on this bus
+ * @buswidth: the width of this bus in bytes: 1, 2 or 4
+ * @fill_bytes: bytes required to fill to the next bus memory
+ * boundary
+ */
+struct pl08x_bus_data {
+	dma_addr_t addr;
+	u8 maxwidth;
+	u8 buswidth;
+	u32 fill_bytes;
+};
+
+/**
+ * struct pl08x_phy_chan - holder for the physical channels
+ * @id: physical index to this channel
+ * @lock: a lock to use when altering an instance of this struct
+ * @signal: the physical signal (aka channel) serving this
+ * physical channel right now
+ * @serving: the virtual channel currently being served by this
+ * physical channel
+ */
+struct pl08x_phy_chan {
+	unsigned int id;
+	void __iomem *base;
+	spinlock_t lock;
+	int signal;
+	struct pl08x_dma_chan *serving;
+	u32 csrc;
+	u32 cdst;
+	u32 clli;
+	u32 cctl;
+	u32 ccfg;
+};
+
+/**
+ * struct pl08x_txd - wrapper for struct dma_async_tx_descriptor
+ * @llis_bus: DMA memory address (physical) start for the LLIs
+ * @llis_va: virtual memory address start for the LLIs
+ */
+struct pl08x_txd {
+	struct dma_async_tx_descriptor tx;
+	struct list_head node;
+	enum dma_data_direction	direction;
+	struct pl08x_bus_data srcbus;
+	struct pl08x_bus_data dstbus;
+	int len;
+	dma_addr_t llis_bus;
+	void *llis_va;
+	struct pl08x_channel_data *cd;
+	bool active;
+	/* Settings to be put into the physical channel when we submit this txd */
+	u32 csrc;
+	u32 cdst;
+	u32 clli;
+	u32 cctl;
+};
+
+/**
+ * struct pl08x_dma_chan - this structure wraps a DMA ENGINE channel
+ * @chan: wrappped abstract channel
+ * @phychan: the physical channel utilized by this channel, if there is one
+ * @tasklet: tasklet scheduled by the IRQ to handle actual work etc
+ * @name: name of channel
+ * @cd: channel platform data
+ * @runtime_addr: address for RX/TX according to the runtime config
+ * @runtime_direction: current direction of this channel according to
+ * runtime config
+ * @lc: last completed transaction on this channel
+ * @desc_list: queued transactions pending on this channel
+ * @at: active transaction on this channel
+ * @lock: a lock for this channel data
+ * @host: a pointer to the host (internal use)
+ * @paused: whether the channel is paused
+ */
+struct pl08x_dma_chan {
+	struct dma_chan chan;
+	struct pl08x_phy_chan *phychan;
+	struct tasklet_struct tasklet;
+	char *name;
+	struct pl08x_channel_data *cd;
+	dma_addr_t runtime_addr;
+	enum dma_data_direction	runtime_direction;
+	atomic_t last_issued;
+	dma_cookie_t lc;
+	struct list_head desc_list;
+	struct pl08x_txd *at;
+	spinlock_t lock;
+	void *host;
+	bool paused;
+};
+
+/**
+ * struct pl08x_platform_data - the platform configuration for the
+ * PL08x PrimeCells.
+ * @slave_channels: the channels defined for the different devices on the
+ * platform, all inclusive, including multiplexed channels. The available
+ * physical channels will be multiplexed around these signals as they
+ * are requested, just enumerate all possible channels.
+ * @get_signal: request a physical signal to be used for a DMA
+ * transfer immediately: if there is some multiplexing or similar blocking
+ * the use of the channel the transfer can be denied by returning
+ * less than zero, else it returns the allocated signal number
+ * @put_signal: indicate to the platform that this physical signal is not
+ * running any DMA transfer and multiplexing can be recycled
+ * @bus_bit_lli: Bit[0] of the address indicated which AHB bus master the
+ * LLI addresses are on 0/1 Master 1/2.
+ */
+struct pl08x_platform_data {
+	struct pl08x_channel_data *slave_channels;
+	unsigned int num_slave_channels;
+	struct pl08x_channel_data memcpy_channel;
+	int (*get_signal)(struct pl08x_dma_chan *);
+	void (*put_signal)(struct pl08x_dma_chan *);
+};
+
+bool pl08x_filter_id(struct dma_chan *chan, void *chan_id);
+
+#endif	/* AMBA_PL08X_H */
diff -Naurp linux-2.6.34.orig/include/linux/amba/pl330.h linux-2.6.34/include/linux/amba/pl330.h
--- linux-2.6.34.orig/include/linux/amba/pl330.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/amba/pl330.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,45 @@
+/* linux/include/linux/amba/pl330.h
+ *
+ * Copyright (C) 2010 Samsung Electronics Co. Ltd.
+ *	Jaswinder Singh <jassi.brar@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef	__AMBA_PL330_H_
+#define	__AMBA_PL330_H_
+
+#include <asm/hardware/pl330.h>
+
+struct dma_pl330_peri {
+	/*
+	 * Peri_Req i/f of the DMAC that is
+	 * peripheral could be reached from.
+	 */
+	u8 peri_id; /* {0, 31} */
+	enum pl330_reqtype rqtype;
+
+	/* For M->D and D->M Channels */
+	int burst_sz; /* in power of 2 */
+	dma_addr_t fifo_addr;
+};
+
+struct dma_pl330_platdata {
+	/*
+	 * Number of valid peripherals connected to DMAC.
+	 * This may be different from the value read from
+	 * CR0, as the PL330 implementation might have 'holes'
+	 * in the peri list or the peri could also be reached
+	 * from another DMAC which the platform prefers.
+	 */
+	u8 nr_valid_peri;
+	/* Array of valid peripherals */
+	struct dma_pl330_peri *peri;
+	/* Bytes to allocate for MC buffer */
+	unsigned mcbuf_sz;
+};
+
+#endif	/* __AMBA_PL330_H_ */
diff -Naurp linux-2.6.34.orig/include/linux/i2c.h linux-2.6.34/include/linux/i2c.h
--- linux-2.6.34.orig/include/linux/i2c.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/i2c.h	2010-09-07 22:16:41.000000000 -0500
@@ -329,6 +329,8 @@ struct i2c_algorithm {
 	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,
 			   unsigned short flags, char read_write,
 			   u8 command, int size, union i2c_smbus_data *data);
+    /* --- ioctl like call to set div. parameters. */
+    int (*algo_control)(struct i2c_adapter *, unsigned int, unsigned long);
 
 	/* To determine what the adapter supports */
 	u32 (*functionality) (struct i2c_adapter *);
diff -Naurp linux-2.6.34.orig/include/linux/i2c_phlm.h linux-2.6.34/include/linux/i2c_phlm.h
--- linux-2.6.34.orig/include/linux/i2c_phlm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/i2c_phlm.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,199 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (C) 2007 NXP B.V.
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %name:    i2c_phlm.h %
+ * %version: 1 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Contains Slave functionality related
+ *               data structures. The application must include this
+ *               header file.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef I2C_PHLM_H
+#define I2C_PHLM_H
+
+#include <linux/types.h>
+
+#define I2C_M_WR    0x00
+
+#define I2C_SET_SLAVE_ENABLE      _IOW('G', 0x0731, int)
+#define I2C_SET_SLAVE_DISABLE     _IO('G', 0x0732)
+
+#define I2C_GET_SLAVE_INFO        _IOR('G', 0x0733, unsigned char*)
+
+#define I2C_SLAVE_RD_DONE         _IO('G', 0x0734)
+#define I2C_SLAVE_WR_DONE         _IO('G', 0x0735)
+#define I2C_SET_SPEED             _IOW('G', 0x0736, unsigned char*)
+#define I2C_SLAVE_BUS_ERROR       _IO('G', 0x0737)
+#define I2C_SET_MASTER_TIMEOUT    _IOW('G', 0x738, unsigned int)
+#define I2C_SOFT_RESET            _IOW('G',0x739,unsigned int)
+#define I2C_SET_SLAVE_TIMEOUT     _IOW('G',0x740,unsigned int)
+
+/* Error codes in case of timeout*/
+#define ESTART_TIMEOUT        120
+#define ETRANSIT_TIMEOUT      121
+#define EMASTERLOST_TIMEOUT   122
+#define ESLAVE_TIMEOUT        123
+
+typedef struct
+{
+    __u32 fskhz;    /* for fast or standard speed in khz*/
+    __u32 hskhz;    /* for high speed in khz*/
+    __u8 hs;        /*Boolean- True: High speed is set;
+                                 False: otherwise*/
+}i2c_ph_xferspeed;
+
+typedef struct i2c_slave
+{
+    __u8  slave_addr;   /* slave address */
+    __u8  general_call; /* True: enables general call */
+    __u8 *tx_buf;      /* Transmit buffer */
+    __u8 *rx_buf;      /* Receive buffer */
+    __u32 tx_data_length; /* length of the slave transmit buffer */
+    __u32 rx_data_length; /* length of the slave recieve buffer */
+    __u32 rx_tx_bytecount; /* indicates number of bytes read or written.
+                            Updated by kernel after Slave transfer */
+    __u32 slave_event;    /* Slave Event from the i2c driver
+                            I2C_SLAVE_RD_DONE or I2C_SLAVE_WR_DONE OR I2C_SLAVE_BUS_ERROR
+                            */
+}i2c_slave_data;
+
+
+#define I2C_SUSPEND		  _IO('G', 0x741)
+#define I2C_RESUME		  _IO('G', 0x742)
+
+#ifndef __KERNEL__
+
+/*
+ * I2C Message - used for pure i2c transaction, also from /dev interface
+ */
+struct i2c_msg {
+    __u16 addr; /* slave address            */
+    __u16 flags;
+#define I2C_M_TEN   0x10    /* we have a ten bit chip address   */
+#define I2C_M_RD    0x01
+#define I2C_M_NOSTART   0x4000
+#define I2C_M_REV_DIR_ADDR  0x2000
+#define I2C_M_IGNORE_NAK    0x1000
+#define I2C_M_NO_RD_ACK     0x0800
+    __u16 len;      /* msg length               */
+    __u8 *buf;      /* pointer to msg data          */
+};
+
+/* To determine what functionality is present */
+
+#define I2C_FUNC_I2C            0x00000001
+#define I2C_FUNC_10BIT_ADDR     0x00000002
+#define I2C_FUNC_PROTOCOL_MANGLING  0x00000004 /* I2C_M_{REV_DIR_ADDR,NOSTART,..} */
+#define I2C_FUNC_SMBUS_HWPEC_CALC   0x00000008 /* SMBus 2.0 */
+#define I2C_FUNC_SMBUS_BLOCK_PROC_CALL  0x00008000 /* SMBus 2.0 */
+#define I2C_FUNC_SMBUS_QUICK        0x00010000
+#define I2C_FUNC_SMBUS_READ_BYTE    0x00020000
+#define I2C_FUNC_SMBUS_WRITE_BYTE   0x00040000
+#define I2C_FUNC_SMBUS_READ_BYTE_DATA   0x00080000
+#define I2C_FUNC_SMBUS_WRITE_BYTE_DATA  0x00100000
+#define I2C_FUNC_SMBUS_READ_WORD_DATA   0x00200000
+#define I2C_FUNC_SMBUS_WRITE_WORD_DATA  0x00400000
+#define I2C_FUNC_SMBUS_PROC_CALL    0x00800000
+#define I2C_FUNC_SMBUS_READ_BLOCK_DATA  0x01000000
+#define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000
+#define I2C_FUNC_SMBUS_READ_I2C_BLOCK   0x04000000 /* I2C-like block xfer  */
+#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK  0x08000000 /* w/ 1-byte reg. addr. */
+#define I2C_FUNC_SMBUS_READ_I2C_BLOCK_2  0x10000000 /* I2C-like block xfer  */
+#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK_2 0x20000000 /* w/ 2-byte reg. addr. */
+
+#define I2C_FUNC_SMBUS_BYTE (I2C_FUNC_SMBUS_READ_BYTE | \
+                             I2C_FUNC_SMBUS_WRITE_BYTE)
+#define I2C_FUNC_SMBUS_BYTE_DATA (I2C_FUNC_SMBUS_READ_BYTE_DATA | \
+                                  I2C_FUNC_SMBUS_WRITE_BYTE_DATA)
+#define I2C_FUNC_SMBUS_WORD_DATA (I2C_FUNC_SMBUS_READ_WORD_DATA | \
+                                  I2C_FUNC_SMBUS_WRITE_WORD_DATA)
+#define I2C_FUNC_SMBUS_BLOCK_DATA (I2C_FUNC_SMBUS_READ_BLOCK_DATA | \
+                                   I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)
+#define I2C_FUNC_SMBUS_I2C_BLOCK (I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
+                                  I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)
+#define I2C_FUNC_SMBUS_I2C_BLOCK_2 (I2C_FUNC_SMBUS_READ_I2C_BLOCK_2 | \
+                                    I2C_FUNC_SMBUS_WRITE_I2C_BLOCK_2)
+
+#define I2C_FUNC_SMBUS_EMUL (I2C_FUNC_SMBUS_QUICK | \
+                             I2C_FUNC_SMBUS_BYTE | \
+                             I2C_FUNC_SMBUS_BYTE_DATA | \
+                             I2C_FUNC_SMBUS_WORD_DATA | \
+                             I2C_FUNC_SMBUS_PROC_CALL | \
+                             I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \
+                             I2C_FUNC_SMBUS_I2C_BLOCK)
+
+/*
+ * Data for SMBus Messages
+ */
+#define I2C_SMBUS_BLOCK_MAX 32  /* As specified in SMBus standard */
+union i2c_smbus_data {
+    __u8 byte;
+    __u16 word;
+    __u8 block[I2C_SMBUS_BLOCK_MAX + 2]; /* block[0] is used for length */
+                           /* and one more for user-space compatibility */
+};
+
+/* smbus_access read or write markers */
+#define I2C_SMBUS_READ  1
+#define I2C_SMBUS_WRITE 0
+
+/* SMBus transaction types (size parameter in the above functions)
+   Note: these no longer correspond to the (arbitrary) PIIX4 internal codes! */
+#define I2C_SMBUS_QUICK         0
+#define I2C_SMBUS_BYTE          1
+#define I2C_SMBUS_BYTE_DATA     2
+#define I2C_SMBUS_WORD_DATA     3
+#define I2C_SMBUS_PROC_CALL     4
+#define I2C_SMBUS_BLOCK_DATA        5
+#define I2C_SMBUS_I2C_BLOCK_DATA    6
+#define I2C_SMBUS_BLOCK_PROC_CALL   7       /* SMBus 2.0 */
+
+
+/* ----- commands for the ioctl like i2c_command call:
+ * note that additional calls are defined in the algorithm and hw
+ *  dependent layers - these can be listed here, or see the
+ *  corresponding header files.
+ */
+                /* -> bit-adapter specific ioctls   */
+#define I2C_RETRIES 0x0701  /* number of times a device address      */
+                /* should be polled when not            */
+                                /* acknowledging            */
+#define I2C_TIMEOUT 0x0702  /* set timeout - call with int      */
+
+
+/* this is for i2c-dev.c    */
+#define I2C_SLAVE   0x0703  /* Change slave address         */
+                /* Attn.: Slave address is 7 or 10 bits */
+#define I2C_SLAVE_FORCE 0x0706  /* Change slave address         */
+                /* Attn.: Slave address is 7 or 10 bits */
+                /* This changes the address, even if it */
+                /* is already taken!            */
+#define I2C_TENBIT  0x0704  /* 0 for 7 bit addrs, != 0 for 10 bit   */
+
+#define I2C_FUNCS   0x0705  /* Get the adapter functionality */
+#define I2C_RDWR    0x0707  /* Combined R/W transfer (one stop only)*/
+#define I2C_PEC     0x0708  /* != 0 for SMBus PEC                   */
+
+#define I2C_SMBUS   0x0720  /* SMBus-level access */
+
+#endif /*__KERNEL__*/
+#endif /* I2C_PHLM_H*/
diff -Naurp linux-2.6.34.orig/include/linux/mtd/mtd.h linux-2.6.34/include/linux/mtd/mtd.h
--- linux-2.6.34.orig/include/linux/mtd/mtd.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/mtd/mtd.h	2010-09-07 22:16:41.000000000 -0500
@@ -228,6 +228,10 @@ struct mtd_info {
 	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
 	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
 
+	/* block read */
+    int (*block_read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+    int (*block_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+
 	struct notifier_block reboot_notifier;  /* default mode before reboot */
 
 	/* ECC status information */
@@ -247,6 +251,16 @@ struct mtd_info {
 	 * supposed to be called by MTD users */
 	int (*get_device) (struct mtd_info *mtd);
 	void (*put_device) (struct mtd_info *mtd);
+
+	/*
+	 * Optional functions:
+	 *
+	 * Note: those are only possible on the master device and are
+	 * not inherited by the parititon devices.
+	 *
+	 * repartition: reread the partition information.
+	 */
+	int (*repartition) (struct mtd_info *mtd);
 };
 
 static inline struct mtd_info *dev_to_mtd(struct device *dev)
diff -Naurp linux-2.6.34.orig/include/linux/mtd/nand.h linux-2.6.34/include/linux/mtd/nand.h
--- linux-2.6.34.orig/include/linux/mtd/nand.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/mtd/nand.h	2010-09-07 22:16:41.000000000 -0500
@@ -169,6 +169,9 @@ typedef enum {
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
+/* Allow clearing of bad block table entries */
+#define NAND_ALLOW_CLEAR_BBT	0x00000400
+
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
diff -Naurp linux-2.6.34.orig/include/linux/nx_dmac_1902.h linux-2.6.34/include/linux/nx_dmac_1902.h
--- linux-2.6.34.orig/include/linux/nx_dmac_1902.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/nx_dmac_1902.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,130 @@
+/*
+ * Device driver for DMA Controller IP_1902
+ *
+ * Copyright (C) 2009 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author                   Date          Remarks
+ * 0.0.1		Mahadev K Cholachagudda  20090528     Draft-Initial version
+ *
+ */
+
+
+#ifndef _NX_DMAC_1902_H_
+#define _NX_DMAC_1902_H_
+
+#include <linux/dmaengine.h>
+
+/*
+ * There is no platform data present for DMA controller IP_1902
+ */
+
+/** burst size */
+/*!
+ * This enumeration specifies the burst size of a burst transfer used in DMA 
+ * transfer
+ */
+typedef enum {
+  nx_dmac_1902_burst_1 = 0x00, /*!< Burst size = 1 */
+  nx_dmac_1902_burst_4,        /*!< Burst size = 4 */
+  nx_dmac_1902_burst_8,        /*!< Burst size = 8 */
+  nx_dmac_1902_burst_16,       /*!< Burst size = 16 */
+  nx_dmac_1902_burst_32,       /*!< Burst size = 32 */
+  nx_dmac_1902_burst_64,       /*!< Burst size = 64 */
+  nx_dmac_1902_burst_128,      /*!< Burst size = 128 */
+  nx_dmac_1902_burst_256       /*!< Burst size = 256 */
+} nx_dmac_1902_burst;
+
+/*!
+ * This enumeration specifies the flow control type that is used to transfer
+ * the data through DMA
+ */
+typedef enum {
+  nx_dmac_1902_fcntl_DMA_M_to_M = 0x00, /*!< DMA being flow-controller and between memory to memory */
+  nx_dmac_1902_fcntl_DMA_M_to_P,        /*!< DMA being flow-controller and from memory to peripheral direction */
+  nx_dmac_1902_fcntl_DMA_P_to_M,        /*!< DMA being flow-controller and from peripheral to memory direction */
+  nx_dmac_1902_fcntl_DMA_P_to_P,        /*!< DMA being flow-controller and from peripheral to peripheral direction */
+  nx_dmac_1902_fcntl_dst_per_P_to_P,    /*!< Destination peripheral being flow-controller and from peripheral to peripheral direction */
+  nx_dmac_1902_fcntl_per_M_to_P,        /*!< Peripheral being flow-controller and from memory to peripheral direction */
+  nx_dmac_1902_fcntl_per_P_to_M,        /*!< Peripheral being flow-controller and from peripheral to memory direction */
+  nx_dmac_1902_fcntl_src_per_P_to_P,    /*!< Source peripheral being flow-controller and from peripheral to peripheral direction */
+} nx_dmac_1902_fcntl;
+
+/*!
+ * This enumeration specifies the AHB master that is selected for different
+ * transfers (source/destination)
+ */
+typedef enum {
+  nx_dmac_1902_ahb_master_1 = 0x00, /*!< AHB master 1 is selected for the transfer */
+  nx_dmac_1902_ahb_master_2         /*!< AHB master 2 is selected for the transfer */
+} nx_dmac_1902_ahb_master;
+
+/**
+ * enum dma_slave_width - DMA slave register access width.
+ * @DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
+ */
+enum dma_slave_width {
+	DMA_SLAVE_WIDTH_8BIT,
+	DMA_SLAVE_WIDTH_16BIT,
+	DMA_SLAVE_WIDTH_32BIT,
+};
+
+/*!
+ * DMAC IP_1902 specific configuration to be performed by the DMA client. This
+ * structure should be updated by the DMA client (other peripheral drivers
+ * which makes use of the DMAC IP_1902 for data transfer before calling the 
+ * \a dma_async_client_chan_request() in there driver module.
+ *
+ * This data should be part of the platform specific data of the DMA client.
+ *
+ * @dma_dev: required DMA master device
+ * @src_per_num: Peripheral number that is assigned in the DMAC IP_1902 for source device
+ * @dst_per_num: Peripheral number that is assigned in the DMAC IP_1902 for destination device
+ * @src_burst: Source burst size for DMA transfer
+ * @dst_burst: Destintation burst size for DMA transfer
+ * @src_incr: To increment the source location (0->no increment, 1->increment)
+ * @dst_incr: To increment the destination location (0->no increment, 1->increment)
+ * @flow_cntrl: Flow controller type for the data transfer.
+ * @src_select: AHB master selected for source transfer
+ * @dst_select: AHB master selected for destination transfer
+ * @src_width: Source peripheral bus width
+ * @dst_width: Destination peripheral bus width
+ */
+struct nx_dmac_1902_slave {
+  struct device           *dma_dev;
+  /* client specific data to be programmed into the IP_1902 */
+  u8                      src_per_num;
+  u8                      dst_per_num;
+  nx_dmac_1902_burst      src_burst;
+  nx_dmac_1902_burst      dst_burst;
+  u8                      src_incr;
+  u8                      dst_incr;
+  nx_dmac_1902_fcntl      flow_cntrl;
+  nx_dmac_1902_ahb_master src_select;
+  nx_dmac_1902_ahb_master dst_select;
+  enum dma_slave_width    src_width;
+  enum dma_slave_width    dst_width;
+  enum dma_slave_width	  reg_width;
+  dma_addr_t		      tx_reg;
+  dma_addr_t		      rx_reg;
+};
+
+#endif /* _NX_DMAC_1902_H_ */
+
diff -Naurp linux-2.6.34.orig/include/linux/nx_dmac.h linux-2.6.34/include/linux/nx_dmac.h
--- linux-2.6.34.orig/include/linux/nx_dmac.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/nx_dmac.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,200 @@
+/*
+ * Device driver for DMAC IP_1902.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version  	Author           Date          Remarks		
+ * 0.0.1		Bangaragiri G			20080402		Draft-Initial version
+ * 0.1.0		Bangaragiri G			20080804		Proposal-After self review
+ * 1.0.0		Bangaragiri G			20090305		Accepted-After testing on TV550M0 board
+ * 1.1.0		Bangaragiri G			20090313		Accepted-Updates for OneNAND
+ */
+#ifndef _NX_DMAC_H
+#define _NX_DMAC_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+
+/**
+ * Number of descriptors per channel
+ **/
+#define NR_DESCRIPTORS      16
+/**
+* Flow control 
+*/
+typedef enum tag_dmac_fl {
+	nx_dmac_mem2mem_dma=0x0,			/* mem2mem with DMA flow control */
+	nx_dmac_mem2per_dma=0x1,			/* mem2per with DMA flow control */
+	nx_dmac_per2mem_dma=0x2,			/* per2mem with DMA flow control */
+	nx_dmac_per2per_dma=0x3,			/* per2per with DMA flow control */
+	nx_dmac_per2per_dstper=0x4,		/* per2per with dst per flow control */
+	nx_dmac_mem2per_per=0x5,			/* mem2per with per flow control */
+	nx_dmac_per2mem_per=0x6,			/* per2mem with per flow control */
+	nx_dmac_per2per_srcper=0x7,		/* per2per with src per flow control */
+} nx_dmac_flctl_t;					
+
+/**
+* DMAC burst size 
+*/
+typedef enum tag_dmac_burst {
+	nx_dmac_1=0x0,					/*	1 word */	
+	nx_dmac_4=0x1,					/*	4 words */	
+	nx_dmac_8=0x2,					/*	8 words */	
+	nx_dmac_16=0x3,					/*	16 words */	
+	nx_dmac_32=0x4,					/*	32 words */	
+	nx_dmac_64=0x5,					/*	64 words */	
+	nx_dmac_128=0x6,				/*	128 words */	
+	nx_dmac_256=0x7,				/*	256 words */	
+} nx_dmac_burst_t;					
+
+/**
+* DMAC width 
+*/
+typedef enum tag_dmac_width {
+	nx_dmac_width_8=0x0,					/*	8 bits */	
+	nx_dmac_width_16=0x1,					/*	16 bits */	
+	nx_dmac_width_32=0x2,					/*	32 bits */	
+} nx_dmac_width_t;					
+
+/**
+* DMAC scatter gather request structure 
+*/
+typedef struct tag_dmac_stgt {
+	uint32_t		src_addr;					/* Source physical address */
+	uint32_t		dst_addr;					/* Destination physical address */
+	uint32_t		tfr_size;					/* Transfer size in words */
+	nx_dmac_flctl_t		flowctl;					/* Flow control */
+	uint32_t		src_per;					/* Source peripheral number */
+	uint32_t		dst_per;					/* Destination perpheral number */
+	uint32_t		src_ahb;					/* Source AHB master */
+	uint32_t		dst_ahb;					/* Destination AHB master */
+	bool			src_inc;						/* Source Increment flag */
+	bool			dst_inc;						/* Destination Increment flag */
+	nx_dmac_burst_t		src_brst;		/* Source burst size */
+	nx_dmac_burst_t		dst_brst;		/* Destination burst size */
+	nx_dmac_width_t		src_width;	/* Source width */
+	nx_dmac_width_t		dst_width;	/* Destination width */
+} nx_dmac_stgt_t;
+
+/**
+* DMAC Transfer request structure 
+*/
+typedef struct tag_dmac_tfr {
+ 	int                 num_reqs;         /* # of requests in scatter gather */
+ 	nx_dmac_stgt_t	    *req; 			      /* Scatter gather structure */
+} nx_dmac_tfr_t;
+
+/**
+* DMAC Transfer function 
+*/
+extern int nx_dmac_tfr(nx_dmac_tfr_t *req);
+
+/**
+* DMAC Transfer complete function 
+*/
+extern int nx_dmac_tfr_comp(int chanid);
+
+/** 
+ * Following are the declarations to be 
+ * used only by the 
+ * device driver source file
+ **/
+#define 	NX_DMAC_INT_STATUS					(0x000)
+#define 	NX_DMAC_INT_TC_STATUS				(0x004)
+#define 	NX_DMAC_INT_TC_CLR					(0x008)
+#define 	NX_DMAC_INT_ERR_STATUS			(0x00C)
+#define 	NX_DMAC_INT_ERR_CLR					(0x010)
+#define 	NX_DMAC_INT_RAW_TC_STATUS		(0x014)
+#define 	NX_DMAC_INT_RAW_ERR_STATUS	(0x018)
+#define 	NX_DMAC_ENLD_CHANS					(0x01C)
+#define 	NX_DMAC_SOFT_BREQ						(0x020)
+#define 	NX_DMAC_SOFT_SREQ						(0x024)
+#define 	NX_DMAC_SOFT_LBREQ					(0x028)
+#define 	NX_DMAC_SOFT_LSREQ					(0x02C)
+#define 	NX_DMAC_CONFIG							(0x030)
+#define 	NX_DMAC_SYNC								(0x034)
+#define 	NX_DMAC_CHAN0_SRC						(0x100)
+#define 	NX_DMAC_CHAN0_DST						(0x104)
+#define 	NX_DMAC_CHAN0_LLI						(0x108)
+#define 	NX_DMAC_CHAN0_CTRL					(0x10C)
+#define 	NX_DMAC_CHAN0_CONFIG				(0x110)
+#define 	NX_DMAC_PERI_ID0						(0xFE0)
+#define 	NX_DMAC_PERI_ID1						(0xFE4)
+#define 	NX_DMAC_PERI_ID2						(0xFE8)
+#define 	NX_DMAC_PERI_ID3						(0xFEC)
+#define 	NX_DMAC_CELL_ID0						(0xFF0)
+#define 	NX_DMAC_CELL_ID1						(0xFF4)
+#define 	NX_DMAC_CELL_ID2						(0xFF8)
+#define 	NX_DMAC_CELL_ID3						(0xFFC)
+
+#define		NX_DMAC_CHAN_OFF						(0x020)
+
+/**
+* DMAC LLI structure 
+*/
+struct nx_dmac_lli_t {
+	uint32_t						src_addr;					/* Source physical address */
+	uint32_t						dst_addr;					/* Source physical address */
+	uint32_t						next_lli;					/* Next LLI address */
+	uint32_t						ctrl;							/* Control word for transfer */
+};
+
+/**
+* DMAC channel structure 
+*/
+struct nx_dmac_chan_t {
+ 	int                 chanid;           /* channel ID */
+	bool								busy;							/* In use */
+ 	struct mutex		    chan_lock;        /* Channel mutex */
+ 	int								  chan_status;      /* DMAC channel status */
+	wait_queue_head_t   chan_queue;       /* DMAC channel queue */     
+	struct nx_dmac_lli_t	*lli_ptr;				/* LLI ptr for channel */
+	dma_addr_t          lli_phy;      /* Physical address of LLI */
+};
+
+/**
+* DMAC device structure 
+*/
+struct nx_dmac_t {
+  void __iomem        		*dmac_base; 	/* DMAC base address */
+	int											num_chans;		/* # of supported channels */
+	int											num_ahb_mas;	/* # of AHB masters */
+	int											num_reqs;			/* # of requestors */
+ 	struct mutex		    		dmac_lock;    /* DMAC lock */
+	struct	nx_dmac_chan_t	*chans;				/* Channel structure */
+};
+
+/* NAND+NOR DMA support -> used by nx_dmac.c and nx_nor.c */
+#define NX_DMAC_NOR_DMA_CHANNEL_ID  (7)
+
+#endif /* __KERNEL__ */
+
+#endif /* _NX_DMAC_H */
diff -Naurp linux-2.6.34.orig/include/linux/pci_ids.h linux-2.6.34/include/linux/pci_ids.h
--- linux-2.6.34.orig/include/linux/pci_ids.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/pci_ids.h	2010-09-07 22:16:41.000000000 -0500
@@ -212,6 +212,10 @@
 #define PCI_DEVICE_ID_LSI_SAS1078	0x0060
 
 #define PCI_VENDOR_ID_ATI		0x1002
+
+#define PCI_VENDOR_ID_FULLHAN		      0x3086
+#define PCI_DEVICE_ID_FULLHAN_FH8735   0x0101
+
 /* Mach64 */
 #define PCI_DEVICE_ID_ATI_68800		0x4158
 #define PCI_DEVICE_ID_ATI_215CT222	0x4354
diff -Naurp linux-2.6.34.orig/include/linux/pci_regs.h linux-2.6.34/include/linux/pci_regs.h
--- linux-2.6.34.orig/include/linux/pci_regs.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/pci_regs.h	2010-09-07 22:16:41.000000000 -0500
@@ -35,9 +35,9 @@
 #define  PCI_COMMAND_SPECIAL	0x8	/* Enable response to special cycles */
 #define  PCI_COMMAND_INVALIDATE	0x10	/* Use memory write and invalidate */
 #define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
-#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_PARITY	0x0/*0x40*/	/* Enable parity checking */
 #define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
-#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_SERR	0x0/*0x100*/	/* Enable SERR */
 #define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
 #define  PCI_COMMAND_INTX_DISABLE 0x400 /* INTx Emulation Disable */
 
@@ -47,7 +47,7 @@
 #define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
 #define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
 #define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
-#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_PARITY	0x0/*0x100*/	/* Detected parity error */
 #define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
 #define  PCI_STATUS_DEVSEL_FAST		0x000
 #define  PCI_STATUS_DEVSEL_MEDIUM	0x200
@@ -55,8 +55,8 @@
 #define  PCI_STATUS_SIG_TARGET_ABORT	0x800 /* Set on target abort */
 #define  PCI_STATUS_REC_TARGET_ABORT	0x1000 /* Master ack of " */
 #define  PCI_STATUS_REC_MASTER_ABORT	0x2000 /* Set on master abort */
-#define  PCI_STATUS_SIG_SYSTEM_ERROR	0x4000 /* Set when we drive SERR */
-#define  PCI_STATUS_DETECTED_PARITY	0x8000 /* Set on parity error */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR	0x0/*0x4000*/ /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY	0x0/*0x8000*/ /* Set on parity error */
 
 #define PCI_CLASS_REVISION	0x08	/* High 24 bits are class, low 8 revision */
 #define PCI_REVISION_ID		0x08	/* Revision ID */
diff -Naurp linux-2.6.34.orig/include/linux/semaphore.h linux-2.6.34/include/linux/semaphore.h
--- linux-2.6.34.orig/include/linux/semaphore.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/semaphore.h	2010-09-07 22:16:41.000000000 -0500
@@ -41,6 +41,7 @@ static inline void sema_init(struct sema
 
 extern void down(struct semaphore *sem);
 extern int __must_check down_interruptible(struct semaphore *sem);
+extern int __must_check down_timeout_interruptible(struct semaphore *sem, long jiffies);
 extern int __must_check down_killable(struct semaphore *sem);
 extern int __must_check down_trylock(struct semaphore *sem);
 extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
diff -Naurp linux-2.6.34.orig/include/mtd/mtd-abi.h linux-2.6.34/include/mtd/mtd-abi.h
--- linux-2.6.34.orig/include/mtd/mtd-abi.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/mtd/mtd-abi.h	2010-09-07 22:16:41.000000000 -0500
@@ -42,6 +42,8 @@ struct mtd_oob_buf64 {
 #define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
 #define MTD_NO_ERASE		0x1000	/* No erase necessary */
 #define MTD_POWERUP_LOCK	0x2000	/* Always locked after reset */
+#define MTD_SKIP_BB_FOR_SQUASHFS	0x4000	/* skip bas blocks */
+#define MTD_USE_DEV_OOB_LAYOUT    0x10000 /* Use Device OOB Layout */
 
 // Some common devices / combinations of capabilities
 #define MTD_CAP_ROM		0
diff -Naurp linux-2.6.34.orig/include/net/LIPP_6300ETH/gmac_ioctl.h linux-2.6.34/include/net/LIPP_6300ETH/gmac_ioctl.h
--- linux-2.6.34.orig/include/net/LIPP_6300ETH/gmac_ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/net/LIPP_6300ETH/gmac_ioctl.h	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,507 @@
+#ifndef __GMAC_IOCTL_H__
+#define __GMAC_IOCTL_H__
+
+#include <linux/types.h>
+#include <linux/sockios.h>
+
+/* Data that is to be passed from the application to the driver
+** This is stored as a pointer to structure 'wakeupinfo' 
+*/
+#ifndef bool
+#define bool int
+#define True 1
+#define False 0
+#endif
+
+/*----------------------------------------------------------------------------
+** Device specific IOCTLs 
+**---------------------------------------------------------------------------*/
+/* En2512 Specific IOCTLs  */
+#define SIOCCLINKDRV    (SIOCDEVPRIVATE+1)  // Control plane commands for the driver
+#define SIOCGCLINKMEM   (SIOCDEVPRIVATE+2)  // Reads registers/memory in c.LINK address space
+#define SIOCSCLINKMEM   (SIOCDEVPRIVATE+3)  // Sets registers/memory in c.LINK address space
+#define SIOCGCLNKCMD    (SIOCDEVPRIVATE+10) // pass thru c.LINK command that expects a response
+#define SIOCSCLNKCMD    (SIOCDEVPRIVATE+11) // pass thru c.LINK command that expects no response
+#define SIOCLNKDRV      (SIOCDEVPRIVATE+12) // a. Initialize Mailbox Queue Handler b. Get Unsolicited Message
+#define SIOCHDRCMD      (SIOCDEVPRIVATE+13)  // Resets the SoC , Control the diplexer switch etc.
+
+#define ETH_POWER_DOWN (SIOCDEVPRIVATE+5)
+
+/* ETH_GMAC_DEBUG is valid only if the GMAC driver is compiled with  
+** __LIPP_6300ETH_DEBUG__ flag in the makefile 
+*/
+#define ETH_GMAC_DEBUG (SIOCDEVPRIVATE+6)
+
+#define ETH_DRV_CONFIG (SIOCDEVPRIVATE+7)
+
+#define ETH_DRV_RMON_CONFIG (SIOCDEVPRIVATE+8)
+
+#define ETH_DRV_RMON_READ (SIOCDEVPRIVATE+9)
+
+/*----------------------------------------------------------------------------
+** Macros for MMC statistics counters 
+**---------------------------------------------------------------------------*/
+
+#define TX_OCTET_CNT_GB (0x0U)
+/*! \def TX_OCTET_CNT_GB
+* Macro used to read the txoctetcount_gb counter
+*/
+
+#define TX_FRAME_CNT_GB (0x1U)
+/*! \def TX_FRAME_CNT_GB
+* Macro used to read the txframecount_gb counter
+*/
+
+#define TX_BRDCST_CNT_G (0x2U)
+/*! \def TX_BRDCST_CNT_G
+* Macro used to read the txbroadcastframes_g counter
+*/
+
+#define TX_MULTCST_CNT_G (0x3U)
+/*! \def TX_MULTCST_CNT_G
+* Macro used to read the txmulticastframes_g counter 
+*/
+
+#define TX_64_CNT_GB (0x4U)
+/*! \def TX_64_CNT_GB
+* Macro used to read the tx64octets_gb counter
+*/
+
+#define TX_65TO127_CNT_GB (0x5U)
+/*! \def TX_65TO127_CNT_GB
+* Macro used to read the tx65to127octets_gb counter 
+*/
+
+#define TX_128TO255_CNT_GB (0x6U)
+/*! \def TX_128TO255_CNT_GB
+* Macro used to read the tx128to255octets_gb counter 
+*/
+
+#define TX_256TO511_CNT_GB (0x7U)
+/*! \def TX_256TO511_CNT_GB
+* Macro used to read the tx256to511octets_gb counter 
+*/
+
+#define TX_512TO1023_CNT_GB (0x8U)
+/*! \def TX_512TO1023_CNT_GB
+* Macro used to read the tx512to1023octets_gb counter 
+*/
+
+#define TX_1024TOMAX_CNT_GB (0x9U)
+/*! \def TX_1024TOMAX_CNT_GB
+* Macro used to read the tx1024tomaxoctets_gb counter 
+*/
+
+#define TX_UNICAST_CNT_GB (0xAU)
+/*! \def TX_UNICAST_CNT_GB
+* Macro used to read the txunicastframes_gb counter 
+*/
+
+#define TX_MULTCST_CNT_GB (0xBU)
+/*! \def TX_MULTCST_CNT_GB
+*  Macro used to read the txmulticastcastframes_gb counter 
+*/
+
+#define TX_BRDCST_CNT_GB (0xCU)
+/*! \def TX_BRDCST_CNT_GB
+* Macro used by MMC API to read the txbroadcastframes_gb counter 
+*/
+
+#define TX_UNDERFLOW_ERR_CNT (0xDU)
+/*! \def TX_UNDERFLOW_ERR_CNT
+* Macro used by MMC API to read the txunderflowerror counter 
+*/
+
+#define TX_SINGLE_COL_CNT_G (0xEU)
+/*! \def TX_SINGLE_COL_CNT_G
+* Macro used by MMC API to read the txsinglecol_g counter 
+*/
+
+#define TX_MULTICOL_COL_G (0xFU)
+/*! \def TX_MULTICOL_COL_G
+* Macro used by MMC API to read the txmulticol_g counter 
+*/
+
+#define TX_DEFERRED_CNT (0x10U)
+/*! \def TX_DEFERRED_CNT
+* Macro used by MMC API to read the txdeferred counter 
+*/
+
+#define TX_LATECOL_CNT (0x11U)
+/*! \def TX_LATECOL_CNT
+* Macro used by MMC API to read txlatecol counter
+*/
+
+#define TX_EXCESSCOL_CNT (0x12U)
+/*! \def TX_EXCESSCOL_CNT
+* Macro used by MMC API to read txexcesscol counter 
+*/
+
+#define TX_CARRIER_ERR_CNT (0x13U)
+/*! \def TX_CARRIER_ERR_CNT
+* Macro used by MMC API to read txcarriererror counter 
+*/
+
+#define TX_OCTET_CNT_G (0x14U)
+/*! \def TX_OCTET_CNT_G
+* Macro used by MMC API to read txoctetcount_g counter 
+*/
+
+#define TX_FRAME_CNT_G (0x15U)
+/*! \def TX_FRAME_CNT_G
+* Macro used by MMC API to read txframecount_g counter 
+*/
+
+#define TX_EXCESSDEF_CNT (0x16U)
+/*! \def TX_EXCESSDEF_CNT
+* Macro used by MMC API to read txexcessdef counter
+*/
+
+#define TX_PAUSE_FRAMES_CNT (0x17U)
+/*! \def TX_PAUSE_FRAMES_CNT
+* Macro used by MMC API to read txpauseframes counter 
+*/
+
+#define TX_VLAN_FRAMES_CNT_G (0x18U)
+/*! \def TX_VLAN_FRAMES_CNT_G
+* Macro used by MMC API to read txvlanframes_g counter 
+*/
+
+/* Receive frame statistics*/
+
+ #define RX_FRM_CNT_GB (0x32U)
+/*! \def RX_FRM_CNT_GB
+* Macro used by MMC API to read rxframecount_gb counter 
+*/
+
+#define RX_OCTET_CNT_GB (0x33U)
+/*! \def RX_OCTET_CNT_GB
+* Macro used by MMC API to read rxoctetcount_gb counter 
+*/
+
+#define RX_OCTET_CNT_G (0x34U)
+/*! \def RX_OCTET_CNT_G
+* Macro used by MMC API to read rxoctetcount_g counter 
+*/
+
+#define RX_BRDCSTF_CNT_G (0x35U)
+/*! \def RX_BRDCSTF_CNT_G
+* Macro used by MMC API to read rxbroadcastframes_g counter
+*/
+
+#define RX_MULTCSTF_CNT_G (0x36U)
+/*! \def RX_MULTCSTF_CNT_G
+* Macro used by MMC API to read rxmulticastframes_g counter
+*/
+
+#define RX_CRC_ERR_CNT (0x37U)
+/*! \def RX_CRC_ERR_CNT
+* Macro used by MMC API to read rxcrcerror counter
+*/
+
+#define RX_ALIGNMT_ERR_CNT (0x38U)
+/*! \def RX_ALIGNMT_ERR_CNT
+* Macro used by MMC API to read rxalignmenterror counter
+*/
+
+#define RX_RUNT_ERR_CNT (0x39U)
+/*! \def RX_RUNT_ERR_CNT
+* Macro used by MMC API to read rxrunterror counter
+*/
+
+#define RX_JABBER_ERR_CNT (0x3AU)
+/*! \def RX_JABBER_ERR_CNT
+* Macro used by MMC API to read rxjabbererror counter
+*/
+
+#define RX_UNDERSIZE_CNT_G (0x3BU)
+/*! \def RX_UNDERSIZE_CNT_G
+* Macro used by MMC API to read rxundersize_g counter
+*/
+
+
+#define RX_OVERSIZE_CNT_G (0x3CU)
+/*! \def RX_OVERSIZE_CNT_G
+* Macro used by MMC API to read rxoversize_g counter
+*/
+
+#define RX_64_CNT_GB (0x3DU)
+/*! \def RX_64_CNT_GB
+* Macro used by MMC API to read rx64octets_gb counter
+*/
+
+#define RX_65TO127_CNT_GB (0x3EU)
+/*! \def RX_65TO127_CNT_GB
+* Macro used by MMC API to read rx65to127octets_gb counter
+*/
+
+#define RX_128TO255_CNT_GB (0x3FU)
+/*! \def RX_128TO255_CNT_GB
+* Macro used by MMC API to read rx128to255octets_gb counter
+*/
+
+#define RX_256TO511_CNT_GB (0x40U)
+/*! \def RX_256TO511_CNT_GB
+* Macro used by MMC API to read rx256to511octets_gb counter
+*/
+
+#define RX_512TO1023_CNT_GB (0x41U)
+/*! \def RX_512TO1023_CNT_GB
+* Macro used by MMC API to read rx512to1023octets_gb counter
+*/
+
+#define RX_1024TOMAX_CNT_GB (0x42U)
+/*! \def RX_1024TOMAX_CNT_GB
+* Macro used by MMC API to read rx1024tomaxoctets_g counter
+*/
+
+#define RX_UNICAST_CNT_G (0x43U)
+/*! \def RX_UNICAST_CNT_G
+* Macro used by MMC API to read rxunicastframes_g counter
+*/
+
+#define RX_LEN_ERR_CNT (0x44U)
+/*! \def RX_LEN_ERR_CNT
+* Macro used by MMC API to read rxlengtherror counter
+*/
+
+#define RX_OUTOFRANGE_CNT (0x45U)
+/*! \def RX_OUTOFRANGE_CNT
+* Macro used by MMC API to read rxoutofrangetype counter
+*/
+
+#define RX_PAUSE_CNT (0x46U)
+/*! \def RX_PAUSE_CNT
+* Macro used by MMC API to read rxpauseframes counter
+*/
+
+#define RX_FIFO_OVERFLOW_CNT (0x47U)
+/*! \def RX_FIFO_OVERFLOW_CNT
+* Macro used by MMC API to read rxfifooverflow counter
+*/
+
+#define RX_VLAN_FRAMES_CNT_GB (0x48U)
+/*! \def RX_VLAN_FRAMES_CNT_GB
+* Macro used by MMC API to read rxvlanframes_gb counter
+*/
+
+#define RX_WATCHDOG_ERR_CNT (0x49U)
+/*! \def RX_WATCHDOG_ERR_CNT
+* Macro used by MMC API to read rxwatchdogerror counter 
+*/
+
+/* Macros to read checksum offload counters on the receive side */
+
+#define RX_IPV4_FRMCNT_G (0x5AU)
+/*! \def RX_IPV4_FRMCNT_G
+* Macro used by MMC API to read number of ipv4 good frames received
+*/
+
+#define RX_IPV4_HDR_ERR_FRMCNT (0x5BU)
+/*! \def RX_IPV4_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number ipv4 packets with header errors
+*/
+
+#define RX_IPV4_NOPPAY_FRMCNT (0x5CU)
+/*! \def RX_IPV4_NOPPAY_FRMCNT
+* Macro used by MMC API to read number of ipv4 frames without TCP/UDP/ICMP payloads
+*/
+
+#define RX_IPV4_FRAG_FRMCNT (0x5DU)
+/*! \def RX_IPV4_FRAG_FRMCNT
+* Macro used by MMC API to read number of good IPv4 datagrams with fragmentation
+*/
+
+#define RX_IPV4_UDPCSUMDSL_FRMCNT (0x5EU)
+/*! \def RX_IPV4_UDPCSUMDSL_FRMCNT
+* Macro used by MMC API to read number of UDP frames without checksum
+*/
+
+#define RX_IPV6_FRMCNT_G (0x5FU)
+/*! \def RX_IPV6_FRMCNT_G
+* Macro used by MMC API to read number of ipv6 frames 
+*/
+
+#define RX_IPV6_HDR_ERR_FRMCNT (0x60U)
+/*! \def RX_IPV6_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames with error in header
+*/
+
+#define RX_IPV6_NOPAY_FRMCNT (0x61U)
+/*! \def RX_IPV6_NOPAY_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames without TCP/ICMP/UDP payload
+*/
+
+#define RX_UDP_FRMCNT_G (0x62U)
+/*! \def RX_UDP_FRMCNT_G
+* Macro used by MMC API to read number of UDP frames received
+*/
+
+#define RX_UDP_ERR_FRMCNT (0x63U)
+/*! \def RX_UDP_ERR_FRMCNT
+* Macro used by MMC API to read number of UDP frames received with checksum errors 
+*/
+
+#define RX_TCP_FRMCNT_G (0x64U)
+/*! \def RX_TCP_FRMCNT_G
+* Macro used by MMC API to read number of good TCP frames 
+*/
+
+#define RX_TCP_ERR_FRMCNT (0x65U)
+/*! \def RX_TCP_ERR_FRMCNT
+* Macro used by MMC API to read  of TCP frames received with checksum errors 
+*/
+
+#define RX_ICMP_FRMCNT_G (0x66U)
+/*! \def RX_ICMP_FRMCNT_G
+* Macro used by MMC API to read number of good ICMP frames received
+*/
+
+#define RX_ICMP_ERR_FRMCNT (0x67U)
+/*! \def RX_ICMP_ERR_FRMCNT
+* Macro used by MMC API to read number of ICMP frames received with checksum errors 
+*/
+
+/* Octets */
+#define RX_IPV4_OCTETS_G (0x68U)
+/*! \def RX_IPV4_OCTETS_G
+* Macro used by MMC API to read number of ipv4 octets received
+*/
+
+#define RX_IPV4_HDR_ERR_OCTETS (0x69U)
+/*! \def RX_IPV4_HDR_ERR_OCTETS
+* Macro used by MMC API to read number of octets received in ipv4 packets with 
+*     header errors
+*/
+
+#define RX_IPV4_NOPPAY_OCTETS (0x6AU)
+/*! \def RX_IPV4_NOPPAY_OCTETS
+* Macro used by MMC API to read no. octets received in ipv4 frame with payload 
+*     other than TCP/UDP/ICMP 
+*/
+
+#define RX_IPV4_FRAG_OCTETS (0x6BU)
+/*! \def RX_IPV4_FRAG_OCTETS
+* Macro used by MMC API to read number of octects in the fragmented IP packet 
+*/
+
+#define RX_IPV4_UDPCSUMDSL_OCTETS (0x6CU)
+/*! \def RX_IPV4_UDPCSUMDSL_OCTETS
+* Macro used by MMC API to read number of octets received in a UDP segment that 
+*     had the UDP checksum disabled
+*/
+
+
+#define RX_IPV6_OCTETS_G (0x6DU)
+/*! \def RX_IPV6_OCTETS_G
+*      Number of bytes received in good IPv6 datagrams encapsulating TCP, UDP or 
+*      ICMPv6 data
+*/
+
+#define RX_IPV6_HDR_ERR_OCTETS (0x6EU)
+/*! \def RX_IPV6_HDR_ERR_OCTETS
+* Number of bytes received in IPv6 datagrams with header errors (length, version mismatch).
+*/
+
+#define RX_IPV6_NOPAY_OCTETS (0x6FU)
+/*! \def RX_IPV6_NOPAY_OCTETS
+* Number of bytes received in IPv6 datagrams that did not have a TCP, UDP, or
+*     ICMP payload.
+*/
+
+#define RX_UDP_OCTETS_G (0x70U)
+/*! \def RX_UDP_OCTETS_G
+* Number of bytes received in a good UDP segment
+*/
+
+#define RX_UDP_ERR_OCTETS (0x71U)
+/*! \def RX_UDP_ERR_OCTETS
+* Number of bytes received in a UDP segment that had checksum errors
+*/
+
+#define RX_TCP_OCTETS_G (0x72U)
+/*! \def RX_TCP_OCTETS_G
+* Number of bytes received in a good TCP segment
+*/
+
+#define RX_TCP_ERR_OCTETS (0x73U)
+/*! \def RX_TCP_ERR_OCTETS
+* Number of bytes received in a TCP segment with checksum errors
+*/
+
+#define RX_ICMP_OCTETS_G (0x74U)
+/*! \def RX_ICMP_OCTETS_G
+* Number of bytes received in a good ICMP segment
+*/
+
+#define RX_ICMP_ERR_OCTETS (0x75U)
+/*! \def RX_ICMP_ERR_OCTETS
+* Number of bytes received in an ICMP segment with checksum errors
+*/
+
+/*----------------------------------------------------------------------------
+** STATISTICS Counters structure 
+**---------------------------------------------------------------------------*/
+
+typedef struct rmonCtrl
+/* MAC management counters configuration */
+{                            /* True => Enable False => Disable */   
+    bool freezeCntrs;        /* Disable freezing of counters */
+    bool resetOnRdEn;        /* Enable/Disable reset on Read */
+    bool rollOverDisable;    /* Enable/Disable rollover */
+    bool resetCounters;      /* Reset counters */
+}rmonCtrl_t,*prmonCtrl_t;
+
+typedef struct rmonRegsRd
+/* MAC management structure to read MAC counters */
+{
+    __u32                        mmcRegVal; /* Register Value read */
+    __u32                        regToRd;   /* Register to be read */
+}rmonRegsRd_t, *prmonRegsRd_t;
+
+/*----------------------------------------------------------------------------
+** WoL specific structures
+**---------------------------------------------------------------------------*/
+
+typedef struct wakeupinfo
+{
+    __u32  filterMask[4];
+    __u32  filterCommand;
+    __u32  filterOffset;
+    __u32  filterCrcVal6;
+    __u32  filterCrcVal7;
+}wakeupinfo_t, *pwakeupinfo_t;
+
+typedef struct gmacWoLinfo
+{    
+    bool          globalUnicastEn;
+    bool          magicPktEn;    
+    bool          wkupFrameEn;
+    wakeupinfo_t  wkupinfo;
+    
+}gmacWoLinfo_t,*pgmacWoLinfo_t;
+
+/*----------------------------------------------------------------------------
+** Loopback application related 
+**---------------------------------------------------------------------------*/
+typedef struct gmacRegs
+{
+    __u32 regOffset;
+    __u32 regValue;
+    bool  rwFlag;
+    bool  rwPhyRegs;
+
+}gmacRegs_t, *pgmacRegs_t;
+
+typedef struct gmacDrvConfig
+{
+	__u32 speed;
+	__u32 enableFullduplex;
+	__u32 enableAutoNeg;
+	__u32 enableMacLoopback;
+	__u32 enablePhyLoopback;
+
+}gmacDrvConfig_t, *pgmacDrvConfig_t;
+
+
+#endif /* __GMAC_IOCTL_H__ */
diff -Naurp linux-2.6.34.orig/kernel/semaphore.c linux-2.6.34/kernel/semaphore.c
--- linux-2.6.34.orig/kernel/semaphore.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/kernel/semaphore.c	2010-09-07 22:16:41.000000000 -0500
@@ -37,6 +37,7 @@ static noinline void __down(struct semap
 static noinline int __down_interruptible(struct semaphore *sem);
 static noinline int __down_killable(struct semaphore *sem);
 static noinline int __down_timeout(struct semaphore *sem, long jiffies);
+static noinline int __down_timeout_interruptible(struct semaphore *sem, long jiffies);
 static noinline void __up(struct semaphore *sem);
 
 /**
@@ -169,6 +170,32 @@ int down_timeout(struct semaphore *sem, 
 EXPORT_SYMBOL(down_timeout);
 
 /**
+ * down_timeout_interruptible - acquire the semaphore within a specified time
+ * @sem: the semaphore to be acquired
+ * @jiffies: how long to wait before failing
+ *
+ * Attempts to acquire the semaphore.  If no more tasks are allowed to
+ * acquire the semaphore, calling this function will put the task to sleep.
+ * If the semaphore is not released within the specified number of jiffies,
+ * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
+ */
+int down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	unsigned long flags;
+	int result = 0;
+
+	spin_lock_irqsave(&sem->lock, flags);
+	if (likely(sem->count > 0))
+		sem->count--;
+	else
+		result = __down_timeout_interruptible(sem, jiffies);
+	spin_unlock_irqrestore(&sem->lock, flags);
+
+	return result;
+}
+EXPORT_SYMBOL(down_timeout_interruptible);
+
+/**
  * up - release the semaphore
  * @sem: the semaphore to release
  *
@@ -253,6 +280,11 @@ static noinline int __sched __down_timeo
 	return __down_common(sem, TASK_UNINTERRUPTIBLE, jiffies);
 }
 
+static noinline int __sched __down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	return __down_common(sem, TASK_INTERRUPTIBLE, jiffies);
+}
+
 static noinline void __sched __up(struct semaphore *sem)
 {
 	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
diff -Naurp linux-2.6.34.orig/tools/perf/build-perf.sh linux-2.6.34/tools/perf/build-perf.sh
--- linux-2.6.34.orig/tools/perf/build-perf.sh	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/tools/perf/build-perf.sh	2010-09-07 22:16:41.000000000 -0500
@@ -0,0 +1,2 @@
+make CROSS_COMPILE=arm-linux- CFLAGS="--sysroot=$_TMSYSROOT -mcpu=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=softfp" LDFLAGS="--sysroot=$_TMSYSROOT" NO_ICONV=1
+
diff -Naurp linux-2.6.34/drivers/mmc/host/sdhci.c linux-2.6.34.sdio/drivers/mmc/host/sdhci.c
--- linux-2.6.34/drivers/mmc/host/sdhci.c	2010-09-08 13:34:15.000000000 -0500
+++ linux-2.6.34.sdio/drivers/mmc/host/sdhci.c	2010-09-08 13:36:52.000000000 -0500
@@ -1831,11 +1831,16 @@ int sdhci_add_host(struct sdhci_host *ho
 		mmc->max_hw_segs = 128;
 	mmc->max_phys_segs = 128;
 
+#if defined(CONFIG_MMC_SDHCI_NX_SDIOMC) || defined(CONFIG_MMC_SDHCI_NX_SDIOMC_MODULE)
+	/* The IP has 16 bits for size so max can be 0xFFFF */
+ 	mmc->max_req_size = 65535;
+#else
 	/*
 	 * Maximum number of sectors in one transfer. Limited by DMA boundary
 	 * size (512KiB).
 	 */
 	mmc->max_req_size = 524288;
+#endif
 
 	/*
 	 * Maximum segment size. Could be one segment with the maximum number
diff -Naurp linux-2.6.34/drivers/mmc/host/sdhci_nx_sdiomc.c linux-2.6.34.sdio/drivers/mmc/host/sdhci_nx_sdiomc.c
--- linux-2.6.34/drivers/mmc/host/sdhci_nx_sdiomc.c	2010-09-08 13:34:15.000000000 -0500
+++ linux-2.6.34.sdio/drivers/mmc/host/sdhci_nx_sdiomc.c	2010-09-08 12:57:33.000000000 -0500
@@ -293,6 +293,10 @@ static int __init nx_sdiomc_probe(struct
   chip->ioaddr = ioaddr;
   chip->quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 
+#ifdef CONFIG_MMC_SDHCI_NX_SDIOMC_SD1_BIT_ALWAYS
+  chip->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;
+#endif
+
   platform_set_drvdata(pdev, chip);
 
   for (i = 0;i < num_slots;i++) {
diff -Naurp linux-2.6.34/arch/arm/include/asm/io.h linux-2.6.34.new/arch/arm/include/asm/io.h
--- linux-2.6.34/arch/arm/include/asm/io.h	2010-09-10 01:07:45.000000000 -0500
+++ linux-2.6.34.new/arch/arm/include/asm/io.h	2010-09-09 16:15:08.000000000 -0500
@@ -200,9 +200,9 @@ extern void _memset_io(volatile void __i
 #define __iowmb()		do { } while (0)
 #endif
 
-#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
-#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
-#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+#define readb(c)		({ u8  __r = readb_relaxed(c); __iormb(); __r; })
+#define readw(c)		({ u16 __r = readw_relaxed(c); __iormb(); __r; })
+#define readl(c)		({ u32 __r = readl_relaxed(c); __iormb(); __r; })
 
 #define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })
 #define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })
diff -Naurp linux-2.6.34/include/linux/tty.h linux-2.6.34.new/include/linux/tty.h
--- linux-2.6.34/include/linux/tty.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34.new/include/linux/tty.h	2010-09-08 23:11:22.000000000 -0500
@@ -446,6 +446,7 @@ extern void tty_wakeup(struct tty_struct
 extern void tty_ldisc_flush(struct tty_struct *tty);
 
 extern long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+extern long tty_ioctl_simple(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
 extern int tty_mode_ioctl(struct tty_struct *tty, struct file *file,
 			unsigned int cmd, unsigned long arg);
 extern int tty_perform_flush(struct tty_struct *tty, unsigned long arg);
@@ -460,6 +461,7 @@ extern void initialize_tty_struct(struct
 extern struct tty_struct *tty_init_dev(struct tty_driver *driver, int idx,
 								int first_ok);
 extern int tty_release(struct inode *inode, struct file *filp);
+extern void tty_release_tty(struct tty_struct *tty);
 extern int tty_init_termios(struct tty_struct *tty);
 
 extern struct tty_struct *tty_pair_get_tty(struct tty_struct *tty);

diff -uNr git/configure.ac unlib/configure.ac
--- git/configure.ac	2018-03-30 11:39:25.387652148 +0800
+++ unlib/configure.ac	2018-04-11 16:55:21.911318400 +0800
@@ -753,7 +753,13 @@
      target_videoplatform=target_mali
      use_cpu=cortex-a15
      ;;
-
+  clap-cortexa15)
+     USE_MALI=1
+     USE_HIPLAYER=1
+     target_platform=target_clap
+     target_videoplatform=target_clap
+     use_cpu=cortex-a15
+     ;;
 esac
 
 if test "$target_platform" = "target_raspberry_pi" ; then
@@ -783,6 +789,13 @@
      CXXFLAGS="$CXXFLAGS"
 fi
 
+if test "$target_platform" = "target_clap" ; then
+     use_openmax=no
+     CORE_SYSTEM_NAME=linux
+     CFLAGS="$CFLAGS"
+     CXXFLAGS="$CXXFLAGS"
+fi
+
 if test "$host_vendor" = "apple"; then
   use_avahi=no
   use_alsa=no
@@ -1079,6 +1092,11 @@
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES mali support is assumed.)
       LIBS="$LIBS -lEGL -lGLESv2 -lmali"
+  elif test "${target_platform}" = "target_clap" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES mali support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -ljpeg -lhi_common -lhi_msp"
   else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
@@ -1184,7 +1202,7 @@
   )])
 AC_LANG_POP([C++])
 
-if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android" || test "${target_platform}" = "target_v3d" || test "${target_platform}" = "target_mali"; then
+if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android" || test "${target_platform}" = "target_v3d" || test "${target_platform}" = "target_mali"|| test "${target_platform}" = "target_clap"; then
   PKG_CHECK_MODULES([UUID], [uuid],, AC_MSG_ERROR(libuuid not found))
 fi
 
@@ -2480,6 +2498,7 @@
 AC_SUBST(USE_NEXTV)
 AC_SUBST(USE_GB)
 AC_SUBST(USE_MALI)
+AC_SUBST(USE_HIPLAYER)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff -uNr git/m4/xbmc_arch.m4 unlib/m4/xbmc_arch.m4
--- git/m4/xbmc_arch.m4	2018-03-30 11:39:25.451651892 +0800
+++ unlib/m4/xbmc_arch.m4	2018-04-11 10:18:58.873873030 +0800
@@ -115,4 +115,8 @@
 if test "$target_videoplatform" = "target_mali" ; then
   AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI")
 fi
+
+if test "$target_videoplatform" = "target_clap" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI -DUSE_HIPLAYER")
+fi
 ])
diff -uNr git/Makefile.in unlib/Makefile.in
--- git/Makefile.in	2018-03-30 11:39:25.387652148 +0800
+++ unlib/Makefile.in	2018-04-11 17:12:45.594138026 +0800
@@ -421,6 +421,13 @@
 endif
 endif # USE_ANDROID
 
+ifeq (@USE_HIPLAYER@,1)
+HI_EXTLIBS = xbmc/cores/hiplayer/hiplayer.a 
+HI_EXTLIBS+= xbmc/linux/hisi/hiadp.a 
+else
+HI_EXTLIBS=${null}
+endif
+
 ifeq (@USE_VUPLUS@,1)
 ifeq (@USE_VUPLUS_ARM_LIB@,1)
 LIBS+= -lKodiGLESPL -ldvb_base -lnxpl -ldvb_client
@@ -466,7 +473,7 @@
 ifeq ($(findstring osx,@ARCH@), osx)
 	$(SILENT_LD) $(CXX) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,-all_load,-ObjC $(MAINOBJS) $(DYNOBJSXBMC) $(NWAOBJSXBMC) $(OBJSXBMC) $(LIBS) -rdynamic
 else
-	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic $(VUPLUS_EXTLIBS) $(GB_EXTLIBS)
+	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) $(HI_EXTLIBS) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic $(VUPLUS_EXTLIBS) $(GB_EXTLIBS)
 endif
 
 @APP_NAME_LC@-xrandr: xbmc-xrandr.c
diff -uNr git/xbmc/Application.cpp unlib/xbmc/Application.cpp
--- git/xbmc/Application.cpp	2018-03-30 11:39:25.331652373 +0800
+++ unlib/xbmc/Application.cpp	2018-07-18 16:32:18.238432260 +0800
@@ -4788,6 +4788,16 @@
   // if player has volume control, set it.
   m_pPlayer->SetVolume(m_volumeLevel);
   m_pPlayer->SetMute(m_muted);
+  
+  int vol = m_muted?0:(int)(m_volumeLevel*100);
+  std::ostringstream sstreamer;
+  sstreamer << "echo ";
+  sstreamer << vol;
+  sstreamer << " > /proc/stb/avs/0/volume";
+  std::string cmd(sstreamer.str());
+  system(cmd.c_str());
+  
+  CLog::Log(LOGNOTICE, "Vol %d", vol);
 }
 
 int CApplication::GetSubtitleDelay() const
diff -uNr git/xbmc/cores/AudioEngine/AESinkFactory.cpp unlib/xbmc/cores/AudioEngine/AESinkFactory.cpp
--- git/xbmc/cores/AudioEngine/AESinkFactory.cpp	2018-03-30 11:39:25.339652341 +0800
+++ unlib/xbmc/cores/AudioEngine/AESinkFactory.cpp	2018-04-11 10:18:57.689908701 +0800
@@ -215,6 +215,14 @@
   if(!info.m_deviceInfoList.empty())
     list.push_back(info);
   #endif
+#elif defined(USE_HIPLAYER)
+  #if defined(HAS_ALSA)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "ALSA";
+  CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+    list.push_back(info);
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
 
   info.m_deviceInfoList.clear();
diff -uNr git/xbmc/cores/hiplayer/HiAdec.h unlib/xbmc/cores/hiplayer/HiAdec.h
--- git/xbmc/cores/hiplayer/HiAdec.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiAdec.h	2018-07-13 19:32:15.379226300 +0800
@@ -0,0 +1,56 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Thread.h"
+#include "HiDecoder.h"
+
+class CHiAudio : public CThread
+{
+public:
+    CHiAudio();
+    virtual ~CHiAudio();
+
+    bool open(CDVDStreamInfo hints);
+    bool close();
+    
+    bool PlayStarted();
+    bool EOS();
+		bool Ready();
+    bool Full();
+
+    double Delay();
+    double CacheTime();
+    double CacheTotal();
+    double FirstPts();
+    double CurrentPts();
+
+    void SubmitEos();
+    void reset();
+    void reSync(double pts);
+    
+    bool Push(uint8_t *pData, size_t iSize, unsigned int pts_ms);
+    bool PushEx(uint8_t *pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+private:
+    HisiAvDecoder * hwDec;
+		bool m_bStop;
+};
diff -uNr git/xbmc/cores/hiplayer/HiCodecAudio.h unlib/xbmc/cores/hiplayer/HiCodecAudio.h
--- git/xbmc/cores/hiplayer/HiCodecAudio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiCodecAudio.h	2018-03-16 16:48:59.937669100 +0800
@@ -0,0 +1,86 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/AudioEngine/Utils/AEAudioFormat.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+#include "DVDStreamInfo.h"
+#include "linux/PlatformDefs.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+#include "cores/AudioEngine/AEResampleFactory.h"
+#include "cores/AudioEngine/Utils/AEStreamInfo.h"
+
+class CProcessInfo;
+
+class CDVDAudioCodecHisi
+{
+	public:
+		CDVDAudioCodecHisi(CProcessInfo &processInfo);
+		virtual ~CDVDAudioCodecHisi();
+		bool Open(CDVDStreamInfo &hints);
+		void Dispose();
+		int Decode(BYTE* pData, int iSize, double dts, double pts);
+		int GetData(BYTE** dst, double &dts, double &pts);
+		void Reset();
+		int GetChannels();
+		void BuildChannelMap();
+		CAEChannelInfo GetChannelMap();
+		int GetSampleRate();
+		int GetBitsPerSample();
+		static const char* GetName() { return "FFmpeg"; }
+		int GetBitRate();
+		unsigned int GetFrameSize() { return m_frameSize; }
+	
+	protected:
+		CProcessInfo &m_processInfo;
+		AVCodecContext* m_pCodecContext;
+		SwrContext* 		m_pConvert;
+		enum AVSampleFormat m_iSampleFormat;
+		enum AVSampleFormat m_desiredSampleFormat;
+	
+		AVFrame* m_pFrame1;
+	
+		BYTE *m_pBufferOutput;
+		int 	m_iBufferOutputUsed;
+		int 	m_iBufferOutputAlloced;
+	
+		int 		m_channels;
+		CAEChannelInfo m_channelLayout;
+		int			m_desiredchannels;
+		CAEChannelInfo m_desiredchannelLayout;
+		
+		bool m_bFirstFrame;
+		bool m_bGotFrame;
+		bool m_bNoConcatenate;
+		unsigned int	m_frameSize;
+		double m_dts, m_pts;
+
+		unsigned char m_buffer[10240];
+};
+
diff -uNr git/xbmc/cores/hiplayer/HiCodecVideo.h unlib/xbmc/cores/hiplayer/HiCodecVideo.h
--- git/xbmc/cores/hiplayer/HiCodecVideo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiCodecVideo.h	2018-07-18 16:33:13.528711713 +0800
@@ -0,0 +1,93 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "threads/CriticalSection.h"
+
+#include <set>
+#include <atomic>
+
+class CHisiVdec;
+struct frame_queue;
+struct mpeg2_sequence;
+class CBitstreamParser;
+class CBitstreamConverter;
+
+class CDVDVideoCodecHisi : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecHisi(CProcessInfo &processInfo);
+  virtual ~CDVDVideoCodecHisi();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetSpeed(int iSpeed);
+  virtual void SetDropState(bool bDrop);
+  virtual int  GetDataSize(void);
+  virtual double GetTimeSize(void);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+  int  Decode(uint8_t *pData, int iSize, double dts, double pts, std::atomic_bool& abort);
+
+	bool PlayStarted();
+	
+	bool BufferReady();
+	bool BufferFull();
+	bool IsEOS();
+	void SubmitEOS();
+	void ReSync(double pts);
+	double FirstPts();
+	double GetCurrentPts();
+	
+protected:
+  void            Dispose(void);
+  void            FrameQueuePop(void);
+  void            FrameQueuePush(double dts, double pts);
+  void            FrameRateTracking(uint8_t *pData, int iSize, double dts, double pts);
+
+  CHisiVdec      *m_Codec;
+  const char     *m_pFormatName;
+  DVDVideoPicture m_videobuffer;
+  CDVDStreamInfo  m_hints;
+  double          m_last_pts;
+  frame_queue    *m_frame_queue;
+  int32_t         m_queue_depth;
+  pthread_mutex_t m_queue_mutex;
+  double          m_framerate;
+  int             m_video_rate;
+  float           m_aspect_ratio;
+  mpeg2_sequence *m_mpeg2_sequence;
+  double          m_mpeg2_sequence_pts;
+
+  CBitstreamParser *m_bitparser;
+  CBitstreamConverter *m_bitstream;
+	
+  bool            m_opened;	
+  bool            m_drop;
+	
+private:
+  CCriticalSection    m_secure;
+};
diff -uNr git/xbmc/cores/hiplayer/HiDecoder.h unlib/xbmc/cores/hiplayer/HiDecoder.h
--- git/xbmc/cores/hiplayer/HiDecoder.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiDecoder.h	2018-07-18 17:03:24.048606182 +0800
@@ -0,0 +1,160 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include <deque>
+
+extern "C" {
+#include <hisi/hi_type.h>
+#include <hisi/hi_unf_video.h>
+#include <hisi/hi_unf_audio.h>
+#include <hisi/hi_unf_common.h>
+#include <hisi/hi_unf_vo.h>
+#include <hisi/hi_unf_disp.h>
+#include <hisi/hi_unf_advca.h>
+#include <hisi/hi_unf_otp.h> 
+#include <hisi/hi_adp_mpi.h> 
+#include <hisi/hi_audio_codec.h> 
+#include "hisi/HA.AUDIO.PCM.decode.h"
+
+}  // extern "C"
+
+#define PTS_FREQ        90000
+#define UNIT_FREQ       96000
+#define AV_SYNC_THRESH  PTS_FREQ*30
+#define PTS_US_TO_MS(PTS_US) ((PTS_US) / 1000.0f)
+#define PTS_MS_TO_US(PTS_MS) ((PTS_MS) * 1000.0f)
+#define PTS_90KHZ_TO_MS(PTS_90MS) ((PTS_90MS) / 90.0f)
+#define PTS_MS_TO_90KHZ(PTS_MS) ((PTS_MS) * 90.0f)
+
+enum
+{
+	VIDEO_MODE_NORMAL,
+	VIDEO_MODE_PAUSE,
+	VIDEO_MODE_FORWARD,
+	VIDEO_MODE_BACKWARD
+};
+
+class HisiAvDecoder
+{
+public:
+  static HisiAvDecoder* GetInstance();
+  
+  HisiAvDecoder();
+  virtual ~HisiAvDecoder();
+
+  bool		IsEOS();
+
+  bool		VideoOpen(CDVDStreamInfo &hints);
+  bool		VideoClose();
+  void		VideoReset();
+  void		VideoReSync(unsigned int pts);
+	
+  bool		VideoWrite(uint8_t *pData, size_t iSize, unsigned int pts_ms);
+  bool		VideoWriteEx(uint8_t *pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+	
+  double	VideoFirstPts();
+  double	VideoCurrentPts();
+  bool		VideoFramePts(int &pts);
+	
+  bool		VideoBufferReady();
+  bool		VideoBufferFull();
+  bool		VideoPlayStarted();
+  void		VideoSetSpeed(int speed);
+  void		VideoSubmitEOS();
+  void		VideoSetRect(int x, int y, int width, int height);	
+	
+  bool		AudioOpen(CDVDStreamInfo &hints);
+  bool		AudioClose(); 
+  void		AudioReset();
+  void		AudioReSync(unsigned int pts);
+
+	
+  bool		AudioBufferReady();
+  bool		AudioBufferFull();
+  bool		AudioWrite(uint8_t *pData, size_t iSize, unsigned int pts_ms);
+  bool		AudioWriteEx(uint8_t *pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+  bool		AudioPlayStarted();
+  double	AudioCurrentPts();
+  double	AudioFirstPts();
+  double	AudioCacheTotal();
+  double	AudioCachetime();
+  double	AudioDelay();
+	
+  void		AudioSubmitEOS();
+
+  HI_S32	EventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara);
+	
+protected:
+  bool		Init();
+  bool		Deinit();
+  void		SubmitEOS();
+  
+  HI_UNF_VCODEC_TYPE_E codec2vdec(int enc);
+  HA_CODEC_ID_E codec2adec(int enc);
+
+private:
+  bool						m_opened;
+  bool						m_video_opend;
+  bool						m_audio_opend;
+  bool						m_dump;
+  
+  unsigned int      		m_hAvplay;
+  unsigned int      		m_hWin;
+  unsigned int 				m_hTrack;
+
+  //video play
+  int						m_mode;
+  int						m_speed;
+  
+  HI_UNF_DISP_E				m_disp;
+  bool						m_freerun;
+
+  CCriticalSection  m_section;
+  CCriticalSection	m_EventMutex;
+    
+  std::deque<int>  m_aptsQueue;
+  std::deque<int>  m_vptsQueue;
+
+
+	bool			m_audio_full;
+	bool			m_video_full;
+	bool			m_video_eos;
+	bool			m_audio_eos;
+	bool			m_eos;
+
+	int				m_audio_last_package_pts;
+	int 			m_audio_bytes_pes_sec;
+	double			m_audio_cache_total;
+	double			m_audio_cache_time;
+	double			m_audio_delay;
+	
+	double			m_video_1st_pts;
+	double			m_audio_1st_pts;
+
+	bool			m_audio_play_started;
+	bool   			m_video_play_started;
+	
+	bool			m_audio_ready;
+	bool			m_video_ready;
+};
diff -uNr git/xbmc/cores/hiplayer/HiPlayerAudio.h unlib/xbmc/cores/hiplayer/HiPlayerAudio.h
--- git/xbmc/cores/hiplayer/HiPlayerAudio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiPlayerAudio.h	2018-07-18 16:32:54.251523291 +0800
@@ -0,0 +1,109 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <deque>
+#include <sys/types.h>
+
+#include "DVDStreamInfo.h"
+#include "threads/Thread.h"
+#include "IVideoPlayer.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDMessageQueue.h"
+#include "utils/BitstreamStats.h"
+
+#include "HiCodecAudio.h"
+#include "HiAdec.h"
+
+class CHiPlayerAudio : public CThread, public IDVDStreamPlayerAudio
+{
+protected:
+  CDVDMessageQueue      m_messageQueue;
+  CDVDMessageQueue      &m_messageParent;
+
+  CDVDStreamInfo            m_hints_current;
+  CDVDStreamInfo            m_hints;
+  CDVDClock                 *m_av_clock;
+  CHiAudio                  *m_hisiAudio;
+  std::string               m_codec_name;
+  bool                      m_passthrough;
+  AEAudioFormat             m_format;
+  CDVDAudioCodecHisi        *m_pAudioCodec;
+  int                       m_speed;
+  bool                      m_silence;
+  double                    m_audioClock;
+  double                    m_start_pts ;
+
+  bool                      m_stalled;
+  IDVDStreamPlayer::ESyncState m_syncState;
+
+  BitstreamStats            m_audioStats;
+
+  bool                      m_buffer_empty;
+  bool                      m_flush;
+  bool                      m_DecoderOpen;
+
+  bool                      m_bad_state;
+  bool                      m_eos;
+  std::atomic_bool          m_bAbortOutput;
+	
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+  void OpenStream(CDVDStreamInfo &hints, CDVDAudioCodecHisi *codec);
+private:
+public:
+  CHiPlayerAudio(CDVDClock *av_clock, CDVDMessageQueue& parent, CProcessInfo &processInfo);
+  ~CHiPlayerAudio();
+  bool OpenStream(CDVDStreamInfo &hints);
+  void SendMessage(CDVDMsg* pMsg, int priority = 0) { m_messageQueue.Put(pMsg, priority); }
+  void FlushMessages()                              { m_messageQueue.Flush(); }
+  bool AcceptsData() const                          { return !m_messageQueue.IsFull(); }
+  bool HasData() const                              ;
+  bool IsInited() const                             { return m_messageQueue.IsInited(); }
+  int  GetLevel() const                             { return m_messageQueue.GetLevel(); }
+  bool IsStalled() const                            { return m_stalled;  }
+  bool IsEOS();
+  void WaitForBuffers();
+  void CloseStream(bool bWaitForBuffers);
+  bool CodecChange();
+  bool Decode(DemuxPacket *pkt, bool bDropPacket, bool bTrickPlay);
+  void Flush(bool sync);
+  AEAudioFormat GetDataFormat(CDVDStreamInfo hints);
+  bool IsPassthrough() const;
+  bool OpenDecoder();
+  void CloseDecoder();
+  double GetDelay();
+  double GetCacheTime();
+  double GetCacheTotal();
+  double GetCurrentPts() { return m_audioClock; };
+  void SubmitEOS();
+
+  void SetDynamicRangeCompression(long drc)              {   }
+  float GetDynamicRangeAmplification() const             { return 0.0f; }
+  void SetSpeed(int iSpeed);
+  int  GetAudioBitrate();
+  int GetAudioChannels();
+  std::string GetPlayerInfo();
+
+  bool BadState() { return m_bad_state; }
+};
+
diff -uNr git/xbmc/cores/hiplayer/HiPlayerVideo.h unlib/xbmc/cores/hiplayer/HiPlayerVideo.h
--- git/xbmc/cores/hiplayer/HiPlayerVideo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiPlayerVideo.h	2018-07-18 16:32:46.033695737 +0800
@@ -0,0 +1,130 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+#include "IVideoPlayer.h"
+#include "DVDMessageQueue.h"
+#include "DVDStreamInfo.h"
+#include "DVDCodecs/Video/DVDVideoCodec.h"
+#include "DVDClock.h"
+#include "DVDOverlayContainer.h"
+#include "DVDTSCorrection.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "utils/BitstreamStats.h"
+#include "utils/BitstreamConverter.h"
+#include "guilib/Geometry.h"
+#include "HiCodecVideo.h"
+#include <atomic>
+
+class CHiPlayerVideo : public CThread, public IDVDStreamPlayerVideo
+{
+public:
+  CHiPlayerVideo(CDVDClock* pClock
+                 ,CDVDOverlayContainer* pOverlayContainer
+                 ,CDVDMessageQueue& parent
+                 ,CRenderManager& renderManager,
+                 CProcessInfo &processInfo);
+  
+  virtual ~CHiPlayerVideo();
+
+  bool OpenStream(CDVDStreamInfo &hint);
+  void CloseStream(bool bWaitForBuffers);
+
+  void Flush(bool sync);
+  bool AcceptsData() const { return !m_messageQueue.IsFull(); }
+  bool HasData() const ;
+  int  GetLevel() const { return m_messageQueue.GetLevel(); }
+  bool IsInited() const { return m_messageQueue.IsInited(); }
+  void SendMessage(CDVDMsg* pMsg, int priority = 0) { m_messageQueue.Put(pMsg, priority); }
+  void FlushMessages() { m_messageQueue.Flush(); }
+
+  void EnableSubtitle(bool bEnable) { m_bRenderSubs = bEnable; }
+  bool IsSubtitleEnabled() { return m_bRenderSubs; }
+  void EnableFullscreen(bool bEnable) { m_bAllowFullscreen = bEnable; }
+  double GetSubtitleDelay() { return m_iSubtitleDelay; }
+  void SetSubtitleDelay(double delay) { m_iSubtitleDelay = delay; }
+  bool IsStalled() const override { return m_stalled; }
+  bool IsRewindStalled() const override { return m_rewindStalled; }
+  double GetCurrentPts();
+  double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
+  int GetDecoderFreeSpace() { return 0; }
+  std::string GetPlayerInfo();
+  int GetVideoBitrate();
+  std::string GetStereoMode();
+  void SetSpeed(int iSpeed);
+	void	SubmitEOS();
+
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+
+	
+	void OpenStream(CDVDStreamInfo &hint, CDVDVideoCodecHisi* codec);
+  void ProcessOverlays(double pts);
+	void ResolutionUpdateCallBack();
+	void Output(double pts, bool bDropPacket);
+	void SetVideoRect(const CRect &InSrcRect, const CRect &InDestRect);
+
+  CDVDStreamInfo m_hints;
+
+  int m_speed;
+
+  bool m_bRenderSubs;
+  bool m_bAllowFullscreen;
+  bool m_paused;
+  bool m_bFpsInvalid;        // needed to ignore fps (e.g. dvd stills)
+
+  float m_fForcedAspectRatio;
+	
+  double m_fFrameRate;       //framerate of the video currently playing
+  double m_iSubtitleDelay;
+
+  bool m_stalled;
+  std::atomic_bool m_rewindStalled;
+  std::atomic_bool m_bAbortOutput;
+	
+  BitstreamStats m_videoStats;
+	
+  CDVDMessageQueue  m_messageQueue;
+  CDVDMessageQueue& m_messageParent;
+  
+  CRenderManager& m_renderManager;
+
+  CDVDOverlayContainer  *m_pOverlayContainer;
+	
+	CBitstreamConverter *m_bitstream;
+
+  IDVDStreamPlayer::ESyncState m_syncState;
+
+	CDVDVideoCodecHisi * m_pVideoCodec;
+	
+  CRect                     m_src_rect;
+  CRect                     m_dst_rect;
+  RENDER_STEREO_MODE        m_video_stereo_mode;
+  RENDER_STEREO_MODE        m_display_stereo_mode;
+  bool                      m_StereoInvert;
+  double                    m_start_pts;
+
+	DVDVideoPicture m_picture;
+};
+
diff -uNr git/xbmc/cores/hiplayer/HiVdec.h unlib/xbmc/cores/hiplayer/HiVdec.h
--- git/xbmc/cores/hiplayer/HiVdec.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiVdec.h	2018-07-17 18:50:37.140701074 +0800
@@ -0,0 +1,114 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "cores/IPlayer.h"
+#include "guilib/Geometry.h"
+#include "rendering/RenderSystem.h"
+#include "threads/Thread.h"
+#include <deque>
+
+#include "HiDecoder.h"
+
+class PosixFile;
+typedef std::shared_ptr<PosixFile> PosixFilePtr;
+
+
+class CHisiVdec : public CThread
+{
+public:
+  CHisiVdec();
+  virtual ~CHisiVdec();
+
+  bool          OpenDecoder(CDVDStreamInfo &hints);
+  void          CloseDecoder();
+  void          Reset();
+	void 					ReSync(double pts);
+
+  int           Decode(uint8_t *pData, size_t size, double dts, double pts, std::atomic_bool& abort);
+
+  bool          GetPicture(DVDVideoPicture* pDvdVideoPicture);
+	bool 					GetFramePts(int& pts);
+  void          SetSpeed(int speed);
+  int           GetDataSize();
+  double        GetTimeSize();
+  void          SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
+  void          SetFreeRun(const bool freerun);
+
+	void					SubmitEos();
+	bool					EOS();
+	bool					PlayStarted();
+	
+	bool 					BufferReady();
+	bool					BufferFull();
+	double				FirstPts();
+	double 				GetCurrentPts();
+	
+protected:
+  virtual void  Process();
+
+private:
+#if 0
+  void          ShowMainVideo(const bool show);
+  void          SetVideoZoom(const float zoom);
+  void          SetVideoContrast(const int contrast);
+  void          SetVideoBrightness(const int brightness);
+  void          SetVideoSaturation(const int saturation);
+  bool          SetVideo3dMode(const int mode3d);
+  std::string   GetStereoMode();
+#endif	
+  void					SetHeader();
+
+private:
+  bool             m_opened;
+  CDVDStreamInfo   m_hints;
+  volatile int     m_speed;
+  volatile int     m_mode;
+	
+  CEvent           m_ready_event;
+	
+  CRect            m_dst_rect;
+  CRect            m_display_rect;
+  int              m_view_mode;
+	
+  RENDER_STEREO_MODE m_stereo_mode;
+  RENDER_STEREO_VIEW m_stereo_view;
+	
+  float            m_zoom;
+  int              m_contrast;
+  int              m_brightness;
+
+  std::deque<int>  m_ptsQueue;
+  CCriticalSection m_ptsQueueMutex;
+
+  unsigned int		m_video_rate;
+  unsigned char* 	m_extradata;
+  unsigned int		m_extrasize;
+	bool						m_extraneed;
+	
+  unsigned char*	m_header;
+  unsigned int		m_headersize;
+  
+  CRect						m_VideoRect;
+    
+  HisiAvDecoder * hwDec;
+};
diff -uNr git/xbmc/cores/VideoPlayer/VideoPlayer.cpp unlib/xbmc/cores/VideoPlayer/VideoPlayer.cpp
--- git/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2018-03-30 11:39:25.347652309 +0800
+++ unlib/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2018-07-18 16:53:39.420012330 +0800
@@ -81,6 +81,12 @@
 #include "cores/omxplayer/OMXPlayerVideo.h"
 #include "cores/omxplayer/OMXHelper.h"
 #endif
+
+#ifdef USE_HIPLAYER
+#include "cores/hiplayer/HiPlayerVideo.h"
+#include "cores/hiplayer/HiPlayerAudio.h"
+#endif
+
 #include "VideoPlayerAudio.h"
 #include "cores/DataCacheCore.h"
 #include "windowing/WindowingFactory.h"
@@ -590,8 +596,13 @@
   }
   else
   {
+#ifdef USE_HIPLAYER
+	m_VideoPlayerVideo = new CHiPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
+	m_VideoPlayerAudio = new CHiPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+#else
     m_VideoPlayerVideo = new CVideoPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
     m_VideoPlayerAudio = new CVideoPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+#endif
   }
   m_VideoPlayerSubtitle = new CVideoPlayerSubtitle(&m_overlayContainer, *m_processInfo);
   m_VideoPlayerTeletext = new CDVDTeletextData(*m_processInfo);
@@ -2184,7 +2195,7 @@
 
     if(current.dts < current.startpts)
     {
-      CLog::Log(LOGDEBUG, "%s - dropping packet type:%d dts:%f to get to start point at %f", __FUNCTION__, current.player,  current.dts, current.startpts);
+      //CLog::Log(LOGDEBUG, "%s - dropping packet type:%d dts:%f to get to start point at %f", __FUNCTION__, current.player,  current.dts, current.startpts);
       return true;
     }
   }
diff -uNr git/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h unlib/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h
--- git/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.PCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_PCM_H__
+#define __HISI_AUDIO_DECODER_PCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_PCM_ID 0x0000        
+
+typedef struct hiWAV_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format category */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* the block alignment (in bytes) of the
+                                      waveform data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* number of bytes of wave raw data cbExtWord*/
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).                      */
+   /* note: big-endian pcm supprt(microsoft wav file only support little-endian pcm format):
+        cbSize = 4;
+        cbExtWord[0] = 1;
+        cbExtWord[1] ; //reserved
+   */
+} WAV_FORMAT_S;
+
+#define HA_PCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(WAV_FORMAT_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_PCM_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_adp_boardcfg.h unlib/xbmc/linux/hisi/hi_adp_boardcfg.h
--- git/xbmc/linux/hisi/hi_adp_boardcfg.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp_boardcfg.h	2017-07-31 21:24:56.000000000 +0800
@@ -0,0 +1,473 @@
+#ifndef __BOARDCFG_H__
+#define __BOARDCFG_H__
+
+#include "hi_unf_frontend.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TUNER_USE 0
+#define TUNER1_USE 1
+
+#define GET_TUNER_CONFIG(u32TunerPort,stTunerAttr) \
+{ \
+	if(0 == u32TunerPort)\
+	{\
+	    stTunerAttr.enSigType      = HI_TUNER_SIGNAL_TYPE; \
+	    stTunerAttr.enTunerDevType = HI_TUNER_TYPE; \
+	    stTunerAttr.u32TunerAddr   = HI_TUNER_DEV_ADDR; \
+	    stTunerAttr.enDemodDevType = HI_DEMOD_TYPE; \
+	    stTunerAttr.u32DemodAddr   = HI_DEMOD_DEV_ADDR; \
+	    stTunerAttr.enOutputMode   = HI_DEMOD_TS_MODE; \
+	    stTunerAttr.enI2cChannel   = HI_DEMOD_I2C_CHANNEL; \
+		stTunerAttr.u32ResetGpioNo = HI_DEMOD_RESET_GPIO; \
+	    stTunerAttr.unTunerAttr.stSat.u32ResetGpioNo = HI_DEMOD_RESET_GPIO; \
+	}\
+	else if(1 == u32TunerPort)\
+	{\
+		stTunerAttr.enSigType      = HI_TUNER1_SIGNAL_TYPE; \
+	    stTunerAttr.enTunerDevType = HI_TUNER1_TYPE; \
+	    stTunerAttr.u32TunerAddr   = HI_TUNER1_DEV_ADDR; \
+	    stTunerAttr.enDemodDevType = HI_DEMOD1_TYPE; \
+	    stTunerAttr.u32DemodAddr   = HI_DEMOD1_DEV_ADDR; \
+	    stTunerAttr.enOutputMode   = HI_DEMOD1_TS_MODE; \
+	    stTunerAttr.enI2cChannel   = HI_DEMOD1_I2C_CHANNEL; \
+           stTunerAttr.u32ResetGpioNo = HI_DEMOD1_RESET_GPIO; \
+	    stTunerAttr.unTunerAttr.stTer.u32ResetGpioNo = HI_DEMOD1_RESET_GPIO; \
+	}\
+}
+
+#if (HI_TUNER_SIGNAL_TYPE == 2)
+#define GET_SAT_TUNER_CONFIG(u32TunerId,stSatTunerAttr) \
+{ \
+	if (0 == u32TunerId) \
+	{ \
+	    stSatTunerAttr.u32DemodClk       = HI_DEMOD_REF_CLOCK; \
+	    stSatTunerAttr.u16TunerMaxLPF    = HI_TUNER_MAX_LPF; \
+	    stSatTunerAttr.u16TunerI2CClk    = HI_TUNER_I2C_CLOCK; \
+	    stSatTunerAttr.enRFAGC           = HI_TUNER_RFAGC; \
+	    stSatTunerAttr.enIQSpectrum      = HI_TUNER_IQSPECTRUM; \
+	    stSatTunerAttr.enTSClkPolar      = HI_TUNER_TSCLK_POLAR; \
+	    stSatTunerAttr.enTSFormat        = HI_TUNER_TS_FORMAT; \
+	    stSatTunerAttr.enTSSerialPIN     = HI_TUNER_TS_SERIAL_PIN; \
+	    stSatTunerAttr.enDiSEqCWave      = HI_TUNER_DISEQCWAVE; \
+	    stSatTunerAttr.enLNBCtrlDev      = HI_LNBCTRL_DEV_TYPE; \
+	    stSatTunerAttr.u16LNBDevAddress  = HI_LNBCTRL_DEV_ADDR; \
+	} \
+}
+#endif
+
+#if (HI_TUNER1_SIGNAL_TYPE == 2)
+#define GET_SAT_TUNER1_CONFIG(u32TunerId,stSatTunerAttr) \
+{ \
+	if (1 == u32TunerId)\
+    { \
+        stSatTunerAttr.u32DemodClk       = HI_DEMOD1_REF_CLOCK; \
+	    stSatTunerAttr.u16TunerMaxLPF    = HI_TUNER1_MAX_LPF; \
+	    stSatTunerAttr.u16TunerI2CClk    = HI_TUNER1_I2C_CLOCK; \
+	    stSatTunerAttr.enRFAGC           = HI_TUNER1_RFAGC; \
+	    stSatTunerAttr.enIQSpectrum      = HI_TUNER1_IQSPECTRUM; \
+	    stSatTunerAttr.enTSClkPolar      = HI_TUNER1_TSCLK_POLAR; \
+	    stSatTunerAttr.enTSFormat        = HI_TUNER1_TS_FORMAT; \
+	    stSatTunerAttr.enTSSerialPIN     = HI_TUNER1_TS_SERIAL_PIN; \
+	    stSatTunerAttr.enDiSEqCWave      = HI_TUNER1_DISEQCWAVE; \
+	    stSatTunerAttr.enLNBCtrlDev      = HI_LNBCTRL1_DEV_TYPE; \
+	    stSatTunerAttr.u16LNBDevAddress  = HI_LNBCTRL1_DEV_ADDR; \
+    } \
+}
+#endif
+
+#if (HI_TUNER2_SIGNAL_TYPE == 2)
+#define GET_SAT_TUNER2_CONFIG(u32TunerId,stSatTunerAttr) \
+{ \
+	if (2 == u32TunerId)\
+    { \
+        stSatTunerAttr.u32DemodClk       = HI_DEMOD2_REF_CLOCK; \
+	    stSatTunerAttr.u16TunerMaxLPF    = HI_TUNER2_MAX_LPF; \
+	    stSatTunerAttr.u16TunerI2CClk    = HI_TUNER2_I2C_CLOCK; \
+	    stSatTunerAttr.enRFAGC           = HI_TUNER2_RFAGC; \
+	    stSatTunerAttr.enIQSpectrum      = HI_TUNER2_IQSPECTRUM; \
+	    stSatTunerAttr.enTSClkPolar      = HI_TUNER2_TSCLK_POLAR; \
+	    stSatTunerAttr.enTSFormat        = HI_TUNER2_TS_FORMAT; \
+	    stSatTunerAttr.enTSSerialPIN     = HI_TUNER2_TS_SERIAL_PIN; \
+	    stSatTunerAttr.enDiSEqCWave      = HI_TUNER2_DISEQCWAVE; \
+	    stSatTunerAttr.enLNBCtrlDev      = HI_LNBCTRL2_DEV_TYPE; \
+	    stSatTunerAttr.u16LNBDevAddress  = HI_LNBCTRL2_DEV_ADDR; \
+    } \
+}
+#endif
+
+#if (HI_TUNER3_SIGNAL_TYPE == 2)
+#define GET_SAT_TUNER3_CONFIG(u32TunerId,stSatTunerAttr) \
+{ \
+	if (3 == u32TunerId)\
+    { \
+        stSatTunerAttr.u32DemodClk       = HI_DEMOD3_REF_CLOCK; \
+	    stSatTunerAttr.u16TunerMaxLPF    = HI_TUNER3_MAX_LPF; \
+	    stSatTunerAttr.u16TunerI2CClk    = HI_TUNER3_I2C_CLOCK; \
+	    stSatTunerAttr.enRFAGC           = HI_TUNER3_RFAGC; \
+	    stSatTunerAttr.enIQSpectrum      = HI_TUNER3_IQSPECTRUM; \
+	    stSatTunerAttr.enTSClkPolar      = HI_TUNER3_TSCLK_POLAR; \
+	    stSatTunerAttr.enTSFormat        = HI_TUNER3_TS_FORMAT; \
+	    stSatTunerAttr.enTSSerialPIN     = HI_TUNER3_TS_SERIAL_PIN; \
+	    stSatTunerAttr.enDiSEqCWave      = HI_TUNER3_DISEQCWAVE; \
+	    stSatTunerAttr.enLNBCtrlDev      = HI_LNBCTRL3_DEV_TYPE; \
+	    stSatTunerAttr.u16LNBDevAddress  = HI_LNBCTRL3_DEV_ADDR; \
+    } \
+}
+#endif
+
+#if (1 == HI_TUNER_SIGNAL_TYPE || 128 == HI_TUNER_SIGNAL_TYPE)
+#define GET_CAB_TUNER_CONFIG(u32TunerId,stCabTunerAttr) \
+{ \
+	if (0 == u32TunerId) \
+	{ \
+        stCabTunerAttr.u32DemodClk       = HI_CAB_DEMOD_REF_CLOCK; \
+        stCabTunerAttr.enTSSerialPIN     = HI_CAB_TUNER_TS_SERIAL_PIN; \
+	} \
+}
+#endif
+
+#if (1 == HI_TUNER1_SIGNAL_TYPE || 128 == HI_TUNER1_SIGNAL_TYPE)
+#define GET_CAB_TUNER1_CONFIG(u32TunerId,stCabTunerAttr) \
+{ \
+	if (1 == u32TunerId) \
+	{ \
+        stCabTunerAttr.u32DemodClk       = HI_CAB_DEMOD1_REF_CLOCK; \
+        stCabTunerAttr.enTSSerialPIN     = HI_CAB_TUNER1_TS_SERIAL_PIN; \
+	} \
+}
+#endif
+
+#if (HI_TUNER_SIGNAL_TYPE == 4) || (HI_TUNER_SIGNAL_TYPE == 8) || (HI_TUNER_SIGNAL_TYPE == 16)
+#define GET_TER_TUNER_CONFIG(u32TunerId,stTerTunerAttr) \
+{ \
+	if (0 == u32TunerId) \
+	{ \
+	    stTerTunerAttr.u32DemodClk       = HI_TER_DEMOD_REF_CLOCK; \
+	    stTerTunerAttr.u32ResetGpioNo    = HI_DEMOD_RESET_GPIO; \
+	    stTerTunerAttr.u16TunerMaxLPF    = HI_TER_TUNER_MAX_LPF; \
+	    stTerTunerAttr.u16TunerI2CClk    = HI_TER_TUNER_I2C_CLOCK; \
+	    stTerTunerAttr.enRFAGC           = HI_TER_TUNER_RFAGC; \
+	    stTerTunerAttr.enIQSpectrum      = HI_TER_TUNER_IQSPECTRUM; \
+	    stTerTunerAttr.enTSClkPolar      = HI_TER_TUNER_TSCLK_POLAR; \
+	    stTerTunerAttr.enTSFormat        = HI_TER_TUNER_TS_FORMAT; \
+	    stTerTunerAttr.enTSSerialPIN     = HI_TER_TUNER_TS_SERIAL_PIN; \
+	    stTerTunerAttr.enTSSyncHead      = HI_TER_TUNER_TS_SYNC_HEAD; \
+	} \
+}
+#endif
+
+#if (HI_TUNER1_SIGNAL_TYPE == 4) || (HI_TUNER1_SIGNAL_TYPE == 8) || (HI_TUNER1_SIGNAL_TYPE == 16)
+#define GET_TER_TUNER1_CONFIG(u32TunerId,stTerTunerAttr) \
+{ \
+	if (1 == u32TunerId)\
+    { \
+	    stTerTunerAttr.u32DemodClk       = HI_TER_DEMOD1_REF_CLOCK; \
+	    stTerTunerAttr.u32ResetGpioNo    = HI_DEMOD1_RESET_GPIO; \
+	    stTerTunerAttr.u16TunerMaxLPF    = HI_TER_TUNER1_MAX_LPF; \
+	    stTerTunerAttr.u16TunerI2CClk    = HI_TER_TUNER1_I2C_CLOCK; \
+	    stTerTunerAttr.enRFAGC           = HI_TER_TUNER1_RFAGC; \
+	    stTerTunerAttr.enIQSpectrum      = HI_TER_TUNER1_IQSPECTRUM; \
+	    stTerTunerAttr.enTSClkPolar      = HI_TER_TUNER1_TSCLK_POLAR; \
+	    stTerTunerAttr.enTSFormat        = HI_TER_TUNER1_TS_FORMAT; \
+	    stTerTunerAttr.enTSSerialPIN     = HI_TER_TUNER1_TS_SERIAL_PIN; \
+	    stTerTunerAttr.enTSSyncHead      = HI_TER_TUNER1_TS_SYNC_HEAD; \
+    } \
+}
+#endif
+
+#if (HI_TUNER2_SIGNAL_TYPE == 4) || (HI_TUNER2_SIGNAL_TYPE == 8) || (HI_TUNER2_SIGNAL_TYPE == 16)
+#define GET_TER_TUNER2_CONFIG(u32TunerId,stTerTunerAttr) \
+{ \
+	if (2 == u32TunerId)\
+    { \
+	    stTerTunerAttr.u32DemodClk       = HI_TER_DEMOD2_REF_CLOCK; \
+	    stTerTunerAttr.u32ResetGpioNo    = HI_DEMOD2_RESET_GPIO; \
+	    stTerTunerAttr.u16TunerMaxLPF    = HI_TER_TUNER2_MAX_LPF; \
+	    stTerTunerAttr.u16TunerI2CClk    = HI_TER_TUNER2_I2C_CLOCK; \
+	    stTerTunerAttr.enRFAGC           = HI_TER_TUNER2_RFAGC; \
+	    stTerTunerAttr.enIQSpectrum      = HI_TER_TUNER2_IQSPECTRUM; \
+	    stTerTunerAttr.enTSClkPolar      = HI_TER_TUNER2_TSCLK_POLAR; \
+	    stTerTunerAttr.enTSFormat        = HI_TER_TUNER2_TS_FORMAT; \
+	    stTerTunerAttr.enTSSerialPIN     = HI_TER_TUNER2_TS_SERIAL_PIN; \
+	    stTerTunerAttr.enTSSyncHead      = HI_TER_TUNER2_TS_SYNC_HEAD; \
+    } \
+}
+#endif
+
+#if (HI_TUNER3_SIGNAL_TYPE == 4) || (HI_TUNER3_SIGNAL_TYPE == 8) || (HI_TUNER3_SIGNAL_TYPE == 16)
+#define GET_TER_TUNER3_CONFIG(u32TunerId,stTerTunerAttr) \
+{ \
+	if (3 == u32TunerId)\
+    { \
+	    stTerTunerAttr.u32DemodClk       = HI_TER_DEMOD3_REF_CLOCK; \
+	    stTerTunerAttr.u32ResetGpioNo    = HI_DEMOD3_RESET_GPIO; \
+	    stTerTunerAttr.u16TunerMaxLPF    = HI_TER_TUNER3_MAX_LPF; \
+	    stTerTunerAttr.u16TunerI2CClk    = HI_TER_TUNER3_I2C_CLOCK; \
+	    stTerTunerAttr.enRFAGC           = HI_TER_TUNER3_RFAGC; \
+	    stTerTunerAttr.enIQSpectrum      = HI_TER_TUNER3_IQSPECTRUM; \
+	    stTerTunerAttr.enTSClkPolar      = HI_TER_TUNER3_TSCLK_POLAR; \
+	    stTerTunerAttr.enTSFormat        = HI_TER_TUNER3_TS_FORMAT; \
+	    stTerTunerAttr.enTSSerialPIN     = HI_TER_TUNER3_TS_SERIAL_PIN; \
+	    stTerTunerAttr.enTSSyncHead      = HI_TER_TUNER3_TS_SYNC_HEAD; \
+    } \
+}
+#endif
+
+#if (HI_DEMOD_TYPE == 274) || (HI_DEMOD1_TYPE == 274)
+#define GET_MULTIMODE_DEMOD_CONFIG(u32TunerPort,stPortAttr) \
+{ \
+    if(0 == u32TunerPort) \
+	{ \
+	    stPortAttr.enADCPort       = HI_MULTIMODE_DEMOD_ADC_PORT; \
+	    stPortAttr.enTSOutputPort   = HI_MULTIMODE_DEMOD_TS_OUTPUT_PORT; \
+	    stPortAttr.enI2CGateWaySel  = HI_MULTIMODE_DEMOD_I2C_GATEWAY_SEL; \
+	    stPortAttr.enSyncPin        = HI_MULTIMODE_DEMOD_SYNC_PIN_MUX; \
+	    stPortAttr.enIFPath          = HI_MULTIMODE_DEMOD_IF_OUTPUT; \
+	} \
+	else if(1 == u32TunerPort) \
+    { \
+	    stPortAttr.enADCPort       = HI_MULTIMODE_DEMOD1_ADC_PORT; \
+	    stPortAttr.enTSOutputPort   = HI_MULTIMODE_DEMOD1_TS_OUTPUT_PORT; \
+	    stPortAttr.enI2CGateWaySel  = HI_MULTIMODE_DEMOD1_I2C_GATEWAY_SEL; \
+	    stPortAttr.enSyncPin        = HI_MULTIMODE_DEMOD1_SYNC_PIN_MUX; \
+	    stPortAttr.enIFPath          = HI_MULTIMODE_DEMOD1_IF_OUTPUT; \
+	} \
+}
+#endif
+
+#define DEMUX_PORT_ID (0)
+/*tuner*/
+
+#if (HI_TUNER_SIGNAL_TYPE == 1)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_CAB; \
+    stConnectPara.unConnectPara.stCab.bReverse = 0; \
+    stConnectPara.unConnectPara.stCab.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stCab.u32SymbolRate = 6875000; \
+    stConnectPara.unConnectPara.stCab.enModType = HI_UNF_MOD_TYPE_QAM_64; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 2)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_SAT; \
+    stConnectPara.unConnectPara.stSat.u32Freq = 3840000; \
+    stConnectPara.unConnectPara.stSat.u32SymbolRate = 27500000; \
+    stConnectPara.unConnectPara.stSat.enPolar = HI_UNF_TUNER_FE_POLARIZATION_H; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 4)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DVB_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 8000; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 8)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DVB_T2; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 8000; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 16)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ISDB_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 32)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ATSC_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 64)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DTMB; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 128)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_J83B; \
+    stConnectPara.unConnectPara.stCab.bReverse = 0; \
+    stConnectPara.unConnectPara.stCab.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stCab.u32SymbolRate = 5056941; \
+    stConnectPara.unConnectPara.stCab.enModType = HI_UNF_MOD_TYPE_QAM_64; \
+}
+#elif (HI_TUNER_SIGNAL_TYPE == 256)
+#define GET_CONNECT_PARA(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ABSS; \
+    stConnectPara.unConnectPara.stSat.u32Freq = 1184000; \
+    stConnectPara.unConnectPara.stSat.u32SymbolRate = 28800000; \
+    stConnectPara.unConnectPara.stSat.enPolar = HI_UNF_TUNER_FE_POLARIZATION_L; \
+}
+#endif
+
+#if (HI_TUNER1_SIGNAL_TYPE == 1)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_CAB; \
+    stConnectPara.unConnectPara.stCab.bReverse = 0; \
+    stConnectPara.unConnectPara.stCab.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stCab.u32SymbolRate = 6875000; \
+    stConnectPara.unConnectPara.stCab.enModType = HI_UNF_MOD_TYPE_QAM_64; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 2)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_SAT; \
+    stConnectPara.unConnectPara.stSat.u32Freq = 3840000; \
+    stConnectPara.unConnectPara.stSat.u32SymbolRate = 27500000; \
+    stConnectPara.unConnectPara.stSat.enPolar = HI_UNF_TUNER_FE_POLARIZATION_H; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 4)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DVB_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 8000; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 8)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DVB_T2; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 8000; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 16)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ISDB_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 32)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ATSC_T; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 64)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_DTMB; \
+    stConnectPara.unConnectPara.stTer.bReverse = 0; \
+    stConnectPara.unConnectPara.stTer.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stTer.u32BandWidth = 6000; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 128)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_J83B; \
+    stConnectPara.unConnectPara.stCab.bReverse = 0; \
+    stConnectPara.unConnectPara.stCab.u32Freq = 666000; \
+    stConnectPara.unConnectPara.stCab.u32SymbolRate = 5056941; \
+    stConnectPara.unConnectPara.stCab.enModType = HI_UNF_MOD_TYPE_QAM_64; \
+}
+#elif (HI_TUNER1_SIGNAL_TYPE == 256)
+#define GET_CONNECT_PARA1(stConnectPara) \
+{ \
+    stConnectPara.enSigType = HI_UNF_TUNER_SIG_TYPE_ABSS; \
+    stConnectPara.unConnectPara.stSat.u32Freq = 1184000; \
+    stConnectPara.unConnectPara.stSat.u32SymbolRate = 28800000; \
+    stConnectPara.unConnectPara.stSat.enPolar = HI_UNF_TUNER_FE_POLARIZATION_L; \
+}
+#endif
+/********
+TS_OUT0data7stTSOut.enTSOutput[0] = HI_UNF_TUNER_OUTPUT_TSDAT7
+********/
+#ifdef HI_TUNER_OUTPUT_PIN0
+#define GET_TUNER0_TSOUT_CONFIG(stTSOut) \
+{ \
+	    stTSOut.enTSOutput[0] = HI_TUNER_OUTPUT_PIN0; \
+	    stTSOut.enTSOutput[1] = HI_TUNER_OUTPUT_PIN1; \
+	    stTSOut.enTSOutput[2] = HI_TUNER_OUTPUT_PIN2; \
+	    stTSOut.enTSOutput[3] = HI_TUNER_OUTPUT_PIN3; \
+	    stTSOut.enTSOutput[4] = HI_TUNER_OUTPUT_PIN4; \
+	    stTSOut.enTSOutput[5] = HI_TUNER_OUTPUT_PIN5; \
+	    stTSOut.enTSOutput[6] = HI_TUNER_OUTPUT_PIN6; \
+	    stTSOut.enTSOutput[7] = HI_TUNER_OUTPUT_PIN7; \
+	    stTSOut.enTSOutput[8] = HI_TUNER_OUTPUT_PIN8; \
+	    stTSOut.enTSOutput[9] = HI_TUNER_OUTPUT_PIN9; \
+	    stTSOut.enTSOutput[10] = HI_TUNER_OUTPUT_PIN10; \
+}
+#endif
+
+#ifdef HI_TUNER1_OUTPUT_PIN0
+#define GET_TUNER1_TSOUT_CONFIG(stTSOut) \
+{ \
+        stTSOut.enTSOutput[0] = HI_TUNER1_OUTPUT_PIN0; \
+	    stTSOut.enTSOutput[1] = HI_TUNER1_OUTPUT_PIN1; \
+	    stTSOut.enTSOutput[2] = HI_TUNER1_OUTPUT_PIN2; \
+	    stTSOut.enTSOutput[3] = HI_TUNER1_OUTPUT_PIN3; \
+	    stTSOut.enTSOutput[4] = HI_TUNER1_OUTPUT_PIN4; \
+	    stTSOut.enTSOutput[5] = HI_TUNER1_OUTPUT_PIN5; \
+	    stTSOut.enTSOutput[6] = HI_TUNER1_OUTPUT_PIN6; \
+	    stTSOut.enTSOutput[7] = HI_TUNER1_OUTPUT_PIN7; \
+	    stTSOut.enTSOutput[8] = HI_TUNER1_OUTPUT_PIN8; \
+	    stTSOut.enTSOutput[9] = HI_TUNER1_OUTPUT_PIN9; \
+	    stTSOut.enTSOutput[10] = HI_TUNER1_OUTPUT_PIN10; \
+}
+#endif
+
+#ifdef HI_TUNER2_OUTPUT_PIN0
+#define GET_TUNER2_TSOUT_CONFIG(stTSOut) \
+{ \
+        stTSOut.enTSOutput[0] = HI_TUNER2_OUTPUT_PIN0; \
+	    stTSOut.enTSOutput[1] = HI_TUNER2_OUTPUT_PIN1; \
+	    stTSOut.enTSOutput[2] = HI_TUNER2_OUTPUT_PIN2; \
+	    stTSOut.enTSOutput[3] = HI_TUNER2_OUTPUT_PIN3; \
+	    stTSOut.enTSOutput[4] = HI_TUNER2_OUTPUT_PIN4; \
+	    stTSOut.enTSOutput[5] = HI_TUNER2_OUTPUT_PIN5; \
+	    stTSOut.enTSOutput[6] = HI_TUNER2_OUTPUT_PIN6; \
+	    stTSOut.enTSOutput[7] = HI_TUNER2_OUTPUT_PIN7; \
+	    stTSOut.enTSOutput[8] = HI_TUNER2_OUTPUT_PIN8; \
+	    stTSOut.enTSOutput[9] = HI_TUNER2_OUTPUT_PIN9; \
+	    stTSOut.enTSOutput[10] = HI_TUNER2_OUTPUT_PIN10; \
+}
+#endif
+#ifdef HI_TUNER3_OUTPUT_PIN0
+#define GET_TUNER3_TSOUT_CONFIG(stTSOut) \
+{ \
+        stTSOut.enTSOutput[0] = HI_TUNER3_OUTPUT_PIN0; \
+	    stTSOut.enTSOutput[1] = HI_TUNER3_OUTPUT_PIN1; \
+	    stTSOut.enTSOutput[2] = HI_TUNER3_OUTPUT_PIN2; \
+	    stTSOut.enTSOutput[3] = HI_TUNER3_OUTPUT_PIN3; \
+	    stTSOut.enTSOutput[4] = HI_TUNER3_OUTPUT_PIN4; \
+	    stTSOut.enTSOutput[5] = HI_TUNER3_OUTPUT_PIN5; \
+	    stTSOut.enTSOutput[6] = HI_TUNER3_OUTPUT_PIN6; \
+	    stTSOut.enTSOutput[7] = HI_TUNER3_OUTPUT_PIN7; \
+	    stTSOut.enTSOutput[8] = HI_TUNER3_OUTPUT_PIN8; \
+	    stTSOut.enTSOutput[9] = HI_TUNER3_OUTPUT_PIN9; \
+	    stTSOut.enTSOutput[10] = HI_TUNER3_OUTPUT_PIN10; \
+}
+#endif
+
+//#endif
+
+#define DEFAULT_DVB_PORT (HI_DEMUX_PORT)
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff -uNr git/xbmc/linux/hisi/hi_adp.h unlib/xbmc/linux/hisi/hi_adp.h
--- git/xbmc/linux/hisi/hi_adp.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp.h	2017-07-31 21:24:56.000000000 +0800
@@ -0,0 +1,132 @@
+#ifndef __HI_ADP_H__
+#define __HI_ADP_H__
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "hi_type.h"
+
+#if defined(ANDROID)
+#include <utils/Log.h>
+extern void LogPrint(const char *format, ...);
+#endif
+
+#ifdef CONFIG_SUPPORT_CA_RELEASE
+#define sample_common_printf
+#else
+#if defined(ANDROID)
+#define sample_common_printf LogPrint
+#else
+#define sample_common_printf printf
+#endif
+#endif
+
+#define HIAPI_RUN(api, ret) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            ret |= errCode; \
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN(api) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN_FN(api, fn) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            fn; \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_ERR_PRINTF(ret) \
+    do {\
+        sample_common_printf("\033[0;31m" " [Function: %s line: %d]  ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, ret); \
+    } while (0)\
+
+
+#define PRINT_SMP(fmt...) sample_common_printf(fmt)
+
+#define SAMPLE_RUN(api, ret) \
+    do { \
+        HI_S32 l_ret = api; \
+        if (l_ret != HI_SUCCESS) \
+        { \
+            PRINT_SMP("run %s failed, ERRNO:%#x.\n", # api, l_ret); \
+        } \
+        else \
+        {\
+            /*printf("sample %s: run %s ok.\n", __FUNCTION__, #api);}*/ \
+        } \
+        ret = l_ret; \
+    } while (0)
+
+#define SAMPLE_CheckNullPTR(pointer) \
+    do  \
+    { \
+        if (NULL == pointer) \
+        {   \
+            PRINT_SMP("%s failed:NULL Pointer in Line:%d!\n", __FUNCTION__, __LINE__); \
+            return HI_FAILURE;  \
+        }   \
+    } while (0)
+
+#ifdef ANDROID
+#define SAMPLE_GET_INPUTCMD(InputCmd)   \
+    do { \
+        memset(InputCmd, 0, sizeof(InputCmd)); \
+        read(0, InputCmd, sizeof(InputCmd)); \
+    } while (0)
+
+#define HISI_SAMPLE_FIFO "/dev/hisi_sample_fifo"
+
+#define HI_GET_INPUTCMD(InputCmd)   \
+    do { \
+        int t_fd; \
+        unlink(HISI_SAMPLE_FIFO); \
+        if (mkfifo(HISI_SAMPLE_FIFO, 0777) != -1) \
+        { \
+            t_fd = open(HISI_SAMPLE_FIFO, O_RDONLY); \
+            if (t_fd != -1)  \
+            { \
+                memset(InputCmd, 0, sizeof(InputCmd));   \
+                read(t_fd, InputCmd, sizeof(InputCmd));  \
+                close(t_fd); \
+            } \
+            else  \
+            { \
+                perror("Can't open the FIFO:");  \
+                exit(0); \
+            } \
+        } \
+        else  \
+        { \
+            perror("Can't create FIFO channel:"); \
+            exit(0); \
+        } \
+    } while (0)
+#else
+#define SAMPLE_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+
+#define HI_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+#endif
+
+#endif
diff -uNr git/xbmc/linux/hisi/hi_adp_hdmi.h unlib/xbmc/linux/hisi/hi_adp_hdmi.h
--- git/xbmc/linux/hisi/hi_adp_hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp_hdmi.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,15 @@
+#ifndef __SAMPLE_HDMI_COMMON_H__
+#define __SAMPLE_HDMI_COMMON_H__
+
+#include "hi_unf_hdmi.h"
+
+typedef void (*User_HDMI_CallBack)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt);
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId);
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId);
+//HI_S32 HIADP_HDMI_SetAdecAttr(HI_UNF_SND_INTERFACE_E enInterface, HI_UNF_SAMPLE_RATE_E enRate);
+HI_VOID HDMI_PrintSinkCap(HI_UNF_EDID_BASE_INFO_S *pCapbility);
+
+#endif /* #if pub_HDMI_H_ */
+
diff -uNr git/xbmc/linux/hisi/hi_adp_mpi.h unlib/xbmc/linux/hisi/hi_adp_mpi.h
--- git/xbmc/linux/hisi/hi_adp_mpi.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp_mpi.h	2017-07-31 21:24:56.000000000 +0800
@@ -0,0 +1,90 @@
+#ifndef  __HI_ADP_MPI_H__
+#define  __HI_ADP_MPI_H__
+
+#include "hi_type.h"
+#include "hi_unf_common.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_vo.h"
+#include "hi_adp.h"
+#include "hi_adp_search.h"
+#include "hi_adp_boardcfg.h"
+#include "hi_unf_ai.h"
+
+#define DOLBYPLUS_HACODEC_SUPPORT
+#define SLIC_AUDIO_DEVICE_ENABLE
+
+#define G711_FRAME_LEN 320
+
+/********************************* Demux Common Interface *******************************/
+HI_S32 HIADP_Demux_Init(HI_U32 DmxPortID,HI_U32 TsPortID);
+
+HI_S32 HIADP_Demux_DeInit(HI_U32 DmxPortID);
+
+/************************************DISPLAY  Common Interface*******************************/
+HI_S32 HIADP_Disp_StrToFmt(HI_CHAR *pszFmt);
+
+HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat);
+
+HI_S32 HIADP_Disp_DeInit(HI_VOID);
+
+
+/****************************VO  Common Interface********************************************/
+HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+HI_S32 HIADP_VO_CreatWin(HI_RECT_S * pstWinRect, HI_HANDLE * phWin);
+
+HI_S32 HIADP_VO_CreatWinExt(HI_RECT_S * pstWinRect, HI_HANDLE * phWin, HI_BOOL bVirtScreen);
+
+HI_S32 HIADP_VO_DeInit();
+
+/*****************************************SOUND  Common Interface************************************/
+HI_S32 HIADP_Snd_Init(HI_VOID);
+
+
+HI_S32 HIADP_Snd_DeInit(HI_VOID);
+
+#ifdef HI_AUDIO_AI_SUPPORT
+/*Only Support Single AI Chn*/
+HI_S32 HIADP_AI_Init(HI_UNF_AI_E enAISrc, HI_HANDLE *pAIHandle, HI_HANDLE *pTrackSlave, HI_HANDLE *pATrackVir);
+HI_S32 HIADP_AI_DeInit(HI_HANDLE hAI, HI_HANDLE hAISlave, HI_HANDLE hAIVir);
+#endif
+
+/*****************************************AIAO  Common Interface************************************/
+HI_S32 HIADP_AIAO_Init(HI_S32 DevId, HI_S32 AI_Ch, HI_S32 AO_Ch, HI_UNF_SAMPLE_RATE_E enSamplerate, HI_U32 u32SamplePerFrame);
+
+
+HI_S32 HIADP_AIAO_DeInit(HI_VOID);
+
+HI_S32 HIADP_SLIC_Open(HI_VOID);
+HI_S32 HIADP_SLIC_Close(HI_VOID);
+HI_S32 HIADP_SLIC_GetHookOff(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_GetHookOn(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_SetRinging(HI_BOOL bEnable);
+
+
+/**************************************AVPLAY  Common Interface***************************************/
+HI_S32 HIADP_AVPlay_RegADecLib();
+
+HI_S32 HIADP_AVPlay_Init();
+
+HI_S32 HIADP_AVPlay_Create(HI_HANDLE *avplay,HI_U32 u32DemuxId,
+                                 HI_UNF_AVPLAY_STREAM_TYPE_E streamtype,
+                                 HI_UNF_VCODEC_CAP_LEVEL_E vdeccap,
+                                 HI_U32 channelflag);
+
+HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode);
+
+HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly);
+
+HI_S32 HIADP_AVPlay_PlayProg(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum,HI_BOOL bAudPlay);
+
+HI_S32 HIADP_AVPlay_PlayAud(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum);
+
+HI_S32 HIADP_AVPlay_SwitchAud(HI_HANDLE hAvplay,HI_U32 AudPid, HI_U32 u32AudType);
+
+HI_S32 HIADP_MCE_Exit(HI_VOID);
+
+HI_S32 HIADP_DMX_AttachTSPort(HI_U32 Dmxid, HI_U32 TunerID);
+
+#endif
+
diff -uNr git/xbmc/linux/hisi/hi_adp_search.h unlib/xbmc/linux/hisi/hi_adp_search.h
--- git/xbmc/linux/hisi/hi_adp_search.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp_search.h	2017-07-31 21:24:56.000000000 +0800
@@ -0,0 +1,375 @@
+#ifndef _COMMON_SEARCH_H__
+#define _COMMON_SEARCH_H__
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/********************Descriptor flag definition******************/
+/********************CNcomment:******************/
+
+#define STREAM_TYPE_11172_VIDEO         0x01
+#define STREAM_TYPE_13818_VIDEO         0x02
+#define STREAM_TYPE_11172_AUDIO         0x03
+#define STREAM_TYPE_13818_AUDIO         0x04
+#define STREAM_TYPE_14496_2_VIDEO       0x10    // MPEG4
+#define STREAM_TYPE_14496_10_VIDEO      0x1B    // H264
+#define STREAM_TYPE_AVS_VIDEO           0x42    // AVS
+#define STREAM_TYPE_AVS2_VIDEO          0xD2    // AVS2.0
+#define STREAM_TYPE_HEVC_VIDEO          0x24    // HEVC
+#define STREAM_TYPE_13818_7_AUDIO       0x0F    // AAC
+#define STREAM_TYPE_14496_3_AUDIO       0x11    // AAC
+#define STREAM_TYPE_AC3_AUDIO           0x81    // AC3
+#define STREAM_TYPE_SCTE                0x82    // TS packets containing SCTE data
+#define STREAM_TYPE_DTS_AUDIO           0x82    // DTS
+#define STREAM_TYPE_DOLBY_TRUEHD_AUDIO  0x83    // dolby true HD
+#define STREAM_TYPE_DTS_MA				0x86	// DTS MA which conflict with CAPTION_SERVICE_DESCRIPTOR
+#define STREAM_TYPE_PRIVATE             0x06    // PES packets containing private data
+
+#define VIDEO_STREAM_DESCRIPTOR             0x02
+#define AUDIO_STREAM_DESCRIPTOR             0x03
+#define HIERACHY_DESCRIPTOR                 0x04
+#define REGISTRATION_DESCRIPTOR             0x05
+#define DATA_STREAM_ALIGNMENT_DESCRIPTOR    0x06
+#define TARGET_BACKGROUND_GRID_DESCRIPTOR   0x07
+#define VIDEO_WINDOW_DESCRIPTOR             0x08
+#define CA_DESCRIPTOR                       0x09
+#define LANGUAGE_DESCRIPTOR                 0x0A
+#define SYSTEM_CLOCK_DESCRIPTOR             0x0B
+#define MULTIPLEX_BUFFER_USAGE_DESCRIPTOR   0x0C
+#define COPYRIGHT_DESCRIPTOR                0x0D
+#define MAXIMUM_BITRATE_DESCRIPTOR          0x0E
+#define PRIVATE_DATA_INDICATOR_DESCRIPTOR   0x0F
+#define SMOOTHING_BUFFER_DESCRIPTOR         0x10
+#define STD_DESCRIPTOR                      0x11
+#define IBP_DESCRIPTOR                      0x12
+
+#define NETWORK_NAME_DESCRIPTOR 0x40
+#define SERVICE_LIST_DESCRIPTOR 0x41
+#define STUFFING_DESCRIPTOR 0x42
+#define SATELLITE_DELIVERY_DESCRIPTOR 0x43
+#define CABLE_DELIVERY_DESCRIPTOR 0x44
+#define BOUQUET_NAME_DESCRIPTOR 0x47
+#define SERVICE_DESCRIPTOR 0x48
+#define COUNTRY_AVAILABILITY_DESCRIPTOR 0x49
+#define LINKAGE_DESCRIPTOR 0x4A
+#define NVOD_REFERENCE_DESCRIPTOR 0x4B
+#define TIME_SHIFTED_SERVICE_DESCRIPTOR 0x4C
+#define SHORT_EVENT_DESCRIPTOR 0x4D
+#define EXTENDED_EVENT_DESCRIPTOR 0x4E
+#define TIME_SHIFTED_EVENT_DESCRIPTOR 0x4F
+#define COMPONENT_DESCRIPTOR 0x50
+#define MOSAIC_DESCRIPTOR 0x51
+#define STREAM_IDENTIFIER_DESCRIPTOR 0x52
+#define CA_IDENTIFIER_DESCRIPTOR 0x53
+#define CONTENT_DESCRIPTOR 0x54
+#define PARENTAL_RATING_DESCRIPTOR 0x55
+#define TELETEXT_DESCRIPTOR 0x56
+#define TELEPHONE_DESCRIPTOR 0x57
+#define LOCAL_TIME_OFFSET_DESCRIPTOR 0x58
+#define SUBTITLING_DESCRIPTOR 0x59
+#define TERRESTRIAL_DELIVERY_DESCRIPTOR 0x5A
+#define MULTILINGUAL_NETWORK_NAME_DESCRIPTOR 0x5B
+#define MULTILINGUAL_BOUQUET_NAME_DESCRIPTOR 0x5C
+#define MULTILINGUAL_SERVICE_NAME_DESCRIPTOR 0x5D
+#define MULTILINGUAL_COMPONENT_DESCRIPTOR 0x5E
+#define PRIVATE_DATA_SPECIFIER_DESCRIPTOR 0x5F
+#define SERVICE_MOVE_DESCRIPTOR 0x60
+#define SHORT_SMOOTHING_BUFFER_DESCRIPTOR 0x61
+#define FREQUENCY_LIST_DESCRIPTOR 0x62
+#define PARTIAL_TRANSPORT_STREAM_DESCRIPTOR 0x63
+#define DATA_BROADCAST_DESCRIPTOR 0x64
+#define CA_SYSTEM_DESCRIPTOR 0x65
+#define DATA_BROADCAST_ID_DESCRIPTOR 0x66
+#define TRANSPORT_STREAM_DESCRIPTOR 0x67
+#define DSNG_DESCRIPTOR 0x68
+#define PDC_DESCRIPTOR 0x69
+#define AC3_DESCRIPTOR 0x6A
+#define AC3_PLUS_DESCRIPTOR 0x7A
+#define ANCILLARY_DATA_DESCRIPTOR 0x6B
+#define CELL_LIST_DESCRIPTOR 0x6C
+#define CELL_FREQUENCY_LINK_DESCRIPTOR 0x6D
+#define ANNOUNCEMENT_SUPPORT_DESCRIPTOR 0x6E
+#define DRA_DESCRIPTOR 0x05
+
+#define AC3_EXT_DESCRIPTOR 0x52
+
+#define CAPTION_SERVICE_DESCRIPTOR 0x86
+#define EXTENSION_DESCRIPTOR 0x7F
+#define SUPPLEMENTARY_AUDIO_DESCRIPTOR 0x06
+
+#define STREAM_TYPE_HEVC_VIDEO_IDENTIFY 0x48455643
+#define STREAM_TYPE_DTS_AUDIO_IDENTIFY 0x44545331
+
+#define MAX_PMT_LEN     1024
+/***********TS PID defintion**************/
+
+#define PAT_TSPID (0x0000)
+#define CAT_TSPID (0x0001)
+#define NIT_TSPID (0x0010)
+#define EIT_TSPID (0x0012)
+#define TOT_TSPID (0x0014)
+#define TDT_TSPID (0x0014)
+#define SDT_TSPID (0x0011)
+#define BAT_TSPID (0x0011)
+
+#define INVALID_TSPID (0x1fff)
+
+/***********Table ID defintion**************/
+#define PAT_TABLE_ID (0x00)
+#define CAT_TABLE_ID (0x01)
+#define PMT_TABLE_ID (0x02)
+#define NIT_TABLE_ID_ACTUAL (0x40)
+#define NIT_TABLE_ID_OTHER (0x41)
+
+#define SDT_TABLE_ID_ACTUAL (0x42)
+#define SDT_TABLE_ID_OTHER (0x46)
+
+#define BAT_TABLE_ID (0x4A)
+#define EIT_TABLE_ID_PF_ACTUAL (0x4E)
+#define EIT_TABLE_ID_PF_OTHER (0x4F)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_LOW (0x50)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_HIGH (0x5F)
+
+#define EIT_TABLE_ID_SCHEDULE_OTHER_LOW (0x60)
+#define EIT_TABLE_ID_SCHEDULE_OTHER_HIGH (0x6F)
+
+#define TDT_TABLE_ID (0x70)
+#define TOT_TABLE_ID (0x73)
+
+#define INVALID_TABLE_ID (0xff)
+#define CHANNEL_MAX_PROG    256
+#define PROG_MAX_VIDEO      8
+#define PROG_MAX_AUDIO      8
+#define PROG_MAX_CA         8
+
+#define SUBTDES_INFO_MAX 10
+#define SUBTITLING_MAX 15
+#define CAPTION_SERVICE_MAX 16
+#define TTX_DES_MAX    10
+#define TTX_MAX        15
+
+#define SUBT_TYPE_DVB  (0x1)
+#define SUBT_TYPE_SCTE (0x2)
+#define SUBT_TYPE_BOTH (SUBT_TYPE_DVB | SUBT_TYPE_SCTE)
+
+typedef struct hiPAT_INFO_S
+{
+    HI_U16 u16ServiceID;    /*Progam 's SERVICE ID*/
+    HI_U16 u16PmtPid;        /*Progam 's PMT ID*/
+} PAT_INFO;
+
+typedef struct hiPAT_TB_S
+{
+    HI_U16 u16ProgNum;
+    HI_U16 u16TsID;
+    PAT_INFO PatInfo[CHANNEL_MAX_PROG];
+} PAT_TB;
+
+typedef struct hiPMT_VIDEO_S
+{
+    HI_U32 u32VideoEncType;
+    HI_U16 u16VideoPid;
+} PMT_VIDEO;
+
+typedef struct hiPMT_AUDIO_S
+{
+    HI_U32         u32AudioEncType;
+    HI_U16         u16AudioPid;
+    HI_U16         u16ADType;
+} PMT_AUDIO;
+typedef struct hiPMT_CA_S
+{
+    HI_U16 u16CASystemID;
+    HI_U16 u16CAPID ;
+} PMT_CA;
+
+typedef struct hiPMP_SUBTITLE_DES_S
+{
+    HI_U32 u32LangCode; /* low 24-bit valid */
+    HI_U8  u8SubtitleType;
+    HI_U16 u16PageID;
+    HI_U16 u16AncillaryPageID;
+
+}PMP_SUBTITLE_DES;
+
+typedef struct hiPMT_SUBTITLE_S
+{
+    HI_U16 u16SubtitlingPID;
+
+    HI_U8 u8DesTag; /*  */
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMP_SUBTITLE_DES DesInfo[SUBTDES_INFO_MAX];
+
+}PMT_SUBTITLE;
+
+typedef struct hiPMT_SCTE_SUBTITLE_S
+{
+
+    HI_U16 u16SCTESubtPID;
+    HI_U32 u32LanguageCode;
+}PMT_SCTE_SUBTITLE_S;
+
+typedef struct hiPMT_CLOSED_CAPTION_S
+{
+    HI_U32 u32LangCode;
+    HI_U8 u8IsDigitalCC;
+    HI_U8 u8ServiceNumber;
+    HI_U8 u8IsEasyReader;
+    HI_U8 u8IsWideAspectRatio;
+}PMT_CLOSED_CAPTION_S;
+
+typedef struct hiPMT_TTX_DES_S
+{
+    HI_U32 u32ISO639LanguageCode; /* low 24-bit valid */
+    HI_U8  u8TtxType;
+    HI_U8  u8TtxMagazineNumber;
+    HI_U8  u8TtxPageNumber;
+} PMT_TTX_DES_S;
+
+typedef struct hiPMT_TTX_S
+{
+    HI_U16 u16TtxPID;
+
+    HI_U8 u8DesTag;
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMT_TTX_DES_S stTtxDes[TTX_DES_MAX];
+
+} PMT_TTX_S;
+
+
+typedef struct hiPMT_TB_S
+{
+    HI_U16 u16ServiceID;
+    HI_U16 u16PcrPid;
+    HI_U16 u16VideoNum;
+    HI_U16 u16AudoNum;
+    HI_U16 u16CANum;
+    PMT_VIDEO Videoinfo[PROG_MAX_VIDEO];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];
+    PMT_CA CASystem[PROG_MAX_CA];
+
+    HI_U16 u16SubtitlingNum;
+    PMT_SUBTITLE SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16 u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16 u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_TB;
+
+typedef enum hiRUN_STATE_E
+{
+    UnDefined = 0,
+    NotRun,
+    StartInSeconds,
+    Pause,
+    Running,
+    Run_Reserved1,
+    Run_Reserved2,
+    Run_Reserved3
+} RUN_STATE_E;
+
+typedef enum hiCA_MODE_E
+{
+    CA_NotNeed = 0,
+    CA_Need
+} CA_MODE_E;
+
+typedef struct hiSDT_INFO_S
+{
+    HI_U16          u16ServiceID;
+    HI_U8       u8EitFlag;
+    HI_U8       u8EitFlag_PF;
+    RUN_STATE_E RunState;
+    CA_MODE_E   CAMode;
+
+    HI_U32      u32ServiceType;
+    HI_S8   s8ProgName[32];
+} SDT_INFO;
+
+typedef struct hiSDT_TB_S
+{
+    HI_U32 u32ProgNum;
+    HI_U16 u16TsId;
+    HI_U16 u16NetID;
+    SDT_INFO SdtInfo[CHANNEL_MAX_PROG];
+} SDT_TB;
+
+
+typedef struct hiPMT_COMPACT_PROG_S
+{
+    HI_U32 ProgID;          /* program ID */
+    HI_U32 PmtPid;          /*program PMT PID*/
+    HI_U32 PmtRemapPid; /* overlapped when remux, remap to new pid */
+    HI_U32 PcrPid;          /*program PCR PID*/
+
+    HI_U32   VideoType;
+    HI_U16               VElementNum;        /* video stream number */
+    HI_U16               VElementPid;        /* the first video stream PID*/
+    HI_U16               VElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U32   AudioFormat;
+    HI_U32   AudioType;
+    HI_U16               AElementNum;        /* audio stream number */
+    HI_U16               AElementPid;        /* the first audio stream PID*/
+    HI_U16               AElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U16 u16CANum;
+    PMT_CA CASystem[PROG_MAX_CA];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];     /* multi-audio info, added by gaoyanfeng 00182102 */
+
+    HI_U32              SubtType;            /*0---NONE,1---DVB,2---SCTE,3---BOTH*/
+    HI_U16              u16SubtitlingNum;
+    PMT_SUBTITLE        SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16               u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16              u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_COMPACT_PROG;
+
+typedef struct hiPMT_COMPACT_TBL_S
+{
+    HI_U32            prog_num;
+    PMT_COMPACT_PROG *proginfo;
+} PMT_COMPACT_TBL;
+
+HI_S32      DVB_SearchStart(HI_U32 u32DmxID);
+HI_VOID     DVB_SaveSearch(HI_U32 u32FrontendID);
+HI_VOID     DVB_ListProg();
+HI_S32      SRH_ParseSDT(const HI_U8 *pu8SectionData, HI_S32 s32Length, HI_U8 *pSectionStruct);
+HI_S32      SRH_ParsePMT ( const HI_U8 *pu8SectionData, HI_S32 s32Length, HI_U8 *pSectionStruct);
+HI_S32      SRH_ParsePAT( const HI_U8  *pu8SectionData, HI_S32 s32Length, HI_U8 *pSectionStruct);
+HI_S32      SRH_PATRequest(HI_U32 u32DmxID,PAT_TB *pat_tb);
+HI_S32      SRH_PMTRequest(HI_U32 u32DmxID,PMT_TB *pmt_tb,HI_U16 u16PmtPid, HI_U16 u16ServiceId);
+HI_S32      SRH_SDTRequest(HI_U32 u32DmxID,SDT_TB *sdt_tb);
+/******************************************Search public interface***********************************/
+HI_VOID     HIADP_Search_Init();
+HI_S32      HIADP_Search_GetAllPmt(HI_U32 u32DmxId,PMT_COMPACT_TBL **ppProgTable);
+HI_S32      HIADP_Search_FreeAllPmt(PMT_COMPACT_TBL *pProgTable);
+HI_VOID     HIADP_Search_DeInit();
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif /*__SEARCH_H__*/
diff -uNr git/xbmc/linux/hisi/hi_audio_codec.h unlib/xbmc/linux/hisi/hi_audio_codec.h
--- git/xbmc/linux/hisi/hi_audio_codec.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_audio_codec.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,828 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_audio_codec.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2009/11/01
+Last Modified :
+Description   : define audio common data structure
+  History       :
+  1.Date        : 2009/11/10
+    Author      : zgjie
+    Modification: Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the audio codec. CNcomment:AUDIO_CODEC CNend
+ */
+
+#ifndef __HI_AUDIO_CODEC_H__
+#define __HI_AUDIO_CODEC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**Define HA codec Print Level*/
+/**CNcomment:HA codec*/
+#define HA_TRACE_LEVEL_FATAL    (0)
+#define HA_TRACE_LEVEL_ERROR    (1)
+#define HA_TRACE_LEVEL_WARN     (2)
+#define HA_TRACE_LEVEL_INFO     (3)
+#define HA_TRACE_LEVEL_DBG      (4)
+
+
+#ifndef HI_ADVCA_FUNCTION_RELEASE
+
+#ifndef CFG_HA_LOG_LEVEL
+#define CFG_HA_LOG_LEVEL         (HA_TRACE_LEVEL_ERROR)
+#endif
+
+#if (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_FATAL)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_ERROR)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRIN(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_WARN)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_INFO)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_DBG)
+
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)     do{printf(fmt);}while(0)
+
+#endif
+
+#else
+
+#define HA_FATAL_PRINT(fmt...)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#endif
+
+/**Define software dual decode*/
+/**CNcomment:*/
+#define HA_SW_DUALDEC_SUPPORT
+
+/**Define HA codec ID*/
+/**CNcomment:HA codec ID*/
+/*
+*                HA CODEC_ID defination
+*   |      7bit                9bit                3bit                   13bit  |
+*   |---vendor---|---format---|---reserved---|---id---|
+*/
+#define VENDOR_HISI 0x040
+#define VENDOR_NONE 0x010
+#define HA_VENDOR_OFFSETK  25 /* (32-7) */
+#define HA_VENDOR_MASK     (0x007fUL << HA_VENDOR_OFFSETK)
+#define HA_FORMAT_OFFSETK  16 /* (32-7-9) */
+#define HA_FORMAT_MASK     (0x01ffUL << HA_FORMAT_OFFSETK)
+#define HA_RESERVED_OFFSET 13 /* (32-7-9-3) */
+#define HA_RESERVED_MASK   (0x007UL << HA_RESERVED_OFFSET)
+#define HA_ID_OFFSET       0 /* (32-7-9-3-13) */
+#define HA_ID_MASK         (0x1fffUL<< HA_ID_OFFSET)
+
+#define HA_BUILD_CODEC_ID(vendor, format, id) (((((HI_U32)vendor) << HA_VENDOR_OFFSETK) & HA_VENDOR_MASK) | ((((HI_U32)format) << HA_FORMAT_OFFSETK) & HA_FORMAT_MASK) | (((HI_U32)id) & HA_ID_MASK))
+#define HA_GET_VENDOR(codec) ((HI_U32)(codec&HA_VENDOR_MASK)>>HA_VENDOR_OFFSETK)
+#define HA_GET_FORMAT(codec) ((HI_U32)(codec&HA_FORMAT_MASK)>>HA_FORMAT_OFFSETK)
+#define HA_GET_ID(codec)     ((HI_U32)(codec&HA_ID_MASK)>>HA_ID_OFFSET)
+
+/********************************Macro Definition********************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!-- ACODEC */
+
+/**Define HA codec common command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_COMMON_CMD_ID   0xffff
+
+/**Define HA codec format query command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_FORMAT_QUERY_CMD         ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1000)
+
+/**Define HA codec decoder open parameter command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_GET_DECOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1001)
+
+/**Define HA codec encoder open parameter command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_GET_ENCOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1002)
+
+/**Define HA codec packet query command ID*/
+/**CNcomment:HA codec packetCMD ID*/
+#define HA_CODEC_PACKETDECODER_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1003)
+
+/**Define HA codec hwdecode query command ID*/
+/**CNcomment:HA codec hwdecodeCMD ID*/
+#define HA_CODEC_HARDWARECODEC_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1004)
+
+/**Define HA codec set outbuf addr command ID  only for hardware codec*/
+/**CNcomment:BufferCMD ID*/
+#define HA_CODEC_OUTBUFADDR_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1005)
+
+/**Define dual decode capability support query command ID*/
+/**CNcomment:CMD ID*/
+#define HA_CODEC_DUAL_DECODE_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1006)
+
+/**Define dual decode set ad output mode command ID*/
+/**CNcomment:ADCMD ID*/
+#define HA_CODEC_AD_OUTPUTMODE_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1007)
+
+/**Define AD Balance Setting command ID*/
+/**CNcomment:AD CMD ID*/
+#define HA_CODEC_AD_BALANCE_SET_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1008)
+
+/**Define PTS Delay command ID*/
+/**CNcomment:PTS Delay CMD ID*/
+#define HA_CODEC_PTS_DELAY_SET_CMD      ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1009)
+
+/**Define HA codec set whether work in compress mode command ID */
+/**CNcomment:CMD ID*/
+#define HA_CODEC_COMPRESSMODE_SET_CMD ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100A)
+
+/**Define HA codec maximum audio channel*/
+/**CNcomment:HA codec  */
+#define HA_AUDIO_MAXCHANNELS 8
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!--  ACODEC */
+
+/**HA format definition*/
+/**CNcomment:HA format */
+typedef enum hiHA_FORMAT_E
+{
+    FORMAT_MP2 = 0x000,  /**<MPEG audio layer 1, 2.*/ /**<CNcomment:MPEG */
+    FORMAT_MP3, /**<MPEG audio layer 1, 2, 3.*/ /**<CNcomment:MPEG */
+    FORMAT_AAC,
+    FORMAT_AC3,
+    FORMAT_DTS,
+    FORMAT_VORBIS,
+    FORMAT_DVAUDIO,
+    FORMAT_WMAV1,
+    FORMAT_WMAV2,
+    FORMAT_MACE3,
+    FORMAT_MACE6,
+    FORMAT_VMDAUDIO,
+    FORMAT_SONIC,
+    FORMAT_SONIC_LS,
+    FORMAT_FLAC,
+    FORMAT_MP3ADU,
+    FORMAT_MP3ON4,
+    FORMAT_SHORTEN,
+    FORMAT_ALAC,
+    FORMAT_WESTWOOD_SND1,
+    FORMAT_GSM,
+    FORMAT_QDM2,
+    FORMAT_COOK,
+    FORMAT_TRUESPEECH,
+    FORMAT_TTA,
+    FORMAT_SMACKAUDIO,
+    FORMAT_QCELP,
+    FORMAT_WAVPACK,
+    FORMAT_DSICINAUDIO,
+    FORMAT_IMC,
+    FORMAT_MUSEPACK7,
+    FORMAT_MLP,
+    FORMAT_GSM_MS, /**<as found in WAV.*/ /**<CNcomment:WAV */
+    FORMAT_ATRAC3,
+    FORMAT_VOXWARE,
+    FORMAT_APE,
+    FORMAT_NELLYMOSER,
+    FORMAT_MUSEPACK8,
+    FORMAT_SPEEX,
+    FORMAT_WMAVOICE,
+    FORMAT_WMAPRO,
+    FORMAT_WMALOSSLESS,
+    FORMAT_ATRAC3P,
+    FORMAT_EAC3,
+    FORMAT_SIPR,
+    FORMAT_MP1,
+    FORMAT_TWINVQ,
+    FORMAT_TRUEHD,
+    FORMAT_MP4ALS,
+    FORMAT_ATRAC1,
+    FORMAT_BINKAUDIO_RDFT,
+    FORMAT_BINKAUDIO_DCT,
+    FORMAT_DRA,
+    FORMAT_MS12_DDP,
+    FORMAT_MS12_AAC,
+    FORMAT_MS12_AC4,
+
+    FORMAT_PCM = 0x100,/**<various PCM codecs.*/ /**<CNcomment:PCM */
+    FORMAT_PCM_BLURAY = 0x121,
+
+    FORMAT_ADPCM = 0x130,/**<various ADPCM codecs.*/ /**<CNcomment:ADPCM */
+
+    FORMAT_AMR_NB = 0x160,/**<various AMR codecs.*/ /**<CNcomment:AMR */
+    FORMAT_AMR_WB,
+    FORMAT_AMR_AWB,
+
+    FORMAT_RA_144 = 0x170,/**<RealAudio codecs.*/ /**<CNcomment:RealAudio */
+    FORMAT_RA_288,
+
+    FORMAT_DPCM = 0x180,/**<various DPCM codecs.*/ /**<CNcomment:DPCM */
+
+    FORMAT_G711 = 0x190,/**<various G.7xx codecs.*/ /**<CNcomment:G.7xx */
+    FORMAT_G722,
+    FORMAT_G7231,
+    FORMAT_G726,
+    FORMAT_G728,
+    FORMAT_G729AB,
+
+    FORMAT_OPUS = 0x1a0,
+
+    FORMAT_MULTI = 0x1f0,/**<support multi codecs.*/ /**<CNcomment: */
+
+    FORMAT_BUTT = 0x1ff,
+} HA_FORMAT_E;
+
+/**HA format definition*/
+/**CNcomment:HA_Codec*/
+typedef enum hiHA_CODEC_ID_E
+{
+    /** HISI Codec*/
+    HA_AUDIO_ID_PCM             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM, 0x0000),
+    HA_AUDIO_ID_MP2             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MP2, 0x0002),
+    HA_AUDIO_ID_MP3             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0003),
+    HA_AUDIO_ID_AAC             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AAC, 0x001),
+    HA_AUDIO_ID_BLYRAYLPCM      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM_BLURAY, 0x021),
+    HA_AUDIO_ID_COOK            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_COOK, 0x0009),
+    HA_AUDIO_ID_DRA             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DRA, 0x007),
+    HA_AUDIO_ID_WMA9STD         = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0006),
+    HA_AUDIO_ID_AMRNB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_NB, 0x0100),
+    HA_AUDIO_ID_AMRWB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_WB, 0x0110),
+    HA_AUDIO_ID_G711            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G711, 0x0102),
+    HA_AUDIO_ID_G722            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G722, 0x0105),
+    HA_AUDIO_ID_G726            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G726, 0x0106),
+    HA_AUDIO_ID_ADPCM           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_ADPCM, 0x0107),
+    HA_AUDIO_ID_VOICE           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0108),
+    HA_AUDIO_ID_TRUEHD          = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x0008),
+    HA_AUDIO_ID_AC3PASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0055),
+    HA_AUDIO_ID_DTSPASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DTS, 0x1025),
+    HA_AUDIO_ID_OPUS            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_OPUS, 0x1006),
+    HA_AUDIO_ID_VORBIS          = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_VORBIS, 0x1007),
+
+    /** DOLBY/DTS IPR Codec*/
+    HA_AUDIO_ID_DOLBY_PLUS      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x1010),
+    HA_AUDIO_ID_DOLBY_TRUEHD    = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x1011),
+    HA_AUDIO_ID_MS12_DDP        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_DDP, 0x1012),
+    HA_AUDIO_ID_MS12_AAC        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_AAC, 0x1013),
+    HA_AUDIO_ID_MS12_AC4        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_AC4, 0x1014),
+    HA_AUDIO_ID_DTSHD           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1020),
+    HA_AUDIO_ID_DTSM6           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1030),
+
+    /** FFMPEG Codec*/
+    HA_AUDIO_ID_FFMPEG_DECODE   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI,  0x03ff),
+    HA_AUDIO_ID_FFMPEG_WMAPRO   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_WMAPRO, 0x041f),
+
+    /** CUSTOMER Codec*/
+    HA_AUDIO_ID_CUSTOM_0        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0400),
+    HA_AUDIO_ID_CUSTOM_1        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0401),
+} HA_CODEC_ID_E;
+
+/**HA Audio Output AD Mode definition*/
+/**CNcomment:HA OUTPUT AD MODE */
+typedef enum
+{
+    HA_OUTPUT_AD_OFF = 0,
+    HA_OUTPUT_AD_ON,
+    HA_OUTPUT_AD_OFF_WITHASSOC,
+    HA_OUTPUT_AD_BUTT
+} HA_CODEC_OUTPUT_AD_MODE_E;
+
+/**Define query parameter of an HA codec.*/
+/**CNcomment:HA codec */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_VOID *pPara;
+} HA_CODEC_PARAMETER_QUERY_S;
+
+/**Define format query parameter of an HA codec.*/
+/**CNcomment:HA codec */
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_FORMAT_E enFormat;
+} HA_CODEC_FORMAT_QUERY_PARAM_S;
+
+/**Define packet query parameter of an HA codec.*/
+/**CNcomment:HA codec packet*/
+typedef struct
+{
+    HI_U32  enCmd;              /**<packet query command.*/ /**<CNcomment:packet*/
+    HI_BOOL bPacketDecoder;     /**<Packet mode.In this mode, the decoder can decode the next packet only after processing an entire packet. */
+                                /**<CNcomment:packet.packetpacket*/
+} HA_CODEC_PACKETDECODER_QUERY_PARAM_S;
+
+/**Define hardware decode query parameter of an HA codec.*/
+/**CNcomment:HA codec hardware*/
+typedef struct
+{
+    HI_U32  enCmd;      /**<hwdecode query command.*/ /**<CNcomment: hwdecode*/
+    HI_BOOL bHwCodec;   /**<HI_TRUE: hwdecode mode else swdecode mode. */ /**<CNcomment:hwdecode*/
+} HA_CODEC_HARDWARECODER_QUERY_PARAM_S;
+
+/**Define query parameter of dual decode capability.*/
+/**CNcomment:*/
+typedef struct
+{
+    HI_U32  enCmd;                  /**<query dual decode capability command.*/ /**<CNcomment: */
+    HI_BOOL bDualDecSupport;        /**<support dual decode or not. */  /**<CNcomment:*/
+} HA_CODEC_DUALDECODE_QUERY_PARAM_S;
+
+/**Define setting parameter of dual decode ad output mode.*/
+/**CNcomment:AD**/
+typedef struct
+{
+    HI_U32               enCmd;             /**<set AD Output Mode command.*/ /**<CNcomment: AD*/
+    HA_CODEC_OUTPUT_AD_MODE_E  enAdMode;    /**<AD Output Mode. */  /**<CNcomment:AD*/
+} HA_CODEC_ADMODE_SET_PARAM_S;
+
+/**Define setting parameter of AD Balance.*/
+/**CNcomment:AD **/
+typedef struct
+{
+    HI_U32  enCmd;                      /**<set AD Balance command.*/ /**<CNcomment: AD*/
+    HI_S16  s16ADBalance;               /**<set the value of AD Balance */  /**<CNcomment:AD*/
+} HA_CODEC_ADBALANCE_SET_PARAM_S;
+
+/**Define set parameter of whether work in compress mode.*/
+/**CNcomment:*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<set the compress mode command. */ /**<CNcomment:*/
+    HI_BOOL bCompressMode;  /**<whether work in compress mode. */ /**<CNcomment:*/
+} HA_CODEC_COMPRESSMODE_SET_PARAM_S;
+
+/**Define the error codes of an HA codec.*/
+/**CNcomment:HA codec */
+typedef enum hiHA_ERRORTYPE_E
+{
+    HA_ErrorNone = 0, /**<None error.*/ /**<CNcomment: */
+
+    HA_ErrorInsufficientResources = (HI_S32) 0x80001000,/**<The device fails to be created due to insufficient resources.*/ /**<CNcomment: */
+
+    HA_ErrorInvalidParameter = (HI_S32) 0x80001001, /**<The input parameter is invalid.*/ /**<CNcomment: */
+
+    HA_ErrorStreamCorrupt = (HI_S32) 0x80001002, /**<The decoding fails due to incorrect input streams.*/ /**<CNcomment: */
+
+    HA_ErrorNotEnoughData = (HI_S32) 0x80001003,/**<The decoding ends due to insufficient streams.*/ /**<CNcomment: */
+
+    HA_ErrorDecodeMode = (HI_S32) 0x80001004,/**<The decoding mode is not supported.*/ /**<CNcomment: */
+
+    HA_ErrorNotSupportCodec = (HI_S32) 0x80001005,/**<The codec is not supported.*/ /**<CNcomment: */
+
+    HA_ErrorInBufFull = (HI_S32) 0x80001006,/**<Input buffer is full.*/ /**<CNcomment: */
+
+    HA_ErrorOutBufEmpty = (HI_S32) 0x80001007,/**<Output buffer is empty.*/ /**<CNcomment: */
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    HA_ErrorNotEnoughADData = (HI_S32) 0x80001008,/**<The decoding ends due to insufficient ad streams.*/ /**<CNcomment:ad */
+
+    HA_ErrorADDecFailed = (HI_S32) 0x80001009,
+#endif
+
+    HA_ErrorMax = 0x9FFFFFFF
+} HI_HA_ERRORTYPE_E;
+
+/**Definition of the distribution mode of the channels of an HA codec.*/
+/**CNcomment:HA codec */
+typedef enum hiHA_CHANNELTYPE_E
+{
+    HA_AUDIO_ChannelNone = 0x0,    /**< Unused or empty.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLF  = 0x1,     /**< Left front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRF  = 0x2,     /**< Right front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelCF  = 0x3,     /**< Center front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLS  = 0x4,     /**< Left surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRS  = 0x5,     /**< Right surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLFE = 0x6,     /**< Low frequency effects.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelCS  = 0x7,     /**< Back surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLR  = 0x8,     /**< Left rear.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRR  = 0x9,     /**< Right rear.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelMax = 0x7FFFFFFF
+} HI_HA_CHANNELTYPE_E;
+
+/**Definition of the decoding mode of an HA decoder.*/
+/**CNcomment:HA */
+typedef enum hiHA_DECODEMODE_E
+{
+    HD_DEC_MODE_RAWPCM = 0,        /**<PCM decoding mode.*/ /**<CNcomment:PCM */
+    HD_DEC_MODE_THRU,              /**<SPIDF61937 passthrough decoding mode only, such as AC3/DTS.*/ /**<CNcomment:*/
+    HD_DEC_MODE_SIMUL,             /**<PCM and passthrough decoding mode.*/ /**<CNcomment:PCM + */
+    HD_DEC_MODE_BUTT = 0x7FFFFFFF
+} HI_HA_DECODEMODE_E;
+
+/**Definition of the HA codec version.*/
+/**CNcomment:HA codec */
+typedef union hiHI_HAAUDIO_VERSIONTYPE_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;      /**< Major version.*/ /**<CNcomment: */
+        HI_U8 u8VersionMinor;      /**< Minor version.*/ /**<CNcomment: */
+        HI_U8 u8Revision;          /**< Revision version.*/ /**<CNcomment: */
+        HI_U8 u8Step;              /**< Step version.*/ /**<CNcomment: */
+    } s;
+    HI_U32 u32Version;
+} HI_HAAUDIO_VERSIONTYPE_U;
+
+/**Definition of the data types of the PCM module in an HA codec HA codec.*/
+/**CNcomment:pcm */
+typedef struct hiHA_PCMMODETYPE_S
+{
+    HI_U32              u32DesiredOutChannels;/**<Input,number of expected output channels.If the number of original channels is not equal to the number of expected output channels,
+                                                  the decoded automatically performs down-mixing or up-mixing,In this way,
+                                                  the number of output channels is equal to the value of u32DesiredOutChannels,1: mono; 2 stereo. \n*/
+                                              /**<CNcomment:IN . 
+                                                  down-mix up-mix 
+                                                  u32DesiredOutChannels.  1: mono, 2 for stereo*/
+    HI_BOOL             bInterleaved;/**<Whether the PCM data is interleaved.
+                                         HI_TRUE: interleaved mode (L/R/L/R.. .L/R/L/R).
+                                         HI_FALSE: non-interleaved mode (L/L/L.../R/R/R...). \n*/
+                                     /**<CNcomment:IN PCM 
+                                         HI_TRUE:  : L/R/L/R...L/R/L/R.
+                                         HI_FALSE: : L/L/L......../R/R/R....... */
+    HI_U32              u32BitPerSample;/**<Input Bit width of the PCM data.Only 16-bit or 24-bit width is supported.For the data of 16-bit width, 16-bit memory is used,
+                                            For the data of 24-bit width, 32-bit memory is used,The active bits of the 24-bit PCM data are upper bits, and the lower eight bits are padded with 0s. \n*/
+                                        /**<CNcomment:IN PCM ,16 24  16bit 16bit ,
+                                            24bit 32.24bit PCM8 0*/
+    HI_U32              u32DesiredSampleRate; /**<Input, expected output sampling rate.*/ /**<CNcomment:IN */
+    HI_HA_CHANNELTYPE_E enChannelMapping[HA_AUDIO_MAXCHANNELS]; /**<Input, distribution mode of output channels.*/ /**<CNcomment:IN */
+} HI_HA_PCMMODETYPE_S;
+
+/**Configuration parameters required by an HA codec for creating devices.*/
+/**CNcomment:HA */
+typedef struct hiHADECODE_OPENPARAM_S
+{
+    HI_HA_DECODEMODE_E  enDecMode;  /**<IN Decode Mode.*/ /**<CNcomment:*/
+    HI_HA_PCMMODETYPE_S sPcmformat; /**<IN data types of pcm module.*/ /**<CNcomment:PCM*/
+    HI_VOID *           pCodecPrivateData;/**<Input, pointer to private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                          /**<CNcomment:IN  0*/
+    HI_U32              u32CodecPrivateDataSize;/**<Input, size of the private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                                /**<CNcomment:IN , 0*/
+} HI_HADECODE_OPENPARAM_S;
+
+/**Input streams of an HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHADECODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;  /**<Input, presentation time stamp (PTS) (in ms).Note: The HA decoder must discard this information. */ /**<CNcomment:*/
+    HI_U8  *pu8Data;   /**<Input/output, pointer to input streams.The decoder update this pointer after decoding. */ /**<CNcomment:IN/OUT */
+    HI_S32  s32Size;   /**<Input, size (in byte) of input streams.*/ /**<CNcomment:IN . unit: Byte*/
+    HI_BOOL bEndOfFrm; /**<Input, the last frame or not.*/ /**<CNcomment:IN */
+} HI_HADECODE_INPACKET_S;
+
+/**Get Open parameter of an HA decoder.*/
+/**CNcomment:HA */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_HADECODE_OPENPARAM_S *pstDecodeParams;
+} HA_CODEC_GET_DECOPENPARAM_PARAM_S;
+
+/**Definition of the decoder output pts infomations.*/
+/**CNcomment:pts*/
+typedef struct hiHI_HA_OUTPTSINFO_S
+{
+    union
+    {
+        HI_U32 u32SwDecoderBytesLeft;   /**<left bytes of software decoder.*/ /**<CNcomment: */
+        HI_U32 u32HwDecoderPtsReadPos;  /**<pts read position of software decoder.*/ /**<CNcomment:pts */
+    } unPts;
+
+    union
+    {
+        HI_U32 u32SwAdDecoderBytesLeft;     /**<ad left bytes of software decoder.*/ /**<CNcomment:ad */
+        HI_U32 u32HwAdDecoderPtsReadPos;    /**<ad pts read position of software decoder.*/ /**<CNcomment:ad pts */
+    } unAdPts;
+} HI_HA_OUTPTSINFO_S;
+
+/**Output structure of the HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHI_HADECODE_OUTPUT_S
+{
+    HI_S32 *ps32PcmOutBuf;       /**<Input, pointer to the decoded PCM data.
+                                     Note: 1) ps32PcmOutBuf must be 32-word aligned.
+                                           2) ps32PcmOutBuf is NULL when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN PCM . */
+
+    HI_U32  u32PcmOutBufSize;    /**<Input, size (in byte) of the buffer for storing the decoded PCM data
+                                     Note: u32PcmOutBufSize is 0 when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN  PCM . unit:Byte */
+
+    HI_S32 *ps32BitsOutBuf;      /**<Input, pointer to the decoded passthrough data.
+                                     Note: 1) ps32BitsOutBuf must be 32-word aligned.
+                                           2) ps32BitsOutBuf is NULL when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN . */
+
+    HI_U32  u32BitsOutBufSize;   /**<Input, size (in byte) of the buffer for storing the decoded passthrough data (IEC61937)
+                                     Note: u32BitsOutBufSize is 0 when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN (IEC61937) . unit:Byte */
+
+    HI_U32  u32PcmOutSamplesPerFrame; /**<Output, number of output sampling points after the PCM data is decoded.*/ /**<CNcomment:OUT. Pcm  */
+    HI_BOOL bInterleaved;             /**<Output, interleaved mode for PCM decoding.*/ /**<CNcomment:OUT PCM  */
+    HI_U32  u32BitPerSample;          /**<Output, bit per sampling.*/ /**<CNcomment:OUT */
+    HI_U32  u32BitsOutBytesPerFrame;  /**<Output, size (in byte) of the passthrough frame.*/ /**<CNcomment:OUT . unit: Byte*/
+    HI_U32  u32OutChannels;           /**<Output, number of output channels.*/ /**<CNcomment:OUT */
+    HI_U32  u32OutSampleRate;         /**<Output, output sampling rate.*/ /**<CNcomment:OUT. */
+    HI_U32  u32OrgChannels;           /**<Output, number of original channels.*/ /**<CNcomment:OUT */
+    HI_U32  u32OrgSampleRate;         /**<Output, original sampling rate.*/ /**<CNcomment:OUT */
+    HI_U32  u32BitRate;               /**<Output, bit rate (in bit/s) of the compressed streams.*/ /**<CNcomment:OUT unit: bit/S*/
+    HI_HA_OUTPTSINFO_S stPtsInfo;     /**<Output, pts information.*/ /**<CNcomment:OUT. pts*/
+    HI_U32  u32FrameIndex;   /**<Output, output frame index.*/ /**<CNcomment:OUT. */
+} HI_HADECODE_OUTPUT_S;
+
+/**Definition of the HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHA_DECODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about a decoder, such as MP3 or AAC. */
+                          /**<CNcomment:IN MP3,AAC*/
+
+    const HI_U32 enCodecID;/**<Input, decoder ID.Note: This ID is the identifier of a decoder, and must be unique. */
+                           /**<CNcomment:IN : */
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, decoder version.*/ /**<CNcomment:IN */
+
+    const HI_PCHAR pszDescription;/**<Input, detailed information about a decoder.*/ /**<CNcomment:IN */
+
+
+
+    struct hiHA_DECODE_S *pstNext;/**<Output, pointer to the next decoder.This member variable is maintained by the client that calls the HA codec,
+                                      Therefore, the developers of the HA decoder can ignore this member variable. \n*/
+                                  /**<CNcomment:OUT  .  HA Codec , HA */
+
+    HI_VOID  * pDllModule;/**<Output, pointer to the dll symbol of an HA decoder,This member variable is maintained by the client that calls the HA codec,
+                              Therefore, the developers of the HA decoder can ignore this member variable.\n*/
+                          /**<CNcomment:OUT HA Codec , HA */
+
+    /**
+    \brief Initializes a decoder. CNcomment: CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open CNend
+    \param[out] phDecoder   pointer of the decoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecInit)(HI_VOID * *phDecoder,
+                                 const HI_HADECODE_OPENPARAM_S * pstOpenParam);
+
+    /**
+    \brief DeInitializes a decoder. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   pointer of the decoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDeInit)(HI_VOID* hDecoder);
+
+    /**
+    \brief Configure a decoder dynamically. You can call this API when a decoder works.
+    CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the decoder CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID* hDecoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum size of the buffer required for storing the PCM data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:PCMsize.  CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the pcm audio frame. unit:Byte CNcomment:PCM CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxPcmOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief Maximum size of the buffer required for storing the passthrough data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:size. CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the iec61937 audio frame. unit:Byte CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxBitsOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to decode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDecodeFrame)(HI_VOID* hDecoder,
+                                        HI_HADECODE_INPACKET_S* pstApkt,
+                                        HI_HADECODE_OUTPUT_S* pstAOut);
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    /**
+    \brief This method is used to dual decode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[in] pstADApkt pointer to AD audio stream packet CNcomment:AD CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDualDecodeFrame)(HI_VOID* hDecoder,
+                                            HI_HADECODE_INPACKET_S* pstApkt,
+                                            HI_HADECODE_INPACKET_S* pstADApkt,
+                                            HI_HADECODE_OUTPUT_S* pstAOut);
+#endif
+
+} HI_HA_DECODE_S;
+
+/**Parameters for creating an HA encoder.*/
+/**CNcomment:HA */
+typedef struct hiHAENCODE_OPENPARAM_S
+{
+    HI_U32      u32DesiredOutChannels; /**<IN Number of channels (e.g 2 for stereo).*/ /**<CNcomment:*/
+    HI_BOOL     bInterleaved;       /**<IN interleave or not.*/ /**<CNcomment:*/
+    HI_S32      s32BitPerSample;    /**<IN bitwidth per sample.*/ /**<CNcomment:*/
+    HI_U32      u32DesiredSampleRate; /**<IN desired samplerate.*/ /**<CNcomment:*/
+    HI_U32      u32SamplePerFrame;  /**<IN Pcm samples per frame for encoder.*/ /**<CNcomment:*/
+    HI_VOID*    pCodecPrivateData;  /**<IN Pointer of decoder private open parameters note: if there is none private parameters, pCodecPrivateData=0.*/
+                                    /**<CNcomment:*/
+    HI_U32      u32CodecPrivateDataSize;/**<IN Size of decoder private open parameters note: if there is none private parameters, u32CodecPrivateDataSize=0.*/
+                                        /**<CNcomment:*/
+} HI_HAENCODE_OPENPARAM_S;
+
+/**HA input pcm  packet struct.*/
+/**CNcomment:packet*/
+typedef struct hiHAENCODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;       /**<IN  PTS (unit:MS) Note: HA encoder should discard this infomation.*/
+                            /**<CNcomment:PTS:*/
+    HI_U8*  pu8Data;        /**<IN/OUT pointer to input auduo pcm data note: HA encoder would update pu8Data after encode.*/
+                            /**<CNcomment:*/
+    HI_U32  u32Size;        /**<IN/OUT size of the input auduo data. unit: Byte.*/ /**<CNcomment:*/
+} HI_HAENCODE_INPACKET_S;
+
+/**HA encoder output struct.*/
+/**CNcomment:*/
+typedef struct hiHAENCODE_OUTPUT_S
+{
+    HI_S32* ps32BitsOutBuf;         /**<IN the pointer to encoded bitstream output buffer note: ps32BitsOutBuf must  be word32-aligned.*/
+                                    /**<CNcomment:buffer*/
+    HI_U32  u32BitsOutBufSize;      /**<IN the buffer size of bitstream output buffer. unit:Byte.*/ /**<CNcomment:buffer*/
+    HI_U32  u32BitsOutBytesPerFrame;/**<IN size of the encoded audio data frame ,unit: Byte.*/ /**<CNcomment::Byte*/
+    HI_U32  u32BitRate;             /**<IN compress bit rate of the audio stream.*/ /**<CNcomment:*/
+} HI_HAENCODE_OUTPUT_S;
+
+/**HA encoder struct define.*/
+/**CNcomment:*/
+typedef struct hiHA_ENCODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about audio encoder. */
+    /**<CNcomment:IN */
+
+    const HI_U32 enCodecID;/**<Input, encoder ID.Note: This ID is the identifier of a encoder, and must be unique. */
+    /**<CNcomment:IN : */
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, encoder version.*/ /**<CNcomment:IN */
+
+    const HI_PCHAR pszDescription;/**<Input, Description infomation of the audio encoder. */ /**<CNcomment:IN */
+
+    struct hiHA_ENCODE_S* pstNext;/**<OUT pointer to next HA enocder.manager by client.client:The layer of software that invokes the methods of the HA encoder. */
+    /**<CNcomment:OUT  */
+
+    HI_VOID*   pDllModule;/**<Output, pointer to the dll symbol of an HA encoder.This member variable is maintained by the client that calls the HA codec
+                              Therefore, the developers of the HA encoder can ignore this member variable. \n*/
+    /**<CNcomment:OUT HA Codec , HA */
+
+    /**
+    \brief Initializes a encoder. CNcomment: CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open CNend
+    \param[out] phEncoder   pointer of the encoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeInit)(HI_VOID * *phEncoder,
+                                    const HI_HAENCODE_OPENPARAM_S* pstOpenParam);
+
+    /**
+    \brief DeInitializes a encoder. CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   pointer of the encoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeDeInit)(HI_VOID* hEncoder);
+
+    /**
+    \brief Configure a encoder dynamically. It can be invoked anytime after the Encoder has been loaded.
+    CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   the encoder handle CNcomment: CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the encoder CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID* hEncoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum output size of an encoded bitstream CNcomment:size CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the encoded audio frame. unit:Byte CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeGetMaxBitsOutSize)(HI_VOID* hEncoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to encode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeFrame)(HI_VOID* hEncoder,
+                                     HI_HAENCODE_INPACKET_S* pstApkt,
+                                     HI_HAENCODE_OUTPUT_S* pstAOut);
+} HI_HA_ENCODE_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* #ifndef __HI_AUDIO_CODEC_H__ */
diff -uNr git/xbmc/linux/hisi/hi_common.h unlib/xbmc/linux/hisi/hi_common.h
--- git/xbmc/linux/hisi/hi_common.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_common.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,743 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_common.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/15
+  Description   : Common apis for hisilicon system.
+  History       :
+  1.Date        : 2010/01/25
+    Author      : jianglei
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_COMMON_H__
+#define __HI_COMMON_H__
+
+#include "hi_type.h"
+#include "hi_debug.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     COMMON */
+/** @{ */ /** <!--  [COMMON] */
+
+/** Global config structure */
+typedef struct hiSYS_CONF_S
+{
+    HI_U32 u32Reverse;  /**<Not used, reserved for extension*/ /**<CNcomment: */
+
+}HI_SYS_CONF_S;
+
+/** Define the chip type. */
+typedef enum hiCHIP_TYPE_E
+{
+    HI_CHIP_TYPE_HI3716M,
+    HI_CHIP_TYPE_HI3716H,
+    HI_CHIP_TYPE_HI3716C,
+    HI_CHIP_TYPE_HI3716D,
+
+    HI_CHIP_TYPE_HI3720,
+    HI_CHIP_TYPE_HI3712,
+    HI_CHIP_TYPE_HI3715,
+
+    HI_CHIP_TYPE_HI3718M,
+    HI_CHIP_TYPE_HI3718C,
+    HI_CHIP_TYPE_HI3719M,
+    HI_CHIP_TYPE_HI3719C,
+    HI_CHIP_TYPE_HI3719M_A,
+
+    HI_CHIP_TYPE_HI3796C    = 0x20,
+    HI_CHIP_TYPE_HI3798C,
+    HI_CHIP_TYPE_HI3796M,
+    HI_CHIP_TYPE_HI3798M,
+
+    HI_CHIP_TYPE_HI3796C_A  = 0x40,
+    HI_CHIP_TYPE_HI3798C_A,
+    HI_CHIP_TYPE_HI3798C_B,
+
+    HI_CHIP_TYPE_HI3798M_A,
+
+    HI_CHIP_TYPE_BUTT
+}HI_CHIP_TYPE_E;
+
+/** Define the chip version. */
+typedef enum hiCHIP_VERSION_E
+{
+    HI_CHIP_VERSION_V100 = 0x100,
+    HI_CHIP_VERSION_V101 = 0x101,
+    HI_CHIP_VERSION_V200 = 0x200,
+    HI_CHIP_VERSION_V210 = 0x210,
+    HI_CHIP_VERSION_V300 = 0x300,
+    HI_CHIP_VERSION_V310 = 0x310,
+    HI_CHIP_VERSION_V400 = 0x400,
+    HI_CHIP_VERSION_V410 = 0x410,
+    HI_CHIP_VERSION_V420 = 0x420,
+    HI_CHIP_VERSION_BUTT
+}HI_CHIP_VERSION_E;
+
+typedef enum
+{
+    HI_CHIP_PACKAGE_TYPE_BGA_15_15 = 0,
+    HI_CHIP_PACKAGE_TYPE_BGA_16_16,
+    HI_CHIP_PACKAGE_TYPE_BGA_19_19,
+    HI_CHIP_PACKAGE_TYPE_BGA_23_23,
+    HI_CHIP_PACKAGE_TYPE_BGA_31_31,
+    HI_CHIP_PACKAGE_TYPE_QFP_216,
+    HI_CHIP_PACKAGE_TYPE_BGA_21_21,
+    HI_CHIP_PACKAGE_TYPE_BGA_14_14,
+    HI_CHIP_PACKAGE_TYPE_BUTT
+} HI_CHIP_PACKAGE_TYPE_E;
+
+/** Define the chip support attrs */
+typedef enum hiCHIP_CAP_E
+{
+    HI_CHIP_CAP_DOLBY,
+    HI_CHIP_CAP_DTS,
+    HI_CHIP_CAP_ADVCA,
+    HI_CHIP_CAP_MACROVISION,
+    HI_CHIP_CAP_HDR10,
+    HI_CHIP_CAP_DOLBYVISION,
+    HI_CHIP_CAP_BUTT 
+} HI_CHIP_CAP_E;
+
+/**System version, that is, the version of the software developer's kit (SDK)*/
+typedef struct hiSYS_VERSION_S
+{
+    HI_CHIP_TYPE_E  enChipTypeSoft;      /**<Chip type corresponding to the SDK*/ /**<CNcomment:  SDK */
+    HI_CHIP_TYPE_E  enChipTypeHardWare;  /**<Chip type that is detected when the SDK is running*/ /**<CNcomment:  SDK */
+    HI_CHIP_VERSION_E enChipVersion;     /**<Chip version that is detected when the SDK is running*/ /**<CNcomment: SDK */
+    HI_CHAR         aVersion[80];        /**<Version string of the SDK*/ /**<CNcomment:  SDK */
+    HI_CHAR         BootVersion[80];     /**<Version string of the Boot*/ /**<CNcomment:  Boot */
+}HI_SYS_VERSION_S;
+
+
+/** Define the chip attributes */
+typedef struct hiSYS_CHIP_ATTR_S
+{
+    HI_BOOL bDolbySupport;         /**<Whether support dolby or not*//**<CNcomment:*/
+    HI_BOOL bDTSSupport;           /**<Whether support DTS or not*//**<CNcomment:DTS */
+    HI_BOOL bADVCASupport;         /**<Whether support ADVCA or not*//**<CNcomment:*/
+    HI_BOOL bMacrovisionSupport;   /**<Whether support Macrovision or not*//**<CNcomment:Macrovision */
+    HI_BOOL bHDR10Support;         /**<Whether support HDR10 or not*//**<CNcomment:HDR10 */
+    HI_BOOL bDolbyvisionSupport;   /**<Whether support DolbyVision or not*//**<CNcomment:Dolbyvision */
+    HI_U64  u64ChipID;             /**<the unique 64 bits chipid*//**<CNcomment:64ID */
+    HI_U32  u32ChipID;             /**<the unique 32 bits chipid since 98mv200*//**<CNcomment:32ID98mv200*/
+}HI_SYS_CHIP_ATTR_S;
+
+/** Maximum bytes of a buffer name */
+#define MAX_BUFFER_NAME_SIZE 16
+
+/**Structure of an MMZ buffer*/
+typedef struct hiMMZ_BUF_S
+{
+    HI_CHAR bufname[MAX_BUFFER_NAME_SIZE];  /**<Strings of an MMZ buffer name*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  phyaddr;                /**<Physical address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U8  *kernel_viraddr;         /**<Kernel-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U8  *user_viraddr;           /**<User-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  bufsize;                /**<Size of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  overflow_threshold;     /**<Overflow threshold of an MMZ buffer, in percentage. For example, the value 100 indicates 100%.*/ /**<CNcomment:  MMZ buffer: 100 indicates 100%.*/
+    HI_U32  underflow_threshold;    /**<Underflow threshold of an MMZ buffer, in percentage. For example, the value 0 indicates 0%.*/ /**<CNcomment:  MMZ buffer: 0 indicates 0%.*/
+}HI_MMZ_BUF_S;
+
+typedef struct hiRECT_S
+{
+    HI_S32 s32X;
+    HI_S32 s32Y;
+    HI_S32 s32Width;
+    HI_S32 s32Height;
+} HI_RECT_S;
+
+typedef enum hiLAYER_ZORDER_E
+{
+    HI_LAYER_ZORDER_MOVETOP = 0,  /**<Move to the top*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEUP,       /**<Move up*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEBOTTOM,   /**<Move to the bottom*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEDOWN,     /**<Move down*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_BUTT
+} HI_LAYER_ZORDER_E;
+
+/** Defines user mode proc show buffer */
+/**CNcomment: PROC buffer */
+typedef struct hiPROC_SHOW_BUFFER_S
+{
+    HI_U8* pu8Buf;                  /**<Buffer address*/  /**<CNcomment: Buffer */
+    HI_U32 u32Size;                 /**<Buffer size*/     /**<CNcomment: Buffer */
+    HI_U32 u32Offset;               /**<Offset*/          /**<CNcomment:  */
+}HI_PROC_SHOW_BUFFER_S;
+
+/** Proc show function */
+/**CNcomment: Proc */
+typedef HI_S32 (* HI_PROC_SHOW_FN)(HI_PROC_SHOW_BUFFER_S * pstBuf, HI_VOID *pPrivData);
+
+/** Proc command function */
+/**CNcomment: Proc */
+typedef HI_S32 (* HI_PROC_CMD_FN)(HI_PROC_SHOW_BUFFER_S * pstBuf, HI_U32 u32Argc, HI_U8 *pu8Argv[], HI_VOID *pPrivData);
+
+/** Defines user mode proc entry */
+/**CNcomment: PROC */
+typedef struct hiPROC_ENTRY_S
+{
+    HI_CHAR *pszEntryName;          /**<Entry name*/            /**<CNcomment:  */
+    HI_CHAR *pszDirectory;          /**<Directory name. If null, the entry will be added to /proc/hisi directory*/
+                                    /**<CNcomment: /proc/hisi */
+    HI_PROC_SHOW_FN pfnShowProc;    /**<Proc show function*/    /**<CNcomment: Proc */
+    HI_PROC_CMD_FN pfnCmdProc;      /**<Proc command function*/ /**<CNcomment: Proc */
+    HI_VOID *pPrivData;             /**<Private data*/          /**<CNcomment: Buffer */
+}HI_PROC_ENTRY_S;
+
+/** Defines DDR configuration type struct */
+/**CNcomment: DDR  */
+typedef struct hiSYS_MEM_CONFIG_S
+{
+    HI_U32 u32TotalSize;    /** Total memory size(MB) */      /**<CNcomment: (MB)*/
+    HI_U32 u32MMZSize;      /**MMZ memory size(MB) */       /** <CNcomment: MMZ(MB)*/
+}HI_SYS_MEM_CONFIG_S;
+
+#ifndef __KERNEL__
+#include <time.h>
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      COMMON */
+/** @{ */  /** <!-- [COMMON] */
+
+/**
+@brief Initializes the system. CNcomment:  CNend
+@attention \n
+You must call this API to initialize the system before using the APIs of all modules.
+Though you can call other APIs successfully before calling this API, the subsequent operations may fail.\n
+CNcomment: \n
+ CNend
+@param N/A CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_Init(HI_VOID);
+
+/**
+@brief Deinitializes the system. CNcomment:  CNend
+@attention \n
+If all modules are not used, you need to call this API to deinitialize the system.\n
+CNcomment:  CNend
+@param N/A CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_DeInit(HI_VOID);
+
+
+/**
+@brief Obtains the compiled time of a version. CNcomment:  CNend
+@attention \n
+The compiled time is the time during which the common module is made again.
+CNcomment: commonmake CNend
+@param[out] pstTime Pointer to the compiled time of a version (output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetBuildTime(struct tm * pstTime);
+
+
+/**
+@brief Obtains the version number. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] pstVersion Pointer to the version number (output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetVersion(HI_SYS_VERSION_S *pstVersion);
+
+
+/**
+@brief Obtains the package type. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] penPackageType Pointer to the package type (output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetChipPackageType(HI_CHIP_PACKAGE_TYPE_E *penPackageType);
+
+
+/**
+@brief Obtains the chip support attributes. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] enChipCap Indicate which chip capability. CNcomment:  CNend
+@param[out] pbSupport Pointer to the chip whether support the attributes(output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetChipCapability(HI_CHIP_CAP_E enChipCap, HI_BOOL *pbSupport);
+
+/**
+@brief Obtains the chip attributes. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] pstChipAttr Pointer to the chip attributes(output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetChipAttr(HI_SYS_CHIP_ATTR_S *pstChipAttr);
+
+/**
+@brief CRC32 function. CNcomment: CRC32 CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pu8Src Pointer to the source buffer. CNcomment: buffer CNend
+@param[in] u32SrcLen length of the source buffer. CNcomment: buffer CNend
+@param[out] pu32Dst Pointer to the out value. CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_CRC32(HI_U8 *pu8Src, HI_U32 u32SrcLen, HI_U32 *pu32Dst);
+
+/**
+@brief Obtains the chip attributes. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] pstConfig Pointer to address for memory configuration(output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetMemConfig(HI_SYS_MEM_CONFIG_S *pstConfig);
+
+/**
+@brief Performs global system configuration. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pstSysConf Pointer to the address for system configuration CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_SetConf(const HI_SYS_CONF_S *pstSysConf);
+
+/**
+@brief Obtains global system configuration. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] pstSysConf Pointer to the system configuration (output). CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetConf(HI_SYS_CONF_S *pstSysConf);
+
+/**
+@brief Sets the debugging information level of a module. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] enModId Debugging ID of a module CNcomment: ID CNend
+@param[in] enLogLevel Debugging information level of a module CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+*/
+HI_S32 HI_SYS_SetLogLevel(HI_MOD_ID_E enModId,  HI_LOG_LEVEL_E enLogLevel);
+
+/**
+@brief Sets the debugging information file path for U-disk. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in]  pszLogPath Debugging information file path. CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+*/
+HI_S32 HI_SYS_SetLogPath(const HI_CHAR* pszLogPath);
+
+/**
+@brief Sets the debugging files(may be stream, YUV data, image...) save path. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in]  pszPath Debugging files path. CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+*/
+HI_S32 HI_SYS_SetStorePath(const HI_CHAR* pszPath);
+
+/**
+@brief Writes to a register or a memory. CNcomment:   CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32RegAddr Physical address of a register or a memory CNcomment:  CNend
+@param[in] u32Value Value of a register CNcomment:   CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_WriteRegister(HI_U32 u32RegAddr, HI_U32 u32Value);
+
+/**
+@brief Reads a register or a memory. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32RegAddr Physical address of a register or a memory CNcomment:  CNend
+@param[out] pu32Value Pointer to the register value (output) CNcomment:   CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_ReadRegister(HI_U32 u32RegAddr, HI_U32 *pu32Value);
+
+/**
+@brief Map registers address. CNcomment:   CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32RegAddr The start physical address of registers. CNcomment:  CNend
+@param[in] u32Length  Length of the registers want to map CNcomment:    CNend
+@param[out] pVirAddr  Virtual address CNcomment:    CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_MapRegister(HI_U32 u32RegAddr, HI_U32 u32Length, HI_VOID *pVirAddr);
+
+/**
+@brief Unmap registers address. CNcomment:   CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pVirAddr The virtual address to be unmapped CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_UnmapRegister(HI_VOID *pVirAddr);
+
+/**
+@brief Get timestamp. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[out] pu32TimeMs Pointer to the timestamp value (output) CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_SYS_GetTimeStampMs(HI_U32 *pu32TimeMs);
+
+/**
+@brief Applies for a media memory zone (MMZ) and maps the user-state address.
+CNcomment:  mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in/out] pstBuf Structure of the buffer information. Bufname and bufsize are inputs, and the physical address and user-state virtual address are outputs.
+                    CNcomment: bufferbufnamebufsize, CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Malloc(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief Unmaps the user-state address and releases the MMZ. CNcomment: mmz CNend
+@attention \n
+Ensure that the lengths of the transferred physical address and user-state virtual address are correct.
+CNcomment:  CNend
+@param[in] pstBuf Structure of the buffer information CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Free(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief pplies for an MMZ with a specified name and obtains its physical address. CNcomment: mmzmmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32Size Buffer size CNcomment: buffer CNend
+@param[in] u32Align Alignment mode CNcomment:  CNend
+@param[in] ps8MMZName Name of an MMZ in the buffer. If the MMZ name is set to NULL, an MMZ is anonymously applied for. CNcomment: bufferNULL CNend
+@param[in] ps8BufName Buffer name CNcomment: buffer CNend
+@retval ::NULL The application fails. CNcomment:  CNend
+@retval Physical address CNcomment:  CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID *HI_MMZ_New(HI_U32 u32Size , HI_U32 u32Align, HI_CHAR *ps8MMZName, HI_CHAR *ps8BufName);
+
+
+/**
+@brief Releases an MMZ based on its physical address. CNcomment: mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Delete(HI_U32 u32PhysAddr);
+
+/**
+@brief Maps the physical address of an MMZ applied for to a user-state virtual address. You can determine whether to cache the address.
+CNcomment: mmzcached CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@param[in] u32Cached Whether to cache the address. 0: no; 1: yes CNcomment: cache01 CNend
+@retval ::NULL The application fails. CNcomment:  CNend
+@retval User-state virtual address CNcomment:  CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID *HI_MMZ_Map(HI_U32 u32PhysAddr, HI_U32 u32Cached);
+
+/**
+@brief Unmaps the user-state address of an MMZ. CNcomment: mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Unmap(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Flushes D-cache to the cached MMZ. CNcomment: cachedMMZDcache CNend
+@attention \n
+If the value 0 is transferred, all D-caches are refreshed; otherwise, only the transferred memory is refreshed.
+CNcomment: 0Dcache CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Flush(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Maps a physical address to a user-state virtual address. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhyAddr Physical address of a buffer CNcomment: buffer CNend
+@param[in] u32Size Buffer size CNcomment: buffer CNend
+@retval ::NULL The application fails. CNcomment:  CNend
+@retval User-state virtual address CNcomment:  CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID *HI_MEM_Map(HI_U32 u32PhyAddr, HI_U32 u32Size);
+
+
+/**
+@brief Unmaps a user-state address. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pAddrMapped User-state virtual address of a buffer. CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MEM_Unmap(HI_VOID *pAddrMapped);
+
+/**
+@brief Obtains the physical address and size based on the virtual address. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pVir User-state virtual address CNcomment:  CNend
+@param[out] pu32Phyaddr Physical address  CNcomment:  CNend
+@param[out] pu32Size Size CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_GetPhyaddr(HI_VOID * pVir, HI_U32 *pu32Phyaddr, HI_U32 *pu32Size);
+
+/**
+@brief Register one module to manager. CNcomment: CNend
+@attention Before manager someone module, calling this interface. CNcomment: CNend
+@param[in] pszModuleName The module name CNcomment: CNend
+@param[in] u32ModuleID   The module ID. CNcomment:ID CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_Register(HI_U32 u32ModuleID, const HI_CHAR * pszModuleName);
+
+/**
+@brief Register one moudle by name. CNcomment:ID CNend
+@attention Before manager someone module, calling this interface. CNcomment: CNend
+@param[in] pszModuleName The module name CNcomment: CNend
+@param[out] pu32ModuleID The module id allocated by system. CNcomment:ID CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_RegisterByName(const HI_CHAR * pszModuleName, HI_U32* pu32ModuleID);
+
+/**
+@brief UnRegister one module to trace. CNcomment: CNend
+@attention Before stopping to manage someone module, calling this interface. CNcomment: CNend
+@param[in] u32ModuleID The module ID. CNcomment:ID CNend
+@param[out] None CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_UnRegister(HI_U32 u32ModuleID);
+
+/**
+@brief User mode proc cretea directory. CNcomment:proc CNend
+@attention You need register module before calling this API. Only support create one level directory. CNcomment: CNend
+@param[in] pszName The directory name. CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_PROC_AddDir(const HI_CHAR *pszName);
+
+/**
+@brief User mode proc remove directory. CNcomment:proc CNend
+@attention It will return fail if there are entries in the directory. CNcomment:, CNend
+@param[in] pszName The directory name. CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_PROC_RemoveDir(const HI_CHAR *pszName);
+
+/**
+@brief User mode proc add entry. CNcomment:proc CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32ModuleID Module ID. CNcomment:ID CNend
+@param[in] pstEntry Parameter of entry. CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_PROC_AddEntry(HI_U32 u32ModuleID, const HI_PROC_ENTRY_S* pstEntry);
+
+/**
+@brief User mode proc remove entry. CNcomment:proc CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32ModuleID Module ID. CNcomment:ID CNend
+@param[in] pstEntry Parameter of entry. CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_PROC_RemoveEntry(HI_U32 u32ModuleID, const HI_PROC_ENTRY_S* pstEntry);
+
+/**
+@brief User mode proc print function. CNcomment:proc CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pstBuf Output buffer parameter. CNcomment:buffer CNend
+@param[in] pFmt   Format parameter. CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_PROC_Printf(HI_PROC_SHOW_BUFFER_S *pstBuf, const HI_CHAR *pFmt, ...);
+
+/**
+@brief malloc the pointed size from system heap. CNcomment: CNend
+@attention None CNcomment: CNend
+@param[in] u32ModuleID The module ID, who need to request memory. CNcomment:ID CNend
+@param[in] u32Size The size of requesting. CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::Valid memory address Success CNcomment: CNend
+@retval ::NULL Failure CNcomment:NULL CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_VOID* HI_MEM_Malloc(HI_U32 u32ModuleID, HI_U32 u32Size);
+
+
+/**
+@brief Free the requsted memory by hi_malloc. CNcomment: CNend
+@attention when stopping to use the memory, calling this interface. CNcomment: CNend
+@param[in] u32ModuleID The module ID, who need to free memory. CNcomment:ID CNend
+@param[in] pMemAddr The memory address to free CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::None CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_VOID HI_MEM_Free(HI_U32 u32ModuleID, HI_VOID* pMemAddr);
+
+/**
+@brief Calloc memory, with u32MemBlock blocks and u32Size size per. CNcomment: CNend
+@attention None CNcomment: CNend
+@param[in] u32ModuleID The module id, who need to calloc memory. CNcomment:ID CNend
+@param[in] u32MemBlock The requesting block number. CNcomment: CNend
+@param[in] u32Size The requesting size per block. CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::Valid memory address Success CNcomment: CNend
+@retval ::NULL Failure CNcomment:NULL CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID* HI_MEM_Calloc(HI_U32 u32ModuleID, HI_U32 u32MemBlock, HI_U32 u32Size);
+
+
+/** @} */ /** <!-- ==== API declaration end ==== */
+
+#endif /* endif __KERNEL__ */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_COMMON_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_debug.h unlib/xbmc/linux/hisi/hi_debug.h
--- git/xbmc/linux/hisi/hi_debug.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_debug.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,237 @@
+/******************************************************************************
+Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_debug.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2005/4/23
+Last Modified :
+Description   : Common debugging macro definition
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_DEBUG_H__
+#define __HI_DEBUG_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_type.h"
+#include "hi_module.h"
+
+#if defined(HI_LOG_SUPPORT) && (0 == HI_LOG_SUPPORT)
+#undef HI_DEBUG
+
+#define HI_PANIC(fmt...)  do{\
+}while(0)
+
+#define HI_PRINT(fmt...) do{\
+}while(0)
+#else
+#define HI_DEBUG
+
+#ifdef __OS_LINUX__
+#ifdef __KERNEL__
+    #define HI_PRINT printk
+#else
+#include <stdio.h>
+    #define HI_PRINT printf
+#endif /* end of __KERNEL__ */
+#else  /* __OS_ECOS__ */
+#define HI_PRINT printf
+#endif /* end of __OS_LINUX__ */
+
+#ifdef __KERNEL__
+    #define HI_PANIC printk
+#else
+    #define HI_PANIC printf
+#endif
+
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup     HI_DEBUG */
+/** @{ */  /** <!-- [HI_DEBUG] */
+
+
+/**Default level of the output debugging information*/
+/**CNcomment: */
+#define HI_LOG_LEVEL_DEFAULT HI_LOG_LEVEL_ERROR
+
+/**Level of the output debugging information*/
+/**CNcomment: */
+typedef enum hiLOG_LEVEL_E
+{
+    HI_LOG_LEVEL_FATAL   = 0,     /**<Fatal error. It indicates that a critical problem occurs in the system. Therefore, you must pay attention to it.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_ERROR   = 1,     /**<Major error. It indicates that a major problem occurs in the system and the system cannot run.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_WARNING = 2,     /**<Warning. It indicates that a minor problem occurs in the system, but the system still can run properly.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_INFO    = 3,     /**<Message. It is used to prompt users. Users can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_DBG     = 4,     /**<Debug. It is used to prompt developers. Developers can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: ,  */
+
+    HI_LOG_LEVEL_BUTT
+} HI_LOG_LEVEL_E;
+
+/** @} */
+
+/**Just only for fatal level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_FATAL    (0)
+/**Just only for error level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_ERROR    (1)
+/**Just only for warning level print. */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_WARN     (2)
+/**Just only for info level print.    */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_INFO     (3)
+/**Just only for debug level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_DBG      (4)
+
+#ifndef HI_LOG_LEVEL
+#define HI_LOG_LEVEL         (HI_TRACE_LEVEL_INFO)
+#endif
+
+
+/**Just only debug output,MUST BE NOT calling it. */
+/**CNcomment:  */
+extern HI_VOID HI_LogOut(HI_U32 u32Level, HI_MOD_ID_E enModId,
+            HI_U8 *pFuncName, HI_U32 u32LineNum, const char *format, ...);
+
+#ifdef HI_DEBUG
+
+#define HI_TRACE(level, module_id, fmt...)                      \
+    do{                                                         \
+        HI_LogOut(level, module_id, (HI_U8*)__FUNCTION__,__LINE__,fmt);  \
+    }while(0)
+
+#define HI_ASSERT(expr)                                     \
+    do{                                                     \
+        if (!(expr)) {                                      \
+            HI_PANIC("\nASSERT failed at:\n  >File name: %s\n  >Function : %s\n  >Line No. : %d\n  >Condition: %s\n", \
+                __FILE__,__FUNCTION__, __LINE__, #expr);    \
+        }                                                   \
+    }while(0)
+
+
+#define HI_ASSERT_RET(expr)                                     \
+    do{                                                         \
+        if (!(expr)) {                                          \
+            HI_PRINT("\n<%s %d>: ASSERT Failure{" #expr "}\n",  \
+                          __FUNCTION__, __LINE__);              \
+            return HI_FAILURE;                                  \
+        }                                                       \
+    }while(0)
+
+#define HI_DEBUG_LOG(fmt...) \
+            HI_TRACE(HI_LOG_LEVEL_INFO, HI_ID_SYS, fmt)
+
+
+/**Supported for debug output to serial/network/u-disk. */
+/**CNcomment: U */
+/**Just only reserve the fatal level output. */
+/**CNcomment:  */
+#if (HI_LOG_LEVEL == HI_TRACE_LEVEL_FATAL)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+/**Just only reserve the fatal/error level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_ERROR)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+/**Just only reserve the fatal/error/warning level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_WARN)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+/**Just only reserve the fatal/error/warning/info level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_INFO)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#else
+/**Reserve all the levels output. */
+/**CNcomment:  */
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_DBG,      module_id, fmt)
+#endif
+
+#else
+#define HI_FATAL_PRINT(module_id, fmt...)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE(level, module_id, fmt...)
+#define HI_ASSERT(expr)
+#define HI_ASSERT_RET(expr)
+#define HI_DEBUG_LOG(fmt...)
+#endif /* endif HI_DEBUG */
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define MKSTR(exp) # exp
+#define MKMARCOTOSTR(exp) MKSTR(exp)
+#define VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "] Build Time: [" __DATE__ ", " __TIME__ "]")
+#define USER_VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "]")
+
+/**Initialize a user module.*/
+/**CNcomment:  */
+#define HI_MODULE_DECLARE(MODULE_NAME)	\
+	static HI_U32 g_u32ModuleId = HI_INVALID_MODULE_ID;	\
+	static HI_S32 __attribute__((constructor(200))) init_module_id() \
+	{	 \
+		return HI_MODULE_RegisterByName(MODULE_NAME, &g_u32ModuleId); \
+	} \
+    static HI_S32 __attribute__((destructor(200))) deinit_module_id() \
+    { \
+        return HI_MODULE_UnRegister(g_u32ModuleId); \
+    }
+
+/**Defines a user module ID.*/
+/**CNcomment: ID */
+#define MODULE_ID (g_u32ModuleId)
+
+/**Defines the command of the user module different level log print.*/
+/**CNcomment:  */
+#define HI_MODULE_FATAL(pszFormat...)  HI_FATAL_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_ERROR(pszFormat...)  HI_ERR_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_WARN(pszFormat...)   HI_WARN_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_DEBUG(pszFormat...)  HI_DBG_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_INFO(pszFormat...)   HI_INFO_PRINT(MODULE_ID,pszFormat)
+
+/**Defines the memory allocate and free command used by user module.*/
+/**CNcomment:  */
+#define HI_MODULE_MALLOC(u32Size)               HI_MEM_Malloc(MODULE_ID, u32Size)
+#define HI_MODULE_FREE(pMemAddr)                HI_MEM_Free(MODULE_ID, pMemAddr)
+#define HI_MODULE_CALLOC(u32MemBlock, u32Size)  HI_MEM_Calloc(MODULE_ID, u32MemBlock, u32Size)
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_DEBUG_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_error_mpi.h unlib/xbmc/linux/hisi/hi_error_mpi.h
--- git/xbmc/linux/hisi/hi_error_mpi.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_error_mpi.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,822 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_error_mpi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2008/04/24
+  Description   : error code of MPI
+  History       :
+  1.Date        : 2008/04/24
+    Author      :
+    Modification: Created file
+
+******************************************************************************/
+/**
+\file
+\brief Describes the information about common error codes. CNcomment: 
+*/
+/* add include here */
+#ifndef __HI_UNF_MPI_ERRORCODE_H__
+#define __HI_UNF_MPI_ERRORCODE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"
+{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      MSP_ERRCODE */
+/** @{ */  /** <!-- MSP_ERRCODE */
+
+#define HI_ERR_DISP_DEV_NOT_EXIST           (HI_S32)(0x80100001)
+#define HI_ERR_DISP_NOT_DEV_FILE            (HI_S32)(0x80100002)
+#define HI_ERR_DISP_DEV_OPEN_ERR            (HI_S32)(0x80100003)
+#define HI_ERR_DISP_DEV_CLOSE_ERR           (HI_S32)(0x80100004)
+#define HI_ERR_DISP_NULL_PTR                (HI_S32)(0x80100005)
+#define HI_ERR_DISP_NO_INIT                 (HI_S32)(0x80100006)
+#define HI_ERR_DISP_INVALID_PARA            (HI_S32)(0x80100007)
+#define HI_ERR_DISP_CREATE_ERR              (HI_S32)(0x80100008)
+#define HI_ERR_DISP_DESTROY_ERR             (HI_S32)(0x80100009)
+#define HI_ERR_DISP_NOT_EXIST               (HI_S32)(0x8010000A)
+#define HI_ERR_DISP_INVALID_OPT             (HI_S32)(0x8010000B)
+#define HI_ERR_DISP_NOT_SUPPORT_FMT         (HI_S32)(0x8010000C)
+#define HI_ERR_DISP_NOT_OPEN                (HI_S32)(0x8010000D)
+#define HI_ERR_DISP_SRC_UNAVAILABLE         (HI_S32)(0x8010000E)
+#define HI_ERR_DISP_NOT_SUPPORT             (HI_S32)(0x8010000F)
+#define HI_ERR_DISP_MALLOC_FAILED           (HI_S32)(0x80100010)
+#define HI_ERR_DISP_UNKNOWN                 (HI_S32)(0x801000FF)
+#define HI_ERR_DISP_TIMEOUT                 (HI_S32)(0x801000F1)
+#define HI_ERR_DISP_MALLOC_MAP_ERR          (HI_S32)(0x801000F2)
+
+
+
+#define HI_ERR_VO_DEV_NOT_EXIST             (HI_S32)(0x80110001)
+#define HI_ERR_VO_NOT_DEV_FILE              (HI_S32)(0x80110002)
+#define HI_ERR_VO_DEV_OPEN_ERR              (HI_S32)(0x80110003)
+#define HI_ERR_VO_DEV_CLOSE_ERR             (HI_S32)(0x80110004)
+#define HI_ERR_VO_NULL_PTR                  (HI_S32)(0x80110005)
+#define HI_ERR_VO_NO_INIT                   (HI_S32)(0x80110006)
+#define HI_ERR_VO_INVALID_PARA              (HI_S32)(0x80110007)
+#define HI_ERR_VO_CREATE_ERR                (HI_S32)(0x80110008)
+#define HI_ERR_VO_DESTROY_ERR               (HI_S32)(0x80110009)
+#define HI_ERR_VO_NOT_EXIST                 (HI_S32)(0x80110010)
+#define HI_ERR_VO_INVALID_OPT               (HI_S32)(0x80110030)
+#define HI_ERR_VO_WIN_NOT_EXIST             (HI_S32)(0x80110040)
+#define HI_ERR_VO_WIN_NOT_ENABLE            (HI_S32)(0x80110041)
+#define HI_ERR_VO_WIN_UNSUPPORT             (HI_S32)(0x80110042)
+#define HI_ERR_VO_TIMEOUT                   (HI_S32)(0x80110043)
+#define HI_ERR_VO_OPERATION_DENIED          (HI_S32)(0x80110044)
+#define HI_ERR_VO_SLAVE_WIN_LOST            (HI_S32)(0x80110045)
+#define HI_ERR_VO_FRAME_INFO_ERROR          (HI_S32)(0x80110046)
+#define HI_ERR_VO_FRAME_RELEASE_FAILED      (HI_S32)(0x80110047)
+#define HI_ERR_VO_NO_FRAME_TO_RELEASE       (HI_S32)(0x80110048)
+#define HI_ERR_VO_ADD_PROC_ERR              (HI_S32)(0x80110049)
+#define HI_ERR_VO_MALLOC_FAILED             (HI_S32)(0x80110050)
+#define HI_ERR_VO_DEPEND_DEVICE_NOT_READY   (HI_S32)(0x80110051)
+#define HI_ERR_VO_BUFQUE_FULL               (HI_S32)(0x80110052)
+#define HI_ERR_VO_BUFQUE_EMPTY              (HI_S32)(0x80110053)
+#define HI_ERR_VO_NO_SOURCE                 (HI_S32)(0x80110054)
+
+
+#define HI_ERR_VDEC_NOT_OPEN                (HI_S32)(0x80120001)
+#define HI_ERR_VDEC_INVALID_PARA            (HI_S32)(0x80120002)
+#define HI_ERR_VDEC_NULL_PTR                (HI_S32)(0x80120003)
+#define HI_ERR_VDEC_NOT_SUPPORT             (HI_S32)(0x80120004)
+#define HI_ERR_VDEC_TIMEOUT                 (HI_S32)(0x80120005)
+#define HI_ERR_VDEC_MALLOC_FAILED           (HI_S32)(0x80120044)
+#define HI_ERR_VDEC_CREATECH_FAILED         (HI_S32)(0x80120047)
+#define HI_ERR_VDEC_DESTROYCH_FAILED        (HI_S32)(0x80120048)
+#define HI_ERR_VDEC_INVALID_CHANID          (HI_S32)(0x80120049)
+#define HI_ERR_VDEC_RESETCH_FAILED          (HI_S32)(0x80120050)
+#define HI_ERR_VDEC_SETATTR_FAILED          (HI_S32)(0x80120051)
+#define HI_ERR_VDEC_GETATTR_FAILED          (HI_S32)(0x80120052)
+#define HI_ERR_VDEC_SENDSTREAM_FAILED       (HI_S32)(0x80120053)
+#define HI_ERR_VDEC_RECEIVE_FAILED          (HI_S32)(0x80120054)
+#define HI_ERR_VDEC_DISCARD_PRIDATA         (HI_S32)(0x80120055)
+#define HI_ERR_VDEC_RELEASEFRAME_FAILED     (HI_S32)(0x80120056)
+#define HI_ERR_VDEC_RELEASEPRI_FAILED       (HI_S32)(0x80120057)
+#define HI_ERR_VDEC_NOT_INIT                (HI_S32)(0x80120059)
+#define HI_ERR_VDEC_USERCOPY_ERR            (HI_S32)(0x8012005A)
+#define HI_ERR_VDEC_LIST_EMPTY              (HI_S32)(0x8012005B)
+#define HI_ERR_VDEC_INVALID_STATE           (HI_S32)(0x8012005C)
+#define HI_ERR_VDEC_NOT_ENABLE              (HI_S32)(0x80120060)
+#define HI_ERR_VDEC_BUFFER_NOT_ATTACH       (HI_S32)(0x80120061)
+#define HI_ERR_VDEC_BUFFER_REQUIRE_INVALID  (HI_S32)(0x80120062)
+#define HI_ERR_VDEC_BUFFER_ATTACHED         (HI_S32)(0x80120063)
+#define HI_ERR_VDEC_BUFFER_FULL             (HI_S32)(0x80120064)
+
+#define HI_ERR_AO_NOT_INIT                  (HI_S32)(0x80130001)
+#define HI_ERR_AO_INVALID_PARA              (HI_S32)(0x80130002)
+#define HI_ERR_AO_NULL_PTR                  (HI_S32)(0x80130003)
+#define HI_ERR_AO_INVALID_ID                (HI_S32)(0x80130004)
+#define HI_ERR_AO_USED                      (HI_S32)(0x80130005)
+#define HI_ERR_AO_NOTSUPPORT                (HI_S32)(0x80130006)
+#define HI_ERR_AO_USERCOPY_ERR              (HI_S32)(0x80130007)
+#define HI_ERR_AO_SOUND_NOT_OPEN            (HI_S32)(0x80130008)
+#define HI_ERR_AO_DEV_NOT_OPEN              (HI_S32)(0x80130041)
+#define HI_ERR_AO_CREATE_FAIL               (HI_S32)(0x80130042)
+#define HI_ERR_AO_OUT_BUF_FULL              (HI_S32)(0x80130046)
+#define HI_ERR_AO_INVALID_OUTFRAME          (HI_S32)(0x80130047)
+#define HI_ERR_AO_DATASIZE_EXCEED           (HI_S32)(0x80130048)
+#define HI_ERR_AO_INVALID_INFRAME           (HI_S32)(0x80130049)
+#define HI_ERR_AO_INBUF_EMPTY               (HI_S32)(0x8013004a)
+#define HI_ERR_AO_INVALID_PORT              (HI_S32)(0x8013004c)
+#define HI_ERR_AO_SENDMUTE                  (HI_S32)(0x8013004d)
+#define HI_ERR_AO_VIRTUALBUF_EMPTY          (HI_S32)(0x8013004e)
+#define HI_ERR_AO_PAUSE_STATE               (HI_S32)(0x8013004f)
+#define HI_ERR_AO_OUTPORT_NOT_ATTATCH       (HI_S32)(0x80130050)
+#define HI_ERR_AO_CAST_TIMEOUT              (HI_S32)(0x80130051)
+#define HI_ERR_AO_MALLOC_FAILED             (HI_S32)(0x80130052)
+
+#define HI_ERR_ADEC_DEV_NOT_OPEN            (HI_S32)(0x80140001)
+#define HI_ERR_ADEC_INVALID_PARA            (HI_S32)(0x80140002)
+#define HI_ERR_ADEC_NULL_PTR                (HI_S32)(0x80140003)
+#define HI_ERR_ADEC_IN_BUF_FULL             (HI_S32)(0x80140004)
+#define HI_ERR_ADEC_OUT_BUF_EMPTY           (HI_S32)(0x80140005)
+#define HI_ERR_ADEC_OUT_VOLUME              (HI_S32)(0x80140006)
+#define HI_ERR_ADEC_IN_PTSBUF_FULL          (HI_S32)(0x80140007)
+
+#define HI_ERR_DMX_NOT_INIT                 (HI_S32)(0x80150001)
+#define HI_ERR_DMX_INVALID_PARA             (HI_S32)(0x80150002)
+#define HI_ERR_DMX_NULL_PTR                 (HI_S32)(0x80150003)
+#define HI_ERR_DMX_NOT_SUPPORT              (HI_S32)(0x80150004)
+#define HI_ERR_DMX_TIMEOUT                  (HI_S32)(0x80150005)
+#define HI_ERR_DMX_ALLOC_MEM_FAILED         (HI_S32)(0x80150006)
+#define HI_ERR_DMX_BUSY                     (HI_S32)(0x80150007)
+#define HI_ERR_DMX_NOATTACH_PORT            (HI_S32)(0x80150008)
+#define HI_ERR_DMX_ATTACHED_PORT            (HI_S32)(0x80150009)
+#define HI_ERR_DMX_RECREAT_TSBUFFER         (HI_S32)(0x8015000a)
+#define HI_ERR_DMX_UNMATCH_CHAN             (HI_S32)(0x8015000b)
+#define HI_ERR_DMX_NOFREE_CHAN              (HI_S32)(0x8015000c)
+#define HI_ERR_DMX_OPENING_CHAN             (HI_S32)(0x8015000d)
+#define HI_ERR_DMX_NOT_OPEN_CHAN            (HI_S32)(0x8015000e)
+#define HI_ERR_DMX_ATTACHED_FILTER          (HI_S32)(0x8015000f)
+#define HI_ERR_DMX_NOATTACH_FILTER          (HI_S32)(0x80150010)
+#define HI_ERR_DMX_UNMATCH_FILTER           (HI_S32)(0x80150011)
+#define HI_ERR_DMX_NOFREE_FILTER            (HI_S32)(0x80150012)
+#define HI_ERR_DMX_NOATTACH_KEY             (HI_S32)(0x80150013)
+#define HI_ERR_DMX_UNMATCH_KEY              (HI_S32)(0x80150014)
+#define HI_ERR_DMX_NOFREE_KEY               (HI_S32)(0x80150015)
+#define HI_ERR_DMX_ATTACHED_KEY             (HI_S32)(0x80150016)
+#define HI_ERR_DMX_NOAVAILABLE_BUF          (HI_S32)(0x80150017)
+#define HI_ERR_DMX_NOAVAILABLE_DATA         (HI_S32)(0x80150018)
+#define HI_ERR_DMX_REACQUIRE_BUF            (HI_S32)(0x80150019)
+#define HI_ERR_DMX_OCCUPIED_PID             (HI_S32)(0x80150020)
+#define HI_ERR_DMX_MMAP_FAILED              (HI_S32)(0x80150021)
+#define HI_ERR_DMX_MUNMAP_FAILED            (HI_S32)(0x80150022)
+#define HI_ERR_DMX_EMPTY_BUFFER             (HI_S32)(0x80150023)
+#define HI_ERR_DMX_OVERFLOW_BUFFER          (HI_S32)(0x80150024)
+#define HI_ERR_DMX_NOT_START_REC_CHAN       (HI_S32)(0x80150030)
+#define HI_ERR_DMX_STARTING_REC_CHAN        (HI_S32)(0x80150031)
+#define HI_ERR_DMX_NOAVAILABLE_EXCLUDEPID   (HI_S32)(0x80150032)
+#define HI_ERR_DMX_NOAVAILABLE_TAG_PORT     (HI_S32)(0x80150033)
+#define HI_ERR_NOT_SUPPORT_TAGDEAL          (HI_S32)(0x80150034)
+#define HI_ERR_DMX_REC_BUFNOTMATCH          (HI_S32)(0x80150035)
+#define HI_ERR_DMX_INVALID_REC_CHAN         (HI_S32)(0x80150036)
+#define HI_ERR_DMX_BUSY_CHAN                (HI_S32)(0x80150037)
+#define HI_ERR_DMX_BUSY_FILTER              (HI_S32)(0x80150038)
+#define HI_ERR_DMX_BUSY_KEY                 (HI_S32)(0x80150039)
+#define HI_ERR_DMX_BUSY_REC                 (HI_S32)(0x8015003A)
+
+#define HI_ERR_TSIO_NOT_INIT                (HI_S32)(0x80160001)
+#define HI_ERR_TSIO_INVALID_PARA            (HI_S32)(0x80160002)
+#define HI_ERR_TSIO_NULL_PTR                (HI_S32)(0x80160003)
+#define HI_ERR_TSIO_NO_MEMORY               (HI_S32)(0x80160004)
+#define HI_ERR_TSIO_NO_RESOURCE             (HI_S32)(0x80160005)
+#define HI_ERR_TSIO_BUSY                    (HI_S32)(0x80160006)
+#define HI_ERR_TSIO_NOT_READY               (HI_S32)(0x80160007)
+#define HI_ERR_TSIO_NOAVAILABLE_BUF         (HI_S32)(0x80160008)
+#define HI_ERR_TSIO_NOAVAILABLE_DATA        (HI_S32)(0x80160009)
+#define HI_ERR_TSIO_INTR                    (HI_S32)(0x8016000a)
+#define HI_ERR_TSIO_TIMEOUT                 (HI_S32)(0x8016000b)
+#define HI_ERR_TSIO_NOT_SUPPORT             (HI_S32)(0x8016000c)
+#define HI_ERR_TSIO_CC_ERROR                (HI_S32)(0x8016000d)
+#define HI_ERR_TSIO_DEMUX_NOT_READY         (HI_S32)(0x8016000e)
+#define HI_ERR_TSIO_STALED                  (HI_S32)(0x8016000f)
+
+#define HI_ERR_VI_NO_INIT                   (HI_S32)(0x801A0001)
+#define HI_ERR_VI_INVALID_PARA              (HI_S32)(0x801A0002)
+#define HI_ERR_VI_NULL_PTR                  (HI_S32)(0x801A0003)
+#define HI_ERR_VI_INVALID_CHNID             (HI_S32)(0x801A0004)
+#define HI_ERR_VI_DEV_OPENED                (HI_S32)(0x801A0005)
+#define HI_ERR_VI_DEV_NOT_EXIST             (HI_S32)(0x801A0006)
+#define HI_ERR_VI_NOT_DEV_FILE              (HI_S32)(0x801A0007)
+#define HI_ERR_VI_NO_CHN_LEFT               (HI_S32)(0x801A0008)
+#define HI_ERR_VI_BUSY                      (HI_S32)(0x801A0009)
+#define HI_ERR_VI_CHN_NOT_EXIST             (HI_S32)(0x801A000A)
+#define HI_ERR_VI_CHN_INVALID_OPT           (HI_S32)(0x801A000B)
+#define HI_ERR_VI_CHN_INVALID_STAT          (HI_S32)(0x801A000C)
+#define HI_ERR_VI_CHN_INIT_BUF_ERR          (HI_S32)(0x801A000D)
+#define HI_ERR_VI_BUF_EMPTY                 (HI_S32)(0x801A000E)
+#define HI_ERR_VI_BUF_FULL                  (HI_S32)(0x801A000F)
+#define HI_ERR_VI_NOT_SUPPORT               (HI_S32)(0x801A0010)
+
+#define HI_ERR_AI_NOT_INIT                  (HI_S32)(0x801B0001)
+#define HI_ERR_AI_INVALID_PARA              (HI_S32)(0x801B0002)
+#define HI_ERR_AI_NULL_PTR                  (HI_S32)(0x801B0003)
+#define HI_ERR_AI_INVALID_ID                (HI_S32)(0x801B0004)
+#define HI_ERR_AI_DEV_OPENED                (HI_S32)(0x801B0005)
+#define HI_ERR_AI_NOTSUPPORT                (HI_S32)(0x801B0006)
+#define HI_ERR_AI_USERCOPY                  (HI_S32)(0x801B0007)
+#define HI_ERR_AI_BUFEMPTY                  (HI_S32)(0x801B0008)
+
+
+#define HI_ERR_AENC_DEV_NOT_OPEN            (HI_S32)(0x801C0001)
+#define HI_ERR_AENC_INVALID_PARA            (HI_S32)(0x801C0002)
+#define HI_ERR_AENC_NULL_PTR                (HI_S32)(0x801C0003)
+#define HI_ERR_AENC_OUT_BUF_FULL            (HI_S32)(0x801C0006)
+#define HI_ERR_AENC_INVALID_OUTFRAME        (HI_S32)(0x801C0007)
+#define HI_ERR_AENC_DATASIZE_EXCEED         (HI_S32)(0x801C0008)
+#define HI_ERR_AENC_CREATECH_FAIL           (HI_S32)(0x801C0009)
+#define HI_ERR_AENC_IN_BUF_FULL             (HI_S32)(0x801C000a)
+#define HI_ERR_AENC_CH_NOT_OPEN             (HI_S32)(0x801C000b)
+#define HI_ERR_AENC_OUT_BUF_EMPTY           (HI_S32)(0x801C000c)
+#define HI_ERR_AENC_OUT_BUF_BAD             (HI_S32)(0x801C000d)
+#define HI_ERR_AENC_IN_BUF_UNEMPTY          (HI_S32)(0x801C000e)
+#define HI_ERR_AENC_CH_NOT_SUPPORT          (HI_S32)(0x801C000f)
+
+
+#define HI_ERR_VENC_NO_INIT                 (HI_S32)(0x801D0001)
+#define HI_ERR_VENC_INVALID_PARA            (HI_S32)(0x801D0002)
+#define HI_ERR_VENC_NULL_PTR                (HI_S32)(0x801D0003)
+#define HI_ERR_VENC_INVALID_CHNID           (HI_S32)(0x801D0004)
+#define HI_ERR_VENC_DEV_OPENED              (HI_S32)(0x801D0005)
+#define HI_ERR_VENC_DEV_NOT_EXIST           (HI_S32)(0x801D0006)
+#define HI_ERR_VENC_NOT_DEV_FILE            (HI_S32)(0x801D0007)
+#define HI_ERR_VENC_CREATE_ERR              (HI_S32)(0x801D0008)
+#define HI_ERR_VENC_DESTROY_ERR             (HI_S32)(0x801D0009)
+#define HI_ERR_VENC_CHN_NOT_EXIST           (HI_S32)(0x801D000A)
+#define HI_ERR_VENC_CHN_INVALID_STAT        (HI_S32)(0x801D000B)
+#define HI_ERR_VENC_CHN_NO_ATTACH           (HI_S32)(0x801D000C)
+#define HI_ERR_VENC_BUF_EMPTY               (HI_S32)(0x801D000D)
+#define HI_ERR_VENC_CHN_RELEASE_ERR         (HI_S32)(0x801D000E)
+#define HI_ERR_VENC_NOT_SUPPORT             (HI_S32)(0x801D000F)
+
+#define HI_ERR_SIO_AI_INVALID_DEVID         (HI_S32)(0x801E0001)
+#define HI_ERR_SIO_AI_INVALID_CHNID         (HI_S32)(0x801E0002)
+#define HI_ERR_SIO_AI_ILLEGAL_PARAM         (HI_S32)(0x801E0003)
+#define HI_ERR_SIO_AI_NULL_PTR              (HI_S32)(0x801E0004)
+#define HI_ERR_SIO_AI_NOT_CONFIG            (HI_S32)(0x801E0005)
+#define HI_ERR_SIO_AI_NOT_SURPPORT          (HI_S32)(0x801E0006)
+#define HI_ERR_SIO_AI_NOT_PERM              (HI_S32)(0x801E0007)
+#define HI_ERR_SIO_AI_NOT_ENABLED           (HI_S32)(0x801E0008)
+#define HI_ERR_SIO_AI_NOMEM                 (HI_S32)(0x801E0009)
+#define HI_ERR_SIO_AI_NOBUF                 (HI_S32)(0x801E000A)
+#define HI_ERR_SIO_AI_BUF_EMPTY             (HI_S32)(0x801E000B)
+#define HI_ERR_SIO_AI_BUF_FULL              (HI_S32)(0x801E000C)
+#define HI_ERR_SIO_AI_SYS_NOTREADY          (HI_S32)(0x801E000D)
+#define HI_ERR_SIO_AI_BUSY                  (HI_S32)(0x801E000E)
+
+#define HI_ERR_SIO_AO_INVALID_DEVID         (HI_S32)(0x801F0001)
+#define HI_ERR_SIO_AO_INVALID_CHNID         (HI_S32)(0x801F0002)
+#define HI_ERR_SIO_AO_ILLEGAL_PARAM         (HI_S32)(0x801F0003)
+#define HI_ERR_SIO_AO_NULL_PTR              (HI_S32)(0x801F0004)
+#define HI_ERR_SIO_AO_NOT_CONFIG            (HI_S32)(0x801F0005)
+#define HI_ERR_SIO_AO_NOT_SURPPORT          (HI_S32)(0x801F0006)
+#define HI_ERR_SIO_AO_NOT_PERM              (HI_S32)(0x801F0007)
+#define HI_ERR_SIO_AO_NOT_ENABLED           (HI_S32)(0x801F0008)
+#define HI_ERR_SIO_AO_NOMEM                 (HI_S32)(0x801F0009)
+#define HI_ERR_SIO_AO_NOBUF                 (HI_S32)(0x801F000A)
+#define HI_ERR_SIO_AO_BUF_EMPTY             (HI_S32)(0x801F000B)
+#define HI_ERR_SIO_AO_BUF_FULL              (HI_S32)(0x801F000C)
+#define HI_ERR_SIO_AO_SYS_NOTREADY          (HI_S32)(0x801F000D)
+#define HI_ERR_SIO_AO_BUSY                  (HI_S32)(0x801F000E)
+
+#define HI_ERR_AFLT_NOT_INIT                (HI_S32)(0x80200001)
+#define HI_ERR_AFLT_INVALID_PARA            (HI_S32)(0x80200002)
+#define HI_ERR_AFLT_NULL_PTR                (HI_S32)(0x80200003)
+#define HI_ERR_AFLT_INVALID_HANDLE          (HI_S32)(0x80200004)
+#define HI_ERR_AFLT_CHN_NOT_OPEN            (HI_S32)(0x80200005)
+#define HI_ERR_AFLT_INBUF_FULL              (HI_S32)(0x80200006)
+#define HI_ERR_AFLT_OUTBUF_EMPTY            (HI_S32)(0x80200007)
+#define HI_ERR_AFLT_BUFEMPTY                (HI_S32)(0x80200008)
+
+#define HI_ERR_HDMI_NOT_INIT                (HI_S32)(0x80210001)
+#define HI_ERR_HDMI_INVALID_PARA            (HI_S32)(0x80210002)
+#define HI_ERR_HDMI_NUL_PTR                 (HI_S32)(0x80210003)
+#define HI_ERR_HDMI_DEV_NOT_OPEN            (HI_S32)(0x80210004)
+#define HI_ERR_HDMI_DEV_NOT_CONNECT         (HI_S32)(0x80210005)
+#define HI_ERR_HDMI_READ_SINK_FAILED        (HI_S32)(0x80210006)
+#define HI_ERR_HDMI_INIT_ALREADY            (HI_S32)(0x80210007)
+#define HI_ERR_HDMI_CALLBACK_ALREADY        (HI_S32)(0x80210008)
+#define HI_ERR_HDMI_INVALID_CALLBACK        (HI_S32)(0x80210009)
+#define HI_ERR_HDMI_FEATURE_NO_USPPORT      (HI_S32)(0x8021000a)
+#define HI_ERR_HDMI_BUS_BUSY                (HI_S32)(0x8021000b)
+
+#define HI_ERR_PVR_NOT_INIT                 (HI_S32)(0x80300001)
+#define HI_ERR_PVR_INVALID_PARA             (HI_S32)(0x80300002)
+#define HI_ERR_PVR_NUL_PTR                  (HI_S32)(0x80300003)
+#define HI_ERR_PVR_CHN_NOT_INIT             (HI_S32)(0x80300004)
+#define HI_ERR_PVR_INVALID_CHNID            (HI_S32)(0x80300005)
+#define HI_ERR_PVR_NO_CHN_LEFT              (HI_S32)(0x80300006)
+#define HI_ERR_PVR_ALREADY                  (HI_S32)(0x80300007)
+#define HI_ERR_PVR_BUSY                     (HI_S32)(0x80300008)
+#define HI_ERR_PVR_NO_MEM                   (HI_S32)(0x80300009)
+#define HI_ERR_PVR_NOT_SUPPORT              (HI_S32)(0x8030000A)
+#define HI_ERR_PVR_RETRY                    (HI_S32)(0x8030000B)
+#define HI_ERR_PVR_FILE_EXIST               (HI_S32)(0x80300011)
+#define HI_ERR_PVR_FILE_NOT_EXIST           (HI_S32)(0x80300012)
+#define HI_ERR_PVR_FILE_CANT_OPEN           (HI_S32)(0x80300013)
+#define HI_ERR_PVR_FILE_CANT_CLOSE          (HI_S32)(0x80300014)
+#define HI_ERR_PVR_FILE_CANT_SEEK           (HI_S32)(0x80300015)
+#define HI_ERR_PVR_FILE_CANT_WRITE          (HI_S32)(0x80300016)
+#define HI_ERR_PVR_FILE_CANT_READ           (HI_S32)(0x80300017)
+#define HI_ERR_PVR_FILE_INVALID_FNAME       (HI_S32)(0x80300018)
+#define HI_ERR_PVR_FILE_TILL_START          (HI_S32)(0x80300019)
+#define HI_ERR_PVR_FILE_TILL_END            (HI_S32)(0x8030001A)
+#define HI_ERR_PVR_FILE_DISC_FULL           (HI_S32)(0x8030001B)
+#define HI_ERR_PVR_REC_INVALID_STATE        (HI_S32)(0x80300021)
+#define HI_ERR_PVR_REC_INVALID_DMXID        (HI_S32)(0x80300022)
+#define HI_ERR_PVR_REC_INVALID_FSIZE        (HI_S32)(0x80300023)
+#define HI_ERR_PVR_REC_INVALID_UDSIZE       (HI_S32)(0x80300024)
+#define HI_ERR_PVR_PLAY_INVALID_STATE       (HI_S32)(0x80300031)
+#define HI_ERR_PVR_PLAY_INVALID_DMXID       (HI_S32)(0x80300032)
+#define HI_ERR_PVR_PLAY_INVALID_TSBUFFER    (HI_S32)(0x80300033)
+#define HI_ERR_PVR_PLAY_INVALID_PACKETBUFFER (HI_S32)(0x80300034)
+#define HI_ERR_PVR_PLAY_INDEX_BEYOND_TS     (HI_S32)(0x80300035)
+#define HI_ERR_PVR_SEC_INIT_FAILED          (HI_S32)(0x80300036)
+#define HI_ERR_PVR_SEC_RUNTIME_ERROR        (HI_S32)(0x80300037)
+
+#define HI_ERR_PVR_INDEX_CANT_MKIDX         (HI_S32)(0x80300041)
+#define HI_ERR_PVR_INDEX_FORMAT_ERR         (HI_S32)(0x80300042)
+#define HI_ERR_PVR_INDEX_DATA_ERR           (HI_S32)(0x80300043)
+#define HI_ERR_PVR_INDEX_INVALID_ENTRY      (HI_S32)(0x80300044)
+#define HI_ERR_PVR_INTF_EVENT_INVAL         (HI_S32)(0x80300051)
+#define HI_ERR_PVR_INTF_EVENT_NOREG         (HI_S32)(0x80300052)
+#define HI_ERR_ADVCA_PVR_KEY_CHECK_FAILED   (HI_S32)(0x80300053)
+#define HI_ERR_ADVCA_PVR_CMAC_CHECK_FAILED  (HI_S32)(0x80300054)
+
+#define HI_ERR_AVPLAY_DEV_NOT_EXIST         (HI_S32)(0x80310001)
+#define HI_ERR_AVPLAY_NOT_DEV_FILE          (HI_S32)(0x80310002)
+#define HI_ERR_AVPLAY_DEV_OPEN_ERR          (HI_S32)(0x80310003)
+#define HI_ERR_AVPLAY_DEV_CLOSE_ERR         (HI_S32)(0x80310004)
+#define HI_ERR_AVPLAY_NULL_PTR              (HI_S32)(0x80310005)
+#define HI_ERR_AVPLAY_DEV_NO_INIT           (HI_S32)(0x80310006)
+#define HI_ERR_AVPLAY_INVALID_PARA          (HI_S32)(0x80310007)
+#define HI_ERR_AVPLAY_CREATE_ERR            (HI_S32)(0x80310008)
+#define HI_ERR_AVPLAY_DESTROY_ERR           (HI_S32)(0x80310009)
+#define HI_ERR_AVPLAY_INVALID_OPT           (HI_S32)(0x8031000A)
+#define HI_ERR_AVPLAY_NOT_SUPPORT           (HI_S32)(0x8031000B)
+
+#define HI_ERR_SYNC_DEV_NOT_EXIST           (HI_S32)(0x80320001)
+#define HI_ERR_SYNC_NOT_DEV_FILE            (HI_S32)(0x80320002)
+#define HI_ERR_SYNC_DEV_OPEN_ERR            (HI_S32)(0x80320003)
+#define HI_ERR_SYNC_DEV_CLOSE_ERR           (HI_S32)(0x80320004)
+#define HI_ERR_SYNC_NULL_PTR                (HI_S32)(0x80320005)
+#define HI_ERR_SYNC_DEV_NO_INIT             (HI_S32)(0x80320006)
+#define HI_ERR_SYNC_INVALID_PARA            (HI_S32)(0x80320007)
+#define HI_ERR_SYNC_CREATE_ERR              (HI_S32)(0x80320008)
+#define HI_ERR_SYNC_DESTROY_ERR             (HI_S32)(0x80320009)
+#define HI_ERR_SYNC_INVALID_OPT             (HI_S32)(0x8032000A)
+
+#define HI_ERR_MCE_DEV_NOT_EXIST            (HI_S32)(0x80330001)
+#define HI_ERR_MCE_NOT_DEVICE               (HI_S32)(0x80330002)
+#define HI_ERR_MCE_DEV_OPEN_ERR             (HI_S32)(0x80330003)
+#define HI_ERR_MCE_DEV_NOT_INIT             (HI_S32)(0x80330004)
+#define HI_ERR_MCE_PTR_NULL                 (HI_S32)(0x80330005)
+#define HI_ERR_MCE_PARAM_INVALID            (HI_S32)(0x80330006)
+#define HI_ERR_MCE_GET_MTDINFO_ERR          (HI_S32)(0x80330007)
+#define HI_ERR_MCE_MTD_OPEN                 (HI_S32)(0x80330008)
+#define HI_ERR_MCE_MTD_CLOSE                (HI_S32)(0x80330009)
+#define HI_ERR_MCE_MTD_READ                 (HI_S32)(0x80330010)
+#define HI_ERR_MCE_MTD_WRITE                (HI_S32)(0x80330011)
+#define HI_ERR_MCE_MTD_GETINFO              (HI_S32)(0x80330012)
+#define HI_ERR_MCE_MTD_ERASE                (HI_S32)(0x80330013)
+#define HI_ERR_MCE_MEM_ALLC                 (HI_S32)(0x80330014)
+#define HI_ERR_MCE_INVALID_OPT              (HI_S32)(0x80330015)
+
+#define HI_ERR_VP_PTR_NULL                  (HI_S32)(0x80340001)
+#define HI_ERR_VP_NOT_INIT                  (HI_S32)(0x80340002)
+#define HI_ERR_VP_DEV_NOT_EXIST             (HI_S32)(0x80340003)
+#define HI_ERR_VP_NOT_DEV_FILE              (HI_S32)(0x80340004)
+#define HI_ERR_VP_DEV_OPEN_ERR              (HI_S32)(0x80340005)
+#define HI_ERR_VP_INVALID_PARA              (HI_S32)(0x80340006)
+#define HI_ERR_VP_NOT_SUPPORT               (HI_S32)(0x80340007)
+#define HI_ERR_VP_INVALID_HANDLE            (HI_S32)(0x80340008)
+#define HI_ERR_VP_HANDLE_NOTEXIST           (HI_S32)(0x80340009)
+#define HI_ERR_VP_NOT_READY                 (HI_S32)(0x8034000a)
+#define HI_ERR_VP_ILLEGAL_STATE             (HI_S32)(0x8034000b)
+
+#define HI_ERR_IR_OPEN_ERR                          (HI_S32)(0x80410001)
+#define HI_ERR_IR_CLOSE_ERR                         (HI_S32)(0x80410002)
+#define HI_ERR_IR_NOT_INIT                          (HI_S32)(0x80410003)
+#define HI_ERR_IR_INVALID_PARA                      (HI_S32)(0x80410004)
+#define HI_ERR_IR_NULL_PTR                          (HI_S32)(0x80410005)
+#define HI_ERR_IR_READ_FAILED                       (HI_S32)(0x80410006)
+#define HI_ERR_IR_ENABLE_FAILED                     (HI_S32)(0x80410007)
+#define HI_ERR_IR_SET_BLOCKTIME_FAILED              (HI_S32)(0x80410008)
+#define HI_ERR_IR_SET_FETCHMETHOD_FAILED            (HI_S32)(0x80410009)
+#define HI_ERR_IR_SET_KEYUP_FAILED                  (HI_S32)(0x8041000A)
+#define HI_ERR_IR_SET_REPEAT_FAILED                 (HI_S32)(0x8041000B)
+#define HI_ERR_IR_SET_REPKEYTIMEOUT_FAILED          (HI_S32)(0x8041000C)
+#define HI_ERR_IR_RESET_FAILED                      (HI_S32)(0x8041000D)
+#define HI_ERR_IR_ENABLE_PROT_FAILED                (HI_S32)(0x8041000E)
+#define HI_ERR_IR_DISABLE_PROT_FAILED               (HI_S32)(0x8041000F)
+#define HI_ERR_IR_GET_PROTENABLE_FAILED             (HI_S32)(0x80410010)
+#define HI_ERR_IR_SETFORMAT_FAILED                  (HI_S32)(0x80410011)
+#define HI_ERR_IR_UNSUPPORT                         (HI_S32)(0x80410012)
+
+#define HI_ERR_RTC_NOT_INIT                         (HI_S32)(0x80420001)
+#define HI_ERR_RTC_REPEAT_INIT                      (HI_S32)(0x80420002)
+#define HI_ERR_RTC_INVALID_POINT                    (HI_S32)(0x80420003)
+#define HI_ERR_RTC_INVALID_PARA                     (HI_S32)(0x80420004)
+#define HI_ERR_RTC_FAILED_INIT                      (HI_S32)(0x80420005)
+#define HI_ERR_RTC_FAILED_SETTIME                   (HI_S32)(0x80420006)
+#define HI_ERR_RTC_FAILED_GETTIME                   (HI_S32)(0x80420007)
+#define HI_ERR_RTC_FAILED_ALARMENABLE               (HI_S32)(0x80420008)
+#define HI_ERR_RTC_FAILED_ALARMDISABLE              (HI_S32)(0x80420009)
+#define HI_ERR_RTC_FAILED_SETALARM                  (HI_S32)(0x8042000A)
+#define HI_ERR_RTC_FAILED_GETALARM                  (HI_S32)(0x8042000B)
+
+#define HI_ERR_WDG_NOT_INIT                         (HI_S32)(0x80430001)
+#define HI_ERR_WDG_REPEAT_INIT                      (HI_S32)(0x80430002)
+#define HI_ERR_WDG_INVALID_POINT                    (HI_S32)(0x80430003)
+#define HI_ERR_WDG_INVALID_PARA                     (HI_S32)(0x80430004)
+#define HI_ERR_WDG_FAILED_INIT                      (HI_S32)(0x80430005)
+#define HI_ERR_WDG_FAILED_SETTIMEOUT                (HI_S32)(0x80430006)
+#define HI_ERR_WDG_FAILED_ENABLE                    (HI_S32)(0x80430007)
+#define HI_ERR_WDG_FAILED_DISABLE                   (HI_S32)(0x80430008)
+#define HI_ERR_WDG_FAILED_CLEARWDG                  (HI_S32)(0x80430009)
+#define HI_ERR_WDG_FAILED_RESET                     (HI_S32)(0x8043000A)
+#define HI_ERR_WDG_FAILED_RESMODE                   (HI_S32)(0x8043000B)
+#define HI_ERR_WDG_NOT_SUPPORT                      (HI_S32)(0x8043000C)
+#define HI_ERR_WDG_FAILED_GETTIMEOUT                (HI_S32)(0x8043000D)
+#define HI_ERR_WDG_FAILED_DEINIT                    (HI_S32)(0x8043000E)
+
+#define HI_ERR_I2C_OPEN_ERR                         (HI_S32)(0x80440001)
+#define HI_ERR_I2C_CLOSE_ERR                        (HI_S32)(0x80440002)
+#define HI_ERR_I2C_NOT_INIT                         (HI_S32)(0x80440003)
+#define HI_ERR_I2C_INVALID_PARA                     (HI_S32)(0x80440004)
+#define HI_ERR_I2C_NULL_PTR                         (HI_S32)(0x80440005)
+#define HI_ERR_I2C_COPY_DATA_ERR                    (HI_S32)(0x80440006)
+#define HI_ERR_I2C_MALLOC_ERR                       (HI_S32)(0x80440007)
+#define HI_ERR_I2C_WRITE_TIMEOUT                    (HI_S32)(0x80440008)
+#define HI_ERR_I2C_READ_TIMEOUT                     (HI_S32)(0x80440009)
+
+#define HI_ERR_SCI_OPEN_ERR                         (HI_S32)(0x80450001)
+#define HI_ERR_SCI_CLOSE_ERR                        (HI_S32)(0x80450002)
+#define HI_ERR_SCI_NOT_INIT                         (HI_S32)(0x80450003)
+#define HI_ERR_SCI_INVALID_PARA                     (HI_S32)(0x80450004)
+#define HI_ERR_SCI_NULL_PTR                         (HI_S32)(0x80450005)
+#define HI_ERR_SCI_INVALID_OPT                      (HI_S32)(0x80450006)
+#define HI_ERR_SCI_SEND_ERR                         (HI_S32)(0x80450007)
+#define HI_ERR_SCI_RECEIVE_ERR                      (HI_S32)(0x80450008)
+#define HI_ERR_SCI_NO_ATR                           (HI_S32)(0x80450009)
+#define HI_ERR_SCI_PPS_PTYPE_ERR                    (HI_S32)(0x8045000A)
+#define HI_ERR_SCI_PPS_FACTOR_ERR                   (HI_S32)(0x8045000B)
+#define HI_ERR_SCI_PPS_NOTSUPPORT_ERR               (HI_S32)(0x8045000C)
+#define HI_ERR_SCI_NOTSUPPORT                       (HI_S32)(0x8045000D)
+
+#define HI_ERR_ETH_NOT_INIT                         (HI_S32)(0x80460001)
+#define HI_ERR_ETH_REPEAT_INIT                      (HI_S32)(0x80460002)
+#define HI_ERR_ETH_INVALID_POINT                    (HI_S32)(0x80460003)
+#define HI_ERR_ETH_INVALID_PARA                     (HI_S32)(0x80460004)
+#define HI_ERR_ETH_FAILED_INIT                      (HI_S32)(0x80460005)
+
+#define HI_ERR_GPIO_OPEN_ERR                        (HI_S32)(0x80470001)
+#define HI_ERR_GPIO_CLOSE_ERR                       (HI_S32)(0x80470002)
+#define HI_ERR_GPIO_NOT_INIT                        (HI_S32)(0x80470003)
+#define HI_ERR_GPIO_INVALID_PARA                    (HI_S32)(0x80470004)
+#define HI_ERR_GPIO_NULL_PTR                        (HI_S32)(0x80470005)
+#define HI_ERR_GPIO_INVALID_OPT                     (HI_S32)(0x80470006)
+#define HI_ERR_GPIO_FAILED_SETINT                   (HI_S32)(0x80470007)
+#define HI_ERR_GPIO_FAILED_SETENABLE                (HI_S32)(0x80470008)
+#define HI_ERR_GPIO_FAILED_GETINT                   (HI_S32)(0x80470009)
+#define HI_ERR_GPIO_GETINT_TIMEOUT                  (HI_S32)(0x8047000A)
+#define HI_ERR_GPIO_INTTYPE_NOT_SUPPORT             (HI_S32)(0x8047000B)
+#define HI_ERR_GPIO_NOT_SUPPORT                     (HI_S32)(0x8047000C)
+#define HI_ERR_GPIO_FAILED_SETOUTPUTTYPE            (HI_S32)(0x8047000D)
+#define HI_ERR_GPIO_FAILED_GETOUTPUTTYPE            (HI_S32)(0x8047000E)
+#define HI_ERR_GPIO_FAILED_SETDIRECT                (HI_S32)(0x8047000F)
+#define HI_ERR_GPIO_FAILED_GETDIRECT                (HI_S32)(0x80470010)
+#define HI_ERR_GPIO_FAILED_SETVALUE                 (HI_S32)(0x80470011)
+#define HI_ERR_GPIO_FAILED_GETVALUE                 (HI_S32)(0x80470012)
+
+#define HI_ERR_DMAC_NOT_INIT                        (HI_S32)(0x80480001)
+#define HI_ERR_DMAC_REPEAT_INIT                     (HI_S32)(0x80480002)
+#define HI_ERR_DMAC_INVALID_POINT                   (HI_S32)(0x80480003)
+#define HI_ERR_DMAC_INVALID_PARA                    (HI_S32)(0x80480004)
+#define HI_ERR_DMAC_FAILED_INIT                     (HI_S32)(0x80480005)
+#define HI_ERR_DMAC_FAILED_GETCHANNEL               (HI_S32)(0x80480006)
+#define HI_ERR_DMAC_FAILED_MEMTRANS                 (HI_S32)(0x80480007)
+#define HI_ERR_DMAC_FAILED_PERTRANS                 (HI_S32)(0x80480008)
+#define HI_ERR_DMAC_FAILED_GETSTAT                  (HI_S32)(0x80480009)
+#define HI_ERR_DMAC_FAILED_LISTRESET                (HI_S32)(0x8048000A)
+#define HI_ERR_DMAC_FAILED_ADDLIST                  (HI_S32)(0x8048000B)
+#define HI_ERR_DMAC_FAILED_LISTTRANS                (HI_S32)(0x8048000C)
+
+#define  HI_ERR_PMOC_NOT_INIT                       (HI_S32)(0x80490001)
+#define  HI_ERR_PMOC_REPEAT_INIT                    (HI_S32)(0x80490002)
+#define  HI_ERR_PMOC_INVALID_POINT                  (HI_S32)(0x80490003)
+#define  HI_ERR_PMOC_INVALID_PARA                   (HI_S32)(0x80490004)
+#define  HI_ERR_PMOC_FAILED_INIT                    (HI_S32)(0x80490005)
+#define  HI_ERR_PMOC_FAILED_MODE                    (HI_S32)(0x80490006)
+#define  HI_ERR_PMOC_FAILED_READMODE                (HI_S32)(0x80490007)
+#define  HI_ERR_PMOC_FAILED_SETWAKEUPVAL            (HI_S32)(0x80490008)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPVAL            (HI_S32)(0x80490009)
+#define  HI_ERR_PMOC_INVALID_MODE                   (HI_S32)(0x8049000A)
+#define  HI_ERR_PMOC_FAILED_STANDBY                 (HI_S32)(0x8049000B)
+#define  HI_ERR_PMOC_FAILED_SETDEV                  (HI_S32)(0x8049000C)
+#define  HI_ERR_PMOC_FAILED_GETPERIOD               (HI_S32)(0x8049000D)
+#define  HI_ERR_PMOC_FAILED_IRPOWERVAL              (HI_S32)(0x8049000E)
+#define  HI_ERR_PMOC_FAILED_KEYLEDPOWERVAL          (HI_S32)(0x8049000F)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPMODE           (HI_S32)(0x80490010)
+#define  HI_ERR_PMOC_FAILED_GETTEMPERATURE          (HI_S32)(0x80490011)
+
+#define HI_ERR_TUNER_NOT_INIT                       (HI_S32)(0x804A0001)
+#define HI_ERR_TUNER_NOT_OPEN                       (HI_S32)(0x804A0002)
+#define HI_ERR_TUNER_INVALID_POINT                  (HI_S32)(0x804A0003)
+#define HI_ERR_TUNER_INVALID_PARA                   (HI_S32)(0x804A0004)
+#define HI_ERR_TUNER_FAILED_INIT                    (HI_S32)(0x804A0005)
+#define HI_ERR_TUNER_FAILED_CONNECT                 (HI_S32)(0x804A0006)
+#define HI_ERR_TUNER_FAILED_GETSTATUS               (HI_S32)(0x804A0007)
+#define HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH       (HI_S32)(0x804A0008)
+#define HI_ERR_TUNER_FAILED_GETBER                  (HI_S32)(0x804A0009)
+#define HI_ERR_TUNER_FAILED_GETSNR                  (HI_S32)(0x804A000A)
+#define HI_ERR_TUNER_FAILED_SETTSTYPE               (HI_S32)(0x804A000B)
+#define HI_ERR_TUNER_FAILED_SELECTTUNER             (HI_S32)(0x804A000C)
+#define HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL        (HI_S32)(0x804A000D)
+#define HI_ERR_TUNER_FAILED_LOWCONS                 (HI_S32)(0x804A000E)
+#define HI_ERR_TUNER_FAILED_NORMALMODE              (HI_S32)(0x804A000F)
+#define HI_ERR_TUNER_FAILED_REGRW                   (HI_S32)(0x804A0010)
+#define HI_ERR_TUNER_FAILED_SETTUNER                (HI_S32)(0x804A0011)
+#define HI_ERR_TUNER_NOT_CONNECT                    (HI_S32)(0x804A0012)
+#define HI_ERR_TUNER_INVALID_PORT                   (HI_S32)(0x804A0013)
+#define HI_ERR_TUNER_FAILED_SETQAMINSIDE            (HI_S32)(0x804A0014)
+#define HI_ERR_TUNER_FAILED_SELECTSYMBOLRATE        (HI_S32)(0x804A0015)
+#define HI_ERR_TUNER_FAILED_GETSIGNALQUALITY        (HI_S32)(0x804A0016)
+#define HI_ERR_TUNER_FAILED_GETSIGNALINFO           (HI_S32)(0x804A0017)
+#define HI_ERR_TUNER_FAILED_BLINDSCAN               (HI_S32)(0x804A0018)
+#define HI_ERR_TUNER_FAILED_LNBCTRL                 (HI_S32)(0x804A0019)
+#define HI_ERR_TUNER_FAILED_SWITCH                  (HI_S32)(0x804A001A)
+#define HI_ERR_TUNER_FAILED_DISEQC                  (HI_S32)(0x804A001B)
+#define HI_ERR_TUNER_FAILED_STANDBY                 (HI_S32)(0x804A001C)
+#define HI_ERR_TUNER_FAILED_WAKEUP                  (HI_S32)(0x804A001D)
+#define HI_ERR_TUNER_FAILED_DISABLE                 (HI_S32)(0x804A001E)
+#define HI_ERR_TUNER_FAILED_ENABLE                  (HI_S32)(0x804A001F)
+#define HI_ERR_TUNER_FAILED_SETPLPID                (HI_S32)(0x804A0020)
+#define HI_ERR_TUNER_FAILED_GETPLPNUM               (HI_S32)(0x804A0021)
+#define HI_ERR_TUNER_FAILED_GETPLPTYPE              (HI_S32)(0x804A0022)
+#define HI_ERR_TUNER_FAILED_SETTSOUT                (HI_S32)(0x804A0023)
+#define HI_ERR_TUNER_FAILED_SETSATATTR              (HI_S32)(0x804A0024)
+#define HI_ERR_TUNER_FAILED_SAMPLEDATA              (HI_S32)(0x804A0025)
+#define HI_ERR_TUNER_FAILED_SETTERATTR              (HI_S32)(0x804A0026)
+#define HI_ERR_TUNER_FAILED_SETSTEP                 (HI_S32)(0x804A0027)
+#define HI_ERR_TUNER_FAILED_GETBANDRANGE            (HI_S32)(0x804A0028)
+#define HI_ERR_TUNER_FAILED_SETTOPADJUST            (HI_S32)(0x804A0029)
+#define HI_ERR_TUNER_FAILED_GETBAND                 (HI_S32)(0x804A002A)
+#define HI_ERR_TUNER_FAILED_GETTONE                 (HI_S32)(0x804A002B)
+#define HI_ERR_TUNER_FAILED_GETAGC                  (HI_S32)(0x804A002C)
+#define HI_ERR_TUNER_FAILED_TERSCANTIMEOUT          (HI_S32)(0x804A002D)
+#define HI_ERR_TUNER_FAILED_ALLOC_MEM               (HI_S32)(0x804A002E)
+#define HI_ERR_TUNER_FAILED_SETISIID                (HI_S32)(0x804A002F)
+#define HI_ERR_TUNER_FAILED_GETISIID                (HI_S32)(0x804A0030)
+#define HI_ERR_TUNER_FAILED_GETTOTALISI             (HI_S32)(0x804A0031)
+#define HI_ERR_TUNER_FAILED_MONITORISDBTLAYER       (HI_S32)(0x804A0032)
+
+#define HI_ERR_KEYLED_NOT_INIT                      (HI_S32)(0x804B0001)
+#define HI_ERR_KEYLED_INVALID_PARA                  (HI_S32)(0x804B0002)
+#define HI_ERR_KEYLED_NULL_PTR                      (HI_S32)(0x804B0003)
+#define HI_ERR_KEYLED_NO_NEW_KEY                    (HI_S32)(0x804B0004)
+#define HI_ERR_KEYLED_TIMEOUT                       (HI_S32)(0x804B0005)
+#define HI_ERR_KEYLED_FAILED_SETMODE                (HI_S32)(0x804B0006)
+#define HI_ERR_KEYLED_FAILED_DISPLAY                (HI_S32)(0x804B0007)
+
+
+#define HI_ERR_E2PROM_OPEN_ERR                      (HI_S32)(0x804C0001)
+#define HI_ERR_E2PROM_CLOSE_ERR                     (HI_S32)(0x804C0002)
+#define HI_ERR_E2PROM_NOT_INIT                      (HI_S32)(0x804C0003)
+#define HI_ERR_E2PROM_INVALID_PARA                  (HI_S32)(0x804C0004)
+#define HI_ERR_E2PROM_NULL_PTR                      (HI_S32)(0x804C0005)
+#define HI_ERR_E2PROM_COPY_DATA_ERR                 (HI_S32)(0x804C0006)
+#define HI_ERR_E2PROM_MALLOC_ERR                    (HI_S32)(0x804C0007)
+
+
+#define  HI_ERR_CIPHER_NOT_INIT                     (HI_S32)(0x804D0001)
+#define  HI_ERR_CIPHER_INVALID_HANDLE               (HI_S32)(0x804D0002)
+#define  HI_ERR_CIPHER_INVALID_POINT                (HI_S32)(0x804D0003)
+#define  HI_ERR_CIPHER_INVALID_PARA                 (HI_S32)(0x804D0004)
+#define  HI_ERR_CIPHER_FAILED_INIT                  (HI_S32)(0x804D0005)
+#define  HI_ERR_CIPHER_FAILED_GETHANDLE             (HI_S32)(0x804D0006)
+#define  HI_ERR_CIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x804D0007)
+#define  HI_ERR_CIPHER_FAILED_CONFIGAES             (HI_S32)(0x804D0008)
+#define  HI_ERR_CIPHER_FAILED_CONFIGDES             (HI_S32)(0x804D0009)
+#define  HI_ERR_CIPHER_FAILED_ENCRYPT               (HI_S32)(0x804D000A)
+#define  HI_ERR_CIPHER_FAILED_DECRYPT               (HI_S32)(0x804D000B)
+#define  HI_ERR_CIPHER_BUSY                         (HI_S32)(0x804D000C)
+#define  HI_ERR_CIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x804D000D)
+
+
+#define  HI_ERR_CA_OPEN_ERR                         (HI_S32)(0x804E0001)
+#define  HI_ERR_CA_CLOSE_ERR                        (HI_S32)(0x804E0002)
+#define  HI_ERR_CA_NOT_INIT                         (HI_S32)(0x804E0003)
+#define  HI_ERR_CA_COPY_DATA_ERR                    (HI_S32)(0x804E0004)
+#define  HI_ERR_CA_INVALID_PARA                     (HI_S32)(0x804E0005)
+#define  HI_ERR_CA_WAIT_TIMEOUT                     (HI_S32)(0x804E0006)
+#define  HI_ERR_CA_CW_DECRYPT                       (HI_S32)(0x804E0007)
+#define  HI_ERR_CA_R2R_DECRYPT                      (HI_S32)(0x804E0008)
+#define  HI_ERR_CA_R2R_ENCRYPT                      (HI_S32)(0x804E0009)
+#define  HI_ERR_CA_SETPARAM_AGAIN                   (HI_S32)(0x804E000A)
+#define  HI_ERR_CA_DBG_INERR                        (HI_S32)(0x804E000B)
+#define  HI_ERR_CA_NOT_CONFIG                       (HI_S32)(0x804E000C)
+#define  HI_ERR_CA_LPK_DECRYPT                      (HI_S32)(0x804E000D)
+#define  HI_ERR_CA_NOT_SUPPORT                      (HI_S32)(0x804E000E)
+#define  HI_ERR_CA_SWPK_ENCRYPT                     (HI_S32)(0x804E000F)
+#define  HI_ERR_CA_NO_MEMORY                        (HI_S32)(0x804E0011)
+#define  HI_ERR_CA_PTR_NULL                         (HI_S32)(0x804E0012)
+#define  HI_ERR_CA_GETSEMA_ERR                      (HI_S32)(0x804E0013)
+#define  HI_ERR_CA_NO_RESOURCE                      (HI_S32)(0x804E0014)
+#define  HI_ERR_CA_NOT_FIND_CA                      (HI_S32)(0x804E0016)
+#define  HI_ERR_CA_NOT_FIND_KLAD                    (HI_S32)(0x804E0017)
+#define  HI_ERR_CA_NOT_FIND_SESSION                 (HI_S32)(0x804E0018)
+#define  HI_ERR_CA_NOT_SET                          (HI_S32)(0x804E0019)
+#define  HI_ERR_CA_ALREADY_SET                      (HI_S32)(0x804E001A)
+#define  HI_ERR_CA_NOT_FIND_CALLBACK                (HI_S32)(0x804E001B)
+#define  HI_ERR_CA_KEY_NOT_READDY                   (HI_S32)(0x804E001C)
+
+#define  HI_ERR_KLAD_NOT_INIT                       (HI_S32)(0x804E0080)
+#define  HI_ERR_KLAD_INVALID_PARA                   (HI_S32)(0x804E0081)
+#define  HI_ERR_KLAD_NO_MEMORY                      (HI_S32)(0x804E0082)
+#define  HI_ERR_KLAD_NO_RESOURCE                    (HI_S32)(0x804E0083)
+#define  HI_ERR_KLAD_WAIT_TIMEOUT                   (HI_S32)(0x804E0082)
+#define  HI_ERR_KLAD_NOT_FIND_CA                    (HI_S32)(0x804E0084)
+#define  HI_ERR_KLAD_NOT_FIND_KLAD                  (HI_S32)(0x804E0085)
+#define  HI_ERR_KLAD_NOT_FIND_SESSION               (HI_S32)(0x804E0086)
+#define  HI_ERR_KLAD_NOT_SET_ATTR                   (HI_S32)(0x804E0087)
+#define  HI_ERR_KLAD_NOT_SET_SESSION_KEY            (HI_S32)(0x804E0088)
+#define  HI_ERR_KLAD_NOT_SET_CONTENT_KEY            (HI_S32)(0x804E0089)
+#define  HI_ERR_KLAD_ALREADY_SET_ATTR               (HI_S32)(0x804E008A)
+#define  HI_ERR_KLAD_KEY_NOT_READY                  (HI_S32)(0x804E008B)
+#define  HI_ERR_KLAD_NOT_SUPPORT                    (HI_S32)(0x804E008C)
+#define  HI_ERR_KLAD_RELEASE_ERR                    (HI_S32)(0x804E008D)
+#define  HI_ERR_KLAD_OPEN_ERR                       (HI_S32)(0x804E008E)
+
+/* klad check error, reference register: KL_KLAD_CHECK_ERROR */
+#define  HI_ERR_KLAD_CHECK_BASE                     (HI_S32)(0x804E00A0)
+#define  HI_ERR_KLAD_CHECK_OTP_CONFIG_DISABLE       (HI_S32)(0x804E00A1)
+#define  HI_ERR_KLAD_CHECK_LEVEL                    (HI_S32)(0x804E00A2)
+#define  HI_ERR_KLAD_CHECK_DSC_MODE                 (HI_S32)(0x804E00A3)
+#define  HI_ERR_KLAD_CHECK_PORT                     (HI_S32)(0x804E00A4)
+#define  HI_ERR_KLAD_CHECK_ROOTKEY_NOT_READY        (HI_S32)(0x804E00A5)
+#define  HI_ERR_KLAD_CHECK_LEVEL1_NOT_READY         (HI_S32)(0x804E00A6)
+#define  HI_ERR_KLAD_CHECK_LEVEL2_NOT_READY         (HI_S32)(0x804E00A7)
+#define  HI_ERR_KLAD_CHECK_LEVEL3_NOT_READY         (HI_S32)(0x804E00A8)
+#define  HI_ERR_KLAD_CHECK_LEVEL4_NOT_READY         (HI_S32)(0x804E00A9)
+#define  HI_ERR_KLAD_CHECK_LEVEL5_NOT_READY         (HI_S32)(0x804E00AA)
+#define  HI_ERR_KLAD_CHECK_DCAS_PROFILE             (HI_S32)(0x804E00AB)
+#define  HI_ERR_KLAD_CHECK_TDES_KEY                 (HI_S32)(0x804E00AC)
+#define  HI_ERR_KLAD_CHECK_C2_TA_HASH               (HI_S32)(0x804E00AD)
+#define  HI_ERR_KLAD_CHECK_CLEAR_CW_CONFIG          (HI_S32)(0x804E00AE)
+#define  HI_ERR_KLAD_CHECK_CW                       (HI_S32)(0x804E00B2)
+#define  HI_ERR_KLAD_CHECK_TEE_ENABLE               (HI_S32)(0x804E00B4)
+
+#define  HI_ERR_PM_COPY_DATA_ERR                    (HI_S32)(0x804F0001)
+#define  HI_ERR_PM_INVALID_PARAM                    (HI_S32)(0x804F0002)
+
+#define  HI_ERR_CI_NOT_INIT                         (HI_S32)(0x80500001)
+#define  HI_ERR_CI_OPEN_ERR                         (HI_S32)(0x80500002)
+#define  HI_ERR_CI_CLOSE_ERR                        (HI_S32)(0x80500003)
+#define  HI_ERR_CI_INVALID_PARA                     (HI_S32)(0x80500004)
+#define  HI_ERR_CI_NO_MEMORY                        (HI_S32)(0x80500005)
+#define  HI_ERR_CI_TIMEOUT                          (HI_S32)(0x80500006)
+#define  HI_ERR_CI_REG_READ_ERR                     (HI_S32)(0x80500007)
+#define  HI_ERR_CI_REG_WRITE_ERR                    (HI_S32)(0x80500008)
+#define  HI_ERR_CI_IO_READ_ERR                      (HI_S32)(0x80500009)
+#define  HI_ERR_CI_IO_WRITE_ERR                     (HI_S32)(0x8050000A)
+#define  HI_ERR_CI_ATTR_READ_ERR                    (HI_S32)(0x8050000B)
+#define  HI_ERR_CI_ATTR_WRITE_ERR                   (HI_S32)(0x8050000C)
+#define  HI_ERR_CI_CANNOT_POWEROFF                  (HI_S32)(0x8050000D)
+#define  HI_ERR_CI_PCCD_DEVICE_BUSY                 (HI_S32)(0x8050000E)
+#define  HI_ERR_CI_PCCD_CIS_READ                    (HI_S32)(0x8050000F)
+#define  HI_ERR_CI_UNSUPPORT                        (HI_S32)(0x80500010)
+#define  HI_ERR_CI_UNKONWN                          (HI_S32)(0x80500011)
+#define  HI_ERR_CI_DETECT_ERR                       (HI_S32)(0x80500012)
+
+#define HI_ERR_PWM_DEV_NOT_EXIST                    (HI_S32)(0x80510001)
+#define HI_ERR_PWM_NOT_INIT                         (HI_S32)(0x80510002)
+#define HI_ERR_PWM_OPEN_ERR                         (HI_S32)(0x80510003)
+#define HI_ERR_PWM_CLOSE_ERR                        (HI_S32)(0x80510004)
+#define HI_ERR_PWM_INVALID_PARA                     (HI_S32)(0x80510005)
+#define HI_ERR_PWM_INVALID_OPT                      (HI_S32)(0x80510006)
+#define HI_ERR_PWM_UNSUPPORT                        (HI_S32)(0x80510007)
+
+#define HI_ERR_PDM_DEV_NOT_EXIST                    (HI_S32)(0x80520001)
+#define HI_ERR_PDM_NOT_DEVICE                       (HI_S32)(0x80520002)
+#define HI_ERR_PDM_DEV_OPEN_ERR                     (HI_S32)(0x80520003)
+#define HI_ERR_PDM_DEV_NOT_INIT                     (HI_S32)(0x80520004)
+#define HI_ERR_PDM_PTR_NULL                         (HI_S32)(0x80520005)
+#define HI_ERR_PDM_PARAM_INVALID                    (HI_S32)(0x80520006)
+#define HI_ERR_PDM_GET_MTDINFO_ERR                  (HI_S32)(0x80520007)
+#define HI_ERR_PDM_MTD_OPEN                         (HI_S32)(0x80520008)
+#define HI_ERR_PDM_MTD_CLOSE                        (HI_S32)(0x80520009)
+#define HI_ERR_PDM_MTD_READ                         (HI_S32)(0x80520010)
+#define HI_ERR_PDM_MTD_WRITE                        (HI_S32)(0x80520011)
+#define HI_ERR_PDM_MTD_GETINFO                      (HI_S32)(0x80520012)
+#define HI_ERR_PDM_MTD_ERASE                        (HI_S32)(0x80520013)
+#define HI_ERR_PDM_MEM_ALLC                         (HI_S32)(0x80520014)
+#define HI_ERR_PDM_INVALID_OPT                      (HI_S32)(0x80520015)
+#define HI_ERR_PDM_GET_DEVINFO_ERR                  (HI_S32)(0x80520016)
+
+#define  HI_ERR_LSADC_INVALID_PARA                   (HI_S32)(0x80520004)
+#define  HI_ERR_LSADC_FAILED_INIT                    (HI_S32)(0x80520005)
+
+#define HI_ERR_UART_OPENED                           (HI_S32)(0x80530000)
+#define HI_ERR_UART_NOT_OPEN                         (HI_S32)(0x80530001)
+#define HI_ERR_UART_BUFF                             (HI_S32)(0x80530002)
+#define HI_ERR_UART_OPEN                             (HI_S32)(0x80530003)
+#define HI_ERR_UART_MAP                              (HI_S32)(0x80530004)
+#define HI_ERR_UART_UNMAP                            (HI_S32)(0x80530005)
+#define HI_ERR_UART_CLOSE                            (HI_S32)(0x80530006)
+#define HI_ERR_UART_DEVICE                           (HI_S32)(0x80530007)
+#define HI_ERR_UART_CREATE_THREAD                    (HI_S32)(0x80530008)
+#define HI_ERR_UART_THREAD_JOIN                      (HI_S32)(0x80530009)
+#define HI_ERR_UART_SET_ATTR                         (HI_S32)(0x8053000a)
+#define HI_ERR_UART_GET_ATTR                         (HI_S32)(0x8053000b)
+#define HI_ERR_UART_SPEED                            (HI_S32)(0x8053000c)
+#define HI_ERR_UART_IOSPEED                          (HI_S32)(0x8053000d)
+#define HI_ERR_UART_DATABITS                         (HI_S32)(0x8053000e)
+#define HI_ERR_UART_PARITY                           (HI_S32)(0x8053000f)
+#define HI_ERR_UART_STOPBITS                         (HI_S32)(0x80530010)
+#define HI_ERR_UART_WRITE                            (HI_S32)(0x80530011)
+#define HI_ERR_UART_GEN                              (HI_S32)(0x80530012)
+
+#define HI_ERR_PQ_DEV_NOT_EXIST                     (HI_S32)(0x80600001)
+#define HI_ERR_PQ_NOT_DEV_FILE                      (HI_S32)(0x80600002)
+#define HI_ERR_PQ_DEV_OPEN_ERR                      (HI_S32)(0x80600003)
+#define HI_ERR_PQ_DEV_CLOSE_ERR                     (HI_S32)(0x80600004)
+#define HI_ERR_PQ_NULL_PTR                          (HI_S32)(0x80600005)
+#define HI_ERR_PQ_NO_INIT                           (HI_S32)(0x80600006)
+#define HI_ERR_PQ_INVALID_PARA                      (HI_S32)(0x80600007)
+#define HI_ERR_PQ_PARAM_NOT_BURN                    (HI_S32)(0x80600008)
+
+#define HI_ERR_SPI_OPEN_ERR                         (HI_S32)(0x80700001)
+#define HI_ERR_SPI_CLOSE_ERR                        (HI_S32)(0x80700002)
+#define HI_ERR_SPI_NOT_INIT                         (HI_S32)(0x80700003)
+#define HI_ERR_SPI_INVALID_PARA                     (HI_S32)(0x80700004)
+#define HI_ERR_SPI_NULL_PTR                         (HI_S32)(0x80700005)
+#define HI_ERR_SPI_COPY_DATA_ERR                    (HI_S32)(0x80700006)
+#define HI_ERR_SPI_MALLOC_ERR                       (HI_S32)(0x80700007)
+#define HI_ERR_SPI_WRITE_TIMEOUT                    (HI_S32)(0x80700008)
+#define HI_ERR_SPI_READ_TIMEOUT                     (HI_S32)(0x80700009)
+
+#define  HI_ERR_PLCIPHER_NOT_INIT                     (HI_S32)(0x808D0001)
+#define  HI_ERR_PLCIPHER_INVALID_HANDLE               (HI_S32)(0x808D0002)
+#define  HI_ERR_PLCIPHER_INVALID_PTR                (HI_S32)(0x808D0003)
+#define  HI_ERR_PLCIPHER_INVALID_PARA                 (HI_S32)(0x808D0004)
+#define  HI_ERR_PLCIPHER_FAILED_INIT                  (HI_S32)(0x808D0005)
+#define  HI_ERR_PLCIPHER_FAILED_GETHANDLE             (HI_S32)(0x808D0006)
+#define  HI_ERR_PLCIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x808D0007)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGAES             (HI_S32)(0x808D0008)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGDES             (HI_S32)(0x808D0009)
+#define  HI_ERR_PLCIPHER_FAILED_ENCRYPT               (HI_S32)(0x808D000A)
+#define  HI_ERR_PLCIPHER_FAILED_DECRYPT               (HI_S32)(0x808D000B)
+#define  HI_ERR_PLCIPHER_BUSY                         (HI_S32)(0x808D000C)
+#define  HI_ERR_PLCIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x808D000D)
+
+#define  HI_ERR_CERT_NOT_INIT                     (HI_S32)(0x808E0001)
+#define  HI_ERR_CERT_INVALID_HANDLE               (HI_S32)(0x808E0002)
+#define  HI_ERR_CERT_INVALID_PTR                  (HI_S32)(0x808E0003)
+#define  HI_ERR_CERT_INVALID_PARA                 (HI_S32)(0x808E0004)
+#define  HI_ERR_CERT_FAILED_INIT                  (HI_S32)(0x808E0005)
+#define  HI_ERR_CERT_UNEXPECTED_STA               (HI_S32)(0x808E0006)
+#define  HI_ERR_CERT_UNEXPECTED_EMI               (HI_S32)(0x808E0007)
+#define  HI_ERR_CERT_KEY_INVALID                  (HI_S32)(0x808E0008)
+#define  HI_ERR_CERT_TIMEOUT                      (HI_S32)(0x808E0009)
+#define  HI_ERR_CERT_LOCKED                       (HI_S32)(0x808E000A)
+#define  HI_ERR_CERT_UNLOCKED                     (HI_S32)(0x808E000B)
+#define  HI_ERR_CERT_UNEXPECTED_CW                (HI_S32)(0x808E000C)
+#define  HI_ERR_CERT_MUTEX_ERR                    (HI_S32)(0x808E000D)
+#define  HI_ERR_CERT_LOCK_STA_ERR                 (HI_S32)(0x808E000E)
+#define  HI_ERR_CERT_DBG_ALG_ERR                  (HI_S32)(0x808E000F)
+#define  HI_ERR_CERT_DBG_PRT_SEL_ERR              (HI_S32)(0x808E0010)
+#define  HI_ERR_CERT_DBG_USAGE_ERR                (HI_S32)(0x808E0011)
+#define  HI_ERR_CERT_DBG_OTHER_ERR                (HI_S32)(0x808E0012)
+#define  HI_ERR_CERT_UNKNOWN_CMD                  (HI_S32)(0x808E0013)
+
+#define  HI_ERR_OTP_NOT_INIT                      (HI_S32)(0x808F0001)
+#define  HI_ERR_OTP_NOT_SUPPORT_INTERFACE         (HI_S32)(0x808F0002)
+#define  HI_ERR_OTP_INVALID_PARA                  (HI_S32)(0x808F0003)
+#define  HI_ERR_OTP_PTR_NULL                      (HI_S32)(0x808F0004)
+#define  HI_ERR_OTP_CHECK_FAILED                  (HI_S32)(0x808F0005)
+#define  HI_ERR_OTP_SYSCALL_FAILED                (HI_S32)(0x808F0006)
+#define  HI_ERR_OTP_MALLOC_ERR                    (HI_S32)(0x808F0007)
+#define  HI_ERR_OTP_NOT_FOUND                     (HI_S32)(0x808F0008)
+#define  HI_ERR_OTP_NOT_SUPPORT                   (HI_S32)(0x808F0009)
+/** @} */  /*! <!-- Macro Definition end */
+
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+
+#endif /* End of #ifndef __HI_UNF_MPI_ERRORCODE_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_module.h unlib/xbmc/linux/hisi/hi_module.h
--- git/xbmc/linux/hisi/hi_module.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_module.h	2017-12-26 11:16:12.704977900 +0800
@@ -0,0 +1,182 @@
+/******************************************************************************
+Copyright (C), 2012-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_module.h
+Version       : V1.0 Initial Draft
+Author        : sdk
+Created       : 2012/6/19
+Last Modified :
+Description   : The module name definition for all the MODULES
+Function List : None.
+History       :
+******************************************************************************/
+/** @addtogroup   MODULES  */
+/** @{ */  /** <!-- [MODULES] */
+#ifndef __HI_MODULE_H__
+#define __HI_MODULE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_INVALID_MODULE_ID        (0xffffffff)
+#define HI_MAX_USER_MODULE_NUMBER   (256)
+
+/** Module ID flags */
+typedef enum hiMOD_ID_E
+{
+    HI_ID_STB         = 0,
+
+    /**< common. */ /**< CNcomment:  */
+    HI_ID_SYS         = 1,
+    HI_ID_MODULE      ,
+    HI_ID_LOG         ,
+    HI_ID_PROC        ,
+    HI_ID_MEM         ,
+    HI_ID_STAT        ,
+    HI_ID_PDM         ,
+    HI_ID_MEMDEV      ,
+
+    HI_ID_DEMUX       = 0x0A,
+    HI_ID_TSIO,
+
+    /**< audio. */ /**< CNcomment:  */
+    HI_ID_ADEC        = 0x10,
+    HI_ID_AO          ,
+    HI_ID_SIO_AI      ,
+    HI_ID_SIO_AO      ,
+    HI_ID_SIO         ,
+    HI_ID_AI          ,
+    HI_ID_AENC        ,
+    HI_ID_SRC         ,
+    HI_ID_AIAO        ,
+    HI_ID_AFLT        ,
+    HI_ID_ADSP        ,
+    HI_ID_AMP         ,
+    HI_ID_SIF         ,
+
+    /**< video. */ /**< CNcomment:  */
+    HI_ID_VFMW        = 0x20,
+    HI_ID_SVDEC       ,
+    HI_ID_DISP        ,
+    HI_ID_HDMI        ,
+    HI_ID_VO          ,
+    HI_ID_VPSS        ,
+    HI_ID_VDEC        ,
+    HI_ID_VI          ,
+    HI_ID_VENC        ,
+    HI_ID_PQ         ,
+    HI_ID_EDID,
+    HI_ID_VICAP       ,
+    HI_ID_HDMIRX      ,
+    /**< graphics. */ /**< CNcomment:  */
+    HI_ID_TDE         = 0x30,
+    HI_ID_JPGDEC      ,
+    HI_ID_JPGENC      ,
+    HI_ID_FB          ,
+    HI_ID_PNG         ,
+    HI_ID_HIGO        ,
+    HI_ID_GFX2D       ,
+
+    /**< player. */ /**< CNcomment:  */
+    HI_ID_PVR         = 0x40,
+    HI_ID_AVPLAY      ,
+    HI_ID_SYNC        ,
+    HI_ID_VSYNC       ,
+    HI_ID_ASYNC       ,
+    HI_ID_FASTPLAY ,
+
+    /**< ecs. */ /**< CNcomment:  */
+    HI_ID_FLASH       = 0x50,
+    HI_ID_IR          ,
+    HI_ID_RTC         ,
+    HI_ID_I2C         ,
+    HI_ID_SCI         ,
+    HI_ID_ETH         ,
+    HI_ID_USB_PROTECT ,
+    HI_ID_WDG         = 0x57,   /* watch dog used 'W' */
+    HI_ID_GPIO        ,
+    HI_ID_GPIO_I2C    ,
+    HI_ID_DMAC        ,
+    HI_ID_PMOC        ,
+    HI_ID_TUNER       ,
+    HI_ID_KEYLED      ,
+    HI_ID_E2PROM      ,
+    HI_ID_CIPHER      ,
+    HI_ID_OTP         = 0x60,
+    HI_ID_CA          ,
+    HI_ID_PM          ,
+    HI_ID_CI          ,
+    HI_ID_CIMAXPLUS   ,
+    HI_ID_TVP5150     ,
+    HI_ID_SIL9293     ,
+    HI_ID_PWM         ,
+    HI_ID_SPI         ,
+    HI_ID_PLCIPHER    ,//0x69
+    HI_ID_CERT        ,//0x6A
+
+    /**< voip, bluetooth,alsa. */ /**<  CNcomment: VOIP*/
+    HI_ID_VOIP_HME    = 0x80,
+    HI_ID_NDPT        ,
+    HI_ID_AUDADP      ,
+    HI_ID_BT          ,
+    HI_ID_ALSA        ,
+    HI_ID_3G          ,
+    HI_ID_KARAOKE     ,
+
+    /**< vp. */ /**<  CNcomment: VP*/
+    HI_ID_VP          = 0x90,
+    HI_ID_HDCP        ,
+
+    /**< subtitle. */ /**<  CNcomment: */
+    HI_ID_SUBT        = 0x98,
+    HI_ID_TTX         ,
+    HI_ID_CC          ,
+
+    /**< loader. */ /**< CNcomment: loader */
+    HI_ID_LOADER      = 0xA0,
+
+    /**< opentv5. */ /**<  CNcomment: opentv5*/
+    HI_ID_O5          = 0xA1,
+    HI_ID_O5_AUDDEC,
+    HI_ID_O5_CRYPTO,
+    HI_ID_O5_DMX,
+    HI_ID_O5_FPCHAR,
+    HI_ID_O5_HDMI,
+    HI_ID_O5_INJECT,
+    HI_ID_O5_LED,
+    HI_ID_O5_LINKER,
+    HI_ID_O5_NOCS,
+    HI_ID_O5_PD_WRITER,
+    HI_ID_O5_RFMOD,
+    HI_ID_O5_SCART,
+    HI_ID_O5_SMARTCARD,
+    HI_ID_O5_STB,
+    HI_ID_O5_TUNER,
+    HI_ID_O5_VIDDEC,
+    HI_ID_O5_VIDENC,
+    HI_ID_O5_SOC,
+    HI_ID_O5_ENDDEF  = 0xB4,
+
+    /**<GPU. */ /**< CNcomment:GPU*/
+    HI_ID_GPU        = 0xB8,
+
+    /**< user definition. */ /**< CNcomment:  */
+    HI_ID_USR_START   = 0xC0,
+    HI_ID_USR_END     = 0xFE,
+
+    HI_ID_BUTT        = 0xFF
+} HI_MOD_ID_E;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif
+
+/** @} */  /** <!-- ==== group Definition end ==== */
+
diff -uNr git/xbmc/linux/hisi/hi_type.h unlib/xbmc/linux/hisi/hi_type.h
--- git/xbmc/linux/hisi/hi_type.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_type.h	2018-07-18 17:35:28.520490000 +0800
@@ -0,0 +1,142 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_type.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2005/4/23
+Last Modified :
+Description   : Common data types of the system.
+                CNcomment:  CNend
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_TYPE_H__
+#define __HI_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of basic data types. The data types are applicable to both the application layer and kernel codes. *
+ * CNcomment:   CNend                                                   *
+ *--------------------------------------------------------------------------------------------------------------*/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Common_TYPE */
+/** @{ */  /** <!-- [Common_TYPE] */
+
+typedef unsigned char           HI_U8;
+typedef unsigned char           HI_UCHAR;
+typedef unsigned short          HI_U16;
+typedef unsigned int            HI_U32;
+typedef unsigned long           HI_ULONG;
+
+typedef signed char             HI_S8;
+typedef short                   HI_S16;
+typedef int                     HI_S32;
+typedef long                    HI_SLONG;
+
+#ifndef _M_IX86
+typedef unsigned long long      HI_U64;
+typedef long long               HI_S64;
+#else
+typedef __int64                 HI_U64;
+typedef __int64                 HI_S64;
+#endif
+
+typedef char                    HI_CHAR;
+typedef char*                   HI_PCHAR;
+
+typedef float                   HI_FLOAT;
+typedef double                  HI_DOUBLE;
+/*typedef void                    HI_VOID;*/
+#define HI_VOID         void
+
+typedef unsigned long           HI_SIZE_T;
+typedef unsigned long           HI_LENGTH_T;
+
+typedef HI_U32                  HI_HANDLE;
+
+typedef unsigned int            HI_PHYS_ADDR_T;
+
+#ifdef CONFIG_ARCH_LP64_MODE
+typedef unsigned long long      HI_VIRT_ADDR_T;
+#else
+typedef unsigned int            HI_VIRT_ADDR_T;
+#endif
+
+/** Constant Definition */
+/** CNcomment:  */
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1,
+} HI_BOOL;
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define HI_NULL             0L
+#define HI_NULL_PTR         0L
+
+#define HI_SUCCESS          0
+#define HI_FAILURE          (-1)
+
+#define HI_INVALID_HANDLE   (0xffffffff)
+
+#define HI_INVALID_PTS      (0xffffffff)
+#define HI_INVALID_TIME     (0xffffffff)
+
+#define HI_OS_LINUX     0xabcd
+#define HI_OS_WIN32     0xcdef
+
+#ifdef _WIN32
+#define HI_OS_TYPE      HI_OS_WIN32
+#else
+#define __OS_LINUX__
+#define HI_OS_TYPE      HI_OS_LINUX
+#endif
+
+#ifdef HI_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+
+define of HI_HANDLE :
+bit31                                                           bit0
+  |<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+  |--------------------------------------------------------------|
+  |      HI_MOD_ID_E       |  mod defined data |     chnID       |
+  |--------------------------------------------------------------|
+
+mod defined data: private data define by each module(for example: sub-mod id), usually, set to 0.
+*/
+
+#define HI_HANDLE_MAKEHANDLE(mod, privatedata, chnid)  (HI_HANDLE)( (((mod)& 0xffff) << 16) | ((((privatedata)& 0xff) << 8) ) | (((chnid) & 0xff)) )
+
+#define HI_HANDLE_GET_MODID(handle)     (((handle) >> 16) & 0xffff)
+#define HI_HANDLE_GET_PriDATA(handle)   (((handle) >> 8) & 0xff)
+#define HI_HANDLE_GET_CHNID(handle)     (((handle)) & 0xff)
+
+#define HI_UNUSED(x) ((x)=(x))
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_TYPE_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_unf_advca.h unlib/xbmc/linux/hisi/hi_unf_advca.h
--- git/xbmc/linux/hisi/hi_unf_advca.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_advca.h	2018-07-18 17:35:28.524490000 +0800
@@ -0,0 +1,1789 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_advca.h
+Version       : Initial
+Author        : Hisilicon hisecurity team
+Created       : 2013-08-28
+Last Modified :
+Description   : Hisilicon CA API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_ADVCA_H__
+#define __HI_UNF_ADVCA_H__
+
+#include "hi_type.h"
+#include "hi_unf_cipher.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/** advanced CA session serect key class*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV1     = 0,    /**<session serect key level 1*/
+    HI_UNF_ADVCA_KEYLADDER_LEV2 ,           /**<session serect key level 2*/
+    HI_UNF_ADVCA_KEYLADDER_LEV3 ,           /**<session serect key level 3*/
+    HI_UNF_ADVCA_KEYLADDER_LEV4,            /**<session serect key level 4*/
+    HI_UNF_ADVCA_KEYLADDER_LEV5,            /**<session serect key level 5*/
+    HI_UNF_ADVCA_KEYLADDER_LEV6,            /**<session serect key level 6*/
+    HI_UNF_ADVCA_KEYLADDER_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LEV_E;
+
+/** advanced CA session keyladder target */
+typedef enum hiUNF_ADVCA_CA_TARGET_E
+{
+    HI_UNF_ADVCA_CA_TARGET_DEMUX         = 0, /**<demux*/
+    HI_UNF_ADVCA_CA_TARGET_MULTICIPHER,       /**<multicipher*/
+    HI_UNF_ADVCA_CA_TARGET_BUTT
+}HI_UNF_ADVCA_CA_TARGET_E;
+
+/** advanced CA Encrypt arith*/
+typedef enum hiUNF_ADVCA_ALG_TYPE_E
+{
+    HI_UNF_ADVCA_ALG_TYPE_TDES      = 0,    /**<Encrypt arith :3 DES*/
+    HI_UNF_ADVCA_ALG_TYPE_AES,              /**<Encrypt arith : AES*/
+    HI_UNF_ADVCA_ALG_TYPE_BUTT
+}HI_UNF_ADVCA_ALG_TYPE_E;
+
+/** FLASH device types*/
+typedef enum hiUNF_ADVCA_FLASH_TYPE_E
+{
+    HI_UNF_ADVCA_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NAND ,          /**<nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NOR ,           /**<nor flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_EMMC ,          /**<eMMC*/
+    HI_UNF_ADVCA_FLASH_TYPE_SPI_NAND ,      /**<spi_nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_BUTT
+}HI_UNF_ADVCA_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum hiUNF_ADVCA_JTAG_MODE_E
+{
+    HI_UNF_ADVCA_JTAG_MODE_OPEN     = 0,
+    HI_UNF_ADVCA_JTAG_MODE_PROTECT,
+    HI_UNF_ADVCA_JTAG_MODE_CLOSED,
+    HI_UNF_ADVCA_JTAG_MODE_BUTT
+}HI_UNF_ADVCA_JTAG_MODE_E;
+
+
+typedef struct HiUNF_ADVCA_LOCK_TZ_OTP_PARAM
+{
+    HI_U32 u32Addr;
+    HI_U32 u32Len;
+}HI_UNF_ADVCA_LOCK_TZ_OTP_PARAM_S;
+
+typedef enum hiUNF_ADVCA_SP_DSC_MODE_E
+{
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA2              = 0x0000,   /**<Demux PAYLOAD CSA2 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA3              = 0x0010,   /**<Demux PAYLOAD CSA3 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_IDSA      = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_ECB           = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI        = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_IPTV          = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CIPLUS        = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CBC           = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_NOVEL         = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_NOVEL        = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_IPTV         = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_ECB          = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_CBC          = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC           = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_IPTV         = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_ECB          = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_CBC          = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC               = 0x4020,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_ECB               = 0x4021,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_PIFF          = 0x4022,   /**<MultiCipher AES CBC PIFF */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_APPLE         = 0x4023,   /**<MultiCipher AES CBC APPLE */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CTR               = 0x4024,   /**<MultiCipher AES CTR */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_CBC              = 0x4040,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_ECB              = 0x4041,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_BUTT
+}HI_UNF_ADVCA_SP_DSC_MODE_E;
+
+/** Advca CA VendorID */
+typedef enum hiUNF_ADVCA_VENDORID_E
+{
+    HI_UNF_ADVCA_NULL       = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_ADVCA_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_ADVCA_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_ADVCA_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_ADVCA_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_ADVCA_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_ADVCA_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_ADVCA_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_ADVCA_COMMONCA   = 0x0b,        /**<COMMONCA Chipset, Marked with H*/
+    HI_UNF_ADVCA_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_ADVCA_PANACCESS  = 0x0e,        /**<PANACCESS CA Chipset*/
+    HI_UNF_ADVCA_VENDORIDE_BUTT
+}HI_UNF_ADVCA_VENDORID_E;
+
+/** Advca CA lock type */
+typedef enum hiUNF_ADVCA_LOCK_TYPE
+{
+    HI_UNF_ADVCA_LOCK_RSA_KEY = 0,
+    HI_UNF_ADVCA_LOCK_TZ_OTP,
+    HI_UNF_ADVCA_LOCK_MISC_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_GG_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_TSKL_CSA3_DISABLE,
+    HI_UNF_ADVCA_LOCK_BUTT,
+}HI_UNF_ADVCA_LOCK_TYPE_E;
+
+
+/** DCAS KeyLadder use mode */
+typedef enum hiUNF_ADVCA_DCAS_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK2         = 0,    /**<session EK2*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK1         = 1,    /**<session EK1*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_VENDORSYSID = 8,    /**<session Vendor_SysID*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_NONCE       = 9,    /**<session nonce*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_BUTT
+}HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E;
+
+/**Defines the attribute ID of the OTP fuse. Please be kindly noted that the OTP fuse is set permanently.
+After setting the OTP fuse, please power off and then power on the STB to make the OTP fuse function effective */
+/**CNcomment: OTPID. OTP.
+OTP.*/
+typedef enum hiUNF_ADVCA_OTP_FUSE_E
+{
+    HI_UNF_ADVCA_OTP_NULL = 0,
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION, /**<Whether to enable the secure boot authentication, set the boot flash type together, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*//**<CNcomment: flash, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_DECRYPTION_ACTIVATION, /**<Whether to enable the secure boot decryption, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SELF_BOOT_DEACTIVATION, /**<Whether to disable the self boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_DEACTIVATION, /**<Whether to disable the DDR wakeup, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment:  , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_LEVEL_SEL, /**<CSA2 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_KL_LEVEL_SEL, /**<R2R keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: R2R keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_LEVEL_SEL, /**<SP keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_LEVEL_SEL, /**<CSA3 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA3 keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_LP_DEACTIVATION, /**<Whether to disable the LP keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: LP keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA2 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2CW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_CW_HARDONLY_ACTIVATION, /**<Whether to enable the SP hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SPCW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA3 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3CW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_DEACTIVATION, /**<Whether to disable the CSA2 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_DEACTIVATION, /**<Whether to disable the SP keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_DEACTIVATION, /**<Whether to disable the CSA3 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3 keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_DEACTIVATION, /**<Whether to disable the MISC keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GOOGLE_KL_DEACTIVATION, /**<Whether to disable the google keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Google keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DCAS_KL_DEACTIVATION, /**<Whether to disable the DCAS keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DCAS keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_SCRAMBLE_ACTIVATION, /**<Whether to enable the DDR scrambling, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GLOBAL_LOCK_ACTIVATION, /**<Whether to lock the whole OTP area, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: OTP , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_RUNTIME_CHECK_ACTIVATION, /**<Whether to enable the runtime check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Runtime check , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_CHECK_ACTIVATION, /**<Whether to enable the DDR check when wakeup from standby, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID_CHECK_ACTIVATION, /**<Whether to enable the version id check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Version ID , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_MSID_CHECK_ACTIVATION, /**<Whether to enable the boot MSID check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Boot MSID , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_MODE, /**<JTAG protected mode, HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*//**<CNcomment: JTAG , HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_READ_DEACTIVATION, /**<Whether to disable to read OTP via JTAG, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: JTAGOTP , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_ROOTKEY, /**<CSA2 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY, /**<R2R keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: R2R keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_ROOTKEY, /**<SP keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_ROOTKEY, /**<CSA3 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA3 keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_ROOTKEY, /**<MISC keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY, /**<OEM keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: OEM keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ESCK_ROOTKEY, /**<ESCK keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: ESCK keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY, /**<JTAG key, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*//**<CNcomment: JTAG , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CHIP_ID, /**<Chip ID, HI_UNF_ADVCA_CHIPID_ATTR_S*//**<CNcomment: Chip ID, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MARKET_SEGMENT_ID, /**<Market segment ID, HI_UNF_ADVCA_MARKET_ID_ATTR_S*//**<CNcomment: Market segment ID , HI_UNF_ADVCA_MARKET_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID, /**<Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*//**<CNcomment: Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_LEVEL_SEL, /**<MISC keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VMX_BL_FUSE, /**<Burn verimatrix bootloader fuse*//**<CNcomment: verimatrixbootloader fuse*/
+    HI_UNF_ADVCA_OTP_IRDETO_ITCSA3_ACTIVATION, /**<Whether to enbale the tweaked CSA3, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOTINFO_DEACTIVATION, /**<Whether to disable the bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ITCSA3_IMLB, /**<tweaked CSA3 IMLB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3IMLB,HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_USB_DEACTIVATION, /**<Whether to disable the usb host, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: USB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SERIAL_DEACTIVATION, /**<Whether to disable serial port, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ETHERNET_DEACTIVATION, /**<Whether to disable the ethernet, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SM4_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the SM4 crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SM4 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TDES_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the TDES crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: TDES , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION_ONLY,   /**<Enable secure boot authentication only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment:  HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE,   /**<Boot flash type, HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*//**<CNcomment: flash HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_RSA_KEY_LOCK_FLAG,   /**< Get the lock flag of RSA_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: RSA_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_STBSN_LOCK_FLAG,   /**< Get the lock flag of STBSN, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: STBSN lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MSID_LOCK_FLAG,   /**< Get the lock flag of MSID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: MSID lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSIONID_LOCK_FLAG,   /**< Get the lock flag of VersionID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: VersionID lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of OEM_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: OEM_Root_key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of R2R_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: R2R_Root_key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY_LOCK_FLAG,   /**< Get the lock flag of JTAG key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: JTAG key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TZ_AREA_LOCK_FLAG,   /**< Get the lock flag of OTP trust area, when otp_tz_area_enable is set, these lock flags can only be accessed by secure cpu , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: OTP trust area lockotp_tz_area_enableCPUHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ENCRYPTION_DEACTIVATION, /**< whether to diable boot loader key generation, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: bootloader keyHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY,        /**<Boot keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: boot keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY,   /**<Sec store keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Sec store keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of BOOT_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: BOOT_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of SEC_STORE_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: SEC_STORE_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SOS_MARKET_SEGMENT_ID,
+    HI_UNF_ADVCA_OTP_FUSE_BUTT
+}HI_UNF_ADVCA_OTP_FUSE_E;
+
+/**Defines the attribute of secure boot check.*/
+/**CNcomment: */
+typedef struct hiUNF_ADVCA_OTP_SECURE_BOOT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is secure boot check enable or not*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type*/
+}HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S;
+
+/**Defines the boot flash type.*/
+/**CNcomment: flash*/
+typedef struct hiUNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S
+{
+    HI_BOOL bBootSelCtrl;    /**<0--the boot flash type is defined by chipset pin, 1--the boot flash type is defined by OTP value*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type, only valid when bBootSelCtrl is 1*/
+}HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S;
+
+/**Defines the default attribute of OTP fuse. If one OTP fuse can ONLY be "Enable" or "Disable",
+then we will use this attribute.*/
+/**CNcomment: OTP. OTP
+*/
+typedef struct hiUNF_ADVCA_OTP_DEFAULT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is the feature enable or not*/
+}HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S;
+
+/**Defines the attribute of the keyladder level.*/
+/**CNcomment: keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enKeyladderLevel;   /**<Keyladder level*/
+}HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S;
+
+/**Defines the attribute of the JTAG protected mode.*/
+/**CNcomment: JTAG.*/
+typedef struct hiUNF_ADVCA_JTAG_PRT_MODE_ATTR_S
+{
+    HI_UNF_ADVCA_JTAG_MODE_E enJtagMode;    /**<JTAG protection mode*/
+}HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S;
+
+/**Defines the attribute of the keyladder root key.*/
+/**CNcomment: keyladder .*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S
+{
+    HI_U8 u8RootKey[16];    /**<Root key of the keyladder*/
+}HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S;
+
+/**Defines the attribute of the JTAG key.*/
+/**CNcomment: JTAG.*/
+typedef struct hiUNF_ADVCA_JTAG_KEY_ATTR_S
+{
+    HI_U8 u8JtagKey[8];     /**<JTAG protected key*/
+}HI_UNF_ADVCA_JTAG_KEY_ATTR_S;
+
+/**Defines the attribute of the chip id.*/
+/**CNcomment: chip id.*/
+typedef struct hiUNF_ADVCA_CHIPID_ATTR_S
+{
+    HI_U8 au8ChipId[8];       /**<ChipID of the chipset, it is unique every chipset*/
+}HI_UNF_ADVCA_CHIPID_ATTR_S;
+
+/**Defines the attribute of the market segment id.*/
+/**CNcomment: market segment id.*/
+typedef struct hiUNF_ADVCA_MARKET_ID_ATTR_S
+{
+    HI_U8 u8MSID[4];    /**<Market Segment ID*/
+}HI_UNF_ADVCA_MARKET_ID_ATTR_S;
+
+/**Defines the attribute of the version id.*/
+/**CNcomment: version id.*/
+typedef struct hiUNF_ADVCA_VERSION_ID_ATTR_S
+{
+    HI_U8 u8VersionId[4];   /**<Bootloader Version ID*/
+}HI_UNF_ADVCA_VERSION_ID_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_BL_FUSE_ATTR_S
+{
+    HI_U32 u32VMXBLFuse;
+}HI_UNF_ADVCA_VMX_BL_FUSE_S;
+
+/**Defines the attribute of the tweaked CSA3 IMLB.*/
+/**CNcomment: tweaked CSA3 IMLB.*/
+typedef struct hiUNF_ADVCA_ITCSA3_IMLB_ATTR_S
+{
+    HI_U8 au8ItCsa3IMLB[2];   /**<tweaked CSA3 IMLB*/
+}HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S;
+
+/**Defines the attribute of the OTP fuse.*/
+/**CNcomment: OTP fuse.*/
+typedef struct hiUNF_ADVCA_OTP_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S          stDefaultAttr; /**<Default attribute, if one fuse can ONLY be "Enable" or "Disable", then we can use this attribute*/
+        HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S      stEnableSecureBoot; /**<Secure boot attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S  stKeyladderLevSel;  /**<Keyladder level attribute*/
+        HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S        stJtagPrtMode; /**<JTAG protected mode attribute*/
+        HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S    stKeyladderRootKey; /**<Keyladder rootkey attribute*/
+        HI_UNF_ADVCA_JTAG_KEY_ATTR_S             stJtagKey;   /**<JTAG key attribute*/
+        HI_UNF_ADVCA_CHIPID_ATTR_S               stChipId;     /**<Chip ID attribute*/
+        HI_UNF_ADVCA_MARKET_ID_ATTR_S            stMarketId;    /**<Market segment ID attribute*/
+        HI_UNF_ADVCA_VERSION_ID_ATTR_S           stVersionId;  /**<Bootloadder version ID attribute*/
+        HI_UNF_ADVCA_VMX_BL_FUSE_S               stVMXBLFuse;  /**<Vmx Bootloadder specific fuse attribute*/
+        HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S          stItCsa3IMLB; /**<tweaked CSA3 IMLB attribute*/
+        HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S  stBootFlashType;   /**<Boot flash type attribute*/
+    }unOtpFuseAttr;
+}HI_UNF_ADVCA_OTP_ATTR_S;
+
+/**Defines the attribute of the keyladder type ID.*/
+/**CNcomment: keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TYPE_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2 = 0,        /**<CSA2 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3,            /**<CSA3 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_R2R,             /**<R2R keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_SP,              /**<SP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_MISC,            /**<MISC keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_LP,              /**<LP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_TA,              /**<TA keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM,            /**<Google DRM key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_TYPE_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TYPE_E;
+
+/**Defines the attribute of the CSA2 keyladder type ID.*/
+/**CNcomment: CSA2 keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E;
+
+/**Defines the attribute of the CSA3 keyladder type ID.*/
+/**CNcomment: CSA3 keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E;
+
+/**Defines the attribute of the R2R keyladder type ID.*/
+/**CNcomment: R2R keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_R2R_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E;
+
+
+
+/**Defines the attribute of the SP keyladder type ID.*/
+/**CNcomment: SP keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ENABLE = 0,       /**<Use SPE keyladder or not for specal CA system */
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ALG ,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E;
+
+/**Defines the attribute of the MISC keyladder type ID.*/
+/**CNcomment: MISC keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_MISC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ENABLE = 0, /**<Use MISC keyladder or not. Before using the MISC keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E;
+
+/**Defines the attribute of the TA keyladder type ID.*/
+/**CNcomment: TA keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TA_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ENABLE = 0, /**<Use TA keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_LOAD_TRANDATA,   /**<Transformation data protection and loading*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E;
+
+/**Defines the attribute of the CSA2 keyladder.*/
+/**CNcomment: CSA2 keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E  enCsa2KlAttr; /**<CSA2 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S;
+
+/**Defines the attribute of the CSA3 keyladder.*/
+/**CNcomment: CSA3 keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E  enCsa3KlAttr; /**<CSA3 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                    /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S;
+
+/**Defines the attribute of the R2R keyladder.*/
+/**CNcomment: R2R keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_R2R_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E  enR2RKlAttr; /**<R2R keyladder attribute  ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S;
+
+/**Defines the attribute of the SP keyladder.*/
+/**CNcomment: SP keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E  enSPKlAttr; /**<SP keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use SP keyladder or not. Before using the SP keyladder*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S;
+
+
+
+/**Defines the attribute of the MISC keyladder.*/
+/**CNcomment: MISC keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_MISC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E  enMiscKlAttr; /**<MISC keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use MISC keyladder or not. Before using the MISC keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: TA keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_TA_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E  enTAKlAttr; /**<TA keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use TA keyladder or not. Before using the TA keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 au8SessionKey[16];                                   /**<Session key*/
+    HI_U8 *pu8TranData;                                         /**<Transformation data*/
+    HI_U32 u32TranDataLen;                                  /**<Transformation data length*/
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S;
+
+/**Defines the attribute of the Google DRM keyladder type ID.*/
+/**CNcomment: Google DRM keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENABLE = 0,    /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should set this attribute to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT,       /**<Encrypt clear device key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG,       /**<Get flag*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E;
+
+/**Defines the attribute of Google DRM keyladder.*/
+/**CNcomment: Google DRM keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E  enGDRMKlAttr;
+    HI_BOOL bEnable;                                  /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should be set to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;       /**<Keyladder stage of the session key to be set*/
+    HI_HANDLE hCipherHandle;                    /**<cipher handle, if enStage is HI_UNF_ADVCA_KEYLADDER_LEV3, hCipherHandle should be set*/
+    HI_U8 au8SessionKey[32];                     /**<if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT it is clear device key, if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY, it is session key*/
+    HI_U8 au8Output[16];                          /**<if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT is set, it is encrypted device key, if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG is set, it is flag*/
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S;
+
+/**Defines the attribute of all of the keyladder.*/
+/**CNcomment:  keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S      stCSA2KlAttr;       /**<CSA2 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S      stCSA3KlAttr;       /**<CSA3 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S       stR2RKlAttr;        /**<R2R keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S        stSPKlAttr;         /**<SP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S      stMiscKlAttr;       /**<MISC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S        stTAKlAttr;         /**<TA keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S      stGDRMAttr;         /**<Google DRM keyladder attribute*/
+    }unKlAttr;
+}HI_UNF_ADVCA_KEYLADDER_ATTR_S;
+
+
+/**Defines the attribute of the CA vendor type ID.*/
+/**CNcomment: CA vendorID.*/
+typedef enum hiUNF_ADVCA_CA_VENDOR_OPT_E
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CHIP_CONF_CMAC = 0, /**<To generate a secure message authentication code (MAC) tag for the OTP configuration data*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_CALC,  /**<To calculate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_AUTH,  /**<To authenticate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_ACTIVATION_CODE, /**<To set the activation code for tweaked CSA3.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_VMX_GET_RNG, /**<To get the RNG number, ONLY used for verimatrix currently.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_BUTT
+}HI_UNF_ADVCA_CA_VENDOR_OPT_E;
+
+/**Defines the attribute of chip configuration CMAC.*/
+/**CNcomment: OTPCMAC.*/
+typedef struct hiUNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S
+{
+    HI_U8 au8ChipConfBitm[16]; /**<128bit Chip configuration bit map*/
+    HI_U8 au8ChipConfCmac[16];   /**<128bit Chip configuration CMAC*/
+}HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S;
+
+/**Defines the attribute of the tweak CSA3, Activation Code.*/
+/**CNcomment: CSA3ACTIVATION CODE.*/
+typedef struct hiUNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S
+{
+    HI_U8 au8CSA3ActCode[16];   /**<128bit tweak CSA3 Activation Code*/
+}HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S;
+
+/**Defines the attribute of the high level code CBC-MAC authentication.*/
+/**CNcomment: CBC-MAC.*/
+typedef struct hiUNF_ADVCA_IRDETO_CBCMAC_ATTR_S
+{
+    HI_U8 *pu8InputData;
+    HI_U32 u32InputDataLen;
+    HI_U8 au8OutputCBCMAC[16];
+    HI_U8 au8RefCBCMAC[16];  /**<Reference CBC-MAC*/
+    HI_U32 u32AppLen; /**<High level code length*/
+}HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_GetRNG_S
+{
+    HI_U32 u32RNG;
+}HI_UNF_ADVCA_VMX_GetRNG_S;
+
+/**Defines the attribute of the CA vendor private function.*/
+/**CNcomment: CA.*/
+typedef struct hiADVCA_CA_VENDOR_OPT_S
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_E enCaVendorOpt;
+    union
+    {
+        HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S     stIrdetoChipConfCmac;
+        HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S    stIrdetoCsa3ActCode;
+        HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S             stIrdetoCbcMac;
+        HI_UNF_ADVCA_VMX_GetRNG_S                     stVMXRng;
+    }unCaVendorOpt;
+}HI_UNF_ADVCA_CA_VENDOR_OPT_S;
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/**
+\brief Initializes the advanced CA module CNcomment:advance CA CNend
+\attention \n
+Call this application programming interface (API) before using the advanced CA module.
+The code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:advance CA\n
+ CNend
+\param N/A CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_OPEN_ERR The CA device fails to start CNcomment:HI_ERR_CA_OPEN_ERR CA CNend
+\see \n
+::HI_UNF_ADVCA_DeInit
+*/
+HI_S32 HI_UNF_ADVCA_Init(HI_VOID);
+
+/**
+\brief Deinitializes the advanced CA module CNcomment:advance CA CNend
+\attention \n
+None CNcomment: CNend
+\param N/A CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DeInit(HI_VOID);
+
+/**
+\brief Set the ChipId CNcomment:ChipId  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+CHIP_ID should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:\n  CNend
+CNcomment:\n
+CHIP_IDCA\n  CNend
+\param[in] Id chip id CNcomment:Id chip id\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\see \n
+::HI_UNF_ADVCA_SetChipId
+*/
+HI_S32 HI_UNF_ADVCA_SetChipId(HI_U32 Id);
+
+/**
+\brief Obtains the chip ID CNcomment:ID  CNend
+\attention \n
+The chip ID is read-only.
+CNcomment:ID CNend
+\param[out] pu32ChipId Chip ID CNcomment:pu32ChipId   ID  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetChipId(HI_U32 *pu32ChipId);
+
+
+/**
+\brief Obtains the market ID CNcomment:Market ID  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] u8MarketId market ID CNcomment:u8MarketId    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetMarketId
+*/
+HI_S32 HI_UNF_ADVCA_GetMarketId(HI_U8 u8MarketId[4]);
+
+/**
+\brief Sets the Market ID CNcomment:Market ID  CNend
+\attention \n
+The market ID of the set-top box (STB) is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] u8MarketId market ID CNcomment:u8MarketId    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetMarketId(HI_U8 u8MarketId[4]);
+
+
+/**
+\brief Obtains the serial number of the STB CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] u8StbSn serial number of the STB CNcomment:u8StbSn    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_SetStbSn
+*/
+HI_S32 HI_UNF_ADVCA_GetStbSn(HI_U8 u8StbSn[4]);
+
+/**
+\brief Sets the serial number of the STB CNcomment: CNend
+\attention \n
+The serial number of the STB is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] u8StbSn serial number of the STB CNcomment:u8StbSn    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetStbSn(HI_U8 u8StbSn[4]);
+
+/**
+\brief Set the R2R RootKey and lock it. CNcomment:R2R RootKey  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+R2R RootKey should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:,\n
+R2RRootKeyCA\n  CNend
+\param[in] pkey R2R Root Key CNcomment:pkey  R2R\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RRootKey(HI_U8 *pkey);
+
+/**
+\brief Obtains the security startup enable status CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable: Security startup enable. CNcomment:pbEnable    CNend
+HI_TRUE enabled CNcomment:HI_TRUE   CNend
+HI_FALSE disabled CNcomment:HI_FALSE  CNend
+\param[out] penFlashType the startup flash type, only valid when SCS is enable
+CNcomment:penFlashType Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSecBootStat(HI_BOOL *pbEnable,HI_UNF_ADVCA_FLASH_TYPE_E *penFlashType);
+
+/**
+\brief Obtains the mode of the JTAG interface CNcomment:JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Mode of the JTAG interface CNcomment:penJtagMode   JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E *penJtagMode);
+
+/**
+\brief Sets the mode of the JTAG interface CNcomment:JTAG   CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG interface CNcomment:enJtagMode   JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Obtains the R2R key ladder stage CNcomment:R2R key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the R2R key ladder stage CNcomment:R2R key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3
+CNcomment:enStage   key ladder\n HI_UNF_ADVCA_KEYLADDER_LEV2  HI_UNF_ADVCA_KEYLADDER_LEV3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the digital video broadcasting (DVB) key ladder stage CNcomment:DVB key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the DVB key ladder stage CNcomment:DVB key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the CSA3 key ladder stage CNcomment:CSA3 key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the CSA3 key ladder stage CNcomment:CSA3 key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Sets session keys for an R2R key ladder CNcomment:R2R key ladder    CNend
+\attention \n
+
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetR2RKeyLadderStage first.
+Session keys can be set during initialization or changed at any time.
+CNcomment:CIPHER\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetR2RKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The R2R decryption fails CNcomment:HI_ERR_CA_R2R_DECRYPT  R2R CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets session keys for a DVB key ladder CNcomment:DVB key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetDVBKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets session keys for a CSA3 key ladder CNcomment:CSA3 key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetDVBKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3SessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Set widevine keyladder session key CNcomment:widevine keyladder CNend
+\param[in]  enLevel keyladder level for input CNcomment:enLevel  CNend
+\param[in]  hCipherHandle cipher handle input when level 3 CNcomment:hCipherHandle Cipher CNend
+\param[in]  pu8Input input data for keyladder CNcomment:pu8Input  keyladder CNend
+\param[in]  u32InputLen input data length CNcomment:u32InputLen  CNend
+\param[out] pu32GdrmFlag the flag value when level 3 CNcomment:pu32GdrmFlag  GDRM  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA    CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT     CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK CNend
+\see
+\li ::
+*/
+HI_S32 HI_UNF_ADVCA_SetGDRMSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enLevel,
+                                    HI_HANDLE hCipherHandle,
+                                    HI_U8 *pu8Input,
+                                    HI_U32 u32InputLen,
+                                    HI_U32 *pu32GdrmFlag);
+
+
+/**
+\brief Encrypts software protect keys (SWPKs) CNcomment: CNend
+\attention
+Before the delivery of the STB, you need to read the SWPKs in plain text format from the flash memory, encrypt SWPKs by calling this API, and store the encrypted SWPKs in the flash memory for security startup.
+CNcomment: FlashSWPK(Software Protect Key),,SWPKFlash CNend
+The fist 8 bytes of the SWPK can't be equal to the last 8 bytes.
+CNcomment:SWPK88 CNend
+This API is only for special CA, please contact Hislicon before usage.
+CNcomment::CA CNend
+\param[in]  pPlainSwpk SWPKs in plain text format CNcomment:pPlainSwpk    SWPK  CNend
+\param[out] pEncryptedSwpk Encrypted SWPKs CNcomment:pEncryptedSwpk  SWPK  CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA    CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT     CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EncryptSWPK(HI_U8 *pPlainSwpk,HI_U8 *pEncryptedSwpk);
+
+/**
+\brief Sets the algorithm of the DVB key ladder CNcomment:DVB key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the CSA2 key ladder CNcomment:CSA3 key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3Alg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the R2R key ladder CNcomment:R2R key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the DVB key ladder CNcomment:  DVB key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Obtains the algorithm of the R2R key ladder CNcomment: R2R key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+  \brief set RSA key CNcomment:RSA CNeng
+  \attention \n
+  If the mass-produced chipset have been set RSA Key by CA, there's no need to use this API to set RSA Key again.
+  This API can been called only once, please be careful, after setting RSA key, you should lock it by call API
+  HI_UNF_ADVCA_ConfigLockFlag.The length of RSA key must be 512 Bytes.
+  CNcomment:CARSAKey,RSAKey\n
+     ,,RSAKey\n
+     HI_UNF_ADVCA_ConfigLockFlag RSA key512 Bytes  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetRSAKey(HI_U8 *pkey);
+
+/**
+  \brief set RSA key CNcomment:RSA CNend
+  \attention \n
+     RSA key can be read out when only the RSAKey is not locked,The length of RSA key is 512 Bytes.
+     RSA key should have been setting and lock before chipset is delivered to STB Manufacture.
+     Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:RSAkey, RSA key512 Bytes\n
+     RSA keyCA\n  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRSAKey(HI_U8 *pkey);
+
+/**
+  \brief set RSA key CNcomment:RSA CNend
+  \attention \n
+    This API is used to lock RSA KEY/Trustzone OTP\misc keyladder etc.Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:RSAkey\Trustzone OTP\misc keyladder\n  CNend
+  \param[enType] enType the type you want to lock.  CNcomment:enType  \n  CNend
+  \param[pu8ParamIn] pu8ParamIn reserved, default is null. CNcomment:pu8ParamIn  null\n  CNend
+  \param[u32ParamLen] u32ParamLen reserved, default is 0. CNcomment:u32ParamLen  0\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_ConfigLockFlag(HI_UNF_ADVCA_LOCK_TYPE_E enType, HI_U8 *pu8ParamIn, HI_U32 u32ParamLen);
+
+
+/**
+  \brief This function is used to check if the MarketID is already set
+  \attention \n
+  None
+  \param[in] pbIsMarketIdSet: the pointer point to the buffer to store the return value
+  \param[out] pbIsMarketIdSet: save the return value
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_IsMarketIdSet(HI_BOOL *pbIsMarketIdSet);
+
+/**
+  \brief This function is used to get the vendor type of the chipset
+  \attention \n
+  None
+  \param[out] pu32VendorID: The number indicates the vendor id
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVendorID(HI_U32 *pu32VendorID);
+
+/**
+\brief Enables the security startup function and sets the type of flash memory for security startup
+CNcomment:,Flash CNend
+\attention \n
+This function can be enabled only and cannot be disabled after being enabled.
+CNcomment: CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBoot(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief Enables the security startup function. This API should be used with the API HI_UNF_ADVCA_SetFlashTypeEx.
+CNcomment:HI_UNF_ADVCA_SetFlashTypeEx CNend
+\attention \n
+\param[in]  None
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBootEx(HI_VOID);
+
+/**
+\brief Sets the type of flash memory for security startup and disable the self boot, which mean that you cannot use the serial port to update the boot. This API should be used with the API HI_UNF_ADVCA_EnableSecBootEx
+CNcomment:FlashfastbootHI_UNF_ADVCA_EnableSecBootEx CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment: CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetFlashTypeEx(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief  Sets whether to use hardware CWs only CNcomment:CW CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the CW type (hardware CWs or software CWs) depends on the configuration of the DEMUX.
+CNcomment:
+DemuxCWCW CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockHardCwSel(HI_VOID);
+
+/**
+\brief Disables the self-boot function CNcomment:SelfBoot,boot/ CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:
+SelfBoot CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized.  CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Obtains the self-boot status CNcomment:SelfBoot CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable: self-boot status. CNcomment:pbEnable   SelfBoot CNend
+HI_TRUE enabled CNcomment:HI_TRUE   CNend
+HI_FALSE disabled CNcomment:HI_FALSE  CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSelfBootStat(HI_BOOL *pbDisable);
+
+/**
+\brief  Get whether to use hardware CWs only CNcomment:CW CNend
+\attention
+None CNcomment: CNend
+\param[out] pbLock indicates the state of hardware CWs  CNcomment:pbLock CW CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetHardCwSelStat(HI_BOOL *pbLock);
+
+/**
+\brief  Open the SWPK key ladder CNcomment:boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderOpen(HI_VOID);
+
+/**
+\brief  Close the SWPK key ladder CNcomment:boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderClose(HI_VOID);
+
+/**
+\brief Obtains the Version ID CNcomment:Version ID  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] u8VersionId version ID CNcomment:u8VersionId    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetVersionId
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionId(HI_U8 u8VersionId[4]);
+
+/**
+\brief Sets the Version ID CNcomment:Version ID  CNend
+\attention \n
+The version ID of the set-top box (STB) is set before delivery. The version ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] u8VersionId version ID CNcomment:u8VersionId    CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetVersionId(HI_U8 u8VersionId[4]);
+
+/**
+\brief  Sets whether to check the boot version CNcomment:Version  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the version check function is disabled
+CNcomment:
+version check  CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableVersionCheck(HI_VOID);
+
+/**
+\brief  Get the boot version check flag CNcomment:version CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat boot version check flag CNcomment:pu32Stat    version CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Sets whether to check the MSID in boot area CNcomment:boot areaMSID  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the boot MSID check function is disabled
+CNcomment:
+boot MSID check  CNend
+\param none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableBootMSIDCheck(HI_VOID);
+
+/**
+\brief  Get the boot MSID check flag CNcomment:MSID CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat boot MSID check flag CNcomment:pu32Stat    MSID CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootMSIDCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Get the software revision
+CNcomment:revision CNend
+\attention \n
+None CNcomment: CNend
+\param[out] revision string of Revision CNcomment:revision    Revision CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRevision(HI_U8 revision[25]);
+
+/**
+\brief  Set the DDR Scramble flag. Normally, this flag has been set as required by CA vendor
+CNcomment:DDRCA CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDDRScramble(HI_VOID);
+
+/**
+\brief  Get the DDR Scramble flag
+CNcomment:DDR CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat DDR Scramble flag CNcomment:pu32Stat    DDR CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDDRScrambleStat(HI_U32 *pu32Stat);
+
+/**
+\brief Sets whether to decrypt the BootLoader CNcomment:BootLoader CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+CNcomment:
+FlashBootLoader CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockBootDecEn(HI_VOID);
+
+/**
+\brief Get the BootLoader Decryption flag CNcomment:BootLoader CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat BootLoader Decryption flag CNcomment:pu32Stat    Bootloader CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootDecEnStat(HI_U32 *pu32Stat);
+
+
+
+
+
+/**
+\brief  Calculte the AES_CMAC value of data
+CNcomment: AES_CMAC  CNend
+\attention \n
+None CNcomment: CNend
+
+\param[in]  buffer  pointer of data buffer .        CNcomment:buffer  CNend
+\param[in]  Length  The length  of data .   CNcomment: CNend
+\param[in]  Key   The key used in Calculte the AES_CMAC of data           CNcomment: AES_CMAC key  CNend
+\param[out]  MAC   The AES_CMAC value          CNcomment:AES_CMAC  CNend
+
+\retval ::HI_SUCCESS  Success                 CNcomment: CNend
+\retval ::HI_FAILURE    Failure                     CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_CalculteAES_CMAC(HI_U8 *buffer, HI_U32 Length, HI_U8 Key[16], HI_U8 MAC[16]);
+
+
+
+/**
+\brief Sets the algorithm of the SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the SP key ladder CNcomment:  SP key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Sets the SP key ladder stage CNcomment:SP key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the SP key ladder stage CNcomment:SP key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+
+/**
+\brief Sets session keys for a SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetSPKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetSPKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetSPSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets the descramble mode of the SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+You must set a descramble mode before using a key ladder in a session. The default algorithm is HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI.
+It is recommended that you retain the descramble mode in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E enType);
+
+/**
+\brief Obtains the descramble mode of the SP key ladder CNcomment:  SP key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E *pEnType);
+
+/**
+  \brief this function is used by the Novel CA for the encryption and decryption setting
+   CNcomment:Novelkey CNend
+  \attention \n
+  This function is used for the Novel encryption and decrption
+  CNcomment:   Novel keyladderkey CNend
+  \retval ::HI_SUCCESS Success  CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called  CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelCryptologyConfig(HI_VOID);
+
+/**
+  \brief Used for Novel CA to encrypt the data  CNcomment:Novel CNend
+  \attention \n
+  None  CNcomment:  CNend
+  \param[in]  pPlainText: the buffer to store the data to be encrypted CNcomment:pPlainText  CNend
+  \param[in]  TextLen: the length of the data to be encrypted CNcomment:TextLen     CNend
+  \param[in]  pCipherText: the buffer to store the encrypted data CNcomment:pCipherText  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataEncrypt(HI_U8 *pPlainText, HI_U32 TextLen, HI_U8 *pCipherText);
+
+/**
+  \brief This function is used for Novel to decrypt the data CNcomment:TextNovel CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  pPlainText: point to the data to be decrypted CNcomment:pPlainText  CNend
+  \param[in]  TextLen: the length of the data to be decrypted CNcomment:TextLen     CNend
+  \param[in]  pCipherText: the buffer store the decrypted data CNcomment:pCipherText  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataDecrypt(HI_U8 *pCipherText, HI_U32 TextLen, HI_U8 *pPlainText);
+
+/**
+\brief Sets oem root key it's mainly used for widevine keyladder CNcomment:OEM_root_key Widevine keyladder    CNend
+\attention \n
+This root key could only be written only once be careful, thanks    CNcomment: , CNend
+\param[in] pu8OEMRootKey buffer of the input key    CNcomment:pu8OEMRootKey    buffer  CNend
+\param[in] u32KeyLen key length of the input CNcomment:u32KeyLen     16  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOEMRootKey(HI_U8 *pu8OEMRootKey, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to open the DCAS CNcomment:DCAS CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enAlg: DCAS keyladder algorithm CNcomment:enAlg DCAS keyladder CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASOpen(HI_UNF_CIPHER_ALG_E enAlg);
+
+/**
+  \brief This function is used to get the DCAS CHIPID CNcomment:DCAS CHIPID
+  \attention \n
+  None  CNcomment: CNend
+  \param[out]  pu32MSBID: First 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID4 CNend
+  \param[out]  pu32LSBID: last 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID4 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDCASChipId(HI_U32 *pu32MSBID, HI_U32 *pu32LSBID);
+
+/**
+  \brief This function is used to set the session key CNcomment:DCAS session CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enDCASLevel: the DCAS keyladder level CNcomment:enAlg DCAS keyladder CNend
+  \param[in]  pu8Key: the DCAS keyladder session key CNcomment:enAlg DCAS keyladder CNend
+  \param[in]  pu8Output: the output of the DCAS keyladder CNcomment:pu8Output DCAS keyladder CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDCASSessionKey(HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E enDCASLevel, HI_U8 au8Key[16], HI_U8 au8Output[16]);
+
+/**
+  \brief This function is used to close the DCAS keyladder CNcomment:DCAS CNend
+  \attention \n
+  None  CNcomment: CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASClose(HI_VOID);
+
+/**
+  \brief This function is used to set the OTP fuse. CNcomment:OTP CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse OTPID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr OTP CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to get the OTP fuse. CNcomment:OTP CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse OTPID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr OTP CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to set the keyladder attribute. CNcomment:keyladder CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enKeyLadderType: The keyladder type ID CNcomment:enKeyLadderType KeyladderID CNend
+  \param[in]  pstKeyladderAttr: The keyladder attribute CNcomment:pstKeyladderAttr keyladderCNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetKeyLadderAttr(HI_UNF_ADVCA_KEYLADDER_TYPE_E enKeyLadderType, HI_UNF_ADVCA_KEYLADDER_ATTR_S *pstKeyladderAttr);
+
+/**
+  \brief This function is used to achieve the CA vendor privated function. CNcomment:CA CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enCaVendor: The CA vendor type ID CNcomment:enCaVendor CA vendorID CNend
+  \param[in]  pstCavendorOpt: The parameter to achieve the CA vendor private function CNcomment:pstCavendorOpt CACNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_CaVendorOperation(HI_UNF_ADVCA_VENDORID_E enCaVendor, HI_UNF_ADVCA_CA_VENDOR_OPT_S *pstCaVendorOpt);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ADVCA_H__ */
+
+
diff -uNr git/xbmc/linux/hisi/hi_unf_ai.h unlib/xbmc/linux/hisi/hi_unf_ai.h
--- git/xbmc/linux/hisi/hi_unf_ai.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_ai.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,340 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_ai.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013/4/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : zgjie
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio input (AI) module. CNcomment:AI CNend
+ */
+
+#ifndef  __HI_UNF_AI_H__
+#define  __HI_UNF_AI_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/********************************Macro Definition********************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!-- AI */
+
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  AI */
+
+
+
+
+/**Audio inputport defination */
+/**CNcomment:*/
+typedef enum hiUNF_AI_E
+{
+    HI_UNF_AI_I2S0 = 0,
+
+    HI_UNF_AI_I2S1,
+
+    HI_UNF_AI_ADC0 = 0x10,
+
+    HI_UNF_AI_ADC1,
+
+    HI_UNF_AI_ADC2,
+
+    HI_UNF_AI_ADC3,
+
+    HI_UNF_AI_ADC4,
+
+    HI_UNF_AI_SIF0 = 0x20,
+
+    HI_UNF_AI_HDMI0 = 0x30,
+
+    HI_UNF_AI_HDMI1,
+
+    HI_UNF_AI_HDMI2,
+
+    HI_UNF_AI_HDMI3,
+
+    HI_UNF_AI_BUTT = 0xff,
+} HI_UNF_AI_E;
+
+/**Defines internal Audio ADC inputport attribute */
+/**CNcomment:ADC*/
+typedef struct hiUNF_AI_ADC_ATTR_S
+{
+    HI_BOOL   bByPass;
+} HI_UNF_AI_ADC_ATTR_S;
+
+
+/**Defines  Audio I2S inputport attribute */
+/**CNcomment:I2S*/
+typedef struct hiUNF_AI_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;  /**<I2S Attribute*/ /**<CNcomment:I2S*/
+}  HI_UNF_AI_I2S_ATTR_S;
+
+/**Defines the HDMI RX Audio data format .*/
+typedef enum hiHI_UNF_AI_HDMI_FORMAT_E
+{
+    HI_UNF_AI_HDMI_FORMAT_LPCM = 0,          /* LPCM 2/8 channels,  Audio Sample Packet layout0 or layout1 */ 
+    HI_UNF_AI_HDMI_FORMAT_LBR = 1,           /* IEC-61937 DD/DDP/DTS, Audio Sample Packet layout0 */ 
+    HI_UNF_AI_HDMI_FORMAT_HBR = 8,           /* IEC-61937 DTSHD/TrueHD, High-Bitrate (HBR) Audio Stream Packet*/ 
+    HI_UNF_AI_HDMI_FORMAT_BUTT
+} HI_UNF_AI_HDMI_FORMAT_E;
+
+
+/**Defines  HDMI Audio inputport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_AI_HDMI_ATTR_S
+{
+    HI_UNF_I2S_CHNUM_E    enChannel;    /**<Channel number*/ /**<CNcomment:*/
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;   /**<Bit Depth*/ /**<CNcomment:*/
+    HI_UNF_SAMPLE_RATE_E  enSampleRate; /**<Sample Rate*/ /**<CNcomment:*/
+    HI_UNF_AI_HDMI_FORMAT_E enHdmiAudioDataFormat;  /**<HDMI audio data format*/ /**<CNcomment:HDMI*/
+} HI_UNF_AI_HDMI_ATTR_S;
+
+/**Defines internal SIF(Audio Demodulator) inputport attribute */
+/**CNcomment:SIF*/
+typedef struct hiUNF_AI_SIF_ATTR_S
+{
+    HI_VOID* pPara;
+} HI_UNF_AI_SIF_ATTR_S;
+
+/**Defines  Audio inputport attribute */
+/**CNcomment:*/
+typedef struct hiHI_UNF_AI_ATTR_S
+{
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;          /**<samplerate, default 48000Hz*/ /**<CNcomment: 48000Hz*/
+    HI_U32                  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer, default 16*/ /**<CNcomment:  16*/
+    HI_U32                  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data, default 960*/ /**<CNcomment: PCM 960*/
+    union
+    {
+        HI_UNF_AI_ADC_ATTR_S  stAdcAttr;    /**<ADC Attribute*/ /**<CNcomment:ADC*/
+        HI_UNF_AI_I2S_ATTR_S  stI2sAttr;    /**<I2S Attribute*/ /**<CNcomment:I2S*/
+        HI_UNF_AI_HDMI_ATTR_S stHDMIAttr;   /**<HDMI Attribute*/ /**<CNcomment:HDMI*/
+    } unAttr;
+} HI_UNF_AI_ATTR_S;
+
+/**Defines AI Delay attribute */
+/**CNcomment:AI*/
+typedef struct hiHI_UNF_AI_DELAY_S
+{
+    HI_U32                  u32DelayMs;    /**<buffer delay compensation(ms), Min Value is 20, Max Value depends on u32PcmFrameMaxNum, u32PcmSamplesPerFrame and enSampleRate in HI_UNF_AI_ATTR_S.
+                                                    MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate. 
+                                                    MaxValue is equal to 320ms according to default HI_UNF_AI_ATTR_S*/ 
+                                                   /**<CNcomment:(ms), 20msHI_UNF_AI_ATTR_Su32PcmFrameMaxNumu32PcmSamplesPerFrameenSampleRate
+                                                    :MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate
+                                                    HI_UNF_AI_ATTR_S320ms */
+    HI_BOOL                 bDelayMsAutoHold;  /**<if hold buffer delay compensation time automatically*/ /**<CNcomment:AI_AOu32CompensationMs*/
+} HI_UNF_AI_DELAY_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  AI */
+
+/**
+\brief Initializes an AI device. CNcomment: CNend
+\attention \n
+Before calling the AI module, you must call this application programming interface (API). CNcomment:AI CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AI device. CNcomment: CNend
+\attention \n
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_DeInit(HI_VOID);
+
+/**
+ \brief Obtains the default attributes of a AI port. CNcomment: AI CNend
+ \attention \n
+ \param[in] pstAttr Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_GetDefaultAttr(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr);
+
+/**
+ \brief Enables a AI port to create a AI handle. CNcomment: AI PortAI CNend
+ \attention \n
+Before calling the AI, you must call this API.\n
+CNcomment: AI  CNend
+ \param[in] pstAttr CNcomment: Pointer to AI attributes AI CNend
+ \param[in] phandle CNcomment: hAi Pointer to the AI handle AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_Create(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr, HI_HANDLE *phAI);
+
+/**
+ \brief Disable a AI port to destroy the handle. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA  The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_Destroy(HI_HANDLE hAI);
+
+/**
+ \brief Set the attributes of a AI port. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \param[in] pstAttr  Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+ HI_S32 HI_UNF_AI_SetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+ \brief Obtains the attributes of a AI port. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \param[out] pstAttr Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_GetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+\brief enable AI port. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] bEnable      enable  .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_SetEnable(HI_HANDLE hAI, HI_BOOL bEnable);
+
+/**
+\brief Obtains enable/disable status of AI port. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[out] pbEnable enable/disable status AI port. CNcomment:AI CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_GetEnable(HI_HANDLE hAI, HI_BOOL *pbEnable);
+
+/**
+\brief set AI delay compensation. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] pstDelay  delay compensation .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_SetDelay(HI_HANDLE hAI, const HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief Obtains AI delay compensation. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[out] pstDelay delay compensation. CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_GetDelay(HI_HANDLE hAI, HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief get frame buffer from AI. CNcomment:  CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as AI).
+\param[in] AI handle CNcomment: AI CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment: CNend
+\param[out] pstFrame        frame info.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_AcquireFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Releases the frame buffer for AI . CNcomment:  CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment: CNend
+\param[out] pstFrame        frame info.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_ReleaseFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_AI_H__*/
+
diff -uNr git/xbmc/linux/hisi/hi_unf_audio.h unlib/xbmc/linux/hisi/hi_unf_audio.h
--- git/xbmc/linux/hisi/hi_unf_audio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_audio.h	2018-07-18 17:35:28.524490000 +0800
@@ -0,0 +1,234 @@
+/******************************************************************************
+
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_audio.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_AUDIO_H__
+#define __HI_UNF_AUDIO_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_audio_codec.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Audio_Common */
+/** @{ */  /** <!-- [Audio_Common] */
+
+/**CNcomment: */
+typedef enum hiUNF_SAMPLE_RATE_E
+{
+    HI_UNF_SAMPLE_RATE_UNKNOWN=0,       /**<Unknown*/ /**<CNcomment:  */
+    HI_UNF_SAMPLE_RATE_8K    = 8000,    /**<8 kHz sampling rate*/ /**<CNcomment: 8K */
+    HI_UNF_SAMPLE_RATE_11K   = 11025,   /**<11.025 kHz sampling rate*/ /**<CNcomment: 11.025K */
+    HI_UNF_SAMPLE_RATE_12K   = 12000,   /**<12 kHz sampling rate*/ /**<CNcomment: 12K */
+    HI_UNF_SAMPLE_RATE_16K   = 16000,   /**<16 kHz sampling rate*/ /**<CNcomment: 16K */
+    HI_UNF_SAMPLE_RATE_22K   = 22050,   /**<22.050 kHz sampling rate*/ /**<CNcomment: 22.050K */
+    HI_UNF_SAMPLE_RATE_24K   = 24000,   /**<24 kHz sampling rate*/ /**<CNcomment: 24K */
+    HI_UNF_SAMPLE_RATE_32K   = 32000,   /**<32 kHz sampling rate*/ /**<CNcomment: 32K */
+    HI_UNF_SAMPLE_RATE_44K   = 44100,   /**<44.1 kHz sampling rate*/ /**<CNcomment: 44.1K */
+    HI_UNF_SAMPLE_RATE_48K   = 48000,   /**<48 kHz sampling rate*/ /**<CNcomment: 48K */
+    HI_UNF_SAMPLE_RATE_88K   = 88200,   /**<88.2 kHz sampling rate*/ /**<CNcomment: 88.2K */
+    HI_UNF_SAMPLE_RATE_96K   = 96000,   /**<96 kHz sampling rate*/ /**<CNcomment: 96K */
+    HI_UNF_SAMPLE_RATE_176K  = 176400,  /**<176 kHz sampling rate*/ /**<CNcomment: 176K */
+    HI_UNF_SAMPLE_RATE_192K  = 192000,  /**<192 kHz sampling rate*/ /**<CNcomment: 192K */
+
+    HI_UNF_SAMPLE_RATE_BUTT
+} HI_UNF_SAMPLE_RATE_E;
+
+/**Defines the bit depth during audio sampling.*/
+/**CNcomment: */
+typedef enum hiUNF_BIT_DEPTH_E
+{
+    HI_UNF_BIT_DEPTH_UNKNOWN =0,/**<Unknown*/ /**<CNcomment:   */
+    HI_UNF_BIT_DEPTH_8  = 8,    /**< 8-bit depth*/ /**<CNcomment: 8  */
+    HI_UNF_BIT_DEPTH_16 = 16,   /**<16-bit depth*/ /**<CNcomment: 16 */
+    HI_UNF_BIT_DEPTH_18 = 18,   /**<18-bit depth*/ /**<CNcomment: 18 */
+    HI_UNF_BIT_DEPTH_20 = 20,   /**<20-bit depth*/ /**<CNcomment: 20 */
+    HI_UNF_BIT_DEPTH_24 = 24,   /**<24-bit depth*/ /**<CNcomment: 24 */
+    HI_UNF_BIT_DEPTH_32 = 32,   /**<32-bit depth*/ /**<CNcomment: 32 */
+
+    HI_UNF_BIT_DEPTH_BUTT
+} HI_UNF_BIT_DEPTH_E;
+
+/**Defines the mode of audio channels.*/
+/**CNcomment: */
+typedef enum hiUNF_TRACK_MODE_E
+{
+    HI_UNF_TRACK_MODE_STEREO = 0,          /**<Stereo*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_MONO,         /**<Data is output after being mixed in the audio-left channel and audio-right channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_LEFT,         /**<The audio-left channel and audio-right channel output the data of the audio-left channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_RIGHT,        /**<The audio-left channel and audio-right channel output the data of the audio-right channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_EXCHANGE,            /**<Data is output after being exchanged in the audio-left channel and audio-right channel.*/ /**<CNcomment:  */
+    HI_UNF_TRACK_MODE_ONLY_RIGHT,          /**<Only the data in the audio-right channel is output.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_ONLY_LEFT,           /**<Only the data in the audio-left channel is output.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_MUTED,               /**<Mute*/ /**<CNcomment: */
+
+    HI_UNF_TRACK_MODE_BUTT
+} HI_UNF_TRACK_MODE_E;
+
+/**Defines the attributes of the audio decoder.*/
+/**CNcomment: */
+typedef struct hiUNF_ACODEC_ATTR_S
+{
+    HA_CODEC_ID_E        enType;                    /**<Audio decoder type*/ /**<CNcomment: */
+    HI_HADECODE_OPENPARAM_S stDecodeParam;   /**<Audio decoder parameter*/ /**<CNcomment: */
+} HI_UNF_ACODEC_ATTR_S;
+
+/**Defines the attributes of audio encoder.*/
+/**CNcomment: */
+typedef struct hiUNF_AENC_ATTR_S
+{
+    HI_U32         enAencType;              /**<Audio encoder type*/ /**<CNcomment: */
+    HI_HAENCODE_OPENPARAM_S   sOpenParam;   /**<Audio encoder parameter*/ /**<CNcomment: */
+} HI_UNF_AENC_ATTR_S;
+
+/**Defines the information about audio streams.*/
+/**CNcomment: */
+typedef struct hiUNF_ACODEC_STREAMINFO_S
+{
+    HI_U32               enACodecType;     /**<Audio encoding type*/ /**<CNcomment: */
+    HI_U32               enSampleRate;     /**<Audio sampling rate*/ /**<CNcomment: */
+    HI_UNF_BIT_DEPTH_E   enBitDepth;       /**<Bit depth during audio sampling*/ /**<CNcomment: */
+    HI_U32               u32Channel;       /**<Audio output channel*//**<CNcomment: */
+    HI_U32               u32BitRate;       /**<Audio output Rate*//**<CNcomment: */
+} HI_UNF_ACODEC_STREAMINFO_S;
+
+/**Defines the I2S(Inter-IC Sound) mode.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_MODE_E
+{
+    HI_UNF_I2S_STD_MODE = 0,     /**<I2S standard mode*/ /**<CNcomment: I2S*/
+    HI_UNF_I2S_PCM_MODE,         /**<pcm mode*/ /**<CNcomment: PCM*/
+    HI_UNF_I2S_TDM_MODE,         /**<TDM mode*/ /**<CNcomment: TDM*/
+
+    HI_UNF_I2S_MODE_BUTT
+} HI_UNF_I2S_MODE_E;
+
+/**Defines the I2S(Inter-IC Sound) master clock.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_MCLK_SEL_E
+{
+    HI_UNF_I2S_MCLK_128_FS = 0,      /* mclk 128*fs  */
+    HI_UNF_I2S_MCLK_256_FS,          /* mclk 256*fs */
+    HI_UNF_I2S_MCLK_384_FS,          /* mclk 384*fs */
+    HI_UNF_I2S_MCLK_512_FS,          /* mclk 512*fs */
+    HI_UNF_I2S_MCLK_768_FS,          /* mclk 768*fs */
+    HI_UNF_I2S_MCLK_1024_FS,         /* mclk 1024*fs */
+    HI_UNF_I2S_MCLK_BUTT
+} HI_UNF_I2S_MCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) bclk clock.*/
+typedef enum hiHI_UNF_I2S_BCLK_SEL_E
+{
+     HI_UNF_I2S_BCLK_1_DIV = 1,           /* bclk=mclk/1  */
+     HI_UNF_I2S_BCLK_2_DIV = 2,           /* bclk=mclk/2  */
+     HI_UNF_I2S_BCLK_3_DIV = 3,           /* bclk=mclk/3  */
+     HI_UNF_I2S_BCLK_4_DIV = 4,           /* bclk=mclk/4  */
+     HI_UNF_I2S_BCLK_6_DIV = 6,           /* bclk=mclk/6  */
+     HI_UNF_I2S_BCLK_8_DIV = 8 ,          /* bclk=mclk/8  */
+     HI_UNF_I2S_BCLK_12_DIV= 12,          /* bclk=mclk/12 */
+     HI_UNF_I2S_BCLK_24_DIV= 24,          /* bclk=mclk/24 */
+     HI_UNF_I2S_BCLK_32_DIV= 32,          /* bclk=mclk/32 */
+     HI_UNF_I2S_BCLK_48_DIV= 48,          /* bclk=mclk/48 */
+     HI_UNF_I2S_BCLK_64_DIV= 64,          /* bclk=mclk/64 */
+     HI_UNF_I2S_BCLK_BUTT
+} HI_UNF_I2S_BCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) channels.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_CHNUM_E
+{
+    HI_UNF_I2S_CHNUM_1  = 1,
+    HI_UNF_I2S_CHNUM_2  = 2,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_8  = 8,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_16 = 16,             /* only work for TDM mode */
+
+    HI_UNF_I2S_BUTT,
+} HI_UNF_I2S_CHNUM_E;
+
+/**Defines the I2S(Inter-IC Sound) bit depth.*/
+typedef enum hiHI_UNF_I2S_BITDEPTH_E
+{
+    HI_UNF_I2S_BIT_DEPTH_16 = 16,
+    HI_UNF_I2S_BIT_DEPTH_24 = 24,         /* only work for I2S mode */
+} HI_UNF_I2S_BITDEPTH_E;
+
+/**Defines the I2S(Inter-IC Sound) data valid after frame sync clock at PCM mode .*/
+/**CNcomment: I2SPCM*/
+typedef enum hiHI_UNF_I2S_PCMDELAY_E
+{
+    HI_UNF_I2S_PCM_0_DELAY = 0,           /* 0  bclk cycles delay*/
+    HI_UNF_I2S_PCM_1_DELAY = 1,           /* 1  bclk cycles delay*/
+    HI_UNF_I2S_PCM_8_DELAY = 8,           /* 8  bclk cycles delay*/
+    HI_UNF_I2S_PCM_16_DELAY = 16,         /* 16 bclk cycles delay*/
+    HI_UNF_I2S_PCM_17_DELAY = 17,         /* 17 bclk cycles delay*/
+    HI_UNF_I2S_PCM_24_DELAY = 24,         /* 24 bclk cycles delay*/
+    HI_UNF_I2S_PCM_32_DELAY = 32,         /* 32 bclk cycles delay*/
+    HI_UNF_I2S_PCM_DELAY_BUTT
+} HI_UNF_I2S_PCMDELAY_E;
+
+/**Defines the I2S(Inter-IC Sound) attribute .*/
+/**CNcomment: I2S*/
+typedef struct hiHI_UNF_I2S_ATTR_S
+{
+    HI_BOOL               bMaster;           /* HI_TRUE:master, HI_FALSE: slave */
+    HI_UNF_I2S_MODE_E     enI2sMode;
+    HI_UNF_I2S_MCLK_SEL_E enMclkSel;
+    HI_UNF_I2S_BCLK_SEL_E enBclkSel;
+    HI_UNF_I2S_CHNUM_E    enChannel;
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;
+    HI_BOOL               bPcmSampleRiseEdge; /* only work for PCM mode. HI_TRUE:sample data at positive edge of bclk, HI_FALSE: sample data at  negative edge of bclk */
+    HI_UNF_I2S_PCMDELAY_E enPcmDelayCycle;    /* only work for PCM mode.  */
+} HI_UNF_I2S_ATTR_S;
+
+/**Defines the information about audio frames.*/
+/**CNcomment: */
+typedef struct hiUNF_AO_FRAMEINFO_S
+{
+    /** s32BitPerSample: (PCM) Data depth, and format of storing the output data
+          If the data depth is 16 bits, 16-bit word memory is used.
+          If the data depth is greater than 16 bits, 32-bit word memory is used, and data is stored as left-aligned data. That is, the valid data is at upper bits.
+     */
+    /**CNcomment: s32BitPerSample: (PCM) . 
+          16bit:   16bit word
+          16bit:   32bit word, ()
+     */
+    HI_S32  s32BitPerSample;       /**<Data depth*/ /**<CNcomment: */
+    HI_BOOL bInterleaved;          /**<Whether the data is interleaved*/ /**<CNcomment: */
+    HI_U32  u32SampleRate;         /**<Sampling rate*/ /**<CNcomment: */
+    HI_U32  u32Channels;           /**<Number of channels*/ /**<CNcomment: */
+    HI_U32  u32PtsMs;              /**<Presentation time stamp (PTS)*/ /**<CNcomment: */
+    HI_S32 *ps32PcmBuffer;         /**<Pointer to the buffer for storing the pulse code modulation (PCM) data*/ /**<CNcomment: PCM*/
+    HI_S32 *ps32BitsBuffer;        /**<Pointer to the buffer for storing the stream data*/ /**<CNcomment: */
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sampling points of the PCM data*/ /**<CNcomment: PCM*/
+    HI_U32  u32BitsBytesPerFrame;  /**<IEC61937 data size*/ /**<CNcomment: IEC61937*/
+    HI_U32  u32FrameIndex;         /**<Frame ID*/ /**<CNcomment:  */
+    HI_U32  u32IEC61937DataType;   /**<IEC61937 Data Type*/ /**<CNcomment: IEC619378bitIEC */
+} HI_UNF_AO_FRAMEINFO_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_AUDIO_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_avplay.h unlib/xbmc/linux/hisi/hi_unf_avplay.h
--- git/xbmc/linux/hisi/hi_unf_avplay.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_avplay.h	2018-07-18 17:35:28.524490000 +0800
@@ -0,0 +1,1534 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_avplay.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/21
+  Description   :
+  History       :
+  1.Date        : 2009/12/21
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio/video player (AVPLAY) module.
+          CNcomment:AVPLAY CNend
+ */
+#ifndef __HI_UNF_AVPLAY_H__
+#define __HI_UNF_AVPLAY_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*********************************error  macro******************************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**Highest priority of the video decoder*/
+/**CNcomment: */
+#define HI_UNF_VCODEC_MAX_PRIORITY  16
+
+
+/**Defines the buffer ID required in an AVPLAY.*/
+/**CNcomment:AVBufferID */
+typedef enum hiUNF_AVPLAY_BUFID_E
+{
+    HI_UNF_AVPLAY_BUF_ID_ES_VID  = 0,       /**<ID of the buffer for storing the video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVESBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD,            /**<ID of the buffer for storing the audio ESs played by an AVPLAY*//**<CNcommentAVESBuffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD_AD,         /**<ID of the buffer for storing the AD audio ESs played by an AVPLAY*//**<CNcommentAVAD ESBuffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_BL,     /**<ID of the buffer for storing the HDR BL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR BLBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_EL,     /**<ID of the buffer for storing the HDR EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR ELBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_DL,     /**<ID of the buffer for storing the HDR BL+EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR BL+ELBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_BUTT
+} HI_UNF_AVPLAY_BUFID_E;
+
+/**Defines the type of a media channel.*/
+/**CNcomment:. */
+typedef enum hiUNF_AVPLAY_MEDIA_CHAN
+{
+    HI_UNF_AVPLAY_MEDIA_CHAN_AUD  = 0x01,  /**<Audio channel*//**<CNcomment:  */
+    HI_UNF_AVPLAY_MEDIA_CHAN_VID  = 0x02,  /**<Video channel*//**<CNcomment:  */
+
+    HI_UNF_AVPLAY_MEDIA_CHAN_BUTT = 0x8
+} HI_UNF_AVPLAY_MEDIA_CHAN_E;
+
+/**Defines the type of an input stream interface.*/
+/**CNcomment: */
+typedef enum hiUNF_AVPLAY_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_TS = 0,   /**<Transport stream (TS)*//**<CNcomment:TS */
+    HI_UNF_AVPLAY_STREAM_TYPE_ES,       /**<ES stream*//**<CNcomment:ES */
+
+    HI_UNF_AVPLAY_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_STREAM_TYPE_E;
+
+/**Defines the stream attributes.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_STREAM_ATTR_S
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_E enStreamType;   /**<Stream type*//**<CNcomment: */
+
+    HI_U32                      u32VidBufSize;  /**<Video buffer size*//**<CNcomment:  */
+    HI_U32                      u32AudBufSize;  /**<Audio buffer size*//**<CNcomment:  */
+
+} HI_UNF_AVPLAY_STREAM_ATTR_S;
+
+/**Supported synchronization control mode*/
+/**CNcomment: */
+typedef enum hiUNF_SYNC_REF_E
+{
+    HI_UNF_SYNC_REF_NONE = 0, /**<Free playing without synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_AUDIO,    /**<Audio-based synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_VIDEO,    /**<Video-based synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_PCR,      /**<Program Clock Reference (PCR)-based synchronization*//**<CNcomment: PCRProgram Clock Reference */
+    HI_UNF_SYNC_REF_SCR,      /**<System Clock Reference (SCR)-based synchronization*//**<CNcomment: SCR (System Clock Reference)  */
+
+    HI_UNF_AVPLAY_SYNC_REF_BUTT
+} HI_UNF_SYNC_REF_E;
+
+/**Defines the status of a buffer.*/
+/**CNcomment: */
+typedef enum hiUNF_AVPLAY_BUF_STATE_E
+{
+    HI_UNF_AVPLAY_BUF_STATE_EMPTY = 0,   /**<The buffer is idle.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_LOW,         /**<The buffer usage is too low.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_NORMAL,      /**<The buffer works normally.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_HIGH,        /**<The buffer usage is too high.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_FULL,        /**<The buffer is full.*//**<CNcomment:  */
+
+    HI_UNF_AVPLAY_BUF_STATE_BUTT
+}HI_UNF_AVPLAY_BUF_STATE_E;
+
+/**Defines the type of pts channel.*/
+/** CNcomment:PTS */
+typedef enum hiUNF_SYNC_PTS_CHAN_E
+{
+    HI_UNF_SYNC_PTS_CHAN_VID,   /**<Video pts channel.*//**<CNcomment:PTS */
+    HI_UNF_SYNC_PTS_CHAN_AUD,   /**<Audio pts channel.*//**<CNcomment:PTS */
+    HI_UNF_SYNC_PTS_CHAN_PCR,   /**<Pcr channel.*//**<CNcomment:PCR */
+
+    HI_UNF_SYNC_PTS_CHAN_BUTT
+}HI_UNF_SYNC_PTS_CHAN_E;
+
+/**Defines the parameters of pts jump.*/
+/** CNcomment:PTS */
+typedef struct hiUNF_SYNC_PTSJUMP_PARAM_S
+{
+    HI_UNF_SYNC_PTS_CHAN_E  enPtsChan;  /**<Pts channel.*//**<CNcomment:PTS */
+    HI_BOOL                 bLoopback;  /**<Loopback or not.*//**<CNcomment: */
+    HI_U32                  u32FirstPts;/**<The first pts.*//**<CNcomment:PTS */
+    HI_U32                  u32FirstValidPts;/**<The first valid pts.*//**<CNcomment:PTS */
+    HI_U32                  u32CurSrcPts;   /**<The current src pts.*//**<CNcomment:PTS */
+    HI_U32                  u32CurPts;      /**<The current pts.*//**<CNcomment:PTS */
+    HI_U32                  u32LastSrcPts;  /**<The last src pts.*//**<CNcomment:PTS */
+    HI_U32                  u32LastPts;     /**<The last pts.*//**<CNcomment:PTS */
+}HI_UNF_SYNC_PTSJUMP_PARAM_S;
+
+/**Defines the parameters of synchronization status change*/
+/** CNcomment: */
+typedef struct hiUNF_SYNC_STAT_PARAM_S
+{
+     HI_S32          s32VidAudDiff;     /**<The diffrence between video and audio frames*//**<CNcomment:  */
+     HI_S32          s32VidPcrDiff;     /**<The diffrence between video frame and pcr*//**<CNcomment: PCR */
+     HI_S32          s32AudPcrDiff;     /**<The diffrence between audio frame and pcr*//**<CNcomment: PCR */
+     HI_U32          u32VidLocalTime;   /**<Local video synchronization reference time*//**<CNcomment:  */
+     HI_U32          u32AudLocalTime;   /**<Local audio synchronization reference time*//**<CNcomment:  */
+     HI_U32          u32PcrLocalTime;   /**<Local pcr synchronization reference time*//**<CNcomment: PCR */
+}HI_UNF_SYNC_STAT_PARAM_S;
+
+/*Type of the event callback function*/
+/**CNcomment:  */
+typedef enum hiUNF_AVPLAY_EVENT_E
+{
+    HI_UNF_AVPLAY_EVENT_EOS,                   /**<The end of stream (EOS) operation is performed, NULL*//**<CNcomment: EOS, NULL.*/
+    HI_UNF_AVPLAY_EVENT_STOP,                  /**<The stop operation is performed, NULL*//**<CNcomment: STOP, NULL.*/
+    HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*//**<CNcomment: , HI_UNF_AVPLAY_BUF_STATE_E.*/
+    HI_UNF_AVPLAY_EVENT_NORM_SWITCH,           /**<Standard switch, HI_UNF_NORMCHANGE_PARAM_S*//**<CNcomment: , HI_UNF_NORMCHANGE_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE,   /**<3D Frame packing change, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E*//**<CNcomment: 3D, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E .*/
+    HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME,         /**<New video frame, HI_UNF_VO_FRAMEINFO_S*//**<CNcomment: , HI_UNF_VO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME,         /**<New audio frame, HI_UNF_AO_FRAMEINFO_S*//**<CNcomment: , HI_UNF_AO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_USER_DATA,         /**<New video user data, HI_UNF_VIDEO_USERDATA_S*//**<CNcomment: , HI_UNF_VIDEO_USERDATA_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_AUD_ES,            /**<New audio ES data, HI_UNF_ES_BUF_S*//**<CNcomment: ES, HI_UNF_ES_BUF_S .*/
+    HI_UNF_AVPLAY_EVENT_IFRAME_ERR,            /**<I frame decode error*//**<CNcomment: I .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP,         /**<Pts Jump, HI_UNF_SYNC_PTSJUMP_PARAM_S * *//**<CNcomment: PTS, HI_UNF_SYNC_PTSJUMP_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE,      /**<Synchronization status change, HI_UNF_SYNC_STAT_PARAM_S * *//**<CNcomment: , HI_UNF_SYNC_STAT_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_VID_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE*//**<CNcomment: , HI_UNF_AVPLAY_EVENT_VID_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE*//**<CNcomment: , HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT,         /**<The video stream is unsupport*//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO,         /**<frame error ratio *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE,       /**<audio info change, HI_UNF_ACODEC_STREAMINFO_S *//**<CNcomment: HI_UNF_ACODEC_STREAMINFO_S*/
+    HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT,         /**<unsupported audio *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR,         /**<audio frame error *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE,          /**<the setting vid codec type is error, HI_UNF_VCODEC_TYPE_E*//**<CNcomment: , HI_UNF_VCODEC_TYPE_E*/
+    HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED, /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME,         /**<vid frame decode error.*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_STATUS_REPORT,         /**<avplay status info, HI_UNF_AVPLAY_STATUS_INFO_S*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO,        /**<Video frame status info, HI_UNF_VIDEO_FRM_STATUS_INFO_S*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_START_POS,         /**<the peek frame first pts, HI_U32*/ /**<CNcomment: peekpts, HI_U32*/
+    HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME,    /**<Estimated time of display, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/ /**<CNcomment: , HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/
+    HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE,   /**<HDCP strategy change, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S*//**<CNcomment:HDCP , HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_BUTT
+} HI_UNF_AVPLAY_EVENT_E;
+
+/**Mode of processing the buffer overflow*/
+/**CNcomment:   */
+typedef enum hiUNF_AVPLAY_OVERFLOW_E
+{
+    HI_UNF_AVPLAY_OVERFLOW_RESET,              /**<Reset during overflow*//**<CNcomment:   */
+    HI_UNF_AVPLAY_OVERFLOW_DISCARD,            /**<Discard during overflow*//**<CNcomment:   */
+    HI_UNF_AVPLAY_OVERFLOW_BUTT
+} HI_UNF_AVPLAY_OVERFLOW_E;
+
+/**Defines the parameters of HDCP output control */
+/**CNcomment: HDCP*/
+typedef struct hiUNF_AVPLAY_HDCPSTRATEGY_PARAM_S
+{
+    HI_U32 u32ImageWidth;                     /**<Width of image allowed by HDCP strategy*/ /**<CNcomment:  HDCP (tvp)*/
+    HI_U32 u32ImageHeight;                    /**<Height of image allowed by HDCP strategy*/ /**<CNcomment:  HDCP (tvp)*/
+}HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S;
+
+/**Defines the type of the event callback function.*/
+/**CNcomment:  */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para);
+
+/**Defines the type of the event callback function.*/
+/**CNcomment:  */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN64)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID *pPara);
+
+/**Defines the attribute of audio security.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_AUD_SECURITY_ATTR_S
+{
+    HI_BOOL    bEnable; /**<Audio dmx channel is security mode or not*//**<CNcomment: DMX*/
+}HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S;
+
+/**Defines the attribute ID of an AVPLAY.*/
+/**CNcomment: AVID */
+typedef enum hiUNF_AVPLAY_ATTR_ID_E
+{
+    HI_UNF_AVPLAY_ATTR_ID_STREAM_MODE = 0,  /**<Playing mode, HI_UNF_AVPLAY_ATTR_S*//**<CNcomment: , HI_UNF_AVPLAY_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_ADEC,             /**<Audio attribute, HI_UNF_ACODEC_ATTR_S*//**<CNcomment: , HI_UNF_ACODEC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_VDEC,             /**<Video attribute, HI_UNF_VCODEC_ATTR_S*//**<CNcomment: , HI_UNF_VCODEC_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_AUD_PID,          /**<Audio packet identifier (PID), HI_U32*//**<CNcomment: PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_VID_PID,          /**<Video PID, HI_U32*//**<CNcomment: PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_PCR_PID,          /**<PCR PID, HI_U32*//**<CNcomment: PCR PID, HI_U32.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_SYNC,             /**<Synchronization attribute, HI_UNF_SYNC_ATTR_S*//**<CNcomment: , HI_UNF_SYNC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_AFD,              /**<Whether to enable the active format descriptor (AFD), HI_BOOL* *//**<CNcomment: AFD  HI_BOOL * .*/
+    HI_UNF_AVPLAY_ATTR_ID_OVERFLOW,         /**<Overflow processing type, HI_UNF_AVPLAY_OVERFLOW_E* *//**<CNcomment:  , HI_UNF_AVPLAY_OVERFLOW_E * .*/
+
+    HI_UNF_AVPLAY_ATTR_ID_MULTIAUD,         /**<Multiple audio attribute,  HI_UNF_AVPLAY_MULTIAUD_ATTR_S **//**<CNcomment: , HI_UNF_AVPLAY_MULTIAUD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM,    /**<Frame Rate Parameter, HI_UNF_AVPLAY_FRMRATE_PARAM_S * *//**<CNcomment:,HI_UNF_AVPLAY_FRMRATE_PARAM_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMPACK_TYPE,     /**<3D Frame Packing Type, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * *//**<CNcomment:3D,HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * .*/
+    HI_UNF_AVPLAY_ATTR_ID_LOW_DELAY,        /**<Low Delay Attr, HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_TVP,              /**<Trusted Video Path Attr, HI_UNF_AVPLAY_TVP_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_TVP_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD,               /**<MS12 Attr, HI_UNF_AVPLAY_AD_ATTR_S * *//**<CNcomment: MS12 , HI_UNF_AVPLAY_AD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_HDR,              /**<HDR Attr, HI_UNF_AVPLAY_HDR_ATTR_S * *//**<CNcomment: HDR , HI_UNF_AVPLAY_HDR_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AUD_SECURITY,     /**<Dmx audio channel security mode, HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD_PID,           /**<AD program id*/ /**<CNcomment: ADPID,HI_S32*/
+    HI_UNF_AVPLAY_ATTR_ID_START_POSITION,   /**< Set video start play position, HI_UNF_AVPLAY_START_POSITION_ATTR_S * *//**<CNcomment:  HI_UNF_AVPLAY_START_POSITION_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_BUTT
+} HI_UNF_AVPLAY_ATTR_ID_E;
+
+/**Defines the stream type of HDR.*/
+/**CNcomment: DOLBY HDR */
+typedef enum hiUNF_AVPLAY_HDR_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_SINGLE_VES = 0,    /**<Dolby Vision Dual layer Single VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_DUAL_VES,          /**<Dolby Vision Dual Layer Dual VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_SL_VES,               /**<Dolby Vision Single Layer VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_HDR_STREAM_TYPE_E;
+
+/**Defines the attribute of low delay.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_LOW_DELAY_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is low delay enable or not*//**<CNcomment: */
+}HI_UNF_AVPLAY_LOW_DELAY_ATTR_S;
+
+/**Defines the attribute of trust video path.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_TVP_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is trusted video path enable or not*//**<CNcomment: */
+}HI_UNF_AVPLAY_TVP_ATTR_S;
+
+/**Defines the audio/video synchronization .*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_REGION_S
+{
+    HI_S32                s32VidPlusTime;        /**<Plus time range during video synchronization*//**<CNcomment:  */
+    HI_S32                s32VidNegativeTime;    /**<Negative time range during video synchronization*//**<CNcomment:  */
+    HI_BOOL               bSmoothPlay;           /**<Slow playing enable*//**<CNcomment:  */
+} HI_UNF_SYNC_REGION_S;
+
+/**Defines the audio/video synchronization attributes.*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_ATTR_S
+{
+    HI_UNF_SYNC_REF_E     enSyncRef;             /**<Audio-based synchronization, PCR-based synchronization, and free playing without synchronization*//**<CNcomment: PCR */
+    HI_UNF_SYNC_REGION_S  stSyncStartRegion;     /**<Synchronization start region*//**<CNcomment:  */
+    HI_UNF_SYNC_REGION_S  stSyncNovelRegion;     /**<Synchronization exception region*//**<CNcomment:  */
+    HI_S32                s32VidPtsAdjust;       /**<Video presentation time stamp (PTS) adjustment*//**<CNcomment: PTS */
+    HI_S32                s32AudPtsAdjust;       /**<Audio PTS adjustment*//**<CNcomment: PTS */
+
+    HI_U32                u32PreSyncTimeoutMs;   /**<Pre-synchronization timeout, in ms*//**<CNcomment:  */
+    HI_BOOL               bQuickOutput;          /**<Fast output enable*//**<CNcomment:  */
+} HI_UNF_SYNC_ATTR_S;
+
+/**Defines the playing attributes of an AVPLAY.*/
+/**CNcomment: AV */
+typedef struct hiUNF_AVPLAY_ATTR_S
+{
+    HI_U32                       u32DemuxId;   /**<ID of the DEMUX used by an AVPLAY*//**<CNcomment: AVPLAYDEMUX ID TS */
+    HI_UNF_AVPLAY_STREAM_ATTR_S  stStreamAttr; /**<Stream attributes*//**<CNcomment:  */
+} HI_UNF_AVPLAY_ATTR_S;
+
+/**Defines the synchronization status when an AVPLAY is running.*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_STATUS_S
+{
+    HI_U32 u32FirstAudPts;    /**<PTS of the first audio frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32FirstVidPts;    /**<PTS of the first video frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32LastAudPts;     /**<PTS of the last audio frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32LastVidPts;     /**<PTS of the last video frame*//**<CNcomment:  PTS .*/
+    HI_S32 s32DiffAvPlayTime; /**<Playing time difference between audio and video frames*//**<CNcomment:   .*/
+    HI_U32 u32PlayTime;       /**<Playing time*//**<CNcomment:  .*/
+    HI_U32 u32LocalTime;      /**<Local synchronization reference time*//**<CNcomment:  .*/
+} HI_UNF_SYNC_STATUS_S;
+
+/**Defines the status of a media buffer.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_BUF_STATUS_S
+{
+    HI_U32 u32BufId;                /**<Media buffer ID*//**<CNcomment:   */
+    HI_U32 u32BufSize;              /**<Media buffer size*//**<CNcomment:  */
+    HI_U32 u32BufRptr;              /*Read pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: ,Ts */
+    HI_U32 u32BufWptr;              /*Write pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: ,Ts */
+    HI_U32 u32UsedSize;             /**<Used size of the media buffer*//**<CNcomment:  */
+    HI_U32 u32CurrentAvailableSize; /**<Current available size of the media buffer for HI_UNF_AVPLAY_GetBuf()*//**<CNcomment:  */
+    HI_U32 u32FrameBufTime;         /**<Frame buffer time*//**<CNcomment:  */
+    HI_U32 u32FrameBufNum;          /**<The number of frames in frame buffer*//**<CNcomment:  VIDEO */
+    HI_BOOL bEndOfStream;           /**<Flag to indicate end of stream*//**<CNcomment:  VIDEO */
+} HI_UNF_AVPLAY_BUF_STATUS_S;
+
+/**Defines the playing status of an AVPLAY.*/
+/**CNcomment:AV */
+typedef enum hiUNF_AVPLAY_STATUS_E
+{
+    HI_UNF_AVPLAY_STATUS_STOP = 0,  /**<Stop*/      /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_PREPLAY,   /**<Buffer*/    /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_PLAY,      /**<Play*/      /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_TPLAY,     /**<Trick play, such as fast forward and rewind*/   /**<CNcomment: TPlay,  */
+    HI_UNF_AVPLAY_STATUS_PAUSE,     /**<Pause*/     /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_EOS,       /**<EOS*/       /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_SEEK ,     /**<Seek play*/ /**<CNcomment:  */
+
+    HI_UNF_AVPLAY_STATUS_BUTT
+} HI_UNF_AVPLAY_STATUS_E;
+
+/**Defines the output value after the playing status of an AVPLAY is queried.*/
+/**CNcomment:AV */
+typedef struct hiUNF_AVPLAY_STATUS_INFO_S
+{
+    HI_UNF_SYNC_STATUS_S       stSyncStatus;      /**<Synchronization status*//**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_E     enRunStatus;       /**<Running status*//**< CNcomment: */
+    HI_U32                     u32VidFrameCount;  /**<Count of played video frames*//**<CNcomment:  */
+    HI_U32                     u32AuddFrameCount; /**<Count of played audio frames*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATUS_S stBufStatus[HI_UNF_AVPLAY_BUF_ID_BUTT]; /**<Status of the media buffer*//**<CNcomment: */
+    HI_U32                     u32VidErrorFrameCount; /**<Number of error frames during video decoding*/ /**<CNcomment:  */
+    HI_U32                     u32AudErrorFrameCount; /**<Number of error frames during audio decoding*//**<CNcomment:  */
+} HI_UNF_AVPLAY_STATUS_INFO_S;
+
+/**Defines the information about the playing program streams to be queried.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_STREAM_INFO_S
+{
+    HI_UNF_VCODEC_STREAMINFO_S stVidStreamInfo; /**<Video stream information*//**<CNcomment: */
+    HI_UNF_ACODEC_STREAMINFO_S stAudStreamInfo; /**<Audio stream information*//**<CNcomment: */
+} HI_UNF_AVPLAY_STREAM_INFO_S;
+
+/**Defines the information about an I frame.*//**CNcomment:I */
+typedef struct hiUNF_AVPLAY_I_FRAME_S
+{
+    HI_U8                *pu8Addr;    /**<User-state virtual address of a frame*//**<CNcomment: */
+    HI_U32               u32BufSize; /**<Frame size, in byte*//**<CNcomment: */
+    HI_UNF_VCODEC_TYPE_E enType;     /*Protocol type of a data segment*//**<CNcomment: */
+} HI_UNF_AVPLAY_I_FRAME_S;
+
+/**Defines the decoder type. The occupied memory varies according to decoders.*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VCODEC_DEC_TYPE_E
+{
+    HI_UNF_VCODEC_DEC_TYPE_NORMAL,            /**<Normal type.*//**<CNcomment: */
+
+    /**<I frame decoding type. If an AVPLAY is used to decode I frames only (HI_UNF_AVPLAY_DecodeIFrame), you can select this type to reduce the memory usage.*/
+    /**<CNcomment:I avplayI(HI_UNF_AVPLAY_DecodeIFrame)  */
+    HI_UNF_VCODEC_DEC_TYPE_ISINGLE,
+
+    HI_UNF_VCODEC_DEC_TYPE_BUTT
+}HI_UNF_VCODEC_DEC_TYPE_E;
+
+/**Defines the level of the protocol supported by the decoder. This value affects the number of frame buffers allocated by the normal decoder.
+The greater the value, the more the required frame buffers.*/
+/**CNcomment: NORMAL  */
+typedef enum hiHI_UNF_VCODEC_PRTCL_LEVEL_E
+{
+    HI_UNF_VCODEC_PRTCL_LEVEL_MPEG = 0,     /**<All protocols except MVC *//**<CNcomment:MVC */
+    HI_UNF_VCODEC_PRTCL_LEVEL_H264 = 1,     /**<Same as HI_UNF_VCODEC_PRTCL_LEVEL_MPEG now *//**<CNcomment:HI_UNF_VCODEC_PRTCL_LEVEL_MPEG*/
+    HI_UNF_VCODEC_PRTCL_LEVEL_MVC,
+    HI_UNF_VCODEC_PRTCL_LEVEL_BUTT
+}HI_UNF_VCODEC_PRTCL_LEVEL_E;
+
+/**Defines the attributes when an AVPLAY enables the video decoder. The settings affect the memory occupied by the video decoder and decoding performance.*/
+/**CNcomment:AV  */
+typedef struct hiHI_UNF_AVPLAY_OPEN_OPT_S
+{
+    HI_UNF_VCODEC_DEC_TYPE_E    enDecType;       /**<Decoder type.*//**<CNcomment:*/
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;      /**<Maximum resolution supported by the decoder. This value affects the size of each frame buffer.*//**<CNcomment:  */
+    HI_UNF_VCODEC_PRTCL_LEVEL_E enProtocolLevel; /**<Supported protocol level. This value affects the number of frame buffers.*//**<CNcomment:  */
+}HI_UNF_AVPLAY_OPEN_OPT_S;
+
+/**Defines the attribute of MS12.*/
+/**CNcomment: MS12*/
+typedef struct hiUNF_AVPLAY_AD_ATTR_S
+{
+    HI_BOOL             bAdEnble;       /**<whether enable ad service (on/off)*/ /**<CNcomment: AD.*/
+    HI_BOOL             bAdToSomePort;  /**<whether enable ad only to some port,such as speaker/headphone etc*/ /**<CNcomment: false.*/
+    HI_U32              u32AdPid;       /**<AD program id*/ /**<CNcomment: ADPID.*/
+    HI_S16              s16AdBalance;   /**<AD Balance*/ /**<CNcomment: AD.*/
+} HI_UNF_AVPLAY_AD_ATTR_S;
+
+/**Defines the attribute of HDR.*/
+/**CNcomment: HDR*/
+typedef struct hiUNF_AVPLAY_HDR_ATTR_S
+{
+    HI_BOOL                           bEnable;          /**<Is Dolby HDR enable or not*/ /**<CNcomment: Dolby HDR.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_E   enHDRStreamType;  /**<Dolby Vision VES Format*/ /**<CNcomment: Dolby HDR.*/
+    HI_UNF_VCODEC_TYPE_E              enElType;         /**<Video encoding type*/ /**<CNcomment: EL*/
+    HI_UNF_AVPLAY_OPEN_OPT_S          stElCodecOpt;     /**<Video decoding option*/ /**<CNcomment: */
+    HI_BOOL                           bCompatible;      /**<Dolby frame is compatible or not.*/ /**<CNcomment: Dolby.*/
+} HI_UNF_AVPLAY_HDR_ATTR_S;
+
+/**Defines the video display mode after an AVPLAY is stopped.*/
+/**CNcomment:AV */
+typedef enum hiUNF_AVPLAY_STOP_MODE_E
+{
+    HI_UNF_AVPLAY_STOP_MODE_STILL = 0,  /**<The last frame is still after an AVPLAY is stopped.*//**<CNcomment:stop */
+    HI_UNF_AVPLAY_STOP_MODE_BLACK = 1,  /**<The blank screen is displayed after an AVPLAY is stopped.*//**<CNcomment:stop */
+    HI_UNF_AVPLAY_STOP_MODE_BUTT
+} HI_UNF_AVPLAY_STOP_MODE_E;
+
+
+/**Defines the attributes when an AVPLAY is prestarted.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PRESTART_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTART_OPT_S;
+
+/**Defines the attributes when an AVPLAY is started.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_START_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_START_OPT_S;
+
+/**Defines the attributes when an AVPLAY is prestoped.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PRESTOP_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTOP_OPT_S;
+
+
+/**Defines the attributes when an AVPLAY is stopped.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_STOP_OPT_S
+{
+    /*
+         s32Timeout: end of stream timeout
+         s32Timeout = 0   Wait until streams are played in non-block mode, that is, the interface is returned immediately. CNcomment: CNend
+         s32Timeout > 0   Block timeout, in ms, CNcomment: CNend
+         s32Timeout = -1  Infinite wait,CNcomment: CNend
+     */
+    HI_U32                    u32TimeoutMs;    /**<Timeout*//**<CNcomment: */
+    HI_UNF_AVPLAY_STOP_MODE_E enMode;          /**<Video display mode*//**<CNcomment: */
+} HI_UNF_AVPLAY_STOP_OPT_S;
+
+/*Defines the attributes when an AVPLAY is paused.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PAUSE_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PAUSE_OPT_S;
+
+/**Defines the direction of tplay*/
+/**CNcomment:AVTPLAY */
+typedef enum hiUNF_AVPLAY_TPLAY_DIRECT_E
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_FORWARD,     /**<Tplay forward*//**<CNcomment: TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BACKWARD,    /**<Tplay backward*//**<CNcomment: TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BUTT
+
+} HI_UNF_AVPLAY_TPLAY_DIRECT_E;
+
+/**Defines the attributes when the playing mode of an AVPLAY is tplay.*/
+/**CNcomment:AVTPALY */
+typedef struct hiAVPLAY_TPLAY_OPT_S
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_E    enTplayDirect;      /**<Tplay direction*//**<CNcomment: TPLAY */
+    HI_U32                          u32SpeedInteger;    /**<Integral part of tplay speed*//**<CNcomment: TPLAY */
+    HI_U32                          u32SpeedDecimal;    /**<Fractional part (calculated to three decimal places) of tplay speed*//**<CNcomment: TPLAY3 */
+} HI_UNF_AVPLAY_TPLAY_OPT_S;
+
+/**Defines the attributes when an AVPLAY is resumed.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_RESUME_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_RESUME_OPT_S;
+
+/**Defines the attributes when an AVPLAY is reset.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_RESET_OPT_S
+{
+    HI_U32        u32SeekPtsMs;   /**<clear these datas which pts is smaller than u32SeekPtsMs in buffer *//**<CNcomment:bufferu32SeekPtsMs */
+} HI_UNF_AVPLAY_RESET_OPT_S;
+
+/**Defines the attributes when an AVPLAY is step.*/
+/**CNcomment:AV */
+typedef struct hiUNF_AVPLAY_STEP_OPT_S
+{
+    HI_U32       u32Reserved;
+}HI_UNF_AVPLAY_STEP_OPT_S;
+
+/**Defines the attributes when an AVPLAY is in Flushing Stream Status.*/
+/**CNcomment:AVFlush Stream */
+typedef struct hiUNF_AVPLAY_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S;
+
+/**Defines the attributes of multiple audio.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_MULTIAUD_ATTR_S
+{
+    HI_U32                  u32PidNum;      /**<the number of Audio PID *//**< CNcomment:PID */
+    HI_U32                  *pu32AudPid;    /**<Pointer to the array of audio PID*//**< CNcomment:PID */
+    HI_UNF_ACODEC_ATTR_S    *pstAcodecAttr; /**<Pointer to the array of audio attribute*//**< CNcomment: */
+}HI_UNF_AVPLAY_MULTIAUD_ATTR_S;
+
+/**Defines the source of frame rate.*/
+/**CNcomment:  */
+typedef enum hiUNF_AVPLAY_FRMRATE_TYPE_E
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_PTS,         /**<Use the frame rate calculates from PTS*//**<CNcomment: PTS */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_STREAM,      /**<Use the frame rate comes from stream*//**<CNcomment:  */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER,        /**<Use the frame rate set by user*//**<CNcomment:  */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER_PTS,    /**<Use the frame rate set by user until the 2nd I frame comes, then use the frame rate calculates from PTS*//**<CNcomment: IPTS */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_BUTT
+}HI_UNF_AVPLAY_FRMRATE_TYPE_E;
+
+/**Defines the parameter of frame rate.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_FRMRATE_PARAM_S
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_E    enFrmRateType;  /**<The source of frame rate*//**<CNcomment:  */
+    HI_UNF_VCODEC_FRMRATE_S         stSetFrmRate;   /**<Setting frame rate*//**<CNcomment:  */
+}HI_UNF_AVPLAY_FRMRATE_PARAM_S;
+
+/**Defines commond to get vdec information, the parameter is HI_UNF_AVPLAY_VDEC_INFO_S.*/
+/**CNcomment: HI_UNF_AVPLAY_VDEC_INFO_S */
+#define HI_UNF_AVPLAY_GET_VDEC_INFO_CMD         0x20
+/**Defines commond to set TPLAY parameter, the parameter is HI_UNF_AVPLAY_TPLAY_OPT_S.*/
+/**CNcomment: TPLAYHI_UNF_AVPLAY_TPLAY_OPT_S*/
+#define HI_UNF_AVPLAY_SET_TPLAY_PARA_CMD        0x21
+/**Defines commond to set special control information of stream, the parameter is HI_UNF_AVPLAY_CONTROL_INFO_S*/
+/**CNcomment: HI_UNF_AVPLAY_CONTROL_INFO_S*/
+#define HI_UNF_AVPLAY_SET_CTRL_INFO_CMD         0x22
+
+/**Defines commond to set video sample type, HI_BOOL *, HI_TRUE: force Progressive, HI_FALSE: auto recognise Progressive or Interlance */
+/**CNcomment: , HI_TRUE: , HI_FALSE: */
+#define HI_UNF_AVPLAY_SET_PROGRESSIVE_CMD       0x23
+
+/**Defines commond to set video color space, the parameter is HI_UNF_COLOR_SPACE_E*/
+/**CNcomment: , HI_UNF_COLOR_SPACE_E*/
+#define HI_UNF_AVPLAY_SET_COLORSPACE_CMD        0x24
+
+/**Defines commond to set dpb full control, HI_BOOL* ,HI_TRUE:force delete min poc frame when dpb is full,HI_FALSE:return error when dpb is full*/
+/**CNcomment:dpb, HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_DPBFULL_CTRL_CMD      0x25
+
+/***fix  videophone scene by AVPLAY ,  format MJPEG**/
+#define HI_UNF_AVPLAY_SET_SCENE_MODE_CMD        0x26
+
+/***Defines commond to get vdec handle, the parameter is HI_U32**/
+#define HI_UNF_AVPLAY_GET_VDEC_HANDLE_CMD       0x28
+
+/**Defines the mode of videophone.*/
+/**CNcomment: Videophone  */
+typedef enum hiUNF_AVPLAY_SCENE_MODE_E
+{
+   HI_UNF_AVPLAY_SCENE_MODE_NORMAL,     /**<Normal scene of non-voip*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_PREVIEW,   /**<Voip scene of the local end*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_REMOTE,   /**<Voip scene of the remote end*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_BUTT,
+} HI_UNF_AVPLAY_SCENE_MODE_E;
+
+
+/**Defines the type of AVPLAY invoke.*/
+/**CNcomment: AVPLAY Invoke */
+typedef enum hiUNF_AVPLAY_INVOKE_E
+{
+    HI_UNF_AVPLAY_INVOKE_ACODEC  = 0,   /**<Invoke commond to control audio codec*//**<CNcomment: Invoke */
+    HI_UNF_AVPLAY_INVOKE_VCODEC,        /**<Invoke commond to control video codec, HI_CODEC_VIDEO_CMD_S*//**<CNcomment: Invoke */
+    HI_UNF_AVPLAY_INVOKE_GET_PRIV_PLAYINFO, /**<Invoke commond to get private play infomation,the parameter is HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S*//**<CNcomment: Invoke HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S * */
+    HI_UNF_AVPLAY_INVOKE_SET_DISP_OPTIMIZE_FLAG, /**Defines commond to set Display Optimize Flag, The Parameter is HI_U32, 1: Enable, 0: Disable */
+    HI_UNF_AVPLAY_INVOKE_GET_GLOBAL_PLAYINFO,   /**<Get global play information of avplay*//**<CNcomment: AVPLAY */
+    HI_UNF_AVPLAY_INVOKE_SET_SYNC_MODE,  /**<Invoke commond to set sync mode, HI_U32, 0 normal sync, 1 use sync replace frc*//**<CNcomment: HI_U320: , 1: */
+    HI_UNF_AVPLAY_INVOKE_BUTT
+} HI_UNF_AVPLAY_INVOKE_E;
+
+/**Defines the decoding information of video codec.*/
+/**CNcomment: VDEC */
+typedef struct hiUNF_AVPLAY_VDEC_INFO_S
+{
+    HI_U32                  u32DispFrmBufNum;   /**<the number of display frame*//**<CNcomment:  */
+    HI_U32                  u32FieldFlag;       /**<The encoding mode of image, 0 frame mode, 1 filed mode*//**<CNcomment: , 0 1  */
+    HI_UNF_VCODEC_FRMRATE_S stDecFrmRate;      /**<decoding frame rate*//**<CNcomment:  */
+    HI_U32                  u32UndecFrmNum;     /**<the number of undecoded frame*//**<CNcomment:  */
+}HI_UNF_AVPLAY_VDEC_INFO_S;
+
+/**Defines the private status information.*/
+/**CNcomment: AVPLAY */
+typedef struct hiUNF_AVPLAY_PRIVATE_STATUS_INFO_S
+{
+    HI_U32 u32LastPts;   /**<PTS of the last audio or video frame*/ /**<CNcomment:  PTSPTS*/
+    HI_U32 u32LastPlayTime; /**< PlayTime of the last audio or video frame */ /**<CNcomment:  PlayTimePlayTime  */
+    HI_U32 u32DispOptimizeFlag; /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: */
+} HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S;
+
+/**Defines the special control information of stream.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_CONTROL_INFO_S
+{
+    HI_U32 u32IDRFlag;               /**<IDR frame Flag, 1 means IDR(instantaneous decoding refresh) frame.*/ /**<CNcomment: IDR()1*/
+    HI_U32 u32BFrmRefFlag;           /**<Whether B frame is refer frame, 1 means B frame is refer frame.*/ /**<CNcomment: B1*/
+    HI_U32 u32ContinuousFlag;        /**<Whether send frame is continusous. 1 means continusous*/ /**<CNcomment: 1*/
+    HI_U32 u32BackwardOptimizeFlag;  /**<The Backward Optimize Flag*//**<CNcomment: .*/
+    HI_U32 u32DispOptimizeFlag;      /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: */
+}HI_UNF_AVPLAY_CONTROL_INFO_S;
+
+/**Defines the parameter when the stream is send by HI_UNF_AVPLAY_PutBufEx.*/
+/**CNcomment: PutBufEx */
+typedef struct hiUNF_AVPLAY_PUTBUFEX_OPT_S
+{
+    HI_BOOL bEndOfFrm;      /**<whether this package of stream is the end of one frame*//**<CNcomment:  */
+    HI_BOOL bContinue;      /**<whether this package of stream is contnued with the last package*//**<CNcomment:  */
+}HI_UNF_AVPLAY_PUTBUFEX_OPT_S;
+
+typedef struct hiUNF_AVPLAY_GLOBAL_PLAY_INFO_S
+{
+    HI_U32 u32ContentCount;
+} HI_UNF_AVPLAY_GLOBAL_PLAY_INFO_S;
+
+typedef struct hiUNF_AVPLAY_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32AspectWidth;     /**<aspect ratio: width*/ /**<CNcomment: */
+    HI_U32                              u32AspectHeight;    /**<aspect ratio: height*/ /**<CNcomment: */
+    HI_U32                              u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32                              u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+} HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S;
+
+/**Defines the avplay video start position .*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_START_POSITION_ATTR_S
+{
+    HI_U32                              u32StartPosPts;     /**<Start play Pts*/ /**<CNcomment: Pts*/
+    HI_U32                              u32IdrPts;          /**<Instantaneous Decoding Refresh Pts */ /**<CNcomment: IPts*/
+}HI_UNF_AVPLAY_START_POSITION_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**
+\brief Initializes the AVPLAY module.CNcomment:AVPLAY CNend
+\attention \n
+Before calling ::HI_UNF_AVPLAY_Create to create an AVPLAY, you must call this application programming interface (API).
+CNcomment AVPLAY CNend
+\param  N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NOT_EXIST There is no AVPLAY. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NOT_DEV_FILE  The file is not an AVPLAY file. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_DEV_OPEN_ERR  An AVPLAY fails to be started. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Init(HI_VOID);
+
+/**
+\brief Deinitializes the AVPLAY module. CNcomment:AVPLAY CNend
+\attention \n
+Please call this API function, before call anyother API of AVPLAY module.
+CNcomment: ::HI_UNF_AVPLAY_Destroy CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT  The operation is invalid.  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_CLOSE_ERR  An AVPLAY fails to be stopped. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DeInit(HI_VOID);
+
+/**
+\brief Get video frame info. CNcomment: CNend
+\attention \n
+\param[out] pstVideoFrameInfo  Pointer to video frame info. For details, see the description of ::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNcomment:::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNend
+\param[in] hAvplay    AVPLAY handle . CNcomment:AVPLAY . CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The pointer is null.  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_FAILURE  Failure. CNcomment:. CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetVideoFrameInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S *pstVideoFrameInfo);
+
+/**
+\brief Obtains the default configuration of an AVPLAY. CNcomment:AV CNend
+\attention \n
+When calling this API to set the enCfg parameter, you must enter correct mode of the player to be created.\n
+It is recommended that you call this API to obtain the default AVPLAY attributes before creating an AVPLAY. This avoids creation failures due to incomplete or incorrect parameters.
+CNcomment:enCfg\n
+AVAVAV CNend
+\param[out] pstAvAttr  Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment: AV::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[in] enCfg       AVPLAY type. For details, see the description of ::HI_UNF_AVPLAY_STREAM_TYPE_E. CNcomment: AV::HI_UNF_AVPLAY_STREAM_TYPE_E. CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_UNF_AVPLAY_STREAM_TYPE_E enCfg);
+
+/**
+\brief Registers a dynamic audio decoding library. CNcomment: CNend
+\attention \n
+\param[in] pFileName Name of the file in the audio decoding library CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterAcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Registers a dynamic video decoding library. CNcomment: CNend
+\attention \n
+\param[in] pFileName Name of the file in the video decoding library CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterVcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Searches for registered dynamic audio decoding libraries based on the audio format.
+CNcomment:,  CNend
+\attention \n
+\param[in] enFormat Audio format CNcomment: CNend
+\param[out] penDstCodecID If an audio decoding library is found, its codec ID is returned.
+CNcomment:CodecID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FoundSupportDeoder(const HA_FORMAT_E enFormat,HI_U32 * penDstCodecID);
+
+
+/**
+\brief Sets private commands for a dynamic audio decoding library. These commands are used to call ha_codec.
+CNcomment:, ha_codec   CNend
+HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID * hDecoder, HI_VOID * pstConfigStructure);
+\attention \n
+\param[in] enDstCodecID  The audio Codec ID  CNcomment:ID CNend
+\param[in] pPara  Attribute structure CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ConfigAcodec(const HI_U32 enDstCodecID, HI_VOID *pPara);
+
+/**
+\brief Creates an AVPLAY. CNcomment:AV CNend
+\attention \n
+Note the following point when setting the input parameter pstAttr: The stream source can be HI_UNF_AVPLAY_STREAM_TYPE_ES (ESs input from the memory) or HI_UNF_AVPLAY_STREAM_TYPE_TS (ESs input from the memory and TSs input from the Tuner).
+CNcomment:pstAttrHI_UNF_AVPLAY_STREAM_TYPE_ESESHI_UNF_AVPLAY_STREAM_TYPE_TSTSTUNERTS CNend
+\param[in]  pstAvAttr   Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment:AV::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[out] phAvplay    Pointer to the handle of a created AVPLAY.CNcomment:AV CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_CREATE_ERR       The AVPLAY fails to be created. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_HANDLE *phAvplay);
+
+/**
+\brief Destroys an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay);
+
+/**
+\brief Sets the attributes of an AVPLAY. CNcomment:AV CNend
+\attention \n
+You can set the audio/video PID, audio/video decoding type, and synchronization mode by calling this API.\n
+Different attribute IDs correspond to different data types. For details, see the Note part of HI_UNF_AVPLAY_ATTR_ID_E. The attribute types of the pPara and enAttrID parameters must be the same.\n
+Before setting HI_UNF_AVPLAY_ATTR_ID_ADEC (audio decoding attribute) and HI_UNF_AVPLAY_ATTR_ID_VDEC (video decoding attribute),\n
+you must disable the audio channel or video channel. The new attributes take effect when you enable the audio channel or video channel again.
+CNcomment:PID\n
+IDHI_UNF_AVPLAY_ATTR_ID_E[], pParaenAttrID\n
+HI_UNF_AVPLAY_ATTR_ID_ADEC(),HI_UNF_AVPLAY_ATTR_ID_VDEC()\n
+ CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] enAttrID        Attribute ID CNcomment:ID CNend
+\param[in] pPara  Data type corresponding to an attribute ID CNcomment:ID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Obtains the attributes of an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay          AVPLAY handle CNcomment:AV CNend
+\param[in] enAttrID         Attribute ID CNcomment:ID CNend
+\param[in] pPara   Data type corresponding to an attribute ID, CNcomment:ID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Decodes I frames. CNcomment:I CNend
+\attention \n
+If pstCapPicture is null, the decoded I frames are displayed in the window,and do not need release memory; \n
+if pstCapPicture is not null, the information about I frames is reported, and need invoke ::HI_UNF_AVPLAY_ReleaseIFrame to release memory.
+You must stop the video decoder before calling this API. If I frames are being processed, do not enable the video decoder.
+CNcomment:pstCapPictureIwindowI,IHI_UNF_AVPLAY_ReleaseIFrameI
+I CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] pstFrame        Pointer to frame attributes CNcomment: CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DecodeIFrame(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_I_FRAME_S *pstFrame, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Release memory of I frame. CNcomment:I CNend
+\attention \n
+If you call HI_UNF_AVPLAY_DecodeIFrame with non-null pstCapPicture, you need call this API to release the memory.
+CNcomment:HI_UNF_AVPLAY_DecodeIFramepstCapPicture CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ReleaseIFrame(HI_HANDLE hAvplay, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Sets the mode of a video decoder. CNcomment: CNend
+\attention \n
+This API is used in trick play mode. Before switching the mode to the trick play mode, you must enable a decoder to decode only I frames by calling this API.\n
+Before switching the mode to the normal mode, you also need to set the mode of a decoder to normal by calling this API.
+CNcomment:I\n
+NORMAL CNend
+\param[in] hAvplay            AVPLAY handle CNcomment:AV CNend
+\param[in] enDecodeMode       Decoding mode CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetDecodeMode(HI_HANDLE hAvplay, HI_UNF_VCODEC_MODE_E enDecodeMode);
+
+/**
+\brief Registers an event on 32bit system. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent     Event type enumeration CNcomment: CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB);
+/**
+\brief Registers an event on 64bit system. CNcomment:64 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent     Event type enumeration CNcomment: CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent64(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN64 pfnEventCB);
+
+/**
+\brief Deregisters an event. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent   Event type enumeration CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent);
+
+/**
+\brief Enables an AVPLAY channel. CNcomment:AV CNend
+\attention \n
+You can enable an audio channel and a video channel for each AVPLAY. If you only need to play videos or audios, you can enable the corresponding channel to save resources.
+CNcomment:AV1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pPara    Pointer type. For details, see the description of ::HI_UNF_AVPLAY_OPEN_OPT_S. CNcomment:::HI_UNF_AVPLAY_OPEN_OPT_S. CNend
+    If enChn is set to HI_UNF_AVPLAY_MEDIA_CHAN_VID, this API is used to specify the maximum decoding performance of the video decoder.
+    If enChn is set to NULL, the maximum performance H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD is used by default.
+    The higher the configured decoding performance, the larger the required MMZ. It is recommended that you configure the performance as required.
+    CNcomment:enChnHI_UNF_AVPLAY_MEDIA_CHAN_VID
+    NULL: H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD
+    MMZ CNend
+\retval ::HI_SUCCESS Success             CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_VOID *pPara);
+
+/**
+\brief Disables an AVPLAY channel. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV CNend
+\param[in] enChn     Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn);
+
+/**
+\brief Start an AVPLAY to prepare play mode, which just demux ts stream. CNcomment:TSPREPLAY CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in prepare play mode. The audios and videos can be prepared play separately or simultaneously.
+CNcomment:PREPLAY CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:NULL. CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStart(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTART_OPT_S *pstPreStartOpt);
+
+/**
+\brief Starts an AVPLAY. The AVPLAY is in play mode. CNcomment:PLAY CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in play mode. The audios and videos can be played separately or simultaneously.
+CNcomment:PLAY CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:NULL. CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt);
+
+/**
+\brief Stop an AVPLAY to prepare stop mode,the interface is reserved for future use. CNcomment:AVPRESTOP, CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStopOpt   Pointer to stop mode. For details, see the description of ::HI_UNF_AVPLAY_PRESTOP_OPT_S. CNcomment:::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_ERR_AVPLAY_NOT_SUPPORT not support for the moment  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTOP_OPT_S *pstPreStopOpt);
+
+/**
+\brief Stops an AVPLAY. Then the AVPLAY is in stop mode. CNcomment:AVSTOP CNend
+\attention \n
+If you call this API, all selected channels stop playing. The playing audios and videos can be stopped separately or simultaneously.\n
+The parameter pstStopOpt->enMode takes effect only when a video channel is selected.\n
+If pstStopOpt->enMode is set to NULL or HI_UNF_AVPLAY_STOP_MODE_STILL, the last frame is kept still.\n
+If pstStopOpt->enMode is set to HI_UNF_AVPLAY_STOP_MODE_BLACK, the last frame is cleared, and the blank screen appears.\n
+When pstStopOpt->u32TimeoutMs is 0, the AVPLAY stops and this API is returned.\n
+When pstStopOpt->u32TimeoutMs is greater than 0, this API is blocked until the data in the buffer is used up.\n
+When pstStopOpt->u32TimeoutMs is greater than -1, this API is blocked until the data in the buffer is used up.\n
+To stop the audio or video separately when both the audio and video are enabled, you must set pstStopOpt->u32TimeoutMs to 0.
+CNcomment:\n
+pstStopOpt->enMode\n
+pstStopOpt->enModeHI_UNF_AVPLAY_STOP_MODE_STILL\n
+pstStopOpt->enModeHI_UNF_AVPLAY_STOP_MODE_BLACK\n
+pstStopOpt->u32TimeoutMs0\n
+pstStopOpt->u32TimeoutMs>0\n
+pstStopOpt->u32TimeoutMs=-1\n
+,pstStopOpt->u32TimeoutMs0. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStopOpt   Pointer to the clear screen mode. For details, see the description of ::HI_UNF_AVPLAY_STOP_OPT_S. CNcomment:::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Pauses an AVPLAY. Then the AVPLAY is in pause mode. CNcomment:AVPAUSE CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment: AV CNend
+\param[in] pstPauseOpt  Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt);
+
+/**
+\brief Plays videos or audios in trick play mode. Then the AVPLAY is in TPLAY mode. CNcomment:TPLAY CNend
+\attention \n
+pstTplayOpt->u32SpeedInteger is the integer part of speed, the range is 0-64.
+pstTplayOpt->u32SpeedDecimal is the decimal part of speed, the range is 0-999.
+CNcomment: pstTplayOpt->u32SpeedInteger0-64. CNend
+CNcomment: pstTplayOpt->u32SpeedDecimal30-999. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment: AV CNend
+\param[in] pstTplayOpt   The pointer of Tplay parameter,For details, see the description of ::HI_UNF_AVPLAY_TPLAY_OPT_S . CNcomment:TPLAY,HI_UNF_AVPLAY_TPLAY_OPT_S CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Tplay(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_TPLAY_OPT_S *pstTplayOpt);
+
+/**
+\brief Resumes an AVPLAY. Then the AVPLAY is in play mode. CNcomment:AVPLAY CNend
+\attention \n
+By calling this API, you can resume an AVPLAY from the trick play mode or pause mode rather than the stop mode.
+CNcomment: CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstResumeOpt  Pointer used for expansion. You can set it to NULL. CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt);
+
+/**
+\brief Resets an AVPLAY. In this case, the play mode is not changed. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstResetOpt   Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Reset(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESET_OPT_S *pstResetOpt);
+
+/**
+\brief Step play. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstStepOpt   Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Step(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_STEP_OPT_S *pstStepOpt);
+
+/**
+\brief Applies for a buffer for storing the streams played by an AVPLAY. CNcomment:AV CNend
+\attention \n
+This API is used only when you want to play the ESs obtained from Internet or local ESs.\n
+The pstData parameter is used to return the start address and size of the buffer applied for.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates that the API waits for an infinite time; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, an error code indicating full buffer is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the audio and video buffers are full. In this case, you need to call the usleep(N*1000) function to release the CPU.
+Therefore, other threads can be scheduled.
+CNcomment:ES\n
+pstDataBuffer\n
+u32TimeOutMs00xffffffffu32TimeOutMs\n
+Bufferbuffer\n
+u32TimeOutMs0BufferBufferusleep(N*1000)cpu
+ CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID CNend
+\param[in] u32ReqLen   Size of the buffer applied for CNcomment: CNend
+\param[out] pstData    Pointer to the returned buffer CNcomment: CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms CNcomment:ms. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay,
+                            HI_UNF_AVPLAY_BUFID_E enBufId,
+                            HI_U32                u32ReqLen,
+                            HI_UNF_STREAM_BUF_S  *pstData,
+                            HI_U32                u32TimeOutMs);
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment: CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:\n
+PTSu32ptsMs-1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID. CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment: CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:, CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                         HI_U32 u32ValidDataLen, HI_U32 u32PtsMs);
+
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment: CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:, \n
+PTSu32ptsMs-1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment: CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:, CNend
+\param[in] pPutOpt   the extern parameter of PutBufEx, see the description of ::HI_UNF_AVPLAY_PUTBUFEX_OPT_S.CNcomment:PutBufEx::HI_UNF_AVPLAY_PUTBUFEX_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBufEx(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                                       HI_U32 u32ValidDataLen, HI_U32 u32Pts, HI_UNF_AVPLAY_PUTBUFEX_OPT_S *pPutOpt);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TSAVDMXHandle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMXHandle CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAudChn);
+
+/**
+\brief Obtains the handle of the DMX video channel used by an AVPLAY in TS mode. CNcomment:TSAVDMXHandle. CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] phDmxVidChn    Pointer to the handle of a DMX video channel CNcomment:DMXHandle CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxVidChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxVidChn);
+
+
+/**
+\brief Obtains the status information about an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[out] pstStatusInfo  Pointer to the status of an AVPLAY. For details, see the description of HI_UNF_AVPLAY_STATUS_INFO_S. CNcomment:AVHI_UNF_AVPLAY_STATUS_INFO_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE          hAvplay,
+                                 HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo);
+
+
+/**
+\brief Obtains the information about audio and video streams. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[in] pstStreamInfo     Pointer to the information about audio and video streams. For details, see the description of HI_UNF_AVPLAY_STREAM_INFO_S. CNcomment:HI_UNF_AVPLAY_STREAM_INFO_S CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE          hAvplay,
+                                   HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo);
+
+/**
+\brief Obtains the information audio spectrums. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[in] pSpectrum      Pointer to the array of audio spectrums. CNcomment: CNend
+\param[in] u32BandNum     Length of an audio spectrum array CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAudioSpectrum(HI_HANDLE hAvplay, HI_U16 *pSpectrum, HI_U32 u32BandNum);
+
+/**
+\brief Queries whether the AVPLAY buffer is empty. CNcomment:AVPLAY buffer CNend
+\attention \n
+N/A
+\param[in] hAvplay        AVPLAY handle CNcomment:AV CNend
+\param[out] pbIsEmpty      Pointer type. This pointer indicates whether the AVPLAY buffer is empty (the playing ends). CNcomment:buffer() CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsBuffEmpty(HI_HANDLE hAvplay, HI_BOOL * pbIsEmpty);
+
+/**
+\brief Switch the demux audio channel CNcomment:DEMUX CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] hNewDmxAud     New demux audio handle CNcomment:DMX CNend
+\param[out] phOldDmxAud     Old  demux audio handle CNcomment:DMX CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchDmxAudChn(HI_HANDLE hAvplay, HI_HANDLE hNewDmxAud, HI_HANDLE *phOldDmxAud);
+
+/**
+\brief Notify an AVPLAY the stream is end CNcomment:AVPLAY CNend
+\attention \n
+Call this interface to notice AVPLAY when the last package of stream has been sent,
+then check whether the last frame has been output by eos event or by invoking ::HI_UNF_AVPLAY_IsBuffEmpty,
+this interface is only apply to ES mode.
+CNcomment: AVPLAYEOS::HI_UNF_AVPLAY_IsBuffEmpty
+ES CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstFlushOpt   Pointer used for expansion. You can set it to NULL.CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FlushStream(HI_HANDLE hAvplay, HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S *pstFlushOpt);
+
+/**
+\brief AVPLAY private command invoking. CNcomment: AVPLAY CNend
+\attention \n
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enInvokeType  Type of private command invoking.CNcomment: CNend
+\param[in] pPara         Pointer to the parameter of invoking. CNcomment:Invoke CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Invoke(HI_HANDLE hAvplay, HI_UNF_AVPLAY_INVOKE_E enInvokeType, HI_VOID *pPara);
+
+/**
+\brief Accquire user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: CC CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[out] pstUserData  user data.CNcomment: CNend
+\param[out] penType      user data type. CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S *pstUserData, HI_UNF_VIDEO_USERDATA_TYPE_E *penType);
+
+/**
+\brief Accquire user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: CC CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstUserData  user data.CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S* pstUserData);
+
+/**
+\brief Extended interface for Accquire user data. CNcomment:  CNend
+\attention \n
+support Closed Caption Data,Active Format Description.
+CNcomment: CCAFD CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enType      user data type. CNcomment: CNend
+\param[out] pstUserData  user data.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Extended interface for Release user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data,Active Format Description..
+CNcomment: CCAFD CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enType      user data type. CNcomment: CNend
+\param[in] pstUserData  user data.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Obtains the left video frame tahr are not decoded CNcomment:  CNend
+\attention \n
+Only support AVPLAY buffer by frame mode.
+CNcomment:  CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pLeftStreamFrm  This pointer indicates the AVPLAY buffer left video frame that are not decoded.CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetLeftStreamFrm(HI_HANDLE hAvplay, HI_U32 *pLeftStreamFrm);
+
+/**
+\brief set stream HDR information. CNcomment: HDR CNend
+\attention \n
+Only support VP9 HDR.
+CNcomment: VP9 HDR  CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR CNend
+\param[in] bPaddingHdrInfo    if need padding HDR information to frame information. CNcomment:HDR CNend
+\param[in] u32PtsMs  current pts of HDR information.it must be set invaild(-1),when that can not available.CNcomment:HDRpts CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetHDRInfo(HI_HANDLE hAvplay, HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo, HI_BOOL bPaddingHdrInfo, HI_U32 u32PtsMs);
+
+/**
+\brief Queries whether the AudioFormat is supported. CNcomment: AudioFormat  CNend
+\attention \n
+N/A
+\param[in] enFormat        Audio Format CNcomment: CNend
+\param[out] pbSupport      Pointer support. This pointer indicates whether the AudioFormat is supported. CNcomment:AudioFormat CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsAudioFormatSupport(const HA_FORMAT_E enFormat, HI_BOOL* pbSupport);
+
+HI_S32 HI_UNF_AVPLAY_DiscardFrame(HI_HANDLE hAvplay, HI_BOOL isDiscard);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff -uNr git/xbmc/linux/hisi/hi_unf_cipher.h unlib/xbmc/linux/hisi/hi_unf_cipher.h
--- git/xbmc/linux/hisi/hi_unf_cipher.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_cipher.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,1246 @@
+#ifndef __HI_UNF_CIPHER_H__
+#define __HI_UNF_CIPHER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+
+/** max length of SM2, unit: word */
+/** CNcomment: SM2word */
+#define SM2_LEN_IN_WROD                   (8)
+
+/** max length of SM2, unit: byte */
+/** CNcomment: SM2byte */
+#define SM2_LEN_IN_BYTE                   (SM2_LEN_IN_WROD * 4)
+
+/** CIPHER set IV for first package */
+/** CNcomment: CIPHER IV */
+#define CIPHER_IV_CHANGE_ONE_PKG        (1)
+
+/** CIPHER set IV for first package */
+/** CNcomment: CIPHER IV */
+#define CIPHER_IV_CHANGE_ALL_PKG        (2)
+
+/** Cipher work mode */
+/** CNcomment:CIPHER */
+typedef enum hiHI_UNF_CIPHER_WORK_MODE_E
+{
+    HI_UNF_CIPHER_WORK_MODE_ECB,        /**<Electronic codebook (ECB) mode*/    /**< CNcomment:ECB */
+    HI_UNF_CIPHER_WORK_MODE_CBC,        /**<Cipher block chaining (CBC) mode*/  /**< CNcomment:CBC */
+    HI_UNF_CIPHER_WORK_MODE_CFB,        /**<Cipher feedback (CFB) mode*/        /**< CNcomment:CFB */
+    HI_UNF_CIPHER_WORK_MODE_OFB,        /**<Output feedback (OFB) mode*/        /**< CNcomment:OFB */
+    HI_UNF_CIPHER_WORK_MODE_CTR,        /**<Counter (CTR) mode*/                /**< CNcomment:CTR */
+    HI_UNF_CIPHER_WORK_MODE_CCM,        /**<Counter (CCM) mode*/                /**< CNcomment:CCM */
+    HI_UNF_CIPHER_WORK_MODE_GCM,        /**<Counter (GCM) mode*/                /**< CNcomment:GCM */
+    HI_UNF_CIPHER_WORK_MODE_BUTT
+}HI_UNF_CIPHER_WORK_MODE_E;
+
+/** Cipher algorithm */
+/** CNcomment:CIPHER */
+typedef enum hiHI_UNF_CIPHER_ALG_E
+{
+    HI_UNF_CIPHER_ALG_DES           = 0x0,  /**< Data encryption standard (DES) algorithm */     /**< CNcomment: DES */
+    HI_UNF_CIPHER_ALG_3DES          = 0x1,  /**< 3DES algorithm */                               /**< CNcomment: 3DES */
+    HI_UNF_CIPHER_ALG_AES           = 0x2,  /**< Advanced encryption standard (AES) algorithm */ /**< CNcomment: AES */
+    HI_UNF_CIPHER_ALG_SM1           = 0x3,  /**<SM1 algorithm*/  /**< CNcomment: SM1 */
+    HI_UNF_CIPHER_ALG_SM4           = 0x4,  /**<SM4 algorithm*/  /**< CNcomment: SM4 */
+    HI_UNF_CIPHER_ALG_DMA           = 0x5,  /**<DMA copy*/  /**< CNcomment: DMA */
+    HI_UNF_CIPHER_ALG_BUTT          = 0x6
+}HI_UNF_CIPHER_ALG_E;
+
+/** Key length */
+/** CNcomment:  */
+typedef enum hiHI_UNF_CIPHER_KEY_LENGTH_E
+{
+    HI_UNF_CIPHER_KEY_AES_128BIT    = 0x0,  /**< 128-bit key for the AES algorithm */ /**< CNcomment:AES128bit */
+    HI_UNF_CIPHER_KEY_AES_192BIT    = 0x1,  /**< 192-bit key for the AES algorithm */ /**< CNcomment:AES192bit */
+    HI_UNF_CIPHER_KEY_AES_256BIT    = 0x2,  /**< 256-bit key for the AES algorithm */ /**< CNcomment:AES256bit */
+    HI_UNF_CIPHER_KEY_DES_3KEY      = 0x2,  /**< Three keys for the DES algorithm */  /**< CNcomment:DES3key */
+    HI_UNF_CIPHER_KEY_DES_2KEY      = 0x3,  /**< Two keys for the DES algorithm */    /**< CNcomment: DES2key  */
+    HI_UNF_CIPHER_KEY_DEFAULT       = 0x0,  /**< default key length, DES-8, SM1-48, SM4-16 */    /**< CNcomment: KeyDES-8, SM1-48, SM4-16*/
+}HI_UNF_CIPHER_KEY_LENGTH_E;
+
+/** Cipher bit width */
+/** CNcomment:  */
+typedef enum hiHI_UNF_CIPHER_BIT_WIDTH_E
+{
+    HI_UNF_CIPHER_BIT_WIDTH_64BIT   = 0x0,  /**< 64-bit width */   /**< CNcomment:64bit */
+    HI_UNF_CIPHER_BIT_WIDTH_8BIT    = 0x1,  /**< 8-bit width */    /**< CNcomment:8bit */
+    HI_UNF_CIPHER_BIT_WIDTH_1BIT    = 0x2,  /**< 1-bit width */    /**< CNcomment:1bit */
+    HI_UNF_CIPHER_BIT_WIDTH_128BIT  = 0x3,  /**< 128-bit width */  /**< CNcomment:128bit */
+}HI_UNF_CIPHER_BIT_WIDTH_E;
+
+/** Cipher control parameters */
+/** CNcomment: */
+typedef struct hiUNF_CIPHER_CTRL_CHANGE_FLAG_S
+{
+    HI_U32   bit1IV:4;              /**< Initial Vector change flag, 0-don't set, 1-set IV for first package, 2-set IV for each package  */ /**< CNcomment:, 0-1-2- */
+    HI_U32   bitsResv:28;           /**< Reserved */                     /**< CNcomment: */
+}HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S;
+
+/** Key ladder selecting parameters */
+/** CNcomment:key ladder */
+typedef enum hiUNF_CIPHER_CA_TYPE_E
+{
+    HI_UNF_CIPHER_CA_TYPE_R2R   = 0x0,      /**< Using R2R key ladder */                                                 /**< CNcomment:R2R key ladder */
+    HI_UNF_CIPHER_CA_TYPE_SP,               /**< Using SP key ladder */                                                  /**< CNcomment:SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA2,             /**< Using CSA2 key ladder */                                                /**< CNcomment:CSA2 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA3,             /**< Using CSA3 key ladder */                                                /**< CNcomment:CSA3 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_MISC,             /**< Using MISC ladder */                                                    /**< CNcomment:SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_GDRM,             /**< Using GDRM ladder */                                                    /**< CNcomment:GDRM key ladder */
+    HI_UNF_CIPHER_CA_TYPE_BLPK,             /**< Using BLPK ladder */                                                    /**< CNcomment:BLPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_LPK,              /**< Using LPK ladder */                                                     /**< CNcomment:LPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_IRDETO_HCA,       /**< Using Irdeto high level code authentication key ladder, only used for Irdeto MSR2.2 */ /**< CNcomment:IrdetokeyladderIrdeto MSR2.2 */
+    HI_UNF_CIPHER_CA_TYPE_STBROOTKEY,       /**< Useing for AntiCopy With STB_Root_Key  */                                                  /**< CNcomment:STB_Root_Key, */
+    HI_UNF_CIPHER_CA_TYPE_BUTT
+}HI_UNF_CIPHER_CA_TYPE_E;
+
+/** Encryption/Decryption type selecting */
+/** CNcomment:CIPHE */
+typedef enum
+{
+    HI_UNF_CIPHER_TYPE_NORMAL       = 0x0,
+    HI_UNF_CIPHER_TYPE_COPY_AVOID,
+    HI_UNF_CIPHER_TYPE_BUTT,
+}HI_UNF_CIPHER_TYPE_E;
+
+/** Structure of the cipher type */
+/** CNcomment: */
+typedef struct
+{
+    HI_UNF_CIPHER_TYPE_E enCipherType;
+}HI_UNF_CIPHER_ATTS_S;
+
+/** sm1 round config */
+/** CNcomment: sm1 */
+typedef enum hiHI_UNF_CIPHER_SM1_ROUND_E
+{
+    HI_UNF_CIPHER_SM1_ROUND_08 = 0x00,          /**< sm1 round 08 */ /**< CNcomment:SM108 */
+    HI_UNF_CIPHER_SM1_ROUND_10 = 0x01,          /**< sm1 round 10 */ /**< CNcomment:SM110 */
+    HI_UNF_CIPHER_SM1_ROUND_12 = 0x02,          /**< sm1 round 12 */ /**< CNcomment:SM112 */
+    HI_UNF_CIPHER_SM1_ROUND_14 = 0x03,          /**< sm1 round 14 */ /**< CNcomment:SM114 */
+    HI_UNF_CIPHER_SM1_ROUND_BUTT,
+}HI_UNF_CIPHER_SM1_ROUND_E;
+
+/** Structure of the cipher control information */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_CTRL_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:CAKey */
+    HI_UNF_CIPHER_CA_TYPE_E enCaType;                   /**< Select keyladder type when using advanced CA */                                                                  /**< CNcomment:CA,keyladder */
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_S;
+
+/** Structure of the cipher AES control information */
+/** CNcomment:AES */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_S
+{
+    HI_U32 u32EvenKey[8];                           /**< Key input, default use this key*/                                                                                /**< CNcomment:,  */
+    HI_U32 u32OddKey[8];                            /**< Key input, only valid for Multi encrypt/decrypt*/                                                                /**< CNcomment:,  */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_AES_S;
+
+/** Structure of the cipher AES CCM/GCM control information */
+/** CNcomment:AES CCM/GCM  */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_CCM_GCM_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_U32 u32IVLen;                                /**< IV lenght for CCM/GCM, which is an element of {4,6,8,10,12,14,16} for CCM, and is an element of [1-16] for GCM*/  /**< CNcomment: CCM/GCMIVCCM{7, 8, 9, 10, 11, 12, 13} GCM[1-16]*/
+    HI_U32 u32TagLen;                               /**< Tag lenght for CCM which is an element of {4,6,8,10,12,14,16}*/          /**< CNcomment: CCMTAG{4,6,8,10,12,14,16}*/
+    HI_U32 u32ALen;                                 /**< Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM*/
+    HI_U32 u32APhyAddr;                             /**< Physical address of Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM*/
+} HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+
+/** Structure of the cipher DES control information */
+/** CNcomment:DES */
+typedef struct hiHI_UNF_CIPHER_CTRL_DES_S
+{
+    HI_U32 u32Key[2];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_DES_S;
+
+/** Structure of the cipher 3DES control information */
+/** CNcomment:3DES */
+typedef struct hiHI_UNF_CIPHER_CTRL_3DES_S
+{
+    HI_U32 u32Key[6];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_3DES_S;
+
+/** Structure of the cipher SM1 control information */
+/** CNcomment:SM1 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM1_S
+{
+    HI_U32 u32EK[4];                               /**< Key of EK input */                                                                                                /**< CNcomment:EK */
+    HI_U32 u32AK[4];                               /**< Key of AK input */                                                                                                /**< CNcomment:AK */
+    HI_U32 u32SK[4];                               /**< Key of SK input */                                                                                                /**< CNcomment:SK */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_SM1_ROUND_E enSm1Round;           /**< SM1 round number, should be 8, 10, 12 or 14*/                                                                                                    /**< CNcomment:sm1 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_SM1_S;
+
+/** Structure of the cipher SM4 control information */
+/** CNcomment:SM4 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM4_S
+{
+    HI_U32 u32Key[4];                               /**< Key  input */                                                                                                    /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_SM4_S;
+
+/** Expand Structure of the cipher control information */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_CTRL_EX_S
+{
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment: */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment: */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:CAKey */
+    /**< Parameter for special algorithm
+        for AES, the pointer should point to HI_UNF_CIPHER_CTRL_AES_S;
+        for AES_CCM or AES_GCM, the pointer should point to HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+        for DES, the pointer should point to HI_UNF_CIPHER_CTRL_DES_S;
+        for 3DES, the pointer should point to HI_UNF_CIPHER_CTRL_3DES_S;
+        for SM1, the pointer should point to HI_UNF_CIPHER_CTRL_SM1_S;
+        for SM4, the pointer should point to HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    /**< CNcomment: 
+         AES,  HI_UNF_CIPHER_CTRL_AES_S;
+         AES_CCM  AES_GCM,  HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+         DES,  HI_UNF_CIPHER_CTRL_DES_S;
+         3DES,  HI_UNF_CIPHER_CTRL_3DES_S;
+         SM1,  HI_UNF_CIPHER_CTRL_SM1_S;
+         SM4,  HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    HI_VOID *pParam;
+} HI_UNF_CIPHER_CTRL_EX_S;
+
+/** Cipher data */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_DATA_S
+{
+    HI_U32 u32SrcPhyAddr;     /**< phy address of the original data */   /**< CNcomment: */
+    HI_U32 u32DestPhyAddr;    /**< phy address of the purpose data */    /**< CNcomment: */
+    HI_U32 u32ByteLength;     /**< cigher data length*/                 /**< CNcomment: */
+    HI_BOOL bOddKey;    /**< Use odd key or even key*/                  /**< CNcomment: */
+} HI_UNF_CIPHER_DATA_S;
+
+/** Hash algrithm type */
+/** CNcomment: */
+typedef enum hiHI_UNF_CIPHER_HASH_TYPE_E
+{
+    HI_UNF_CIPHER_HASH_TYPE_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_IRDETO_CBCMAC, /**< Irdeto MSR2.2 CBC-MAC*/ /**< CNcomment: Irdeto MSR2.2 CBC-MAC*/    
+    HI_UNF_CIPHER_HASH_TYPE_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_SM3,
+    HI_UNF_CIPHER_HASH_TYPE_BUTT,
+}HI_UNF_CIPHER_HASH_TYPE_E;
+
+/** Hash init struct input */
+/** CNcomment: */
+typedef struct
+{
+    HI_U8 *pu8HMACKey;
+    HI_U32 u32HMACKeyLen;
+    HI_UNF_CIPHER_HASH_TYPE_E eShaType;
+}HI_UNF_CIPHER_HASH_ATTS_S;
+
+typedef enum hiHI_UNF_CIPHER_RSA_ENC_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_NO_PADDING,            /**< without padding */             /**< CNcomment:  */
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_0,          /**< PKCS#1 block type 0 padding*/  /**< CNcomment: PKCS#1block type 0*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_1,          /**< PKCS#1 block type 1 padding*/  /**< CNcomment: PKCS#1block type 1*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_2,          /**< PKCS#1 block type 2 padding*/  /**< CNcomment: PKCS#1block type 2*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA1,       /**< PKCS#1 RSAES-OAEP-SHA1 padding*/    /**< CNcomment: PKCS#1RSAES-OAEP-SHA1*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA224,     /**< PKCS#1 RSAES-OAEP-SHA224 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA224*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA256,     /**< PKCS#1 RSAES-OAEP-SHA256 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA256*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA384,     /**< PKCS#1 RSAES-OAEP-SHA384 padding*/    /**< CNcomment: PKCS#1RSAES-OAEP-SHA384*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA512,     /**< PKCS#1 RSAES-OAEP-SHA512 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA512*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_PKCS1_V1_5,      /**< PKCS#1 RSAES-PKCS1_V1_5 padding*/   /**< CNcomment: PKCS#1PKCS1_V1_5*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_ENC_SCHEME_E;
+
+typedef enum hiHI_UNF_CIPHER_RSA_SIGN_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1 = 0x100, /**< PKCS#1 RSASSA_PKCS1_V15_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA1*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA224*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA256*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA384 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA384*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA512 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA512*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1,         /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA1*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA224*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA256*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA384*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA512*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_SIGN_SCHEME_E;
+
+typedef struct
+{
+    HI_U8  *pu8N;              /**< point to public modulus  */   /**< CNcomment: RSAN*/
+    HI_U8  *pu8E;              /**< point to public exponent */   /**< CNcomment: RSAE*/
+    HI_U16 u16NLen;            /**< length of public modulus, max value is 512Byte*/  /**< CNcomment: RSAN, 512Byte*/
+    HI_U16 u16ELen;            /**< length of public exponent, max value is 512Byte*/  /**< CNcomment: RSAE, 512Byte*/
+}HI_UNF_CIPHER_RSA_PUB_KEY_S;
+
+/** RSA private key struct */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_U8 *pu8N;                      /*!<  public modulus    */ /**< CNcomment: RSAN*/
+    HI_U8 *pu8E;                      /*!<  public exponent   */ /**< CNcomment: RSAE*/
+    HI_U8 *pu8D;                      /*!<  private exponent  */ /**< CNcomment: RSAD*/
+    HI_U8 *pu8P;                      /*!<  1st prime factor  */ /**< CNcomment: RSAP*/
+    HI_U8 *pu8Q;                      /*!<  2nd prime factor  */ /**< CNcomment: RSAQ*/
+    HI_U8 *pu8DP;                     /*!<  D % (P - 1)       */ /**< CNcomment: RSADP*/
+    HI_U8 *pu8DQ;                     /*!<  D % (Q - 1)       */ /**< CNcomment: RSADQ*/
+    HI_U8 *pu8QP;                     /*!<  1 / (Q % P)       */ /**< CNcomment: RSAQP*/
+    HI_U16 u16NLen;                   /**< length of public modulus */   /**< CNcomment: RSAN*/
+    HI_U16 u16ELen;                   /**< length of public exponent */  /**< CNcomment: RSAE*/
+    HI_U16 u16DLen;                   /**< length of private exponent */ /**< CNcomment: RSAD*/
+    HI_U16 u16PLen;                   /**< length of 1st prime factor */ /**< CNcomment: RSAP*/
+    HI_U16 u16QLen;                   /**< length of 2nd prime factor */ /**< CNcomment: RSAQ*/
+    HI_U16 u16DPLen;                  /**< length of D % (P - 1) */      /**< CNcomment: RSADP*/
+    HI_U16 u16DQLen;                  /**< length of D % (Q - 1) */      /**< CNcomment: RSADQ*/
+    HI_U16 u16QPLen;                  /**< length of 1 / (Q % P) */      /**< CNcomment: RSAQP*/
+}HI_UNF_CIPHER_RSA_PRI_KEY_S;
+
+/** RSA public key encryption struct input */
+/** CNcomment:RSA  */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme;   /** RSA encryption scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;      /** RSA private key struct */ /** CNcomment:RSA */
+}HI_UNF_CIPHER_RSA_PUB_ENC_S;
+
+/** RSA private key decryption struct input */
+/** CNcomment:RSA  */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme; /** RSA encryption scheme */ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;    /** RSA private key struct */ /** CNcomment:RSA */
+}HI_UNF_CIPHER_RSA_PRI_ENC_S;
+
+/** RSA signature struct input */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme;  /** RSA signature scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;      /** RSA private key struct */ /** CNcomment:RSA */
+ }HI_UNF_CIPHER_RSA_SIGN_S;
+
+/** RSA signature verify struct input */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme; /** RSA signature scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;     /** RSA public key struct */ /** CNcomment:RSA */
+ }HI_UNF_CIPHER_RSA_VERIFY_S;
+
+ /** SM2 signature struct input */
+/** CNcomment: SM2 */
+ typedef struct hiHI_UNF_CIPHER_SM2_SIGN_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_SIGN_S;
+
+/** SM2 signature verify struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_VERIFY_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_VERIFY_S;
+
+/** SM2 publuc key encryption struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_ENC_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_ENC_S;
+
+/** SM2 private key decryption struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_DEC_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_DEC_S;
+
+/** SM2 key generate struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_KEY_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_KEY_S;
+
+/** Elliptic curve domain parameters. */
+/** CNcomment: ECC */
+typedef struct
+{
+  HI_U8 *pu8p; /** Finite field: equal to p in case of prime field curves or equal to 2^n in case of binary field curves.*/
+  HI_U8 *pu8a; /** Curve parameter a (q-3 in Suite B).*/
+  HI_U8 *pu8b; /** Curve parameter b*/
+  HI_U8 *pu8GX;/** X coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8GY;/** Y coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8n; /** Prime which is the order of G point.*/
+  HI_U32 u32h; /**<  Cofactor, which is the order of the elliptic curve divided by the order of the point G. For the Suite B curves, h = 1.*/
+  HI_U32 u32keySize; /**<  Key size in bytes. It corresponds to the size in bytes of the prime pu8n*/
+} HI_UNF_CIPHER_ECC_PARAM_S;
+
+/** CENC subsample struct input */
+/** CNcomment: CENC subsample  */
+typedef struct hiHI_UNF_CIPHER_SUBSAMPLE_S
+{
+    HI_U32 u32ClearHeaderLen;
+    HI_U32 u32PayLoadLen;
+    HI_U32 u32PayloadPatternEncryptLen;
+    HI_U32 u32PayloadPatternClearLen;
+    HI_U32 u32PayloadPatternOffsetLen;
+}HI_UNF_CIPHER_SUBSAMPLE_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define HI_UNF_CIPHER_Open(HI_VOID) HI_UNF_CIPHER_Init(HI_VOID);
+#define HI_UNF_CIPHER_Close(HI_VOID) HI_UNF_CIPHER_DeInit(HI_VOID);
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+/* ---CIPHER---*/
+/**
+\brief  Init the cipher device.  CNcomment:CIPHER CNend
+\attention \n
+This API is used to start the cipher device.
+CNcomment:CIPHER CNend
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_FAILED_INIT  The cipher device fails to be initialized. CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Init(HI_VOID);
+
+
+/**
+\brief  Deinit the cipher device.
+CNcomment:\brief  CIPHER CNend
+\attention \n
+This API is used to stop the cipher device. If this API is called repeatedly, HI_SUCCESS is returned, but only the first operation takes effect.
+CNcomment:CIPHER CNend
+
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DeInit(HI_VOID);
+
+
+/**
+\brief Obtain a cipher handle for encryption and decryption.
+CNcommentCipher CNend
+
+\param[in] cipher attributes                                                    CNcomment:cipher  CNend
+\param[out] phCipher Cipher handle                                              CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment: API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_FAILED_GETHANDLE  The cipher handle fails to be obtained, because there are no available cipher handles. CNcomment: CIPHERCIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CreateHandle(HI_HANDLE* phCipher, const HI_UNF_CIPHER_ATTS_S *pstCipherAttr);
+
+
+/**
+\brief Destroy the existing cipher handle. CNcomment:CIPHER CNend
+\attention \n
+This API is used to destroy existing cipher handles.
+CNcomment:CIPHER CNend
+
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DestroyHandle(HI_HANDLE hCipher);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief CIPHER CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandleEx to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB mode.
+CNcomment:HI_UNF_CIPHER_ConfigHandleExCIPHER
+TDES64 bit
+ AES/DES/3DES/SM4 , ECB/CBC/CTR/OFB/CFB .CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] pstCtrl Cipher control information.                                  CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandle(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_S* pstCtrl);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief CIPHER CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandle to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM1/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB/CCM/GCM mode.
+CNcomment:HI_UNF_CIPHER_ConfigHandleCIPHER
+TDES64 bit
+ AES/DES/3DES/SM1/SM4 , ECB/CBC/CTR/OFB/CFB/CCM/GCM .CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] pstExCtrl Cipher control information.                                CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandleEx(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_EX_S* pstExCtrl);
+
+
+/**
+\brief Performs encryption.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to perform encryption by using the cipher module.
+The length of the encrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:CIPHERTDES8AES160xFFFFFHI_UNF_CIPHER_ConfigHandleIV(pstCtrl->stChangeFlags.bit1IV1) CNend
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER CNend
+\param[in] u32SrcPhyAddr Physical address of the source data                    CNcomment: CNend
+\param[in] u32DestPhyAddr Physical address of the target data                   CNcomment: CNend
+\param[in] u32ByteLength   Length of the encrypted data                         CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Encrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Performs decryption.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to perform decryption by using the cipher module.
+The length of the decrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:CIPHERTDES8AES160xFFFFFHI_UNF_CIPHER_ConfigHandleIV(pstCtrl->stChangeFlags.bit1IV1) CNend
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] u32SrcPhyAddr Physical address of the source data.                   CNcomment: CNend
+\param[in] u32DestPhyAddr Physical address of the target data.                  CNcomment: CNend
+\param[in] u32ByteLength Length of the decrypted data                           CNcomment: CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Decrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Encrypt multiple packaged data.
+CNcomment:\brief  CNend
+\attention \n
+You can not encrypt more than 128 data package one time. When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When encrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:128HI_ERR_CIPHER_BUSY: HI_UNF_CIPHER_ConfigHandle CNend
+\param[in] hCipher cipher handle                                                                  CNcomment:CIPHER CNend
+\param[in] pstDataPkg data package ready for cipher                                               CNcomment: CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                   CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                        CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                             CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                            CNcomment: CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EncryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Decrypt multiple packaged data.
+CNcomment:\brief  CNend
+\attention \n
+You can not decrypt more than 128 data package one time.When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When decrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:128HI_ERR_CIPHER_BUSY: HI_UNF_CIPHER_ConfigHandle CNend
+\param[in] hCipher cipher handle                                                                 CNcomment:CIPHER CNend
+\param[in] pstDataPkg data package ready for cipher                                              CNcomment: CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                     CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                  CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                        CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                            CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                           CNcomment: CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DecryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Get the tag data of CCM/GCM.
+CNcomment:\brief CCM/GCMTAG CNend
+
+\attention \n
+This API is used to get the tag data of CCM/GCM.
+\param[in] hCipher cipher handle                                                CNcomment:CIPHER CNend
+\param[out] pu8Tag tag data of CCM/GCM                                          CNcomment:TAG CNend
+\param[in/out] pu32TagLen tag data length of CCM/GCM, the input should be 16 now. CNcomment:TAG16 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetTag(HI_HANDLE hCipher, HI_U8 *pu8Tag, HI_U32 *pu32TagLen);
+
+
+/**
+\brief Get the random number.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+CNcomment: CNend
+
+\param[out] pu32RandomNumber Point to the random number.                                        CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetRandomNumber(HI_U32 *pu32RandomNumber);
+
+
+/**
+\brief Get the AES CBC-MAC value.
+CNcomment:\brief AES CBC-MAC CNend
+
+\attention \n
+This API is used to obtain the AES CBC-MAC value.
+CNcomment:AES CBC-MAC CNend
+\param[in] hCipherHandle:  The cipher handle.                                                   CNcomment:Cipher CNend
+\param[in] pInputData: input data.                                                              CNcomment: CNend
+\param[in] u32InputDataLen: input data length,the length should be multiple of 16 bytes if it is not the last block. CNcomment:block16byte CNend
+\param[in] bIsLastBlock: Whether this block is last block or not.                               CNcomment:block CNend
+\param[out] pOutputMAC: output CBC-MAC value.                                                   CNcomment:CBC-MAC   CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CalcMAC(HI_HANDLE hCipherHandle, HI_U8 *pInputData, HI_U32 u32InputDataLen,
+                                        HI_U8 *pOutputMAC, HI_BOOL bIsLastBlock);
+
+
+/**
+\brief Init the hash module, if other program is using the hash module, the API will return failure.
+CNcomment:\brief HASHHASH CNend
+
+\attention \n
+N/A
+
+\param[in] pstHashAttr: The hash calculating structure input.                                      CNcomment:hash CNend
+\param[out] pHashHandle: The output hash handle.                                                CNcomment:hash CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashInit(HI_UNF_CIPHER_HASH_ATTS_S *pstHashAttr, HI_HANDLE *pHashHandle);
+
+
+/**
+\brief Calculate the hash, if the size of the data to be calculated is very big and the DDR ram is not enough, this API can calculate the data one block by one block. Attention: The input block length must be 64bytes alingned except for the last block.
+CNcomment:\brief hashblockblock block64CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandl:  Hash handle.                                        CNcomment:Hash CNend
+\param[in] pu8InputData:  The input data buffer.                            CNcomment: CNend
+\param[in] u32InputDataLen:  The input data length, attention: the block length input must be 64bytes aligned except the last block!            CNcomment: 64block CNend
+\retval ::HI_SUCCESS  Call this API succussful.                             CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                  CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashUpdate(HI_HANDLE hHashHandle, HI_U8 *pu8InputData, HI_U32 u32InputDataLen);
+
+
+/**
+\brief Get the final hash value, after calculate all of the data, call this API to get the final hash value and close the handle.If there is some reason need to interupt the calculation, this API should also be call to close the handle.
+CNcomment:hashhashhashhash CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandle:  Hash handle.                                       CNcomment:Hash CNend
+\param[out] pu8OutputHash:  The final output hash value.                    CNcomment:hash CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                             CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashFinal(HI_HANDLE hHashHandle, HI_U8 *pu8OutputHash);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA public key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaEnc:   encryption struct.                                   CNcomment: CNend
+\param[in] pu8Input   input data to be encryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8Output output data to be encryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicEncrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaEnc,
+                                  HI_U8 *pu8Input, HI_U32 u32InLen,
+                                  HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaDec:   decryption struct.                                   CNcomment:  CNend
+\param[in] pu8Input   input data to be decryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Output output data to be decryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateDecrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaDec,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:   encryption struct.                                  CNcomment: CNend
+\param[in] pu8Input   input data to be encryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8Output output data to be encryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateEncrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaEnc,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA public key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:   decryption struct.                                CNcomment:  CNend
+\param[in] pu8Input   input data to be decryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Output output data to be decryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicDecrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaDec,
+                               HI_U8 *pu8Input, HI_U32 u32InLen,
+                               HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA signature a context with appendix, where a signers RSA private key is used.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:      signature struct.                                    CNcomment:  CNend
+\param[in] pu8Input       input context to be signaturemaybe null            CNcomment: , pu8HashData CNend
+\param[in] u32InLen:        length of input context to be signature              CNcomment:  CNend
+\param[in] pu8HashData    hash value of context,if NULL, let pu8HashData = Hash(context) automatically   Ncomment: HASHHASH CNend
+\param[out] pu8OutSign    output message of signature                          CNcomment:  CNend
+\param[out] pu32OutSignLen: length of message of signature                       CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaSign(HI_UNF_CIPHER_RSA_SIGN_S *pstRsaSign,
+                             HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                             HI_U8 *pu8HashData,
+                             HI_U8 *pu8OutSign, HI_U32 *pu32OutSignLen);
+
+
+/**
+\brief RSA signature verification a context with appendix, where a signers RSA public key is used.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:    signature verification struct.                         CNcomment:  CNend
+\param[in] pu8Input       input context to be signature verificationmaybe null CNcomment: , pu8HashData CNend
+\param[in] u32InLen:        length of input context to be signature                CNcomment:  CNend
+\param[in] pu8HashData    hash value of context,if NULL, let pu8HashData = Hash(context) automatically   Ncomment: HASHHASH CNend
+\param[in] pu8InSign      message of signature                                 CNcomment:  CNend
+\param[in] pu32InSignLen:   length of message of signature                       CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaVerify(HI_UNF_CIPHER_RSA_VERIFY_S *pstRsaVerify,
+                               HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                               HI_U8 *pu8HashData,
+                               HI_U8 *pu8InSign, HI_U32 u32InSignLen);
+
+/**
+\brief Generate a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits: bit numbers of the integer public modulus. CNcomment: RSAN CNend
+\param[in] u32Exponent: value of public exponent. CNcomment: RSAE CNend
+\param[out] ptRsaPriKey: private key struct. CNcomment: RSA CNend
+
+\retval ::HI_SUCCESS Call this API succussful. CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaGenKey(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_UNF_CIPHER_RSA_PRI_KEY_S *pstRsaPriKey);
+
+/**
+\brief Computes CRT parameters dP, dQ and qInv from the two primes p and q and the public exponent e.
+CNcomment: pqCRTdP, dQ  qInv  CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits:     bit numbers of the integer public modulus.  CNcomment: RSAN CNend
+\param[in] u32Exponent:    value of public exponent.                   CNcomment: RSAE CNend
+\param[in] pu8P Buffer containing the prime number p used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTpu32NumBits/2. CNend
+\param[in] pu8Q Buffer containing the prime number q used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTqu32NumBits/2. CNend
+\param[out] pu8DP Buffer where to store the CRT exponent dP computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTdPu32NumBits/2. CNend
+\param[out] pu8DQ Buffer where to store the CRT exponent dQ computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTdQu32NumBits/2. CNend
+\param[out] pu8QP Buffer where to store the CRT exponent qInv computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTqInvu32NumBits/2. CNend
+
+\param[out] ptRsaPriKey:   private key struct.                         CNcomment: RSA CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaComputeCrtParams(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_U8 *pu8P,
+                               HI_U8 *pu8Q, HI_U8 *pu8DP, HI_U8 *pu8DQ, HI_U8 *pu8QP);
+
+
+/**
+\brief SM2 signature a context with appendix, where a signers SM2 private key is used.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Sign:      signature struct.                                    CNcomment:  CNend
+\param[in] pu8Msg:          input context to be signaturemaybe null            CNcomment: , pu8HashData CNend
+\param[in] u32MsgLen:       length of input context to be signature              CNcomment:  CNend
+\param[out] pu8R          output message of signature                          CNcomment: R CNend
+\param[out] pu8S:           length of message of signature                       CNcomment: S CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Sign(HI_UNF_CIPHER_SM2_SIGN_S *pstSm2Sign, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 signature verification a context with appendix, where a signers SM2 public key is used.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Verify:    signature verification struct.                         CNcomment:  CNend
+\param[in] pu8Msg         input context to be signature verificationmaybe null CNcomment: , pu8HashData CNend
+\param[in] u32MsgLen:       length of input context to be signature                CNcomment:  CNend
+\param[in] pu8R           output message of signature                            CNcomment: R CNend
+\param[in] pu8S:            length of message of signature                         CNcomment: S CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Verify(HI_UNF_CIPHER_SM2_VERIFY_S *pstSm2Verify, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 encryption a plaintext with a RSA public key.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Enc:   encryption struct.                                   CNcomment:  CNend
+\param[in] pu8Msg     input data to be encryption                          CNcomment:  CNend
+\param[in] u32MsgLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8C      output data to be encryption                         CNcomment:  CNend
+\param[out] pu32Clen:   length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Encrypt(HI_UNF_CIPHER_SM2_ENC_S *pstSm2Enc,  HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8C, HI_U32 *pu32Clen);
+
+
+/**
+\brief RSA decryption a ciphertext with a SM2 private key.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Dec:   decryption struct.                                   CNcomment:  CNend
+\param[in] pu8C       input data to be decryption                          CNcomment:  CNend
+\param[out] u32Clen:    length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Msg    output data to be decryption                         CNcomment:  CNend
+\param[out] pu32MsgLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Decrypt(HI_UNF_CIPHER_SM2_DEC_S *pstSm2Dec, HI_U8 *pu8C, HI_U32 u32Clen, HI_U8 *pu8Msg, HI_U32 *pu32MsgLen);
+
+
+/**
+\brief Generate a SM2 key pair.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[out] pstSm2Key:   key pair struct.                               CNcomment: SM2 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2GenKey(HI_UNF_CIPHER_SM2_KEY_S *pstSm2Key);
+
+/**
+\brief CENC decryption a ciphertext.
+CNcomment: CENC CNend
+
+\attention \n
+This API is used to perform decryption ciphertext base on CENC format.
+CNcomment:CIPHERCENC CNend
+\param[in] hCipher Cipher handle                                              CNcomment:CIPHER CNend
+\param[in] u8Key key for cipher decryption                                    CNcomment:CIPHER  CNend
+\param[in] u8IV  iv for cipher decryption                                     CNcomment:CIPHER IV CNend
+\param[in] u32NonSecInputPhyAddr non-secure Physical address of the source data    CNcomment: CNend
+\param[in] u32SecOutputPhyAddr secure Physical address of the target data          CNcomment: CNend
+\param[in] u32ByteLength   Length of the decrypted data                         CNcomment: CNend
+\param[in] u32FirstEncrypt offset of the first encrypt block data               CNcomment:0~15 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CENCDecrypt(HI_HANDLE hCipher, HI_U8 *pu8Key, HI_U8 *pu8IV,
+                               HI_U32 u32NonSecInPhyAddr, HI_U32 u32SecOutPhyAddr, HI_U32 u32ByteLength,
+                               HI_U32 u32FirstEncryptOffset,
+                               HI_UNF_CIPHER_SUBSAMPLE_S *pstSubSample, HI_U32 u32SubsampleNum);
+
+/**
+\brief Compute Diffie-Hellman shared secret as otherPubKey^privKey mod p.
+CNcomment: DH CNend
+
+\attention \n
+N/A
+
+\param[in] pu8P:  Buffer containing the DH prime modulus p used for the operation.  CNcomment: DHp. CNend
+\param[in] pu8PrivKey: Buffer containing the DH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: DHKey0 CNend
+\param[in] pu8OtherPubKey: Buffer containing the DH public key of the other peer. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHKey0 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: DHKey0 CNend
+\param[in] u32KeySize: DH key size. CNcomment: DH. CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhComputeKey(HI_U8 * pu8P, HI_U8 *pu8PrivKey, HI_U8 *pu8OtherPubKey,
+                                  HI_U8 *pu8SharedSecret, HI_U32 u32KeySize);
+
+
+/**
+\brief Generate Diffie-Hellman public/private key pair from g and p parameters. The public key is equal to g^x mod p, where x is random number considered as the private key.
+CNcomment: DH CNend
+
+\attention \n
+N/A
+
+\param[in] pu8G: Buffer containing the DH generator g used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHgKey0 CNend
+\param[in] pu8P: Buffer containing the DH generator p used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHpKey0 CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: DHKey0, pu8OutputPrivKey CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: DHKey0, pu8InputPrivKeybuffer CNend
+\param[in] u32KeySize: DH key size.                       CNcomment: DH. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhGenKey(HI_U8 *pu8G, HI_U8 *pu8P, HI_U8 *pu8InputPrivKey,
+                                   HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKey,
+                                   HI_U32 u32KeySize);
+
+
+/**
+\brief Compute ECDH shared secret key. This key corresponds to the X coordinates of the computed P point.
+CNcomment: ECC DH CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDHKey0 CNend
+\param[in] pu8OtherPubKeyX: Buffer containing the X coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size.  CNcomment: ECDHXKey0 CNend
+\param[in] pu8OtherPubKeyY: Buffer containing the Y coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key Y coordinates is smaller than the buffer size.  CNcomment: ECDHYKey0 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: ECDHKey0 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdhComputeKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                                    HI_U8 *pu8OtherPubKeyX, HI_U8 *pu8OtherPubKeyY,
+                                    HI_U8 *pu8SharedSecret);
+
+
+/**
+\brief Generate ECC public/private key pair.
+CNcomment: ECDH CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: ECCKey0, pu8OutputPrivKey CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: ECCKey0, pu8InputPrivKeybuffer CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCX. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCY. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EccGenKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8InputPrivKey,
+                                    HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY);
+
+
+/**
+\brief Sign a message with ECDSA algorithm and returns an uncompressed signature made of the pair (r, s).
+CNcomment: ECDSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDHKey0 CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH  CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment:  CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment:  CNend
+\param[out] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: R CNend
+\param[out] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: S CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaSign(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                               HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                               HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                               HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/**
+\brief Verify an ECDSA signature made of an uncompressed pair (r, s).
+CNcomment: ECDSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCX. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCY. CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH  CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment:  CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment:  CNend
+\param[in] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: R CNend
+\param[in] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: S CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaVerify(HI_UNF_CIPHER_ECC_PARAM_S *pstParams,
+                                 HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY,
+                                 HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                                 HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                                 HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_CIPHER_H__ */
diff -uNr git/xbmc/linux/hisi/hi_unf_common.h unlib/xbmc/linux/hisi/hi_unf_common.h
--- git/xbmc/linux/hisi/hi_unf_common.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_common.h	2018-07-18 17:35:28.524490000 +0800
@@ -0,0 +1,82 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_common.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_COMMON_H__
+#define __HI_UNF_COMMON_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Media_Common */
+/** @{ */  /** <!-- [Media_Common] */
+
+/**Defines the stream buffer.*/
+/**CNcomment:  */
+typedef struct hiUNF_STREAM_BUF_S
+{
+    HI_U8   *pu8Data;        /**<Data pointer*/ /**<CNcomment:  */
+    HI_U32  u32Size;         /**<Data size*/ /**<CNcomment:  */
+} HI_UNF_STREAM_BUF_S;
+
+/**Defines the structure of the ES buffer.*/
+/**CNcomment: ES */
+typedef struct hiUNF_ES_BUF_S
+{
+    HI_U8 * pu8Buf;    /**<User-state virtual address of the buffer*/ /**<CNcomment: buffer*/
+    HI_U32 u32BufLen;  /**<Buffer length*/ /**<CNcomment: buffer*/
+    HI_U32 u32PtsMs;   /**<Presentation time stamp (PTS) value corresponding to the start of the stream. The invalid value is 0xFFFFFFFF.*/
+                       /**<CNcomment: PTS0xffffffff*/
+}HI_UNF_ES_BUF_S;
+
+/* Crop parameter */
+typedef struct hiUNF_CROP_RECT_S
+{
+    HI_U32 u32LeftOffset;
+    HI_U32 u32TopOffset;
+    HI_U32 u32RightOffset;
+    HI_U32 u32BottomOffset;
+}HI_UNF_CROP_RECT_S;
+
+/**Defines the signal status of the input source.*/
+/**CNcomment:  */
+typedef enum hiUNF_SIG_STATUS_E
+{
+    HI_UNF_SIG_SUPPORT = 0,  /**<Stable signal*/            /**<CNcomment: */
+    HI_UNF_SIG_NO_SIGNAL,    /**<No signal*/                /**<CNcomment: */
+    HI_UNF_SIG_NOT_SUPPORT,  /**<Not support the signal*/   /**<CNcomment: */
+    HI_UNF_SIG_UNSTABLE,     /**<Unstable signal*/          /**<CNcomment: */
+    HI_UNF_SIG_BUTT          /**<Invalid value*/            /**<CNcomment: */
+} HI_UNF_SIG_STATUS_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_COMMON_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_disp.h unlib/xbmc/linux/hisi/hi_unf_disp.h
--- git/xbmc/linux/hisi/hi_unf_disp.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_disp.h	2018-07-18 17:35:28.524490000 +0800
@@ -0,0 +1,1519 @@
+/******************************************************************************
+
+   Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_disp.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2009/12/15
+   Description   :
+   History       :
+   1.Date        : 2009/12/15
+    Author      : w58735
+    Modification: Created file
+
+ *******************************************************************************/
+
+
+/**
+ * \file
+ **\brief : define DISPLAY module information
+ * \brief supply infor about display.
+ */
+
+#ifndef  __HI_UNF_DISP_H__
+#define  __HI_UNF_DISP_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_hdmi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+/**enum define about DISPLAY channel*/
+/**CNcomment:DISPLAY*/
+typedef enum hiUNF_DISP_E
+{
+    HI_UNF_DISPLAY0 = 0x0,  /**< DISPLAY0,Compatible with SD */ /**<CNcomment:DISPLAY0 */
+    HI_UNF_DISPLAY1,        /**< DISPLAY1 *//**<CNcomment: DISPLAY1 */
+    HI_UNF_DISPLAY2,        /**< DISPLAY2 *//**<CNcomment: DISPLAY2 */
+    HI_UNF_DISPLAY_BUTT
+}HI_UNF_DISP_E;
+
+/**max DAC count*/
+/**CNcomment:DAC*/
+#define MAX_DAC_NUM ( 6 )
+
+/**define the LCD data format*/
+/**CNcomment:LCD*/
+typedef enum hiHI_UNF_DISP_INTF_DATA_FMT
+{
+    HI_UNF_DISP_INTF_DATA_FMT_YUV422   = 0,         /**<YUV422,data width is 16*//**<CNcomment:YUV42216*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB565   = 0x8,       /**<RGB565,data width is 16*//**<CNcomment:RGB56516*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB444   = 0xa,       /**<RGB444,data width is 16*//**<CNcomment:RGB44416*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB666   = 0xb,       /**<RGB666,data width is 24*//**<CNcomment:RGB66624*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB888   = 0xc,       /**<RGB888,data widht is 24*//**<CNcomment:RGB88824*/
+    HI_UNF_DISP_INTF_DATA_FMT_BUTT
+}HI_UNF_DISP_INTF_DATA_FMT_E;
+
+/**define LCD output data width*/
+/**CNcomment:LCD*/
+typedef enum hiUNF_DISP_INTF_DATA_WIDTH_E
+{
+    HI_UNF_DISP_INTF_DATA_WIDTH8 = 0,       /**<8 bits*//**<CNcomment:8*/
+    HI_UNF_DISP_INTF_DATA_WIDTH16,          /**<16 bits*//**<CNcomment:16*/
+    HI_UNF_DISP_INTF_DATA_WIDTH24,          /**<24 bits*//**<CNcomment:24*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_BUTT
+}HI_UNF_DISP_INTF_DATA_WIDTH_E;
+
+/**define LCD timing */
+/**CNcomment:LCD*/
+typedef struct hiUNF_DISP_TIMING_S
+{
+    HI_U32                        VFB;            /**<vertical front blank*//**<CNcomment:*/
+    HI_U32                        VBB;            /**<vertical back blank*//**<CNcomment:*/
+    HI_U32                        VACT;           /**<vertical active area*//**<CNcomment:*/
+    HI_U32                        HFB;            /**<horizonal front blank*//**<CNcomment:*/
+    HI_U32                        HBB;            /**<horizonal back blank*//**<CNcomment:*/
+    HI_U32                        HACT;           /**<horizonal active area*/ /**<CNcomment:*/
+    HI_U32                        VPW;            /**<vertical sync pluse width*//**<CNcomment:*/
+    HI_U32                        HPW;            /**<horizonal sync pluse width*/ /**<CNcomment:*/
+    HI_BOOL                       IDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:*/
+    HI_BOOL                       IHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       IVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       ClockReversal;  /**<flag of clock is needed flip*//**<CNcomment:*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_E DataWidth;      /**<data width*/ /**<CNcomment:*/
+    HI_UNF_DISP_INTF_DATA_FMT_E   ItfFormat;      /**<data format.*//**<CNcomment:.*/
+
+    HI_BOOL DitherEnable;                           /**< flag of is enable Dither*//**<CNcomment:.*/
+    HI_U32  ClkPara0;                               /**<PLL  register SC_VPLL1FREQCTRL0  value *//**<CNcomment:PLL  SC_VPLL1FREQCTRL0  */
+    HI_U32  ClkPara1;                               /**<PLL  register SC_VPLL1FREQCTRL1 value*//**<CNcomment:PLL   SC_VPLL1FREQCTRL1*/
+
+    HI_BOOL bInterlace;                             /**<progressive or interlace*//**<CNcomment:*/
+    HI_U32  PixFreq;                                /**<pixel clock*//**<CNcomment:*/
+    HI_U32  VertFreq;                               /**<display rate*//**<CNcomment:*/
+    HI_U32  AspectRatioW;                           /**<width of screen*//**<CNcomment:*/
+    HI_U32  AspectRatioH;                           /**<height of screen*//**<CNcomment:*/
+    HI_BOOL bUseGamma;                              /**<gamma modulation*//**<CNcomment:*/
+    HI_U32  Reserve0;                               /**<reserved byte*//**<CNcomment:*/
+    HI_U32  Reserve1;                               /**<reserved byte*//**<CNcomment:*/
+} HI_UNF_DISP_TIMING_S;
+
+/**define video and graphics layers */
+/**CNcomment:*/
+typedef enum hiUNF_DISP_LAYER_E
+{
+    HI_UNF_DISP_LAYER_VIDEO = 0,                   /**<video layer *//**<CNcomment:*/
+    HI_UNF_DISP_LAYER_GFX,                  /**<graphics layer *//**<CNcomment:*/
+    HI_UNF_DISP_LAYER_BUTT
+}HI_UNF_DISP_LAYER_E;
+
+/**bt1120 interface ID */
+/**CNcomment:bt1120 ID  */
+typedef enum hiUNF_DISP_BT1120_E
+{
+    HI_UNF_DISP_BT1120_0,    /**<BT1120 interface 0 *//**<CNcomment:BT11200 */
+    HI_UNF_DISP_BT1120_BUTT,
+}HI_UNF_DISP_BT1120_E;
+
+/**BT656 interface ID */
+/**CNcomment:BT656 ID  */
+typedef enum hiUNF_DISP_BT656_E
+{
+    HI_UNF_DISP_BT656_0,    /**<BT656 interface 0 *//**<CNcomment:BT6560 */
+    HI_UNF_DISP_BT656_BUTT,
+}HI_UNF_DISP_BT656_E;
+
+/**LCD interface ID */
+/**CNcomment:LCD ID  */
+typedef enum hiUNF_LCD_E
+{
+    HI_UNF_DISP_LCD_0,    /**<LCD interface 0 *//**<CNcomment:LCD0 */
+    HI_UNF_DISP_LCD_BUTT,
+}HI_UNF_DISP_LCD_E;
+
+/**define the type of interface*/
+/**CNcomment:*/
+typedef enum  hiUNF_DISP_INTF_TYPE_E
+{
+    HI_UNF_DISP_INTF_TYPE_HDMI,     /**<HDMI interface type *//**<CNcomment:HDMI*/
+    HI_UNF_DISP_INTF_TYPE_LCD,      /**<LCD interface type *//**<CNcomment:LCD*/
+    HI_UNF_DISP_INTF_TYPE_BT1120,   /**<bt1120 digital interface type *//**<CNcomment:BT1120*/
+    HI_UNF_DISP_INTF_TYPE_BT656,    /**<bt656 digital interface type*//**<CNcomment:BT656*/
+    HI_UNF_DISP_INTF_TYPE_YPBPR,    /**<YPBPR interface type*//**<CNcomment:YPBPR*/
+    HI_UNF_DISP_INTF_TYPE_RGB,      /**<RGB interface type*//**<CNcomment:RGB*/
+    HI_UNF_DISP_INTF_TYPE_CVBS,     /**<CVBS interface type*//**<CNcomment:CVBS*/
+    HI_UNF_DISP_INTF_TYPE_SVIDEO,   /**<SVIDEO interface type*//**<CNcomment:SVIDEO*/
+    HI_UNF_DISP_INTF_TYPE_VGA,      /**<VGA interface type*//**<CNcomment:VGA*/
+    HI_UNF_DISP_INTF_TYPE_BUTT
+}HI_UNF_DISP_INTF_TYPE_E;
+
+/**define the YPBPR type struct of interface*/
+/**CNcomment:YPBPR*/
+typedef struct  hiUNF_DISP_INTF_YPBPR_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Ydac*/
+    HI_U8 u8DacPb;            /**<DAC num of Pb  *//**<CNcomment:Pbdac*/
+    HI_U8 u8DacPr;            /**<DAC num of Pr  *//**<CNcomment:Prdac*/
+}HI_UNF_DISP_INTF_YPBPR_S;
+
+/**define the RGB type struct of interface*/
+/**CNcomment:RGB*/
+typedef struct  hiUNF_DISP_INTF_RGB_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:Rdac*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:Gdac*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:Bdac*/
+    HI_BOOL bDacSync;         /**<G without sync signal  *//**<CNcomment:G*/
+}HI_UNF_DISP_INTF_RGB_S;
+
+/**define the VGA type struct of interface*/
+/**CNcomment:VGA*/
+typedef struct  hiUNF_DISP_INTF_VGA_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:Rdac*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:Gdac*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:Bdac*/
+}HI_UNF_DISP_INTF_VGA_S;
+
+/**define the CVBS type struct of interface*/
+/**CNcomment:CVBS*/
+typedef struct  hiUNF_DISP_INTF_CVBS_S
+{
+    HI_U8 u8Dac;              /**<DAC num of CVBS  *//**<CNcomment:CVBSdac*/
+}HI_UNF_DISP_INTF_CVBS_S;
+
+/**define the SVIDEO type struct of interface*/
+/**CNcomment:SVIDEO*/
+typedef struct  hiUNF_DISP_INTF_SVIDEO_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Ydac*/
+    HI_U8 u8DacC;             /**<DAC num of C   *//**<CNcomment:Cdac*/
+}HI_UNF_DISP_INTF_SVIDEO_S;
+
+/**define display interface struct*/
+/**CNcomment:*/
+typedef struct  hiUNF_DISP_INTF_S
+{
+    HI_UNF_DISP_INTF_TYPE_E enIntfType;         /**<interface type *//**<CNcomment:*/
+    union
+    {
+        HI_UNF_HDMI_ID_E        enHdmi;         /**<hdmi id *//**<CNcomment:HDMI */
+        HI_UNF_DISP_BT1120_E    enBT1120;       /**<bt1120 id *//**<CNcomment:BT1120*/
+        HI_UNF_DISP_BT656_E     enBT656;        /**<bt656 id *//**<CNcomment:BT656*/
+        HI_UNF_DISP_LCD_E       enLcd;          /**<lcd id *//**<CNcomment:LCD*/
+
+        HI_UNF_DISP_INTF_YPBPR_S    stYPbPr;    /**<intf config of YPBPR  *//**<CNcomment:YPBPR*/
+        HI_UNF_DISP_INTF_RGB_S      stRGB;      /**<intf config of RGB  *//**<CNcomment:RGB*/
+        HI_UNF_DISP_INTF_VGA_S      stVGA;      /**<intf config of VGA  *//**<CNcomment:VGA*/
+        HI_UNF_DISP_INTF_CVBS_S     stCVBS;     /**<intf config of CVBS  *//**<CNcomment:CVBS*/
+        HI_UNF_DISP_INTF_SVIDEO_S   stSVideo;   /**<intf config of SVIDEO  *//**<CNcomment:SVIDEO*/
+    }unIntf;
+}HI_UNF_DISP_INTF_S;
+
+
+/**Defines the device aspect ratio.*/
+/**CNcomment: */
+typedef enum hiUNF_DISP_ASPECT_RATIO_E
+{
+    HI_UNF_DISP_ASPECT_RATIO_AUTO,              /**<aspect ratio as device Resolution*//**<CNcomment: */
+    HI_UNF_DISP_ASPECT_RATIO_4TO3,              /**<4:3*//**<CNcomment: 43*/
+    HI_UNF_DISP_ASPECT_RATIO_16TO9,             /**<16:9*//**<CNcomment: 169*/
+    HI_UNF_DISP_ASPECT_RATIO_221TO1,            /**<221:100*//**<CNcomment: 221100*/
+    HI_UNF_DISP_ASPECT_RATIO_USER,              /**<user define*//**<CNcomment: */
+
+    HI_UNF_DISP_ASPECT_RATIO_BUTT
+}HI_UNF_DISP_ASPECT_RATIO_E;
+
+/**Defines the device aspect ratio struct.*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_ASPECT_RATIO_S
+{
+    HI_UNF_DISP_ASPECT_RATIO_E enDispAspectRatio;   /**<aspect ratio type of device*//**<CNcomment: */
+    HI_U32                     u32UserAspectWidth;  /**<user define width of device*//**<CNcomment: */
+    HI_U32                     u32UserAspectHeight; /**<user define height of device*//**<CNcomment: */
+}HI_UNF_DISP_ASPECT_RATIO_S;
+
+/**Defines algorithmic  control struct of display device.*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_ALG_CFG_S
+{
+    HI_BOOL bAccEnable;                             /**<acc alg*//**<CNcomment: acc*/
+    HI_BOOL bSharpEnable;                           /**<sharp alg*//**<CNcomment: sharp*/
+}HI_UNF_DISP_ALG_CFG_S;
+
+/**Defines VBI type.*/
+/**CNcomment: VBI*/
+typedef enum hiUNF_DISP_VBI_TYPE_E
+{
+    HI_UNF_DISP_VBI_TYPE_TTX = 0,                   /**<Teltext type*//**<CNcomment:teltext*/
+    HI_UNF_DISP_VBI_TYPE_CC,                        /**<Closed caption/V-Chip type *//**<CNcomment: /V-Chip*/
+    HI_UNF_DISP_VBI_TYPE_WSS,                       /**<Wide screen signal*//**<CNcomment:*/
+    HI_UNF_DISP_VBI_TYPE_BUTT
+} HI_UNF_DISP_VBI_TYPE_E;
+
+/**Defines VBI config struct.*/
+/**CNcomment: VBI*/
+typedef struct hiUNF_DISP_VBI_CFG_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI */
+    HI_U32                  u32InBufferSize;        /**<VBI data(pes) buffer size,more than 4K,suggest 4K*//**<CNcomment:VBI pes ,4K4K*/
+    HI_U32                  u32WorkBufferSize;      /**<VBI data buffer size used in driver,more than 2K,suggest 2K*//**<CNcomment:VBI2K2K*/
+} HI_UNF_DISP_VBI_CFG_S;
+
+/** define VBI information structure*/
+/**CNcomment: VBI*/
+typedef struct hiUNF_DISP_VBI_DATA_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI */
+    HI_U8                   *pu8DataAddr;           /**<Vbi data buffer virtual address*//**<CNcomment:Vbi*/
+    HI_U32                  u32DataLen;             /**<Vbi data lenght*//**<CNcomment:Vbi*/
+} HI_UNF_DISP_VBI_DATA_S;
+
+/**Defines the MAX buffer number.*/
+/** CNcomment:buffer */
+#define HI_DISP_CAST_BUFFER_MAX_NUMBER ( 16 )
+
+/**define CAST config */
+/**CNcomment:*/
+typedef struct hiUNF_DISP_CAST_ATTR_S
+{
+    HI_UNF_VIDEO_FORMAT_E enFormat;                                        /**<the output video format.*//**<CNcomment:*/
+    HI_U32                u32Width;                                       /**<the output video width.*//**<CNcomment:*/
+    HI_U32                u32Height;                                      /**<the output video height.*//**<CNcomment:*/
+    HI_BOOL               bLowDelay;                                      /**<work at low delay mode.*//**<CNcomment:*/
+    HI_U32                u32BufNum;                                      /**<the buffer number.*//**<CNcomment:buffer */
+    HI_BOOL               bUserAlloc;                                     /**<whether is user alloc memory*//**<CNcomment:*/
+    HI_U32                u32BufSize;                                     /**<each the buffer size.*//**<CNcomment:buffer */
+    HI_U32                u32BufStride;                                   /**<the horizonal stride.*//**<CNcomment:*/
+    HI_U32                u32BufPhyAddr[HI_DISP_CAST_BUFFER_MAX_NUMBER];  /**<the buffer physics address.*//**<CNcomment:buffer */
+    HI_BOOL               bCrop;                                          /**<whether enable crop .*//**<CNcomment:crop*/
+    HI_UNF_CROP_RECT_S    stCropRect;                                     /**<the crop wise .*//**<CNcomment:crop */
+} HI_UNF_DISP_CAST_ATTR_S;
+
+/**define color setting */
+/**CNcomment:*/
+typedef struct hiUNF_DISP_COLOR_SETTING_S
+{
+    HI_BOOL bGammaEnable;         /**<whether Gamma enable.*//**<CNcomment:Gamma */
+    HI_BOOL bUseCustGammaTable;   /**<whether use custom GammaTable.*//**<CNcomment:Gamma*/
+    HI_BOOL bColorCorrectEnable;  /**<whether Color Correct.*//**<CNcomment:*/
+    HI_S32  s32ColorTemp;         /**<color Temp.*//**<CNcomment:*/
+    HI_U32  u32Reserve;           /**<Reserve.*//**<CNcomment:*/
+    HI_VOID *pPrivate;            /**<Private.*//**<CNcomment:*/
+}HI_UNF_DISP_COLOR_SETTING_S;
+
+/**define the struct about color */
+/**CNcomment: */
+typedef struct  hiUNF_DISP_BG_COLOR_S
+{
+    HI_U8 u8Red;                  /**<red *//**<CNcomment:*/
+    HI_U8 u8Green;                /**<green*//**<CNcomment:*/
+    HI_U8 u8Blue;                 /**<blue*//**<CNcomment:*/
+} HI_UNF_DISP_BG_COLOR_S;
+
+/**define the struct about isogeny attributes */
+/**CNcomment: */
+typedef struct  hiUNF_DISP_ISOGENY_ATTR_S
+{
+    HI_UNF_DISP_E          enDisp; /**<channel id*//**<CNcomment: */
+    HI_UNF_ENC_FMT_E       enFormat;/**<format type*//**<CNcomment:*/
+}HI_UNF_DISP_ISOGENY_ATTR_S ;
+
+
+/********************************ENCODER STRUCT********************************/
+/** define the enum of Macrovision output type*/
+/** CNcomment:Macrovision*/
+typedef enum hiUNF_DISP_MACROVISION_MODE_E
+{
+    HI_UNF_DISP_MACROVISION_MODE_TYPE0,     /**<type 0 *//**<CNcomment:0 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE1,     /**<type 1 *//**<CNcomment:1 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE2,     /**<type 2 *//**<CNcomment:2 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE3,     /**<type 3 *//**<CNcomment:3 */
+    HI_UNF_DISP_MACROVISION_MODE_CUSTOM,    /**<type of configure by user *//**<CNcomment: */
+    HI_UNF_DISP_MACROVISION_MODE_BUTT
+} HI_UNF_DISP_MACROVISION_MODE_E;
+
+/** CGMS type select */
+/**CNcomment:CGMS */
+typedef enum hiUNF_DISP_CGMS_TYPE_E
+{
+    HI_UNF_DISP_CGMS_TYPE_A = 0x00,     /**<CGMS type  A*//**<CNcomment:CGMS A*/
+    HI_UNF_DISP_CGMS_TYPE_B,            /**<CGMS type  B*//**<CNcomment:CGMS B*/
+
+    HI_UNF_DISP_CGMS_TYPE_BUTT
+}HI_UNF_DISP_CGMS_TYPE_E;
+
+/** definition of CGMS mode */
+/**CNcomment:CGMS */
+typedef enum hiUNF_DISP_CGMS_MODE_E
+{
+    HI_UNF_DISP_CGMS_MODE_COPY_FREELY  = 0,     /**<copying is permitted without restriction *//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NO_MORE = 0x01,  /**<No more copies are allowed (one generation copy has been made)*//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_ONCE    = 0x02,  /**<One generation of copies may be made *//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NEVER   = 0x03,  /**<No copying is permitted *//**<CNcomment:*/
+
+    HI_UNF_DISP_CGMS_MODE_BUTT
+}HI_UNF_DISP_CGMS_MODE_E;
+
+/** definition of CGMS configuration */
+typedef struct hiUNF_DISP_CGMS_CFG_S
+{
+    HI_BOOL                 bEnable;            /**<HI_TRUE:CGMS is enabled; HI_FALSE:CGMS is disabled *//**<CNcomment:CGMS */
+    HI_UNF_DISP_CGMS_TYPE_E enType;             /**<type-A or type-B or None(BUTT) *//**<CNcomment:CGMS */
+    HI_UNF_DISP_CGMS_MODE_E enMode;             /**<CGMS mode. *//**<CNcomment:CGMS */
+}HI_UNF_DISP_CGMS_CFG_S;
+
+/**define WSS information structure*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_WSS_DATA_S
+{
+    HI_BOOL bEnable;                            /**<WSS configure enable HI_TRUE: enable,HI_FALSE: disnable*//**<CNcomment:WSSHI_TRUEHI_FALSE*/
+    HI_U16  u16Data;                            /**<Wss data */ /**<CNcomment:Wss*/
+}HI_UNF_DISP_WSS_DATA_S;
+
+
+/**define display 3D mode stucture*/
+/**CNcomment: */
+typedef enum hiUNF_DISP_3D_E
+{
+    HI_UNF_DISP_3D_NONE = 0,
+    HI_UNF_DISP_3D_FRAME_PACKING,                   /**<3d type:Frame Packing*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_HALF,               /**<3d type:Side by side half*//**<CNcomment:3d : */
+    HI_UNF_DISP_3D_TOP_AND_BOTTOM,                  /**<3d type:Top and Bottom*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_FIELD_ALTERNATIVE,               /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_LINE_ALTERNATIVE,                /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_FULL,               /**<3d type:Side by side full*//**<CNcomment:3d : */
+    HI_UNF_DISP_3D_L_DEPTH,                         /**<3d type:L+depth*//**<CNcomment:3d :L+DEPTH*/
+    HI_UNF_DISP_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d :L+depth+Graphics+Graphics-depth*/
+    HI_UNF_DISP_3D_BUTT
+}HI_UNF_DISP_3D_E;
+
+/**define display margin stucture*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_OFFSET_S
+{
+    HI_U32 u32Left;    /**<left offset *//**<CNcomment:*/
+    HI_U32 u32Top;     /**<top offset *//**<CNcomment:*/
+    HI_U32 u32Right;   /**<right offset *//**<CNcomment:*/
+    HI_U32 u32Bottom;  /**<bottom offset *//**<CNcomment:*/
+}HI_UNF_DISP_OFFSET_S;
+
+/**define output signal type.*/
+/**CNcomment:*/
+typedef enum hiUNF_DISP_HDR_TYPE_E
+{
+    HI_UNF_DISP_HDR_TYPE_NONE = 0,      /**<Normal SDR signal output type *//**<CNcomment:SDR */
+    HI_UNF_DISP_HDR_TYPE_AUTO,          /**<Optimum signal output type automatically *//**<CNcomment:*/
+    HI_UNF_DISP_HDR_TYPE_DOLBY,         /**<DolbyVision signal output type *//**<CNcomment:DolbyVision */
+    HI_UNF_DISP_HDR_TYPE_HDR10,         /**<HDR10 signal output type *//**<CNcomment:HDR10 */
+    HI_UNF_DISP_HDR_TYPE_HLG,           /**<HLG signal output type *//**<CNcomment:HLG */
+    HI_UNF_DISP_HDR_TYPE_BUTT
+} HI_UNF_DISP_HDR_TYPE_E;
+
+/**SD format should use BT601*/
+/**CNcomment:BT601*/
+typedef enum hiHI_UNF_DISP_COLOR_SPACE_E
+{
+    HI_UNF_DISP_COLOR_SPACE_AUTO = 0x0,     /**<  optimum output color space *//**<CNcomment:*/
+    HI_UNF_DISP_COLOR_SPACE_BT709,          /**< output  color space BT709*//**<CNcomment:BT709*/
+    HI_UNF_DISP_COLOR_SPACE_BT2020,         /**< output  color space BT2020*//**<CNcomment:BT2020*/
+    HI_UNF_DISP_COLOR_SPACE_BUTT
+}HI_UNF_DISP_COLOR_SPACE_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+
+/**
+   \brief Initiallization DISP module.CNcomment:DISP CNend
+   \attention \n
+   Please call this API function, before call anyother API of DISP module.
+   CNcomment:DISP CNend
+   \param  none.CNcomment: CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_NOT_EXIST DISP device not exist.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NOT_DEV_FILE  DISP  not device file .CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_OPEN_ERR  DISP  open fail.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Init( HI_VOID );
+
+
+/**
+   \brief deinital.CNcomment:DISP CNend
+   \attention \n
+   please call API HI_UNF_DISP_Close and open all the DISP device, before call this API.
+   CNcomment:::HI_UNF_DISP_CloseDISP CNend
+   \param none.CNcomment: CNend
+   \retval ::HI_SUCCESS success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_CLOSE_ERR  DISP close fail.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DeInit( HI_VOID );
+
+
+/**
+   \brief Attach one DISP channel to anoter.CNcomment:DISP CNend
+   \attention \n
+   Please finish the attach operation before the DISP channel has been open, and currently we only support HD channel attach to SD channel.
+   CNcomment:DISPDISPDISP CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:DISP CNend
+   \param[in] enSrcDisp   source DISP channel.CNcomment:  DISP CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT  display not be initialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid opeation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Attach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief dettach DISP.CNcomment:DISP CNend
+   \attention \n
+   should  close the DISP channels, before do detach operation.
+   CNcomment:DISP CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:DISP CNend
+   \param[in] enSrcDisp    source DISP channel.CNcomment: DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Detach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief open DISP channel.CNcomment:DISP CNend
+   \attention \n
+   Please config the valid parameters before open DISP.
+   CNcomment:DISP CNend
+   \param[in] enDisp   DISP channel ID, please reference the define of HI_UNF_DISP_E.CNcomment:DISP::HI_UNF_DISP_E CNend
+   \retval ::HI_SUCCESS success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    DISP create fail.CNcomment:DISP CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Open( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  coase DISP channel.CNcomment:DISP CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS success. CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Close( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  set DISP interface parameter.CNcomment:DISP CNend
+   \attention \n
+   The API is uesed for set  interface attach .If the interface has been attached,must be detach it ,or return HI_ERR_DISP_INVALID_OPT;\n
+   There are 4 DAC provided by SOC 3712 v300. suggest, DAC 0/1/2 used by HD channel, DAC3 used by SD channel CVBS. \n
+   There are 6 DAC provided by SOC 3716 v100/v200/v300. suggest, DAC 0/1/2 used by HD channel, DAC3/4/5 used by SD channel.
+   CNcomment:API Detach\n
+   HI_ERR_DISP_INVALID_OPT;\n
+   3712 v300 4DAC0123CVBS\n
+   3716 v100/v200/v300 6DAC012345CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32IntfNum  DISP intf num of DISP channel.CNcomment:DISP CNend
+   \param[in] pstIntf  DISP intf para.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS   success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR      Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AttachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief cancel DISP interface parameter.CNcomment:DISP CNend
+   \attention \n
+   The API is uesed to  detach  interface.
+   CNcomment:API  CNend
+   \param[in] enDisp        DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32IntfNum  DISP interface number of DISP channel.CNcomment:DISP CNend
+   \param[in] pstIntf  DISP interface para.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS   success. CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR        Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DetachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief set DISP output format.CNcomment:DISP CNend
+   \attention \n
+   for HD DISP channel please set HD display format, and for SD DISP channel please set SD display format.\n
+   for scenario of HD,SD use same source, only support format which frame rate is 50Hz or 60Hz.
+   CNcomment:DISPDISP\n
+   50Hz/60Hz1080P24/1080P25/1080P30 CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] enEncodingFormat    DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E enEncodingFormat );
+
+
+/**
+   \brief get DISP format.CNcomment:DISP CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] penEncodingFormat    poiner of DISP format.DCNcomment:ISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E *penEncodingFormat );
+
+
+/**
+   \brief set user define LCD clock parameter.CNcomment:LCD CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstTiming    poiner of DISP format.CNcomment:LCD CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief  get LCD parameter which had been config.CNcomment:DISPLCD CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstTiming      pointer of LCD paramter.CNcomment:LCD CNend
+   \retval ::HI_SUCCESS success.CNcomment:  CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief   set DISP layers Z order.CNcomment:DISPZ CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP CNend
+   \param[in] enLayer        layer ID which needed overlay to the DISP channel.CNcomment: DISP CNend
+   \param[in] enZFlag        the way of overlay.CNcomment:Z CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_LAYER_ZORDER_E enZFlag );
+
+
+/**
+   \brief  get DISP overlay z order.CNcomment:DISPZ CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:DISPDISPDISPDISP CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP CNend
+   \param[in] enLayer           CNcomment:DISP CNend
+   \param[in] pu32Zorder        CNcomment:Z CNend
+   \retval ::HI_SUCCESS success.CNcomment:  CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_U32 *pu32Zorder );
+
+
+/**
+   \brief set DISP back ground color.CNcomment:DISP CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp       CNcomment:DISP CNend
+   \param[in] pstBgColor   CNcomment:::HI_UNF_BG_COLOR_S CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetBgColor( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP back ground color.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:DISPDISPDISPDISP CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstBgColor   pointer of back ground color.CNcomment:  CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetBgColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP brightness.CNcomment:DISP CNend
+   \attention \n
+   if the value seted more than 100, we clip it to 100.CNcomment:100100 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Brightness   brightness value. the range is 0~100, 0 means the min brightness value.
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetBrightness( HI_UNF_DISP_E enDisp, HI_U32 u32Brightness );
+
+
+/**
+   \brief   get the DISP brightness.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Brightness    pointer of brightness. CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetBrightness( HI_UNF_DISP_E enDisp, HI_U32 *pu32Brightness );
+
+
+/**
+   \brief  set DISP contrast value.CNcomment:DISP CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:100100 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Contrast    contrast value. the range is 0~100, 0 means the min contrast value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetContrast( HI_UNF_DISP_E enDisp, HI_U32 u32Contrast );
+
+
+/**
+   \brief  get DISP contrast value.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Contrast   pointer of contrast. CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetContrast( HI_UNF_DISP_E enDisp, HI_U32 *pu32Contrast );
+
+
+/**
+   \brief   set DISP saturation.CNcomment:DISP CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:100100 CNend
+   \param[in] enDisp             DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Saturation      saturation value. the range is 0~100, 0 means the min saturation value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_DISP_SetSaturation( HI_UNF_DISP_E enDisp, HI_U32 u32Saturation );
+
+
+/**
+   \brief   get DISP saturation.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp                 DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Saturation    pointer of saturation. CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetSaturation( HI_UNF_DISP_E enDisp, HI_U32 *pu32Saturation );
+
+
+/**
+   \brief  set DISP hueplus.CNcomment:DISP CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32HuePlus       hueplus value. the range is 0~100, 0 means the min hueplus value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 u32HuePlus );
+
+
+/**
+   \brief get DISP hueplus.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP CNend
+   \param[out] pu32HuePlus     pointer of hueplus. CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 *pu32HuePlus );
+
+
+/**
+   \brief  set Wss.CNcomment:WSSWide Screen Singnalling CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstWssData        pointer of Wss data description structure.CNcomment:WSS CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetWss( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_WSS_DATA_S *pstWssData );
+
+
+/**
+   \brief  set Macrovision mode.CNcomment:Macrovision CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] enMode        Macrovision mode.  CNcomment:Macrovision::HI_UNF_MACROVISION_MODE_E CNend
+   \param[in] pData          pointer of Macrovision control data CNcomment: Macrovision CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E enMode, const HI_VOID *pData );
+
+
+/**
+   \brief get Macrovision mode.CNcomment: Macrovision CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] penMode    pointer of Macrovision mode. CNcomment:MACROVISION CNend
+   \param[out] pData      a data pointer only valid whenpenMode=HI_MACROVISION_MODE_CUSTOM.\n
+   CNcomment:penMode=HI_MACROVISION_MODE_CUSTOM CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E *penMode, const HI_VOID *pData );
+
+
+/**
+   \brief   set CGMS data.CNcomment:CGMSCopy Generation Management System CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp                   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstCgmsCfg             pointer of CGMS configuration  CNcomment:CGMS CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCgms( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_CGMS_CFG_S *pstCgmsCfg );
+
+
+/**
+   \brief chip do or not support Macrovision.CNcomment: Macrovision CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pbSupport    pointer of Macrovision flag. CNcomment:Macrovision  CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovisionSupport( HI_UNF_DISP_E enDisp, HI_BOOL *pbSupport );
+
+/**
+   \brief set aspect ratio attribute of display device.CNcomment:  CNend
+   \attention \n
+   If set AspectRatio USER mode ,must be set u32UserAspectWidth and u32UserAspectHeight \n
+   (theWidth/Height range is 1/64~64,if set zero means using current screen AspectRatio.) \n
+   If not AspectRatio USER mode ,it will be set value by enumeration means;In this mode u32UserAspectWidth and u32UserAspectHeight are invalid ;\n
+   If set AspectRatio AUTO mode , use current screen AspectRatio;
+   CNcomment:USERu32UserAspectWidth u32UserAspectHeight\n
+   1/64~64,0\n
+   USERu32UserAspectWidth u32UserAspectHeight\n
+   AUTO CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief get aspect ratio attribute of display device.CNcomment:  CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief set algorithmic attribute of display device.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstAlg    pointer of algorithmic attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief get algorithmic status of display device.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstAlg    pointer of algorithmic attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief create VBI data channel.CNcomment: VBI CNend
+   \attention \n
+   Each VBI type can not  created  repeatedly,if created more than one time,it will be return HI_ERR_DISP_CREATE_ERR;
+   CNcomment:VBIHI_ERR_DISP_CREATE_ERR CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstCfg    pointer of parameter of VBI channel . CNcomment:VBI CNend
+   \param[out] phVbi    pointer of VBI handle . CNcomment:VBI CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_CreateVBI( HI_UNF_DISP_E enDisp, HI_UNF_DISP_VBI_CFG_S *pstCfg, HI_HANDLE *phVbi );
+
+
+/**
+   \brief destroy VBI data channel.CNcomment: VBI CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI  CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyVBI( HI_HANDLE hVbi );
+
+
+/**
+   \brief send data to vbi channel.CNcomment: VBI CNend
+   \attention \n
+   After  call HI_UNF_DISP_CreateVBI creat VBI handle sucess,you can call API HI_UNF_DISP_SendVBIData send VBI data .
+   CNcomment:HI_UNF_DISP_CreateVBI VBIHI_UNF_DISP_SendVBIData   CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI  CNend
+   \param[in] pstVbiData      pointer of VBI data.CNcomment:VBI CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SendVBIData(HI_HANDLE hVbi, HI_UNF_DISP_VBI_DATA_S *pstVbiData);
+
+/**
+   \brief Get default attributes of screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[out]pstAttr     pointer of parameter .CNcomment:, CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetDefaultCastAttr(HI_UNF_DISP_E enDisp,HI_UNF_DISP_CAST_ATTR_S *pstAttr);
+
+
+/**
+   \brief create screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstAttr      pointer of parameter .CNcomment:, CNend
+   \param[out] phCast      handle of screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_CreateCast(HI_UNF_DISP_E enDisp, HI_UNF_DISP_CAST_ATTR_S * pstAttr, HI_HANDLE *phCast);
+
+
+/**
+   \brief destroy screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyCast( HI_HANDLE hCast );
+
+
+/**
+   \brief enable screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \param[in] bEnable      enable screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCastEnable( HI_HANDLE hCast, HI_BOOL bEnable );
+
+
+/**
+   \brief get enable flag of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \param[out] bEnable     flag .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetCastEnable( HI_HANDLE hCast, HI_BOOL *pbEnable );
+
+
+/**
+   \brief get frame info of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] hCast      handle of screen share .CNcomment: CNend
+   \param[out] pstFrameInfo        frame info.CNcomment: CNend
+   \param[in] u32TimeoutMs wait time in ms.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \retval ::HI_ERR_DISP_TIMEOUT          operation timeout. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo, HI_U32 u32TimeoutMs);
+
+
+/**
+   \brief release frame info of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] hCast      handle of screen share .CNcomment: CNend
+   \param[in] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseCastFrame( HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo );
+
+
+/**
+   \brief professional color modulation.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstCS      struct of color modulation.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \brief get color modulation parameter.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstCS      struct of color modulation.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \Snapshot truncation screen connection, intercepts the screen complete picture;CNcomment:; CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[out] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+/**
+   \Release Snapshot picture;CNcomment:; CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+
+/**
+   \brief get color modulation parameter.CNcomment:DISP CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetDefaultPara( HI_UNF_DISP_E enDisp);
+
+
+/**
+   \brief set DISP 3D format.CNcomment:DISP3D CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[in] en3D             DISP 3D mode.CNcomment:DISP 3D CNend
+   \param[in] enEncodingFormat DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Set3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E en3D, HI_UNF_ENC_FMT_E enEncFormat);
+
+/**
+   \brief get DISP 3D format.CNcomment:DISP3D CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[out] pen3D           DISP 3D mode.CNcomment:DISP 3D CNend
+   \param[out] penEncFormat    DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Get3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E *pen3D, HI_UNF_ENC_FMT_E *penEncFormat);
+
+/**
+   \brief set right eye first for 3D output.CNcomment:3D CNend
+   \attention \n
+   Only take effect in 3D output mode. CNcomment: 3D CNend
+   \param[in] enDisp     DISP channel ID.CNcomment:DISP CNend
+   \param[in] bEnable   Right-Eye-First.CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetRightEyeFirst(HI_UNF_DISP_E enDisp, HI_BOOL bEnable);
+
+/**
+   \brief set virtual screen size of display.CNcomment: CNend
+   \attention \n
+   if not set ,default value is 1280*720. CNcomment: 720p. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Width  virtual screen width, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \param[in] u32Height  virtual screen height, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 u32Width, HI_U32 u32Height);
+
+/**
+   \brief get virtual screen size of display.CNcomment: CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] u32Width  virtual screen width, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \param[out] u32Height  virtual screen height, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 *u32Width, HI_U32 *u32Height);
+
+
+/**
+   \brief set offset of display area in real screen.CNcomment:, CNend
+   \attention \n
+   must be 4 pixels aligned,if not set, the default value is 0. CNcomment: offset 4,0. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstOffset  offset in pixel, the range is [0, 200].CNcomment:[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief get offset of display area in real screen.CNcomment:, CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstOffset  offset in pixel, the range is [0, 200].CNcomment:[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief set isogeny attributes.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] pstIsogeny isogenous attributes.CNcomment: CNend
+   \param[in] u32ChannelNum  channel counts to be set in isogenous mode.CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetIsogenyAttr(const HI_UNF_DISP_ISOGENY_ATTR_S *pstIsogeny, const HI_U32 u32ChannelNum);
+
+/**
+   \brief set display output type.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] enHDRType   DISP type.CNcomment:HDR CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRType(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_HDR_TYPE_E enHDRType);
+
+/**
+   \brief Get display output type.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] penHDRType   DISP type.CNcomment:HDRCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRType(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_TYPE_E *penHDRType);
+
+/**
+   \brief Set display output color space.CNcomment:  CNend
+   \attention \n
+   should set sink capability with HI_UNF_DISP_SetSinkCapability api when set auto out color space.
+   CNcomment: AUTOHI_UNF_DISP_SetSinkCapability CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] enColorSpace output color space.CNcomment:CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_COLOR_SPACE_E enColorSpace);
+
+/**
+   \brief Get display output color space.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] penColorSpace output color space.CNcomment:CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputColorSpace(HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SPACE_E *penColorSpace);
+
+/**
+   \brief Set capability of sink .CNcomment: SinkCNend
+   \attention \n
+    Sink capability can acquire from hdmi, Strongly recommend to set sink capability when detect hdmi hot-plot event .
+    CNcomment: HDMISinkSink  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstSinkCap output color space.CNcomment:SinkCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetSinkCapability( HI_UNF_DISP_E enDisp, const HI_UNF_EDID_BASE_INFO_S *pstSinkCap);
+
+/**
+   \brief Set alpha of video .CNcomment: alphaCNend
+   \attention \n
+    none  CNcomment: CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Alpha video alpha value.CNcomment:alphaCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetVideoAlpha( HI_UNF_DISP_E enDisp, HI_U32 u32Alpha );
+
+/**
+   \brief Get alpha of video .CNcomment: alphaCNend
+   \attention \n
+    none CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pu32Alpha video alpha value.CNcomment:alphaCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetVideoAlpha(HI_UNF_DISP_E enDisp, HI_U32 *pu32Alpha);
+
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif
+/************************************** The End Of File **************************************/
diff -uNr git/xbmc/linux/hisi/hi_unf_edid.h unlib/xbmc/linux/hisi/hi_unf_edid.h
--- git/xbmc/linux/hisi/hi_unf_edid.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_edid.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,462 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_edid.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013-8-28
+  Description   :
+  History       :
+  1.Date        : 2013-8-28
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+#ifndef __HI_UNF_EDID_H__
+#define __HI_UNF_EDID_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      EDID */
+/** @{*/  /** <!-- [EDID] */
+
+/**EDID Audio type enum*//**CNcomment:HDMI   */
+typedef enum hiUNF_EDID_AUDIO_FORMAT_CODE_E
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_RESERVED  = 0x00,  /**<Audio coding type, refer stream,default type*//**<CNcomment: */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM,               /**<Audio coding PCM type*//**<CNcomment:PCM */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3,               /**<Audio coding AC3 type*//**<CNcomment:AC3 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG1,             /**<Audio coding MPEG1 type*//**<CNcomment:MPEG1 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MP3,               /**<Audio coding MP3 type*//**<CNcomment:MP3 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG2,             /**<Audio coding MPEG2 type*//**<CNcomment:MPEG2 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AAC,               /**<Audio coding AAC type*//**<CNcomment:AAC */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS,               /**<Audio coding DTS type*//**<CNcomment:DTS */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC,             /**<Audio coding ATRAC type*//**<CNcomment:ATRAC */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ONE_BIT,           /**<Audio coding ONE BIT AUDIO type*//**<CNcomment:ONE_BIT */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DDP,               /**<Audio coding DDPLUS type*//**<CNcomment:DDPLUS */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS_HD,            /**<Audio coding DTS HD type*//**<CNcomment:DTS HD */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MAT,               /**<Audio coding MAT type*//**<CNcomment:MAT */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DST,               /**<Audio coding DST type*//**<CNcomment:DST */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_WMA_PRO,           /**<Audio coding WMA PRO type*//**<CNcomment:WMA PRO */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_BUTT,
+}HI_UNF_EDID_AUDIO_FORMAT_CODE_E;
+
+/**the max audio smprate count*//**CNcomment: */
+#define MAX_SAMPE_RATE_NUM 8
+
+/**the max audio bit depth count*//**CNcomment: */
+#define MAX_BIT_DEPTH_NUM  6
+
+/**EDID Audio Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_AUDIO_INFO_S
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E enAudFmtCode; /**<Audio coding type*//**<CNcomment: */
+    HI_UNF_SAMPLE_RATE_E            enSupportSampleRate[MAX_SAMPE_RATE_NUM]; /**<Audio sample rate*//**<CNcomment: */
+    HI_U32                          u32SupportSampleRateNum; /**<Audio sample rate num*//**<CNcomment: */
+    HI_U8                           u8AudChannel;      /**<Aud Channel of the coding type*//**<CNcomment: */
+
+    HI_UNF_BIT_DEPTH_E              bSupportBitDepth[MAX_BIT_DEPTH_NUM];/*sample bit depth,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM */
+    HI_U32                          u32SupportBitDepthNum; /*sample bit depth Num,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM */
+    HI_U32                          u32MaxBitRate;  /**enter max bit rate,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3 - HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC**//**<CNcomment:AC3-ATRAC */
+}HI_UNF_EDID_AUDIO_INFO_S;
+
+/**EDID Audio speaker enum*//**CNcomment:EDID  */
+typedef enum hiUNF_EDID_AUDIO_SPEAKER_E
+{
+    HI_UNF_EDID_AUDIO_SPEAKER_FL_FR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_LFE     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RL_RR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLC_FRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RLC_RRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLW_FRW ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLH_FRH ,
+    HI_UNF_EDID_AUDIO_SPEAKER_TC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FCH     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_BUTT    ,
+} HI_UNF_EDID_AUDIO_SPEAKER_E;
+
+/**EDID MANUFACTURE Info struct*//**CNcomment:EDID */
+typedef struct hiUNF_EDID_MANUFACTURE_INFO_E
+{
+    HI_U8      u8MfrsName[4];            /**<Manufacture name*//**<CNcomment: */
+    HI_U32     u32ProductCode;           /**<Product code*//**<CNcomment:ID */
+    HI_U32     u32SerialNumber;          /**<Serial numeber of Manufacture*//**<CNcomment: */
+    HI_U32     u32Week;                  /**<the week of manufacture*//**<CNcomment:() */
+    HI_U32     u32Year;                  /**<the year of manufacture*//**<CNcomment:() */
+    HI_U8      u8pSinkName[14];          /**<Sink Name*//**<CNcomment:*/
+}HI_UNF_EDID_MANUFACTURE_INFO_S;
+
+
+/**EDID Display Base Parameters struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_BASE_PARA_S
+{
+    HI_U8      u8MaxImageWidth;               /**<The disp image max width  (0~255)cm*//**<CNcomment:  */
+    HI_U8      u8MaxImageHeight;              /**<The disp image max height (0~255)cm*//**<CNcomment:  */
+} HI_UNF_EDID_BASE_DISP_PARA_S;
+
+
+/**EDID Colorimety Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_COLORIMETRY_S
+{
+    HI_BOOL    bxvYCC601      ;          /**<The sink is support xcYCC601 or not flag*//**<CNcomment:xvYCC601 */
+    HI_BOOL    bxvYCC709      ;          /**<The sink is support xvYCC709 or not flag*//**<CNcomment:xvYCC709 */
+    HI_BOOL    bsYCC601       ;          /**<The sink is support sYCC601 or not flag*//**<CNcomment:sYCC601 */
+    HI_BOOL    bAdobleYCC601  ;          /**<The sink is support AdobleYCC601 or not flag*//**<CNcomment:AdobleYCC601 */
+    HI_BOOL    bAdobleRGB     ;          /**<The sink is support AdobleRGB or not flag*//**<CNcomment:AdobleRGB */
+    HI_BOOL    bBT2020cYCC    ;          /**<The sink is support BT2020cYCC or not flag*//**<CNcomment:BT2020cYCC */
+    HI_BOOL    bBT2020YCC     ;          /**<The sink is support BT2020YCC or not flag*//**<CNcomment:BT2020YCC */
+    HI_BOOL    bBT2020RGB     ;          /**<The sink is support BT2020RGB or not flag*//**<CNcomment:BT2020RGB */
+} HI_UNF_EDID_COLORIMETRY_S;
+
+/**EDID color space Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_COLOR_SPACE_S
+{
+    HI_BOOL    bRGB444        ;          /**<The sink is support RGB444 or not flag*//**<CNcomment:< RGB444 */
+    HI_BOOL    bYCbCr422      ;          /**<The sink is support YCbCr422 or not flag*//**<CNcomment:< YCbCr422 */
+    HI_BOOL    bYCbCr444      ;          /**<The sink is support YCbCr444 or not flag*//**<CNcomment:< YCbCr444 */
+    HI_BOOL    bYCbCr420      ;          /**<The sink is support YCbCr420 or not flag*//**<CNcomment:< YCbCr420 */
+} HI_UNF_EDID_COLOR_SPACE_S;
+
+/**EDID cec address Info struct*//**CNcomment:EDID cec */
+typedef struct hiUNF_EDID_CEC_ADDRESS_S
+{
+    HI_BOOL    bPhyAddrValid   ;          /**<the flag of phyiscs address is valid or not*//**<CNcomment:CEC */
+    HI_U8      u8PhyAddrA      ;          /**<phyiscs address A of CEC*//**<CNcomment:CECA */
+    HI_U8      u8PhyAddrB      ;          /**<phyiscs address B of CEC*//**<CNcomment:CECB */
+    HI_U8      u8PhyAddrC      ;          /**<phyiscs address C of CEC*//**<CNcomment:CECC */
+    HI_U8      u8PhyAddrD      ;          /**<phyiscs address D of CEC*//**<CNcomment:CECD */
+} HI_UNF_EDID_CEC_ADDRESS_S;
+
+/**EDID deep color Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_DEEP_COLOR_S
+{
+    HI_BOOL    bDeepColorY444   ;         /**<the Deep Color support YCBCR444-bits same with RGB-bits or not*//**<CNcomment: YCBCR 4:4:4  Deep Color RGBbit */
+    HI_BOOL    bDeepColor30Bit  ;         /**<the Deep Color support RGB 30 bit  or not *//**<CNcomment:RGB Deep Color 30bit  */
+    HI_BOOL    bDeepColor36Bit  ;         /**<the Deep Color support RGB 36 bit  or not *//**<CNcomment:RGB Deep Color 36bit  */
+    HI_BOOL    bDeepColor48Bit  ;         /**<the Deep Color support RGB 48 bit  or not *//**<CNcomment:RGB Deep Color 48bit  */
+} HI_UNF_EDID_DEEP_COLOR_S;
+
+typedef struct hiUNF_EDID_DEEP_COLOR_Y420_S
+{
+    HI_BOOL    bY420DeepColor30Bit  ;     /**<the Deep Color support YCBCR420  30 bit  or not *//**<CNcomment:YCBCR420 Deep Color 30bit  */
+    HI_BOOL    bY420DeepColor36Bit  ;     /**<the Deep Color support YCBCR420  36 bit  or not *//**<CNcomment:YCBCR420 Deep Color 36bit  */
+    HI_BOOL    bY420DeepColor48Bit  ;     /**<the Deep Color support YCBCR420  48 bit  or not *//**<CNcomment:YCBCR420 Deep Color 48bit  */
+} HI_UNF_EDID_DEEP_COLOR_Y420_S;
+
+typedef struct hiUNF_EDID_HDCP_S
+{
+	HI_BOOL     bHdcp14Support  ;		  /**<the HDCP support HDCP1.4 or not *//**<CNcomment:HDCP1.4 */
+    HI_BOOL     bHdcp22Support  ;		  /**<the HDCP support HDCP2.2 or not *//**<CNcomment:HDCP2.2 */
+} HI_UNF_EDID_HDCP_S;
+
+/**HDMI 3d enum type*/
+/**CNcomment: HDMI 3d  */
+typedef enum hiUNF_EDID_3D_TYPE_E
+{
+    HI_UNF_EDID_3D_FRAME_PACKETING                 = 0x00, /**<3d type:Frame Packing*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_FIELD_ALTERNATIVE               = 0x01, /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_LINE_ALTERNATIVE                = 0x02, /**<3d type:Line alternative*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_FULL               = 0x03, /**<3d type:Side by side full*//**<CNcomment:3d : */
+    HI_UNF_EDID_3D_L_DEPTH                         = 0x04, /**<3d type:L+depth*//**<CNcomment:3d :L+DEPTH*/
+    HI_UNF_EDID_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH = 0x05, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d :L+depth+Graphics+Graphics-depth*/
+    HI_UNF_EDID_3D_TOP_AND_BOTTOM                  = 0x06, /**<3d type:Top and Bottom*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_HALF               = 0x08, /**<3d type:Side by side half*//**<CNcomment:3d : */
+    HI_UNF_EDID_3D_BUTT,
+}HI_UNF_EDID_3D_TYPE_E;
+
+/**3d Info struct*//**CNcomment: 3d  */
+typedef struct hiUNF_EDID_3D_INFO_S
+{
+    HI_BOOL    bSupport3D  ;                         /**<flag of 3d*//**<CNcomment:3d*/
+    HI_BOOL    bSupport3DType[HI_UNF_EDID_3D_BUTT] ; /**<supported 3d type*//**<CNcomment:3d*/
+} HI_UNF_EDID_3D_INFO_S;
+
+/**EDID detailed Timing Info struct*//**CNcomment: EDID */
+typedef struct hiUNF_EDID_TIMING_S
+{
+    HI_U32                        u32VFB;          /**<vertical front blank*//**<CNcomment:*/
+    HI_U32                        u32VBB;          /**<vertical back blank*//**<CNcomment:*/
+    HI_U32                        u32VACT;         /**<vertical active area*//**<CNcomment:*/
+    HI_U32                        u32HFB;          /**<horizonal front blank*//**<CNcomment:*/
+    HI_U32                        u32HBB;          /**<horizonal back blank*//**<CNcomment:*/
+    HI_U32                        u32HACT;         /**<horizonal active area*/ /**<CNcomment:*/
+    HI_U32                        u32VPW;          /**<vertical sync pluse width*//**<CNcomment:*/
+    HI_U32                        u32HPW;          /**<horizonal sync pluse width*/ /**<CNcomment:*/
+    HI_BOOL                       bIDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:*/
+    HI_BOOL                       bIHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       bIVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:*/
+    HI_U32                        u32ImageWidth;   /**<image width *//**<CNcomment:*/
+    HI_U32                        u32ImageHeight;  /**<image height *//**<CNcomment: */
+    HI_U32                        u32AspectRatioW; /**<aspect ratio width *//**<CNcomment: */
+    HI_U32                        u32AspectRatioH; /**<aspect ratio height *//**<CNcomment: */
+    HI_BOOL                       bInterlace;      /**<flag of interlace *//**<CNcomment: */
+    HI_S32                        u32PixelClk;     /**<pixelc clk for this timing *//**<CNcomment: */
+} HI_UNF_EDID_TIMING_S;
+
+/**the max audio capability count*//**CNcomment: */
+#define HI_UNF_EDID_MAX_AUDIO_CAP_COUNT  16
+
+/**EDID Dolby capability in VSVDB version 0*//**CNcomment: EDID VSVDB0Dolby*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_0_S
+{
+    HI_U8       u8DMmajorVersion;       /**<the major version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U8       u8DMminorVersion;       /**<the minor version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U16      u16White_X;             /**<white point chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0. */
+    HI_U16      u16White_Y;             /**<white point  chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0.*/
+
+}HI_UNF_EDID_DOLBY_CAPS_VER_0_S;
+
+/**EDID Dolby capability in VSVDB version 1*//**CNcomment: EDID VSVDB1Dolby*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_1_S
+{
+    HI_U8       u8DMVersion;            /**<0:based on display management v2.x; 1:based on the video and blending pipeline v3.x; 2-7: reserved. only support when u8VSVDBVersion = 1. */
+    HI_BOOL     bColorimetry;           /**<this bit is valid only u8VSVDBVersion = 1. 0: Dolby Vision HDMI sink's colorimetry is close to Rec.709, 1: EDR HDMI sink's colorimetry is close to P3, if Byte[9] to Byte[14] are present, ignores this bit. *//**<CNcomment:0Dolby Vision SinkRec.7091Dolby Vision SinkP3Byte[9]Byte[14]*/
+}HI_UNF_EDID_DOLBY_CAPS_VER_1_S;
+
+/**EDID union of Dolby capability.*//**CNcomment: EDID Dolby*/
+typedef union hiUNF_EDID_DOLBY_CAPS_U
+{
+    HI_UNF_EDID_DOLBY_CAPS_VER_0_S stDolbyCapsVer0;
+    HI_UNF_EDID_DOLBY_CAPS_VER_1_S stDolbyCapsVer1;
+}HI_UNF_EDID_DOLBY_CAPS_U;
+
+/**EDID Dolby capability.see <Dolby  Vision  HDMI Transmission Specification> *//**CNcomment: EDID DolbyDolby  Vision  HDMI Transmission Specification*/
+typedef struct hiUNF_EDID_DOLBY_CAP_S
+{
+    /* CEA-861-F VCDB */
+    HI_BOOL     bYccQrangeSelectable;   /**<flag of RGB Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:SinkRGB/ HI_TRUEsinkHI_FALSEsink*/
+    HI_BOOL     bRgbQrangeSelectable;   /**<flag of YCC Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:SinkYCC/ HI_TRUEsinkHI_FALSEsink*/
+
+    /* Dolby  Vision  HDMI Transmission Specification */
+    HI_U8       u8VSVDBVersion;         /**<the version of VSVDB, if this equal to 1, the value of u16MinLuminance and u16MaxLuminance only 7 bits, the Rx, Ry, Gx, Gy, Bx, By only 8 bits. see <Dolby Vision HDMI Transmission Specification issue 2.6>*//**<CNcomment:VSVDB1u16MinLuminanceu16MaxLuminance7bitRx, Ry, Gx, Gy, Bx, By8bit*/
+	HI_BOOL     bYUV422_12Bit;          /**<support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal.*//**<CNcomment:YUV422-12BitDolby*/
+    HI_BOOL     b2160P60;               /**<capable of processing a max timming 3840X2160p60(HI_TRUE) /3840X2160p30(HI_FALSE) *//**<CNcomment:YUV422-12BitDolby*/
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:global dimming(HI_TRUE)(HI_FALSE)*/
+
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+
+    HI_U16      u16MinLuminance;        /**<minimum luminance value of the target display ,[0,4095] cd/m^2 */
+    HI_U16      u16MaxLuminance;        /**<maximum luminance value of the target display,[0,4095] cd/m^2 */
+
+    HI_UNF_EDID_DOLBY_CAPS_U uOtherCaps; /**<other caps in Dolby VSVDB. distinction between V0(u8VSVDBVersion=0) and V1(u8VSVDBVersion=1).*//**<CNcomment:DolbyDolby VSVDBV0(u8VSVDBVersion=0)V1(u8VSVDBVersion=1)*/
+
+}HI_UNF_EDID_DOLBY_CAP_S;
+
+/**EDID EOTF support. *//**CNcomment:EDID EOTF */
+typedef struct hiUNF_EDID_EOTF_S
+{
+    HI_BOOL bEotfSdr;               /**<Traditional gamma - SDR Luminance Range. *//**<CNcomment:SinkSDR EOTF*/
+    HI_BOOL bEotfHdr;               /**<Traditional gamma - HDR Luminance Range. *//**<CNcomment:SinkHDR EOTF*/
+    HI_BOOL bEotfSmpteSt2084;       /**<SMPTE ST 2084 *//**<CNcomment:SinkSmpteSt2084 EOTF*/
+    HI_BOOL bEotfHLG;               /**<Hybrid Log-Gamma(HLG) based on Recommendation ITU-R BT.2100-0 *//**<CNcomment:SinkHybrid Log-Gamma(HLG) */
+    HI_BOOL bEotfFuture;            /**<Future EOTF *//**<CNcomment:SinkEOTF*/
+}HI_UNF_EDID_EOTF_S;
+
+/**EDID Supported Static Metadata Descriptor *//**CNcomment:EDID Metadata */
+typedef struct hiUNF_EDID_HDR_METADATA_TYPE_S
+{
+    HI_BOOL bDescriptorType1;       /**<Support Static Metadata Type 1 or not.*//**<CNcomment:Sinkmetadata1*/
+}HI_UNF_EDID_HDR_METADATA_TYPE_S;
+
+/**EDID HDR capability,see <CEA-861.3-2015> *//**CNcomment:EDID HDRCEA-861.3-2015 */
+typedef struct hiUNF_EDID_HDR_CAP_S{
+
+    HI_UNF_EDID_EOTF_S                  stEotf;                 /**<EOTF support. *//**<CNcomment:SinkEOTF*/
+    HI_UNF_EDID_HDR_METADATA_TYPE_S     stMetadata;             /**<static metadata descriptor type(ID) support. *//**<CNcomment:Sinkmetadata*/
+    HI_U8                               u8MaxLuminance_CV;      /**<Desired Content Max Luminance Data. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink*/
+    HI_U8                               u8AverageLumin_CV;      /**<Desired Content Max Frame-average Luminance. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink*/
+    HI_U8                               u8MinLuminance_CV;      /**<Desired Content Min Luminance Data. Real value(in 1cd/m^2) = u8MaxLuminance_CV * (u8MinLuminance_CV/255)^2 / 100  *//**<CNcomment:Sink*/
+}HI_UNF_EDID_HDR_CAP_S;
+
+/**HDMI sink capability of interface*/
+/**CNcomment: HDMI sink  */
+typedef struct hiUNF_EDID_BASE_INFO_S
+{
+    HI_BOOL                         bSupportHdmi;           /**<The Device suppot HDMI or not,the device is DVI when nonsupport HDMI*//**<CNcomment:HDMIDVI.*/
+    HI_UNF_ENC_FMT_E                enNativeFormat;         /**<The sink native video format*//**<CNcomment: */
+    HI_BOOL                         bSupportFormat[HI_UNF_ENC_FMT_BUTT]; /**<video capability,HI_TRUE:support the video display format;HI_FALSE:nonsupport the video display foramt*//**<CNcomment:,HI_TRUEHI_FALSE */
+    HI_UNF_EDID_3D_INFO_S           st3DInfo;               /**<3d Info*//**<CNcomment:3d  */
+    HI_UNF_EDID_DEEP_COLOR_S        stDeepColor;            /**<YCBCR/RGB deep color Info*//**<CNcomment:YCBCR/RGB deep color */
+    HI_UNF_EDID_COLORIMETRY_S       stColorMetry;           /**<colorimetry Info*//**<CNcomment: */
+    HI_UNF_EDID_COLOR_SPACE_S       stColorSpace;           /**<color space Info*//**<CNcomment: */
+
+    HI_UNF_EDID_AUDIO_INFO_S        stAudioInfo[HI_UNF_EDID_MAX_AUDIO_CAP_COUNT];   /**<audio Info*//**<CNcomment: */
+    HI_U32                          u32AudioInfoNum;                                /**<num of audio Info*//**<CNcomment:  */
+    HI_BOOL                         bSupportAudioSpeaker[HI_UNF_EDID_AUDIO_SPEAKER_BUTT];/**<speaker Info*//**<CNcomment:speaker  */
+
+    HI_U8                           u8ExtBlockNum;          /**<edid extend block num Info*//**<CNcomment:edid */
+
+    HI_U8                           u8Version;              /**<the version of manufacture*//**<CNcomment: */
+    HI_U8                           u8Revision;             /**<the revision of manufacture*//**<CNcomment: */
+    HI_UNF_EDID_MANUFACTURE_INFO_S  stMfrsInfo;
+
+    HI_UNF_EDID_CEC_ADDRESS_S       stCECAddr;              /**<cec address Info*//**<CNcomment:cec */
+    HI_BOOL                         bSupportDVIDual;        /**<the DVI support dual-link or not *//**<CNcomment: DVI dual-link  */
+    HI_BOOL                         bSupportsAI;            /**<support AI or not *//**<CNcomment: Supports_AI  */
+    HI_UNF_EDID_TIMING_S            stPerferTiming;         /**<first detailed timing Info*//**<CNcomment:VESA */
+    HI_U32                          u32MaxTMDSClock;        /**<Max TMDS clock in MHz*//**<CNcomment:TMDS(MHz) */
+    HI_BOOL                         bSupportY420Format[HI_UNF_ENC_FMT_BUTT];/**<video capability,HI_TRUE:support the video display format in YCBCR420;HI_FALSE:nonsupport the video display foramt  in YCBCR420*//**<CNcomment:,HI_TRUEYCBCR420HI_FALSE */
+    HI_UNF_EDID_DEEP_COLOR_Y420_S   stY420DeepColor;        /**<YCBCR deep color Info*//**<CNcomment:YCBCR420 deep color  */
+
+    HI_BOOL                         bDolbySupport;          /**<Dolby support flag.When VSVDB is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:VSVDBHI_TRUE;HI_FALSE.*/
+    HI_UNF_EDID_DOLBY_CAP_S         stDolby;                /**<Dolby capability*//**<CNcomment:Dolby */
+    HI_BOOL                         bHdrSupport;            /**<HDR support flag.When HDR Static Metadata Data Block is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:HDR (HI_UNF_EDID_EOTF_SHI_TRUE)HI_TRUE;HI_FALSE.*/
+    HI_UNF_EDID_HDR_CAP_S           stHdr;                  /**<HDR capability*//**<CNcomment:HDR */
+    HI_UNF_EDID_HDCP_S				stHDCPSupport;			/**<HDCP capability,HI_TRUE:support the HDCP version;HI_FALSE:nonsupport the HDCP version*//**<CNcomment:HDCP,HI_TRUEHDCPHI_FALSE */
+    HI_UNF_EDID_BASE_DISP_PARA_S	stBaseDispPara;		    /**<the parameters of display*//**<CNcomment:  */
+} HI_UNF_EDID_BASE_INFO_S;
+
+/**enum define about Video port*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_VIDEO_PORT_E
+{
+    HI_UNF_EDID_VIDEO_PORT_VGA   = 0x00,/**<VGA port *//**<CNcomment: VGA */
+    HI_UNF_EDID_VIDEO_PORT_DVI,         /**<DVI port *//**<CNcomment: DVI */
+    HI_UNF_EDID_VIDEO_PORT_HDMI,        /**<HDMI port *//**<CNcomment: HDMI  */
+    HI_UNF_EDID_VIDEO_PORT_BUTT
+} HI_UNF_EDID_VIDEO_PORT_E;
+
+/**enum define about timing protocol type*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_TIMING_TYPE_E
+{
+    HI_UNF_EDID_TIMING_TYPE_DMT= 0x00,/**< DMT  protocol Timing *//**<CNcomment: DMT */
+    HI_UNF_EDID_TIMING_TYPE_861,/**< 861D  protocol Timing *//**<CNcomment: 861D */
+    HI_UNF_EDID_TIMING_TYPE_CVT,/**< CVT  protocol Timing *//**<CNcomment: CVT */
+    HI_UNF_EDID_TIMING_TYPE_CVT_RB,/**< CVT_RB  protocol Timing *//**<CNcomment: CVT_RB */
+    HI_UNF_EDID_TIMING_TYPE_GTF,/**< GTF  protocol Timing *//**<CNcomment: GTF */
+    HI_UNF_EDID_TIMING_TYPE_BUTT
+} HI_UNF_EDID_TIMING_TYPE_E;
+
+/**enum define about timing type*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_TIMING_ATTR_E
+{
+    HI_UNF_EDID_TIMING_ATTR_NONE = 0x00,/**< None *//**<CNcomment:  */
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_TIMING,/**< None *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_VERTICAL_FREQ,/**< None *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_BUTT
+} HI_UNF_EDID_TIMING_ATTR_E;
+
+/**Detailed Timing Definitions Sync Signal Definitions*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_SYNC_TYPE_E
+{
+    /*Analog Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_ACS_WS_GREEN    = 0x00,     /**<Analog Composite Sync - Without Serrations - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_WS_ALL,                 /**<Analog Composite Sync - Without Serrations - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_DS_GREEN,               /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_DS_ALL,                 /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_WS_GREEN,              /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_WS_ALL,                /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_DS_GREEN,              /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment:  */
+    HI_UNF_EDID_SYNC_BACS_DS_ALL,                /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment:  */
+    /*Digital Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_DCS_WS,                     /**<Digital Composite Sync - Without Serrations*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_DCS_DS,                     /**<Digital Composite Sync - With Serrations (H-sync during V-sync)*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_DSS_VN_HN,                  /**<Digital Separate Sync Vsync(-) Hsync(-)*//**<CNcomment: (-)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VN_HP,                  /**<Digital Separate Sync Vsync(-) Hsync(+)*//**<CNcomment: (-)(+)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HN,                  /**<Digital Separate Sync Vsync(+) Hsync(-)*//**<CNcomment: (+)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HP,                  /**<Digital Separate Sync Vsync(+) Hsync(+)*//**<CNcomment: (+)(+)*/
+    HI_UNF_EDID_SYNC_BUTT
+} HI_UNF_EDID_SYNC_TYPE_E;
+
+
+/**Simple Timing Definitions*/
+/**CNcomment:*/
+typedef struct hiUNF_EDID_SIMPLE_TIMING_S
+{
+    HI_U32              u32Vact;    /**<  Active Line *//**<CNcomment: */
+    HI_U32              u32Hact;/**< Active Pixels *//**<CNcomment: */
+    HI_U32              u32VerFreq;/**<Ver Frequency *//**<CNcomment:  */
+    HI_UNF_EDID_TIMING_TYPE_E          enTimingType;/**< Timing protocol type *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_E          enTimingAttr;/**<timing type *//**<CNcomment: :*/
+} HI_UNF_EDID_SIMPLE_TIMING_S;
+
+/**Detailed Timing Definitions*/
+/**CNcomment:*/
+typedef struct hiUNF_EDID_DETAIL_TIMING_S
+{
+    HI_UNF_EDID_TIMING_S	            stTiming; /**<  Detailed Timing *//**<CNcomment: */
+    HI_UNF_EDID_SYNC_TYPE_E             enSyncType;/**Detailed Timing Definitions Sync Signal Definitions*//**CNcomment:*/
+    HI_UNF_EDID_TIMING_ATTR_E           enTimingAttr;/**<timing type *//**<CNcomment: :*/
+} HI_UNF_EDID_DETAIL_TIMING_S;
+
+/**EDID information*/
+/**CNcomment:EDID*/
+typedef struct hiUNF_EDID_INFO_S
+{
+    HI_UNF_EDID_BASE_INFO_S 		stEDIDBaseInfo;/**< EDID base information *//**<CNcomment: EDID */
+    HI_UNF_EDID_VIDEO_PORT_E        enVideoPort;                  /**<video port  *//**<CNcomment:  */
+    HI_UNF_EDID_SIMPLE_TIMING_S*	pstSimpleTiming;	/**<Simple timing   *//**<CNcomment: */
+    HI_U32                          u32SimpleTimingNum;/**<Simple timing number *//**<CNcomment: */
+    HI_UNF_EDID_DETAIL_TIMING_S*  	pstDetailTiming;	/**<Simple timing *//**<CNcomment: */
+    HI_U32                          u32DetailTimingNum;/**<Simple timing number *//**<CNcomment: */
+} HI_UNF_EDID_INFO_S;
+
+
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      EDID*/
+/** @{*/  /** <!-- [EDID] */
+
+
+/**
+\brief parse the edid information. CNcomment:EDID CNend
+\attention \n
+\param[in]  u32EdidLength EDID data length . CNcomment:EDID   CNend
+\param[in]  *pu8Edid  EDID data point . CNcomment:EDID CNend
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDIDCNend
+
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_EDID_EdidParse(HI_U8* pu8Edid, HI_U32 u32EdidLength, HI_UNF_EDID_INFO_S* pstEdidInfo);
+
+/**
+\brief release the edid information. CNcomment:EDID CNend
+\attention \n
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDIDCNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_VOID HI_UNF_EDID_EdidRelease(HI_UNF_EDID_INFO_S * pstEdidInfo);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_EDID_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_unf_frontend.h unlib/xbmc/linux/hisi/hi_unf_frontend.h
--- git/xbmc/linux/hisi/hi_unf_frontend.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_frontend.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,2549 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name       : hi_unf_frontend.h
+Version         : Initial draft
+Author          : HiSilicon multimedia software group
+Created Date    : 2008-06-05
+Description     : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List   :
+Change History  :
+ ******************************************************************************/
+#ifndef __HI_UNF_FRONTEND_H__
+#define __HI_UNF_FRONTEND_H__
+
+#include "hi_common.h"
+
+#include "hi_unf_i2c.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_I2C_MAX_NUM_USER (15)    /** Maximum I2C channel ID*/ /** CNcomment:I2C*/
+
+#define HI_UNF_DISEQC_MSG_MAX_LENGTH    (6)     /** DiSEqC message length*/  /** CNcomment:DiSEqC*/
+#define HI_UNF_DISEQC_MAX_REPEAT_TIMES  (4)     /** DiSEqC message max repeat times*/ /** CNcomment:DiSEqC*/
+#define MAX_TS_LINE 11                      /** The NO of ts lines that can be configured*/ /** CNcomment:ts*/
+#define TER_MAX_TP              (20)
+
+#define DISEQC_MAX_MOTOR_PISITION (255) /** DiSEqC motor max stored position*/ /** CNcomment:DiSEqC*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+
+/** Sample data, complex format*/
+/** CNcomment: , */
+typedef struct  hiUNF_TUNER_SAMPLE_DATA_S
+{
+    HI_S32 s32DataIP;   /*sample data, i component*/    /**<CNcomment:I*/
+    HI_S32 s32DataQP;   /*sample data, q component*/    /**<CNcomment:Q*/
+} HI_UNF_TUNER_SAMPLE_DATA_S;
+
+/** Sample data length*/
+/** CNcomment: */
+typedef enum hiUNF_TUNER_SAMPLE_DATALEN_E
+{
+    HI_UNF_TUNER_SAMPLE_DATALEN_32,         /*sample 32 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_64,         /*sample 64 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_128,        /*sample 128 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_256,        /*sample 256 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_512,        /*sample 512 pts*/      /**<CNcomment:512*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_1024,       /*sample 1024 pts*/     /**<CNcomment:1024*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_2048,       /*sample 2048 pts*/     /**<CNcomment:2048*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_BUTT        /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_SAMPLE_DATALEN_E;
+
+/** Modulation mode*/
+/** CNcomment: */
+typedef enum hiUNF_QAM_TYPE_E
+{
+    HI_UNF_MOD_TYPE_DEFAULT,          /**<Default QAM mode. The default QAM mode is HI_UNF_MOD_TYPE_QAM_64 at present.*/                /**<CNcomment:QAM, HI_UNF_MOD_TYPE_QAM_64 */
+    HI_UNF_MOD_TYPE_QAM_16 = 0x100,   /**<Enumeration corresponding to the 16QAM mode*/                                                 /**<CNcomment:16QAM*/
+    HI_UNF_MOD_TYPE_QAM_32,           /**<Enumeration corresponding to the 32QAM mode*/                                                 /**<CNcomment:32QAM*/
+    HI_UNF_MOD_TYPE_QAM_64,           /**<Enumeration corresponding to the 64QAM mode*/                                                 /**<CNcomment:64QAM*/
+    HI_UNF_MOD_TYPE_QAM_128,          /**<Enumeration corresponding to the 128QAM mode*/                                                /**<CNcomment:128QAM*/
+    HI_UNF_MOD_TYPE_QAM_256,          /**<Enumeration corresponding to the 256QAM mode*/                                                /**<CNcomment:256QAM*/
+    HI_UNF_MOD_TYPE_QAM_512,          /**<Enumeration corresponding to the 512QAM mode*/                                                /**<CNcomment:512QAM*/
+
+    HI_UNF_MOD_TYPE_BPSK = 0x200,     /**<Enumeration corresponding to the binary phase shift keying (BPSK) mode. */                    /**<CNcomment:BPSK*/
+    HI_UNF_MOD_TYPE_QPSK = 0x300,     /**<Enumeration corresponding to the quaternary phase shift keying (QPSK) mode. */                /**<CNcomment:QPSK*/
+    HI_UNF_MOD_TYPE_DQPSK,
+    HI_UNF_MOD_TYPE_8PSK,             /**<Enumeration corresponding to the 8 phase shift keying (8PSK) mode*/                           /**<CNcomment:8PSK*/
+    HI_UNF_MOD_TYPE_16APSK,           /**<Enumeration corresponding to the 16-Ary Amplitude and Phase Shift Keying (16APSK) mode*/      /**<CNcomment:16APSK*/
+    HI_UNF_MOD_TYPE_32APSK,           /**<Enumeration corresponding to the 32-Ary Amplitude and Phase Shift Keying (32APSK) mode*/      /**<CNcomment:32APSK*/
+    HI_UNF_MOD_TYPE_8VSB,             /**<Enumeration corresponding to (8VSB) mode*/                                                    /**<CNcomment:8VSB*/
+    HI_UNF_MOD_TYPE_16VSB,            /**<Enumeration corresponding to (16VSB) mode*/                                                   /**<CNcomment:16VSB*/
+
+    /**<Enumeration corresponding to the auto mode. For DVB-S/S2, if detect modulation type fail, it will return auto*/
+    /**<CNcomment:AUTO*/
+    HI_UNF_MOD_TYPE_AUTO,
+
+    HI_UNF_MOD_TYPE_BUTT              /**<Invalid Modulation mode*/       /**<CNcomment:*/
+} HI_UNF_MODULATION_TYPE_E;
+
+/** Frequency locking status of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum  hiUNF_TUNER_LOCK_STATUS_E
+{
+    HI_UNF_TUNER_SIGNAL_DROPPED = 0,       /**<The signal is not locked.*/  /**<CNcomment:*/
+    HI_UNF_TUNER_SIGNAL_LOCKED,            /**<The signal is locked.*/      /**<CNcomment:*/
+    HI_UNF_TUNER_SIGNAL_BUTT               /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_TUNER_LOCK_STATUS_E;
+
+/** Output mode of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_OUTPUT_MODE_E
+{
+    HI_UNF_TUNER_OUTPUT_MODE_DEFAULT ,            /**<Default mode*/                       /**<CNcomment:*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_A,     /**<Parallel mode A*/                    /**<CNcomment:A*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_B,     /**<Parallel mode B*/                    /**<CNcomment:B*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL,              /**<Serial mode 74.25M*/                 /**<CNcomment:74.25M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_50,           /**<Serial mode 50M*/                    /**<CNcomment:50M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_2BIT,         /**<Serial mode witch 2 bit data line*/  /**<CNcomment:2bit*/
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_PARALLEL,       /**<FULLBAND Parallel mode */               /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_3WIRE,   /**<FULLBAND SERIAL three wire mode */      /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_4WIRE,   /**<FULLBAND SERIAL four wire mode */       /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_BUTT                 /**<Invalid value*/                      /**<CNcomment:*/
+} HI_UNF_TUNER_OUPUT_MODE_E;
+
+/** Output order*/
+/** CNcomment:TUNER */
+typedef enum hiUNF_TUNER_OUTPUT_TS_E
+{
+    HI_UNF_TUNER_OUTPUT_TSDAT0,        /**<data0*/                       /**<CNcomment:0bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT1,        /**<data1*/                       /**<CNcomment:1bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT2,        /**<data2*/                       /**<CNcomment:2bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT3,        /**<data3*/                       /**<CNcomment:3bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT4,        /**<data4*/                       /**<CNcomment:4bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT5,        /**<data5*/                       /**<CNcomment:5bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT6,        /**<data6*/                       /**<CNcomment:6bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT7,        /**<data7*/                       /**<CNcomment:7bit*/
+    HI_UNF_TUNER_OUTPUT_TSSYNC,        /**<sync*/                        /**<CNcomment:sync*/
+    HI_UNF_TUNER_OUTPUT_TSVLD,         /**<valid*/                       /**<CNcomment:valid*/
+    HI_UNF_TUNER_OUTPUT_TSERR,         /**<err*/                         /**<CNcomment:err*/
+    HI_UNF_TUNER_OUTPUT_BUTT           /**<Invalid value*/               /**<CNcomment:*/
+} HI_UNF_TUNER_OUTPUT_TS_E;
+
+/** ts output port order*/
+/** CNcomment:ts */
+typedef struct hiUNF_TUNER_TSOUT_SET_S
+{
+    HI_UNF_TUNER_OUTPUT_TS_E enTSOutput[MAX_TS_LINE];   /**<ts output port order*/    /**<CNcomment:ts*/
+} HI_UNF_TUNER_TSOUT_SET_S;
+
+/** Signal type of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum    hiTUNER_SIG_TYPE_E
+{
+    HI_UNF_TUNER_SIG_TYPE_CAB       = 1,        /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX A/C(DVB_C)*/
+    HI_UNF_TUNER_SIG_TYPE_SAT       = 2,        /**<Satellite signal*/      /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T     = 4,        /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T2    = 8,        /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_ISDB_T    = 16,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_ATSC_T    = 32,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DTMB      = 64,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_J83B      = 128,      /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX B(US Cable)*/
+    HI_UNF_TUNER_SIG_TYPE_ABSS      = 256,      /**ABS-S signal */          /**<CNcomment: */
+    HI_UNF_TUNER_SIG_TYPE_BUTT                  /**<Invalid value*/         /**<CNcomment:*/
+} HI_UNF_TUNER_SIG_TYPE_E;
+
+/** type of TUNER device*/
+/** CNcomment:TUNER*/
+typedef enum    hiUNF_TUNER_DEV_TYPE_E
+{
+    HI_UNF_TUNER_DEV_TYPE_XG_3BL,               /**<XG_3BL,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616,               /**<CD1616,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_ALPS_TDAE,            /**<ALPS_TDAE,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDCC,                 /**<TDCC,                   Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250,             /**<TDA18250*/                                 /**<CNcomment:TDA18250*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616_DOUBLE,        /**<CD1616 with double agc, Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MT2081,               /**<MT2081,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TMX7070X,             /**<THOMSON7070X,           Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_R820C,                /**<R820C*/                                    /**<CNcomment:R820C*/
+    HI_UNF_TUNER_DEV_TYPE_MXL203,               /**<MXL203 */                                  /**<CNcomment:MXL203*/
+    HI_UNF_TUNER_DEV_TYPE_AV2011,               /**<AV2011*/                                   /**<CNcomment:AV2011*/
+    HI_UNF_TUNER_DEV_TYPE_SHARP7903,            /**<SHARP7903,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL101,               /**<MXL101,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL603,               /**<MXL603*/                                   /**<CNcomment:MXL603*/
+    HI_UNF_TUNER_DEV_TYPE_IT9170,               /**<IT9170,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_IT9133,               /**<IT9133,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA6651,              /**<TDA6651,                Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250B,            /**<TDA18250B*/                                /**<CNcomment:TDA18250B*/
+    HI_UNF_TUNER_DEV_TYPE_M88TS2022,            /**<M88TS2022,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_RDA5815,              /**<RDA5815*/                                  /**<CNcomment:RDA5815*/
+    HI_UNF_TUNER_DEV_TYPE_MXL254,               /**<MXL254*/                                   /**<CNcomment:MXL254*/
+    HI_UNF_TUNER_DEV_TYPE_CXD2861,              /**<CXD2861,                Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_SI2147,               /**<Si2147*/                                   /**<CNcomment:Si2147*/
+    HI_UNF_TUNER_DEV_TYPE_RAFAEL836,            /**<Rafael836*/                                /**<CNcomment:Rafael836*/
+    HI_UNF_TUNER_DEV_TYPE_MXL608,               /**<MXL608*/                                   /**<CNcomment:MXL608*/
+    HI_UNF_TUNER_DEV_TYPE_MXL214,               /**<MXL214*/                                   /**<CNcomment:MXL214*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18280,             /**<TDA18280*/                                 /**<CNcomment:TDA18280*/
+    HI_UNF_TUNER_DEV_TYPE_TDA182I5A,            /**<TDA182I5A*/                                /**<CNcomment:TDA182I5A*/
+    HI_UNF_TUNER_DEV_TYPE_SI2144,               /**<Si2144*/                                   /**<CNcomment:Si2144*/
+    HI_UNF_TUNER_DEV_TYPE_AV2018,               /**<AV2018*/                                   /**<CNcomment:AV2018*/
+    HI_UNF_TUNER_DEV_TYPE_MXL251,               /**<MXL251*/                                   /**<CNcomment:MXL251*/
+    HI_UNF_TUNER_DEV_TYPE_M88TC3800,            /**<M88TC3800,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL601,               /**< MXL601 */                                 /**<CNcomment:MXL601*/
+    HI_UNF_TUNER_DEV_TYPE_MXL683,               /**<MXL683*/                                   /**<CNcomment:MXL683*/
+    HI_UNF_TUNER_DEV_TYPE_AV2026,               /**<AV2026*/                                   /**<CNcomment:AV2026*/
+    HI_UNF_TUNER_DEV_TYPE_R850,                 /**<R850*/                                     /**<CNcomment:R850*/
+    HI_UNF_TUNER_DEV_TYPE_R858,                 /**<R858*/                                     /**<CNcomment:R858*/   
+	HI_UNF_TUNER_DEV_TYPE_BUTT                  /**<Invalid value*/                            /**<CNcomment:*/
+} HI_UNF_TUNER_DEV_TYPE_E ;
+
+/** Type of the demod device*/
+/** CNcomment:demod*/
+typedef enum    hiUNF_DEMOD_DEV_TYPE_E
+{
+    HI_UNF_DEMOD_DEV_TYPE_NONE,                 /**<Not supported*/                         /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3130I = 0x100,        /**<Internal QAM*/                          /**<CNcomment:QAM*/
+    HI_UNF_DEMOD_DEV_TYPE_3130E,                /**<External Hi3130*/                       /**<CNcomment:QAM hi3130*/
+    HI_UNF_DEMOD_DEV_TYPE_J83B,                 /**<suppoort j83b*/                         /**<CNcomment:j83b*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6211,              /**<Avalink 6211*/                          /**<CNcomment:Avalink 6211*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL101,               /**<Maxlinear mxl101,    Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88472,              /**<PANASONIC mn88472*/                     /**<CNcomment:PANASONIC mn88472*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9170,               /**<ITE it9170,          Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9133,               /**<ITE it9133,          Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3136,                 /**<External Hi3136*/                       /**<CNcomment:hi3136*/
+    HI_UNF_DEMOD_DEV_TYPE_3136I,                /**<Internal Hi3136*/                       /**<CNcomment:hi3136*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL254,               /**<External mxl254*/                       /**<CNcomment:MXL254*/
+    HI_UNF_DEMOD_DEV_TYPE_CXD2837,              /**Sony cxd2837,         Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3137,                 /**External Hi3137*/                        /**<CNcomment:hi3137*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL214,               /**<External mxl214*/                       /**<CNcomment:MXL214*/
+    HI_UNF_DEMOD_DEV_TYPE_TDA18280,             /**<External tda18280*/                     /**<CNcomment:tda18280*/
+    HI_UNF_DEMOD_DEV_TYPE_HIFDVBC100,           /**<External HiFdvbc100, Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_HIFJ83B100,           /**<External HiFj83b100, Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL251,               /**<External mxl251*/                       /**<CNcomment:MXL251*/
+    HI_UNF_DEMOD_DEV_TYPE_3138,                 /**External Hi3138*/                        /**<CNcomment:hi3138*/
+    HI_UNF_DEMOD_DEV_TYPE_ATBM888X,             /**External ATBM888X*/                      /**<CNcomment:ATBM888X*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88473,              /**< Panasonic 88473 */                     /**<CNcomment:Panasonic 88473 */
+    HI_UNF_DEMOD_DEV_TYPE_MXL683,               /**<External mxl683*/                       /**<CNcomment:mxl683*/
+    HI_UNF_DEMOD_DEV_TYPE_TP5001,               /**External TP5001*/                        /**<CNcomment:TP5001*/
+    HI_UNF_DEMOD_DEV_TYPE_HD2501,               /**External HD2501*/                        /**<CNcomment:HD2501*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6381,              /**External AVL6381*/                       /**<CNcomment:AVL6381*/
+    HI_UNF_DEMOD_DEV_TYPE_BUTT                  /**<Invalid value*/                         /**<CNcomment:*/
+} HI_UNF_DEMOD_DEV_TYPE_E;
+
+/** Defines the cable transmission signal.*/
+/** CNcomment:CABLE*/
+typedef struct  hiUNF_CAB_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<Frequency, in kHz*/         /**<CNcomment:kHz*/
+    HI_U32                      u32SymbolRate;      /**<Symbol rate, in bit/s*/     /**<CNcomment:bps */
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<QAM mode*/                  /**<CNcomment:QAM*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:kHz*/
+} HI_UNF_CAB_CONNECT_PARA_S;
+
+/** Guard interval of OFDM*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_GUARD_INTV_E
+{
+    HI_UNF_TUNER_FE_GUARD_INTV_DEFALUT = 0,     /**<default guard interval mode*/   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_128,           /**<1/128*/                         /**<CNcomment:1/128*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_32,            /**<1/32*/                          /**<CNcomment:1/32*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_16,            /**<1/16*/                          /**<CNcomment:1/16*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_8,             /**<1/8*/                           /**<CNcomment:1/8*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_4,             /**<1/4*/                           /**<CNcomment:1/4*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_128,          /**<19/128*/                        /**<CNcomment:19/128*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_256,          /**<19/256*/                        /**<CNcomment:19/256*/
+    HI_UNF_TUNER_FE_GUARD_INTV_BUTT             /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_FE_GUARD_INTV_E;
+
+/** OFDM Mode, used in multi-carrier modulation*/
+/** CNcomment:OFDM*/
+typedef enum hiUNF_TUNER_FE_FFT_E
+{
+    HI_UNF_TUNER_FE_FFT_DEFAULT = 0,   /**<default mode*/     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_1K ,           /**<1k mode*/          /**<CNcomment:1k*/
+    HI_UNF_TUNER_FE_FFT_2K ,           /**<2k mode*/          /**<CNcomment:2k*/
+    HI_UNF_TUNER_FE_FFT_4K ,           /**<4k mode*/          /**<CNcomment:4k*/
+    HI_UNF_TUNER_FE_FFT_8K ,           /**<8k mode*/          /**<CNcomment:8k*/
+    HI_UNF_TUNER_FE_FFT_16K ,          /**<16k mode*/         /**<CNcomment:16k*/
+    HI_UNF_TUNER_FE_FFT_32K ,          /**<32k mode*/         /**<CNcomment:32k*/
+    HI_UNF_TUNER_FE_FFT_64K ,          /**<64k mode*/         /**<CNcomment:64k*/
+    HI_UNF_TUNER_FE_FFT_BUTT           /**<Invalid value*/    /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FFT_E;
+
+/** Hierarchical modulation mode, only used in DVB-T*/
+/** CNcomment:DVB-T*/
+typedef enum hiUNF_TUNER_FE_HIERARCHY_E
+{
+    HI_UNF_TUNER_FE_HIERARCHY_DEFAULT = 0,      /**<hierarchical modulation default mode*/      /**<CNcomment:*/
+    HI_UNF_TUNER_FE_HIERARCHY_NO,               /**<no hierarchical modulation mode*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA1,           /**<hierarchical mode, alpha = 1*/              /**<CNcomment:, alpha = 1*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA2,           /**<hierarchical mode, alpha = 2*/              /**<CNcomment:, alpha = 2*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA4,           /**<hierarchical mode, alpha = 4*/              /**<CNcomment:, alpha = 4*/
+    HI_UNF_TUNER_FE_HIERARCHY_BUTT              /**<Invalid value*/                             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_HIERARCHY_E;
+
+/** TS Priority, only used in DVB-T*/
+/** CNcomment:DVB-T*/
+typedef enum hiUNF_TUNER_TS_PRIORITY_E
+{
+    HI_UNF_TUNER_TS_PRIORITY_NONE = 0,      /**<no priority mode*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_HP,            /**<high priority mode*/        /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_LP,            /**<low priority mode*/         /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_TS_PRIORITY_E;
+
+/** base channel or lite channel, only used in DVB-T2*/
+/** CNcomment:DVB-T2*/
+typedef enum hiUNF_TUNER_TER_MODE_E
+{
+    HI_UNF_TUNER_TER_MODE_BASE = 0,     /**< the channel is base mode*/         /**<CNcomment:base*/
+    HI_UNF_TUNER_TER_MODE_LITE,         /**< the channel is lite mode*/         /**<CNcomment:lite*/
+    HI_UNF_TUNER_TER_MODE_BUTT      /**<Invalid value*/            /**<CNcomment:*/
+} HI_UNF_TUNER_TER_MODE_E;
+
+/** TS clock polarization*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TSCLK_POLAR_E
+{
+    HI_UNF_TUNER_TSCLK_POLAR_FALLING,       /**<Falling edge*/      /**<CNcomment:*/
+    HI_UNF_TUNER_TSCLK_POLAR_RISING,        /**<Rising edge*/       /**<CNcomment:*/
+    HI_UNF_TUNER_TSCLK_POLAR_BUTT           /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TSCLK_POLAR_E;
+
+/** TS format*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TS_FORMAT_E
+{
+    HI_UNF_TUNER_TS_FORMAT_TS,              /**<188*/               /**<CNcomment:188*/
+    HI_UNF_TUNER_TS_FORMAT_TSP,             /**<204*/               /**<CNcomment:204*/
+    HI_UNF_TUNER_TS_FORMAT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TS_FORMAT_E;
+
+/** TS serial PIN*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TS_SERIAL_PIN_E
+{
+    HI_UNF_TUNER_TS_SERIAL_PIN_0,           /**<Serial pin 0, default*/  /**<CNcomment:0bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_7,           /**<Serial pin 7*/           /**<CNcomment:7bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_BUTT         /**<Invalid value*/          /**<CNcomment:*/
+} HI_UNF_TUNER_TS_SERIAL_PIN_E;
+
+/** ISDBT layer information,each layer can be received indepent*/
+/** CNcomment:ISDBT*/
+typedef enum hiUNF_TUNER_ISDBT_MONITOR_LAYER_E
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_ALL,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_A,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_B,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_C,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_BUTT
+}HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E;
+/** Tuner RF AGC mode*/
+/** CNcomment:agc*/
+typedef enum hiUNF_TUNER_RFAGC_MODE_E
+{
+    /**< Inverted polarization, default.This setting is used for a tuner whose gain decreases with increased AGC voltage*/   /**<CNcomment:agc*/
+    HI_UNF_TUNER_RFAGC_INVERT,
+
+    /**< Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage*/             /**<CNcomment:agc*/
+    HI_UNF_TUNER_RFAGC_NORMAL,
+    HI_UNF_TUNER_RFAGC_BUTT                  /**<Invalid value*/                                                             /**<CNcomment:*/
+} HI_UNF_TUNER_RFAGC_MODE_E;
+
+/** TS sync head length */
+typedef enum hiUNF_TUNER_TS_SYNC_HEAD_E
+{
+    HI_UNF_TUNER_TS_SYNC_HEAD_AUTO,
+    HI_UNF_TUNER_TS_SYNC_HEAD_8BIT,
+    HI_UNF_TUNER_TS_SYNC_HEAD_BUTT
+} HI_UNF_TUNER_TS_SYNC_HEAD_E;
+
+/** Tuner IQ spectrum mode*/
+/** CNcomment:IQ*/
+typedef enum hiUNF_TUNER_IQSPECTRUM_MODE_E
+{
+    HI_UNF_TUNER_IQSPECTRUM_NORMAL,         /**<The received signal spectrum is not inverted*/    /**<CNcomment:IQ*/
+    HI_UNF_TUNER_IQSPECTRUM_INVERT,         /**<The received signal spectrum is inverted*/        /**<CNcomment:IQ*/
+    HI_UNF_TUNER_IQSPECTRUM_BUTT            /**<Invalid value*/                                   /**<CNcomment:*/
+} HI_UNF_TUNER_IQSPECTRUM_MODE_E;
+
+/** DiSEqC Wave Mode*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQCWAVE_MODE_E
+{
+    HI_UNF_TUNER_DISEQCWAVE_NORMAL,         /**<Waveform produced by demod*/                 /**<CNcomment:demod*/
+    HI_UNF_TUNER_DISEQCWAVE_ENVELOPE,       /**<Waveform produced by LNB control device*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQCWAVE_BUTT            /**<Invalid value*/                              /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQCWAVE_MODE_E;
+
+/** LNB power supply and control device*/
+/** CNcomment:LNB*/
+typedef enum hiUNF_LNBCTRL_DEV_TYPE_E
+{
+    HI_UNF_LNBCTRL_DEV_TYPE_NONE,           /**<No LNB control device*/      /**<CNcomment:*/
+    HI_UNF_LNBCTRL_DEV_TYPE_MPS8125,        /**<MPS8125*/                    /**<CNcomment:MPS8125*/
+    HI_UNF_LNBCTRL_DEV_TYPE_ISL9492,        /**<ISL9492*/                    /**<CNcomment:ISL9492*/
+    HI_UNF_LNBCTRL_DEV_TYPE_BUTT            /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_LNBCTRL_DEV_TYPE_E;
+
+/** FEC code Rate*/
+/** CNcomment:FEC*/
+typedef enum hiUNF_TUNER_FE_FECRATE_E
+{
+    HI_UNF_TUNER_FE_FEC_AUTO = 0,
+    HI_UNF_TUNER_FE_FEC_1_2,           /**<1/2*/           /**<CNcomment:1/2*/
+    HI_UNF_TUNER_FE_FEC_2_3,           /**<2/3*/           /**<CNcomment:2/3*/
+    HI_UNF_TUNER_FE_FEC_3_4,           /**<3/4*/           /**<CNcomment:3/4*/
+    HI_UNF_TUNER_FE_FEC_4_5,           /**<4/5*/           /**<CNcomment:4/5*/
+    HI_UNF_TUNER_FE_FEC_5_6,           /**<5/6*/           /**<CNcomment:5/6*/
+    HI_UNF_TUNER_FE_FEC_6_7,           /**<6/7*/           /**<CNcomment:6/7*/
+    HI_UNF_TUNER_FE_FEC_7_8,           /**<7/8*/           /**<CNcomment:7/8*/
+    HI_UNF_TUNER_FE_FEC_8_9,           /**<8/9*/           /**<CNcomment:8/9*/
+    HI_UNF_TUNER_FE_FEC_9_10,          /**<9/10*/          /**<CNcomment:9/10*/
+    HI_UNF_TUNER_FE_FEC_1_4,           /**<1/4*/           /**<CNcomment:1/4*/
+    HI_UNF_TUNER_FE_FEC_1_3,           /**<1/3*/           /**<CNcomment:1/3*/
+    HI_UNF_TUNER_FE_FEC_2_5,           /**<2/5*/           /**<CNcomment:2/5*/
+    HI_UNF_TUNER_FE_FEC_3_5,           /**<3/5*/           /**<CNcomment:3/5*/
+    HI_UNF_TUNER_FE_FECRATE_BUTT       /**<Invalid value*/ /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FECRATE_E;
+
+/** Parameter for ISDB-T layer exist or not*/
+/** CNcomment:ISDB-T*/
+typedef union hiUNF_TUNER_ISDBT_LAYERS_IDENTIFY_U
+{
+    struct
+    {
+        HI_U8 u8LayerAExist:1;  /*[0]*/
+        HI_U8 u8LayerBExist:1;  /*[1]*/
+        HI_U8 u8LayerCExist:1;  /*[2]*/
+        HI_U8 reserved:5;       /*[7:3]*/
+    }bits;
+
+    HI_U8 ExistanceFlag;
+}HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U;
+
+/** Parameter for ISDB-T layer configuration*/
+/** CNcomment:ISDB-T*/
+typedef struct hiUNF_TUNER_MONITOR_LAYERS_CONFIG_S
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E enMonitorLayer;  /**<ISDB-T layer exist or not*/ /**<CNcomment:ISDB-T*/
+} HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S;
+
+
+/** Parameter for ISDB-T layer information*/
+/** CNcomment:ISDB-T */
+typedef struct hiUNF_TUNER_ISDBT_LAYERS_INFO_S
+{
+    HI_U8 u8LayerSegNum;            /**<layer segment number*/              /**<CNcomment:segment*/
+    HI_U8 u8LayerReserved[3];
+    HI_UNF_TUNER_FE_HIERARCHY_E enLayerHierMod; /**<layer hierarchy mode*/  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E   enLayerFECRate; /**<layer FEC rate*/        /**<CNcomment:*/
+    HI_UNF_MODULATION_TYPE_E    enLayerModType; /**<layer modulation type*/ /**<CNcomment:*/
+}HI_UNF_TUNER_ISDBT_LAYERS_INFO_S;
+
+/** Parameter for ISDB-T TMCC information*/
+/** CNcomment:ISDB-TTMCC */
+typedef struct hiUNF_TUNER_TMCC_INFO_S
+{
+    HI_U8 u8EmergencyFlag;  /**<the start flag for emergency alarm broadcasting*/                   /**<CNcomment:*/
+    HI_U8 u8PartialFlag;    /**<partial reception flag*/                                            /**<CNcomment:*/
+    HI_U8 u8PhaseShiftCorr; /**<phase shift correction value for connected segment transmission*/   /**<CNcomment:*/
+    HI_U8 u8IsdbtSystemId;  /**<system identification[0 = ISDB_T,1 = ISDB_T_SB]*/                   /**<CNcomment:*/
+
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersAInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersBInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersCInfoBits;
+
+    HI_U8 u8TMCCReserved[4];    /**<Reserve*/                                                       /**<CNcomment:*/
+} HI_UNF_TUNER_TMCC_INFO_S;
+
+/** ADC port select*/
+/** CNcomment:ADC*/
+typedef enum hiUNF_TUNER_ADC_PORT_E
+{
+    HI_UNF_TUNER_ADC0,          /**<ADC0 port*/   /**<CNcomment:ADC0*/
+    HI_UNF_TUNER_ADC1,          /**<ADC1 port*/   /**<CNcomment:ADC1*/
+    HI_UNF_TUNER_ADC_BUTT
+}HI_UNF_TUNER_ADC_PORT_E;
+
+/** TS port select*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TS_OUTPUT_PORT_E
+{
+    HI_UNF_TUNER_TS0_OUTPUT,        /**<TS0 port*/   /**<CNcomment:TS0*/
+    HI_UNF_TUNER_TS1_OUTPUT,        /**<TS1 port*/   /**<CNcomment:TS1*/
+    HI_UNF_TUNER_TS_OUTPUT_BUTT
+}HI_UNF_TUNER_TS_OUTPUT_PORT_E;
+
+/**tuner i2c transmit way select*/
+/** CNcomment:i2c*/
+typedef enum hiUNF_TUNER_I2C_TRANSMISSION_SEL_E
+{
+    HI_UNF_TUNER_I2C_TRANSMISSION_SEL_SCLT_SDAT,    /**<SCLT/SDAT i2c way*/         /**<CNcomment:SCLT/SDAT i2c*/
+    HI_UNF_TUNER_I2C_TRANSMISSION_SEL_TS1_DATAx,    /**<TS1 data0/data1 i2c way*/   /**<CNcomment:TS1 data0/data1 i2c*/
+    HI_UNF_TUNER_I2C_TRANSMISSION_SEL_BUTT
+}HI_UNF_TUNER_I2C_TRANSMISSION_GATEWAY_E;
+
+/** sync pin mux configure*/
+/** CNcomment:sync*/
+typedef enum hiUNF_TUNER_SYNC_PIN_MUX_E
+{
+    HI_UNF_TUNER_SYNC_PIN_MUX_SYNC = 0,     /**<sync pin*/                  /**<CNcomment:sync*/
+    HI_UNF_TUNER_SYNC_PIN_MUX_HV_SEL,       /**< horizontal/Vertical pin*/  /**<CNcomment:/*/
+    HI_UNF_TUNER_SYNC_PIN_MUX_LNB_EN,       /**<lnb enable pin*/            /**<CNcomment:lnb*/
+    HI_UNF_TUNER_SYNC_PIN_MUX_GPIO,         /**<gpio pin*/                  /**<CNcomment:gpio*/
+    HI_UNF_TUNER_SYNC_PIN_MUX_BUTT
+}HI_UNF_TUNER_SYNC_PIN_MUX_E;
+
+/** internal frequence output way select*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_IF_PATH_SEL_E
+{
+    HI_UNF_TUNER_IF_OUTPUT_SEL_SINGLE_I = 0,    /**<single I output*/   /**<CNcomment:I*/
+    HI_UNF_TUNER_IF_OUTPUT_SEL_SINGLE_Q,        /**<single Q output*/   /**<CNcomment:Q*/
+    HI_UNF_TUNER_IF_OUTPUT_SEL_BOTH_IQ,         /**<both I/Q output*/   /**<CNcomment:I/Q*/
+    HI_UNF_TUNER_IF_OUTPUT_SEL_BUTT
+}HI_UNF_TUNER_IF_PATH_SEL_E;
+
+/** Satellite extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_SAT_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demodMHz*/
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tunerMHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts*/
+    HI_UNF_TUNER_DISEQCWAVE_MODE_E enDiSEqCWave;    /**<DiSEqC Wave Mode*/                        /**<CNcomment:DiSEqC*/
+    HI_UNF_LNBCTRL_DEV_TYPE_E      enLNBCtrlDev;    /**<LNB power supply and control device*/     /**<CNcomment:LNB*/
+    HI_U16                         u16LNBDevAddress;/**<LNB control device address*/              /**<CNcomment:LNBi2c*/
+} HI_UNF_TUNER_SAT_ATTR_S;
+
+/** Terrestrial extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_TER_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demodMHz*/
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tunerMHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                     /**<CNcomment:ts*/
+} HI_UNF_TUNER_TER_ATTR_S;
+
+/** Cable extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_CAB_ATTR_S
+{
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U32                         u32DemodClk;     /**< Demod reference clock frequency, KHz */
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**< TS clock polarization */
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**< TS format */
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**< TS serial PIN */
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                   /**<CNcomment:ts*/
+} HI_UNF_TUNER_CAB_ATTR_S;
+
+/** Multi mode demod attribution*/
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_MULTI_MODE_CHIP_ATTR_S
+{
+    HI_UNF_TUNER_ADC_PORT_E       enADCPort;                    /**<the index of ADC port*/         /**<CNcomment:*/
+    HI_UNF_TUNER_TS_OUTPUT_PORT_E enTSOutputPort;               /**<the index of TS port*/          /**<CNcomment:TS*/
+    HI_UNF_TUNER_I2C_TRANSMISSION_GATEWAY_E enI2CGateWaySel;    /**<tuner i2c transfer way select*/ /**<CNcomment:tuner i2c*/
+    HI_UNF_TUNER_SYNC_PIN_MUX_E   enSyncPin;                    /**<config sync pin's multiplex*/   /**<CNcomment:sync*/
+    HI_UNF_TUNER_IF_PATH_SEL_E    enIFPath;                     /**<the index of TS port*/          /**<CNcomment:*/
+}HI_UNF_TUNER_MULTI_MODE_CHIP_ATTR_S;
+
+/** Polarization type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_POLARIZATION_E
+{
+    HI_UNF_TUNER_FE_POLARIZATION_H,     /**<Horizontal Polarization*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_V,     /**<Vertical Polarization*/             /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_L,     /**<Left-hand circular Polarization*/   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_R,     /**<Right-hand circular Polarization*/  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_BUTT,  /**<Invalid value*/                     /**<CNcomment:*/
+} HI_UNF_TUNER_FE_POLARIZATION_E;
+
+/** FEC Type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_FECTYPE_E
+{
+    HI_UNF_TUNER_FE_DVBS,               /**<DVB-S*/                         /**<CNcomment:DVB-S*/
+    HI_UNF_TUNER_FE_DVBS2,              /**<DVB-S2*/                        /**<CNcomment:DVB-S2*/
+    HI_UNF_TUNER_FE_DIRECTV,            /**<DIRECTV*/                       /**<CNcomment:DIRECTV*/
+    HI_UNF_TUNER_FE_BUTT                /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FECTYPE_E;
+
+/** LNB type*/
+/** CNcomment:LNB*/
+typedef enum hiUNF_TUNER_FE_FE_LNBTYPE_E
+{
+    HI_UNF_TUNER_FE_LNB_SINGLE_FREQUENCY,   /**<Single LO frequency*/       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_DUAL_FREQUENCY,     /**<Dual LO frequency*/         /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_UNICABLE,           /**<Unicable LNB */             /**<CNcomment:unicable*/
+    HI_UNF_TUNER_FE_LNB_TRIPLE_FREQUENCY,   /**<Triple LO frequency*/       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_TYPE_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_TYPE_E;
+
+/** LNB band type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_LNB_BAND_E
+{
+    HI_UNF_TUNER_FE_LNB_BAND_C,             /**<C */                        /**<CNcomment:C*/
+    HI_UNF_TUNER_FE_LNB_BAND_KU,            /**<Ku */                       /**<CNcomment:Ku*/
+    HI_UNF_TUNER_FE_LNB_BAND_KA,            /**<Ka */                       /**<CNcomment:Ka*/
+    HI_UNF_TUNER_FE_LNB_BAND_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_BAND_E;
+
+/** LNB power control*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_LNB_POWER_E
+{
+    HI_UNF_TUNER_FE_LNB_POWER_OFF,          /**<LNB power off*/                                                     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_POWER_ON,           /**<LNB power auto, 13V/18V, default*/                                  /**<CNcomment:13/18V*/
+    HI_UNF_TUNER_FE_LNB_POWER_ENHANCED,     /**<LNB power auto, 14V/19V, some LNB control device can support.*/     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_POWER_BUTT          /**<Invalid value*/                                                     /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_POWER_E;
+
+typedef enum hiUNF_TUNER_TER_ANTENNA_POWER_E
+{
+    HI_UNF_TUNER_TER_ANTENNA_POWER_OFF,
+    HI_UNF_TUNER_TER_ANTENNA_POWER_ON,
+    HI_UNF_TUNER_TER_ANTENNA_POWER_BUTT
+} HI_UNF_TUNER_TER_ANTENNA_POWER_E;
+
+typedef enum hiUNF_TUNER_DEMOD_STATUS_E
+{
+    HI_UNF_TUNER_DEMODE_WAKE_UP = 0,
+    HI_UNF_TUNER_DEMODE_STANDBY,
+    HI_UNF_TUNER_DEMOD_STATUS_BUTT
+}HI_UNF_TUNER_DEMOD_STATUS_E;
+
+/** LNB 22K tone status, for Ku band LNB*/
+/** CNcomment:22kKu*/
+typedef enum hiUNF_TUNER_FE_LNB_22K_E
+{
+    HI_UNF_TUNER_FE_LNB_22K_OFF,            /**<22k off*/                    /**<CNcomment:22k*/
+    HI_UNF_TUNER_FE_LNB_22K_ON,             /**<22k on*/                     /**<CNcomment:22k*/
+    HI_UNF_TUNER_FE_LNB_22K_BUTT            /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_22K_E;
+
+/** 0/12V switch*/
+/** CNcomment:0/12V*/
+typedef enum hiUNF_TUNER_SWITCH_0_12V_E
+{
+    HI_UNF_TUNER_SWITCH_0_12V_NONE,         /**< None, default*/            /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_0_12V_0,            /**< 0V*/                       /**<CNcomment:0V*/
+    HI_UNF_TUNER_SWITCH_0_12V_12,           /**< 12V*/                      /**<CNcomment:12V*/
+    HI_UNF_TUNER_SWITCH_0_12V_BUTT          /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_0_12V_E;
+
+/** 22KHz switch*/
+/** CNcomment:22K*/
+typedef enum hiUNF_TUNER_SWITCH_22K_E
+{
+    HI_UNF_TUNER_SWITCH_22K_NONE,           /**< None, default*/            /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_22K_0,              /**< 0*/                        /**<CNcomment:0kHz*/
+    HI_UNF_TUNER_SWITCH_22K_22,             /**< 22KHz*/                    /**<CNcomment:22kHz*/
+    HI_UNF_TUNER_SWITCH_22K_BUTT            /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_22K_E;
+
+/** Tone burst switch*/
+/** CNcomment:Tone burst*/
+typedef enum hiUNF_TUNER_SWITCH_TONEBURST_E
+{
+    HI_UNF_TUNER_SWITCH_TONEBURST_NONE,     /**< Don't send tone burst, default*/ /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_0,        /**< Tone burst 0*/                   /**<CNcomment:0 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_1,        /**< Tone burst 1*/                   /**<CNcomment:1 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_BUTT      /**<Invalid value*/                   /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_TONEBURST_E;
+
+/** scan range*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_SCAN_MODE_E
+{
+    HI_UNF_TUNER_TER_SCAN_DVB_T2 = 0,       /**< scan only DVB-T2*/             /**<CNcomment:DVB-T2*/
+    HI_UNF_TUNER_TER_SCAN_DVB_T,            /**< scan only DVB-T*/              /**<CNcomment:DVB-T*/
+    HI_UNF_TUNER_TER_SCAN_DVB_T_T2_ALL,     /**< scan both DVB-T2 and DVB-T*/   /**<CNcomment:DVB-T2DVB-T*/
+    HI_UNF_TUNER_TER_SCAN_DVB_T_T2_BUTT     /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_TER_SCAN_MODE_E;
+
+/** pilot pattern */
+typedef enum hiUNF_TUNER_TER_PILOT_PATTERN_E
+{
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP1 = 0,  /**< pilot pattern pp1 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP2,      /**< pilot pattern pp2 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP3,      /**< pilot pattern pp3 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP4,      /**< pilot pattern pp4 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP5,      /**< pilot pattern pp5 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP6,      /**< pilot pattern pp6 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP7,      /**< pilot pattern pp7 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP8,      /**< pilot pattern pp8 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_BUTT
+} HI_UNF_TUNER_TER_PILOT_PATTERN_E;
+
+/** information for channel mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_CHANNEL_MODE_E
+{
+    HI_UNF_TUNER_TER_PURE_CHANNEL = 0,      /**< pure channel*/     /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MIXED_CHANNEL,         /**< mixed channel*/    /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CHANNEL_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_CHANNEL_MODE_E;
+
+/** information for carrier mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_CARRIER_MODE_E
+{
+    HI_UNF_TUNER_TER_EXTEND_CARRIER = 0,    /**< extend carrier*/   /**<CNcomment:*/
+    HI_UNF_TUNER_TER_NORMAL_CARRIER,        /**< normal carrier*/   /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_CARRIER_MODE_E;
+
+/** CNcomment:code and modulation */
+typedef enum hiUNF_TUNER_CODE_MODULATION_E
+{
+    HI_UNF_TUNER_CODE_MODULATION_VCM_ACM,       /**< VCM/ACM*/      /**<CNcomment:/*/
+    HI_UNF_TUNER_CODE_MODULATION_CCM,           /**< CCM*/          /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_MULTISTREAM,   /**< MultiStream*/  /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_BUTT           /**<Invalid value*/ /**<CNcomment:*/
+} HI_UNF_TUNER_CODE_MODULATION_E;
+
+/** information for constellation mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_CONSTELLATION_MODE_E
+{
+    HI_UNF_TUNER_CONSTELLATION_STANDARD = 0,    /**< standard constellation*/   /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_ROTATION,        /**< rotation constellation*/   /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_BUTT        /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_CONSTELLATION_MODE_E;
+
+/** FEC frame length*/
+/** CNcomment:FEC*/
+typedef enum hiUNF_TUNER_TER_FEC_FRAME_MODE_E
+{
+    HI_UNF_TUNER_TER_FEC_FRAME_NORMAL = 0,      /**< normal fec frame*/ /**<CNcomment:fec*/
+    HI_UNF_TUNER_TER_FEC_FRAME_SHORT,           /**< short fec frame*/  /**<CNcomment:fec*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_BUTT        /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_FEC_FRAME_MODE_E;
+
+/** Structure of the satellite transmission signal.*/
+/** CNcomment:Satellite*/
+typedef struct  hiUNF_SAT_CONNECT_PARA_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/ /**<CNcomment:kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/     /**<CNcomment:Symb/s */
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/          /**<CNcomment:*/
+    HI_U32                         u32ScrambleValue; /**<initial scrambling code,range 0~262141,when value is not 0,signal is special,
+    and the value must be telled by signal owner.default 0 must be configed when TP signal is not special*/
+    /**<CNcomment:0~26214100*/
+} HI_UNF_SAT_CONNECT_PARA_S;
+
+/** Terestrial connect param*/
+/** CNcomment:*/
+typedef struct  hiUNF_TER_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<freq in KHz*/               /**<CNcomment:kHz*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:kHz*/
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<modulation type*/           /**<CNcomment:*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;      /**<dvb-t2 */
+    HI_UNF_TUNER_TS_PRIORITY_E  enDVBTPrio;         /**<dvb-t */
+} HI_UNF_TER_CONNECT_PARA_S;
+
+/** Structure of the satellite transmission signal's detailed information.*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_SAT_SIGNALINFO_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/              /**<CNcomment:kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/                  /**<CNcomment:Symb/s*/
+    HI_UNF_MODULATION_TYPE_E       enModType;       /**<Modulation type*/                         /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/                       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECTYPE_E      enSATType;       /**<Saterllite standard, DVB-S/S2/DIRECTV*/   /**<CNcomment: DVB-S/S2/DIRECTV*/
+    HI_UNF_TUNER_FE_FECRATE_E      enFECRate;       /**<FEC rate*/                                /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_E enCodeModulation;
+} HI_UNF_TUNER_SAT_SIGNALINFO_S;
+
+/** PLP type of DVB-T2.*/
+/** CNcomment:T2*/
+typedef enum hiUNF_TUNER_T2_PLP_TYPE_E
+{
+    HI_UNF_TUNER_T2_PLP_TYPE_COM=0,         /**<common type*/              /**<CNcomment:*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT1,          /**<data1 type*/               /**<CNcomment:1*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT2,          /**<data2 type*/               /**<CNcomment:2*/
+    HI_UNF_TUNER_T2_PLP_TYPE_BUTT           /**<Invalid value*/            /**<CNcomment:*/
+} HI_UNF_TUNER_T2_PLP_TYPE_E;
+
+/** Structure of the terrestrial transmission signal's detailed information.*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_TER_SIGNALINFO_S
+{
+    HI_U32                              u32Freq;                /**<Frequency, in kHz*/         /**<CNcomment:kHz*/
+    HI_U32                              u32BandWidth;           /**<Band width, in KHz*/        /**<CNcomment:KHz */
+    HI_UNF_MODULATION_TYPE_E            enModType;              /**<Modulation type*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E           enFECRate;              /**<FEC rate*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E           enLowPriFECRate;
+    HI_UNF_TUNER_FE_GUARD_INTV_E        enGuardIntv;            /**<GI mode*/                   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_E               enFFTMode;              /**<FFT mode*/                  /**<CNcomment:FFT*/
+    HI_UNF_TUNER_FE_HIERARCHY_E         enHierMod;              /**<Hierarchical Modulation and alpha, only used in DVB-T*/
+                                                                /**<CNcomment:hierachicalalpha*/
+    HI_UNF_TUNER_TS_PRIORITY_E          enTsPriority;           /**<The TS priority, only used in DVB-T*/
+                                                                /**<CNcomment:ts priority, DVB-T*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E          enPLPType;              /**<PLP type*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_TER_PILOT_PATTERN_E    enPilotPattern;         /**<pilot pattern*/             /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_E     enCarrierMode;          /**<carrier mode*/              /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_E   enConstellationMode;    /**<constellation mode*/        /**<CNcomment:*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_E   enFECFrameMode;         /**<FEC frame length*/          /**<CNcomment:FEC*/
+} HI_UNF_TUNER_TER_SIGNALINFO_S;
+
+/** Structure of the ISDB-T terrestrial transmission signal's detailed information.*/
+/** CNcomment:ISDB-T*/
+typedef struct  hiUNF_TUNER_ISDB_T_SIGNALINFO_S
+{
+    HI_U32                                  u32Freq;            /**<Frequency, in kHz */        /**<CNcomment:: kHz */
+    HI_U32                                  u32BandWidth;       /**<Band width, in KHz */       /**<CNcomment:KHz */
+    HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U    unISDBTLayers;      /**<the transmission and used information of ISDBT layer*/          /**<CNcomment:ISDBT*/
+    HI_UNF_TUNER_TMCC_INFO_S                stISDBTTMCCInfo;    /**<the para of ISDBT layer*/   /**<CNcomment:ISDBT*/
+    HI_UNF_TUNER_FE_GUARD_INTV_E            enGuardIntv;        /**<GI mode*/                   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_E                   enFFTMode;          /**<FFT mode*/                  /**<CNcomment:FFT*/
+} HI_UNF_TUNER_ISDB_T_SIGNALINFO_S;
+
+/** signal information.*/
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_SIGNALINFO_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;              /**<Signal transmission type*/    /**<CNcomment:*/
+
+    union
+    {
+        HI_UNF_TUNER_SAT_SIGNALINFO_S stSat;        /**<Signal info of satellite*/    /**<CNcomment:*/
+        HI_UNF_TUNER_TER_SIGNALINFO_S stTer;        /**<Signal info of terrestrial*/  /**<CNcomment:*/
+        HI_UNF_TUNER_ISDB_T_SIGNALINFO_S stIsdbT;/**<Signal info of ISDB-T terrestrial*/  /**<CNcomment:ISDB-T*/
+    } unSignalInfo;
+} HI_UNF_TUNER_SIGNALINFO_S;
+
+/** unicable multi-switch port.*/
+/** CNcomment:unicable*/
+typedef enum hiUNF_TUNER_SATPOSITION_E
+{
+    HI_UNF_TUNER_SATPOSN_A,    /**<unicable switch port A*/    /**<CNcomment:A*/
+    HI_UNF_TUNER_SATPOSN_B,    /**<unicable switch port B*/    /**<CNcomment:B*/
+    HI_UNF_TUNER_SATPOSN_BUT   /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SATPOSITION_E;
+
+/** LNB configurating parameters*/
+/** CNcomment:LNB*/
+typedef struct hiUNF_TUNER_FE_LNB_CONFIG_S
+{
+    HI_UNF_TUNER_FE_LNB_TYPE_E  enLNBType;      /**<LNB type*/                              /**<CNcomment:LNB*/
+    HI_U32                      u32LowLO;       /**< Low Local Oscillator Frequency, MHz */ /**<CNcomment:LNBMHz*/
+    HI_U32                      u32HighLO;      /**< High Local Oscillator Frequency, MHz*/ /**<CNcomment:LNBMHz*/
+    HI_U32                      u32MediumLO;      /**< Medium Local Oscillator Frequency, MHz*/ /**<CNcomment:LNBMHz*/
+    HI_UNF_TUNER_FE_LNB_BAND_E  enLNBBand;      /**< LNB band, C or Ku */                   /**<CNcomment:LNBCKu*/
+    HI_U8 u8UNIC_SCRNO;                         /**< SCR number, 0-7 */                     /**<CNcomment:SCR0-7*/
+    HI_U32 u32UNICIFFreqMHz;                    /**< SCR IF frequency, unit MHz */          /**<CNcomment:SCR MHz*/
+    HI_UNF_TUNER_SATPOSITION_E enSatPosn;       /**< unicable multi-switch port */          /**<CNcomment:unicable*/
+} HI_UNF_TUNER_FE_LNB_CONFIG_S;
+
+/** tuner attribution.*/
+/** CNcomment:TUNER*/
+typedef struct  hiHI_UNF_TUNER_ATTR_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E     enSigType;          /**<Signal type*/                               /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_E     enTunerDevType;     /**<Tuner type*/                                /**<CNcomment:TUNER*/
+    HI_U32                      u32TunerAddr;       /*The i2c address of tuner, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_DEMOD_DEV_TYPE_E     enDemodDevType;     /**<QAM type*/                                  /**<CNcomment:QAM*/
+    HI_U32                      u32DemodAddr;       /*The i2c address of demod, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_TUNER_OUPUT_MODE_E   enOutputMode ;      /**<Output mode of transport streams (TSs)*/    /**<CNcomment:TS*/
+    HI_U8                       enI2cChannel;       /**<I2C channel used by the demod*/             /**<CNcomment:DEMODI2C*/
+    HI_U8                       enTunerI2cChannel;  /**<I2C channel used by the tuner*/             /**<CNcomment:TUNERI2C tuner demodI2CR858*/
+    HI_U32                      u32ResetGpioNo;     /**<Demod reset GPIO NO.*/                      /**<CNcomment:gpio*/
+    HI_UNF_TUNER_MULTI_MODE_CHIP_ATTR_S stPortAttr;  /**<Multi-mode demod attribute*/               /**<CNcomment:*/
+} HI_UNF_TUNER_ATTR_S;
+
+/** Frequency locking parameters of the tuner*/
+/** CNcomment:TUNER*/
+typedef struct  hiUNF_TUNER_CONNECT_PARA_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;          /**<Signal type*/                       /**<CNcomment:*/
+
+    union
+    {
+        HI_UNF_CAB_CONNECT_PARA_S stCab;        /**<Cable transmission signal*/         /**<CNcomment:CABLE*/
+        HI_UNF_TER_CONNECT_PARA_S stTer;        /**<Terrestrial transmission signal*/   /**<CNcomment:*/
+        HI_UNF_SAT_CONNECT_PARA_S stSat;        /**<Satellite transmission signal*/     /**<CNcomment:*/
+    } unConnectPara;
+} HI_UNF_TUNER_CONNECT_PARA_S ;
+
+/** Frequency locking status and parameters of the tuner*/
+/** CNcomment:TUNER*/
+typedef struct  hiUNF_TUNER_STATUS_S
+{
+    HI_UNF_TUNER_LOCK_STATUS_E  enLockStatus ;  /**<Frequency locking status*/               /**<CNcomment:*/
+    HI_UNF_TUNER_CONNECT_PARA_S stConnectPara;  /**<Actual frequency locking parameters*/    /**<CNcomment:*/
+} HI_UNF_TUNER_STATUS_S;
+
+/** Tuner blind scan type*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_MODE_E
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_AUTO = 0,       /**<Blind scan automatically*/  /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_MANUAL,         /**<Blind scan manually*/       /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_BUTT            /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_MODE_E;
+
+/** Definition of blind scan event type*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_EVT_E
+{
+    HI_UNF_TUNER_BLINDSCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_NEWRESULT,       /**<Find new channel*/  /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_EVT_E;
+
+/** Definition of tuner blind scan status*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_STATUS_E
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_STATUS_E;
+
+/** Definition of tuner blind scan status*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_TER_SCAN_STATUS_E
+{
+    HI_UNF_TUNER_TER_SCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:*/
+    HI_UNF_TUNER_TER_SCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TER_SCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:*/
+    HI_UNF_TUNER_TER_SCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:*/
+    HI_UNF_TUNER_TER_SCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:*/
+    HI_UNF_TUNER_TER_SCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_SCAN_STATUS_E;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_STATUS_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E;
+
+/** Structure of satellite TP*/
+/** CNcomment:TUNERTP*/
+typedef struct  hiUNF_TUNER_SAT_TPINFO_S
+{
+    HI_U32                          u32Freq;            /**<Downlink frequency, in kHz*/    /**<CNcomment:kHz*/
+    HI_U32                          u32SymbolRate;      /**<Symbol rate, in bit/s*/         /**<CNcomment:bps */
+    HI_UNF_TUNER_FE_POLARIZATION_E  enPolar;            /**<Polarization type*/             /**<CNcomment:*/
+    HI_U8                           cbs_reliablity;     /**<TP reliability*/                /**<CNcomment:TP*/
+} HI_UNF_TUNER_SAT_TPINFO_S;
+
+/** Structure of terrestrial tp information*/
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_TER_CHANNEL_ATTR_S
+{
+    HI_U32 u32Frequency;        /**<frequency of TP,unit KHz*/                /**<CNcomment:KHz*/
+    HI_U32 u32BandWidth;        /**<BandWidth of TP,unit KHz*/                /**<CNcomment:KHz*/
+    HI_U8  u8DVBTMode;          /**<signal type.0--DVB-T2,1--DVB-T*/          /**<CNcomment:.0--DVB-T2,1--DVB-T*/
+    HI_U8  u8PlpIndex;          /**<plp index*/                               /**<CNcomment:*/
+    HI_U8  u8PlpId;             /**<plp id*/                                  /**<CNcomment:ID*/
+    HI_U8  u8CommId;            /**<common plp id*/                           /**<CNcomment:ID*/
+    HI_U8  u8Combination;       /**<plp combination flag*/                    /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;  /**<channel attribute*/             /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_E  enTSPri;        /**<TS priority, only in DVB-T*/    /**<CNcomment:TSDVB-T*/
+} HI_UNF_TUNER_TER_CHANNEL_ATTR_S;
+
+/** Notify structure of tuner blind scan */
+/** CNcomment:TUNER*/
+typedef union hiUNF_TUNER_BLINDSCAN_NOTIFY_U
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_E* penStatus;             /**<Scanning status*/            /**<CNcomment:*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/          /**<CNcomment:*/
+    HI_UNF_TUNER_SAT_TPINFO_S* pstResult;                   /**<Scanning result*/            /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_NOTIFY_U;
+
+/** Notify structure of tuner blind scan */
+/** CNcomment:TUNER*/
+typedef union hiUNF_TUNER_TER_SCAN_NOTIFY_U
+{
+    HI_UNF_TUNER_TER_SCAN_STATUS_E* penStatus;              /**<Scanning status*/            /**<CNcomment:*/
+    HI_U16*                         pu16ProgressPercent;    /**<Scanning progress*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CHANNEL_ATTR_S *pstResult;             /**<Scanning result*/            /**<CNcomment:*/
+} HI_UNF_TUNER_TER_SCAN_NOTIFY_U;
+
+/** Parameter of the satellite tuner blind scan */
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_SAT_BLINDSCAN_PARA_S
+{
+    /**<LNB Polarization type, only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;
+
+    /**<LNB 22K signal status, for Ku band LNB which has dual LO, 22K ON will select high LO and 22K off select low LO,
+        only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB 22KKuLNBONOFF*/
+    HI_UNF_TUNER_FE_LNB_22K_E      enLNB22K;
+
+    /**<Blind scan start IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:()kHz*/
+    HI_U32                         u32StartFreq;
+
+    /**<Blind scan stop IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:()kHz*/
+    HI_U32                         u32StopFreq;
+
+    /**<The execution of the blind scan may change the 13/18V or 22K status.
+        If you use any DiSEqC device which need send command when 13/18V or 22K status change,
+        you should registe a callback here. Otherwise, you can set NULL here.*/
+    /**<CNcomment:22KDiSEqC13/18V22K
+        NULL */
+    HI_VOID (*pfnDISEQCSet)(HI_U32 u32TunerId, HI_UNF_TUNER_FE_POLARIZATION_E enPolar,
+                            HI_UNF_TUNER_FE_LNB_22K_E enLNB22K);
+
+    /**<Callback when scan status change, scan progress change or find new channel.*/
+    /**<CNcomment:*/
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_BLINDSCAN_EVT_E enEVT, HI_UNF_TUNER_BLINDSCAN_NOTIFY_U * punNotify);
+} HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S;
+
+/** Structure of terrestrial scan*/
+/** CNcomment:TUNERDVB-T/T2*/
+typedef struct hiUNF_TUNER_TER_SCAN_ATTR_S
+{
+    HI_U32 u32Frequency;        /**<Scanning frequency,unit KHz*/           /**<CNcomment:KHz*/
+    HI_U32 u32BandWidth;        /**<Scanning band width,unit KHz*/          /**<CNcomment:KHz*/
+    HI_UNF_TUNER_TER_SCAN_MODE_E enScanMode;    /**<Scanning range*/        /**<CNcomment:*/
+    HI_BOOL  bScanLite;                         /**<whether to scan lite signal,0--not scan lite,1--scan base and lite*/
+                                                /**<CNcomment:lite0--lite1--baselite*/
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_TER_SCAN_STATUS_E enEVT, HI_UNF_TUNER_TER_SCAN_NOTIFY_U * punNotify);
+}HI_UNF_TUNER_TER_SCAN_ATTR_S;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E;
+
+typedef union hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E* penStatus;         /**<Scanning status*/   /**<CNcomment:*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/ /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S;
+
+/** Structure of terrestrial scan*/
+/** CNcomment:TUNERDVB-T/T2*/
+typedef struct hiUNF_TUNER_UNICABLE_SCAN_PARA_S
+{
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E enEVT, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S *pNotify);
+} HI_UNF_TUNER_UNICABLE_SCAN_PARA_S;
+
+/** Parameter of the tuner blind scan */
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_BLINDSCAN_PARA_S
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_E enMode;            /**<Scanning mode*/            /**<CNcomment:*/
+    union
+    {
+        HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S stSat;    /**<Scanning parameter*/        /**<CNcomment:*/
+    } unScanPara;
+} HI_UNF_TUNER_BLINDSCAN_PARA_S;
+
+typedef struct hiUNF_TUNER_TER_SCAN_PARA_S
+{
+    HI_UNF_TUNER_TER_SCAN_ATTR_S stTer;
+    HI_UNF_TUNER_TER_CHANNEL_ATTR_S enChanArray[TER_MAX_TP];    /**<result of tp array*/    /**<CNcomment:*/
+    HI_U32 u32ChanNum;                                          /**<number of tp*/          /**<CNcomment:*/
+    HI_S32 s32TimeOut;                                          /**<time out,unit second*/
+}HI_UNF_TUNER_TER_SCAN_PARA_S;
+
+/** Attribute of PLP */
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_TER_PLP_ATTR_S
+{
+    HI_U8                       u8PlpIndex;         /**<PLP index*/             /**<CNcomment:*/
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:ID*/
+    HI_U8                       u8PlpGrpId;         /**<PLP group id*/          /**<CNcomment:ID*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E  enPlpType;          /**<PLP type*/              /**<CNcomment:*/
+} HI_UNF_TUNER_TER_PLP_ATTR_S;
+
+/** configure lock tp PLP attribute,only in DVB-T2 */
+/** CNcomment:DVB-T2*/
+typedef struct hiUNF_TUNER_TER_ACC_S
+{
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:ID*/
+    HI_U8                       u8CommPlpId;        /**<common PLP id*/         /**<CNcomment:ID*/
+    HI_U8                       u8Combination;      /**<PLP combination*/       /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelAttr;      /**<channel attribute*/     /**<CNcomment:lite*/
+} HI_UNF_TUNER_TER_ACC_S;
+
+/** result of terrestrial scan */
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_TER_TPINFO_S
+{
+    HI_U8                           u8ProgNum;          /**<program number*/        /**<CNcomment:*/
+    HI_U8                           u8DVBTMode;         /**<DVB-T or DVB-T2*/       /**<CNcomment:,0--DVB-T2,1--DVB-T*/
+    HI_U8                           u8DVBTHier;         /**<delaminate or not*/     /**<CNcomment:,1--,0--*/
+    HI_UNF_TUNER_TER_MODE_E         enChannelAttr;      /**<base or lite*/          /**<CNcomment:lite*/
+    HI_UNF_TUNER_TER_CHANNEL_MODE_E enChannelMode;      /**<channel mode*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TER_PLP_ATTR_S     enPlpAttr[16];      /**<information of plp*/    /**<CNcomment:*/
+} HI_UNF_TUNER_TER_TPINFO_S;
+
+/** DiSEqC Level*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_LEVEL_E
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_1_X,      /**<1.x, one way*/                  /**<CNcomment:1.x */
+    HI_UNF_TUNER_DISEQC_LEVEL_2_X,      /**<2.x, two way, support reply*/   /**<CNcomment:2.xReply*/
+    HI_UNF_TUNER_DISEQC_LEVEL_BUTT      /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LEVEL_E;
+
+/** Receive status of DiSEqC reply massage*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_RECV_STATUS_E
+{
+    HI_UNF_TUNER_DISEQC_RECV_OK,        /**<Receive successfully*/          /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_UNSUPPORT, /**<Device don't support reply*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_TIMEOUT,   /**<Receive timeout*/               /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_ERROR,     /**<Receive fail*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_BUTT       /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECV_STATUS_E;
+
+/** Structure of the DiSEqC send massage */
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_SENDMSG_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;        /**<Device level*/                         /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_E enToneBurst;    /**<Tone Burst */                          /**<CNcomment:tone*/
+    HI_U8                           au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Message data*/   /**<CNcomment:*/
+    HI_U8                           u8Length;       /**<Message length*/                       /**<CNcomment:*/
+    HI_U8                           u8RepeatTimes;  /**<Message repeat times*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SENDMSG_S;
+
+/** Structure of the DiSEqC reply massage */
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RECVMSG_S
+{
+    HI_UNF_TUNER_DISEQC_RECV_STATUS_E enStatus;     /**<Recieve status*/                                 /**<CNcomment:*/
+    HI_U8                             au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Recieve message data*/   /**<CNcomment:*/
+    HI_U8                             u8Length;     /**<Recieve message length*/                         /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECVMSG_S;
+
+typedef struct hiUNF_TUNER_SCR_UB_S
+{
+    HI_U32          u32SCRNo;
+    HI_S32          s32CenterFreq;      /**<Unit MHz*/
+}HI_UNF_TUNER_SCR_UB_S;
+
+/** DiSEqC Switch port*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_SWITCH_PORT_E
+{
+    HI_UNF_TUNER_DISEQC_SWITCH_NONE = 0,         /**<none*/                                 /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_1,           /**<port1*/                                /**<CNcomment:1*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_2,           /**<port2*/                                /**<CNcomment:2*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_3,           /**<port3*/                                /**<CNcomment:3*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_4,           /**<port4*/                                /**<CNcomment:4*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_5,           /**<port5*/                                /**<CNcomment:5*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_6,           /**<port6*/                                /**<CNcomment:6*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_7,           /**<port7*/                                /**<CNcomment:7*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_8,           /**<port8*/                                /**<CNcomment:8*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_9,           /**<port9*/                                /**<CNcomment:9*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_10,          /**<port10*/                               /**<CNcomment:10*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_11,          /**<port11*/                               /**<CNcomment:11*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_12,          /**<port12*/                               /**<CNcomment:12*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_13,          /**<port13*/                               /**<CNcomment:13*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_14,          /**<port14*/                               /**<CNcomment:14*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_15,          /**<port15*/                               /**<CNcomment:15*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_16,          /**<port16*/                               /**<CNcomment:16*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_BUTT         /**<Invalid value*/                        /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SWITCH_PORT_E;
+
+/** Parameter for DiSEqC 1.0/2.0 switch
+   Some DiSEqC device need set polarization(13/18V) and 22K, you can set them here. */
+/** CNcomment:DiSEqC 1.0/2.0 
+   DiSEqC22K */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH4PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/            /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_E    enPolar;  /**<Polarization type */            /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_22K_E         enLNB22K; /**<22K status*/                    /**<CNcomment:22k*/
+} HI_UNF_TUNER_DISEQC_SWITCH4PORT_S;
+
+/** Parameter for DiSEqC 1.1/2.1 switch */
+/** CNcomment:DiSEqC 1.1/2.1  */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH16PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/            /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/             /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SWITCH16PORT_S;
+
+/** DiSEqC motor limit setting*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_LIMIT_E
+{
+    HI_UNF_TUNER_DISEQC_LIMIT_OFF,              /**<Disable Limits*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_EAST,             /**<Set East Limit*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_WEST,             /**<Set West Limit*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_BUTT              /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LIMIT_E;
+
+/** Difinition of DiSEqC motor move direction*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_DIR_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_EAST,          /**<Move east*/                     /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_WEST,          /**<Move west*/                     /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_BUTT           /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_MOVE_DIR_E;
+
+/** Difinition of DiSEqC motor move type*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_TYPE_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW,         /**<1 step one time, default*/      /**<CNcomment:1 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW1,        /**<2 step one time*/               /**<CNcomment:2 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW2,        /**<3 step one time*/               /**<CNcomment:3 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW3,        /**<4 step one time*/               /**<CNcomment:4 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW4,        /**<5 step one time*/               /**<CNcomment:5 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST,         /**<6 step one time*/               /**<CNcomment:6 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST1,        /**<7 step one time*/               /**<CNcomment:7 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST2,        /**<8 step one time*/               /**<CNcomment:8 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST3,        /**<9 step one time*/               /**<CNcomment:9 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST4,        /**<10 step one time*/               /**<CNcomment:10 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_CONTINUE,          /**<Continuous moving*/             /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_BUTT          /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_MOVE_TYPE_E;
+
+/** Parameter for DiSEqC motor store position*/
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_DISEQC_POSITION_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:*/
+    HI_U32                      u32Pos;         /**<Index of position, 0-255*/          /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_POSITION_S;
+
+/** Parameter for DiSEqC motor limit setting*/
+/** CNcomment:Limit*/
+typedef struct hiUNF_TUNER_DISEQC_LIMIT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_E enLimit;        /**<Limit setting*/                     /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LIMIT_S;
+
+/** Parameter for DiSEqC motor moving*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_MOVE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_E enType;     /**<Moving type*/                   /**<CNcomment:()*/
+} HI_UNF_TUNER_DISEQC_MOVE_S;
+
+/** Parameter for DiSEqC motor running*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RUN_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:*/
+    HI_U32                          u32RunningSteps;        /**<0 mean running continus;1~128 mean running steps every time.*/
+                                                            /**<CNcomment:01~128step*/
+} HI_UNF_TUNER_DISEQC_RUN_S;
+
+/** Parameter for DiSEqC motor recalculate*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RECALCULATE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_U8                       u8Para1;        /**<Parameter 1*/                   /**<CNcomment:1*/
+    HI_U8                       u8Para2;        /**<Parameter 2*/                   /**<CNcomment:2*/
+    HI_U8                       u8Para3;        /**<Parameter 3*/                   /**<CNcomment:3*/
+    HI_U8                       u8Reserve;      /**<Reserve*/                       /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECALCULATE_S;
+
+/** Parameter for USALS*/
+/** CNcomment:USALS */
+typedef struct hiUNF_TUNER_DISEQC_USALS_PARA_S
+{
+    HI_U16 u16LocalLongitude;   /**<local longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:0.10-18001800-36003600-*/
+    HI_U16 u16LocalLatitude;    /**<local latitude, is 10*latitude, in param N:0-900, S:900-1800(1800-latitude)*/
+                                /**<CNcomment:0.10-900900-18001800-*/
+    HI_U16 u16SatLongitude;     /**<sat longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:0.10-18001800-36003600-*/
+    HI_U16 u16Angular;          /**<calculate result, out param*/
+                                /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_USALS_PARA_S;
+
+/** Parameter for USALS goto angular*/
+/** CNcomment:USALS*/
+typedef struct hiUNF_TUNER_DISEQC_USALS_ANGULAR_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/                                       /**<CNcomment:*/
+    HI_U16                      u16Angular;     /**<Angular, calculated by HI_UNF_TUNER_DISEQC_CalcAngular()*/  /**<CNcomment:HI_UNF_TUNER_DISEQC_CalcAngular*/
+} HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+/*---TUNER---*/
+/**
+\brief Initializes the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+\param N/A                                    CNcomment: CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+\param  N/A                    CNcomment: CNend
+\retval ::HI_SUCCESS Success   CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DeInit(HI_VOID);
+
+/**
+\brief  Obtains the default attributes of the tuner.
+CNcomment:\brief  TUNERCNend
+\attention \n
+This API is available only after the tuner is initialized.
+CNcomment:TUNERCNend
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2CNend
+\param[out] pstTunerAttr The default attributes of the tuner are returned. CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success.                                      CNcomment:  CNend
+\retval ::HI_FAILURE Calling this API fails.                                               CNcomment: API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The Frontend module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:PORT  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:PORT  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDeftAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTunerAttr tuner attributes                            CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL The input I2C channel is invalid. CNcomment:I2C  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetAttr(HI_U32  u32tunerId , const HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief While using satellite channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstSatTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETSATATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_SAT_ATTR_S *pstSatTunerAttr);
+
+/**
+\brief While using terrestrial channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetTerAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_TER_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief While using cable channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetCabAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_CAB_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief Obtains the attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+This API is available only after the tuner is initialized.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.                CNcomment:TUNER0-2 CNend
+\param[out] pstTunerAttr   The current attributes of the tuner are returned. CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                                 CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                                CNcomment: API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Starts the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_INIT  Opening The TUNER module  fails. CNcomment:CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Open (HI_U32    u32tunerId);
+
+
+/**
+\brief Stops the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.     CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS Success                                      CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                     CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Close(HI_U32    u32tunerId);
+
+
+/**
+\brief Locks the frequency of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] pstConnectPara   Information about the frequency of the tuner  CNcomment:TUNERCNend
+\param[in] u32TimeOut  Wait timeout (in ms) when the frequency of the tuner \n
+is locked. The value 0 indicates no wait, and any other value indicates the \n
+maximum wait period.
+                                                                          CNcomment:TUNER0msCNend
+\retval ::HI_SUCCESS Success                                              CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_CONNECT The signal is locked unsuccessfully . CNcomment:CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Connect(HI_U32  u32tunerId , const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara,HI_U32 u32TimeOut);
+
+
+/**
+\brief  set TS out.CNcomment:TS CNend
+\attention \n
+\Please call this API to set TS out. \n
+\There are 12 signals in ts interface, ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clk.\n
+\There're 12 pins in HI3136 or HI3130v200 chip, and each pin can be set to output ts_dat[0..7], ts_sync,\n
+\ts_vld or ts_err, but ts_clk is binded to one pin, cannot be setted.\n
+CNcomment:ts12ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clkHI3136/HI3130V200 12ts\n
+ts_clkts_clkpstTSOUT->enTSOutput[0..7]TS_OUT0..TS_OUT7;\n
+pstTSOUT->enTSOutput[8..10]TS_SYNC,TS_VALID,TS_ERRCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] pstTSOUT   pointer of ts pin.                                  CNcomment:ts::HI_UNF_TUNER_TSOUT_SET_S CNend
+\retval ::HI_SUCCESS                                                      CNcomment: success. CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTSOUT Setting tsout fails. CNcomment:ts out  CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_TUNER_SetTSOUT(HI_U32 u32TunerId, HI_UNF_TUNER_TSOUT_SET_S *pstTSOUT);
+
+/**
+\brief Obtains the frequency locking status and parameters of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] u32TimeOut frequency locking timeout, unit: ms, frequency locking time is related to strength of signal CNcomment:CNend
+               if you want to get the state of locking, the u32TimeOut should be set 100ms at least;
+               if the u32TimeOut is 0, just config register without locking state, return HI_SUCCESS
+               CNcomment: 100ms
+                          0HI_SUCCESSCNend
+\param[out] pstTunerStatus: The current frequency locking status and parameters of the tuner are returned. Note: This parameter is valid only when HI_SUCCESS is returned.  CNcomment: TUNER CNend
+\retval ::HI_SUCCESS Success                    CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetStatus(HI_U32    u32tunerId , HI_UNF_TUNER_STATUS_S  *pstTunerStatus);
+
+
+/**
+\brief Obtains the current bit error rate (BER) of the tuner. The BER is expressed by using the scientific notation.
+CNcomment:\brief TUNER CNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] pu32BER  Pointer to the current BER of the tuner The error bit rate consists of three elements. Their definitions are as follows:
+                      Their definitions are as follows:
+                    pu32BER[0]: integral part of the base number of the BER
+                    pu32BER[1]: decimal part of the base number of the BER x 1000
+                    pu32BER[2]: absolute value of the exponential of the BER
+                    For example, if the BER is 2.156E-7, the values of the three elements are
+                    2, 156, and 7 respectively.
+                    The three elements are valid only when HI_SUCCESS is returned.
+                    Otherwise, the application layer sets a large value as required, for example, 0.5 (the values of the three elements are 5, 0, and 1 respectively).
+                         0.5 (the values of the three elements are 5, 0, and 1 respectively).
+CNcomment:\param[out] pu32BER  TUNER :
+                              pu32BER[0]:
+                              pu32BER[1]:1000
+                              pu32BER[2]:
+                              :2.156E-7
+                              21567
+                              
+                              (0.5501)CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetBER(HI_U32   u32tunerId , HI_U32 *pu32BER);
+
+
+/**
+\brief Obtains the current signal-to-noise ratio (SNR) of the tuner.
+CNcomment:\brief TUNER CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SNR  Pointer to the current SNR of the tuner.
+                    This parameter is valid only when HI_SUCCESS is returned.
+                   Otherwise, the application layer sets the parameter to a small value. range: 0-255.
+CNcomment:\param[out] pu32SNR  TUNER
+                              
+                              0-255CNend
+\retval ::HI_SUCCESS Success                   CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSNR(HI_U32   u32tunerId , HI_U32 *pu32SNR );
+
+
+/**
+\brief Obtains the current signal strength of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SignalStrength  Pointer to the current signal strength of the tuner
+                            For cable signal, the value of *pu32SignalStrength ranges from 20~120.
+                            For satellite signal, the value is 0~100, unit in percent.
+                            For terrestrial signal, the value is 0~100, unit in percent.
+                  This parameter is valid only when HI_SUCCESS is returned.
+                  Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pu32SignalStrength  TUNER
+                            Cable*pu32SignalStrength20~120
+                            Satellite*pu32SignalStrength0~100
+                            Terrestrial*pu32SignalStrength0~100
+                            
+                            CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalStrength(HI_U32   u32tunerId , HI_U32 *pu32SignalStrength );
+
+/**
+\brief Obtains the current signal quality of the tuner, returns a percentage value.
+CNcomment:\brief TUNER( DVB_C J83B)CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SignalQuality   Output pointer.                       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALQUALITY Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalQuality(HI_U32 u32TunerId, HI_U32 *pu32SignalQuality);
+
+/**
+\brief Obtains the actual frequency and symbol rate of the current tuner for cable,terrestrial and satellite
+signal, for terrestrial signal, symbol rate means nothing, ignore it.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32Freq   Pointer to the current frequency of the tuner. CNcomment:TUNERCNend
+\param[out] pu32Symb   Points to the current symbol rate.             CNcomment: CNend
+\retval ::HI_SUCCESS Success                                          CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                         CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetRealFreqSymb( HI_U32 u32TunerId, HI_U32 *pu32Freq, HI_U32 *pu32Symb );
+
+/**
+\brief Obtains current signal information of the TUNER, used in satellite and terrestrial, not necessary for cable.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pstSignalInfo Pointer to a signal info structure.         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALINFO  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SIGNALINFO_S *pstSignalInfo);
+
+/**
+\brief Sets the LNB parameter.
+CNcomment:\brief LNBCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstLNB      Pointer to a LNB parameter structure.          CNcomment:LNBCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBConfig(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_CONFIG_S *pstLNB);
+
+/**
+\brief Sets the LNB power.
+CNcomment:\brief LNBCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLNBPower  The enumeration of the LNB power type.         CNcomment:LNBCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBPower(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_POWER_E enLNBPower);
+
+/**
+\brief Sets PLP ID, only used in DVB-T2.
+CNcomment:\brief IDCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] u8PLPID  The PLP ID.                                       CNcomment:IDCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetPLPID(HI_U32 u32TunerId, HI_U8 u8PLPID);
+
+/**
+\brief Sets PLP read or write mode, only used in DVB-T2.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] u8Mode  1-read ,0-write.                                       CNcomment:1-0-CNend
+
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetPLPMode(HI_U32 u32TunerId, HI_U8 u8Mode);
+
+/**
+\brief Sets common plp id, only used in DVB-T2.
+CNcomment: ID CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] u8PLPID  The common plp id.         CNcomment:ID CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetCommonPLPID(HI_U32 u32TunerId, HI_U8 u8PLPID);
+
+/**
+\brief Sets common plp and data plp combination flag, only used in DVB-T2.
+CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] u8PLPID  The common plp and data plp combination flag.         CNcomment: CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetCommonPLPCombination(HI_U32 u32TunerId, HI_U8 u8PLPID);
+
+/**
+\brief Gets PLP number, only used in DVB-T2.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu8PLPNum  The PLP number.                                CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_GETPLPNUM  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPLPNum(HI_U32 u32TunerId, HI_U8 *pu8PLPNum);
+
+
+/**
+\brief Gets current PLP type, only used in DVB-T2.
+CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] penPLPType  The PLP type.         CNcomment: CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetCurrentPLPType(HI_U32 u32TunerId, HI_UNF_TUNER_T2_PLP_TYPE_E *penPLPType);
+
+/**
+\brief Gets current PLP id, only used in DVB-T2.
+CNcomment: ID CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pt8PlpId  The PLP ID.         CNcomment:ID CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPLPId(HI_U32 u32TunerId, HI_U8 *pu8PLPId);
+
+/**
+\brief Gets current PLP group id, only used in DVB-T2.
+CNcomment: ID CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] ptGrpId  The PLP group ID.         CNcomment:ID CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPLPGrpId(HI_U32 u32TunerId, HI_U8 *pu8PLPGrpId);
+
+HI_S32 HI_UNF_TUNER_SetAntennaPower(HI_U32 u32TunerId, HI_UNF_TUNER_TER_ANTENNA_POWER_E enPower);
+
+
+/**
+\brief Starts blind scan.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to the blind scan parameter.       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_BLINDSCAN Blind scan busy. CNcomment: CNend
+
+\see Please refer to definition of HI_UNF_TUNER_BLINDSCAN_PARA_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStart(HI_U32 u32TunerId, const HI_UNF_TUNER_BLINDSCAN_PARA_S *pstPara);
+
+/**
+\brief Stops blind scan.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStop(HI_U32 u32TunerId);
+
+/**
+\brief Starts terrestrial scan.
+CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to the terrestrial scan parameter.       CNcomment: CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see Please refer to definition of HI_UNF_TUNER_TER_SCAN_PARA_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_TerScanStart( HI_U32 u32TunerId, HI_UNF_TUNER_TER_SCAN_PARA_S *pstPara);
+
+/**
+\brief Stops terrestrial scan.
+CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_TerScanStop( HI_U32 u32TunerId);
+
+/**
+\brief TUNER standby.
+CNcomment:\brief TUNER(  DVB_C J83Bpmoc )  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_STANDBY  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Standby(HI_U32 u32TunerId);
+
+/**
+\brief Wakes up TUNER.
+CNcomment:\brief TUNER(  DVB_C J83Bpmoc ) CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_WAKEUP  Calling this CMD fails. CNcomment:ioctl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_WakeUp( HI_U32 u32TunerId);
+
+/**
+\brief Sends and receives DiSEqC message, only the devices supporting DiSEqC 2.x support receive message.
+CNcomment:\brief DiSEqCDiSEqC 2.xCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER, 0-2 CNend
+\param[in] pstSendMsg  The pointer to a sending message structure.    CNcomment:CNend
+\param[out] pstRecvMsg The pointer to a receiving message structure.If your device is DiSEqC 1.x, you can pass NULL here.
+CNcomment:\param[out] pstRecvMsg DiSEqC 1.xNULLCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Send DiSEqC message fail. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Recv DiSEqC message fail. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SendRecvMessage(HI_U32 u32TunerId,
+                                           const HI_UNF_TUNER_DISEQC_SENDMSG_S * pstSendMsg,
+                                           HI_UNF_TUNER_DISEQC_RECVMSG_S * pstRecvMsg);
+
+/**
+\brief Sets 0/12V switch. Don't support now.
+CNcomment:\brief 0/12VCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch012V(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_0_12V_E enPort);
+
+/**
+\brief Sets 22KHz switch.
+CNcomment:\brief 22KHzCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch22K(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_22K_E enPort);
+
+/**
+\brief Sets tone burst switch.
+CNcomment:\brief Tone burstCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enStatus    The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC  Calling this CMD fails. CNcomment:ioctl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SwitchToneBurst(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_TONEBURST_E enStatus);
+
+//#ifdef DISEQC_SUPPORT
+/**
+\brief Sets DiSEqC 1.0/2.0 switch, at most 4 port.
+CNcomment:\brief DiSEqC 1.0/2.04CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see Please refer to definition of HI_UNF_TUNER_DISEQC_SWITCH4PORT_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch4Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH4PORT_S* pstPara);
+
+/**
+\brief Sets DiSEqC 1.1/2.1 switch, supports 8in1, 16in1 switches.
+CNcomment:\brief DiSEqC 1.1/2.1816CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch16Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH16PORT_S* pstPara);
+
+/**
+\brief Lets the DiSEqC motor store current position.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_StorePos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Lets the DiSEqC motor move to stored position.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoPos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Enables or disables the DiSEqC motor's limit setting.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a limit parameter structure.    CNcomment:limitCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SetLimit(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LIMIT_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief DiSEqCHI_UNF_TUNER_DISEQC_MoveHI_UNF_TUNER_DISEQC_RunStep
+HI_UNF_TUNER_DISEQC_MoveHI_UNF_TUNER_DISEQC_RunStepCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Move(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_MOVE_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_RunStep(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_RUN_S* pstPara);
+
+/**
+\brief Halts DiSEqC motor.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC motor.         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Stop(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Lets the DiSEqC motor recalculate its stored positions.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a recaulculate parameter structure.
+                                                                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Recalculate(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_RECALCULATE_S* pstPara);
+
+/**
+\brief Calculates the angular, basing on site-longitude, site-latitude and satellite-longitude.
+CNcomment:\brief USALSCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in/out] pstPara The pointer to a USALS parameter structure.    CNcomment:USALSCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_CalcAngular(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_USALS_PARA_S* pstPara);
+
+/**
+\brief Gotos the indicated angular.
+CNcomment:\brief USALSCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a USALS angular structure.      CNcomment:USALSCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoAngular(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S* pstPara);
+
+/**
+\brief Resets DiSEqC device.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Reset(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief DiSEqC device standby.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Standby(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Wakes up DiSEqC device.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_WakeUp(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Acquire data to display constellation.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:, 51210242048 3CNend
+\param[out] pstData       The buffer to store data.                          CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetConstellationData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_UNF_TUNER_SAMPLE_DATA_S *pstData);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:, 51210242048 3CNend
+\param[out] pu32Data      The buffer to store data.                          CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSpectrumData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_U32 *pu32Data);
+
+/**
+\brief Get the upper limit time according to the connect parameter.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  pstConnectPara     The pointer to store the connect parameter.   CNcomment:CNend
+\param[out] pu32TimeOutMs      The upper limit time.                         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDefaultTimeout(HI_U32  u32tunerId, const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara, HI_U32 *pu32TimeOutMs);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief VCMIDVCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicPowerOff(HI_U32 u32TunerId,HI_U8 u8SCRNO);
+
+/**
+\brief Each SaTCR generates a tone at the center frequency of its associated band-pass filter.
+CNcomment: unicabletone CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicSCRxOn(HI_U32 u32TunerId);
+
+/**
+\brief Allows to check the application number.
+CNcomment: unicableCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\param[in]  u8AppNo     application number.   CNcomment:unicableCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicConfig(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8AppNo);
+
+/**
+\brief Allows to check LNB local oscillator frequencies.
+CNcomment: unicable LNBCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\param[in]  u8LoFreqNo     local oscillator number.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicLOFREQ(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8LoFreqNo);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief VCMIDVCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:IDCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatIsiID(HI_U32 u32TunerId, HI_U8 u8IsiID);
+
+/**
+\brief Get total vcm streams number.
+CNcomment:\brief VCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  *pu32TotalStream      total streams number.                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatTotalStream(HI_U32 u32TunerId, HI_U8 *pu8TotalStream);
+
+/**
+\brief Get isi id,by setting stream number,will get isi id.
+CNcomment:\brief VCMIDCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8Stream      stream number,can be 0-n.                          CNcomment:CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:IDCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatIsiID(HI_U32 u32TunerId, HI_U8 u8StreamIndex, HI_U8 *pu8IsiID);
+
+/**
+\brief scan 950~2150 frequency range,and find out the user bands.
+CNcomment: 950~2150MHzCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_ScanUserBands(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_PARA_S stScanPara);
+
+HI_S32 HI_UNF_TUNER_UNICABLE_ExitScanUserBands(HI_U32 u32TunerId);
+
+/**
+\brief Copy scanned results,get user bands information.
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out]  pUBInfo     user bands information,included user band number/user band frequency.       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_GetUserBandsInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SCR_UB_S **ppUBInfo, HI_U32 *pu32Num);
+
+/**
+\brief config the scrambing code sequces on physical layer.
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId           Tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in]  u32ScrambleValue     Initial scrambling code. Range 0-262141,
+                                when value is not 0, signal is special       CNcomment:0-2621410 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetScramble(HI_U32 u32TunerId, HI_U32 u32ScrambleValue);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.                                                                          CNcomment:TUNER0-2 CNend
+\param[in]  u32freqStartInHz     The sample data start freqency (Hz), For examle: 435000000 Hz, 698000000 Hz (1000HZ~1300000000HZ).     CNcomment:( ): 435000000 Hz,698000000 Hz(: 1000HZ~1300000000HZ)CNend
+\param[in]  u32freqStepInHz     The sample data step(Hz), For examle: 10000 Hz, 20000 Hz (greater than 10000Hz).                CNcomment:( ): 10000 Hz,20000 Hz (: 10000Hz )CNend
+\param[in]  u32numOfFreqSteps     The sample data number, For examle: 1000, 10000.                                          CNcomment:: 1000,10000CNend
+\param[out] ps16powerData      The buffer to store data.                                                                                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetTunerPowerSpectrumData(HI_U32 u32TunerId, HI_U32 u32freqStartInHz,HI_U32 u32freqStepInHz,HI_U32 u32numOfFreqSteps,HI_S16 *ps16powerData);
+
+/**
+\brief config which ISDBT layer is select to receive.
+CNcomment: ISDBTA/B/CCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  pstMonLayersConfig    the layers configuration.                              CNcomment: CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_MonitorISDBTLayer(HI_U32 u32TunerId, HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S *pstMonLayersConfig);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_unf_hdmi.h unlib/xbmc/linux/hisi/hi_unf_hdmi.h
--- git/xbmc/linux/hisi/hi_unf_hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_hdmi.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,1238 @@
+
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_hdmi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009-12-10
+  Description   :
+  History       :
+  1.Date        : 2009-12-10
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_HDMI_H__
+#define __HI_UNF_HDMI_H__
+
+/* add include here */
+#include "hi_unf_common.h"
+#include "hi_unf_sound.h"
+#include "hi_unf_edid.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**the max infoframe length*//**CNcomment: */
+#define HI_UNF_HDMI_MAX_INFOFRAME_LEN   0X20
+
+/**HDMI default value*//**CNcomment:HDMI  */
+#define HI_UNF_HDMI_DEFAULT_SETTING     0x00
+
+/**HDMI interface ID *//**CNcomment:HDMIID  */
+typedef enum hiUNF_HDMI_ID_E
+{
+    HI_UNF_HDMI_ID_0         = 0,          /**<HDMI interface 0*/ /**<CNcomment:HDMI0 */
+    HI_UNF_HDMI_ID_BUTT
+} HI_UNF_HDMI_ID_E;
+
+/**HDMI event type*//**CNcomment: HDMI */
+typedef enum hiUNF_HDMI_EVENT_TYPE_E
+{
+    HI_UNF_HDMI_EVENT_HOTPLUG = 0x10,       /**<HDMI HotPlug event type*//**<CNcomment:<HDMI */
+    HI_UNF_HDMI_EVENT_NO_PLUG,              /**<HDMI unplug event type*//**<CNcomment:HDMI Cable  */
+    HI_UNF_HDMI_EVENT_EDID_FAIL,            /**<HDMI read edid fail event type*//**<CNcomment:HDMI EDID */
+    HI_UNF_HDMI_EVENT_HDCP_FAIL,            /**<HDCP authentication fail event type *//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_HDCP_SUCCESS,         /**<HDCP authentication succeed event type*//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_RSEN_CONNECT,         /**<TMDS link is connected*//**<CNcomment:TMDS */
+    HI_UNF_HDMI_EVENT_RSEN_DISCONNECT,      /**<TMDS link is disconnected*//**<CNcomment:TMDS */
+    HI_UNF_HDMI_EVENT_HDCP_USERSETTING,     /**<HDMI Reset *//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_BUTT
+}HI_UNF_HDMI_EVENT_TYPE_E;
+
+/*Video color space mode*//**CNcomment:*/
+typedef enum hiUNF_HDMI_VIDEO_MODE
+{
+    HI_UNF_HDMI_VIDEO_MODE_RGB444,          /**<RGB444 output mode*//**<CNcomment:RGB444 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR422,        /**<YCBCR422 output mode*//**<CNcomment:YCBCR422 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR444,        /**<YCBCR444 output mode*//**<CNcomment:YCBCR444 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR420,        /**<YCBCR420 output mode*//**<CNcomment:YCBCR420 */
+    HI_UNF_HDMI_VIDEO_MODE_BUTT
+}HI_UNF_HDMI_VIDEO_MODE_E;
+
+/*HDMI Output Aspect Ratio*//**CNcomment:HDMI*/
+typedef enum hiUNF_HDMI_ASPECT_RATIO_E
+{
+    HI_UNF_HDMI_ASPECT_RATIO_NO_DATA,        /**<Aspect Ratio unknown *//**<CNcomment: */
+    HI_UNF_HDMI_ASPECT_RATIO_4TO3,           /**<Aspect Ratio 4:3  *//**<CNcomment:4:3*/
+    HI_UNF_HDMI_ASPECT_RATIO_16TO9,          /**<Aspect Ratio 16:9 *//**<CNcomment:16:9 */
+    HI_UNF_HDMI_ASPECT_RATIO_64TO27,
+	HI_UNF_HDMI_ASPECT_RATIO_256TO135,
+    HI_UNF_HDMI_ASPECT_RATIO_FUTURE,
+    HI_UNF_HDMI_ASPECT_RATIO_BUTT
+}HI_UNF_HDMI_ASPECT_RATIO_E;
+
+
+/**HDMI Deep color mode*//**CNcomment: HDMI  */
+typedef enum hiUNF_HDMI_DEEP_COLOR_E
+{
+    HI_UNF_HDMI_DEEP_COLOR_24BIT = 0x00,    /**<HDMI Deep color 24bit mode*//**<CNcomment:HDMI 24bit   */
+    HI_UNF_HDMI_DEEP_COLOR_30BIT,           /**<HDMI Deep color 30bit mode*//**<CNcomment:HDMI 30bit   */
+    HI_UNF_HDMI_DEEP_COLOR_36BIT,           /**<HDMI Deep color 36bit mode*//**<CNcomment:HDMI 36bit   */
+    HI_UNF_HDMI_DEEP_COLOR_OFF   = 0xff,
+    HI_UNF_HDMI_DEEP_COLOR_BUTT
+}HI_UNF_HDMI_DEEP_COLOR_E;
+
+/**HDMI AVI infoframe BarInfo enum*//**CNcomment: HDMI AVI BarInfo  */
+typedef enum hiUNF_HDMI_BARINFO_E
+{
+   HDMI_BAR_INFO_NOT_VALID,                 /**<Bar Data not valid *//**<CNcomment:Bar  */
+   HDMI_BAR_INFO_V,                         /**<Vertical bar data valid *//**<CNcomment:Bar  */
+   HDMI_BAR_INFO_H,                         /**<Horizental bar data valid *//**<CNcomment:bar  */
+   HDMI_BAR_INFO_VH                         /**<Horizental and Vertical bar data valid *//**<CNcomment:Bar */
+}HI_UNF_HDMI_BARINFO_E;
+
+/**HDMI AVI infofram ScanInfo enum*//**CNcomment: HDMI AVI ScanInfo  */
+typedef enum hiUNF_HDMI_SCANINFO_E
+{
+    HDMI_SCAN_INFO_NO_DATA      = 0,        /**< No Scan information*//**<CNcomment:  */
+    HDMI_SCAN_INFO_OVERSCANNED  = 1,        /**< Scan information, Overscanned (for television) *//**<CNcomment::  */
+    HDMI_SCAN_INFO_UNDERSCANNED = 2,        /**< Scan information, Underscanned (for computer) *//**<CNcomment::   */
+    HDMI_SCAN_INFO_FUTURE
+}HI_UNF_HDMI_SCANINFO_E;
+
+/**HDMI AVI InfoFrame picture scale enum*//**CNcomment: HDMI AVI Picture scale  */
+typedef enum hiUNF_HDMI_PICTURE_SCALING_E
+{
+    HDMI_PICTURE_NON_UNIFORM_SCALING,       /**< No Known, non-uniform picture scaling  *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_H,                 /**< Picture has been scaled horizentally *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_V,                 /**< Picture has been scaled Vertically *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_HV                 /**< Picture has been scaled Horizentally and Vertically   *//**<CNcomment:  */
+} HI_UNF_HDMI_PICTURE_SCALING_E;
+
+/**HDMI AVI InfoFrame colorimetry enum*//**CNcomment: HDMI AVI   */
+typedef enum hiUNF_HDMI_COLORSPACE_E
+{
+    HDMI_COLORIMETRY_NO_DATA,               /**<Colorimetry No Data option*//**<CNcomment:Colorimetry No Data */
+    HDMI_COLORIMETRY_ITU601,                /**<Colorimetry ITU601 option*//**<CNcomment:Colorimetry ITU601 */
+    HDMI_COLORIMETRY_ITU709,                /**<Colorimetry ITU709 option*//**<CNcomment:Colorimetry ITU709 */
+    HDMI_COLORIMETRY_EXTENDED,              /**<Colorimetry extended option*//**<CNcomment:Colorimetry  */
+    HDMI_COLORIMETRY_XVYCC_601,             /**<Colorimetry xvYCC601 extened option*//**<CNcomment:Colorimetry xvYCC601 */
+    HDMI_COLORIMETRY_XVYCC_709,             /**<Colorimetry xvYCC709 extened option*//**<CNcomment:Colorimetry xvYCC709 */
+	HDMI_COLORIMETRY_S_YCC_601,             /**<Colorimetry S YCC 601 extened option*//**<CNcomment:Colorimetry S YCC 601 */
+	HDMI_COLORIMETRY_ADOBE_YCC_601,         /**<Colorimetry ADOBE YCC 601 extened option*//**<CNcomment:Colorimetry ADOBE YCC 601 */
+	HDMI_COLORIMETRY_ADOBE_RGB,             /**<Colorimetry ADOBE RGB extened option*//**<CNcomment:Colorimetry ADOBE RGB */
+	HDMI_COLORIMETRY_2020_CONST_LUMINOUS,    /**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020:BT2020cYCC */
+    HDMI_COLORIMETRY_2020_NON_CONST_LUMINOUS,/**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020:BT2020RGBBT2020YCC*/
+} HI_UNF_HDMI_COLORSPACE_E;
+
+/**HDMI AVI InfoFrame RGB range enum*//**CNcomment: HDMI AVI RGB  */
+typedef enum hiUNF_HDMI_RGB_QUAN_RAGE_E
+{
+    HDMI_RGB_QUANTIZATION_DEFAULT_RANGE,    /**< Defaulr range, it depends on the video format *//**<CNcomment: */
+    HDMI_RGB_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:16-234 */
+    HDMI_RGB_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment: 0-255 */
+} HI_UNF_HDMI_RGB_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame YCC quantization range enum *//**CNcomment:HDMI AVI YCC  */
+typedef enum hiUNF_HDMI_YCC_QUAN_RAGE_E
+{
+    HDMI_YCC_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:16-234 */
+    HDMI_YCC_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment: 0-255 */
+}HI_UNF_HDMI_YCC_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame AVI video content type enum*//**CNcomment:HDMI AVI AVI  */
+typedef enum hiUNF_HDMI_CONTENT_TYPE_E
+{
+    HDMI_CONTNET_GRAPHIC,                   /**< Graphics type*//**<CNcomment: */
+    HDMI_CONTNET_PHOTO,                     /**< Photo type*//**<CNcomment: */
+    HDMI_CONTNET_CINEMA,                    /**< Cinema type*//**<CNcomment: */
+    HDMI_CONTNET_GAME                       /**< Game type*//**<CNcomment: */
+}HI_UNF_HDMI_CONTENT_TYPE_E;
+
+/**HDMI Priority judgments strategy enum*//**CNcomment:HDMI  */
+typedef enum hiUNF_HDMI_DEFAULT_ACTION_E
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_NULL,   /**<Default action null*//**<CNcomment: */
+    HI_UNF_HDMI_DEFAULT_ACTION_HDMI,   /**<Default action HDMI*//**<CNcomment:HDMI */
+    HI_UNF_HDMI_DEFAULT_ACTION_DVI,    /**<Default action DVI*//**<CNcomment:DVI */
+    HI_UNF_HDMI_DEFAULT_ACTION_BUTT
+}HI_UNF_HDMI_DEFAULT_ACTION_E;
+
+
+/**The hotplug callback function interface */
+/**CNcomment:  */
+typedef void (*HI_UNF_HDMI_CALLBACK)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+/**HDMI Callback Struct*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_CALLBACK_FUNC_S
+{
+    HI_UNF_HDMI_CALLBACK pfnHdmiEventCallback;  /**<callback function pointer*//**<CNcomment:*/
+    HI_VOID             *pPrivateData;         /**<callback funtion param*//**<CNcomment:*/
+ }HI_UNF_HDMI_CALLBACK_FUNC_S;
+
+/**HDMI Open Param*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_OPEN_PARA_S
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_E enDefaultMode;/**<HDMI Priority judgments strategy enum*//**<CNcomment:HDMI  */
+}HI_UNF_HDMI_OPEN_PARA_S;
+
+/**Current HDCP version enum*/
+/**CNcomment:HDCP */
+typedef enum hiUNF_HDMI_HDCP_VERSION_E
+{
+    HI_UNF_HDMI_HDCP_VERSION_NONE,      /**<HDCP version, none HDCP*//**<CNcomment:HDCP */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP14,    /**<HDCP version, HDCP1.4*//**<CNcomment:HDCP1.4 */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP22,    /**<HDCP version, HDCP2.2*//**<CNcomment:HDCP2.2 */
+    HI_UNF_HDMI_HDCP_VERSION_BUTT
+}HI_UNF_HDMI_HDCP_VERSION_E;
+
+/**HDMI status*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_STATUS_S
+{
+    HI_BOOL                 bConnected;             /**<The Device is connected or disconnected *//**<CNcomment: */
+    HI_BOOL                 bSinkPowerOn;           /**<The sink is PowerOn or not*//**<CNcomment:Sink */
+    HI_BOOL                 bAuthed;                /**<HDCP Authentication *//**<CNcomment:HDCP  */
+    HI_U8                   u8Bksv[5];              /**<Bksv of sink 40bits*//**<CNcomment:Bksv */
+    HI_UNF_HDMI_HDCP_VERSION_E enHDCPVersion;       /**<Current HDCP version*//**<CNcomment:HDCP */
+}HI_UNF_HDMI_STATUS_S;
+
+/**Current HDCP mode enum*/
+/**CNcomment:HDCP */
+typedef enum hiUNF_HDMI_HDCP_MODE_E
+{
+    HI_UNF_HDMI_HDCP_MODE_AUTO,			/**< HDCP auto mode,priority is 2.2 then 1.4 to set HDCP according to sink's HDCP-capability *//**<CNcomment:HDCPHDMISinkHDCP2.21.4 */
+    HI_UNF_HDMI_HDCP_MODE_1_4,			/**< forec to HDCP1.4 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:HDCP1.4sinksink */
+    HI_UNF_HDMI_HDCP_MODE_2_2,			/**< forec to HDCP2.2 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:HDCP2.2sinksink */
+    HI_UNF_HDMI_HDCP_BUTT
+}HI_UNF_HDMI_HDCP_MODE_E;
+
+/**the config parameter of HDMI interface*/
+/**CNcomment:HDMI  */
+typedef struct hiUNF_HDMI_ATTR_S
+{
+    HI_BOOL                 bEnableHdmi;         /**<force to HDMI or DVI,the value must set before HI_UNF_HDMI_Start or behind HI_UNF_HDMI_Stop*//**<CNcomment:HDMI,DVI. HI_UNF_HDMI_StartHI_UNF_HDMI_Stop  */
+
+    HI_BOOL                 bEnableVideo;        /**<parameter must set HI_TRUE,or the HDMI diver will force to set HI_TRUE*//**<CNcomment:HI_TRUE, HI_FALSE:HDMIHI_TRUE */
+
+    HI_UNF_HDMI_VIDEO_MODE_E enVidOutMode;       /**<HDMI output vedio mode VIDEO_MODE_YCBCR,VIDEO_MODE_YCBCR444,VIDEO_MODE_YCBCR422,VIDEO_MODE_RGB444 *//**<CNcomment:HDMIVIDEO_MODE_YCBCR444VIDEO_MODE_YCBCR422VIDEO_MODE_RGB444 */
+    HI_UNF_HDMI_DEEP_COLOR_E enDeepColorMode;    /**<Deep Color output mode,defualt: HI_UNF_HDMI_DEEP_COLOR_24BIT *//**<CNcomment:DeepColor, HI_UNF_HDMI_DEEP_COLOR_24BIT */
+    HI_BOOL                 bxvYCCMode;          /**<the xvYCC output mode,default:HI_FALSE*//**<CNcomment:< xvYCCHI_FALSE */
+
+    HI_BOOL                 bEnableAudio;        /**<Enable flag of Audio*//**CNcomment:Enable */
+
+    HI_BOOL                 bEnableAviInfoFrame; /**<Enable flag of AVI InfoFrame,suggestion:enable *//**<CNcomment: AVI InfoFrame */
+    HI_BOOL                 bEnableAudInfoFrame; /**<Enable flag of Audio InfoFrame,suggestion:enable*//**<CNcomment: AUDIO InfoFrame */
+    HI_BOOL                 bEnableSpdInfoFrame; /**<Enable flag of SPD info frame,suggestion:disable*//**<CNcomment: SPD InfoFrame  */
+    HI_BOOL                 bEnableMpegInfoFrame;/**<Enable flag of MPEG info frame,suggestion:disable*//**<CNcomment: MPEG InfoFrame  */
+
+    HI_BOOL                 bHDCPEnable;         /**<0:HDCP disable mode,1:eable HDCP mode.see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< 0:HDCP1:HDCPHI_UNF_HDMI_HdcpEanble */
+
+    HI_BOOL                 bEnableVidModeAdapt; /**<Enable flag of vedio mode & DVI adapting case of user setting incorrect,default:HI_TRUE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:DVI   */
+    HI_BOOL                 bEnableDeepClrAdapt; /**<Enable flag of deep color mode adapting case of user setting incorrect,default: HI_FALSE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:() */
+    HI_BOOL                 bAuthMode;           /**<Enable flag of authentication, suggestion:disable *//**<CNcomment: */
+	HI_UNF_HDMI_HDCP_MODE_E enHDCPMode;          /**<HDCP mode:HI_UNF_HDMI_HDCP_MODE_AUTO, HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2,see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< HDCPHI_UNF_HDMI_HDCP_MODE_AUTO()HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2. HI_UNF_HDMI_HdcpEanble */
+}HI_UNF_HDMI_ATTR_S;
+
+/**HDMI infoFrame type definition*/
+/**CNcomment: HDMI  */
+typedef enum tagHI_UNF_HDMI_INFOFRAME_TYPE_E
+{
+    HI_INFOFRAME_TYPE_AVI,          /**<HDMI AVI InfoFrame type defintion*//**<CNcomment:HDMI AVI InfoFrame  */
+    HI_INFOFRAME_TYPE_SPD,          /**<HDMI SPD InfoFrame type defintion*//**<CNcomment:HDMI SPD InfoFrame  */
+    HI_INFOFRAME_TYPE_AUDIO,        /**<HDMI AUDIO InfoFrame type defintion*//**<CNcomment:HDMI AUDIO InfoFrame  */
+    HI_INFOFRAME_TYPE_MPEG,         /**<HDMI MPEG InfoFrame type defintion*//**<CNcomment:HDMI MPEG InfoFrame  */
+    HI_INFOFRAME_TYPE_VENDORSPEC,   /**<HDMI Specific InfoFrame type defintion*//**<CNcomment:HDMI Vendor Specific InfoFrame  */
+    HI_INFOFRAME_TYPE_BUTT
+}HI_UNF_HDMI_INFOFRAME_TYPE_E;
+
+/**HDMI AVI InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI AVI , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AVI_INFOFRAME_VER2_S
+{
+    HI_UNF_ENC_FMT_E               enTimingMode;            /**<AVI video timing format*//**<CNcomment:AVItiming */
+    HI_UNF_HDMI_VIDEO_MODE_E       enOutputType;            /**<AVI video output color space*//**<CNcomment:AVI */
+    HI_BOOL                        bActive_Infor_Present;   /**<AVI video Active_Infor_Present flag*//**<CNcomment:AVIActive_Infor_Present */
+    HI_UNF_HDMI_BARINFO_E          enBarInfo;               /**<AVI video BarInfo type*//**<CNcomment:AVIBarInfo */
+    HI_UNF_HDMI_SCANINFO_E         enScanInfo;              /**<AVI video ScanInfo type*//**<CNcomment:AVIScanInfo */
+    HI_UNF_HDMI_COLORSPACE_E       enColorimetry;           /**<AVI video Colorimetry type*//**<CNcomment:AVIColorimetry */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enAspectRatio;           /**<AVI video AspectRatio type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enActiveAspectRatio;     /**<AVI video Active AspectRatio type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_PICTURE_SCALING_E  enPictureScaling;        /**<AVI video picture scaling type*//**<CNcomment:AVIscaling */
+    HI_UNF_HDMI_RGB_QUAN_RAGE_E    enRGBQuantization;       /**<AVI video RGB Quantization*//**<CNcomment:AVIRGB */
+    HI_BOOL                        bIsITContent;            /**<AVI video ITContent flag*//**<CNcomment:AVIITcontent */
+    HI_U32                         u32PixelRepetition;      /**<AVI video Pixel Repetition flag*//**<CNcomment:AVI */
+
+    HI_UNF_HDMI_CONTENT_TYPE_E     enContentType;           /**<AVI video content type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_YCC_QUAN_RAGE_E    enYCCQuantization;       /**<AVI video YCC Quantization*//**CNcomment:*< AVIYCC */
+
+    HI_U32                         u32LineNEndofTopBar;     /**<AVI video EndofTopBar coordinate,defualt:0 *//**<CNcomment:AVIEndofTopBar0 */
+    HI_U32                         u32LineNStartofBotBar;   /**<AVI video StartofBotBar coordinate,defualt:0*//**<CNcomment:AVIStartofBotBar0 */
+    HI_U32                         u32PixelNEndofLeftBar;   /**<AVI video EndofLeft coordinate,defualt:0*//**<CNcomment:AVIEndofLeft0 */
+    HI_U32                         u32PixelNStartofRightBar;/**<AVI video StartofRightBar coordinate,defualt:0*//**<CNcomment:AVIStartofRightBar0 */
+}HI_UNF_HDMI_AVI_INFOFRAME_VER2_S;
+
+/**HDMI AUDIO InfoFrame parameter struct ,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AUD_INFOFRAME_VER1_S
+{
+    HI_U32                            u32ChannelCount;          /**<audio frequency channel count*//**<CNcomment:  */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E   enCodingType;             /**<audio frequency coding type,default 0;Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32SampleSize;            /**<audio frequency sample size,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32SamplingFrequency;     /**<audio frequency sampling frequency ,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32ChannelAlloc;          /**<audio frequency channel allocable ,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32LevelShift;            /**<audio frequency Levelshift ,default 0,Refer to Stream Header*//**<CNcomment: Levelshift0Refer to Stream Header */
+    HI_BOOL                           u32DownmixInhibit;        /**<audio frequency DownmixInhibit ,default 0,Refer to Stream Header*//**<CNcomment: DownmixInhibit0Refer to Stream Header */
+}HI_UNF_HDMI_AUD_INFOFRAME_VER1_S;
+
+/**HDMI SPD InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI SPD , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_SPD_INFOFRAME_S
+{
+    HI_U8                          u8VendorName[8];          /**<vendor name*//**<CNcomment: */
+    HI_U8                          u8ProductDescription[16]; /**<product Description*//**<CNcomment: */
+    HI_U8                          u8SrcDevInfo;             /**<Source Device Information  *//**<CNcomment: */
+}HI_UNF_HDMI_SPD_INFOFRAME_S;
+
+/**HDMI Source HDMI MPEG InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI MPEG , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_MPEGSOURCE_INFOFRAME_S
+{
+    HI_U32                         u32MPEGBitRate;           /**<MPEG bit Rate*//**<CNcomment:MPEG */
+    HI_BOOL                        bIsFieldRepeated;         /**<FieldRepeater flag*//**<CNcomment:FieldRepeater */
+}HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S;
+
+/**HDMI Vendor Specific InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI VSIF  , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_VENDORSPEC_INFOFRAME_S
+{
+    HI_U32                         u32RegistrationId;       /**<Registration Id*//**<CNcomment:ID */
+}HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S;
+
+/**HDMI InfoFrame unit struct*/
+/**CNcomment: HDMI  */
+typedef union hiUNF_HDMI_INFOFRAME_UNIT_U
+{
+    HI_UNF_HDMI_AVI_INFOFRAME_VER2_S   stAVIInfoFrame;      /**<AVI FrameInfo*//**<CNcomment:AVI */
+    HI_UNF_HDMI_AUD_INFOFRAME_VER1_S   stAUDInfoFrame;      /**<Audio FrameInfo*//**<CNcomment:AUD */
+    HI_UNF_HDMI_SPD_INFOFRAME_S        stSPDInfoFrame;      /**<SPD FrameInfo*//**<CNcomment:SPD */
+    HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S stMPEGSourceInfoFrame;/**<MPEGSource FrameInfo*//**<CNcomment:MPEGSource */
+    HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S stVendorSpecInfoFrame;/**<VS FrameInfo*//**<CNcomment:VS */
+}HI_UNF_HMDI_INFORFRAME_UNIT_U;
+
+/**HDMI InfoFrame struct */
+/**CNcomment: HDMI  */
+typedef struct hiUNF_HDMI_INFOFRAME_S
+{
+    HI_UNF_HDMI_INFOFRAME_TYPE_E    enInfoFrameType;  /**<InfoFrame type*//**CNcomment:<InfoFrame */
+    HI_UNF_HMDI_INFORFRAME_UNIT_U   unInforUnit;      /**<InfoFrame unit data*//**CNcomment:<InfoFrame */
+}HI_UNF_HDMI_INFOFRAME_S;
+
+
+/* CEC */
+/** CEC interrelated Opcode:Please refer to CEC 15 Message Descriptions */
+/** CNcomment: CEC  */
+
+/* General Protocol messages */
+
+/**"Feature Abort" Used as a response to indicate that the device does not support the requested message type, or that it cannot execute it at the present time. */
+/**CNcomment:"Feature Abort"*/
+#define CEC_OPCODE_FEATURE_ABORT                  0X00
+/**"Abort" Message This message is reserved for testing purposes.*/
+/**CNcomment:"Abort"*/
+#define CEC_OPCODE_ABORT_MESSAGE                  0XFF
+
+/* One Touch Play Feature*/
+
+/**"Active Source" Used by a new source to indicate that it has started to transmit a stream OR used in response to a "Request Active Source"*/
+/**CNcomment:"Active Source""Request Active Source"*/
+#define CEC_OPCODE_ACTIVE_SOURCE                  0X82
+/**"Image View On" Sent by a source device to the TV whenever it enters the active state (alternatively it may send "Text View On").*/
+/**CNcomment:TV"Image View On"*/
+#define CEC_OPCODE_IMAGE_VIEW_ON                  0X04
+/**"Text View On" As "Image View On", but should also remove any text, menus and PIP windows from the TV's display.*/
+/**CNcomment:"Text View On" "Image View On"TV*/
+#define CEC_OPCODE_TEXT_VIEW_ON                   0X0D
+
+/* Routing Control Feature*/
+
+/**"Inactive Source" Used by the currently active source to inform the TV that it has no video to be presented to the user, or is going into standby as the result of a local user command on the device. */
+/**CNcomment: "Inactive Source"*/
+#define CEC_OPCODE_INACTIVE_SOURCE                0X9D
+/**"Request Active Source" Used by a new device to discover the status of the system.*/
+/**CNcomment: "Request Active Source"*/
+#define CEC_OPCODE_REQUEST_ACTIVE_SOURCE          0X85
+/**"Routing Change" Sent by a CEC Switch when it is manually switched to inform all other devices on the network that the active route below the switch has changed. */
+/**CNcomment: CEC "Routing Change"*/
+#define CEC_OPCODE_ROUTING_CHANGE                 0X80
+/**"Routing Information" Sent by a CEC Switch to indicate the active route below the switch.*/
+/**CNcomment: CEC"Routing Information"*/
+#define CEC_OPCODE_ROUTING_INFORMATION            0X81
+/**"Set Stream Path" Used by the TV to request a streaming path from the specified physical address.*/
+/**CNcomment: TV */
+#define CEC_OPCODE_SET_STREAM_PATH                0X86
+
+/* Standby Feature*/
+
+/**"Standby" Switches one or all devices into standby mode. Can be used as a broadcast message or be addressed to a specific device.See section CEC 13.3 for important notes on the use of this message */
+/**CNcomment: "Standby"*/
+#define CEC_OPCODE_STANDBY                        0X36
+
+/* One Touch Record Feature*/
+
+/**"Record Off" Requests a device to stop a recording. */
+/**CNcomment: "Record Off"*/
+#define CEC_OPCODE_RECORD_OFF                     0X0B
+/**"Record On" Attempt to record the specified source. */
+/**CNcomment: "Record On"*/
+#define CEC_OPCODE_RECORD_ON                      0X09
+/**"Record Status" Used by a Recording Device to inform the initiator of the message "Record On" about its status. */
+/**CNcomment: "Record Status""Record On"*/
+#define CEC_OPCODE_RECORD_STATUS                  0X0A
+/**"Record TV Screen" Request by the Recording Device to record the presently displayed source. */
+/**CNcomment: "Record TV Screen"*/
+#define CEC_OPCODE_RECORD_TV_SCREEN               0X0F
+
+/* Timer Programming Feature*/
+
+/**"Clear Analogue Timer" Used to clear an Analogue timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_ANALOGUE_TIMER           0X33
+/**"Clear Digital Timer" Used to clear a Digital timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_DIGITAL_TIMER            0X99
+/**"Clear External Timer" Used to clear an External timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_EXTERNAL_TIMER           0XA1
+/**"Set Analogue Timer" Used to set a single timer block on an Analogue Recording Device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_ANALOGUE_TIMER             0X34
+/**"Set Digital Timer" Used to set a single timer block on a Digital Recording Device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_DIGITAL_TIMER              0X97
+/**"Set External Timer" Used to set a single timer block to record from an external device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_EXTERNAL_TIMER             0XA2
+/**"Set Timer Program Title" Used to set the name of a program associated with a timer block. Sent directly after sending a "Set Analogue Timer" or "Set Digital Timer" message. The name is then associated with that timer block. */
+/**CNcomment: "Set Analogue Timer" "Set Digital Timer" */
+#define CEC_OPCODE_SET_TIMER_PROGRAM_TITLE        0X67
+/**"Timer Cleared Status" Used to give the status of a "Clear Analogue Timer", "Clear Digital Timer" or "Clear External Timer" message. */
+/**CNcomment: "Timer Cleared Status""Clear Analogue Timer""Clear Digital Timer""Clear External Timer"*/
+#define CEC_OPCODE_TIMER_CLEARED_STATUS           0X43
+/**"Timer Status" Used to send timer status to the initiator of a "Set Timer" message. */
+/**CNcomment: "Timer Status"Set Timer"*/
+#define CEC_OPCODE_TIMER_STATUS                   0X35
+
+/* System Information Feature*/
+
+/**"CEC Version" Used to indicate the supported CEC version, in response to a "Get CEC Version" */
+/**CNcomment: "CEC Version"CEC"Get CEC Version"*/
+#define CEC_OPCODE_CEC_VERSION                    0X9E
+/**"Get CEC Version" Used by a device to enquire which version of CEC the target supports */
+/**CNcomment: "Get CEC Version"CEC*/
+#define CEC_OPCODE_GET_CEC_VERSION                0X9F
+/**"Give Physical Address" A request to a device to return its physical address. */
+/**CNcomment: */
+#define CEC_OPCODE_GIVE_PHYSICAL_ADDRESS          0X83
+/**"Report Physical Address" Used to inform all other devices of the mapping between physical and logical address of the initiator.*/
+/**CNcomment: */
+#define CEC_OPCODE_REPORT_PHYSICAL_ADDRESS        0X84
+/**"Get Menu Language" Sent by a device capable of character generation (for OSD and Menus) to a TV in order to discover the currently selected Menu language.Also used by a TV during installation to discover the currently set menu language of other devices.*/
+/**CNcomment: "Get Menu Language"TvTV*/
+#define CEC_OPCODE_GET_MENU_LANGUAGE              0X91
+/**"Set Menu Language" Used by a TV or another device to indicate the menu language. */
+/**CNcomment: "Set Menu Language"Tv*/
+#define CEC_OPCODE_SET_MENU_LANGUAGE              0X32
+
+/*  Deck Control Feature*/
+
+/**"Deck Control" Used to control a device's media functions. */
+/**CNcomment: "Deck control"*/
+#define CEC_OPCODE_DECK_CONTROL                   0X42
+/**"Deck Status" Used to provide a deck's status to the initiator of the "Give Deck Status" message. */
+/**CNcomment: "Deck Status ""Give Deck Status"Deck*/
+#define CEC_OPCODE_DECK_STATUS                    0X1B
+/**"Give Deck Status" Used to request the status of a device, regardless of whether or not it is the current active source. */
+/**CNcomment: "Give Deck Status"*/
+#define CEC_OPCODE_GIVE_DECK_STATUS               0X1A
+/**"Play" Used to control the playback behaviour of a source device. */
+/**CNcomment: "Play"*/
+#define CEC_OPCODE_PLAY                           0X41
+
+/* Tuner Control Feature*/
+
+/**"Give Tuner Device Status" Used to request the status of a tuner device. */
+/**CNcomment: "Give Tuner Device Status"*/
+#define CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS       0X08
+/**"Select Analogue Service" Directly selects an Analogue TV service */
+/**CNcomment: "Select Analogue Service"*/
+#define CEC_OPCODE_SELECT_ANALOGUE_SERVICE        0X92
+/**"Select Digital Service" Directly selects a Digital TV, Radio or Data Broadcast Service */
+/**CNcomment: "Select Digital Service"*/
+#define CEC_OPCODE_SELECT_DIGITAL_SERVICE         0X93
+/**"Tuner Device Status" Use by a tuner device to provide its status to the initiator of the "Give Tuner Device Status" message. */
+/**CNcomment: "Tuner Device Status"" Give Tuner Device Status"*/
+#define CEC_OPCODE_TUNER_DEVICE_STATUS            0X07
+/**"Tuner Step Decrement" Used to tune to next lowest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"*/
+#define CEC_OPCODE_TUNER_STEP_DECREMENT           0X06
+/**"Tuner Step Increment" Used to tune to next highest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"*/
+#define CEC_OPCODE_TUNER_STEP_INCREMENT           0X05
+
+/* Vendor Specific Command*/
+
+/**"Device Vendor ID" Reports the vendor ID of this device. */
+/**CNcomment: "Device Vendor ID"ID*/
+#define CEC_OPCODE_DEVICE_VENDOR_ID               0X87
+/**"Give Device Vendor ID" Requests the Vendor ID from a device. */
+/**CNcomment: "Give Device Vendor ID"ID*/
+#define CEC_OPCODE_GIVE_DEVICE_VENDOR_ID          0X8C
+/**"Vendor Command" Allows vendor specific commands to be sent between two devices. */
+/**CNcomment: "Vendor Command"*/
+#define CEC_OPCODE_VENDOR_COMMAND                 0X89
+/**"Vendor Command With ID" Allows vendor specific commands to be sent between two devices or broadcast. */
+/**CNcomment: "Vendor Command With ID"*/
+#define CEC_OPCODE_VENDOR_COMMAND_WITH_ID         0XA0
+/**"Vendor Remote Button Down" Indicates that a remote control button has been depressed. */
+/**CNcomment: "Vendor Remote Button Down"*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN      0X8A
+/**"Vendor Remote Button Up" Indicates that a remote control button (the last button pressed indicated by the Vendor Remote Button Down message) has been released. */
+/**CNcomment: "Vendor Remote Button Up" "Vendor Remote Button Down"*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP        0X8B
+
+/* OSD Display Feature*/
+
+/**"Set OSD String" Used to send a text message to output on a TV. */
+/**CNcomment: "Set OSD String"*/
+#define CEC_OPCODE_SET_OSD_STRING                 0X64
+/**"Give OSD Name" Used to request the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment: */
+#define CEC_OPCODE_GIVE_OSD_NAME                  0X46
+/**"Set OSD Name" Used to set the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_OSD_NAME                   0X47
+
+/* Device Menu Control Feature*/
+
+/**"Menu Request" A request from the TV for a device to show/remove a menu or to query if a device is currently showing a menu. */
+/**CNcomment: "Menu Request"/*/
+#define CEC_OPCODE_MENU_REQUEST                   0X8D
+/**"Menu Status" Used to indicate to the TV that the device is showing/has removed a menu and requests the remote control keys to be passed though. */
+/**CNcomment: "Menu Status"/*/
+#define CEC_OPCODE_MENU_STATUS                    0X8E
+/**"User Control Pressed" Used to indicate that the user pressed a remote control button or switched from one remote control button to another. */
+/**CNcomment: "User Control Pressed".*/
+#define CEC_OPCODE_USER_CONTROL_PRESSED           0X44
+/**"User Control Released" Indicates that user released a remote control button (the last one indicated by the "User Control Pressed" message) */
+/**CNcomment: "User Control Released""User Control Released".*/
+#define CEC_OPCODE_USER_CONTROL_RELEASED          0X45
+
+/* Power Status Feature*/
+
+/**"Give Device Power Status" Used to determine the current power status of a target device */
+/**CNcomment: "Give Device Power Status"*/
+#define CEC_OPCODE_GIVE_DEVICE_POWER_STATUS       0X8F
+/**"Report Power Status" Used to inform a requesting device of the current power status */
+/**CNcomment: "Report Power Status"*/
+#define CEC_OPCODE_REPORT_POWER_STATUS            0X90
+
+/* System Audio Control Feature*/
+
+/**"Give Audio Status" Requests an amplifier to send its volume and mute status */
+/**CNcomment: "Give Audio Status"*/
+#define CEC_OPCODE_GIVE_AUDIO_STATUS              0X71
+/**"Give System Audio Mode Status" Requests the status of the System Audio Mode */
+/**CNcomment: "Give System Audio Mode Status"*/
+#define CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS  0x7D
+/**"Report Audio Status" Reports an amplifier's volume and mute status */
+/**CNcomment: "Report Audio Status"*/
+#define CEC_OPCODE_REPORT_AUDIO_STATUS            0X7A
+/**"Set System Audio Mode" Turns the System Audio Mode On or Off. */
+/**CNcomment: "Set System Audio Mode"/*/
+#define CEC_OPCODE_SET_SYSTEM_AUDIO_MODE          0X72
+/**"System Audio Mode Request" A device implementing System Audio Control and which has volume control RC buttons (eg TV or STB) requests to use System Audio Mode to the amplifier */
+/**CNcomment: (stbtv) System Audio Mode*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST      0X70
+/**"System Audio Mode Status" Reports the current status of the System Audio Mode */
+/**CNcomment: "System Audio Mode Status"*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS       0X7E
+
+/* Audio Rate Control Feature*/
+
+/**"Set Audio Rate" Used to control audio rate from Source Device. */
+/**CNcomment: "Set Audio Rate"*/
+#define CEC_OPCODE_SET_AUDIO_RATE                 0X9A
+
+/**POLL message have no opcode, So, we just use this value */
+/**CNcomment: "POLL"*/
+#define CEC_OPCODE_POLLING_MESSAGE                0XFE
+
+/**HDMI CEC logical address,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef enum hiUNF_CEC_LOGICALADD_S
+{
+    HI_UNF_CEC_LOGICALADD_TV               = 0X00, /**<TV*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_1      = 0X01, /**<Record device 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_2      = 0X02, /**<Record device 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_1          = 0X03, /**<Tuner 1*//**CNcomment:< 1*/
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_1        = 0X04, /**<play device 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_AUDIOSYSTEM      = 0X05, /**<audio system*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_TUNER_2          = 0X06, /**<tuner 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_3          = 0X07, /**<tuner 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_2        = 0X08, /**<play device 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_3      = 0X09, /**<Record device 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_TUNER_4          = 0X0A, /**<tuner 4*//**CNcomment:< 4 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_3        = 0X0B, /**<play device 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_1       = 0X0C, /**<reserved 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_2       = 0X0D, /**<reserved 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_SPECIALUSE       = 0X0E, /**<special use*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_BROADCAST        = 0X0F, /**<broadcast*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_BUTT
+}HI_UNF_CEC_LOGICALADD_S;
+
+/**HDMI CEC command type,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef enum hiUNF_CEC_CMDTYPE_E
+{
+    HI_UNF_CEC_STRUCTCOMMAND,                    /**<CEC struct command*//**<CNcomment:CEC  */
+    HI_UNF_CEC_RAWCOMMAND,                       /**<CEC raw command*//**<CNcomment:CEC  */
+    HI_UNF_CEC_BUTT
+}HI_UNF_CEC_CMDTYPE_E;
+
+/**HDMI CEC Raw Data struct,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef struct hiUNF_CEC_RAWDATA_S
+{
+    HI_U8                              u8Length;  /**<CEC raw data lengh*//**<CNcomment:cec  */
+    HI_U8                              u8Data[15];     /**<CEC raw data*//**<CNcomment:CEC  */
+}HI_UNF_CEC_RAWDATA_S;
+
+/**HDMI CEC user Interface Command Opcode,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC HDMI 1.4a */
+typedef enum hiUNF_CEC_UICMD_E
+{
+    HI_UNF_CEC_UICMD_SELECT                      = 0x00,
+    HI_UNF_CEC_UICMD_UP                          = 0x01,
+    HI_UNF_CEC_UICMD_DOWN                        = 0x02,
+    HI_UNF_CEC_UICMD_LEFT                        = 0x03,
+    HI_UNF_CEC_UICMD_RIGHT                       = 0x04,
+    HI_UNF_CEC_UICMD_RIGHT_UP                    = 0x05,
+    HI_UNF_CEC_UICMD_RIGHT_DOWN                  = 0x06,
+    HI_UNF_CEC_UICMD_LEFT_UP                     = 0x07,
+    HI_UNF_CEC_UICMD_LEFT_DOWN                   = 0x08,
+    HI_UNF_CEC_UICMD_ROOT_MENU                   = 0x09,
+    HI_UNF_CEC_UICMD_SETUP_MENU                  = 0x0A,
+    HI_UNF_CEC_UICMD_CONTENTS_MENU               = 0x0B,
+    HI_UNF_CEC_UICMD_FAVORITE_MENU               = 0x0C,
+    HI_UNF_CEC_UICMD_EXIT                        = 0x0D,
+    HI_UNF_CEC_UICMD_NUM_0                       = 0x20,
+    HI_UNF_CEC_UICMD_NUM_1                       = 0x21,
+    HI_UNF_CEC_UICMD_NUM_2                       = 0x22,
+    HI_UNF_CEC_UICMD_NUM_3                       = 0x23,
+    HI_UNF_CEC_UICMD_NUM_4                       = 0x24,
+    HI_UNF_CEC_UICMD_NUM_5                       = 0x25,
+    HI_UNF_CEC_UICMD_NUM_6                       = 0x26,
+    HI_UNF_CEC_UICMD_NUM_7                       = 0x27,
+    HI_UNF_CEC_UICMD_NUM_8                       = 0x28,
+    HI_UNF_CEC_UICMD_NUM_9                       = 0x29,
+    HI_UNF_CEC_UICMD_DOT                         = 0x2A,
+    HI_UNF_CEC_UICMD_ENTER                       = 0x2B,
+    HI_UNF_CEC_UICMD_CLEAR                       = 0x2C,
+    HI_UNF_CEC_UICMD_NEXT_FAVORITE               = 0x2F,
+    HI_UNF_CEC_UICMD_CHANNEL_UP                  = 0x30,
+    HI_UNF_CEC_UICMD_CHANNEL_DOWN                = 0x31,
+    HI_UNF_CEC_UICMD_PREVIOUS_CHANNEL            = 0x32,
+    HI_UNF_CEC_UICMD_SOUND_SELECT                = 0x33,
+    HI_UNF_CEC_UICMD_INPUT_SELECT                = 0x34,
+    HI_UNF_CEC_UICMD_DISPLAY_INFORMATION         = 0x35,
+    HI_UNF_CEC_UICMD_HELP                        = 0x36,
+    HI_UNF_CEC_UICMD_PAGE_UP                     = 0x37,
+    HI_UNF_CEC_UICMD_PAGE_DOWN                   = 0x38,
+    HI_UNF_CEC_UICMD_POWER                       = 0x40,
+    HI_UNF_CEC_UICMD_VOLUME_UP                   = 0x41,
+    HI_UNF_CEC_UICMD_VOLUME_DOWN                 = 0x42,
+    HI_UNF_CEC_UICMD_MUTE                        = 0x43,
+    HI_UNF_CEC_UICMD_PLAY                        = 0x44,
+    HI_UNF_CEC_UICMD_STOP                        = 0x45,
+    HI_UNF_CEC_UICMD_PAUSE                       = 0x46,
+    HI_UNF_CEC_UICMD_RECORD                      = 0x47,
+    HI_UNF_CEC_UICMD_REWIND                      = 0x48,
+    HI_UNF_CEC_UICMD_FAST_FORWARD                = 0x49,
+    HI_UNF_CEC_UICMD_EJECT                       = 0x4A,
+    HI_UNF_CEC_UICMD_FORWARD                     = 0x4B,
+    HI_UNF_CEC_UICMD_BACKWARD                    = 0x4C,
+    HI_UNF_CEC_UICMD_STOP_RECORD                 = 0x4D,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD                = 0x4E,
+    HI_UNF_CEC_UICMD_ANGLE                       = 0x50,
+    HI_UNF_CEC_UICMD_SUBPICTURE                  = 0x51,
+    HI_UNF_CEC_UICMD_VIDEO_ON_DEMAND             = 0x52,
+    HI_UNF_CEC_UICMD_ELECTRONIC_PROGRAM_GUIDE    = 0x53,
+    HI_UNF_CEC_UICMD_TIMER_PROGRAMMING           = 0x54,
+    HI_UNF_CEC_UICMD_INITIAL_CONFIGURATION       = 0x55,
+    HI_UNF_CEC_UICMD_PLAY_FUNCTION               = 0x60,
+    HI_UNF_CEC_UICMD_PAUSE_PLAY_FUNCTION         = 0x61,
+    HI_UNF_CEC_UICMD_RECORD_FUNCTION             = 0x62,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD_FUNCTION       = 0x63,
+    HI_UNF_CEC_UICMD_STOP_FUNCTION               = 0x64,
+    HI_UNF_CEC_UICMD_MUTE_FUNCTION               = 0x65,
+    HI_UNF_CEC_UICMD_RESTORE_VOLUME_FUNCTION     = 0x66,
+    HI_UNF_CEC_UICMD_TUNE_FUNCTION               = 0x67,
+    HI_UNF_CEC_UICMD_SELECT_MEDIA_FUNCTION       = 0x68,
+    HI_UNF_CEC_UICMD_SELECT_AV_INPUT_FUNCTION    = 0x69,
+    HI_UNF_CEC_UICMD_SELECT_AUDIO_INPUT_FUNCTION = 0x6A,
+    HI_UNF_CEC_UICMD_POWER_TOGGLE_FUNCTION       = 0x6B,
+    HI_UNF_CEC_UICMD_POWER_OFF_FUNCTION          = 0x6C,
+    HI_UNF_CEC_UICMD_POWER_ON_FUNCTION           = 0x6D,
+    HI_UNF_CEC_UICMD_F1_BLUE                     = 0x71,
+    HI_UNF_CEC_UICMD_F2_RED                      = 0x72,
+    HI_UNF_CEC_UICMD_F3_GREEN                    = 0x73,
+    HI_UNF_CEC_UICMD_F4_YELLOW                   = 0x74,
+    HI_UNF_CEC_UICMD_F5                          = 0x75,
+    HI_UNF_CEC_UICMD_DATA                        = 0x76
+}HI_UNF_CEC_UICMD_E;
+
+/**HDMI CEC operand command,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC HDMI 1.4a */
+typedef union hiUNF_CEC_Operand_t
+{
+    HI_UNF_CEC_RAWDATA_S               stRawData;   /**<CEC raw date*//**<CNcomment:CEC  */
+    HI_UNF_CEC_UICMD_E                 stUIOpcode;  /**<CEC user interface command*//**<CNcomment:CEC */
+}HI_UNF_CEC_Operand_t;
+
+/**HDMI CEC struct command*/
+/**CNcomment: HDMI CEC  */
+typedef struct hiUNF_HDMI_CEC_CMD_S
+{
+    HI_UNF_CEC_LOGICALADD_S  enSrcAdd;     /**<logical address of source *//**<CNcomment: */
+    HI_UNF_CEC_LOGICALADD_S  enDstAdd;     /**<logical address of destination*//**<CNcomment: */
+    HI_U8                    u8Opcode;     /**<opration code*//**<CNcomment:*/
+    HI_UNF_CEC_Operand_t     unOperand;    /**<operand*//**<CNcomment:*/
+}HI_UNF_HDMI_CEC_CMD_S;
+
+/**HDMI CEC status struct*/
+/**CNcomment: HDMI CEC  */
+typedef struct hiUNF_HDMI_CEC_STATUS_S
+{
+    HI_BOOL bEnable;                                 /**<the flag of CEC work,HI_TRUE:CEC work enable,HI_FALSE:CEC no work ,other parameter no effect*/ /**<CNcomment:CEC HI_TRUE,CECHI_FASLE,CEC */
+    HI_U8   u8PhysicalAddr[4];                       /**<CEC physics address*/ /**<CNcomment:CEC  */
+    HI_U8   u8LogicalAddr;                           /**<CEC logic address,defualt 0x03*//**<CNcomment:CEC 0x03. */
+    HI_U8   u8Network[HI_UNF_CEC_LOGICALADD_BUTT];   /**<CEC network struct ,1:the device can response CEC command*/ /**<CNcomment:CEC 1CEC */
+}HI_UNF_HDMI_CEC_STATUS_S;
+
+/**HDMI CEC Regcallback param struct */
+/**CNcomment: HDMI CEC  */
+typedef HI_VOID (*HI_UNF_HDMI_CECCALLBACK)(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S *pstCECCmd, HI_VOID *pData);
+
+
+/**HDMI HDCP key struct*/
+/**CNcomment: HDMI HDCP  */
+typedef struct hiUNF_HDMI_LOAD_KEY_S
+{
+    HI_U8 *pu8InputEncryptedKey;            /**<Encrypted key pointer *//**<CNcomment: */
+    HI_U32 u32KeyLength;                    /**<Encrypted key length*//**<CNcomment: */
+}HI_UNF_HDMI_LOAD_KEY_S;
+
+/**HDMI HDCP SRM(system renewability messages) struct*/
+/**CNcomment: HDMI HDCP SRM() */
+typedef struct hiUNF_HDMI_SRM_S
+{
+    HI_U8 *pu8SrmData;              /**<SRM raw data *//**<CNcomment:SRM  */
+    HI_U32 u32SrmLen;               /**<Length of SRM *//**<CNcomment: */
+} HI_UNF_HDMI_SRM_S;
+
+
+/**< HDCP-capability struct *//**<CNcomment:HDCP  */
+typedef struct{
+    HI_BOOL        bHdcp14Support;  /**<sink support HDCP1.4 *//**<CNcomment:sinkHDCP1.4 */
+    HI_BOOL        bHdcp22Support;  /**<sink support HDCP2.2 *//**<CNcomment:sinkHDCP2.2 */
+}HI_UNF_HDMI_HDCP_CAP_S;
+
+/**HDMI HDCP eanble parameter*/
+/**CNcomment: HDMI HDCP  */
+typedef struct hiUNF_HDMI_HDCP_PARAM_S{
+    HI_BOOL                 bHdcpEnable;    /**<set HI_TRUE to enable HDCP,set HI_FALSE to disable HDCP. *//**<CNcomment:HI_TRUEHDCP;HI_FALSEHDCP*/
+    HI_UNF_HDMI_HDCP_MODE_E enHdcpMode;     /**<HDCP mode of authentication,suggest that according to HDCP-capability. *//**<CNcomment:HDCPsink*/
+
+}HI_UNF_HDMI_HDCP_PARAM_S;
+
+/**HDMI HDCP error code*/
+/**CNcomment: HDMI HDCP*/
+typedef enum hiUNF_HDMI_HDCP_ERR_E
+{
+    HI_UNF_HDMI_HDCP_ERR_UNDO = 0x00,           /**< undo hdcp. *//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_NONE,                  /**< no error. *//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_UNHPD,                 /**< eanble HDCP when HPD is low. *//**<CNcomment:HPD*/
+    HI_UNF_HDMI_HDCP_ERR_NO_TIMMING,            /**< no timming.Enable HDCP before HDMI start. *//**<CNcomment:HDMIHDCP(HDMI )*/
+    HI_UNF_HDMI_HDCP_ERR_LOADKEY_FAIL,          /**< no loadkey.Only for HDCP1.4 *//**<CNcomment:HDCP1.4 key*/
+    HI_UNF_HDMI_HDCP_ERR_ON_REVOCATION_LIST,    /**< recieve ID/BKSV list on revocation list.*//**<CNcomment:()DCP*/
+    HI_UNF_HDMI_HDCP_ERR_RECEIVER_FAIL,         /**< receiver respond error.*//**<CNcomment:*/
+    HI_UNF_HDMI_HDCP_ERR_MAXDEV_EXCEEDED,       /**< more than 127 downstream devices,  or the capacity of the KSV Fifo, are attached.*//**<CNcomment:127KSV Fifo*/
+    HI_UNF_HDMI_HDCP_ERR_MAXCASCADE_EXCEEDED,   /**< more than seven levels of video repeater have been cascaded together*//**<CNcomment:7*/
+    HI_UNF_HDMI_HDCP_ERR_REPEATER_FAIL,         /**< repeater respond error.*//**<CNcomment:repeater*/
+
+}HI_UNF_HDMI_HDCP_ERR_E;
+
+/**HDMI HDCP status */
+/**CNcomment: HDMI HDCP*/
+typedef struct hiUNF_HDCP_STATUS_S{
+    HI_UNF_HDMI_HDCP_VERSION_E      enHdcpVersion;  /**< HDCP current version.*//**<CNcomment:HDCP*/
+    HI_BOOL                         bHdcpEnable;    /**< HDCP enable status.*//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_E          enHdcpErrCode;  /**< HDCP error code.*//**<CNcomment:HDCP */
+}HI_UNF_HDCP_STATUS_S;
+
+
+/**HDMI Delay struct*/
+/**CNcomment: HDMI  */
+typedef struct hiUNF_HDMI_DELAY_S
+{
+    HI_U32  u32MuteDelay;           /**<delay for avmute *//**<CNcomment:avmute */
+    HI_U32  u32FmtDelay;            /**<delay for setformat *//**<CNcomment: */
+    HI_BOOL bForceFmtDelay;         /**<force setformat delay mode *//**<CNcomment: */
+    HI_BOOL bForceMuteDelay;        /**<force avmute delay mode *//**<CNcomment:mute */
+}HI_UNF_HDMI_DELAY_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**
+\brief the whole initialization of the hdmi. CNcomment:HDMI CNend
+\attention  this func should be called before vo_init and after disp_init. CNcomment:DISPSetupVOSetup CNend
+\param CNcomment: CNend
+\retval HI_SUCCESS  success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Init(HI_VOID);
+
+
+/**
+\brief deinit the hdmi. CNcomment:HDMI CNend
+\attention  this must be called after vo exited and before disp  exited . CNcomment:VOExitDISPExit CNend
+\param CNcomment: CNend
+\retval HI_SUCCESS      success.CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_DeInit(HI_VOID);
+
+
+/**
+\brief create hdmi device. CNcomment:HDMI CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMI CNend
+\param[in] pstOpenPara  When get GetSinkCapability failed,defalut set sink device to DVI/HDMI mode.CNcomment:(DVI/HDMI) CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Open(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_OPEN_PARA_S *pstOpenPara);
+
+/**
+\brief close the handler created by  HI_UNF_HDMI_Open. CNcomment:HI_UNF_HDMI_Open CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Close(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief get current hdmi status. CNcomment:hdmi CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\param[out] pHdmiStatus hdmi cuttent status. CNcomment:HDMI CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_STATUS_S *pHdmiStatus);
+
+/**
+\brief to get the capability of sink connect to stbbox. CNcomment:HDMI Sink CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[out] pCapability  the capability of the sink .CNcomment:SINK CNend
+\retval HI_SUCCESS       success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi. CNcomment:MPI CNend
+\see ::HI_UNF_EDID_BASE_INFO_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetSinkCapability(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_EDID_BASE_INFO_S *pCapability);
+
+/**
+\brief set the attr of given hdmi interface. CNcomment:HDMI CNend
+\attention the setting will take effect after HI_UNF_HDMI_Start is called.Suggest that HI_UNF_HDMI_Stop before change enDeepColorMode to reduce noisy.
+\param[in] enHdmi      hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstAttr     the attr of given hdmi interface.CNcomment:HDMI CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the current attr of the give hdmi interface. CNcomment:HDMI CNend
+\attention \n
+\param[in] enHdmi hdmi device id.CNcomment: HDMIID CNend
+\param[out] pstAttr     the attr of given hdmi interface. CNcomment:HDMI CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see HI_UNF_HDMI_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the cec working status. CNcomment:CEC CNend
+\attention  user can get the cec working status through this func. CNcomment:CEC\n CNend
+\param[in] enHdmi       hdmi device id.CNcomment:HDMIID CNend
+\param[in] pStatus     get cec working status. CNcomment:CEC  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CECStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_STATUS_S  *pStatus);
+
+
+/**
+\brief send the cec data. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCmd      the cec cmd data.CNcomment:Cec Command  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd);
+
+
+/**
+\brief get the cec data received. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCmd    the cec cmd data. CNcomment:Cec Command  CNend
+\param[in] timeout    timeout for getting cec cmd, unit: 10ms;
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd, HI_U32 timeout);
+
+/**
+\brief register CEC callback function. CNcomment:CEC CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCallback    the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+/**
+\brief unregister CEC callback function. CNcomment:CEC CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCallback  the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+/**
+\brief enable the cec func. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Enable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief disable the cec func. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Disable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief  set and send infoframe. CNcomment:InfoFrame CNend
+\attention \n
+\param[in] enHdmi       hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstInfoFrame the inforframe content.CNcomment:InfoFrame CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+/**
+\brief get the infoframe infor. CNcomment:InfoFrame CNend
+\attention \n
+\param[in] enHdmi       hdmi device id. CNcomment:HDMIID CNend
+\param[in] enInfoFrameType the info frame type such as avi or audio or gcp etc. CNcomment:InfoFrame CNend
+\param[out] pstInfoFrame   the inforframe content.CNcomment:InfoFrame CNend
+\retval HI_SUCCESS      success.CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_TYPE_E enInfoFrameType, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+
+
+/**
+\brief  start the hdmi works. CNcomment:HDMI CNend
+\attention \n
+this should be called after HI_UNF_HDMI_SetAttr.
+CNcomment:HDMIHI_UNF_HDMI_SetAttr CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Start(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief stop  the hdmi. CNcomment:hdmi CNend
+\attention \n
+this func should be called  when hdmi plug out.
+CNcomment:HDMIHDMI CNend
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Stop(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief set the deep color mode. CNcomment:HDMI DeepColor CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] enDeepColor deep color mode,please refer to the HI_UNF_HDMI_DEEP_COLOR_E definiton.CNcomment:DeepColor::HI_UNF_HDMI_DEEP_COLOR_E  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDeepColor(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DEEP_COLOR_E enDeepColor);
+
+/**
+\brief switch the xvycc on or off. CNcomment:HDMI xvYCC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] bEnalbe   whether to enable xvycc mode or not .CNcomment:xvYCC CNend
+\retval HI_SUCCESS    success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetxvYCCMode(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bEnalbe);
+
+/**
+\brief switch the mute of av  on or off. CNcomment:HDMI AV mute  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] bAvMute   whether to mute the av.CNcomment:mute AV CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAVMute(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bAvMute);
+
+/**
+\brief get the edid information forcelly. CNcomment:EDID,EDID CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *u8Edid  the buffer allocated externally, buffer size must be 512. CNcomment:EDIDbufferEDIDbuffer 512,; CNend
+\param[in] *u32EdidLength  the data lenth of  original edid. CNcomment:EDID CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Force_GetEDID(HI_UNF_HDMI_ID_E enHdmi, HI_U8 *u8Edid, HI_U32 *u32EdidLength);
+
+
+/**
+\brief register callback function. CNcomment: CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_Open and after HI_UNF_HDMI_Init
+because HI_UNF_HDMI_Open will trigger hotplug event.
+And this function can only register one function
+If call this func two times,then the 2nd callback function will cover 1st one.
+CNcomment:HI_UNF_HDMI_InitHI_UNF_HDMI_Open \n
+Openhotplug \n
+ CNend
+\param CNcomment: CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment: CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+
+/**
+\brief unregister CallbackFunc. CNcomment: CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_DeInit and after HI_UNF_HDMI_Close
+CNcomment:HI_UNF_HDMI_CloseHI_UNF_HDMI_DeInit CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment: CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+/**
+\brief Load HDCP key. CNcomment:hdcpkey CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *pstLoadKey  key struct length and point CNcomment:key   CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_LoadHDCPKey(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_LOAD_KEY_S *pstLoadKey);
+
+/**
+\brief Set SRM, it is called by user, it can be call more time,only remain the last one when set success.Ncomment:SRM CNend
+\param[in]  enHdmi  hdmi channel id. CNcomment:HDMIID CNend
+\param[in]  pstSrm SRM raw dataCNcomment:SRM  CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_SetSrm(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_SRM_S *pstSrm);
+
+/**
+\brief to get the HDCP-capability of sink connect to stbbox. CNcomment:HDMI SinkHDCP CNend
+\attention in HI_UNF_HDMI_GetSinkCapability,HI_UNF_EDID_BASE_INFO_S's stHDCPSupport is triggered by HotPlug,some Sink get HDCP-capability fail when HotPlug.Base on these,it is suggested that use HI_UNF_HDMI_GetHdcpCapability force to get HDCP-capability from sink.When retval is HI_FAILURE,it is suggested that use HI_UNF_HDMI_GetHdcpCapability to get more times until retval is HI_SUCCESS.
+\CNcomment:HI_UNF_EDID_BASE_INFO_SstHDCPSupportHotPlugsinkHI_UNF_HDMI_GetHdcpCapabilitysinkHDCPHI_FAILURE,HI_SUCCESS CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[out] pstHdcpCap  the HDCP capability of the sink .CNcomment:SINKHDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpCapability(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_CAP_S *pstHdcpCap);
+
+/**
+\brief to enable HDCP authentication dynamically after HI_UNF_HDMI_Start. CNcomment:HDCP CNend
+\attention the interface must call after HI_UNF_HDMI_Start.And ,it is suggested that select enHdcpMode according to sink's HDCP-capability.
+\CNcomment:HI_UNF_HDMI_StartsinkHDCP CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstParm  hdcp parameter when enable.CNcomment:HDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_PARAM_S *pstParm);
+
+/**
+\brief to get HDCP status. CNcomment:HDCP CNend
+\attention suggest the interface call after getting HDCP event.CNcomment:HDCP CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstStatus  hdcp status.CNcomment:HDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpStatus(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDCP_STATUS_S *pstStatus);
+
+
+/**
+\brief get the edid information forcelly. CNcomment:EEPROMEDID CNend
+\attention \n
+Difference with two interface for get EDID
+HI_UNF_HDMI_Force_GetEDID : Reread EDID from Sink,and write it to EEPROM
+HI_UNF_HDMI_ReadEDID : read edid from EEPROM,not Real-time read from Sink
+CNcomment:EDID
+HI_UNF_HDMI_Force_GetEDID EdidEEPROM
+HI_UNF_HDMI_ReadEDID EEPROMEdidEDID CNend
+\param[in] *pstLoadKey  key struct length and point CNcomment:key   CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_ReadEDID(HI_U8 *u8Edid, HI_U32 *u32EdidLength);
+
+/**
+\brief Get HDMI runtime delay. CNcomment:hdmi CNend
+\attention \n
+CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:  CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/**
+\brief Set HDMI runtime delay. CNcomment:hdmi CNend
+\attention \n
+if not use this interface, then use hdmi inner delay
+CNcomment:,delay CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:  CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __HI_UNF_HDMI_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_unf_i2c.h unlib/xbmc/linux/hisi/hi_unf_i2c.h
--- git/xbmc/linux/hisi/hi_unf_i2c.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_i2c.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,248 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_i2c.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_I2C_H__
+#define __HI_UNF_I2C_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      I2C */
+/** @{*/  /** <!-[I2C]*/
+
+#define HI_UNF_I2C_Open  HI_UNF_I2C_Init
+#define HI_UNF_I2C_Close HI_UNF_I2C_DeInit
+
+/**Maximum I2C channel ID*/ /**CNcomment:I2C*/
+#define HI_I2C_MAX_NUM_USER (15)
+
+/**Rate type of the I2C module*/
+/**CNcomment:I2C */
+typedef enum hiUNF_I2C_RATE_E
+{
+    HI_UNF_I2C_RATE_10K = 0, /**<Standard rate: 10 kbit/s*/         /**<CNcomment:10kbit/s*/
+    HI_UNF_I2C_RATE_50K, /**<Standard rate: 50 kbit/s*/   /**<CNcomment:50kbit/s*/
+    HI_UNF_I2C_RATE_100K, /**<Standard rate: 100 kbit/s*/  /**<CNcomment:100kbit/s*/
+    HI_UNF_I2C_RATE_200K, /**<Standard rate: 200 kbit/s*/  /**<CNcomment:200kbit/s*/
+    HI_UNF_I2C_RATE_300K, /**<Standard rate: 300 kbit/s*/  /**<CNcomment:300kbit/s*/
+    HI_UNF_I2C_RATE_400K, /**<Fast rate: 400 kbit/s*/      /**<CNcomment:400kbit/s*/
+
+    HI_UNF_I2C_RATE_BUTT
+} HI_UNF_I2C_RATE_E;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      I2C*/
+/** @{*/  /** <!-- -I2C=*/
+
+/**
+ \brief Init the I2C device.
+CNcomment:\brief I2Cthe Inter-Integrated CircuitCNend
+
+ \param N/A                                                               CNcomment:CNend
+ \retval 0 Success                                                        CNcomment:CNend
+ \retval ::HI_ERR_I2C_OPEN_ERR  Open I2c Error				  CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Init (HI_VOID);
+
+/**
+ \brief  DeInit the I2C device.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+This API is called after I2C operations are completed.\n
+CNcomment:I2C\n CNend
+
+ \param N/A                                                        CNcomment:CNend
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::HI_ERR_I2C_CLOSE_ERR  Close I2c Error.	 	   CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DeInit(HI_VOID);
+
+/**
+ \brief  Get the number of I2C module.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API to get the number of I2C module befor read/write data.\n
+CNcomment:I2CI2C\n CNend
+
+ \param N/A                                                        CNcomment:CNend
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_GetCapability(HI_U32 *pu32I2cNum);
+
+/**
+The I2C device is not initialized.
+CNcomment:\brief GpioI2cCNend
+
+ \attention \n
+If the specified GPIO pins are used, this API fails to be called.\n
+CNcomment:Gpio\n CNend
+
+ \param[out] u32I2cNum  ID of the obtained I2C bus                            CNcomment:I2CCNend
+ \param[in] u32SCLGpioNo  SCL Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] u32SDAGpioNo  SDA Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \retval 0 Success                                                           CNcomment:CNend
+ \retval ::HI_FAILURE	Create gpioi2c failed								CNcomment:CNend
+ \retval ::HI_ERR_I2C_NULL_PTR 		The pointer parameter is NULL			CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid.               CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_CreateGpioI2c(HI_U32 *pu32I2cNum, HI_U32 u32SCLGpioNo, HI_U32 u32SDAGpioNo);
+
+/**
+ \brief Destroys a inter-integrated circuit (I2C) channel that simulates the general-purpose input/output (GPIO) function.
+CNcomment:\brief GpioI2cCNend
+
+ \attention \n
+If the I2C channel is not used, a code indicating success is returned.\n
+CNcomment:GpioI2c\n CNend
+
+ \param[in] u32I2cNum ID of the I2C bus to be destroyed        CNcomment:I2CCNend
+ \retval 0  Success                                            CNcomment:CNend
+ \retval ::HI_FAILURE	Destroy gpioi2c failed				  CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid. CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DestroyGpioI2c(HI_U32 u32I2cNum);
+
+/**
+ \brief Reads data by using the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be read           CNcomment:I2CCNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus      CNcomment:I2CCNend
+ \param[in] u32RegAddr  On-chip offset address of a device        CNcomment:CNend
+ \param[in] u32RegAddrCount  Length of an on-chip offset address. CNcomment:CNend
+                      1: 8-bit sub address                       CNcomment:18bitCNend
+                      2: 16-bit sub address                      CNcomment:216bitCNend
+                      3: 24-bit sub address                      CNcomment:324bitCNend
+                      4: 32-bit sub address                      CNcomment:432bitCNend
+
+ \param[out] pu8Buf   Buffer for storing the data to be read                            CNcomment:BufferCNend
+ \param[in] u32Length  Length of the data to be read                                    CNcomment:CNend
+ \retval 0 Success                                                                      CNcomment:CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_FAILED_READ  Data fails to be read by using the I2C bus.          CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Read(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                       HI_U32 u32RegAddrCount, HI_U8 *pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Writes data by using the I2C bus. That is, you can call this API to write data to the device mounted on the I2C bus through the I2C channel.
+CNcomment:\brief I2CI2CI2CCNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be written         CNcomment:I2CCNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus       CNcomment:I2CCNend
+ \param[in] u32RegAddr  On-chip offset address of a device         CNcomment:CNend
+ \param[in] u32RegAddrCount Length of an on-chip offset address.   CNcomment:CNend
+                    1: 8-bit sub address                          CNcomment:18bitCNend
+                    2: 16-bit sub address                         CNcomment:216bitCNend
+                    3: 24-bit sub address                         CNcomment:324bitCNend
+                    4: 32-bit sub address                         CNcomment:432bitCNend
+
+ \param[in]  pu8Buf   Buffer for storing the data to be written                         CNcomment:BufferCNend
+ \param[in] u32Length  Length of the data to be written                                 CNcomment:CNend
+ \retval 0  Success                                                                     CNcomment:CNend
+ \retval ::HI_FAILURE	Write data failed					  	CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_FAILED_WRITE  Data fails to be written by using the I2C bus.      CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Write(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                        HI_U32 u32RegAddrCount, HI_U8 * pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:i2cgpio  i2c \nCNend
+CNcomment:400Kbit/s\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:I2CCNend
+ \param[in] enI2cRate  I2C clock rate. For details about the definition, see the description of ::HI_UNF_I2C_RATE_E. CNcomment:I2C::HI_UNF_I2C_RATE_ECNend
+ \retval 0  Success                                                                                                  CNcomment:CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRate(HI_U32 u32I2cNum, HI_UNF_I2C_RATE_E enI2cRate);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:i2cgpio  i2c \n
+400Kbit/s\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:I2CCNend
+ \param[in] u32I2cRate  I2C clock rate.  CNcomment:I2CCNend
+ \retval 0  Success                                                                                                  CNcomment:CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRateEx(HI_U32 u32I2cNum, HI_U32 u32I2cRate);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
diff -uNr git/xbmc/linux/hisi/hi_unf_otp.h unlib/xbmc/linux/hisi/hi_unf_otp.h
--- git/xbmc/linux/hisi/hi_unf_otp.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_otp.h	2018-04-08 17:22:52.675733600 +0800
@@ -0,0 +1,978 @@
+/******************************************************************************
+
+  Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2016/10/9
+  Description   :
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the otp module.
+          CNcomment: OTP  CNend
+ */
+#ifndef __HI_UNF_OTP_H__
+#define __HI_UNF_OTP_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+/** CA VendorID */
+typedef enum
+{
+    HI_UNF_OTP_VENDORID_COMMON     = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_OTP_VENDORID_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_OTP_VENDORID_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_OTP_VENDORID_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_OTP_VENDORID_NDS        = 0x04,        /**<NDS Chipset*/
+    HI_UNF_OTP_VENDORID_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_OTP_VENDORID_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_OTP_VENDORID_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_OTP_VENDORID_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_OTP_VENDORID_SAFEVIEW   = 0x09,        /**<SAFEVIEW CA Chipset*/
+    HI_UNF_OTP_VENDORID_LATENSE    = 0x0a,        /**<LATENSE CA Chipset*/
+    HI_UNF_OTP_VENDORID_SH_TELECOM = 0x0b,        /**<SH_TELECOM CA Chipset*/
+    HI_UNF_OTP_VENDORID_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_OTP_VENDORID_VIACCESS   = 0x0d,        /**<VIACCESS CA Chipset*/
+    HI_UNF_OTP_VENDORID_BUTT
+} HI_UNF_OTP_VENDORID_E;
+
+/** FLASH device types*/
+typedef enum
+{
+    HI_UNF_OTP_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_OTP_FLASH_TYPE_NAND,           /**<nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_NOR,            /**<nor flash*/
+    HI_UNF_OTP_FLASH_TYPE_EMMC,           /**<eMMC*/
+    HI_UNF_OTP_FLASH_TYPE_SPI_NAND,       /**<spi_nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_OTP_FLASH_TYPE_BUTT
+} HI_UNF_OTP_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum
+{
+    HI_UNF_OTP_JTAG_MODE_OPEN     = 0,
+    HI_UNF_OTP_JTAG_MODE_PROTECT,
+    HI_UNF_OTP_JTAG_MODE_CLOSED,
+    HI_UNF_OTP_JTAG_MODE_BUTT
+} HI_UNF_OTP_JTAG_MODE_E;
+
+/** Rootkey type*/
+typedef enum
+{
+    HI_UNF_OTP_OEM_ROOTKEY        = 0,
+    HI_UNF_OTP_HDCP_ROOTKEY,
+    HI_UNF_OTP_STB_ROOTKEY,
+    HI_UNF_OTP_SW_ROOTKEY,
+    HI_UNF_OTP_STBTA_ROOTKEY,
+
+} HI_UNF_OTP_ROOTKEY_E;
+
+#define OTP_FIELD_VALUE_MAX_LEN 1024
+#define OTP_FIELD_NAME_MAX_LEN 32
+typedef struct
+{
+    HI_BOOL bBurn;
+    HI_CHAR aszFieldName[OTP_FIELD_NAME_MAX_LEN]; //32
+    HI_U32 u32ValueLen;
+    HI_U8 au8Value[OTP_FIELD_VALUE_MAX_LEN]; //4
+    HI_BOOL bLock;
+}HI_UNF_OTP_BURN_PV_ITEM_S;
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+#define HI_UNF_OTP_Open(HI_VOID) HI_UNF_OTP_Init(HI_VOID)
+#define HI_UNF_OTP_Close(HI_VOID) HI_UNF_OTP_DeInit(HI_VOID)
+
+/**
+\brief Initializes the otp module. CNcomment:OTP CNend
+\attention \n
+Before calling other functions in this file, you must call this application programming interface (API).
+CNcomment OTP CNend
+\param N/A
+\retval ::HI_SUCCESS  Success.   CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_Init(HI_VOID);
+
+/**
+\brief Deinitializes the otp module. CNcomment:OTP CNend
+\attention \n
+N/A
+\param N/A                                        CNcomment: CNend
+\retval ::HI_SUCCESS  Success.   CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_DeInit(HI_VOID);
+
+
+/**
+\brief Set customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:customer keycustomer key CNend
+\attention \n
+N/A
+\param[in] pKey:  Customer key to be written to otp.                    CNcomment:Customer keyOTP CNend
+\param[in] u32KeyLen:  The length of customer key, must be 16bytes.     CNcomment:Customer key16           CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+/**
+\brief Get customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:customer key CNend
+\attention \n
+N/A
+\param[in] pKey:Buffer to store the customer key read from otp.     CNcomment:customer keybuffer CNend
+\param[in] u32KeyLen:The length of buffer, must be 16bytes.             CNcomment:customer key 16 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+
+/**
+\brief Set stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to set the private data, should be between 0 and 15.  CNcomment:stbprivData0~15 CNend
+\param[in] u8Data:  The private data to be set.                         CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetStbPrivData(HI_U32 u32Offset, HI_U8 u8Data);
+
+/**
+\brief Get stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to get the private data, should be between 0 and 15.  CNcomment:stbprivData0~15 CNend
+\param[out] pu8Data:  The data read from otp.                           CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbPrivData(HI_U32 u32Offset, HI_U8 *pu8Data);
+
+/**
+\brief burn chipset to normal chipset CNcomment: CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToNormalChipset(HI_VOID);
+
+/**
+\brief Burn nomal chipset to secure chipset
+\brief CNcomment: CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToSecureChipset(HI_VOID);
+
+/**
+\brief Get idword lock status CNcomment:IDWord CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to IDWord lock status. CNcomment: CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetIDWordLockFlag(HI_BOOL *pbLockFlag);
+/**
+\brief  Set hdcp root key to otp, 16bytes length.
+\brief CNcomment:hdcp root key16 CNend
+\attention \n
+N/A
+\param[in] pu8RootKey:  Set hdcp root key to otp.                   CNcommenthdcp root keyOTP CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Get hdcp root key from otp, 16bytes length.
+\brief CNcomment:hdcp root key16 CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to hdcp root key from otp.               CNcomment:OTPhdcp root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Lock hdcp root key in otp.
+\brief CNcomment:hdcp root keyhdcp root key CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockHdcpRootKey(HI_VOID);
+
+/**
+\brief  Get hdcp root Key lock flag.
+\brief CNcomment:hdcp root key CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to hdcp root key lock flag from otp.     CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetHdcpRootKeyLockFlag(HI_BOOL *pbLock);
+
+/**
+\brief Set stb root key to otp.
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[in] u8StbRootKey:  Point to stb root key value.                  CNcomment:Stb root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Get stb root key from otp.
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to stb root key from otp.                CNcomment:Stb root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Lock stb root key in otp.
+\brief CNcomment:stb root keystb root key CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockStbRootKey(HI_VOID);
+
+/**
+\brief Get stb root Key lock flag
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to stb root key lock flag from otp.      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbRootKeyLockFlag(HI_BOOL *pbLockFlag);
+
+
+/**
+\brief Get CA Vendor ID. CNcomment: CNend
+\attention \n
+N/A
+\param[out] penVendorID:  CA VendorID. CNcomment: CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetVendorID(HI_UNF_OTP_VENDORID_E *penVendorID);
+
+/**
+\brief Get the serial number of the STB. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8StbSn serial number of the STB. CNcomment: CNend
+\param[in/out] pu32Len point to the length of serial number of the STB, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+::HI_UNF_ADVCA_SetStbSn
+*/
+HI_S32 HI_UNF_OTP_GetStbSN(HI_U8 *pu8StbSN, HI_U32 *pu32Len);
+
+/**
+\brief Set the serial number of the STB. CNcomment: CNend
+\attention \n
+The serial number of the STB is set before delivery. The serial number can be set once only and takes effects after the STB restarts.
+CNcomment: CNend
+\param[in] pu8StbSn point to serial number of the STB. CNcomment: CNend
+\param[in] u32Len The length of serial number of the STB, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetStbSN(HI_U8 *pu8StbSN, HI_U32 u32Len);
+
+/**
+\brief set the type of flash memory for security startup. CNcomment:Flash CNend
+\attention N/A
+\param[in]  enFlashType Type of the flash memory for security startup. CNcomment: Flash CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootMode(HI_UNF_OTP_FLASH_TYPE_E enFlashType);
+
+
+/**
+\brief Disables the self-boot. CNcomment:, boot/ CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:SelfBoot CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Get the self-boot status. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable Pointer to the self-boot status, true means DISABLE. CNcomment:true CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetSelfBootStat(HI_BOOL *pbDisable);
+
+
+/**
+\brief Force decrypt the BootLoader. CNcomment:BootLoader CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment:
+FlashBootLoader CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableBootDecrypt(HI_VOID);
+
+
+/**
+\brief Get the BootLoader Decryption status. CNcomment:BootLoader CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to bootLoader Decryption status. CNcomment:Bootloader CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetBootDecryptStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the security startup. This API should be used after the API HI_UNF_OTP_SetBootMode.
+CNcomment:HI_UNF_OTP_COMMON_SetBootMode CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableSCS(HI_VOID);
+
+
+/**
+\brief Get the security startup status function. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to bootLoader SCS status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetSCSStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the Trust Zone. CNcomment:Trust ZoneCNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableTrustZone(HI_VOID);
+
+
+/**
+\brief Get the Trust Zone status.
+CNcomment:TrustZone CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to trust zone status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetTrustZoneStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the market segment identifier. CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8MSID Point to MSID. CNcomment: CNend
+\param[in/out] pu32Len Point to MSID length, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetMSID(HI_U8 *pu8MSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Set the market segment identifier CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8MSID Point to MSID. CNcomment: CNend
+\param[in/out] u32MSIdLen MSID length, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetMSID(HI_U8 *pu8MSID, HI_U32 u32Len);
+
+
+/**
+\brief Get the secure os market segment identifier CNcomment:OS  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8SOSMSID Point to SOS MSID. CNcomment:OS CNend
+\param[in/out] pu32Len Point to SOS MSID length, current is 4. CNcomment:OS4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the sos market segment identifier CNcomment:OS  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8SOSMSID Point to SOSMSID. CNcomment:OS CNend
+\param[in] u32Len MSID length, current is 4. CNcomment:OS4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 u32Len);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: 16 CNend
+\param[in] pu8Value CNcomment: otp  CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongData(HI_CHAR * pFuseName, HI_U32 u32Offset, HI_U8 * pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: 16 CNend
+\param[out] pu8Value CNcomment: otp  CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongData(HI_CHAR * pFuseName, HI_U32 u32Offset, HI_U8 * pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: ,16 CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongDataLock(HI_CHAR * pFuseName, HI_U32 u32Offset, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: ,16 CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\param[out] pu32Lock CNcomment: 0,1,2  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongDataLock(HI_CHAR * pFuseName, HI_U32 u32Offset, HI_U32 u32Length,  HI_U32 * pu32Lock);
+
+/**
+\brief disable wake up from ddr. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeup(HI_VOID);
+
+
+/**
+\brief Get wake up from ddr status. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable Point to DDR WakeUp status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupStat(HI_BOOL *pbDisable);
+
+/**
+\brief Lock the whole OTP area. CNcomment:OTP CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_LockGlobalOTP(HI_VOID);
+
+
+
+/**
+\brief Get global otp lock status function. CNcomment:OTP CNend
+\attention \n
+None CNcomment: CNend
+\param[out]  pbEnable Point to global OTP lock status. CNcomment:OTP CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetGlobalOTPLockStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable runtime-check. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[in]  None
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableRuntimeCheck(HI_VOID);
+
+
+/**
+\brief Get runtime-check status CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to runtime Check status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetRuntimeCheckStat(HI_BOOL *pbEnable);
+
+/**
+\brief Disable DDR wakeup check. CNcomment:CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeupCheck(HI_VOID);
+
+
+/**
+\brief Get ddr wakeup check status. CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to DDR Wakeup Check status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupCheckStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable ddr scramble. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableDDRScramble(HI_VOID);
+
+
+/**
+\brief Get ddr scramble status CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Pointer to DDR Scramble Stat. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRScrambleStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the mode of the JTAG. CNcomment:JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the JTAG. CNcomment:JTAG CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the mode of the TEE JTAG. CNcomment: TEE JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the TEE JTAG. CNcomment: TEE JTAG CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the boot version identifier CNcomment:boot  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8VersionID Point to version ID. CNcomment:boot CNend
+\param[in/out] pu32VersionIdLen Point to the length of version ID, current is 4. CNcomment:boot4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetBootVersionID(HI_U8 *pu8VersionID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the boot version identifier CNcomment:boot  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8VersionID Point to version ID. CNcomment:boot CNend
+\param[in] u32Len The length of version ID, current is 4. CNcomment:boot4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootVersionID(HI_U8 *pu8VersionID, HI_U32 u32Len);
+
+
+/**
+\brief Set root key to otp. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enRootkeyType:   Type of rootkey.        CNcomment: CNend
+\param[in] pu8Rootkey: Point to root key value.     CNcomment: CNend
+\param[in] u32Len: The length of root key.          CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRootKey(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_U8 *pu8Rootkey, HI_U32 u32Len);
+
+
+/**
+\brief Get root key lock status.                    CNcomment:OTP CNend
+\attention \n
+N/A
+\param[in] enRootkeyType: Type of rootkey.          CNcomment: CNend
+\param[out] pbLock: Point to root key lock status.  CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRootKeyLockStat(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_BOOL *pbLock);
+
+/**
+\brief Set RSA key to otp. CNcomment:RSA CNend
+\attention \n
+N/A
+\param[in] pu8Key: Point to RSA key value.         CNcomment:RSA CNend
+\param[in] u32KeyLen: The length of RSA key.       CNcomment:RSA CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRSAKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get rsa lock status. CNcomment:RSA lock CNend
+\attention \n
+N/A
+\param[out] pbLock: Rsa lock status.   CNcomment:RSA lock CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRSALockStat(HI_BOOL *pbLock);
+
+
+/**
+\brief Burn product PV to otp. CNcomment:OTP CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment: CNend
+\param[in] u32Num:  the nember of config table.         CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/**
+\brief Verify product PV. CNcomment:PV CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment: CNend
+\param[in] u32Num:  the nember of config table.         CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_VerifyProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_H__ */
diff -uNr git/xbmc/linux/hisi/hi_unf_sound.h unlib/xbmc/linux/hisi/hi_unf_sound.h
--- git/xbmc/linux/hisi/hi_unf_sound.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_sound.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,1743 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_sound.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/1/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : z67193
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the SOUND (SND) module. CNcomment:SOUND CNend
+ */
+
+#ifndef  __HI_UNF_SND_H__
+#define  __HI_UNF_SND_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/********************************Macro Definition********************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!-- SOUND */
+
+/**Maximum sound outputport*/
+/**CNcomment:sound*/
+#define HI_UNF_SND_OUTPUTPORT_MAX (16)
+#define HI_UNF_SND_EQ_BANDNUM_MAX (10)
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  SOUND */
+
+/**Defines the ID of the audio output (AO) device.*/
+/**CNcomment:*/
+typedef enum hiUNF_SND_E
+{
+    HI_UNF_SND_0,           /**<AO device 0*/ /**<CNcomment:0 */
+    HI_UNF_SND_1,           /**<AO device 1*/ /**<CNcomment:1 */
+    HI_UNF_SND_2,           /**<AO device 2*/ /**<CNcomment:2 */
+    HI_UNF_SND_BUTT
+} HI_UNF_SND_E;
+
+/**Audio volume attribute*/
+/**CNcomment:*/
+typedef struct hiHI_UNF_SND_GAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type of volume*/ /**<CNcomment: */
+    HI_S32  s32Gain; /**<Linear gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                     /**<Decibel gain(bLinearMode is HI_FALSE) , ranging from -70dB to 0dB */ /**<CNcomment: dB:-70~0*/
+} HI_UNF_SND_GAIN_ATTR_S;
+
+/**Audio L/R channel volume attribute*/
+/**CNcomment:*/
+typedef struct hiHI_UNF_SND_ABSGAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type*/ /**<CNcomment: */
+    HI_S32  s32GainL; /**<Linear left ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                     /**<Decibel left ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: dB:-81~+18*/
+    HI_S32  s32GainR; /**<Linear right ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                  /**<Decibel right ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: dB:-81~+18*/
+} HI_UNF_SND_ABSGAIN_ATTR_S;
+
+/**High Precision Gain, ranging from -81dB to 18dB, step 0.125dB*/
+/**CNcomment:-81dB18dB0.125dB*/
+typedef struct hiHI_UNF_SND_PRECIGAIN_ATTR_S
+{
+    HI_S32 s32IntegerGain; /**<Interger part of high preicision gain*/ /**<CNcomment: */
+    HI_S32 s32DecimalGain; /**<decimal part of high preicision gain, if -0.125dB, value is -125*/ /**<CNcomment:  0.125125*/
+}HI_UNF_SND_PRECIGAIN_ATTR_S;
+
+/**Audio Track Type: Master, Slave, Virtual channel,LowLatency channel*/
+/**CNcomment:Track:   */
+/**LowLatency channel not support attach avplay and the data only support 48K,stereo,16Bit.Only support one lowlatency track in a sound*/
+/**CNcomment:AVPLAY48K,,16,*/
+typedef enum hiHI_UNF_SND_TRACK_TYPE_E
+{
+    HI_UNF_SND_TRACK_TYPE_MASTER = 0,
+    HI_UNF_SND_TRACK_TYPE_SLAVE,
+    HI_UNF_SND_TRACK_TYPE_VIRTUAL,
+    HI_UNF_SND_TRACK_TYPE_LOWLATENCY,
+
+    HI_UNF_SND_TRACK_TYPE_SYS,   /**< System sound(PCM) MS12 ONLY.*/
+    HI_UNF_SND_TRACK_TYPE_TTS,   /**< TTS(PCM) MS12 ONLY.*/
+    HI_UNF_SND_TRACK_TYPE_BUTT
+} HI_UNF_SND_TRACK_TYPE_E;
+
+/**Audio output attribute */
+/**CNcomment:*/
+typedef struct hiHI_UNF_AUDIOTRACK_ATTR_S
+{
+    HI_UNF_SND_TRACK_TYPE_E     enTrackType;        /**<Track Type*/ /**<CNcomment:Track*/
+    HI_U32                      u32FadeinMs;        /**<Fade in time(unit:ms)*/ /**<CNcomment:(: ms)*/
+    HI_U32                      u32FadeoutMs;       /**<Fade out time(unit:ms)*/ /**<CNcomment:(: ms)*/
+    HI_U32                      u32OutputBufSize;   /**<Track output buffer size*/ /**<CNcomment:Track*/
+    HI_U32                      u32BufLevelMs;      /**<Output buffer data size control(ms),default 400ms*/ /**<CNcomment:(ms),400ms*/
+    HI_U32                      u32StartThresholdMs;  /**<Track start threshold (ms), default value is 50ms, max value is equal to u32BufLevelMs, only valid for master track*/
+                                                      /**<CNcomment:Track50msu32BufLevelMsmaster track*/
+} HI_UNF_AUDIOTRACK_ATTR_S;
+
+/**Audiotrack config parameter*/
+/**CNcomment: Track*/
+typedef struct hiHI_UNF_AUDIOTRACK_CONFIG_S
+{
+    HI_U32      u32ConfigType;        /**<Track config type*/ /**<CNcomment:Track*/
+    HI_VOID*    pConfigData;          /**<Track config data*/ /**<CNcomment:Track*/
+} HI_UNF_AUDIOTRACK_CONFIG_S;
+
+/**Audio outputport: DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+/**CNcomment::DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+typedef enum hiUNF_SND_OUTPUTPORT_E
+{
+    HI_UNF_SND_OUTPUTPORT_DAC0 = 0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S1,
+
+    HI_UNF_SND_OUTPUTPORT_SPDIF0,
+
+    HI_UNF_SND_OUTPUTPORT_HDMI0,
+
+    HI_UNF_SND_OUTPUTPORT_ARC0,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC1 = 0x50,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC2,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC3,
+
+    HI_UNF_SND_OUTPUTPORT_ALL = 0x7fff,
+
+    HI_UNF_SND_OUTPUTPORT_BUTT,
+} HI_UNF_SND_OUTPUTPORT_E;
+
+/**Defines internal Audio DAC outport attribute */
+/**CNcomment:DAC*/
+typedef struct hiUNF_SND_DAC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_DAC_ATTR_S;
+
+/**Defines  Audio I2S outport attribute */
+/**CNcomment:I2S*/
+typedef struct hiUNF_SND_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;
+}  HI_UNF_SND_I2S_ATTR_S;
+
+/**Defines  S/PDIF outport attribute */
+/**CNcomment:S/PDIF*/
+typedef struct hiUNF_SND_SPDIF_ATTR_S
+{
+    HI_U32 u32Reserved;
+}  HI_UNF_SND_SPDIF_ATTR_S;
+
+/**Defines  HDMI Audio outport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_SND_HDMI_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_HDMI_ATTR_S;
+
+/**Defines  HDMI ARC outport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_SND_ARC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_ARC_ATTR_S;
+
+/**Defines  Audio outport attribute */
+/**CNcomment:*/
+typedef struct hiUNF_SND_OUTPORT_S
+{
+    HI_UNF_SND_OUTPUTPORT_E enOutPort;
+    union
+    {
+        HI_UNF_SND_DAC_ATTR_S   stDacAttr;
+        HI_UNF_SND_I2S_ATTR_S   stI2sAttr;
+        HI_UNF_SND_SPDIF_ATTR_S stSpdifAttr;
+        HI_UNF_SND_HDMI_ATTR_S  stHDMIAttr;
+        HI_UNF_SND_ARC_ATTR_S   stArcAttr;
+    } unAttr;
+} HI_UNF_SND_OUTPORT_S;
+
+/**Defines  Audio Sound device attribute */
+/**CNcomment:Sound*/
+typedef struct hiHI_UNF_SND_ATTR_S
+{
+    HI_U32                  u32PortNum;  /**<Outport number attached sound*/ /**<CNcomment:Sound*/
+    HI_UNF_SND_OUTPORT_S    stOutport[HI_UNF_SND_OUTPUTPORT_MAX];  /**<Outports attached sound*/ /**<CNcomment:Sound*/
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;       /**<Sound samplerate*/ /**<CNcomment:Sound*/
+    HI_U32                  u32MasterOutputBufSize; /**<Sound master channel buffer size*/ /**<CNcomment:Sound*/
+    HI_U32                  u32SlaveOutputBufSize;  /**<Sound slave channel buffer size*/ /**<CNcomment:Sound*/
+} HI_UNF_SND_ATTR_S;
+
+/**define SND CAST config  struct */
+/**CNcomment:*/
+typedef struct hiUNF_SND_CAST_ATTR_S
+{
+    HI_U32  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer*/ /**<CNcomment: */
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data*/ /**<CNcomment: PCM*/
+    HI_BOOL bAddMute;              /**<Add mute frame in cast or not>*/ /**<CNcomment: cast*/
+} HI_UNF_SND_CAST_ATTR_S;
+
+/**HDMI MODE:AUTO,LPCM,RAW,HBR2LBR*/
+/**CNcomment:HDMI :AUTO,LPCM,RAW,HBR2LBR*/
+typedef enum hiHI_UNF_SND_HDMI_MODE_E
+{
+    HI_UNF_SND_HDMI_MODE_LPCM = 0,       /**<HDMI LCPM2.0*/ /**<CNcomment: pcm*/
+    HI_UNF_SND_HDMI_MODE_RAW,            /**<HDMI Pass-through.*/ /**<CNcomment: HDMI*/
+    HI_UNF_SND_HDMI_MODE_HBR2LBR,        /**<HDMI Pass-through force high-bitrate to low-bitrate.*/ /**<CNcomment: */
+    HI_UNF_SND_HDMI_MODE_AUTO,           /**<automatically match according to the EDID of HDMI */ /**<CNcomment: HDMI EDID*/
+    HI_UNF_SND_HDMI_MODE_BUTT
+} HI_UNF_SND_HDMI_MODE_E;
+
+/**SPDIF MODE:LPCM,RAW*/
+/**CNcomment:SPDIF :LPCM,RAW*/
+typedef enum hiHI_UNF_SND_SPDIF_MODE_E
+{
+    HI_UNF_SND_SPDIF_MODE_LPCM,           /**<SPDIF LCPM2.0*/ /**<CNcomment: pcm*/
+    HI_UNF_SND_SPDIF_MODE_RAW,            /**<SPDIF Pass-through.*/ /**<CNcomment: SPDIF*/
+    HI_UNF_SND_SPDIF_MODE_BUTT
+} HI_UNF_SND_SPDIF_MODE_E;
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/**SPDIF Category Code Setting*/
+/**CNcomment:SPDIF Category Code*/
+typedef enum hiHI_UNF_SND_SPDIF_CATEGORYCODE_E
+{
+    HI_UNF_SND_SPDIF_CATEGORY_GENERAL = 0x00,       /**<General*/                  /**<CNcomment:*/
+    /*broadcast reception of digitally encoded audio
+    with/without video signals*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_JP = 0x10,  /**<Japan*/                    /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_USA,        /**<United States*/            /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_EU,         /**<Europe*/                   /**<CNcomment:*/
+    /*digital converter & signal-processing products*/
+    HI_UNF_SND_SPDIF_CATEGORY_PCM_CODEC = 0x20,     /**<PCM Encoder/Decoder*/      /**<CNcomment:PCM*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDSAMPLER,   /**<Digital Sound Sampler*/    /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_MIXER,        /**<Digital Signal Mixer*/     /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDPROCESSOR, /**<Digital Sound Processor*/  /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_SRC,                  /**<Sample Rate Converter*/    /**<CNcomment:*/
+    /*laser optical products*/
+    HI_UNF_SND_SPDIF_CATEGORY_MD = 0x30,            /**<MiniDisc*/                 /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DVD,                  /**<Digital Versatile Disc*/   /**<CNcomment:*/
+    /*musical instruments, microphones and other sources
+    that create original sound*/
+    HI_UNF_SND_SPDIF_CATEGORY_SYNTHESISER = 0x40,   /**<Synthesiser*/              /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_MIC,                  /**<Microphone*/               /**<CNcomment:*/
+    /*magnetic tape or magnetic disc based products*/
+    HI_UNF_SND_SPDIF_CATEGORY_DAT = 0x50,           /**<Digital Audio Tape*/       /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DCC,                  /**<Digital Compact Cassette*/ /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_VCR,                  /**<Video Cassette Recorder*/  /**<CNcomment:*/
+
+    HI_UNF_SND_SPDIF_CATEGORY_BUTT
+} HI_UNF_SND_SPDIF_CATEGORYCODE_E;
+
+/**SPDIF SCMS Mode Setting*/
+/**CNcomment:SPDIF SCMS*/
+typedef enum hiHI_UNF_SND_SPDIF_SCMSMODE_E
+{
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYALLOW,                /**<Copy Allow*/      /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYONCE,                 /**<Copy Once*/       /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYNOMORE,               /**<Copy NoMore*/     /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYPROHIBITED,           /**<Copy prohibited*/ /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_BUTT
+} HI_UNF_SND_SPDIF_SCMSMODE_E;
+
+/**audio effect type, HI_UNF_AUDIO_EFFECT_TYPE_E keep consistent with effect type of ARM/DSP*/
+/**CNcomment:HI_UNF_AUDIO_EFFECT_TYPE_E  ARM/DSP  */
+typedef enum
+{
+    HI_UNF_SND_AEF_TYPE_DOLBYDV258 = 0x000,  /**<Dolby audio effect*/ /**<CNcomment: Dolby*/
+
+    HI_UNF_SND_AEF_TYPE_SRS3D = 0x010,      /**<SRS audio effect*/ /**<CNcomment: SRS*/
+
+    HI_UNF_SND_AEF_TYPE_BASE = 0x080,       /**<Base audio effect*/ /**<CNcomment: */
+} HI_UNF_SND_AEF_TYPE_E;
+
+typedef enum hiUNF_PEQ_FILTER_TYPE_E
+{
+    HI_UNF_PEQ_FILTER_TYPE_HP = 0,  /**<high-pass filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_LS = 1,  /**<low-shelving filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_PK = 2,  /**<peaking filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_HS = 3,  /**<high-shelving filter*/ /**<CNcomment:   */
+    HI_UNF_PEQ_FILTER_TYPE_LP = 4,  /**<low-pass filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_BUTT
+} HI_UNF_PEQ_FILTER_TYPE_E;
+
+/**Defines PEQ band attribute*/
+/**CNcomment:PEQ */
+typedef struct hiHI_UNF_SND_PEQ_BAND_ATTR_S
+{
+    HI_UNF_PEQ_FILTER_TYPE_E enFltType; /**<filter type of the band*/ /**<CNcomment: */
+    HI_U32 u32freq;  /**<center frequency of the band, HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+                     /**<CNcomment: ,: HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+    HI_U32 u32Q; /**<Q value of the band, if 2.5, value is 25, range:HS and LS[0.7, 1], PK[0.5, 10],HP and LP is fix to be 0.7*/
+                 /**<CNcomment: q,2.5,25,: HS and LS[0.7, 1], PK[0.5, 10], 0.7*/
+    HI_S32 s32Gain; /**<gain of the band, if -2.125, value is -2125,Gain ranging from -15 to 15 step by 0.125dB*/
+                    /**<CNcomment: ,-2.125,-2125,:[-15, 15],0.125*/
+} HI_UNF_SND_PEQ_BAND_ATTR_S;
+
+/**Defines PEQ attribute */
+/**CNcomment:PEQ */
+typedef struct hiHI_UNF_SND_PEQ_ATTR_S
+{
+    HI_U32 u32BandNum; /**<the PEQ band number,u32BandNum ranging from 5 to 10*/ /**<CNcomment: PEQ,:[5,10]*/
+    HI_UNF_SND_PEQ_BAND_ATTR_S stEqParam[HI_UNF_SND_EQ_BANDNUM_MAX];/**<PEQ band attribute*/ /**<CNcomment: PEQ*/
+} HI_UNF_SND_PEQ_ATTR_S;
+
+/**Defines DRC attribute */
+/**CNcomment:DRC*/
+typedef struct hiHI_UNF_SND_DRC_ATTR_S
+{
+    HI_U32  u32AttackTime;   /**<the attack time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: (:ms),:[20, 2000]*/
+    HI_U32  u32ReleaseTime;  /**<the release time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: (:ms),:[20, 2000]*/
+    HI_S32  s32Thrhd;  /**<the threshold value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: ,-2.125,-2125,0.125dB,:[-80dB, -1dB)*/
+    HI_S32  s32Limit;  /**<the maximum value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: ,-2.125,-2125,0.125dB,:[-80dB, -1dB)*/
+    HI_U32  u32RefMode;  /**<refmode(0:process both channel together mode, 1:process each channel independently mode)*/ /**<CNcomment:  0:  1 */
+    HI_U32  u32SpeedCtrlMode;  /**<speedctrlmode(0:normal mode, 1:fast mode)*/ /**<CNcomment: 0:  1:  */
+} HI_UNF_SND_DRC_ATTR_S;
+
+/**Defines  AVC attribute */
+/**CNcomment:AVC*/
+typedef struct hiHI_UNF_SND_AVC_ATTR_S
+{
+    HI_S32  s32ThresholdLevel;  /**<the threshold value, if -32.125, value is -32125, ranging from -40dB to -16dB step by 0.125dB*/
+                                /**<CNcomment: ,-32.125,-32125,0.125dB,(-40dB, -16dB)*/
+    HI_S32  s32Gain;            /**<the gain value, if 2.125, value is 2125,ranging from 0dB to 8dB step by 0.125dB*/
+                                /**<CNcomment: ,2.125,2125,0.125dB,:[0dB, 8dB]*/
+    HI_S32  s32LimiterLevel;    /**<the target level value, if -2.125, value is -2125, ranging from -40dB to 0dB step by 0.125dB*/
+                                /**<CNcomment:,-2.125,-2125,0.125dB,:(-40dB, 0dB]*/
+    HI_U32  u32AttackTime;      /**<the attack time(unit:ms),ranging from 20 to 2000,default value 50(recommended)*/ /**<CNcomment: (:ms),:[20, 2000]50*/
+    HI_U32  u32ReleaseTime;     /**<the release time(unit:ms),ranging from 20 to 2000,default value 100(recommended)*/ /**<CNcomment: (:ms),:[20, 2000]100*/
+} HI_UNF_SND_AVC_ATTR_S;
+
+/******************************* API declaration *****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  SOUND */
+
+/**
+\brief Initializes an AO device. CNcomment: CNend
+\attention \n
+Before calling the SND module, you must call this application programming interface (API). CNcomment:SND CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AO device. CNcomment: CNend
+\attention \n
+N/A
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_DeInit(HI_VOID);
+
+/**
+\brief Obtains the default configured parameters of an AO device. CNcomment: CNend
+\attention \n
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[out] pstAttr     Audio attributes CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_E enSound, HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Starts an AO device. CNcomment: CNend
+\attention \n
+One port only can attach to one sound.
+CNcomment:sound CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] pstAttr     Attribute of an AO device CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Open(HI_UNF_SND_E enSound, const HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Destroys a AO SND instance. CNcomment:Sound CNend
+\attention \n
+An instance cannot be destroyed repeatedly. CNcomment: CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Close(HI_UNF_SND_E enSound);
+
+
+/**
+\brief Sets the mute status of  AO ports. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of AO ports. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbMute);
+
+/**
+\brief Sets the output mode of the HDMI(Auto/PCM/RAW/HBR2LBR).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enHdmiMode HDMI mode CNcomment:HDMICNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E enHdmiMode);
+
+/**
+\brief Gets the output mode of the HDMI.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] Pointer to the obtained HDMI mode CNcomment:HDMICNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E* penHdmiMode);
+
+/**
+\brief Sets the output mode of the SPDIF(PCM/RAW).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enHdmiMode SPDIF mode CNcomment:SPDIFCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E enSpdifMode);
+
+/**
+\brief Gets the output mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] penSpdifMode Pointer to the obtained SPDIF mode CNcomment:SPDIFCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E* penSpdifMode);
+
+/**
+ \brief Sets the output volume value. CNcomment: CNend
+ \attention \n
+If s32Gain is set to a value greater than 100 or 0dB, then return failure. CNcomment:s32Gain1000dB CNend
+ \param[in] enSound        ID of an AO device CNcomment: CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+ \param[in] pstGain     Volume value CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE FAILURE CNcomment: CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_SND_INVALID_ID        The parameter enSound is invalid. CNcomment:Sound ID CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_SetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Obtains the output volume value. CNcomment: CNend
+\attention \n
+The default linear volume value is 100 and abslute volume is 0dB. CNcomment:100() and 0dB() CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+ \param[out] pstGain    Pointer to the obtained volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Sets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enSpdifCategoryCode  SPDIF category code CNcomment:SPDIF CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E enSpdifCategoryCode);
+
+/**
+\brief Gets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] enSpdifCategoryCode Pointer to the obtained category code CNcomment:CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E* penSpdifCategoryCode);
+
+/**
+\brief Sets the SCMS mode of the SPDIF(COPYALLOW/COPYONCE/COPYPROHIBITED).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enSpdifSCMSMode  SPDIF SCMS mode CNcomment:SPDIF SCMS CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E enSpdifSCMSMode);
+
+/**
+\brief Gets the SCMS mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] enSpdifSCMSMode Pointer to the obtained SPDIF SCMS mode CNcomment:SPDIF SCMSCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E* enSpdifSCMSMode);
+
+/**
+\brief Sets the sampling rate during audio output. CNcomment: CNend
+\attention \n
+At present, the sampling rate cannot be set, and it is fixed at 48 kHz. The streams that are not sampled at 48 kHz are resampled at 48 kHz.
+CNcomment:48k(48K~192K)8K192K6\n
+192K(192K)32K()\n
+8K(8K~192K)HDMI32K(HDMI) CNend
+\param[in] enSound          ID of an AO device CNcomment: CNend
+\param[in] enSampleRate    Audio sampling rate. For details, see the description of ::HI_UNF_SAMPLE_RATE_E. CNcomment:::HI_UNF_SAMPLE_RATE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E enSampleRate);
+
+/**
+\brief Obtains the sampling rate during audio output. CNcomment: CNend
+\attention \n
+The 48 kHz sampling rate is returned by default. CNcomment:48kHz CNend
+\param[in] enSound           ID of an AO device CNcomment: CNend
+\param[out] penSampleRate   Pointer to the type of the audio sampling rate CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E* penSampleRate);
+
+/**
+\brief set aduiodelay for output port. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] enOutPort output port .CNcomment: CNend
+\param[in] u32DelayMs Audio delay ms .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32 u32DelayMs);
+
+/**
+\brief get aduiodelay for output port. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] enOutPort output port .CNcomment: CNend
+\param[in] pu32DelayMs Audio delay ms .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32* pu32DelayMs);
+
+/**
+\brief enable ADAC audio output. CNcomment: ADAC  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] bEnable enable ADAC output .CNcomment:ADAC  CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAdacEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Sets the smart volume for audio output. CNcomment: CNend
+\attention \n
+1. The smart volume is disabled by default.\n
+2. The smart volume is valid only for the track.\n
+3. The smart volume is enabled only when the program is switched.
+CNcomment:1. \n
+2. track\n
+3.  CNend
+\param[in] hTrack           Track handle CNcomment:Track  CNend
+\param[in] bSmartVolume     Smart volume enable, HI_TRUE: enabled; HI_FALSE: disabled CNcomment:HI_TRUEHI_FALSE CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL bEnable);
+
+/**
+\brief Obtains the status of the smart volume for audio output. CNcomment: CNend
+\attention \n
+\param[in] hTrack           Track handle CNcomment:Track  CNend
+\param[out] pbSmartVolume     Pointer to the enable status of the smart volume CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL* pbEnable);
+
+/**
+\brief Seting low latency threshold for audio output. CNcomment: Sound CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  CNcomment:sound  CNend
+\param[in] u32LatecnyMs,  latency ms .CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32 u32LatecnyMs);
+
+/**
+\brief Geting low latency threshold for audio output. CNcomment: Sound CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  CNcomment:sound  CNend
+\param[in] pu32LatecnyMs,  latency ms .CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32* p32LatecnyMs);
+
+/**
+\brief Set the AO track mode. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] enOutPort   CNcomment:sound CNend
+\param[in] enMode     Audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the AO track mode. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] enOutPort   CNcomment:sound CNend
+\param[out] penMode   Pointer to the AO track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+\brief Attaches the SND module to an audio/video player (AVPLAY). CNcomment:SoundAVAudio Video CNend
+\attention \n
+Before calling this API, you must create a player and ensure that the player has no output. CNcomment: CNend
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track  CNend
+\param[in] hSource           Instance handle of an AVPLAY CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_Attach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Detaches the SND module from an AVPLAY. CNcomment:TrackAV CNend
+\attention \n
+N/A
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track  CNend
+\param[in] hSource    Instance handle of an AVPLAY CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Detach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Sets the mixing weight of an audio player. CNcomment:Track  CNend
+\attention \n
+The output volumes of two players are calculated as follows: (volume x weight 1 + volume x weight 2)/100. The formula of calculating the output volumes of multiple players is similar.
+CNcomment:Track %1+%2/100 CNend
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstMixWeightGain   the MixWeight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:01000100 CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackWeight(HI_HANDLE hTrack, const HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Obtains the mixing weight of an audio player. CNcomment: CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstMixWeightGain     Pointer to the MixWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackWeight(HI_HANDLE hTrack, HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Sets the L/R channel weight of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackAbsWeight(HI_HANDLE hTrack, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of an audio player. CNcomment: CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackAbsWeight(HI_HANDLE hTrack, HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets mute or unmute of an audio player. CNcomment:Track  CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] bMute               mute or not CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackMute(HI_HANDLE hTrack, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[out] pbMute               mute status CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackMute(HI_HANDLE hTrack, HI_BOOL* pbMute);
+
+/**
+\brief Sets mute or unmute of all players. CNcomment:Track  CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:soundtrack CNend
+\param[in] bMute               mute or not CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of all players. CNcomment:Track CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:sound track CNend
+\param[in] pbMute               mute status CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL* pbMute);
+
+/**
+\brief Set the track channel mode. CNcomment:Track   CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] enMode             The audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the track channel mode. CNcomment:Track  CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[out] penMode   Pointer to the audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+ \brief Obtains the default configured parameters of an AO Track. CNcomment:Track CNend
+ \attention \n
+ \param[in] enTrackType              Track Type CNcomment:Track CNend
+ \param[out] pstAttr     Audio attributes CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE  Failure  CNcomment: CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_E enTrackType, HI_UNF_AUDIOTRACK_ATTR_S* pstAttr);
+
+/**
+\brief Create a Track. CNcomment:Track CNend
+\attention \n
+Create 8 output tracks(master/slave track) and 6 virtual tracks at the most. only create 1 master track on every sound.
+CNcomment:8track(master/slave), 6tracksoundmaster track CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] pTrackAttr  Track attributes CNcomment:Track   CNend
+\param[out] phTrack   Pointer to the handle of the created Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE  Failure  CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_CreateTrack(HI_UNF_SND_E enSound, const HI_UNF_AUDIOTRACK_ATTR_S* pTrackAttr, HI_HANDLE* phTrack);
+
+/**
+\brief Destroy a Track. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_DestroyTrack(HI_HANDLE hTrack);
+
+/**
+\brief set the attribute of  a track, reversed. CNcomment:track  CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] stTrackAttr   the attribute of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackAttr(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief get the attribute of  a track, reversed. CNcomment:track  CNend
+\attention \n
+1.virtual track Attr not support set.\n
+2.pstTrackAttr struct: just enTrackType&u32BufLevelMs can be set ,other members not support.
+CNcomment:1.track\n
+2.pstTrackAttrenTrackType&u32BufLevelMs CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[out] pstTrackAttr   the attribute of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackAttr(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief set the config of a track. CNcomment:track CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.ms12track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] pstConfig   the config of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackConfig(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief get the config of a track. CNcomment:track CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.ms12track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[out] pstConfig   the config of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackConfig(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief Acquire the audio frame from the track. CNcomment:track CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment: CNend
+\param[out] pstAOFrame the audio frame  CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_AcquireTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Release the audio frame . CNcomment:track  CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] pstAOFrame the audio frame  CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID  The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_ReleaseTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief  Transmits data to a slave track directly. CNcomment:slave track CNend
+\attention \n
+1. If HI_ERR_AO_OUT_BUF_FULL is returned, you need to transmit the data that fails to be transmitted last time to ensure the audio continuity.
+2. For the PCM data, the restrictions are as follows:
+    s32BitPerSample must be set to 16.
+    bInterleaved must be set to HI_TRUE. Only interlaced mode is supported.
+    u32Channels can be set to 1 or 2.
+    u32PtsMs can be ignored.
+    ps32PcmBuffer indicates the PCM data pointer.
+    ps32BitsBuffer can be ignored.
+    u32PcmSamplesPerFrame indicates the number of audio sampling. The data length (in byte) is calculated as follows: u32PcmSamplesPerFrame x u32Channels x sizeof(HI_u16)
+    u32BitsBytesPerFrame can be ignored.
+    u32FrameIndex can be ignored.
+CNcomment:1 HI_ERR_AO_OUT_BUF_FULL
+2 PCM 
+    s32BitPerSample: 16
+    bInterleaved: HI_TRUE, 
+    u32Channels: 1 2
+    u32PtsMs: 
+    ps32PcmBuffer: PCM 
+    ps32BitsBuffer: 
+    u32PcmSamplesPerFrame: , (unit:Bytes): u32PcmSamplesPerFrame*u32Channels*sizeof(HI_u16)
+    u32BitsBytesPerFrame: 
+    u32FrameIndex:  CNend
+\param[in] hTrack   Track handle CNcomment:Track  CNend
+\param[in] pstAOFrame   Information about the audio data CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_OUT_BUF_FULL  Data fails to be transmitted because the mixer buffer is full. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SendTrackData(HI_HANDLE hTrack, const HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief Obtains the delay ms of track. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack     ID of ao track CNcomment:Track ID CNend
+\param[out] pDelayMs     DelayMs attributes CNcomment:Track CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackDelayMs(const HI_HANDLE hTrack, HI_U32* pDelayMs);
+
+/**
+\brief Sets the output high precision volume value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound        ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstPreciGain     high precision volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Obtains the output high precision volume value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pstPreciGain   Pointer to the obtained high precision volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Sets the output balance. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound        ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] s32Balance     balance value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32 s32Balance);
+
+/**
+\brief Obtains balance value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] ps32Balance   Pointer to the obtained balance value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32* ps32Balance);
+
+/**
+\brief create screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound      display channel.CNcomment: CNend
+\param[out] pstAttr      handle of default attr  .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32   HI_UNF_SND_GetDefaultCastAttr(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr);
+
+/**
+\brief create screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound      display channel.CNcomment: CNend
+\param[in] pstAttr      pointer of parameter .CNcomment:, CNend
+\param[out] phCast      handle of screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_CreateCast(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr, HI_HANDLE* phCast);
+
+/**
+\brief destroy screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phCast      handle of screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_DestroyCast(HI_HANDLE hCast);
+
+/**
+\brief enable screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] phCast      handle of screen share .CNcomment:
+\param[in] bEnable      enable screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetCastEnable(HI_HANDLE hCast, HI_BOOL bEnable);
+
+/**
+\brief get enable flag of screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phCast      handle of screen share .CNcomment: CNend
+\param[out] bEnable     flag .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetCastEnable(HI_HANDLE hCast, HI_BOOL* pbEnable);
+
+/**
+\brief get frame info of snd cast. CNcomment:  CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as SND).
+\param[in] hCast      handle of screen share .CNcomment: CNend
+\param[out] pstCastFrame        frame info.CNcomment: CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_V_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_CAST_TIMEOUT   no enough data.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief release frame info of screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] hCast      handle of screen share .CNcomment: CNend
+\param[in] pstCastFrame     frame info.CNcomment: CNend
+\param[in] u32TimeoutMs    release timeout.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_ReleaseCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame);
+
+/**
+\brief Sets the L/R channel weight of snd cast. CNcomment:Cast CNend
+\attention \n
+\param[in] hCast              ID of snd cast CNcomment:Cast ID CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:01000100 CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetCastAbsWeight(HI_HANDLE hCast, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of audio cast. CNcomment:Cast CNend
+\attention \n
+
+\param[in] hCast              ID of snd cast CNcomment:Cast ID CNend
+\param[out] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetCastAbsWeight(HI_HANDLE hCast,  HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets the mute status of audio cast. CNcomment:Cast CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetCastMute(HI_HANDLE hCast, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of audio cast. CNcomment:Cast CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetCastMute(HI_HANDLE hCast, HI_BOOL* pbMute);
+
+/**
+\brief enable/disable audio effect for output port. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  output port .CNcomment: CNend
+\param[in] bBypass    enable/disable .CNcomment: CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bBypass);
+
+/**
+\brief get info of audio effect for output port. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  output port .CNcomment: CNend
+\param[in] pbBypass   enable/disable .CNcomment: CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbBypass);
+
+/**
+\brief Registers Audio effect authorize library . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pAefLibFileName  file name of authorize library .CNcomment: CNend
+\retval ::HI_SUCCESS    success. CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_RegisterAefAuthLib(const HI_CHAR* pAefLibFileName);
+
+/**
+\brief Create audio effect . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enAefType  audio effect type .CNcomment: CNend
+\param[in] pstAdvAttr audio effect attribute .CNcomment: CNend
+\param[out] phAef     the point of audio effect handle  .CNcomment: CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_CreateAef(HI_UNF_SND_E enSound, HI_UNF_SND_AEF_TYPE_E enAefType, HI_VOID* pstAdvAttr, HI_HANDLE* phAef);
+
+/**
+\brief Destroy audio effect . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_DestroyAef(HI_HANDLE hAef);
+
+/**
+\brief start/stop audio effect postprocess. CNcomment: / CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef   audio effect handle .CNcomment: CNend
+\param[in] bEnable start/stop .CNcomment:/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefEnable(HI_HANDLE hAef, HI_BOOL bEnable);
+
+/**
+\brief Set audio effect params. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\param[in] u32ParamType parameter type .CNcomment: CNend
+\param[in] pstParms     point of parameter .CNcomment: CNend
+\retval ::HI_SUCCESSsuccess. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, const HI_VOID* pstParms);
+
+/**
+\brief Get audio effect params. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef    audio effect handle .CNcomment: CNend
+\param[in] u32ParamType  parameter type .CNcomment: CNend
+\param[out] pstParms      point of parameter .CNcomment: CNend
+\retval ::HI_SUCCESS     success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, HI_VOID* pstParms);
+
+/**
+\brief Set audio effect config. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\param[in] u32CfgType   config type .CNcomment: CNend
+\param[in] pstConfig    point of config .CNcomment: CNend
+\retval ::HI_SUCCESS    success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, const HI_VOID* pstConfig);
+
+/**
+\brief Get audio effect config. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef   audio effect handle .CNcomment: CNend
+\param[in] u32CfgType  config type .CNcomment: CNend
+\param[out] pstConfig   point of config .CNcomment: CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, HI_VOID* pstConfig);
+
+/**
+\brief Set audio avc attr. CNcomment: avc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] pstAvcAttr  the attribute of the avc .CNcomment:avc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcAttr(HI_UNF_SND_E enSound, const HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief get the attribute of  avc, reversed. CNcomment:avc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pstAvcAttr   the attribute of avc CNcomment:avc  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetAvcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief start/stop avc process. CNcomment: /avc CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of avc postprocess. CNcomment: avc/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:avc/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio drc attr. CNcomment: drc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief Get audio drc attr. CNcomment: drc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief start/stop drc process. CNcomment: /drc CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of drc postprocess. CNcomment: drc/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:drc/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio peq attr. CNcomment: peq CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstPeqAttr  the attribute of the peq .CNcomment:peq CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief get the attribute of  peq, reversed. CNcomment:peq CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pstPeqAttr   the attribute of peq CNcomment:peq  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief start/stop peq process. CNcomment: /peq CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of peq postprocess. CNcomment: peq/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:peq/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_SND_H__*/
+
diff -uNr git/xbmc/linux/hisi/hi_unf_video.h unlib/xbmc/linux/hisi/hi_unf_video.h
--- git/xbmc/linux/hisi/hi_unf_video.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_video.h	2018-07-18 17:35:28.528490000 +0800
@@ -0,0 +1,646 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_video.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_VIDEO_H__
+#define __HI_UNF_VIDEO_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include "hi_common.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VIDEO */
+/** @{ */  /** <!-- [VIDEO] */
+
+/**Defines the oversample mode.*/
+/**CNcomment: */
+typedef enum hiUNF_OVERSAMPLE_MODE_E
+{
+    HI_UNF_OVERSAMPLE_1X = 0,
+    HI_UNF_OVERSAMPLE_2X,
+    HI_UNF_OVERSAMPLE_4X,
+    HI_UNF_OVERSAMPLE_BUTT,
+} HI_UNF_OVERSAMPLE_MODE_E;
+
+/**Defines the pixel width.*/
+/**CNcomment: */
+typedef enum hiUNF_PIXEL_BITWIDTH_E
+{
+    HI_UNF_PIXEL_BITWIDTH_8BIT = 0,
+    HI_UNF_PIXEL_BITWIDTH_10BIT,
+    HI_UNF_PIXEL_BITWIDTH_12BIT,
+    HI_UNF_PIXEL_BITWIDTH_BUTT,
+} HI_UNF_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: */
+typedef enum hiUNF_COLOR_SPACE_E
+{
+    HI_UNF_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_UNF_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_UNF_COLOR_SPACE_BT601_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_UNF_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_UNF_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_UNF_COLOR_SPACE_BT709_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT709_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_UNF_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_UNF_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_UNF_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_UNF_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_UNF_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_UNF_COLOR_SPACE_JPEG = 0x90,
+    HI_UNF_COLOR_SPACE_RGB = 0xa0,
+
+    HI_UNF_COLOR_SPACE_BUTT
+} HI_UNF_COLOR_SPACE_E;
+
+/**Defines the RGB range.*/
+/**CNcomment: RGB */
+typedef enum hiUNF_RGB_RANGE_E
+{
+    HI_UNF_RGB_DEFAULT,
+    HI_UNF_RGB_LIMIT_RANGE,
+    HI_UNF_RGB_FULL_RANGE,
+    HI_UNF_RGB_RANGE_BUTT
+} HI_UNF_RGB_RANGE_E;
+/**Defines the video norm.*/
+/**CNcomment: */
+typedef enum hiUNF_ENC_FMT_E
+{
+    HI_UNF_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/
+    HI_UNF_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/
+    HI_UNF_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/
+    HI_UNF_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/
+    HI_UNF_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/
+
+    HI_UNF_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/
+    HI_UNF_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/
+
+    HI_UNF_ENC_FMT_720P_60,          /**<720p 60 Hz*/
+    HI_UNF_ENC_FMT_720P_50,          /**<720p 50 Hz */
+
+    HI_UNF_ENC_FMT_576P_50,          /**<576p 50 Hz*/
+    HI_UNF_ENC_FMT_480P_60,          /**<480p 60 Hz*/
+
+    HI_UNF_ENC_FMT_PAL,              /* B D G H I PAL */
+    HI_UNF_ENC_FMT_PAL_N,            /* (N)PAL        */
+    HI_UNF_ENC_FMT_PAL_Nc,           /* (Nc)PAL       */
+
+    HI_UNF_ENC_FMT_NTSC,             /* (M)NTSC       */
+    HI_UNF_ENC_FMT_NTSC_J,           /* NTSC-J        */
+    HI_UNF_ENC_FMT_NTSC_PAL_M,       /* (M)PAL        */
+
+    HI_UNF_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/
+    HI_UNF_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/
+
+    HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_50_FRAME_PACKING,
+
+    HI_UNF_ENC_FMT_861D_640X480_60,
+    HI_UNF_ENC_FMT_VESA_800X600_60,
+    HI_UNF_ENC_FMT_VESA_1024X768_60,
+    HI_UNF_ENC_FMT_VESA_1280X720_60,
+    HI_UNF_ENC_FMT_VESA_1280X800_60,
+    HI_UNF_ENC_FMT_VESA_1280X1024_60,
+    HI_UNF_ENC_FMT_VESA_1360X768_60,
+    HI_UNF_ENC_FMT_VESA_1366X768_60,
+    HI_UNF_ENC_FMT_VESA_1400X1050_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X1200_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60_RB,
+    HI_UNF_ENC_FMT_VESA_1920X1080_60,
+    HI_UNF_ENC_FMT_VESA_1920X1200_60,
+    HI_UNF_ENC_FMT_VESA_1920X1440_60,
+    HI_UNF_ENC_FMT_VESA_2048X1152_60,
+    HI_UNF_ENC_FMT_VESA_2560X1440_60_RB,
+    HI_UNF_ENC_FMT_VESA_2560X1600_60_RB,
+
+    HI_UNF_ENC_FMT_3840X2160_24 = 0x40,
+    HI_UNF_ENC_FMT_3840X2160_25,
+    HI_UNF_ENC_FMT_3840X2160_30,
+    HI_UNF_ENC_FMT_3840X2160_50,
+    HI_UNF_ENC_FMT_3840X2160_60,
+
+    HI_UNF_ENC_FMT_4096X2160_24,
+    HI_UNF_ENC_FMT_4096X2160_25,
+    HI_UNF_ENC_FMT_4096X2160_30,
+    HI_UNF_ENC_FMT_4096X2160_50,
+    HI_UNF_ENC_FMT_4096X2160_60,
+
+    HI_UNF_ENC_FMT_3840X2160_23_976,
+    HI_UNF_ENC_FMT_3840X2160_29_97,
+    HI_UNF_ENC_FMT_720P_59_94,
+    HI_UNF_ENC_FMT_1080P_59_94,
+    HI_UNF_ENC_FMT_1080P_29_97,
+    HI_UNF_ENC_FMT_1080P_23_976,
+    HI_UNF_ENC_FMT_1080i_59_94,
+    HI_UNF_ENC_FMT_BUTT
+}HI_UNF_ENC_FMT_E;
+
+/**Defines the mode of the video decoder.*/
+/**CNcomment: */
+typedef enum hiUNF_VCODEC_MODE_E
+{
+    HI_UNF_VCODEC_MODE_NORMAL = 0,   /**<Decode all frames.*/ /**<CNcomment: */
+    HI_UNF_VCODEC_MODE_IP,           /**<Decode only I frames and P frames.*/ /**<CNcomment: IP*/
+    HI_UNF_VCODEC_MODE_I,            /**<Decode only I frames.*/ /**<CNcomment: I*/
+    HI_UNF_VCODEC_MODE_DROP_INVALID_B,  /**<Decode all frames except the first B frame sequence behind I frames */ /**<CNcomment: IB*/
+    HI_UNF_VCODEC_MODE_BUTT
+} HI_UNF_VCODEC_MODE_E;
+
+/**Defines special control operation of decoder*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VCODEC_CTRL_OPTION_E
+{
+    HI_UNF_VCODEC_CTRL_OPTION_NORMAL_DPB = 0x0,
+    HI_UNF_VCODEC_CTRL_OPTION_SIMPLE_DPB = 0x1
+} HI_UNF_VCODEC_CTRL_OPTION_E;
+
+/**Defines the decoding capability (resolution) of the decoder.*/
+/**CNcomment: () */
+typedef enum hiUNF_VCODEC_CAP_LEVEL_E
+{
+    HI_UNF_VCODEC_CAP_LEVEL_NULL = 0, /**<Do not decode.*/ /**<CNcomment:  */
+    HI_UNF_VCODEC_CAP_LEVEL_QCIF = 0, /**<The resolution of the picture to be decoded is less than or equal to 176x144.*/ /**<CNcomment: 176*144 */
+    HI_UNF_VCODEC_CAP_LEVEL_CIF,      /**<The resolution of the picture to be decoded less than or equal to 352x288.*/ /**<CNcomment: 352*288 */
+    HI_UNF_VCODEC_CAP_LEVEL_D1,       /**<The resolution of the picture to be decoded less than or equal to 720x576.*/ /**<CNcomment: 720*576 */
+    HI_UNF_VCODEC_CAP_LEVEL_720P,     /**<The resolution of the picture to be decoded is less than or equal to 1280x720.*/ /**<CNcomment: 1280*720 */
+    HI_UNF_VCODEC_CAP_LEVEL_FULLHD,   /**<The resolution of the picture to be decoded is less than or equal to 1920x1080.*/ /**<CNcomment: 1920*1080 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_1280x800, /**<The resolution of the picture to be decoded is less than or equal to 1280x800.*/ /**<CNcomment: 1280x800*/
+    HI_UNF_VCODEC_CAP_LEVEL_800x1280, /**<The resolution of the picture to be decoded is less than or equal to 800x1280.*/ /**<CNcomment: 800x1280*/
+    HI_UNF_VCODEC_CAP_LEVEL_1488x1280, /**<The resolution of the picture to be decoded is less than or equal to 1488x1280.*/ /**<CNcomment: 1488x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x1488, /**<The resolution of the picture to be decoded is less than or equal to 1280x1488.*/ /**<CNcomment: 1280x1488 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x1280, /**<The resolution of the picture to be decoded is less than or equal to 2160x1280.*/ /**<CNcomment: 2160x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x2160, /**<The resolution of the picture to be decoded is less than or equal to 1280x2160.*/ /**<CNcomment: 1280x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x2160, /**<The resolution of the picture to be decoded is less than or equal to 2160x2160.*/ /**<CNcomment: 2160x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x2160, /**<The resolution of the picture to be decoded is less than or equal to 4096x2160.*/ /**<CNcomment: 4096x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x4096, /**<The resolution of the picture to be decoded is less than or equal to 2160x4096.*/ /**<CNcomment: 2160x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x4096, /**<The resolution of the picture to be decoded is less than or equal to 4096x4096.*/ /**<CNcomment: 4096x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x4096, /**<The resolution of the picture to be decoded is less than or equal to 8192x4096.*/ /**<CNcomment: 8192x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x8192, /**<The resolution of the picture to be decoded is less than or equal to 4096x8192.*/ /**<CNcomment: 4096x8192 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x8192, /**<The resolution of the picture to be decoded is less than or equal to 8192x8192.*/ /**<CNcomment: 8192x8192 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_BUTT
+} HI_UNF_VCODEC_CAP_LEVEL_E;
+
+/**Defines the stream type supported by the decoder.*/
+/**CNcomment:  */
+typedef enum hiUNF_VCODEC_TYPE_E
+{
+    HI_UNF_VCODEC_TYPE_MPEG2,
+    HI_UNF_VCODEC_TYPE_MPEG4,       /**<MPEG4 DIVX4 DIVX5 */
+    HI_UNF_VCODEC_TYPE_AVS,
+    HI_UNF_VCODEC_TYPE_H263,
+    HI_UNF_VCODEC_TYPE_H264,
+    HI_UNF_VCODEC_TYPE_REAL8,
+    HI_UNF_VCODEC_TYPE_REAL9,
+    HI_UNF_VCODEC_TYPE_VC1,
+    HI_UNF_VCODEC_TYPE_VP6,
+    HI_UNF_VCODEC_TYPE_VP6F,
+    HI_UNF_VCODEC_TYPE_VP6A,
+    HI_UNF_VCODEC_TYPE_MJPEG,
+    HI_UNF_VCODEC_TYPE_SORENSON,    /**<SORENSON SPARK */
+    HI_UNF_VCODEC_TYPE_DIVX3,
+    HI_UNF_VCODEC_TYPE_RAW,
+    HI_UNF_VCODEC_TYPE_JPEG,        /**<Used only for VENC */
+    HI_UNF_VCODEC_TYPE_VP8,
+    HI_UNF_VCODEC_TYPE_MSMPEG4V1,   /**<MS private MPEG4 */
+    HI_UNF_VCODEC_TYPE_MSMPEG4V2,
+    HI_UNF_VCODEC_TYPE_MSVIDEO1,    /**<MS video */
+    HI_UNF_VCODEC_TYPE_WMV1,
+    HI_UNF_VCODEC_TYPE_WMV2,
+    HI_UNF_VCODEC_TYPE_RV10,
+    HI_UNF_VCODEC_TYPE_RV20,
+    HI_UNF_VCODEC_TYPE_SVQ1,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_SVQ3,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_H261,
+    HI_UNF_VCODEC_TYPE_VP3,
+    HI_UNF_VCODEC_TYPE_VP5,
+    HI_UNF_VCODEC_TYPE_CINEPAK,
+    HI_UNF_VCODEC_TYPE_INDEO2,
+    HI_UNF_VCODEC_TYPE_INDEO3,
+    HI_UNF_VCODEC_TYPE_INDEO4,
+    HI_UNF_VCODEC_TYPE_INDEO5,
+    HI_UNF_VCODEC_TYPE_MJPEGB,
+    HI_UNF_VCODEC_TYPE_MVC,
+    HI_UNF_VCODEC_TYPE_HEVC,
+    HI_UNF_VCODEC_TYPE_DV,
+    HI_UNF_VCODEC_TYPE_VP9,
+    HI_UNF_VCODEC_TYPE_AVS2,
+    HI_UNF_VCODEC_TYPE_BUTT
+}HI_UNF_VCODEC_TYPE_E;
+
+/**Defines the H264 profile of the video encoder.*/
+/**CNcomment:  H264*/
+typedef enum hiUNF_H264_PROFILE_E
+{
+    HI_UNF_H264_PROFILE_BASELINE = 0,   /**<Encode H264 stream by baseline profile.*/ /**<CNcomment: H264*/
+    HI_UNF_H264_PROFILE_MAIN,           /**<Encode H264 stream by main profile.*/     /**<CNcomment:H264*/
+    HI_UNF_H264_PROFILE_EXTENDED,       /**<Encode H264 stream by extended profile.*/ /**<CNcomment:H264*/
+    HI_UNF_H264_PROFILE_HIGH,           /**<Encode H264 stream by high profile.*/     /**<CNcomment: H264*/
+    HI_UNF_H264_PROFILE_BUTT
+}HI_UNF_H264_PROFILE_E;
+
+typedef enum hiUNF_VIDEO_HDR_TYPE_E
+{
+    HI_UNF_VIDEO_HDR_TYPE_HDR10 = 0,
+    HI_UNF_VIDEO_HDR_TYPE_HLG,
+    HI_UNF_VIDEO_HDR_TYPE_BUTT
+}HI_UNF_VIDEO_HDR_TYPE_E;
+
+typedef struct hiUNF_VCODEC_VC1_ATTR_S
+{
+    HI_BOOL  bAdvancedProfile;   /**<Whether the profile is an advanced profile*/ /**<CNcomment: Advanced Profile*/
+    HI_U32   u32CodecVersion;    /**<Version number*/ /**<CNcomment: */
+}HI_UNF_VCODEC_VC1_ATTR_S;
+
+typedef struct hiUNF_VCODEC_VP6_ATTR_S
+{
+    HI_BOOL  bReversed;     /**<To reverse a picture, set this parameter to 1. In this cases, set it to 0.*/ /**<CNcomment: 10*/
+    HI_U16   u16DispWidth;  /**<Display Width.*/ /**<CNcomment: */
+    HI_U16   u16DispHeight; /**<Display Height.*/ /**<CNcomment: */
+}HI_UNF_VCODEC_VP6_ATTR_S;
+
+typedef union hiUNF_VCODEC_EXTATTR_U
+{
+    HI_UNF_VCODEC_VC1_ATTR_S stVC1Attr;
+    HI_UNF_VCODEC_VP6_ATTR_S stVP6Attr;
+}HI_UNF_VCODEC_EXTATTR_U;
+
+/**Defines the attributes of a video decoder.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enType;          /**<Video encoding type*/ /**<CNcomment: */
+    HI_UNF_VCODEC_EXTATTR_U     unExtAttr;       /**<Extra attributes related to the video encoding type*/ /**<CNcomment: */
+    HI_UNF_VCODEC_MODE_E        enMode;          /**<Mode of a video decoder*/ /**<CNcomment: */
+    HI_U32                      u32ErrCover;     /**<Error concealment threshold of the output frames of a video decoder. The value 0 indicates that no frames are output if an error occurs; the value 100 indicates that all frames are output no matter whether errors occur.*/
+                                                 /**<CNcomment: 0:100:*/
+    HI_U32                      u32Priority;     /**<Priority of a video decoder. The value range is [1, HI_UNF_VCODEC_MAX_PRIORITY]. The value 0 is a reserved value. If you set the value to 0, no error message is displayed, but the value 1 is used automatically. The smaller the value, the lower the priority.*/
+                                                 /**<CNcomment: , : 1HI_UNF_VCODEC_MAX_PRIORITY, 001, */
+    HI_BOOL                     bOrderOutput;    /**<Whether the videos are output by the decoding sequence. You are advised to set this parameter to HI_TRUE in VP mode, and HI_FALSE in other modes.*/
+                                                 /**<CNcomment: VPHI_TRUE, HI_FALSE */
+    HI_S32                      s32CtrlOptions;  /**<The value is HI_UNF_VCODEC_CTRL_OPTION_E, or the 'or' value of several enum type*/
+                                                 /**<CNcomment: HI_UNF_VCODEC_CTRL_OPTION_E''  */
+    HI_VOID*                    pCodecContext;   /**<Private codec context */
+}HI_UNF_VCODEC_ATTR_S;
+
+/**Defines the hdr attributes of a video decoder.*/
+/**CNcomment: HDR*/
+typedef struct hiUNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S
+{
+    HI_U16 u16DisplayPrimaries_x[3];
+    HI_U16 u16DisplayPrimaries_y[3];
+    HI_U16 u16WhitePoint_x;
+    HI_U16 u16WhitePoint_y;
+    HI_U32 u32MaxDisplayMasteringLuminance;
+    HI_U32 u32MinDisplayMasteringLuminance;
+} HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S;
+
+typedef struct hiUNF_VIDEO_CONTENT_LIGHT_LEVEL_S
+{
+    HI_U32 u32MaxContentLightLevel;
+    HI_U32 u32MaxPicAverageLightLevel;
+} HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S;
+
+typedef struct hiUNF_VIDEO_HDR10__S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering,0:1:*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content,0:1:*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+} HI_UNF_VIDEO_HDR10_INFO_S;
+
+typedef struct hiUNF_VIDEO_HLG_INFO_S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering,0:1:*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content,0:1:*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+    HI_U8  u8BackWardsCompatible;
+} HI_UNF_VIDEO_HLG_INFO_S;
+
+typedef union hiUNF_VIDEO_HDR_METADATA_U
+{
+    HI_UNF_VIDEO_HDR10_INFO_S stHdr10Info;
+    HI_UNF_VIDEO_HLG_INFO_S   stHlgInfo;
+}HI_UNF_VIDEO_HDR_METADATA_U;
+
+typedef struct hiUNF_VIDEO_HDR_INFO_S
+{
+    HI_UNF_VIDEO_HDR_TYPE_E          enHdrType;
+    HI_UNF_VIDEO_HDR_METADATA_U      unHdrMetadata;
+} HI_UNF_VIDEO_HDR_INFO_S;
+
+/**Defines the sub stream protocol.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_SUB_STANDARD_E
+{
+    HI_UNF_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2MPEG1 */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4SHV*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4XVID*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4DIVX*/
+
+    HI_UNF_VIDEO_SUB_STANDARD_BUTT
+}HI_UNF_VIDEO_SUB_STANDARD_E;
+
+/**Defines the frame rate of the video stream.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_FRMRATE_S
+{
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+                              /**<CNcomment: 3, fps */
+}HI_UNF_VCODEC_FRMRATE_S;
+
+/**Defines the information about video streams.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_STREAMINFO_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Stream type*/ /**<CNcomment:  */
+    HI_UNF_VIDEO_SUB_STANDARD_E enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                      u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                      u32Profile;     /**<Stream profile*/ /**<CNcomment: profile */
+    HI_U32                      u32Level;       /**<Stream level*/ /**<CNcomment: level */
+    HI_UNF_ENC_FMT_E            enDisplayNorm;  /**<Display norm (PAL or NTSC)*/ /**<CNcomment: (P/N) */
+    HI_BOOL                     bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_U32                      u32AspectWidth; /**<Output aspect ratio: width*/ /**<CNcomment:  */
+    HI_U32                      u32AspectHeight;/**<Output aspect ratio: height*/ /**<CNcomment:  */
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: , Kbps */
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 3, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+}HI_UNF_VCODEC_STREAMINFO_S;
+
+
+/**Defines the types of the user data in the video information.*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VIDEO_USERDATA_TYPE_E
+{
+    HI_UNF_VIDEO_USERDATA_UNKNOWN = 0,      /**<Unknown type*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_DVB1_CC = 0x1,    /**<Closed Caption Data*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_DVB1_BAR = 0x2,   /**<Bar Data*/ /**<CNcomment: Bar*/
+    HI_UNF_VIDEO_USERDATA_AFD = 0x10000,    /**<Active Format Description*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_BUTT
+}HI_UNF_VIDEO_USERDATA_TYPE_E;
+
+/**Defines the profile of video broadcasting.*/
+/**CNcomment: profile*/
+typedef enum hiUNF_VIDEO_BROADCAST_PROFILE_E
+{
+    HI_UNF_VIDEO_BROADCAST_DVB,        /**<Digital video broadcasting (DVB)*/ /**<CNcomment: DVB*/
+    HI_UNF_VIDEO_BROADCAST_DIRECTV,    /**<American live broadcast operator DirecTV*/ /**<CNcomment: DirecTV*/
+    HI_UNF_VIDEO_BROADCAST_ATSC,       /**<Advanced Television Systems Committee (ATSC)*/ /**<CNcomment: ATSCAdvanced Television Systems Committee*/
+    HI_UNF_VIDEO_BROADCAST_DVD,        /**<Digital video disc (DVD)*/ /**<CNcomment: */
+    HI_UNF_VIDEO_BROADCAST_ARIB,       /**<Association of Radio Industries and Businesses (ARIB)*/ /**<CNcomment: */
+    HI_UNF_VIDEO_BROADCAST_BUTT
+}HI_UNF_VIDEO_BROADCAST_PROFILE_E;
+
+/**Defines the position of the user data in the video information.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_USER_DATA_POSITION_E
+{
+    HI_UNF_VIDEO_USER_DATA_POSITION_UNKNOWN,       /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_SEQ,     /**<The data is parsed from sequences under the MPEG2 protocol.*/ /**<CNcomment: MPEG2*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_GOP,     /**<The data is parsed from the group of pictures (GOP) under the MPEG2 protocol.*/ /**<CNcomment: MPEG2GOPGroup Of Pictures*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_FRAME,   /**<The data is parsed from picture frames under the MPEG2 protocol.*/ /**<CNcomment: MPEG2*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSOS,    /**<The data is parsed from the sequences of visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSO,     /**<The data is parsed from visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VOL,     /**<The data is parsed from the video object layer under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_GOP,     /**<The data is parsed from the GOP under the MPEG4 protocol.*/ /**<CNcomment: MPEG4GOP*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_REG,      /**<The data is parsed from the user_data_regestered_itu_t_t35() syntax under the H.264 protocol.*/ /**<CNcomment: H.264user_data_regestered_itu_t_t35()*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_UNREG,    /**<The data is parsed from the user_data_unregestered() syntax under the H.264 protocol.*/ /**<CNcomment: H.264user_data_unregestered()*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_BUTT
+}HI_UNF_VIDEO_USER_DATA_POSITION_E;
+
+/**Defines the structure of the user data in the video information.*/
+/**CNcomment: */
+typedef struct hiUNF_VIDEO_USERDATA_S
+{
+    HI_UNF_VIDEO_BROADCAST_PROFILE_E   enBroadcastProfile;   /**<Broadcasting profile of the user data*/ /**<CNcomment: profile*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_E  enPositionInStream;   /**<Position of the user data in video streams*/ /**<CNcomment: */
+    HI_U32                             u32Pts;               /**<PTS corresponding to the user data*/ /**<CNcomment: */
+    HI_U32                             u32SeqCnt;            /**<Sequence ID of the user data*/ /**<CNcomment: */
+    HI_U32                             u32SeqFrameCnt;       /**<Frame number of the user data*/ /**<CNcomment: */
+    HI_U8                              *pu8Buffer;           /**<Initial address of the user data memory, output parameter*/ /**<CNcomment: ,*/
+    HI_U32                             u32Length;            /**<User data size (a multiple of 1 byte)*/ /**<CNcomment: 1byte*/
+    HI_BOOL                            bBufferOverflow;      /**<Indicate that whether the user data size exceeds the maximum size defined by MAX_USER_DATA_LEN.*/ /**<CNcomment: MAX_USER_DATA_LEN*/
+    HI_BOOL                            bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: */
+}HI_UNF_VIDEO_USERDATA_S;
+
+/**Defines the parameters of format changing */
+/**CNcomment: */
+typedef struct hiUNF_NORMCHANGE_PARAM_S
+{
+    HI_UNF_ENC_FMT_E            enNewFormat;            /**<New format*/ /**<CNcomment: */
+    HI_U32                      u32ImageWidth;          /**<Width of image*/ /**<CNcomment: */
+    HI_U32                      u32ImageHeight;         /**<Height of image*/ /**<CNcomment: */
+    HI_BOOL                     bProgressive;           /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_U32                      u32FrameRate;           /**<Frame rate*//**<CNcomment:*/
+}HI_UNF_NORMCHANGE_PARAM_S;
+
+/**Defines the video format.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FORMAT_E
+{
+    /* Semi-Planner */
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422,       /**<The YUV spatial sampling format is 4:2:2.*/ /**<CNcomment: YUV4:2:2*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is 4:2:0, V first.*/ /**<CNcomment: YUV4:2:0V*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_400,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_411,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_444,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420_UV,   /**<The YUV spatial sampling format is 4:2:0,U first.*/ /**<CNcomment: YUV4:2:0, U*/
+
+
+    /* Package */
+    HI_UNF_FORMAT_YUV_PACKAGE_UYVY,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUVpackage,UYVY*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YUYV,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUVpackage,YUYV*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YVYU,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUVpackage,YVYU*/
+
+    /* Planner */
+    HI_UNF_FORMAT_YUV_PLANAR_400,
+    HI_UNF_FORMAT_YUV_PLANAR_411,
+    HI_UNF_FORMAT_YUV_PLANAR_420,
+    HI_UNF_FORMAT_YUV_PLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_PLANAR_422_2X1,
+    HI_UNF_FORMAT_YUV_PLANAR_444,
+    HI_UNF_FORMAT_YUV_PLANAR_410,
+    HI_UNF_FORMAT_YUV_TILE_420,	            /**<The YUV spatial sampling format is TILE 4:2:0, V first.*/
+    HI_UNF_FORMAT_YUV_TILE_420_UV,          /**<The YUV spatial sampling format is TILE 4:2:0, U first.*/
+    HI_UNF_FORMAT_YUV_BUTT,
+
+    HI_UNF_FORMAT_RGB_SEMIPLANAR_444,
+    HI_UNF_FORMAT_RGB_BUTT
+}HI_UNF_VIDEO_FORMAT_E;
+
+/**Defines the type of the video frame.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FRAME_TYPE_E
+{
+    HI_UNF_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I*/
+    HI_UNF_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P*/
+    HI_UNF_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B*/
+	HI_UNF_FRAME_TYPE_IDR,       /**<IDR frame*/ /**<CNcomment: IDR*/
+    HI_UNF_FRAME_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FIELD_MODE_E
+{
+    HI_UNF_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_BUTT
+}HI_UNF_VIDEO_FIELD_MODE_E;
+
+
+/**Defines 3D frame packing type*/
+typedef enum hiUNF_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_UNF_FRAME_PACKING_TYPE_NONE,             /**< Normal frame, not a 3D frame */
+    HI_UNF_FRAME_PACKING_TYPE_SIDE_BY_SIDE,     /**< Side by side */
+    HI_UNF_FRAME_PACKING_TYPE_TOP_AND_BOTTOM,   /**< Top and bottom */
+    HI_UNF_FRAME_PACKING_TYPE_TIME_INTERLACED,  /**< Time interlaced: one frame for left eye, the next frame for right eye */
+    HI_UNF_FRAME_PACKING_TYPE_FRAME_PACKING,    /**< frame packing */
+    HI_UNF_FRAME_PACKING_TYPE_3D_TILE,          /**< Tile 3D */
+    HI_UNF_FRAME_PACKING_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_PACKING_TYPE_E;
+
+typedef struct hiUNF_VIDEO_FRAME_ADDR_S
+{
+    HI_U32             u32YAddr;    /**<Address of the Y component in the current frame*/ /**<CNcomment: Y*/
+    HI_U32             u32CAddr;    /**<Address of the C component in the current frame*/ /**<CNcomment: C*/
+    HI_U32             u32CrAddr;   /**<Address of the Cr component in the current frame*/ /**<CNcomment: Cr*/
+
+    HI_U32             u32YStride;  /**<Stride of the Y component*/ /**<CNcomment: Y*/
+    HI_U32             u32CStride;  /**<Stride of the C component*/ /**<CNcomment: C*/
+    HI_U32             u32CrStride; /**<Stride of the Cr component*/ /**<CNcomment: Cr*/
+}HI_UNF_VIDEO_FRAME_ADDR_S;
+
+typedef struct hiUNF_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32FrameIndex;      /**<Frame index ID of a video sequence*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FRAME_ADDR_S           stVideoFrameAddr[2];
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32SrcPts;          /**<Original PTS of a video frame*/ /**<CNcomment: */
+    HI_U32                              u32Pts;             /**<PTS of a video frame*/ /**<CNcomment: */
+    HI_U32                              u32AspectWidth;
+    HI_U32                              u32AspectHeight;
+    HI_UNF_VCODEC_FRMRATE_S             stFrameRate;
+
+    HI_UNF_VIDEO_FORMAT_E               enVideoFormat;      /**<Video YUV format*/ /**<CNcomment: YUV*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_UNF_VIDEO_FIELD_MODE_E           enFieldMode;        /**<Frame or field encoding mode*/ /**<CNcomment: */
+    HI_BOOL                             bTopFieldFirst;     /**<Top field first flag*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+    HI_U32                              u32Circumrotate;    /**<Need circumrotate, 1 need */
+    HI_BOOL                             bVerticalMirror;
+    HI_BOOL                             bHorizontalMirror;
+    HI_U32                              u32DisplayWidth;    /**<Width of the displayed picture*/ /**<CNcomment: */
+    HI_U32                              u32DisplayHeight;   /**<Height of the displayed picture*/ /**<CNcomment: */
+    HI_U32                              u32DisplayCenterX;  /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: x*/
+    HI_U32                              u32DisplayCenterY;  /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: y*/
+    HI_U32                              u32ErrorLevel;      /**<Error percentage of a decoded picture, ranging from 0% to 100%*/ /**<CNcomment: 0100*/
+    HI_U32                              u32Private[64];     /**<Private data for every frame: 
+                                                                u32Private[0]: securty flag, if u32Private[0] == 1, this is a secure frame;
+                                                                */
+    
+    
+}HI_UNF_VIDEO_FRAME_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_STATUS_INFO_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E enVidFrmType; /**<Type of video frame*/ /**<CNcomment: */ 
+    HI_U32 u32VidFrmStreamSize;             /**<Size of video frame*/ /**<CNcomment: */ 
+    HI_U32 u32VidFrmQP;                     /**<QP of video frame*/ /**<CNcomment: QP*/ 
+    HI_U32 u32VidFrmPTS;                    /**<PTS of video frame*/ /**<CNcomment: pts*/
+    HI_U32 u32MaxMV;                        /**<MAX MV*/ /**<CNcomment: MV*/
+    HI_U32 u32MinMV;                        /**<MIN MV*/ /**<CNcomment: MV*/
+    HI_U32 u32AvgMV;                        /**<AVG MV*/ /**<CNcomment: MV*/
+    HI_U32 u32SkipRatio;                    /**<MB ratio */ /**<CNcomment: MB0~100*/
+}HI_UNF_VIDEO_FRM_STATUS_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_DISPLAY_TIME_S
+{
+    HI_S64 s64PTS;                          /**<PTS of video frame*/ /**<CNcomment: PTS*/
+    HI_S64 s64DisplayTime;                  /**<Estimated time of display */ /**<CNcomment: */
+} HI_UNF_VIDEO_FRM_DISPLAY_TIME_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_VIDEO_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_vo.h unlib/xbmc/linux/hisi/hi_unf_vo.h
--- git/xbmc/linux/hisi/hi_unf_vo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_vo.h	2018-07-18 17:35:28.528490000 +0800
@@ -0,0 +1,823 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vo.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/16
+  Description   :
+  History       :
+  1.Date        : 2009/12/16
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief  supply info of vo module.
+ */
+
+#ifndef  __HI_UNF_VO_H__
+#define  __HI_UNF_VO_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+
+
+/**defines the ROTATION type.*/
+/**CNcomment:*/
+typedef enum hiUNF_VO_ROTATION_E
+{
+    HI_UNF_VO_ROTATION_0, /**< 0 degree rotation*//**<CNcomment: 0*/
+    HI_UNF_VO_ROTATION_90, /**< 90 degree rotation*//**<CNcomment: 90*/
+    HI_UNF_VO_ROTATION_180, /**< 180 degree rotation*//**<CNcomment: 180*/
+    HI_UNF_VO_ROTATION_270, /**< 270 degree rotation*//**<CNcomment: 270*/
+    HI_UNF_VO_ROTATION_BUTT
+}HI_UNF_VO_ROTATION_E;
+
+
+/**conversion mode of AspectRatio.*/
+/**CNcomment:*/
+typedef enum hiUNF_VO_ASPECT_CVRS_E
+{
+    HI_UNF_VO_ASPECT_CVRS_IGNORE = 0x0,
+    HI_UNF_VO_ASPECT_CVRS_LETTERBOX,      /**<Add black borders*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_PAN_SCAN,      /**<Clip the picture*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_COMBINED,       /**<Add black borders and clip the picture*//**<CNcomment: */
+
+    HI_UNF_VO_ASPECT_CVRS_HORIZONTAL_FULL,  /**<keep picture's HORIZONTAL be full*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_VERTICAL_FULL,    /**<keep picture's VERTICAL be full*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_BUTT,
+} HI_UNF_VO_ASPECT_CVRS_E;
+
+/** AspectRatio attribute.*/
+/**CNcomment:*/
+typedef struct hiUNF_WINDOW_ASPECT_ATTR_S
+{
+    HI_UNF_VO_ASPECT_CVRS_E   enAspectCvrs;  /**<the method to the aspect ratio transfer.\n*//**<CNcomment:  */
+    HI_BOOL                   bUserDefAspectRatio;  /**<use or not user define aspectratio. \n
+                                                     if this is true, u32UserAspectWidth and u32UserAspectHeight will be effective.\n*/
+                                                    /**<CNcomment: , TRUEu32UserAspectWidthu32UserAspectHeight*/
+    HI_U32                    u32UserAspectWidth; /**<aspect width of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                  /**<CNcomment:  \n
+                                                   0~3840 \n
+                                                   0*/
+    HI_U32                    u32UserAspectHeight; /**<aspect height of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                    /**<CNcomment:  \n
+                                                    0~3840 \n
+                                                    0*/
+} HI_UNF_WINDOW_ASPECT_ATTR_S;
+
+/**define the attribution of window.*/
+/**CNcomment:WINDOW*/
+typedef struct hiUNF_WINDOW_ATTR_S
+{
+    HI_UNF_DISP_E             enDisp;          /**<the display channel where window locate in. can not be modified.\n*//**<CNcomment: ,  */
+    HI_BOOL                   bVirtual;      /**< whether is virtual window or not. can not be modified.\n*//**<CNcomment:  */
+    HI_UNF_VIDEO_FORMAT_E     enVideoFormat; /**<the data format of virtual window.\n*//**<CNcomment:  */
+    HI_UNF_WINDOW_ASPECT_ATTR_S     stWinAspectAttr;  /**<the AspectRatio of window.\n*//**<CNcomment:  */
+    HI_BOOL                   bUseCropRect;     /**<cut video frame as stCropRect struct or as stInputRect struct \n
+                                                    if this is TRUE, stCropRect will be effective \n
+                                                    if this is false, stInputRect will be effective.*/
+                                                   /**<CNcomment: stCropRect \n
+                                                    TRUEstCropRect \n
+                                                    FALSEstInputRect*/
+
+    HI_UNF_CROP_RECT_S        stCropRect;   /**<clip window of user define ,clip pix num of top,buttom,left,right.\n*/
+                                            /**<CNcomment: , */
+
+    HI_RECT_S                 stInputRect;       /**<the crop area .\n
+                                                  all values are zero indicate outputing whole video stream \n
+                                                  if the value is bigger than video frame, the whole video frame will be displayed \n
+                                                  width and height should not be less than 64.\n*/
+                                                 /**<CNcomment:   \n
+                                                  0 \n
+                                                  , \n
+                                                  6464*64*/
+
+    HI_RECT_S                 stOutputRect;  /**<the window display area on the virtual screen. \n
+                                                The width and height of display area should not larger than virtual screen,\n
+                                                and all parameters are zero means to fill whole virtual screen.\n
+                                                The area could move out of virtual screen, and the outside part will not display.\n*/
+                                                /**<CNcomment: \n
+                                                0\n
+                                                */
+
+
+
+} HI_UNF_WINDOW_ATTR_S;
+
+
+/**define user buffer management attribute.*/
+/**CNcomment:*/
+typedef struct hiUNF_BUFFER_ATTR_S
+{
+    HI_S32              s32Stride;          /**<the stride of the buffer.*//**<CNcomment: */
+    HI_U32              u32PhyAddr[16];     /**<start physics addrss of the buffer.*//**<CNcomment: */
+    HI_U32              u32BuffIndex[16];   /**<Stride of the buffer.*//**<CNcomment: */
+    HI_S32              s32BuffNum;         /**<the number of the buffer.*//**<CNcomment: */
+} HI_UNF_BUFFER_ATTR_S;
+
+/** the running mode of vo*/
+/**CNcomment:VO */
+typedef enum hiUNF_VO_DEV_MODE_E
+{
+    HI_UNF_VO_DEV_MODE_NORMAL,  /**<normal mode:
+                                  3716 V100/V200 :no more than 2 windows to be created.
+                                  3716 v300:no more than 3 windows to be created.
+                                  3712 v300:no more than 1 windows to be created.*/
+                                  /**<CNcomment: 
+                                   3716 V100/V200:2WINDOW
+                                   3716 v300: 3WINDOW
+                                   3712 v300: 1WINDOW*/
+    HI_UNF_VO_DEV_MODE_MOSAIC,  /**<mosaic mode: can create more than 2 windows.
+                                 3712 v300: not support*/
+                                /**<CNcomment: WINDOW
+                                 3712 v300: */
+    HI_UNF_VO_DEV_MODE_STANDALONE,  /**<seperate mode,only 1 window can be created,and  the aspect ratio set seperately.
+                                        3716 v300: not support*/
+                                    /**<CNcomment: standalone
+                                     3716 v300 : */
+    HI_UNF_VO_DEV_MODE_BUTT
+} HI_UNF_VO_DEV_MODE_E;
+
+/**define the freeze mode enumeration.*/
+/**CNcomment:Freeze*/
+typedef enum hiUNF_WINDOW_FREEZE_MODE_E
+{
+    HI_UNF_WINDOW_FREEZE_MODE_LAST = 0,   /**<display the last frame when freeze.*//**<CNcomment: freeze*/
+    HI_UNF_WINDOW_FREEZE_MODE_BLACK = 1,  /**<display a black frame when freeze.*//**<CNcomment: freeze*/
+    HI_UNF_WINDOW_FREEZE_MODE_BUTT
+} HI_UNF_WINDOW_FREEZE_MODE_E;
+
+/**<Frosted glass effect level*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_WINDOW_FROST_E
+{
+    HI_UNF_WINDOW_FROST_CLOSE = 0x0 ,       /**<Close  */ /**<CNcomment: CNend*/
+    HI_UNF_WINDOW_FROST_LOW         ,       /**<Low    */ /**<CNcomment:   CNend*/
+    HI_UNF_WINDOW_FROST_MIDDLE      ,       /**<Middle */ /**<CNcomment:   CNend*/
+    HI_UNF_WINDOW_FROST_HIGH        ,       /**<High   */ /**<CNcomment:   CNend*/
+
+    HI_UNF_WINDOW_FROST_BUTT
+}HI_UNF_WINDOW_FROST_E;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+/**
+\brief  init vo module.CNcomment:VO CNend
+\attention \n
+Before call this func, you should confirm that HI_UNF_DISP_Init and HI_UNF_DISP_Open have been called yet.
+call this func before any other vo funcs .
+CNcomment:DISPLAYVO CNend
+\param[in]   enDevMode  the vo running mode.  CNcomment:VO CNend
+\retval ::HI_SUCCESS successs.CNcomment: CNend
+\retval ::HI_ERR_VO_DEV_NOT_EXIST  vo device not exist. CNcomment:VO CNend
+\retval ::HI_ERR_VO_NOT_DEV_FILE   not vo device. CNcomment:VO CNend
+\retval ::HI_ERR_VO_DEV_OPEN_ERR   open vo failed. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal param. CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+/**
+\brief  deinit vo module.CNcomment:VO CNend
+\attention \n
+before calling this func ,you should call HI_UNF_VO_Close to close all the windows first.
+CNcomment:::HI_UNF_VO_CloseVO CNend
+\param CNcomment: CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_DEV_CLOSE_ERR  vo deinited failed. CNcomment:VO CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DeInit(HI_VOID);
+
+/**
+\brief create the window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO CNend
+\param[in] phWindow   the window handler to be created.CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S *pWinAttr, HI_HANDLE *phWindow);
+
+/**
+\brief create the window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO CNend
+\param[in] phWindow   the window handler to be created.CNcomment:WINDOW CNend
+\param[in] bVirtScreen   flag indicates whether creating with virtscreen coordinate.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindowExt(const HI_UNF_WINDOW_ATTR_S* pWinAttr,
+                                  HI_HANDLE *phWindow,
+                                  HI_BOOL bVirtScreen);
+
+/**
+\brief  destroy the given window.CNcomment:WINDOW CNend
+\attention \n
+user should disable window before call this func
+CNcomment:disable  CNend
+\param[in] hWindow    the input window handler. CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow);
+
+
+/**
+\brief to enable or disable the given window.CNcomment:/WINDOW CNend
+\attention \n
+Window can only be disabled after the corresponding avplay is stopped, else data will overflow.
+CNcomment:AVPLAYVIDstopwindow CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable     the flag  of enable or disable window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief get the status of the given window: enable or not.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pbEnable    the status of window:enable or disable.CNcomment:/. CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowEnable(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+/**
+\brief set the attribution of the given window.CNcomment:WINDOW CNend
+\attention \n
+the two members of pWinAttr:enDisp and bVirtual are fixed when window created, and they can't be modified here.
+Each value as HI_UNF_WINDOW_ATTR_S Definition
+CNcomment:enDispbVirtualHI_UNF_WINDOW_ATTR_S CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW CNend
+\param[in] pWinAttr   the pointer of windows attr.CNcomment:WINDO CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowAttr(HI_HANDLE hWindow, const HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the attribution of the given window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pWinAttr    the pointer of windows attr. CNcomment:WINDO CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowAttr(HI_HANDLE hWindow, HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the frame from given window.CNcomment:WINDOWFrame CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[out] pstFrameinfo  frame information. CNcomment:Frame CNend
+\param[in] u32TimeoutMs wait time in ms.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited.CNcomment: VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AcquireFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief return the frame back to the given window, used for 3d graphics testing.CNcomment:WINDOWFrame3D CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_ReleaseFrame(HI_HANDLE hWindow,HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief set the zorder of the given window.CNcomment:WINDOWZ CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW CNend
+\param[in] enZFlag    how to adjust zorder. CNcomment:Z CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowZorder(HI_HANDLE hWindow, HI_LAYER_ZORDER_E enZFlag);
+
+/**
+\brief get the zorder of the given window.CNcomment:WINDOWZ CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow       the input window handler.CNcomment:WINDOW CNend
+\param[in] pu32Zorder    value of zoder, bigger value means higher prioty. CNcomment:Z CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowZorder(HI_HANDLE hWindow, HI_U32 *pu32Zorder);
+
+/**
+\brief attach the window with video source such as vi/avplay.CNcomment:WINDOWAVPLAY/VI CNend
+\attention \n
+it can attach the handler of avplay or vi to the window.
+CNcomment:AVPLAYVIWINDOW CNend
+\param[in] hWindow     the input window handler. CNcomment:WINDOW CNend
+\param[in] hSrc        the handler of video source. CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params. CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+
+/**
+\brief detach the window from the video source such as avplay or vi.CNcomment:WINDOWAVPLAY/VI CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] hSrc        the handler of video source.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+/**
+\brief Set frost glass effect level at one window .CNcomment: CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow         the input window handler.CNcomment:WINDOW CNend
+\param[in] enWinFrostMode  Frost glass level.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E enWinFrostMode);
+
+/**
+\brief Get frost glass effect level at one window .CNcomment: CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] *penWinFrostMode  Frost glass level.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E* penWinFrostMode);
+
+/**
+\brief  to freeze the video content of given window.CNcomment:WINDOW CNend
+\attention \n
+the display will be freezed after calling this func, but backgrounddly,the data flow is normal from video decoder.
+so when freezing is cacelled, the newest video content can be display at once.
+CNcomment:WINDOW\n
+ CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable           shows whether to freeze window.CNcomment:/ CNend
+\param[in] enWinFreezeMode   the mode of freeze.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_FreezeWindow(HI_HANDLE hWindow, HI_BOOL bEnable, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief  to get the freeze status of the given window.CNcomment: CNend
+\attention \n
+\param[in] hWindow            the input window handler.CNcomment:WINDOW CNend
+\param[out] pbEnable           shows whether to freeze window.CNcomment:/ CNend
+\param[out] penWinFreezeMode   the mode of freeze.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFreezeStatus(HI_HANDLE hWindow, HI_BOOL *pbEnable, HI_UNF_WINDOW_FREEZE_MODE_E *penWinFreezeMode);
+
+
+/**
+\brief reset the window.CNcomment:WINDOW CNend
+\attention \n
+this function can reset buffers of the given window, and black frame or the last frame will be displayed according configuration.
+CNcomment:window CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] enWinFreezeMode   method of freeze the window.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_ResetWindow(HI_HANDLE hWindow, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief pass the external allocated buffer to this function to test 3d graphics.CNcomment:WINDOWbuffer3D CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pstBufAttr  external buffer.CNcomment:buffer CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AttachExternBuffer(HI_HANDLE hWindow,HI_UNF_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+\brief to set the work mode of window: quick output or not. Deinterlace alg will be disabled when quick output is enabled.
+CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] bQuickOutputEnable  whether determine the output mode of window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetQuickOutputEnable(HI_HANDLE hWindow, HI_BOOL bQuickOutputEnable);
+
+/**
+\brief to get the work mode of window: quick output or not.
+CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in]  hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[out] pbQuickOutputEnable  whether determine the output mode of window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetQuickOutputStatus(HI_HANDLE hWindow, HI_BOOL *pbQuickOutputEnable);
+
+/**
+\brief  to set the filed mode of given window.CNcomment: CNend
+\attention \n
+when fast-backward playing, there will be no abnormity through calling this func. But calling of this
+func is forbidden when normal playing. It should be called after HI_UNF_VO_AttachWindow.
+CNcomment:\n
+HI_UNF_VO_AttachWindow CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable           wether to enable field play.CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief  to get the filed mode of given window.CNcomment: CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[out] pbEnable         wether to enable field play.CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+
+/**
+\brief capture the current frame of given window.CNcomment:WINDOW CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment:  CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CapturePicture(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief if you capture picture is finished, release the memory.CNcomment: CNend
+\attention \n
+this function will release captured picture, so user should call this function
+after you used this captured picture.
+CNcomment: CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment:  CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CapturePictureRelease(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+/**
+\brief set window rotion type.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] enRotation    rotion type.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E enRotation);
+
+
+/**
+\brief get window rotion type.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] enRotation    rotion type.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E *penRotation);
+
+/**
+\brief flip window.CNcomment:window CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] bHoriFlip    horizon flip.CNcomment: CNend
+\param[in] bVertFlip    vertical flip.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetFlip(HI_HANDLE hWindow, HI_BOOL bHoriFlip, HI_BOOL bVertFlip);
+
+/**
+\brief get fliping tpye of window.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] bHoriFlip    horizon flip flag.CNcomment: CNend
+\param[in] bVertFlip    vertical flip flag.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetFlip(HI_HANDLE hWindow, HI_BOOL *pbHoriFlip, HI_BOOL *pbVertFlip);
+
+/**
+\brief set video stereo depth for 3D output.CNcomment:3D CNend
+\attention \n
+3716/3712: not support.Only take effect in 3D output mode.
+CNcomment: 3716/3712 .3D CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] s32Depth Depth of filed. the range is [-50,50].CNcomment:[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_SetStereoDetpth(HI_HANDLE hWindow, HI_S32 s32Depth);
+
+/**
+\brief get video stereo depth for 3D output.CNcomment: 3D CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[out] ps32Depth Depth of filed. the range is [-50,50].CNcomment:[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_GetStereoDetpth(HI_HANDLE hWindow, HI_S32 *ps32Depth);
+
+/**
+\brief Queue frame into the specified window.CNcomment:  CNend
+\attention \n
+\param[in] hWindow    window handle. CNcomment: CNend
+\param[in] pstFrameinfo  frame infor to be passed into. CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\retval ::HI_ERR_VO_BUFQUE_FULL   buffer is full .CNcomment:buffer  CNend
+\retval ::HI_ERR_VO_INVALID_OPT   invalid opt.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_QueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief dequeue frame from window.CNcomment: CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[out] pstFrameinfo  frame infor dequeued from window .CNcomment:. CNend
+\param[in] u32TimeoutMs  timeout when get frame failed .CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_DeQueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief set  window alpha.CNcomment: alphaCNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] u32Alpha  window alpha .CNcomment:alpha. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_SetWindowAlpha(HI_HANDLE hWindow, HI_U32 u32Alpha);
+/**
+\brief get  window alpha.CNcomment: alphaCNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] pu32Alpha  window alpha .CNcomment:alpha. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_GetWindowAlpha(HI_HANDLE hWindow, HI_U32 *pu32Alpha);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+/************************************** The End Of File **************************************/

diff -uNr git/configure.ac unlib/configure.ac
--- git/configure.ac	2018-03-30 11:39:25.387652148 +0800
+++ unlib/configure.ac	2018-04-11 16:55:21.911318400 +0800
@@ -753,7 +753,13 @@
      target_videoplatform=target_mali
      use_cpu=cortex-a15
      ;;
-
+  clap-cortexa15)
+     USE_MALI=1
+     USE_HIPLAYER=1
+     target_platform=target_clap
+     target_videoplatform=target_clap
+     use_cpu=cortex-a15
+     ;;
 esac
 
 if test "$target_platform" = "target_raspberry_pi" ; then
@@ -783,6 +789,13 @@
      CXXFLAGS="$CXXFLAGS"
 fi
 
+if test "$target_platform" = "target_clap" ; then
+     use_openmax=no
+     CORE_SYSTEM_NAME=linux
+     CFLAGS="$CFLAGS"
+     CXXFLAGS="$CXXFLAGS"
+fi
+
 if test "$host_vendor" = "apple"; then
   use_avahi=no
   use_alsa=no
@@ -1079,6 +1092,11 @@
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES mali support is assumed.)
       LIBS="$LIBS -lEGL -lGLESv2 -lmali"
+  elif test "${target_platform}" = "target_clap" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES mali support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -ljpeg -lhi_common -lhi_msp"
   else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
@@ -1184,7 +1202,7 @@
   )])
 AC_LANG_POP([C++])
 
-if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android" || test "${target_platform}" = "target_v3d" || test "${target_platform}" = "target_mali"; then
+if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android" || test "${target_platform}" = "target_v3d" || test "${target_platform}" = "target_mali"|| test "${target_platform}" = "target_clap"; then
   PKG_CHECK_MODULES([UUID], [uuid],, AC_MSG_ERROR(libuuid not found))
 fi
 
@@ -2480,6 +2498,7 @@
 AC_SUBST(USE_NEXTV)
 AC_SUBST(USE_GB)
 AC_SUBST(USE_MALI)
+AC_SUBST(USE_HIPLAYER)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff -uNr git/m4/xbmc_arch.m4 unlib/m4/xbmc_arch.m4
--- git/m4/xbmc_arch.m4	2018-03-30 11:39:25.451651892 +0800
+++ unlib/m4/xbmc_arch.m4	2018-04-11 10:18:58.873873030 +0800
@@ -115,4 +115,8 @@
 if test "$target_videoplatform" = "target_mali" ; then
   AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI")
 fi
+
+if test "$target_videoplatform" = "target_clap" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI -DUSE_HIPLAYER")
+fi
 ])
diff -uNr git/Makefile.in unlib/Makefile.in
--- git/Makefile.in	2018-03-30 11:39:25.387652148 +0800
+++ unlib/Makefile.in	2018-04-11 17:12:45.594138026 +0800
@@ -421,6 +421,13 @@
 endif
 endif # USE_ANDROID
 
+ifeq (@USE_HIPLAYER@,1)
+HI_EXTLIBS = xbmc/cores/hiplayer/hiplayer.a 
+HI_EXTLIBS+= xbmc/linux/hisi/hiadp.a 
+else
+HI_EXTLIBS=${null}
+endif
+
 ifeq (@USE_VUPLUS@,1)
 ifeq (@USE_VUPLUS_ARM_LIB@,1)
 LIBS+= -lKodiGLESPL -ldvb_base -lnxpl -ldvb_client
@@ -466,7 +473,7 @@
 ifeq ($(findstring osx,@ARCH@), osx)
 	$(SILENT_LD) $(CXX) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,-all_load,-ObjC $(MAINOBJS) $(DYNOBJSXBMC) $(NWAOBJSXBMC) $(OBJSXBMC) $(LIBS) -rdynamic
 else
-	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic $(VUPLUS_EXTLIBS) $(GB_EXTLIBS)
+	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) $(HI_EXTLIBS) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic $(VUPLUS_EXTLIBS) $(GB_EXTLIBS)
 endif
 
 @APP_NAME_LC@-xrandr: xbmc-xrandr.c
diff -uNr git/xbmc/cores/AudioEngine/AESinkFactory.cpp unlib/xbmc/cores/AudioEngine/AESinkFactory.cpp
--- git/xbmc/cores/AudioEngine/AESinkFactory.cpp	2018-03-30 11:39:25.339652341 +0800
+++ unlib/xbmc/cores/AudioEngine/AESinkFactory.cpp	2018-04-11 10:18:57.689908701 +0800
@@ -215,6 +215,14 @@
   if(!info.m_deviceInfoList.empty())
     list.push_back(info);
   #endif
+#elif defined(USE_HIPLAYER)
+  #if defined(HAS_ALSA)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "ALSA";
+  CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+    list.push_back(info);
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
 
   info.m_deviceInfoList.clear();
diff -uNr git/xbmc/cores/hiplayer/HiCodecAudio.h unlib/xbmc/cores/hiplayer/HiCodecAudio.h
--- git/xbmc/cores/hiplayer/HiCodecAudio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiCodecAudio.h	2018-03-16 16:48:59.937669100 +0800
@@ -0,0 +1,86 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/AudioEngine/Utils/AEAudioFormat.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+#include "DVDStreamInfo.h"
+#include "linux/PlatformDefs.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+#include "cores/AudioEngine/AEResampleFactory.h"
+#include "cores/AudioEngine/Utils/AEStreamInfo.h"
+
+class CProcessInfo;
+
+class CDVDAudioCodecHisi
+{
+	public:
+		CDVDAudioCodecHisi(CProcessInfo &processInfo);
+		virtual ~CDVDAudioCodecHisi();
+		bool Open(CDVDStreamInfo &hints);
+		void Dispose();
+		int Decode(BYTE* pData, int iSize, double dts, double pts);
+		int GetData(BYTE** dst, double &dts, double &pts);
+		void Reset();
+		int GetChannels();
+		void BuildChannelMap();
+		CAEChannelInfo GetChannelMap();
+		int GetSampleRate();
+		int GetBitsPerSample();
+		static const char* GetName() { return "FFmpeg"; }
+		int GetBitRate();
+		unsigned int GetFrameSize() { return m_frameSize; }
+	
+	protected:
+		CProcessInfo &m_processInfo;
+		AVCodecContext* m_pCodecContext;
+		SwrContext* 		m_pConvert;
+		enum AVSampleFormat m_iSampleFormat;
+		enum AVSampleFormat m_desiredSampleFormat;
+	
+		AVFrame* m_pFrame1;
+	
+		BYTE *m_pBufferOutput;
+		int 	m_iBufferOutputUsed;
+		int 	m_iBufferOutputAlloced;
+	
+		int 		m_channels;
+		CAEChannelInfo m_channelLayout;
+		int			m_desiredchannels;
+		CAEChannelInfo m_desiredchannelLayout;
+		
+		bool m_bFirstFrame;
+		bool m_bGotFrame;
+		bool m_bNoConcatenate;
+		unsigned int	m_frameSize;
+		double m_dts, m_pts;
+
+		unsigned char m_buffer[10240];
+};
+
diff -uNr git/xbmc/cores/hiplayer/HiCodecVideo.h unlib/xbmc/cores/hiplayer/HiCodecVideo.h
--- git/xbmc/cores/hiplayer/HiCodecVideo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiCodecVideo.h	2018-03-15 17:40:53.861891800 +0800
@@ -0,0 +1,82 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "threads/CriticalSection.h"
+
+#include <set>
+
+class CHisiCodec;
+struct frame_queue;
+struct mpeg2_sequence;
+class CBitstreamParser;
+class CBitstreamConverter;
+
+class CDVDVideoCodecHisi;
+
+class CDVDVideoCodecHisi : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecHisi(CProcessInfo &processInfo);
+  virtual ~CDVDVideoCodecHisi();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetSpeed(int iSpeed);
+  virtual void SetDropState(bool bDrop);
+  virtual int  GetDataSize(void);
+  virtual double GetTimeSize(void);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+protected:
+  void            Dispose(void);
+  void            FrameQueuePop(void);
+  void            FrameQueuePush(double dts, double pts);
+  void            FrameRateTracking(uint8_t *pData, int iSize, double dts, double pts);
+
+  CHisiCodec      *m_Codec;
+  const char     *m_pFormatName;
+  DVDVideoPicture m_videobuffer;
+  CDVDStreamInfo  m_hints;
+  double          m_last_pts;
+  frame_queue    *m_frame_queue;
+  int32_t         m_queue_depth;
+  pthread_mutex_t m_queue_mutex;
+  double          m_framerate;
+  int             m_video_rate;
+  float           m_aspect_ratio;
+  mpeg2_sequence *m_mpeg2_sequence;
+  double          m_mpeg2_sequence_pts;
+
+  CBitstreamParser *m_bitparser;
+  CBitstreamConverter *m_bitstream;
+	
+  bool            m_opened;	
+  bool            m_drop;
+	
+private:
+  CCriticalSection    m_secure;
+};
diff -uNr git/xbmc/cores/hiplayer/HiDecoder.h unlib/xbmc/cores/hiplayer/HiDecoder.h
--- git/xbmc/cores/hiplayer/HiDecoder.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiDecoder.h	2018-04-09 18:43:43.124112600 +0800
@@ -0,0 +1,147 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include <deque>
+
+extern "C" {
+#include <hisi/hi_type.h>
+#include <hisi/hi_unf_video.h>
+#include <hisi/hi_unf_audio.h>
+#include <hisi/hi_unf_common.h>
+#include <hisi/hi_unf_vo.h>
+#include <hisi/hi_unf_disp.h>
+#include <hisi/hi_unf_advca.h>
+#include <hisi/hi_adp_mpi.h> 
+#include <hisi/hi_audio_codec.h> 
+#include "hisi/HA.AUDIO.PCM.decode.h"
+
+}  // extern "C"
+
+#define PTS_FREQ        90000
+#define UNIT_FREQ       96000
+#define AV_SYNC_THRESH  PTS_FREQ*30
+#define PTS_US_TO_MS(PTS_US) ((PTS_US) / 1000.0f)
+#define PTS_MS_TO_US(PTS_MS) ((PTS_MS) * 1000.0f)
+#define PTS_90KHZ_TO_MS(PTS_90MS) ((PTS_90MS) / 90.0f)
+#define PTS_MS_TO_90KHZ(PTS_MS) ((PTS_MS) * 90.0f)
+
+enum
+{
+	VIDEO_MODE_NORMAL,
+	VIDEO_MODE_PAUSE,
+	VIDEO_MODE_FORWARD,
+	VIDEO_MODE_BACKWARD
+};
+
+class HisiAvDecoder
+{
+public:
+  static HisiAvDecoder& GetInstance();
+  
+  HisiAvDecoder();
+  virtual ~HisiAvDecoder();
+
+  bool          OpenVideo(CDVDStreamInfo &hints);
+  bool          CloseVideo();
+	void					VideoReset();
+  bool			WriteVideoPackage(uint8_t *pData, size_t iSize, unsigned int pts_ms);
+	bool 			WriteVideoPackageEx(uint8_t *pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+	
+  double 		VideoGetPts();
+  bool 			VideoIsBufferFull();
+  bool 			VideoIsNewFrame(int64_t &pts);
+  void			VideoSpeed(int speed);
+
+  bool          OpenAudio(CDVDStreamInfo &hints);
+  bool          CloseAudio(); 
+	void					AudioReset();
+  bool			WriteAudioPackage(uint8_t *pData, size_t iSize, unsigned int pts_ms);
+  bool			WriteAudioPackageEx(uint8_t *pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+  double 		AudioGetPts();
+  int 			AudioGetFrame();
+	bool			VideoFirstFrame(double& pts);
+	bool			AudioFirstFrame(double& pts);
+
+	bool			IsEOS();
+	
+	void 			SubmitEOS();
+	void 			AudioSubmitEOS();
+	void			VideoSubmitEOS();
+
+	double		AudioCacheTotal();
+	double 		AudioCachetime();
+	double		AudioDelay();
+  HI_S32 		EventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara);
+
+	bool			VideoCanPush();
+	bool			AudioCanPush();
+
+	void			SetVideoRect(int x, int y, int width, int height);
+protected:
+  bool			Init();
+  bool			Deinit();
+  
+  HI_UNF_VCODEC_TYPE_E codec2vdec(int enc);
+  HA_CODEC_ID_E codec2adec(int enc);
+
+
+private:
+  bool						m_opened;
+	bool						m_video_opend;
+	bool						m_audio_opend;
+  bool						m_dump;
+  
+  unsigned int      m_hAvplay;
+  unsigned int      m_hWin;
+  unsigned int 		m_hTrack;
+
+  //video play
+  int				m_mode;
+  int				m_speed;
+  
+  HI_UNF_DISP_E		m_disp;
+  bool				m_freerun;
+  bool 				m_firstpack;
+
+  CCriticalSection  m_section;
+  CCriticalSection	m_EventMutex;
+  
+  bool				m_newpts;
+  bool  			m_fullbuff;
+  unsigned int		m_pts;
+  
+  std::deque<int>  m_aptsQueue;
+  std::deque<int>  m_vptsQueue;
+
+	
+	bool			m_audiocanpush;
+	bool			m_videocanpush;
+
+	bool			m_video_eos;
+	bool			m_audio_eos;
+
+	bool			m_eos;
+	double		m_audiocache;
+	double		m_delay;
+};
diff -uNr git/xbmc/cores/hiplayer/HiPlayerAudio.h unlib/xbmc/cores/hiplayer/HiPlayerAudio.h
--- git/xbmc/cores/hiplayer/HiPlayerAudio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiPlayerAudio.h	2018-04-11 14:34:03.362072875 +0800
@@ -0,0 +1,105 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <deque>
+#include <sys/types.h>
+
+#include "DVDStreamInfo.h"
+#include "threads/Thread.h"
+#include "IVideoPlayer.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDMessageQueue.h"
+#include "utils/BitstreamStats.h"
+
+#include "HiCodecAudio.h"
+
+class CHiPlayerAudio : public CThread, public IDVDStreamPlayerAudio
+{
+protected:
+  CDVDMessageQueue      m_messageQueue;
+  CDVDMessageQueue     &m_messageParent;
+
+  CDVDStreamInfo            m_hints_current;
+  CDVDStreamInfo            m_hints;
+  CDVDClock                *m_av_clock;
+  //COMXAudio                 m_omxAudio;
+  std::string               m_codec_name;
+  bool                      m_passthrough;
+  AEAudioFormat             m_format;
+  CDVDAudioCodecHisi       *m_pAudioCodec;
+  int                       m_speed;
+  bool                      m_silence;
+  double                    m_audioClock;
+
+  bool                      m_stalled;
+  IDVDStreamPlayer::ESyncState m_syncState;
+
+  BitstreamStats            m_audioStats;
+
+  bool                      m_buffer_empty;
+  bool                      m_flush;
+  bool                      m_DecoderOpen;
+
+  bool                      m_bad_state;
+  bool                      m_eos;
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+  void OpenStream(CDVDStreamInfo &hints, CDVDAudioCodecHisi *codec);
+private:
+public:
+  CHiPlayerAudio(CDVDClock *av_clock, CDVDMessageQueue& parent, CProcessInfo &processInfo);
+  ~CHiPlayerAudio();
+  bool OpenStream(CDVDStreamInfo &hints);
+  void SendMessage(CDVDMsg* pMsg, int priority = 0) { m_messageQueue.Put(pMsg, priority); }
+  void FlushMessages()                              { m_messageQueue.Flush(); }
+  bool AcceptsData() const                          { return !m_messageQueue.IsFull(); }
+  bool HasData() const                              ;
+  bool IsInited() const                             { return m_messageQueue.IsInited(); }
+  int  GetLevel() const                             { return m_messageQueue.GetLevel(); }
+  bool IsStalled() const                            { return m_stalled;  }
+  bool IsEOS();
+  void WaitForBuffers();
+  void CloseStream(bool bWaitForBuffers);
+  bool CodecChange();
+  bool Decode(DemuxPacket *pkt, bool bDropPacket, bool bTrickPlay);
+  void Flush(bool sync);
+  AEAudioFormat GetDataFormat(CDVDStreamInfo hints);
+  bool IsPassthrough() const;
+  bool OpenDecoder();
+  void CloseDecoder();
+  double GetDelay();
+  double GetCacheTime();
+  double GetCacheTotal();
+  double GetCurrentPts() { return m_audioClock; };
+  void SubmitEOS();
+
+  void SetDynamicRangeCompression(long drc)              {   }
+  float GetDynamicRangeAmplification() const             { return 0.0f; }
+  void SetSpeed(int iSpeed);
+  int  GetAudioBitrate();
+  int GetAudioChannels();
+  std::string GetPlayerInfo();
+
+  bool BadState() { return m_bad_state; }
+};
+
diff -uNr git/xbmc/cores/hiplayer/HiPlayerVideo.h unlib/xbmc/cores/hiplayer/HiPlayerVideo.h
--- git/xbmc/cores/hiplayer/HiPlayerVideo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HiPlayerVideo.h	2018-03-16 17:27:37.842445700 +0800
@@ -0,0 +1,129 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+#include "IVideoPlayer.h"
+#include "DVDMessageQueue.h"
+#include "DVDStreamInfo.h"
+#include "DVDCodecs/Video/DVDVideoCodec.h"
+#include "DVDClock.h"
+#include "DVDOverlayContainer.h"
+#include "DVDTSCorrection.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "utils/BitstreamStats.h"
+#include "utils/BitstreamConverter.h"
+#include "guilib/Geometry.h"
+#include "HiCodecVideo.h"
+#include <atomic>
+
+class CHiPlayerVideo : public CThread, public IDVDStreamPlayerVideo
+{
+public:
+  CHiPlayerVideo(CDVDClock* pClock
+                 ,CDVDOverlayContainer* pOverlayContainer
+                 ,CDVDMessageQueue& parent
+                 ,CRenderManager& renderManager,
+                 CProcessInfo &processInfo);
+  
+  virtual ~CHiPlayerVideo();
+
+  bool OpenStream(CDVDStreamInfo &hint);
+  void CloseStream(bool bWaitForBuffers);
+
+  void Flush(bool sync);
+  bool AcceptsData() const { return !m_messageQueue.IsFull(); }
+  bool HasData() const ;
+  int  GetLevel() const { return m_messageQueue.GetLevel(); }
+  bool IsInited() const { return m_messageQueue.IsInited(); }
+  void SendMessage(CDVDMsg* pMsg, int priority = 0) { m_messageQueue.Put(pMsg, priority); }
+  void FlushMessages() { m_messageQueue.Flush(); }
+
+  void EnableSubtitle(bool bEnable) { m_bRenderSubs = bEnable; }
+  bool IsSubtitleEnabled() { return m_bRenderSubs; }
+  void EnableFullscreen(bool bEnable) { m_bAllowFullscreen = bEnable; }
+  double GetSubtitleDelay() { return m_iSubtitleDelay; }
+  void SetSubtitleDelay(double delay) { m_iSubtitleDelay = delay; }
+  bool IsStalled() const override { return m_stalled; }
+  bool IsRewindStalled() const override { return m_rewindStalled; }
+  double GetCurrentPts();
+  double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
+  int GetDecoderFreeSpace() { return 0; }
+  std::string GetPlayerInfo();
+  int GetVideoBitrate();
+  std::string GetStereoMode();
+  void SetSpeed(int iSpeed);
+	void	SubmitEOS();
+
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+
+	
+	void OpenStream(CDVDStreamInfo &hint, CDVDVideoCodecHisi* codec);
+  void ProcessOverlays(double pts);
+	void ResolutionUpdateCallBack();
+	void Output(double pts, bool bDropPacket);
+	void SetVideoRect(const CRect &InSrcRect, const CRect &InDestRect);
+
+  CDVDStreamInfo m_hints;
+
+  int m_speed;
+
+  bool m_bRenderSubs;
+  bool m_bAllowFullscreen;
+  bool m_paused;
+  bool m_bFpsInvalid;        // needed to ignore fps (e.g. dvd stills)
+
+  float m_fForcedAspectRatio;
+	
+  double m_fFrameRate;       //framerate of the video currently playing
+  double m_iSubtitleDelay;
+
+  bool m_stalled;
+  std::atomic_bool m_rewindStalled;
+  std::atomic_bool m_bAbortOutput;
+	
+  BitstreamStats m_videoStats;
+	
+  CDVDMessageQueue  m_messageQueue;
+  CDVDMessageQueue& m_messageParent;
+  
+  CRenderManager& m_renderManager;
+
+  CDVDOverlayContainer  *m_pOverlayContainer;
+	
+	CBitstreamConverter *m_bitstream;
+
+  IDVDStreamPlayer::ESyncState m_syncState;
+
+	CDVDVideoCodecHisi * m_pVideoCodec;
+	
+  CRect                     m_src_rect;
+  CRect                     m_dst_rect;
+  RENDER_STEREO_MODE        m_video_stereo_mode;
+  RENDER_STEREO_MODE        m_display_stereo_mode;
+  bool                      m_StereoInvert;
+
+	DVDVideoPicture m_picture;
+};
+
diff -uNr git/xbmc/cores/hiplayer/HisiCodec.h unlib/xbmc/cores/hiplayer/HisiCodec.h
--- git/xbmc/cores/hiplayer/HisiCodec.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/cores/hiplayer/HisiCodec.h	2018-03-15 16:57:51.482142500 +0800
@@ -0,0 +1,123 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "cores/IPlayer.h"
+#include "guilib/Geometry.h"
+#include "rendering/RenderSystem.h"
+#include "threads/Thread.h"
+#include <deque>
+
+extern "C" {
+#include <hisi/hi_type.h>
+#include <hisi/hi_unf_video.h>
+#include <hisi/hi_unf_common.h>
+#include <hisi/hi_unf_vo.h>
+#include <hisi/hi_unf_disp.h>
+#include <hisi/hi_unf_advca.h>
+#include <hisi/hi_adp_mpi.h> 
+}  // extern "C"
+
+
+class PosixFile;
+typedef std::shared_ptr<PosixFile> PosixFilePtr;
+
+
+class CHisiCodec : public CThread
+{
+public:
+  CHisiCodec();
+  virtual ~CHisiCodec();
+
+  bool          OpenDecoder(CDVDStreamInfo &hints);
+  void          CloseDecoder();
+  void          Reset();
+
+  int           Decode(uint8_t *pData, size_t size, double dts, double pts);
+
+  bool          GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  void          SetSpeed(int speed);
+  int           GetDataSize();
+  double        GetTimeSize();
+  void          SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
+  int64_t       GetCurPts() const { return m_cur_pts; }
+  int           GetHIPts() const { return static_cast<int>(m_cur_pts - m_start_pts); }
+  void          SetFreeRun(const bool freerun);
+protected:
+  virtual void  Process();
+
+private:
+  void          ShowMainVideo(const bool show);
+  void          SetVideoZoom(const float zoom);
+  void          SetVideoContrast(const int contrast);
+  void          SetVideoBrightness(const int brightness);
+  void          SetVideoSaturation(const int saturation);
+  bool          SetVideo3dMode(const int mode3d);
+  std::string   GetStereoMode();
+  int           DequeueBuffer(int64_t &pts);
+  void			SetHeader();
+static  
+  HI_S32 		EventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara);
+
+private:
+  bool             m_opened;
+  CDVDStreamInfo   m_hints;
+  volatile int     m_speed;
+  volatile int     m_mode;
+  volatile int64_t m_1st_pts;
+  volatile int64_t m_cur_pts;
+  volatile double  m_timesize;
+  volatile int64_t m_vbufsize;
+  int64_t          m_start_dts;
+  int64_t          m_start_pts;
+  CEvent           m_ready_event;
+  CRect            m_dst_rect;
+  CRect            m_display_rect;
+  int              m_view_mode;
+  RENDER_STEREO_MODE m_stereo_mode;
+  RENDER_STEREO_VIEW m_stereo_view;
+  float            m_zoom;
+  int              m_contrast;
+  int              m_brightness;
+
+  std::deque<int64_t>  m_ptsQueue;
+  CCriticalSection m_ptsQueueMutex;
+
+  unsigned int		m_video_rate;
+  unsigned char* 	m_extradata;
+  unsigned int      m_extrasize;
+ 
+  unsigned char*    m_header;
+  unsigned int      m_headersize;
+  
+  CRect				m_VideoRect;
+  HI_UNF_DISP_E		m_disp;
+  bool				m_freerun;
+  bool 				m_firstpack;
+  
+  static bool 	            g_got_newpts;
+  static bool	            g_dont_push;
+  static unsigned int	    g_decoder_pts;
+  static unsigned int	    g_timesize;
+  static unsigned int 		g_printdevide;
+
+};
diff -uNr git/xbmc/cores/VideoPlayer/VideoPlayer.cpp unlib/xbmc/cores/VideoPlayer/VideoPlayer.cpp
--- git/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2018-03-30 11:39:25.347652309 +0800
+++ unlib/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2018-04-11 10:18:57.705908221 +0800
@@ -81,6 +81,12 @@
 #include "cores/omxplayer/OMXPlayerVideo.h"
 #include "cores/omxplayer/OMXHelper.h"
 #endif
+
+#ifdef USE_HIPLAYER
+#include "cores/hiplayer/HiPlayerVideo.h"
+#include "cores/hiplayer/HiPlayerAudio.h"
+#endif
+
 #include "VideoPlayerAudio.h"
 #include "cores/DataCacheCore.h"
 #include "windowing/WindowingFactory.h"
@@ -590,8 +596,13 @@
   }
   else
   {
+#ifdef USE_HIPLAYER
+	m_VideoPlayerVideo = new CHiPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
+	m_VideoPlayerAudio = new CHiPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+#else
     m_VideoPlayerVideo = new CVideoPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
     m_VideoPlayerAudio = new CVideoPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+#endif
   }
   m_VideoPlayerSubtitle = new CVideoPlayerSubtitle(&m_overlayContainer, *m_processInfo);
   m_VideoPlayerTeletext = new CDVDTeletextData(*m_processInfo);
diff -uNr git/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h unlib/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h
--- git/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/HA.AUDIO.PCM.decode.h	2018-04-11 10:18:57.873903157 +0800
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.PCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_PCM_H__
+#define __HISI_AUDIO_DECODER_PCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_PCM_ID 0x0000        
+
+typedef struct hiWAV_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format category */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* the block alignment (in bytes) of the
+                                      waveform data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* number of bytes of wave raw data cbExtWord*/
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).                      */
+   /* note: big-endian pcm supprt(microsoft wav file only support little-endian pcm format):
+        cbSize = 4;
+        cbExtWord[0] = 1;
+        cbExtWord[1] ; //reserved
+   */
+} WAV_FORMAT_S;
+
+#define HA_PCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(WAV_FORMAT_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_PCM_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_adp_hdmi.h unlib/xbmc/linux/hisi/hi_adp_hdmi.h
--- git/xbmc/linux/hisi/hi_adp_hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_adp_hdmi.h	2017-07-31 21:24:56.000000000 +0800
@@ -0,0 +1,15 @@
+#ifndef __SAMPLE_HDMI_COMMON_H__
+#define __SAMPLE_HDMI_COMMON_H__
+
+#include "hi_unf_hdmi.h"
+
+typedef void (*User_HDMI_CallBack)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt);
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId);
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId);
+//HI_S32 HIADP_HDMI_SetAdecAttr(HI_UNF_SND_INTERFACE_E enInterface, HI_UNF_SAMPLE_RATE_E enRate);
+HI_VOID HDMI_PrintSinkCap(HI_UNF_EDID_BASE_INFO_S *pCapbility);
+
+#endif /* #if pub_HDMI_H_ */
+
diff -uNr git/xbmc/linux/hisi/hi_audio_codec.h unlib/xbmc/linux/hisi/hi_audio_codec.h
--- git/xbmc/linux/hisi/hi_audio_codec.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_audio_codec.h	2018-02-28 16:02:02.022591000 +0800
@@ -0,0 +1,828 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_audio_codec.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2009/11/01
+Last Modified :
+Description   : define audio common data structure
+  History       :
+  1.Date        : 2009/11/10
+    Author      : zgjie
+    Modification: Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the audio codec. CNcomment:提供AUDIO_CODEC的相关信息 CNend
+ */
+
+#ifndef __HI_AUDIO_CODEC_H__
+#define __HI_AUDIO_CODEC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**Define HA codec Print Level*/
+/**CNcomment:定义HA codec打印级别*/
+#define HA_TRACE_LEVEL_FATAL    (0)
+#define HA_TRACE_LEVEL_ERROR    (1)
+#define HA_TRACE_LEVEL_WARN     (2)
+#define HA_TRACE_LEVEL_INFO     (3)
+#define HA_TRACE_LEVEL_DBG      (4)
+
+
+#ifndef HI_ADVCA_FUNCTION_RELEASE
+
+#ifndef CFG_HA_LOG_LEVEL
+#define CFG_HA_LOG_LEVEL         (HA_TRACE_LEVEL_ERROR)
+#endif
+
+#if (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_FATAL)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_ERROR)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRIN(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_WARN)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_INFO)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_DBG)
+
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)     do{printf(fmt);}while(0)
+
+#endif
+
+#else
+
+#define HA_FATAL_PRINT(fmt...)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#endif
+
+/**Define software dual decode*/
+/**CNcomment:定义软解双路解码*/
+#define HA_SW_DUALDEC_SUPPORT
+
+/**Define HA codec ID*/
+/**CNcomment:定义HA codec ID*/
+/*
+*                HA CODEC_ID defination
+*   |      7bit                9bit                3bit                   13bit  |
+*   |---vendor---|---format---|---reserved---|---id---|
+*/
+#define VENDOR_HISI 0x040
+#define VENDOR_NONE 0x010
+#define HA_VENDOR_OFFSETK  25 /* (32-7) */
+#define HA_VENDOR_MASK     (0x007fUL << HA_VENDOR_OFFSETK)
+#define HA_FORMAT_OFFSETK  16 /* (32-7-9) */
+#define HA_FORMAT_MASK     (0x01ffUL << HA_FORMAT_OFFSETK)
+#define HA_RESERVED_OFFSET 13 /* (32-7-9-3) */
+#define HA_RESERVED_MASK   (0x007UL << HA_RESERVED_OFFSET)
+#define HA_ID_OFFSET       0 /* (32-7-9-3-13) */
+#define HA_ID_MASK         (0x1fffUL<< HA_ID_OFFSET)
+
+#define HA_BUILD_CODEC_ID(vendor, format, id) (((((HI_U32)vendor) << HA_VENDOR_OFFSETK) & HA_VENDOR_MASK) | ((((HI_U32)format) << HA_FORMAT_OFFSETK) & HA_FORMAT_MASK) | (((HI_U32)id) & HA_ID_MASK))
+#define HA_GET_VENDOR(codec) ((HI_U32)(codec&HA_VENDOR_MASK)>>HA_VENDOR_OFFSETK)
+#define HA_GET_FORMAT(codec) ((HI_U32)(codec&HA_FORMAT_MASK)>>HA_FORMAT_OFFSETK)
+#define HA_GET_ID(codec)     ((HI_U32)(codec&HA_ID_MASK)>>HA_ID_OFFSET)
+
+/********************************Macro Definition********************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!-- 【ACODEC】 */
+
+/**Define HA codec common command ID*/
+/**CNcomment:定义HA codec 公共CMD ID*/
+#define HA_COMMON_CMD_ID   0xffff
+
+/**Define HA codec format query command ID*/
+/**CNcomment:定义HA codec 格式查询CMD ID*/
+#define HA_CODEC_FORMAT_QUERY_CMD         ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1000)
+
+/**Define HA codec decoder open parameter command ID*/
+/**CNcomment:定义HA codec 解码器打开参数CMD ID*/
+#define HA_CODEC_GET_DECOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1001)
+
+/**Define HA codec encoder open parameter command ID*/
+/**CNcomment:定义HA codec 编码器打开参数CMD ID*/
+#define HA_CODEC_GET_ENCOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1002)
+
+/**Define HA codec packet query command ID*/
+/**CNcomment:定义HA codec packet解码模式CMD ID*/
+#define HA_CODEC_PACKETDECODER_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1003)
+
+/**Define HA codec hwdecode query command ID*/
+/**CNcomment:定义HA codec hwdecode解码模式CMD ID*/
+#define HA_CODEC_HARDWARECODEC_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1004)
+
+/**Define HA codec set outbuf addr command ID  only for hardware codec*/
+/**CNcomment:定义输出Buffer地址设置CMD ID*/
+#define HA_CODEC_OUTBUFADDR_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1005)
+
+/**Define dual decode capability support query command ID*/
+/**CNcomment:定义双路解码能力查询CMD ID*/
+#define HA_CODEC_DUAL_DECODE_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1006)
+
+/**Define dual decode set ad output mode command ID*/
+/**CNcomment:定义双路解码AD输出模式设置CMD ID*/
+#define HA_CODEC_AD_OUTPUTMODE_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1007)
+
+/**Define AD Balance Setting command ID*/
+/**CNcomment:定义AD 权重设置CMD ID*/
+#define HA_CODEC_AD_BALANCE_SET_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1008)
+
+/**Define PTS Delay command ID*/
+/**CNcomment:定义PTS Delay CMD ID*/
+#define HA_CODEC_PTS_DELAY_SET_CMD      ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1009)
+
+/**Define HA codec set whether work in compress mode command ID */
+/**CNcomment:定义是否工作于在线压缩模式设置CMD ID*/
+#define HA_CODEC_COMPRESSMODE_SET_CMD ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100A)
+
+/**Define HA codec maximum audio channel*/
+/**CNcomment:定义HA codec 最大音频通道 */
+#define HA_AUDIO_MAXCHANNELS 8
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!--  【ACODEC】 */
+
+/**HA format definition*/
+/**CNcomment:HA format 定义*/
+typedef enum hiHA_FORMAT_E
+{
+    FORMAT_MP2 = 0x000,  /**<MPEG audio layer 1, 2.*/ /**<CNcomment:MPEG音频第一层、第二层 */
+    FORMAT_MP3, /**<MPEG audio layer 1, 2, 3.*/ /**<CNcomment:MPEG音频第一层、第二层 、第三层*/
+    FORMAT_AAC,
+    FORMAT_AC3,
+    FORMAT_DTS,
+    FORMAT_VORBIS,
+    FORMAT_DVAUDIO,
+    FORMAT_WMAV1,
+    FORMAT_WMAV2,
+    FORMAT_MACE3,
+    FORMAT_MACE6,
+    FORMAT_VMDAUDIO,
+    FORMAT_SONIC,
+    FORMAT_SONIC_LS,
+    FORMAT_FLAC,
+    FORMAT_MP3ADU,
+    FORMAT_MP3ON4,
+    FORMAT_SHORTEN,
+    FORMAT_ALAC,
+    FORMAT_WESTWOOD_SND1,
+    FORMAT_GSM,
+    FORMAT_QDM2,
+    FORMAT_COOK,
+    FORMAT_TRUESPEECH,
+    FORMAT_TTA,
+    FORMAT_SMACKAUDIO,
+    FORMAT_QCELP,
+    FORMAT_WAVPACK,
+    FORMAT_DSICINAUDIO,
+    FORMAT_IMC,
+    FORMAT_MUSEPACK7,
+    FORMAT_MLP,
+    FORMAT_GSM_MS, /**<as found in WAV.*/ /**<CNcomment:存在WAV格式中 */
+    FORMAT_ATRAC3,
+    FORMAT_VOXWARE,
+    FORMAT_APE,
+    FORMAT_NELLYMOSER,
+    FORMAT_MUSEPACK8,
+    FORMAT_SPEEX,
+    FORMAT_WMAVOICE,
+    FORMAT_WMAPRO,
+    FORMAT_WMALOSSLESS,
+    FORMAT_ATRAC3P,
+    FORMAT_EAC3,
+    FORMAT_SIPR,
+    FORMAT_MP1,
+    FORMAT_TWINVQ,
+    FORMAT_TRUEHD,
+    FORMAT_MP4ALS,
+    FORMAT_ATRAC1,
+    FORMAT_BINKAUDIO_RDFT,
+    FORMAT_BINKAUDIO_DCT,
+    FORMAT_DRA,
+    FORMAT_MS12_DDP,
+    FORMAT_MS12_AAC,
+    FORMAT_MS12_AC4,
+
+    FORMAT_PCM = 0x100,/**<various PCM codecs.*/ /**<CNcomment:PCM格式 */
+    FORMAT_PCM_BLURAY = 0x121,
+
+    FORMAT_ADPCM = 0x130,/**<various ADPCM codecs.*/ /**<CNcomment:ADPCM格式 */
+
+    FORMAT_AMR_NB = 0x160,/**<various AMR codecs.*/ /**<CNcomment:AMR格式 */
+    FORMAT_AMR_WB,
+    FORMAT_AMR_AWB,
+
+    FORMAT_RA_144 = 0x170,/**<RealAudio codecs.*/ /**<CNcomment:RealAudio格式 */
+    FORMAT_RA_288,
+
+    FORMAT_DPCM = 0x180,/**<various DPCM codecs.*/ /**<CNcomment:DPCM格式 */
+
+    FORMAT_G711 = 0x190,/**<various G.7xx codecs.*/ /**<CNcomment:G.7xx格式 */
+    FORMAT_G722,
+    FORMAT_G7231,
+    FORMAT_G726,
+    FORMAT_G728,
+    FORMAT_G729AB,
+
+    FORMAT_OPUS = 0x1a0,
+
+    FORMAT_MULTI = 0x1f0,/**<support multi codecs.*/ /**<CNcomment:多种格式 */
+
+    FORMAT_BUTT = 0x1ff,
+} HA_FORMAT_E;
+
+/**HA format definition*/
+/**CNcomment:HA_Codec定义*/
+typedef enum hiHA_CODEC_ID_E
+{
+    /** HISI Codec*/
+    HA_AUDIO_ID_PCM             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM, 0x0000),
+    HA_AUDIO_ID_MP2             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MP2, 0x0002),
+    HA_AUDIO_ID_MP3             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0003),
+    HA_AUDIO_ID_AAC             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AAC, 0x001),
+    HA_AUDIO_ID_BLYRAYLPCM      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM_BLURAY, 0x021),
+    HA_AUDIO_ID_COOK            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_COOK, 0x0009),
+    HA_AUDIO_ID_DRA             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DRA, 0x007),
+    HA_AUDIO_ID_WMA9STD         = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0006),
+    HA_AUDIO_ID_AMRNB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_NB, 0x0100),
+    HA_AUDIO_ID_AMRWB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_WB, 0x0110),
+    HA_AUDIO_ID_G711            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G711, 0x0102),
+    HA_AUDIO_ID_G722            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G722, 0x0105),
+    HA_AUDIO_ID_G726            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G726, 0x0106),
+    HA_AUDIO_ID_ADPCM           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_ADPCM, 0x0107),
+    HA_AUDIO_ID_VOICE           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0108),
+    HA_AUDIO_ID_TRUEHD          = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x0008),
+    HA_AUDIO_ID_AC3PASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0055),
+    HA_AUDIO_ID_DTSPASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DTS, 0x1025),
+    HA_AUDIO_ID_OPUS            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_OPUS, 0x1006),
+    HA_AUDIO_ID_VORBIS          = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_VORBIS, 0x1007),
+
+    /** DOLBY/DTS IPR Codec*/
+    HA_AUDIO_ID_DOLBY_PLUS      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x1010),
+    HA_AUDIO_ID_DOLBY_TRUEHD    = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x1011),
+    HA_AUDIO_ID_MS12_DDP        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_DDP, 0x1012),
+    HA_AUDIO_ID_MS12_AAC        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_AAC, 0x1013),
+    HA_AUDIO_ID_MS12_AC4        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MS12_AC4, 0x1014),
+    HA_AUDIO_ID_DTSHD           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1020),
+    HA_AUDIO_ID_DTSM6           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1030),
+
+    /** FFMPEG Codec*/
+    HA_AUDIO_ID_FFMPEG_DECODE   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI,  0x03ff),
+    HA_AUDIO_ID_FFMPEG_WMAPRO   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_WMAPRO, 0x041f),
+
+    /** CUSTOMER Codec*/
+    HA_AUDIO_ID_CUSTOM_0        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0400),
+    HA_AUDIO_ID_CUSTOM_1        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0401),
+} HA_CODEC_ID_E;
+
+/**HA Audio Output AD Mode definition*/
+/**CNcomment:HA OUTPUT AD MODE 定义*/
+typedef enum
+{
+    HA_OUTPUT_AD_OFF = 0,
+    HA_OUTPUT_AD_ON,
+    HA_OUTPUT_AD_OFF_WITHASSOC,
+    HA_OUTPUT_AD_BUTT
+} HA_CODEC_OUTPUT_AD_MODE_E;
+
+/**Define query parameter of an HA codec.*/
+/**CNcomment:定义HA codec 查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_VOID *pPara;
+} HA_CODEC_PARAMETER_QUERY_S;
+
+/**Define format query parameter of an HA codec.*/
+/**CNcomment:定义HA codec 格式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_FORMAT_E enFormat;
+} HA_CODEC_FORMAT_QUERY_PARAM_S;
+
+/**Define packet query parameter of an HA codec.*/
+/**CNcomment:定义HA codec packet解码模式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;              /**<packet query command.*/ /**<CNcomment:packet模式查询命令*/
+    HI_BOOL bPacketDecoder;     /**<Packet mode.In this mode, the decoder can decode the next packet only after processing an entire packet. */
+                                /**<CNcomment:packet模式.在这种模式下，只有处理完当前整个packet后解码器才能处理下一个packet包*/
+} HA_CODEC_PACKETDECODER_QUERY_PARAM_S;
+
+/**Define hardware decode query parameter of an HA codec.*/
+/**CNcomment:定义HA codec hardware解码模式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;      /**<hwdecode query command.*/ /**<CNcomment: hwdecode模式查询命令*/
+    HI_BOOL bHwCodec;   /**<HI_TRUE: hwdecode mode else swdecode mode. */ /**<CNcomment:hwdecode模式*/
+} HA_CODEC_HARDWARECODER_QUERY_PARAM_S;
+
+/**Define query parameter of dual decode capability.*/
+/**CNcomment:定义双路解码能力查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;                  /**<query dual decode capability command.*/ /**<CNcomment: 查询双路解码能力命令*/
+    HI_BOOL bDualDecSupport;        /**<support dual decode or not. */  /**<CNcomment:是否支持双路解码*/
+} HA_CODEC_DUALDECODE_QUERY_PARAM_S;
+
+/**Define setting parameter of dual decode ad output mode.*/
+/**CNcomment:设置双路解码AD输出模式**/
+typedef struct
+{
+    HI_U32               enCmd;             /**<set AD Output Mode command.*/ /**<CNcomment: 设置AD输出模式命令*/
+    HA_CODEC_OUTPUT_AD_MODE_E  enAdMode;    /**<AD Output Mode. */  /**<CNcomment:AD输出模式*/
+} HA_CODEC_ADMODE_SET_PARAM_S;
+
+/**Define setting parameter of AD Balance.*/
+/**CNcomment:设置AD 权重**/
+typedef struct
+{
+    HI_U32  enCmd;                      /**<set AD Balance command.*/ /**<CNcomment: 设置AD权重命令*/
+    HI_S16  s16ADBalance;               /**<set the value of AD Balance */  /**<CNcomment:设置AD权重值*/
+} HA_CODEC_ADBALANCE_SET_PARAM_S;
+
+/**Define set parameter of whether work in compress mode.*/
+/**CNcomment:定义是否工作于在线压缩模式设置参数*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<set the compress mode command. */ /**<CNcomment:设置是否在线压缩模式命令*/
+    HI_BOOL bCompressMode;  /**<whether work in compress mode. */ /**<CNcomment:是否工作于在线压缩模式*/
+} HA_CODEC_COMPRESSMODE_SET_PARAM_S;
+
+/**Define the error codes of an HA codec.*/
+/**CNcomment:定义HA codec 错误码*/
+typedef enum hiHA_ERRORTYPE_E
+{
+    HA_ErrorNone = 0, /**<None error.*/ /**<CNcomment:没有错误 */
+
+    HA_ErrorInsufficientResources = (HI_S32) 0x80001000,/**<The device fails to be created due to insufficient resources.*/ /**<CNcomment:资源不够，创建设备失败 */
+
+    HA_ErrorInvalidParameter = (HI_S32) 0x80001001, /**<The input parameter is invalid.*/ /**<CNcomment:输入参数非法 */
+
+    HA_ErrorStreamCorrupt = (HI_S32) 0x80001002, /**<The decoding fails due to incorrect input streams.*/ /**<CNcomment:输入码流错误，解码失败 */
+
+    HA_ErrorNotEnoughData = (HI_S32) 0x80001003,/**<The decoding ends due to insufficient streams.*/ /**<CNcomment:输入码流不够，退出解码 */
+
+    HA_ErrorDecodeMode = (HI_S32) 0x80001004,/**<The decoding mode is not supported.*/ /**<CNcomment:解码模式不支持 */
+
+    HA_ErrorNotSupportCodec = (HI_S32) 0x80001005,/**<The codec is not supported.*/ /**<CNcomment:解码器不支持 */
+
+    HA_ErrorInBufFull = (HI_S32) 0x80001006,/**<Input buffer is full.*/ /**<CNcomment:输入缓存满 */
+
+    HA_ErrorOutBufEmpty = (HI_S32) 0x80001007,/**<Output buffer is empty.*/ /**<CNcomment:输出缓存空 */
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    HA_ErrorNotEnoughADData = (HI_S32) 0x80001008,/**<The decoding ends due to insufficient ad streams.*/ /**<CNcomment:ad输入码流不够，退出解码 */
+
+    HA_ErrorADDecFailed = (HI_S32) 0x80001009,
+#endif
+
+    HA_ErrorMax = 0x9FFFFFFF
+} HI_HA_ERRORTYPE_E;
+
+/**Definition of the distribution mode of the channels of an HA codec.*/
+/**CNcomment:定义HA codec 声道分布模式*/
+typedef enum hiHA_CHANNELTYPE_E
+{
+    HA_AUDIO_ChannelNone = 0x0,    /**< Unused or empty.*/ /**<CNcomment:未使用或为空*/
+    HA_AUDIO_ChannelLF  = 0x1,     /**< Left front.*/ /**<CNcomment:左前*/
+    HA_AUDIO_ChannelRF  = 0x2,     /**< Right front.*/ /**<CNcomment:右前*/
+    HA_AUDIO_ChannelCF  = 0x3,     /**< Center front.*/ /**<CNcomment:中置*/
+    HA_AUDIO_ChannelLS  = 0x4,     /**< Left surround.*/ /**<CNcomment:左环绕*/
+    HA_AUDIO_ChannelRS  = 0x5,     /**< Right surround.*/ /**<CNcomment:右环绕*/
+    HA_AUDIO_ChannelLFE = 0x6,     /**< Low frequency effects.*/ /**<CNcomment:低音*/
+    HA_AUDIO_ChannelCS  = 0x7,     /**< Back surround.*/ /**<CNcomment:后环绕*/
+    HA_AUDIO_ChannelLR  = 0x8,     /**< Left rear.*/ /**<CNcomment:左后*/
+    HA_AUDIO_ChannelRR  = 0x9,     /**< Right rear.*/ /**<CNcomment:右后*/
+    HA_AUDIO_ChannelMax = 0x7FFFFFFF
+} HI_HA_CHANNELTYPE_E;
+
+/**Definition of the decoding mode of an HA decoder.*/
+/**CNcomment:定义HA 解码器解码模式*/
+typedef enum hiHA_DECODEMODE_E
+{
+    HD_DEC_MODE_RAWPCM = 0,        /**<PCM decoding mode.*/ /**<CNcomment:PCM 解码模式*/
+    HD_DEC_MODE_THRU,              /**<SPIDF61937 passthrough decoding mode only, such as AC3/DTS.*/ /**<CNcomment:透传解码模式*/
+    HD_DEC_MODE_SIMUL,             /**<PCM and passthrough decoding mode.*/ /**<CNcomment:PCM + 透传解码模式*/
+    HD_DEC_MODE_BUTT = 0x7FFFFFFF
+} HI_HA_DECODEMODE_E;
+
+/**Definition of the HA codec version.*/
+/**CNcomment:HA codec 版本定义*/
+typedef union hiHI_HAAUDIO_VERSIONTYPE_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;      /**< Major version.*/ /**<CNcomment:主版本号 */
+        HI_U8 u8VersionMinor;      /**< Minor version.*/ /**<CNcomment:副版本号 */
+        HI_U8 u8Revision;          /**< Revision version.*/ /**<CNcomment:修订版本 */
+        HI_U8 u8Step;              /**< Step version.*/ /**<CNcomment:阶段性版本 */
+    } s;
+    HI_U32 u32Version;
+} HI_HAAUDIO_VERSIONTYPE_U;
+
+/**Definition of the data types of the PCM module in an HA codec HA codec.*/
+/**CNcomment:pcm 数据类型结构体定义*/
+typedef struct hiHA_PCMMODETYPE_S
+{
+    HI_U32              u32DesiredOutChannels;/**<Input,number of expected output channels.If the number of original channels is not equal to the number of expected output channels,
+                                                  the decoded automatically performs down-mixing or up-mixing,In this way,
+                                                  the number of output channels is equal to the value of u32DesiredOutChannels,1: mono; 2 stereo. \n*/
+                                              /**<CNcomment:IN 期望输出声道数目. 如果码流原始声道不等于
+                                                  期望输出声道，解码器自动进行down-mix 或up-mix 处理，使得输出
+                                                  声道等于u32DesiredOutChannels.  1: mono, 2 for stereo*/
+    HI_BOOL             bInterleaved;/**<Whether the PCM data is interleaved.
+                                         HI_TRUE: interleaved mode (L/R/L/R.. .L/R/L/R).
+                                         HI_FALSE: non-interleaved mode (L/L/L.../R/R/R...). \n*/
+                                     /**<CNcomment:IN PCM 数据是否交织模式
+                                         HI_TRUE:  交织模式: L/R/L/R...L/R/L/R.
+                                         HI_FALSE: 非交织模式: L/L/L......../R/R/R....... */
+    HI_U32              u32BitPerSample;/**<Input Bit width of the PCM data.Only 16-bit or 24-bit width is supported.For the data of 16-bit width, 16-bit memory is used,
+                                            For the data of 24-bit width, 32-bit memory is used,The active bits of the 24-bit PCM data are upper bits, and the lower eight bits are padded with 0s. \n*/
+                                        /**<CNcomment:IN PCM 数据位宽,仅支持16 或24 数据位宽 16bit 位宽占用16bit 内存,
+                                            24bit 位宽占用32比特内存.24bit PCM数据有效为在高位，低8 位补0*/
+    HI_U32              u32DesiredSampleRate; /**<Input, expected output sampling rate.*/ /**<CNcomment:IN 期望输出采样频率*/
+    HI_HA_CHANNELTYPE_E enChannelMapping[HA_AUDIO_MAXCHANNELS]; /**<Input, distribution mode of output channels.*/ /**<CNcomment:IN 输出声道分布模式*/
+} HI_HA_PCMMODETYPE_S;
+
+/**Configuration parameters required by an HA codec for creating devices.*/
+/**CNcomment:HA 解码器创建设备的配置参数*/
+typedef struct hiHADECODE_OPENPARAM_S
+{
+    HI_HA_DECODEMODE_E  enDecMode;  /**<IN Decode Mode.*/ /**<CNcomment:解码模式*/
+    HI_HA_PCMMODETYPE_S sPcmformat; /**<IN data types of pcm module.*/ /**<CNcomment:PCM数据类型结构体*/
+    HI_VOID *           pCodecPrivateData;/**<Input, pointer to private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                          /**<CNcomment:IN  指向私有配置结构体的指针，如果解码器没有私有配置，设置为0*/
+    HI_U32              u32CodecPrivateDataSize;/**<Input, size of the private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                                /**<CNcomment:IN 私有结构体大小, 如果解码器没有私有配置，设置为0*/
+} HI_HADECODE_OPENPARAM_S;
+
+/**Input streams of an HA decoder.*/
+/**CNcomment:HA 解码器输入码流结构体*/
+typedef struct hiHADECODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;  /**<Input, presentation time stamp (PTS) (in ms).Note: The HA decoder must discard this information. */ /**<CNcomment:当前时间戳*/
+    HI_U8  *pu8Data;   /**<Input/output, pointer to input streams.The decoder update this pointer after decoding. */ /**<CNcomment:IN/OUT 输入码流指针，解码完成后解码器更新该指针*/
+    HI_S32  s32Size;   /**<Input, size (in byte) of input streams.*/ /**<CNcomment:IN 输入码流大小. unit: Byte*/
+    HI_BOOL bEndOfFrm; /**<Input, the last frame or not.*/ /**<CNcomment:IN 是否最后一帧*/
+} HI_HADECODE_INPACKET_S;
+
+/**Get Open parameter of an HA decoder.*/
+/**CNcomment:获取HA 解码器打开参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_HADECODE_OPENPARAM_S *pstDecodeParams;
+} HA_CODEC_GET_DECOPENPARAM_PARAM_S;
+
+/**Definition of the decoder output pts infomations.*/
+/**CNcomment:pts输出信息*/
+typedef struct hiHI_HA_OUTPTSINFO_S
+{
+    union
+    {
+        HI_U32 u32SwDecoderBytesLeft;   /**<left bytes of software decoder.*/ /**<CNcomment:软解剩余字节数 */
+        HI_U32 u32HwDecoderPtsReadPos;  /**<pts read position of software decoder.*/ /**<CNcomment:硬解pts读位置 */
+    } unPts;
+
+    union
+    {
+        HI_U32 u32SwAdDecoderBytesLeft;     /**<ad left bytes of software decoder.*/ /**<CNcomment:软解ad剩余字节数 */
+        HI_U32 u32HwAdDecoderPtsReadPos;    /**<ad pts read position of software decoder.*/ /**<CNcomment:硬解ad pts读位置 */
+    } unAdPts;
+} HI_HA_OUTPTSINFO_S;
+
+/**Output structure of the HA decoder.*/
+/**CNcomment:HA 解码器输出结构体*/
+typedef struct hiHI_HADECODE_OUTPUT_S
+{
+    HI_S32 *ps32PcmOutBuf;       /**<Input, pointer to the decoded PCM data.
+                                     Note: 1) ps32PcmOutBuf must be 32-word aligned.
+                                           2) ps32PcmOutBuf is NULL when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN 指向PCM 解码输出的指针. */
+
+    HI_U32  u32PcmOutBufSize;    /**<Input, size (in byte) of the buffer for storing the decoded PCM data
+                                     Note: u32PcmOutBufSize is 0 when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN  PCM 解码输出缓冲区大小. unit:Byte */
+
+    HI_S32 *ps32BitsOutBuf;      /**<Input, pointer to the decoded passthrough data.
+                                     Note: 1) ps32BitsOutBuf must be 32-word aligned.
+                                           2) ps32BitsOutBuf is NULL when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN 指向透传解码输出的指针. */
+
+    HI_U32  u32BitsOutBufSize;   /**<Input, size (in byte) of the buffer for storing the decoded passthrough data (IEC61937)
+                                     Note: u32BitsOutBufSize is 0 when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN 透传(IEC61937) 解码输出缓冲区大小. unit:Byte */
+
+    HI_U32  u32PcmOutSamplesPerFrame; /**<Output, number of output sampling points after the PCM data is decoded.*/ /**<CNcomment:OUT. 解码Pcm 输出样点数 */
+    HI_BOOL bInterleaved;             /**<Output, interleaved mode for PCM decoding.*/ /**<CNcomment:OUT PCM  解码交织模式*/
+    HI_U32  u32BitPerSample;          /**<Output, bit per sampling.*/ /**<CNcomment:OUT 位宽*/
+    HI_U32  u32BitsOutBytesPerFrame;  /**<Output, size (in byte) of the passthrough frame.*/ /**<CNcomment:OUT 透传输出帧大小. unit: Byte*/
+    HI_U32  u32OutChannels;           /**<Output, number of output channels.*/ /**<CNcomment:OUT 输出声道数*/
+    HI_U32  u32OutSampleRate;         /**<Output, output sampling rate.*/ /**<CNcomment:OUT. 输出采样频率*/
+    HI_U32  u32OrgChannels;           /**<Output, number of original channels.*/ /**<CNcomment:OUT 码流原始声道数*/
+    HI_U32  u32OrgSampleRate;         /**<Output, original sampling rate.*/ /**<CNcomment:OUT 码流原始采样频率*/
+    HI_U32  u32BitRate;               /**<Output, bit rate (in bit/s) of the compressed streams.*/ /**<CNcomment:OUT 码流压缩率unit: bit/S*/
+    HI_HA_OUTPTSINFO_S stPtsInfo;     /**<Output, pts information.*/ /**<CNcomment:OUT. pts信息*/
+    HI_U32  u32FrameIndex;   /**<Output, output frame index.*/ /**<CNcomment:OUT. 输出帧序号*/
+} HI_HADECODE_OUTPUT_S;
+
+/**Definition of the HA decoder.*/
+/**CNcomment:HA 解码器设备定义*/
+typedef struct hiHA_DECODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about a decoder, such as MP3 or AAC. */
+                          /**<CNcomment:IN 解码器描述名字，如MP3,AAC*/
+
+    const HI_U32 enCodecID;/**<Input, decoder ID.Note: This ID is the identifier of a decoder, and must be unique. */
+                           /**<CNcomment:IN 解码器标识，注意: 此标识作为解码器唯一身份标识，必须唯一而不能有重复*/
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, decoder version.*/ /**<CNcomment:IN 解码器版本描述*/
+
+    const HI_PCHAR pszDescription;/**<Input, detailed information about a decoder.*/ /**<CNcomment:IN 解码器详细描述信息*/
+
+
+
+    struct hiHA_DECODE_S *pstNext;/**<Output, pointer to the next decoder.This member variable is maintained by the client that calls the HA codec,
+                                      Therefore, the developers of the HA decoder can ignore this member variable. \n*/
+                                  /**<CNcomment:OUT  指向下个解码器设备的指针.  该成员变量由调用HA Codec 的客户端维护, HA 解码器开发者可以忽略该成员*/
+
+    HI_VOID  * pDllModule;/**<Output, pointer to the dll symbol of an HA decoder,This member variable is maintained by the client that calls the HA codec,
+                              Therefore, the developers of the HA decoder can ignore this member variable.\n*/
+                          /**<CNcomment:OUT 该成员变量由调用HA Codec 的客户端维护, HA 解码器开发者可以忽略该成员*/
+
+    /**
+    \brief Initializes a decoder. CNcomment:初始化解码器 CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open参数结构体指针 CNend
+    \param[out] phDecoder   pointer of the decoder handle CNcomment:解码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecInit)(HI_VOID * *phDecoder,
+                                 const HI_HADECODE_OPENPARAM_S * pstOpenParam);
+
+    /**
+    \brief DeInitializes a decoder. CNcomment:去初始化解码器 CNend
+    \attention \n
+    \param[in] hDecoder   pointer of the decoder handle CNcomment:解码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDeInit)(HI_VOID* hDecoder);
+
+    /**
+    \brief Configure a decoder dynamically. You can call this API when a decoder works.
+    CNcomment:解码器动态配置方法，用户可以在解码器运行时调用该接口 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the decoder CNcomment:解码器初始化结构体 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID* hDecoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum size of the buffer required for storing the PCM data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:解码器PCM输出所需最大缓冲区size. 客户端需要根据该方法分配内存 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the pcm audio frame. unit:Byte CNcomment:最大PCM输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxPcmOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief Maximum size of the buffer required for storing the passthrough data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:解码器透传输出所需最大缓冲区size.客户端需要根据该方法分配内存 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the iec61937 audio frame. unit:Byte CNcomment:最大透传输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxBitsOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to decode a frame. CNcomment:解码器解码一帧方法 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDecodeFrame)(HI_VOID* hDecoder,
+                                        HI_HADECODE_INPACKET_S* pstApkt,
+                                        HI_HADECODE_OUTPUT_S* pstAOut);
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    /**
+    \brief This method is used to dual decode a frame. CNcomment:解码器双路解码一帧方法 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[in] pstADApkt pointer to AD audio stream packet CNcomment:AD音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDualDecodeFrame)(HI_VOID* hDecoder,
+                                            HI_HADECODE_INPACKET_S* pstApkt,
+                                            HI_HADECODE_INPACKET_S* pstADApkt,
+                                            HI_HADECODE_OUTPUT_S* pstAOut);
+#endif
+
+} HI_HA_DECODE_S;
+
+/**Parameters for creating an HA encoder.*/
+/**CNcomment:HA 编码器创建配置参数*/
+typedef struct hiHAENCODE_OPENPARAM_S
+{
+    HI_U32      u32DesiredOutChannels; /**<IN Number of channels (e.g 2 for stereo).*/ /**<CNcomment:声道数*/
+    HI_BOOL     bInterleaved;       /**<IN interleave or not.*/ /**<CNcomment:交织模式*/
+    HI_S32      s32BitPerSample;    /**<IN bitwidth per sample.*/ /**<CNcomment:位宽*/
+    HI_U32      u32DesiredSampleRate; /**<IN desired samplerate.*/ /**<CNcomment:期望采样率*/
+    HI_U32      u32SamplePerFrame;  /**<IN Pcm samples per frame for encoder.*/ /**<CNcomment:每帧采样点*/
+    HI_VOID*    pCodecPrivateData;  /**<IN Pointer of decoder private open parameters note: if there is none private parameters, pCodecPrivateData=0.*/
+                                    /**<CNcomment:私有参数*/
+    HI_U32      u32CodecPrivateDataSize;/**<IN Size of decoder private open parameters note: if there is none private parameters, u32CodecPrivateDataSize=0.*/
+                                        /**<CNcomment:私有参数大小*/
+} HI_HAENCODE_OPENPARAM_S;
+
+/**HA input pcm  packet struct.*/
+/**CNcomment:packet模式结构体*/
+typedef struct hiHAENCODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;       /**<IN  PTS (unit:MS) Note: HA encoder should discard this infomation.*/
+                            /**<CNcomment:PTS，单位:毫秒*/
+    HI_U8*  pu8Data;        /**<IN/OUT pointer to input auduo pcm data note: HA encoder would update pu8Data after encode.*/
+                            /**<CNcomment:输入数据指针*/
+    HI_U32  u32Size;        /**<IN/OUT size of the input auduo data. unit: Byte.*/ /**<CNcomment:输入数据大小*/
+} HI_HAENCODE_INPACKET_S;
+
+/**HA encoder output struct.*/
+/**CNcomment:编码器输出结构体*/
+typedef struct hiHAENCODE_OUTPUT_S
+{
+    HI_S32* ps32BitsOutBuf;         /**<IN the pointer to encoded bitstream output buffer note: ps32BitsOutBuf must  be word32-aligned.*/
+                                    /**<CNcomment:编码数据输出buffer*/
+    HI_U32  u32BitsOutBufSize;      /**<IN the buffer size of bitstream output buffer. unit:Byte.*/ /**<CNcomment:编码器输出buffer大小*/
+    HI_U32  u32BitsOutBytesPerFrame;/**<IN size of the encoded audio data frame ,unit: Byte.*/ /**<CNcomment:编码数据帧大小，单位:Byte*/
+    HI_U32  u32BitRate;             /**<IN compress bit rate of the audio stream.*/ /**<CNcomment:比特率*/
+} HI_HAENCODE_OUTPUT_S;
+
+/**HA encoder struct define.*/
+/**CNcomment:定义编码器结构体*/
+typedef struct hiHA_ENCODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about audio encoder. */
+    /**<CNcomment:IN 编码器描述名字*/
+
+    const HI_U32 enCodecID;/**<Input, encoder ID.Note: This ID is the identifier of a encoder, and must be unique. */
+    /**<CNcomment:IN 编码器标识，注意: 此标识作为编码器唯一身份标识，必须唯一而不能有重复*/
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, encoder version.*/ /**<CNcomment:IN 编码器版本描述*/
+
+    const HI_PCHAR pszDescription;/**<Input, Description infomation of the audio encoder. */ /**<CNcomment:IN 编码器详细描述信息*/
+
+    struct hiHA_ENCODE_S* pstNext;/**<OUT pointer to next HA enocder.manager by client.client:The layer of software that invokes the methods of the HA encoder. */
+    /**<CNcomment:OUT 下个编码器结构体指针，由客户管理 */
+
+    HI_VOID*   pDllModule;/**<Output, pointer to the dll symbol of an HA encoder.This member variable is maintained by the client that calls the HA codec
+                              Therefore, the developers of the HA encoder can ignore this member variable. \n*/
+    /**<CNcomment:OUT 该成员变量由调用HA Codec 的客户端维护, HA 编码器开发者可以忽略该成员*/
+
+    /**
+    \brief Initializes a encoder. CNcomment:初始化编码器 CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open参数结构体指针 CNend
+    \param[out] phEncoder   pointer of the encoder handle CNcomment:编码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeInit)(HI_VOID * *phEncoder,
+                                    const HI_HAENCODE_OPENPARAM_S* pstOpenParam);
+
+    /**
+    \brief DeInitializes a encoder. CNcomment:去初始化编码器 CNend
+    \attention \n
+    \param[in] hEncoder   pointer of the encoder handle CNcomment:编码器句柄 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeDeInit)(HI_VOID* hEncoder);
+
+    /**
+    \brief Configure a encoder dynamically. It can be invoked anytime after the Encoder has been loaded.
+    CNcomment:编码器动态配置方法。用户可以在编码器运行时调用该接口 CNend
+    \attention \n
+    \param[in] hEncoder   the encoder handle CNcomment:编码器句柄 CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the encoder CNcomment:编码器初始化结构体 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID* hEncoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum output size of an encoded bitstream CNcomment:编码器输出所需最大缓冲区size CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the encoded audio frame. unit:Byte CNcomment:最大编码帧输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeGetMaxBitsOutSize)(HI_VOID* hEncoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to encode a frame. CNcomment:编码器编码一帧方法 CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment:编码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeFrame)(HI_VOID* hEncoder,
+                                     HI_HAENCODE_INPACKET_S* pstApkt,
+                                     HI_HAENCODE_OUTPUT_S* pstAOut);
+} HI_HA_ENCODE_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* #ifndef __HI_AUDIO_CODEC_H__ */
diff -uNr git/xbmc/linux/hisi/hi_type.h unlib/xbmc/linux/hisi/hi_type.h
--- git/xbmc/linux/hisi/hi_type.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_type.h	2017-12-26 11:16:12.704977900 +0800
@@ -0,0 +1,142 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_type.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2005/4/23
+Last Modified :
+Description   : Common data types of the system.
+                CNcomment: 系统共用的数据类型定义 CNend
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_TYPE_H__
+#define __HI_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of basic data types. The data types are applicable to both the application layer and kernel codes. *
+ * CNcomment: 基本数据类型定义，应用层和内核代码均使用  CNend                                                   *
+ *--------------------------------------------------------------------------------------------------------------*/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Common_TYPE */
+/** @{ */  /** <!-- [Common_TYPE] */
+
+typedef unsigned char           HI_U8;
+typedef unsigned char           HI_UCHAR;
+typedef unsigned short          HI_U16;
+typedef unsigned int            HI_U32;
+typedef unsigned long           HI_ULONG;
+
+typedef signed char             HI_S8;
+typedef short                   HI_S16;
+typedef int                     HI_S32;
+typedef long                    HI_SLONG;
+
+#ifndef _M_IX86
+typedef unsigned long long      HI_U64;
+typedef long long               HI_S64;
+#else
+typedef __int64                 HI_U64;
+typedef __int64                 HI_S64;
+#endif
+
+typedef char                    HI_CHAR;
+typedef char*                   HI_PCHAR;
+
+typedef float                   HI_FLOAT;
+typedef double                  HI_DOUBLE;
+/*typedef void                    HI_VOID;*/
+#define HI_VOID         void
+
+typedef unsigned long           HI_SIZE_T;
+typedef unsigned long           HI_LENGTH_T;
+
+typedef HI_U32                  HI_HANDLE;
+
+typedef unsigned int            HI_PHYS_ADDR_T;
+
+#ifdef CONFIG_ARCH_LP64_MODE
+typedef unsigned long long      HI_VIRT_ADDR_T;
+#else
+typedef unsigned int            HI_VIRT_ADDR_T;
+#endif
+
+/** Constant Definition */
+/** CNcomment: 常量定义 */
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1,
+} HI_BOOL;
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define HI_NULL             0L
+#define HI_NULL_PTR         0L
+
+#define HI_SUCCESS          0
+#define HI_FAILURE          (-1)
+
+#define HI_INVALID_HANDLE   (0xffffffff)
+
+#define HI_INVALID_PTS      (0xffffffff)
+#define HI_INVALID_TIME     (0xffffffff)
+
+#define HI_OS_LINUX     0xabcd
+#define HI_OS_WIN32     0xcdef
+
+#ifdef _WIN32
+#define HI_OS_TYPE      HI_OS_WIN32
+#else
+#define __OS_LINUX__
+#define HI_OS_TYPE      HI_OS_LINUX
+#endif
+
+#ifdef HI_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+
+define of HI_HANDLE :
+bit31                                                           bit0
+  |<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+  |--------------------------------------------------------------|
+  |      HI_MOD_ID_E       |  mod defined data |     chnID       |
+  |--------------------------------------------------------------|
+
+mod defined data: private data define by each module(for example: sub-mod id), usually, set to 0.
+*/
+
+#define HI_HANDLE_MAKEHANDLE(mod, privatedata, chnid)  (HI_HANDLE)( (((mod)& 0xffff) << 16) | ((((privatedata)& 0xff) << 8) ) | (((chnid) & 0xff)) )
+
+#define HI_HANDLE_GET_MODID(handle)     (((handle) >> 16) & 0xffff)
+#define HI_HANDLE_GET_PriDATA(handle)   (((handle) >> 8) & 0xff)
+#define HI_HANDLE_GET_CHNID(handle)     (((handle)) & 0xff)
+
+#define HI_UNUSED(x) ((x)=(x))
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_TYPE_H__ */
+
diff -uNr git/xbmc/linux/hisi/hi_unf_advca.h unlib/xbmc/linux/hisi/hi_unf_advca.h
--- git/xbmc/linux/hisi/hi_unf_advca.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_advca.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,1789 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_advca.h
+Version       : Initial
+Author        : Hisilicon hisecurity team
+Created       : 2013-08-28
+Last Modified :
+Description   : Hisilicon CA API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_ADVCA_H__
+#define __HI_UNF_ADVCA_H__
+
+#include "hi_type.h"
+#include "hi_unf_cipher.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/** advanced CA session serect key class*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV1     = 0,    /**<session serect key level 1*/
+    HI_UNF_ADVCA_KEYLADDER_LEV2 ,           /**<session serect key level 2*/
+    HI_UNF_ADVCA_KEYLADDER_LEV3 ,           /**<session serect key level 3*/
+    HI_UNF_ADVCA_KEYLADDER_LEV4,            /**<session serect key level 4*/
+    HI_UNF_ADVCA_KEYLADDER_LEV5,            /**<session serect key level 5*/
+    HI_UNF_ADVCA_KEYLADDER_LEV6,            /**<session serect key level 6*/
+    HI_UNF_ADVCA_KEYLADDER_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LEV_E;
+
+/** advanced CA session keyladder target */
+typedef enum hiUNF_ADVCA_CA_TARGET_E
+{
+    HI_UNF_ADVCA_CA_TARGET_DEMUX         = 0, /**<demux*/
+    HI_UNF_ADVCA_CA_TARGET_MULTICIPHER,       /**<multicipher*/
+    HI_UNF_ADVCA_CA_TARGET_BUTT
+}HI_UNF_ADVCA_CA_TARGET_E;
+
+/** advanced CA Encrypt arith*/
+typedef enum hiUNF_ADVCA_ALG_TYPE_E
+{
+    HI_UNF_ADVCA_ALG_TYPE_TDES      = 0,    /**<Encrypt arith :3 DES*/
+    HI_UNF_ADVCA_ALG_TYPE_AES,              /**<Encrypt arith : AES*/
+    HI_UNF_ADVCA_ALG_TYPE_BUTT
+}HI_UNF_ADVCA_ALG_TYPE_E;
+
+/** FLASH device types*/
+typedef enum hiUNF_ADVCA_FLASH_TYPE_E
+{
+    HI_UNF_ADVCA_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NAND ,          /**<nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NOR ,           /**<nor flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_EMMC ,          /**<eMMC*/
+    HI_UNF_ADVCA_FLASH_TYPE_SPI_NAND ,      /**<spi_nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_BUTT
+}HI_UNF_ADVCA_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum hiUNF_ADVCA_JTAG_MODE_E
+{
+    HI_UNF_ADVCA_JTAG_MODE_OPEN     = 0,
+    HI_UNF_ADVCA_JTAG_MODE_PROTECT,
+    HI_UNF_ADVCA_JTAG_MODE_CLOSED,
+    HI_UNF_ADVCA_JTAG_MODE_BUTT
+}HI_UNF_ADVCA_JTAG_MODE_E;
+
+
+typedef struct HiUNF_ADVCA_LOCK_TZ_OTP_PARAM
+{
+    HI_U32 u32Addr;
+    HI_U32 u32Len;
+}HI_UNF_ADVCA_LOCK_TZ_OTP_PARAM_S;
+
+typedef enum hiUNF_ADVCA_SP_DSC_MODE_E
+{
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA2              = 0x0000,   /**<Demux PAYLOAD CSA2 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA3              = 0x0010,   /**<Demux PAYLOAD CSA3 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_IDSA      = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_ECB           = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI        = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_IPTV          = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CIPLUS        = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CBC           = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_NOVEL         = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_NOVEL        = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_IPTV         = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_ECB          = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_CBC          = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC           = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_IPTV         = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_ECB          = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_CBC          = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC               = 0x4020,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_ECB               = 0x4021,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_PIFF          = 0x4022,   /**<MultiCipher AES CBC PIFF */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_APPLE         = 0x4023,   /**<MultiCipher AES CBC APPLE */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CTR               = 0x4024,   /**<MultiCipher AES CTR */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_CBC              = 0x4040,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_ECB              = 0x4041,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_BUTT
+}HI_UNF_ADVCA_SP_DSC_MODE_E;
+
+/** Advca CA VendorID */
+typedef enum hiUNF_ADVCA_VENDORID_E
+{
+    HI_UNF_ADVCA_NULL       = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_ADVCA_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_ADVCA_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_ADVCA_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_ADVCA_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_ADVCA_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_ADVCA_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_ADVCA_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_ADVCA_COMMONCA   = 0x0b,        /**<COMMONCA Chipset, Marked with H*/
+    HI_UNF_ADVCA_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_ADVCA_PANACCESS  = 0x0e,        /**<PANACCESS CA Chipset*/
+    HI_UNF_ADVCA_VENDORIDE_BUTT
+}HI_UNF_ADVCA_VENDORID_E;
+
+/** Advca CA lock type */
+typedef enum hiUNF_ADVCA_LOCK_TYPE
+{
+    HI_UNF_ADVCA_LOCK_RSA_KEY = 0,
+    HI_UNF_ADVCA_LOCK_TZ_OTP,
+    HI_UNF_ADVCA_LOCK_MISC_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_GG_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_TSKL_CSA3_DISABLE,
+    HI_UNF_ADVCA_LOCK_BUTT,
+}HI_UNF_ADVCA_LOCK_TYPE_E;
+
+
+/** DCAS KeyLadder use mode */
+typedef enum hiUNF_ADVCA_DCAS_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK2         = 0,    /**<session EK2*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK1         = 1,    /**<session EK1*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_VENDORSYSID = 8,    /**<session Vendor_SysID*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_NONCE       = 9,    /**<session nonce*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_BUTT
+}HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E;
+
+/**Defines the attribute ID of the OTP fuse. Please be kindly noted that the OTP fuse is set permanently.
+After setting the OTP fuse, please power off and then power on the STB to make the OTP fuse function effective */
+/**CNcomment: 定义OTP位ID枚举类型. 请注意OTP位设置后不可改变.
+设置后，请断电重启使OTP位功能生效.*/
+typedef enum hiUNF_ADVCA_OTP_FUSE_E
+{
+    HI_UNF_ADVCA_OTP_NULL = 0,
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION, /**<Whether to enable the secure boot authentication, set the boot flash type together, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*//**<CNcomment: 安全启动是否开启，同时设置安全启动flash类型, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_DECRYPTION_ACTIVATION, /**<Whether to enable the secure boot decryption, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: boot解密功能是否开启, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SELF_BOOT_DEACTIVATION, /**<Whether to disable the self boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 自举是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_DEACTIVATION, /**<Whether to disable the DDR wakeup, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 待机原地唤醒是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_LEVEL_SEL, /**<CSA2 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA2 keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_KL_LEVEL_SEL, /**<R2R keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: R2R keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_LEVEL_SEL, /**<SP keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: SP keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_LEVEL_SEL, /**<CSA3 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA3 keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_LP_DEACTIVATION, /**<Whether to disable the LP keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: LP keyladder是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA2 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_CW_HARDONLY_ACTIVATION, /**<Whether to enable the SP hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA3 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_DEACTIVATION, /**<Whether to disable the CSA2 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2 keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_DEACTIVATION, /**<Whether to disable the SP keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_DEACTIVATION, /**<Whether to disable the CSA3 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3 keyladder解密引擎是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_DEACTIVATION, /**<Whether to disable the MISC keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: MISC keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GOOGLE_KL_DEACTIVATION, /**<Whether to disable the google keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Google keyladder解密引擎是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DCAS_KL_DEACTIVATION, /**<Whether to disable the DCAS keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DCAS keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_SCRAMBLE_ACTIVATION, /**<Whether to enable the DDR scrambling, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR加扰是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GLOBAL_LOCK_ACTIVATION, /**<Whether to lock the whole OTP area, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: OTP写保护是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_RUNTIME_CHECK_ACTIVATION, /**<Whether to enable the runtime check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Runtime check是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_CHECK_ACTIVATION, /**<Whether to enable the DDR check when wakeup from standby, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 待机原地唤醒时DDR校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID_CHECK_ACTIVATION, /**<Whether to enable the version id check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Version ID校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_MSID_CHECK_ACTIVATION, /**<Whether to enable the boot MSID check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Boot MSID校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_MODE, /**<JTAG protected mode, HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*//**<CNcomment: JTAG保护模式 , HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_READ_DEACTIVATION, /**<Whether to disable to read OTP via JTAG, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 通过JTAG读取OTP是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_ROOTKEY, /**<CSA2 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA2 keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY, /**<R2R keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: R2R keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_ROOTKEY, /**<SP keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: SP keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_ROOTKEY, /**<CSA3 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA3 keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_ROOTKEY, /**<MISC keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: MISC keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY, /**<OEM keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: OEM keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ESCK_ROOTKEY, /**<ESCK keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: ESCK keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY, /**<JTAG key, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*//**<CNcomment: JTAG密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CHIP_ID, /**<Chip ID, HI_UNF_ADVCA_CHIPID_ATTR_S*//**<CNcomment: Chip ID, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MARKET_SEGMENT_ID, /**<Market segment ID, HI_UNF_ADVCA_MARKET_ID_ATTR_S*//**<CNcomment: Market segment ID , HI_UNF_ADVCA_MARKET_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID, /**<Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*//**<CNcomment: Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_LEVEL_SEL, /**<MISC keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: MISC keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VMX_BL_FUSE, /**<Burn verimatrix bootloader fuse*//**<CNcomment: 烧写verimatrix特定的bootloader fuse位*/
+    HI_UNF_ADVCA_OTP_IRDETO_ITCSA3_ACTIVATION, /**<Whether to enbale the tweaked CSA3, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 私有CSA3算法是否开启。HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOTINFO_DEACTIVATION, /**<Whether to disable the bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Bootinfo是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ITCSA3_IMLB, /**<tweaked CSA3 IMLB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 私有CSA3算法IMLB,HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_USB_DEACTIVATION, /**<Whether to disable the usb host, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止USB设备, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SERIAL_DEACTIVATION, /**<Whether to disable serial port, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止串口功能, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ETHERNET_DEACTIVATION, /**<Whether to disable the ethernet, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止网络, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SM4_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the SM4 crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SM4解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TDES_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the TDES crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: TDES解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION_ONLY,   /**<Enable secure boot authentication only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 安全启动使能， HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE,   /**<Boot flash type, HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*//**<CNcomment: 安全启动flash类型， HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_RSA_KEY_LOCK_FLAG,   /**< Get the lock flag of RSA_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取RSA_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_STBSN_LOCK_FLAG,   /**< Get the lock flag of STBSN, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取STBSN lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MSID_LOCK_FLAG,   /**< Get the lock flag of MSID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取MSID lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSIONID_LOCK_FLAG,   /**< Get the lock flag of VersionID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取VersionID lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of OEM_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取OEM_Root_key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of R2R_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取R2R_Root_key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY_LOCK_FLAG,   /**< Get the lock flag of JTAG key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取JTAG key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TZ_AREA_LOCK_FLAG,   /**< Get the lock flag of OTP trust area, when otp_tz_area_enable is set, these lock flags can only be accessed by secure cpu , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取OTP trust area lock标记，当otp_tz_area_enable被设置时，这些标记只能被安全CPU读取，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ENCRYPTION_DEACTIVATION, /**< whether to diable boot loader key generation, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 生成bootloader key功能是否关闭，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY,        /**<Boot keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: boot keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY,   /**<Sec store keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Sec store keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of BOOT_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取BOOT_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of SEC_STORE_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取SEC_STORE_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SOS_MARKET_SEGMENT_ID,
+    HI_UNF_ADVCA_OTP_FUSE_BUTT
+}HI_UNF_ADVCA_OTP_FUSE_E;
+
+/**Defines the attribute of secure boot check.*/
+/**CNcomment: 定义安全启动校验属性结构体*/
+typedef struct hiUNF_ADVCA_OTP_SECURE_BOOT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is secure boot check enable or not*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type*/
+}HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S;
+
+/**Defines the boot flash type.*/
+/**CNcomment: 定义安全启动flash类型结构体*/
+typedef struct hiUNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S
+{
+    HI_BOOL bBootSelCtrl;    /**<0--the boot flash type is defined by chipset pin, 1--the boot flash type is defined by OTP value*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type, only valid when bBootSelCtrl is 1*/
+}HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S;
+
+/**Defines the default attribute of OTP fuse. If one OTP fuse can ONLY be "Enable" or "Disable",
+then we will use this attribute.*/
+/**CNcomment: 定义OTP位默认属性结构体. 适用于一个OTP位的功能
+只是开启或关闭的情况*/
+typedef struct hiUNF_ADVCA_OTP_DEFAULT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is the feature enable or not*/
+}HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S;
+
+/**Defines the attribute of the keyladder level.*/
+/**CNcomment: 定义keyladder级数属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enKeyladderLevel;   /**<Keyladder level*/
+}HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S;
+
+/**Defines the attribute of the JTAG protected mode.*/
+/**CNcomment: 定义JTAG接口保护属性结构体.*/
+typedef struct hiUNF_ADVCA_JTAG_PRT_MODE_ATTR_S
+{
+    HI_UNF_ADVCA_JTAG_MODE_E enJtagMode;    /**<JTAG protection mode*/
+}HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S;
+
+/**Defines the attribute of the keyladder root key.*/
+/**CNcomment: 定义keyladder 根密钥属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S
+{
+    HI_U8 u8RootKey[16];    /**<Root key of the keyladder*/
+}HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S;
+
+/**Defines the attribute of the JTAG key.*/
+/**CNcomment: 定义JTAG接口保护密钥属性结构体.*/
+typedef struct hiUNF_ADVCA_JTAG_KEY_ATTR_S
+{
+    HI_U8 u8JtagKey[8];     /**<JTAG protected key*/
+}HI_UNF_ADVCA_JTAG_KEY_ATTR_S;
+
+/**Defines the attribute of the chip id.*/
+/**CNcomment: 定义chip id属性结构体.*/
+typedef struct hiUNF_ADVCA_CHIPID_ATTR_S
+{
+    HI_U8 au8ChipId[8];       /**<ChipID of the chipset, it is unique every chipset*/
+}HI_UNF_ADVCA_CHIPID_ATTR_S;
+
+/**Defines the attribute of the market segment id.*/
+/**CNcomment: 定义market segment id属性结构体.*/
+typedef struct hiUNF_ADVCA_MARKET_ID_ATTR_S
+{
+    HI_U8 u8MSID[4];    /**<Market Segment ID*/
+}HI_UNF_ADVCA_MARKET_ID_ATTR_S;
+
+/**Defines the attribute of the version id.*/
+/**CNcomment: 定义version id属性结构体.*/
+typedef struct hiUNF_ADVCA_VERSION_ID_ATTR_S
+{
+    HI_U8 u8VersionId[4];   /**<Bootloader Version ID*/
+}HI_UNF_ADVCA_VERSION_ID_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_BL_FUSE_ATTR_S
+{
+    HI_U32 u32VMXBLFuse;
+}HI_UNF_ADVCA_VMX_BL_FUSE_S;
+
+/**Defines the attribute of the tweaked CSA3 IMLB.*/
+/**CNcomment: 定义tweaked CSA3 IMLB属性结构体.*/
+typedef struct hiUNF_ADVCA_ITCSA3_IMLB_ATTR_S
+{
+    HI_U8 au8ItCsa3IMLB[2];   /**<tweaked CSA3 IMLB*/
+}HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S;
+
+/**Defines the attribute of the OTP fuse.*/
+/**CNcomment: 定义OTP fuse属性结构体.*/
+typedef struct hiUNF_ADVCA_OTP_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S          stDefaultAttr; /**<Default attribute, if one fuse can ONLY be "Enable" or "Disable", then we can use this attribute*/
+        HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S      stEnableSecureBoot; /**<Secure boot attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S  stKeyladderLevSel;  /**<Keyladder level attribute*/
+        HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S        stJtagPrtMode; /**<JTAG protected mode attribute*/
+        HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S    stKeyladderRootKey; /**<Keyladder rootkey attribute*/
+        HI_UNF_ADVCA_JTAG_KEY_ATTR_S             stJtagKey;   /**<JTAG key attribute*/
+        HI_UNF_ADVCA_CHIPID_ATTR_S               stChipId;     /**<Chip ID attribute*/
+        HI_UNF_ADVCA_MARKET_ID_ATTR_S            stMarketId;    /**<Market segment ID attribute*/
+        HI_UNF_ADVCA_VERSION_ID_ATTR_S           stVersionId;  /**<Bootloadder version ID attribute*/
+        HI_UNF_ADVCA_VMX_BL_FUSE_S               stVMXBLFuse;  /**<Vmx Bootloadder specific fuse attribute*/
+        HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S          stItCsa3IMLB; /**<tweaked CSA3 IMLB attribute*/
+        HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S  stBootFlashType;   /**<Boot flash type attribute*/
+    }unOtpFuseAttr;
+}HI_UNF_ADVCA_OTP_ATTR_S;
+
+/**Defines the attribute of the keyladder type ID.*/
+/**CNcomment: 定义keyladder类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TYPE_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2 = 0,        /**<CSA2 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3,            /**<CSA3 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_R2R,             /**<R2R keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_SP,              /**<SP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_MISC,            /**<MISC keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_LP,              /**<LP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_TA,              /**<TA keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM,            /**<Google DRM key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_TYPE_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TYPE_E;
+
+/**Defines the attribute of the CSA2 keyladder type ID.*/
+/**CNcomment: 定义CSA2 keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E;
+
+/**Defines the attribute of the CSA3 keyladder type ID.*/
+/**CNcomment: 定义CSA3 keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E;
+
+/**Defines the attribute of the R2R keyladder type ID.*/
+/**CNcomment: 定义R2R keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_R2R_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E;
+
+
+
+/**Defines the attribute of the SP keyladder type ID.*/
+/**CNcomment: 定义SP keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ENABLE = 0,       /**<Use SPE keyladder or not for specal CA system */
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ALG ,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E;
+
+/**Defines the attribute of the MISC keyladder type ID.*/
+/**CNcomment: 定义MISC keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_MISC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ENABLE = 0, /**<Use MISC keyladder or not. Before using the MISC keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E;
+
+/**Defines the attribute of the TA keyladder type ID.*/
+/**CNcomment: 定义TA keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TA_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ENABLE = 0, /**<Use TA keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_LOAD_TRANDATA,   /**<Transformation data protection and loading*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E;
+
+/**Defines the attribute of the CSA2 keyladder.*/
+/**CNcomment: 定义CSA2 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E  enCsa2KlAttr; /**<CSA2 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S;
+
+/**Defines the attribute of the CSA3 keyladder.*/
+/**CNcomment: 定义CSA3 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E  enCsa3KlAttr; /**<CSA3 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                    /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S;
+
+/**Defines the attribute of the R2R keyladder.*/
+/**CNcomment: 定义R2R keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_R2R_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E  enR2RKlAttr; /**<R2R keyladder attribute  ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S;
+
+/**Defines the attribute of the SP keyladder.*/
+/**CNcomment: 定义SP keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E  enSPKlAttr; /**<SP keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use SP keyladder or not. Before using the SP keyladder*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S;
+
+
+
+/**Defines the attribute of the MISC keyladder.*/
+/**CNcomment: 定义MISC keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_MISC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E  enMiscKlAttr; /**<MISC keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use MISC keyladder or not. Before using the MISC keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: 定义TA keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_TA_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E  enTAKlAttr; /**<TA keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use TA keyladder or not. Before using the TA keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 au8SessionKey[16];                                   /**<Session key*/
+    HI_U8 *pu8TranData;                                         /**<Transformation data*/
+    HI_U32 u32TranDataLen;                                  /**<Transformation data length*/
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S;
+
+/**Defines the attribute of the Google DRM keyladder type ID.*/
+/**CNcomment: 定义Google DRM keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENABLE = 0,    /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should set this attribute to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT,       /**<Encrypt clear device key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG,       /**<Get flag*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E;
+
+/**Defines the attribute of Google DRM keyladder.*/
+/**CNcomment: 定义Google DRM keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E  enGDRMKlAttr;
+    HI_BOOL bEnable;                                  /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should be set to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;       /**<Keyladder stage of the session key to be set*/
+    HI_HANDLE hCipherHandle;                    /**<cipher handle, if enStage is HI_UNF_ADVCA_KEYLADDER_LEV3, hCipherHandle should be set*/
+    HI_U8 au8SessionKey[32];                     /**<if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT it is clear device key, if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY, it is session key*/
+    HI_U8 au8Output[16];                          /**<if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT is set, it is encrypted device key, if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG is set, it is flag*/
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S;
+
+/**Defines the attribute of all of the keyladder.*/
+/**CNcomment: 定义所有 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S      stCSA2KlAttr;       /**<CSA2 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S      stCSA3KlAttr;       /**<CSA3 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S       stR2RKlAttr;        /**<R2R keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S        stSPKlAttr;         /**<SP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S      stMiscKlAttr;       /**<MISC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S        stTAKlAttr;         /**<TA keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S      stGDRMAttr;         /**<Google DRM keyladder attribute*/
+    }unKlAttr;
+}HI_UNF_ADVCA_KEYLADDER_ATTR_S;
+
+
+/**Defines the attribute of the CA vendor type ID.*/
+/**CNcomment: 定义CA vendor属性类型ID.*/
+typedef enum hiUNF_ADVCA_CA_VENDOR_OPT_E
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CHIP_CONF_CMAC = 0, /**<To generate a secure message authentication code (MAC) tag for the OTP configuration data*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_CALC,  /**<To calculate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_AUTH,  /**<To authenticate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_ACTIVATION_CODE, /**<To set the activation code for tweaked CSA3.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_VMX_GET_RNG, /**<To get the RNG number, ONLY used for verimatrix currently.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_BUTT
+}HI_UNF_ADVCA_CA_VENDOR_OPT_E;
+
+/**Defines the attribute of chip configuration CMAC.*/
+/**CNcomment: 定义产生OTP数据CMAC属性结构体.*/
+typedef struct hiUNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S
+{
+    HI_U8 au8ChipConfBitm[16]; /**<128bit Chip configuration bit map*/
+    HI_U8 au8ChipConfCmac[16];   /**<128bit Chip configuration CMAC*/
+}HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S;
+
+/**Defines the attribute of the tweak CSA3, Activation Code.*/
+/**CNcomment: 定义CSA3算法需要设置的ACTIVATION CODE.*/
+typedef struct hiUNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S
+{
+    HI_U8 au8CSA3ActCode[16];   /**<128bit tweak CSA3 Activation Code*/
+}HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S;
+
+/**Defines the attribute of the high level code CBC-MAC authentication.*/
+/**CNcomment: 定义上层应用CBC-MAC校验属性结构体.*/
+typedef struct hiUNF_ADVCA_IRDETO_CBCMAC_ATTR_S
+{
+    HI_U8 *pu8InputData;
+    HI_U32 u32InputDataLen;
+    HI_U8 au8OutputCBCMAC[16];
+    HI_U8 au8RefCBCMAC[16];  /**<Reference CBC-MAC*/
+    HI_U32 u32AppLen; /**<High level code length*/
+}HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_GetRNG_S
+{
+    HI_U32 u32RNG;
+}HI_UNF_ADVCA_VMX_GetRNG_S;
+
+/**Defines the attribute of the CA vendor private function.*/
+/**CNcomment: 定义CA厂家私有功能属性结构体.*/
+typedef struct hiADVCA_CA_VENDOR_OPT_S
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_E enCaVendorOpt;
+    union
+    {
+        HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S     stIrdetoChipConfCmac;
+        HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S    stIrdetoCsa3ActCode;
+        HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S             stIrdetoCbcMac;
+        HI_UNF_ADVCA_VMX_GetRNG_S                     stVMXRng;
+    }unCaVendorOpt;
+}HI_UNF_ADVCA_CA_VENDOR_OPT_S;
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/**
+\brief Initializes the advanced CA module CNcomment:初始化advance CA模块 CNend
+\attention \n
+Call this application programming interface (API) before using the advanced CA module.
+The code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:在进行advance CA相关操作前应该首先调用本接口\n
+重复调用本接口，会返回成功 CNend
+\param N/A CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_OPEN_ERR The CA device fails to start CNcomment:HI_ERR_CA_OPEN_ERR 打开CA设备失败 CNend
+\see \n
+::HI_UNF_ADVCA_DeInit
+*/
+HI_S32 HI_UNF_ADVCA_Init(HI_VOID);
+
+/**
+\brief Deinitializes the advanced CA module CNcomment:去初始化advance CA模块 CNend
+\attention \n
+None CNcomment:无 CNend
+\param N/A CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DeInit(HI_VOID);
+
+/**
+\brief Set the ChipId CNcomment:设置ChipId  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+CHIP_ID should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:\n  CNend
+CNcomment:该接口只允许调用一次，不能重复调用，请谨慎使用\n
+CHIP_ID可能已按照CA公司要求设置，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+\param[in] Id chip id CNcomment:Id chip id\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\see \n
+::HI_UNF_ADVCA_SetChipId
+*/
+HI_S32 HI_UNF_ADVCA_SetChipId(HI_U32 Id);
+
+/**
+\brief Obtains the chip ID CNcomment:获取芯片ID  CNend
+\attention \n
+The chip ID is read-only.
+CNcomment:芯片ID只能读不能写 CNend
+\param[out] pu32ChipId Chip ID CNcomment:pu32ChipId   芯片ID  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetChipId(HI_U32 *pu32ChipId);
+
+
+/**
+\brief Obtains the market ID CNcomment:获取Market ID  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] u8MarketId market ID CNcomment:u8MarketId   针对市场的标识序号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetMarketId
+*/
+HI_S32 HI_UNF_ADVCA_GetMarketId(HI_U8 u8MarketId[4]);
+
+/**
+\brief Sets the Market ID CNcomment:设置Market ID  CNend
+\attention \n
+The market ID of the set-top box (STB) is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] u8MarketId market ID CNcomment:u8MarketId   针对市场的标识序号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetMarketId(HI_U8 u8MarketId[4]);
+
+
+/**
+\brief Obtains the serial number of the STB CNcomment:获取机顶盒序列号 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] u8StbSn serial number of the STB CNcomment:u8StbSn   机顶盒序列号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetStbSn
+*/
+HI_S32 HI_UNF_ADVCA_GetStbSn(HI_U8 u8StbSn[4]);
+
+/**
+\brief Sets the serial number of the STB CNcomment:设置机顶盒序列号 CNend
+\attention \n
+The serial number of the STB is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] u8StbSn serial number of the STB CNcomment:u8StbSn   机顶盒序列号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetStbSn(HI_U8 u8StbSn[4]);
+
+/**
+\brief Set the R2R RootKey and lock it. CNcomment:设置R2R RootKey并且锁住。  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+R2R RootKey should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:该接口只允许调用一次，不能重复调用,请谨慎使用该接口\n
+R2RRootKey可能已按照CA公司要求设置，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+\param[in] pkey R2R Root Key CNcomment:pkey  R2R根密钥\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RRootKey(HI_U8 *pkey);
+
+/**
+\brief Obtains the security startup enable status CNcomment:获取安全启动使能状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable: Security startup enable. CNcomment:pbEnable   安全启动是否使能， CNend
+HI_TRUE enabled CNcomment:HI_TRUE 使能，  CNend
+HI_FALSE disabled CNcomment:HI_FALSE 不使能 CNend
+\param[out] penFlashType the startup flash type, only valid when SCS is enable
+CNcomment:penFlashType 仅在安全启动使能时有效，表示安全启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSecBootStat(HI_BOOL *pbEnable,HI_UNF_ADVCA_FLASH_TYPE_E *penFlashType);
+
+/**
+\brief Obtains the mode of the JTAG interface CNcomment:获取JTAG调试口模式 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penJtagMode Mode of the JTAG interface CNcomment:penJtagMode   JTAG调试口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E *penJtagMode);
+
+/**
+\brief Sets the mode of the JTAG interface CNcomment:设置JTAG调试口模式   CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:不支持设置为打开状态。\n
+打开的时候可以关闭或设置为密钥保护状态。\n
+处于密钥保护状态时可以关闭。\n
+关闭之后不能打开和设置为密钥保护状态 CNend
+\param[in] enJtagMode Mode of the JTAG interface CNcomment:enJtagMode   JTAG调试口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN 重复设置 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Obtains the R2R key ladder stage CNcomment:获取R2R key ladder级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the R2R key ladder stage CNcomment:设置R2R key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3
+CNcomment:enStage   key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_LEV2 或者 HI_UNF_ADVCA_KEYLADDER_LEV3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the digital video broadcasting (DVB) key ladder stage CNcomment:获取DVB key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the DVB key ladder stage CNcomment:设置DVB key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the CSA3 key ladder stage CNcomment:获取CSA3 key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the CSA3 key ladder stage CNcomment:设置CSA3 key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Sets session keys for an R2R key ladder CNcomment:为R2R key ladder配置会话密钥    CNend
+\attention \n
+
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetR2RKeyLadderStage first.
+Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由CIPHER模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetR2RKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The R2R decryption fails CNcomment:HI_ERR_CA_R2R_DECRYPT  R2R解密失败 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets session keys for a DVB key ladder CNcomment:为DVB key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetDVBKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets session keys for a CSA3 key ladder CNcomment:为CSA3 key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetDVBKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3SessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Set widevine keyladder session key CNcomment:设置widevine keyladder的各级输入密钥 CNend
+\param[in]  enLevel keyladder level for input CNcomment:enLevel 输入密钥的级数 CNend
+\param[in]  hCipherHandle cipher handle input when level 3 CNcomment:hCipherHandle 当输入第三级数据时，需要传入预先创建好的Cipher的句柄 CNend
+\param[in]  pu8Input input data for keyladder CNcomment:pu8Input  keyladder的输入数据 CNend
+\param[in]  u32InputLen input data length CNcomment:u32InputLen 数据的长度 CNend
+\param[out] pu32GdrmFlag the flag value when level 3 CNcomment:pu32GdrmFlag  当输入第三级别密钥时，输出的GDRM标志  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS               成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   输入参数非法 CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT    功能不支持 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA等待加解密超时 CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK加密失败 CNend
+\see
+\li ::
+*/
+HI_S32 HI_UNF_ADVCA_SetGDRMSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enLevel,
+                                    HI_HANDLE hCipherHandle,
+                                    HI_U8 *pu8Input,
+                                    HI_U32 u32InputLen,
+                                    HI_U32 *pu32GdrmFlag);
+
+
+/**
+\brief Encrypts software protect keys (SWPKs) CNcomment:加密软件保护密钥 CNend
+\attention
+Before the delivery of the STB, you need to read the SWPKs in plain text format from the flash memory, encrypt SWPKs by calling this API, and store the encrypted SWPKs in the flash memory for security startup.
+CNcomment:机顶盒出厂时 从Flash上读取明文的SWPK(Software Protect Key),调用该接口加密,将加密的SWPK存储在Flash中，用于安全启动 CNend
+The fist 8 bytes of the SWPK can't be equal to the last 8 bytes.
+CNcomment:SWPK的前8个字节与后8个字节不能相等 CNend
+This API is only for special CA, please contact Hislicon before usage.
+CNcomment:注意:此接口为特定CA专用，如需使用，请联系海思 CNend
+\param[in]  pPlainSwpk SWPKs in plain text format CNcomment:pPlainSwpk    明文SWPK  CNend
+\param[out] pEncryptedSwpk Encrypted SWPKs CNcomment:pEncryptedSwpk  加密后的SWPK  CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS               成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   输入参数非法 CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT    功能不支持 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA等待加解密超时 CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK加密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EncryptSWPK(HI_U8 *pPlainSwpk,HI_U8 *pEncryptedSwpk);
+
+/**
+\brief Sets the algorithm of the DVB key ladder CNcomment:设置DVB key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the CSA2 key ladder CNcomment:设置CSA3 key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3Alg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the R2R key ladder CNcomment:设置R2R key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the DVB key ladder CNcomment: 获取 DVB key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Obtains the algorithm of the R2R key ladder CNcomment:获取 R2R key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+  \brief set RSA key CNcomment:设置签名校验的RSA公钥 CNeng
+  \attention \n
+  If the mass-produced chipset have been set RSA Key by CA, there's no need to use this API to set RSA Key again.
+  This API can been called only once, please be careful, after setting RSA key, you should lock it by call API
+  HI_UNF_ADVCA_ConfigLockFlag.The length of RSA key must be 512 Bytes.
+  CNcomment:如果量产芯片已经按照CA公司设置RSAKey,则无需再次使用该接口设置RSAKey\n
+     该接口只允许调用一次，不能重复调用,请谨慎使用该接口,并且设置后RSAKey后需要使用接口\n
+     HI_UNF_ADVCA_ConfigLockFlag进行锁定。 RSA key的长度必须为512 Bytes  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA公钥\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetRSAKey(HI_U8 *pkey);
+
+/**
+  \brief set RSA key CNcomment:获取签名校验的RSA公钥 CNend
+  \attention \n
+     RSA key can be read out when only the RSAKey is not locked,The length of RSA key is 512 Bytes.
+     RSA key should have been setting and lock before chipset is delivered to STB Manufacture.
+     Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:该接口仅在RSAkey没有被锁定的情况下，读取出来, RSA key的长度为512 Bytes\n
+     RSA key可能已按照CA公司要求设置并锁定，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA密公钥\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRSAKey(HI_U8 *pkey);
+
+/**
+  \brief set RSA key CNcomment:获取签名校验的RSA密码 CNend
+  \attention \n
+    This API is used to lock RSA KEY/Trustzone OTP\misc keyladder etc.Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:该接口用于锁定RSAkey\Trustzone OTP\misc keyladder等，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+  \param[enType] enType the type you want to lock.  CNcomment:enType  需要锁定的类型\n  CNend
+  \param[pu8ParamIn] pu8ParamIn reserved, default is null. CNcomment:pu8ParamIn  预留，默认为null\n  CNend
+  \param[u32ParamLen] u32ParamLen reserved, default is 0. CNcomment:u32ParamLen  预留，默认为0\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_ConfigLockFlag(HI_UNF_ADVCA_LOCK_TYPE_E enType, HI_U8 *pu8ParamIn, HI_U32 u32ParamLen);
+
+
+/**
+  \brief This function is used to check if the MarketID is already set
+  \attention \n
+  None
+  \param[in] pbIsMarketIdSet: the pointer point to the buffer to store the return value
+  \param[out] pbIsMarketIdSet: save the return value
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_IsMarketIdSet(HI_BOOL *pbIsMarketIdSet);
+
+/**
+  \brief This function is used to get the vendor type of the chipset
+  \attention \n
+  None
+  \param[out] pu32VendorID: The number indicates the vendor id
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVendorID(HI_U32 *pu32VendorID);
+
+/**
+\brief Enables the security startup function and sets the type of flash memory for security startup
+CNcomment:设置安全启动使能,同时指定安全启动的Flash类型 CNend
+\attention \n
+This function can be enabled only and cannot be disabled after being enabled.
+CNcomment:只能使能，使能之后不可修改。 CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBoot(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief Enables the security startup function. This API should be used with the API HI_UNF_ADVCA_SetFlashTypeEx.
+CNcomment:设置安全启动使能，该接口必须和HI_UNF_ADVCA_SetFlashTypeEx配套使用。 CNend
+\attention \n
+\param[in]  None
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBootEx(HI_VOID);
+
+/**
+\brief Sets the type of flash memory for security startup and disable the self boot, which mean that you cannot use the serial port to update the boot. This API should be used with the API HI_UNF_ADVCA_EnableSecBootEx
+CNcomment:指定安全启动的Flash类型，同时关闭自举功能，即不能通过串口升级fastboot。该接口跟HI_UNF_ADVCA_EnableSecBootEx配套使用 CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次 CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetFlashTypeEx(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief  Sets whether to use hardware CWs only CNcomment:设置固定使用硬件CW字 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the CW type (hardware CWs or software CWs) depends on the configuration of the DEMUX.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认根据Demux的配置选择使用硬件CW字还是软件CW字 CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockHardCwSel(HI_VOID);
+
+/**
+\brief Disables the self-boot function CNcomment:关闭SelfBoot功能,也就是boot下不能使用串口/网口升级 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认使能SelfBoot功能 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized.  CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Obtains the self-boot status CNcomment:获取SelfBoot状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbDisable: self-boot status. CNcomment:pbEnable   SelfBoot是否禁用 CNend
+HI_TRUE enabled CNcomment:HI_TRUE 禁用，  CNend
+HI_FALSE disabled CNcomment:HI_FALSE 未禁用 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSelfBootStat(HI_BOOL *pbDisable);
+
+/**
+\brief  Get whether to use hardware CWs only CNcomment:获取固定使用硬件CW字标志 CNend
+\attention
+None CNcomment:无 CNend
+\param[out] pbLock indicates the state of hardware CWs  CNcomment:pbLock 硬件CW字的标志位 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetHardCwSelStat(HI_BOOL *pbLock);
+
+/**
+\brief  Open the SWPK key ladder CNcomment:打开boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderOpen(HI_VOID);
+
+/**
+\brief  Close the SWPK key ladder CNcomment:关闭boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderClose(HI_VOID);
+
+/**
+\brief Obtains the Version ID CNcomment:获取Version ID  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] u8VersionId version ID CNcomment:u8VersionId   版本号标志 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetVersionId
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionId(HI_U8 u8VersionId[4]);
+
+/**
+\brief Sets the Version ID CNcomment:设置Version ID  CNend
+\attention \n
+The version ID of the set-top box (STB) is set before delivery. The version ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] u8VersionId version ID CNcomment:u8VersionId   版本号标志 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetVersionId(HI_U8 u8VersionId[4]);
+
+/**
+\brief  Sets whether to check the boot version CNcomment:设置是否检查Version  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the version check function is disabled
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认不使能version check  CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableVersionCheck(HI_VOID);
+
+/**
+\brief  Get the boot version check flag CNcomment:获取是否检查version的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat boot version check flag CNcomment:pu32Stat    version检查的标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Sets whether to check the MSID in boot area CNcomment:设置是否检查boot area的MSID  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the boot MSID check function is disabled
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认不使能boot MSID check  CNend
+\param none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableBootMSIDCheck(HI_VOID);
+
+/**
+\brief  Get the boot MSID check flag CNcomment:获取是否检查MSID的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat boot MSID check flag CNcomment:pu32Stat    MSID检查的标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootMSIDCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Get the software revision
+CNcomment:获取软件的revision版本号 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] revision string of Revision CNcomment:revision    Revision版本号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRevision(HI_U8 revision[25]);
+
+/**
+\brief  Set the DDR Scramble flag. Normally, this flag has been set as required by CA vendor
+CNcomment:设置DDR加扰标志位，一般高安芯片出厂时已按照CA公司要求设置 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDDRScramble(HI_VOID);
+
+/**
+\brief  Get the DDR Scramble flag
+CNcomment:获取DDR加扰标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat DDR Scramble flag CNcomment:pu32Stat    DDR加扰标志 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDDRScrambleStat(HI_U32 *pu32Stat);
+
+/**
+\brief Sets whether to decrypt the BootLoader CNcomment:设置必须对BootLoader进行解密 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认根据Flash中的数据标识，决定BootLoader是否需要解密 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockBootDecEn(HI_VOID);
+
+/**
+\brief Get the BootLoader Decryption flag CNcomment:获取BootLoader解密的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat BootLoader Decryption flag CNcomment:pu32Stat    Bootloader解密标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootDecEnStat(HI_U32 *pu32Stat);
+
+
+
+
+
+/**
+\brief  Calculte the AES_CMAC value of data
+CNcomment: 计算数据的AES_CMAC 值 CNend
+\attention \n
+None CNcomment:无 CNend
+
+\param[in]  buffer  pointer of data buffer .        CNcomment:数据buffer 指针 CNend
+\param[in]  Length  The length  of data .   CNcomment:数据长度 CNend
+\param[in]  Key   The key used in Calculte the AES_CMAC of data           CNcomment: AES_CMAC 计算中使用的key  CNend
+\param[out]  MAC   The AES_CMAC value          CNcomment:AES_CMAC 值 CNend
+
+\retval ::HI_SUCCESS  Success                 CNcomment:成功 CNend
+\retval ::HI_FAILURE    Failure                     CNcomment:失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_CalculteAES_CMAC(HI_U8 *buffer, HI_U32 Length, HI_U8 Key[16], HI_U8 MAC[16]);
+
+
+
+/**
+\brief Sets the algorithm of the SP key ladder CNcomment:设置SP key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the SP key ladder CNcomment: 获取 SP key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Sets the SP key ladder stage CNcomment:设置SP key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the SP key ladder stage CNcomment:获取SP key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+
+/**
+\brief Sets session keys for a SP key ladder CNcomment:为SP key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetSPKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetSPKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetSPSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key);
+
+/**
+\brief Sets the descramble mode of the SP key ladder CNcomment:设置SP key ladder的解扰算法    CNend
+\attention \n
+You must set a descramble mode before using a key ladder in a session. The default algorithm is HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI.
+It is recommended that you retain the descramble mode in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E enType);
+
+/**
+\brief Obtains the descramble mode of the SP key ladder CNcomment: 获取 SP key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E *pEnType);
+
+/**
+  \brief this function is used by the Novel CA for the encryption and decryption setting
+   CNcomment:Novel内存加解密算法和key配置 CNend
+  \attention \n
+  This function is used for the Novel encryption and decrption
+  CNcomment:  本函数是提供给 Novel 内存加解密方案使用，用作配置加解密过程keyladder算法和key CNend
+  \retval ::HI_SUCCESS Success  CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called  CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelCryptologyConfig(HI_VOID);
+
+/**
+  \brief Used for Novel CA to encrypt the data  CNcomment:Novel内存数据加密 CNend
+  \attention \n
+  None  CNcomment: 无 CNend
+  \param[in]  pPlainText: the buffer to store the data to be encrypted CNcomment:pPlainText 待加密数据指针 CNend
+  \param[in]  TextLen: the length of the data to be encrypted CNcomment:TextLen    待加密数据长度 CNend
+  \param[in]  pCipherText: the buffer to store the encrypted data CNcomment:pCipherText 加密后数据指针 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataEncrypt(HI_U8 *pPlainText, HI_U32 TextLen, HI_U8 *pCipherText);
+
+/**
+  \brief This function is used for Novel to decrypt the data CNcomment:TextNovel内存数据解密 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  pPlainText: point to the data to be decrypted CNcomment:pPlainText 待解密密数据指针 CNend
+  \param[in]  TextLen: the length of the data to be decrypted CNcomment:TextLen    待解密数据长度 CNend
+  \param[in]  pCipherText: the buffer store the decrypted data CNcomment:pCipherText 解密后数据指针 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataDecrypt(HI_U8 *pCipherText, HI_U32 TextLen, HI_U8 *pPlainText);
+
+/**
+\brief Sets oem root key， it's mainly used for widevine keyladder CNcomment:OEM_root_key 主要用于Widevine keyladder    CNend
+\attention \n
+This root key could only be written only once be careful, thanks    CNcomment: 这个密钥只允许写一次,请谨慎操作 CNend
+\param[in] pu8OEMRootKey buffer of the input key    CNcomment:pu8OEMRootKey    输入密钥的buffer  CNend
+\param[in] u32KeyLen key length of the input CNcomment:u32KeyLen     输入密钥的长度，限定为16字节  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOEMRootKey(HI_U8 *pu8OEMRootKey, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to open the DCAS CNcomment:用于打开DCAS CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enAlg: DCAS keyladder algorithm CNcomment:enAlg DCAS keyladder算法 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASOpen(HI_UNF_CIPHER_ALG_E enAlg);
+
+/**
+  \brief This function is used to get the DCAS CHIPID CNcomment:用于获取DCAS CHIPID
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[out]  pu32MSBID: First 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID前4个字节 CNend
+  \param[out]  pu32LSBID: last 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID后4个字节 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDCASChipId(HI_U32 *pu32MSBID, HI_U32 *pu32LSBID);
+
+/**
+  \brief This function is used to set the session key CNcomment:用于设置DCAS session密钥 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enDCASLevel: the DCAS keyladder level CNcomment:enAlg DCAS keyladder级数 CNend
+  \param[in]  pu8Key: the DCAS keyladder session key CNcomment:enAlg DCAS keyladder密钥 CNend
+  \param[in]  pu8Output: the output of the DCAS keyladder CNcomment:pu8Output DCAS keyladder输出 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDCASSessionKey(HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E enDCASLevel, HI_U8 au8Key[16], HI_U8 au8Output[16]);
+
+/**
+  \brief This function is used to close the DCAS keyladder CNcomment:用于关闭DCAS CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASClose(HI_VOID);
+
+/**
+  \brief This function is used to set the OTP fuse. CNcomment:用于设置OTP位 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse 待设置的OTP位ID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr 待设置的OTP位属性 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to get the OTP fuse. CNcomment:用于获取OTP位 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse 待获取的OTP位ID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr 获取的OTP位属性 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to set the keyladder attribute. CNcomment:用于设置keyladder属性 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enKeyLadderType: The keyladder type ID CNcomment:enKeyLadderType Keyladder类型ID CNend
+  \param[in]  pstKeyladderAttr: The keyladder attribute CNcomment:pstKeyladderAttr 待设置的keyladder属性CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetKeyLadderAttr(HI_UNF_ADVCA_KEYLADDER_TYPE_E enKeyLadderType, HI_UNF_ADVCA_KEYLADDER_ATTR_S *pstKeyladderAttr);
+
+/**
+  \brief This function is used to achieve the CA vendor privated function. CNcomment:用于完成CA厂家特有的操作 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enCaVendor: The CA vendor type ID CNcomment:enCaVendor CA vendor类型ID CNend
+  \param[in]  pstCavendorOpt: The parameter to achieve the CA vendor private function CNcomment:pstCavendorOpt 完成CA厂家特有功能需要的参数CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_CaVendorOperation(HI_UNF_ADVCA_VENDORID_E enCaVendor, HI_UNF_ADVCA_CA_VENDOR_OPT_S *pstCaVendorOpt);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ADVCA_H__ */
+
+
diff -uNr git/xbmc/linux/hisi/hi_unf_audio.h unlib/xbmc/linux/hisi/hi_unf_audio.h
--- git/xbmc/linux/hisi/hi_unf_audio.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_audio.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,234 @@
+/******************************************************************************
+
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_audio.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_AUDIO_H__
+#define __HI_UNF_AUDIO_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_audio_codec.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Audio_Common */
+/** @{ */  /** <!-- [Audio_Common] */
+
+/**CNcomment: 定义音频采样率枚举*/
+typedef enum hiUNF_SAMPLE_RATE_E
+{
+    HI_UNF_SAMPLE_RATE_UNKNOWN=0,       /**<Unknown*/ /**<CNcomment: 未知采样频率 */
+    HI_UNF_SAMPLE_RATE_8K    = 8000,    /**<8 kHz sampling rate*/ /**<CNcomment: 8K采样频率 */
+    HI_UNF_SAMPLE_RATE_11K   = 11025,   /**<11.025 kHz sampling rate*/ /**<CNcomment: 11.025K采样频率 */
+    HI_UNF_SAMPLE_RATE_12K   = 12000,   /**<12 kHz sampling rate*/ /**<CNcomment: 12K采样频率 */
+    HI_UNF_SAMPLE_RATE_16K   = 16000,   /**<16 kHz sampling rate*/ /**<CNcomment: 16K采样频率 */
+    HI_UNF_SAMPLE_RATE_22K   = 22050,   /**<22.050 kHz sampling rate*/ /**<CNcomment: 22.050K采样频率 */
+    HI_UNF_SAMPLE_RATE_24K   = 24000,   /**<24 kHz sampling rate*/ /**<CNcomment: 24K采样频率 */
+    HI_UNF_SAMPLE_RATE_32K   = 32000,   /**<32 kHz sampling rate*/ /**<CNcomment: 32K采样频率 */
+    HI_UNF_SAMPLE_RATE_44K   = 44100,   /**<44.1 kHz sampling rate*/ /**<CNcomment: 44.1K采样频率 */
+    HI_UNF_SAMPLE_RATE_48K   = 48000,   /**<48 kHz sampling rate*/ /**<CNcomment: 48K采样频率 */
+    HI_UNF_SAMPLE_RATE_88K   = 88200,   /**<88.2 kHz sampling rate*/ /**<CNcomment: 88.2K采样频率 */
+    HI_UNF_SAMPLE_RATE_96K   = 96000,   /**<96 kHz sampling rate*/ /**<CNcomment: 96K采样频率 */
+    HI_UNF_SAMPLE_RATE_176K  = 176400,  /**<176 kHz sampling rate*/ /**<CNcomment: 176K采样频率 */
+    HI_UNF_SAMPLE_RATE_192K  = 192000,  /**<192 kHz sampling rate*/ /**<CNcomment: 192K采样频率 */
+
+    HI_UNF_SAMPLE_RATE_BUTT
+} HI_UNF_SAMPLE_RATE_E;
+
+/**Defines the bit depth during audio sampling.*/
+/**CNcomment: 定义音频采样位宽枚举*/
+typedef enum hiUNF_BIT_DEPTH_E
+{
+    HI_UNF_BIT_DEPTH_UNKNOWN =0,/**<Unknown*/ /**<CNcomment: 未知采样位宽  */
+    HI_UNF_BIT_DEPTH_8  = 8,    /**< 8-bit depth*/ /**<CNcomment: 8位采样位宽  */
+    HI_UNF_BIT_DEPTH_16 = 16,   /**<16-bit depth*/ /**<CNcomment: 16位采样位宽 */
+    HI_UNF_BIT_DEPTH_18 = 18,   /**<18-bit depth*/ /**<CNcomment: 18位采样位宽 */
+    HI_UNF_BIT_DEPTH_20 = 20,   /**<20-bit depth*/ /**<CNcomment: 20位采样位宽 */
+    HI_UNF_BIT_DEPTH_24 = 24,   /**<24-bit depth*/ /**<CNcomment: 24位采样位宽 */
+    HI_UNF_BIT_DEPTH_32 = 32,   /**<32-bit depth*/ /**<CNcomment: 32位采样位宽 */
+
+    HI_UNF_BIT_DEPTH_BUTT
+} HI_UNF_BIT_DEPTH_E;
+
+/**Defines the mode of audio channels.*/
+/**CNcomment: 定义音频声道模式枚举*/
+typedef enum hiUNF_TRACK_MODE_E
+{
+    HI_UNF_TRACK_MODE_STEREO = 0,          /**<Stereo*/ /**<CNcomment: 立体声*/
+    HI_UNF_TRACK_MODE_DOUBLE_MONO,         /**<Data is output after being mixed in the audio-left channel and audio-right channel.*/ /**<CNcomment: 左右声道混合后输出*/
+    HI_UNF_TRACK_MODE_DOUBLE_LEFT,         /**<The audio-left channel and audio-right channel output the data of the audio-left channel.*/ /**<CNcomment: 左右声道输出左声道数据*/
+    HI_UNF_TRACK_MODE_DOUBLE_RIGHT,        /**<The audio-left channel and audio-right channel output the data of the audio-right channel.*/ /**<CNcomment: 左右声道输出右声道数据*/
+    HI_UNF_TRACK_MODE_EXCHANGE,            /**<Data is output after being exchanged in the audio-left channel and audio-right channel.*/ /**<CNcomment: 左右声道数据交换输出 */
+    HI_UNF_TRACK_MODE_ONLY_RIGHT,          /**<Only the data in the audio-right channel is output.*/ /**<CNcomment: 只输出右声道数据*/
+    HI_UNF_TRACK_MODE_ONLY_LEFT,           /**<Only the data in the audio-left channel is output.*/ /**<CNcomment: 只输出左声道数据*/
+    HI_UNF_TRACK_MODE_MUTED,               /**<Mute*/ /**<CNcomment: 静音*/
+
+    HI_UNF_TRACK_MODE_BUTT
+} HI_UNF_TRACK_MODE_E;
+
+/**Defines the attributes of the audio decoder.*/
+/**CNcomment: 定义音频解码器属性结构*/
+typedef struct hiUNF_ACODEC_ATTR_S
+{
+    HA_CODEC_ID_E        enType;                    /**<Audio decoder type*/ /**<CNcomment: 音频解码类型*/
+    HI_HADECODE_OPENPARAM_S stDecodeParam;   /**<Audio decoder parameter*/ /**<CNcomment: 音频解码参数*/
+} HI_UNF_ACODEC_ATTR_S;
+
+/**Defines the attributes of audio encoder.*/
+/**CNcomment: 定义音频编码器属性结构*/
+typedef struct hiUNF_AENC_ATTR_S
+{
+    HI_U32         enAencType;              /**<Audio encoder type*/ /**<CNcomment: 音频编码类型*/
+    HI_HAENCODE_OPENPARAM_S   sOpenParam;   /**<Audio encoder parameter*/ /**<CNcomment: 音频编码参数*/
+} HI_UNF_AENC_ATTR_S;
+
+/**Defines the information about audio streams.*/
+/**CNcomment: 定义音频码流信息结构*/
+typedef struct hiUNF_ACODEC_STREAMINFO_S
+{
+    HI_U32               enACodecType;     /**<Audio encoding type*/ /**<CNcomment: 音频编码类型*/
+    HI_U32               enSampleRate;     /**<Audio sampling rate*/ /**<CNcomment: 音频采样率*/
+    HI_UNF_BIT_DEPTH_E   enBitDepth;       /**<Bit depth during audio sampling*/ /**<CNcomment: 音频采样位宽*/
+    HI_U32               u32Channel;       /**<Audio output channel*//**<CNcomment: 音频输出声道数*/
+    HI_U32               u32BitRate;       /**<Audio output Rate*//**<CNcomment: 音频输出码率*/
+} HI_UNF_ACODEC_STREAMINFO_S;
+
+/**Defines the I2S(Inter-IC Sound) mode.*/
+/**CNcomment: 定义音频I2S接口模式枚举*/
+typedef enum hiHI_UNF_I2S_MODE_E
+{
+    HI_UNF_I2S_STD_MODE = 0,     /**<I2S standard mode*/ /**<CNcomment: I2S标准模式*/
+    HI_UNF_I2S_PCM_MODE,         /**<pcm mode*/ /**<CNcomment: PCM模式*/
+    HI_UNF_I2S_TDM_MODE,         /**<TDM mode*/ /**<CNcomment: TDM模式*/
+
+    HI_UNF_I2S_MODE_BUTT
+} HI_UNF_I2S_MODE_E;
+
+/**Defines the I2S(Inter-IC Sound) master clock.*/
+/**CNcomment: 定义音频I2S接口工作时钟枚举*/
+typedef enum hiHI_UNF_I2S_MCLK_SEL_E
+{
+    HI_UNF_I2S_MCLK_128_FS = 0,      /* mclk 128*fs  */
+    HI_UNF_I2S_MCLK_256_FS,          /* mclk 256*fs */
+    HI_UNF_I2S_MCLK_384_FS,          /* mclk 384*fs */
+    HI_UNF_I2S_MCLK_512_FS,          /* mclk 512*fs */
+    HI_UNF_I2S_MCLK_768_FS,          /* mclk 768*fs */
+    HI_UNF_I2S_MCLK_1024_FS,         /* mclk 1024*fs */
+    HI_UNF_I2S_MCLK_BUTT
+} HI_UNF_I2S_MCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) bclk clock.*/
+typedef enum hiHI_UNF_I2S_BCLK_SEL_E
+{
+     HI_UNF_I2S_BCLK_1_DIV = 1,           /* bclk=mclk/1  */
+     HI_UNF_I2S_BCLK_2_DIV = 2,           /* bclk=mclk/2  */
+     HI_UNF_I2S_BCLK_3_DIV = 3,           /* bclk=mclk/3  */
+     HI_UNF_I2S_BCLK_4_DIV = 4,           /* bclk=mclk/4  */
+     HI_UNF_I2S_BCLK_6_DIV = 6,           /* bclk=mclk/6  */
+     HI_UNF_I2S_BCLK_8_DIV = 8 ,          /* bclk=mclk/8  */
+     HI_UNF_I2S_BCLK_12_DIV= 12,          /* bclk=mclk/12 */
+     HI_UNF_I2S_BCLK_24_DIV= 24,          /* bclk=mclk/24 */
+     HI_UNF_I2S_BCLK_32_DIV= 32,          /* bclk=mclk/32 */
+     HI_UNF_I2S_BCLK_48_DIV= 48,          /* bclk=mclk/48 */
+     HI_UNF_I2S_BCLK_64_DIV= 64,          /* bclk=mclk/64 */
+     HI_UNF_I2S_BCLK_BUTT
+} HI_UNF_I2S_BCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) channels.*/
+/**CNcomment: 定义音频I2S接口音频通道枚举*/
+typedef enum hiHI_UNF_I2S_CHNUM_E
+{
+    HI_UNF_I2S_CHNUM_1  = 1,
+    HI_UNF_I2S_CHNUM_2  = 2,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_8  = 8,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_16 = 16,             /* only work for TDM mode */
+
+    HI_UNF_I2S_BUTT,
+} HI_UNF_I2S_CHNUM_E;
+
+/**Defines the I2S(Inter-IC Sound) bit depth.*/
+typedef enum hiHI_UNF_I2S_BITDEPTH_E
+{
+    HI_UNF_I2S_BIT_DEPTH_16 = 16,
+    HI_UNF_I2S_BIT_DEPTH_24 = 24,         /* only work for I2S mode */
+} HI_UNF_I2S_BITDEPTH_E;
+
+/**Defines the I2S(Inter-IC Sound) data valid after frame sync clock at PCM mode .*/
+/**CNcomment: 定义音频I2S接口，数据有效延迟周期，仅PCM模式有效*/
+typedef enum hiHI_UNF_I2S_PCMDELAY_E
+{
+    HI_UNF_I2S_PCM_0_DELAY = 0,           /* 0  bclk cycles delay*/
+    HI_UNF_I2S_PCM_1_DELAY = 1,           /* 1  bclk cycles delay*/
+    HI_UNF_I2S_PCM_8_DELAY = 8,           /* 8  bclk cycles delay*/
+    HI_UNF_I2S_PCM_16_DELAY = 16,         /* 16 bclk cycles delay*/
+    HI_UNF_I2S_PCM_17_DELAY = 17,         /* 17 bclk cycles delay*/
+    HI_UNF_I2S_PCM_24_DELAY = 24,         /* 24 bclk cycles delay*/
+    HI_UNF_I2S_PCM_32_DELAY = 32,         /* 32 bclk cycles delay*/
+    HI_UNF_I2S_PCM_DELAY_BUTT
+} HI_UNF_I2S_PCMDELAY_E;
+
+/**Defines the I2S(Inter-IC Sound) attribute .*/
+/**CNcomment: 定义音频I2S接口配置属性*/
+typedef struct hiHI_UNF_I2S_ATTR_S
+{
+    HI_BOOL               bMaster;           /* HI_TRUE:master, HI_FALSE: slave */
+    HI_UNF_I2S_MODE_E     enI2sMode;
+    HI_UNF_I2S_MCLK_SEL_E enMclkSel;
+    HI_UNF_I2S_BCLK_SEL_E enBclkSel;
+    HI_UNF_I2S_CHNUM_E    enChannel;
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;
+    HI_BOOL               bPcmSampleRiseEdge; /* only work for PCM mode. HI_TRUE:sample data at positive edge of bclk, HI_FALSE: sample data at  negative edge of bclk */
+    HI_UNF_I2S_PCMDELAY_E enPcmDelayCycle;    /* only work for PCM mode.  */
+} HI_UNF_I2S_ATTR_S;
+
+/**Defines the information about audio frames.*/
+/**CNcomment: 定义音频帧信息结构*/
+typedef struct hiUNF_AO_FRAMEINFO_S
+{
+    /** s32BitPerSample: (PCM) Data depth, and format of storing the output data
+          If the data depth is 16 bits, 16-bit word memory is used.
+          If the data depth is greater than 16 bits, 32-bit word memory is used, and data is stored as left-aligned data. That is, the valid data is at upper bits.
+     */
+    /**CNcomment: s32BitPerSample: (PCM) 数据位宽设置. 输出存放格式
+          等于16bit:   占用16bit word内存
+          大于16bit:   占用32bit word内存, 数据左对齐方式存放(有效数据在高位)
+     */
+    HI_S32  s32BitPerSample;       /**<Data depth*/ /**<CNcomment: 数据位宽*/
+    HI_BOOL bInterleaved;          /**<Whether the data is interleaved*/ /**<CNcomment: 数据是否交织*/
+    HI_U32  u32SampleRate;         /**<Sampling rate*/ /**<CNcomment: 采样率*/
+    HI_U32  u32Channels;           /**<Number of channels*/ /**<CNcomment: 通道数量*/
+    HI_U32  u32PtsMs;              /**<Presentation time stamp (PTS)*/ /**<CNcomment: 时间戳*/
+    HI_S32 *ps32PcmBuffer;         /**<Pointer to the buffer for storing the pulse code modulation (PCM) data*/ /**<CNcomment: PCM数据缓冲指针*/
+    HI_S32 *ps32BitsBuffer;        /**<Pointer to the buffer for storing the stream data*/ /**<CNcomment: 码流数据缓冲指针*/
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sampling points of the PCM data*/ /**<CNcomment: PCM数据采样点数量*/
+    HI_U32  u32BitsBytesPerFrame;  /**<IEC61937 data size*/ /**<CNcomment: IEC61937数据长度*/
+    HI_U32  u32FrameIndex;         /**<Frame ID*/ /**<CNcomment: 帧序号 */
+    HI_U32  u32IEC61937DataType;   /**<IEC61937 Data Type*/ /**<CNcomment: IEC61937数据类型标识，低8bit为IEC数据类型 */
+} HI_UNF_AO_FRAMEINFO_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_AUDIO_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_avplay.h unlib/xbmc/linux/hisi/hi_unf_avplay.h
--- git/xbmc/linux/hisi/hi_unf_avplay.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_avplay.h	2018-02-07 19:44:03.419778700 +0800
@@ -0,0 +1,1534 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_avplay.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/21
+  Description   :
+  History       :
+  1.Date        : 2009/12/21
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio/video player (AVPLAY) module.
+          CNcomment:提供AVPLAY的相关信息 CNend
+ */
+#ifndef __HI_UNF_AVPLAY_H__
+#define __HI_UNF_AVPLAY_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*********************************error  macro******************************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**Highest priority of the video decoder*/
+/**CNcomment:视频解码器的最大优先级 */
+#define HI_UNF_VCODEC_MAX_PRIORITY  16
+
+
+/**Defines the buffer ID required in an AVPLAY.*/
+/**CNcomment:定义AV播放器中需要的BufferID枚举类型 */
+typedef enum hiUNF_AVPLAY_BUFID_E
+{
+    HI_UNF_AVPLAY_BUF_ID_ES_VID  = 0,       /**<ID of the buffer for storing the video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器ES视频Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD,            /**<ID of the buffer for storing the audio ESs played by an AVPLAY*//**<CNcommentAV播放器ES音频Buffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD_AD,         /**<ID of the buffer for storing the AD audio ESs played by an AVPLAY*//**<CNcommentAV播放器AD ES音频Buffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_BL,     /**<ID of the buffer for storing the HDR BL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR BL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_EL,     /**<ID of the buffer for storing the HDR EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR EL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_DL,     /**<ID of the buffer for storing the HDR BL+EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR BL+EL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_BUTT
+} HI_UNF_AVPLAY_BUFID_E;
+
+/**Defines the type of a media channel.*/
+/**CNcomment:定义媒体通道类型. */
+typedef enum hiUNF_AVPLAY_MEDIA_CHAN
+{
+    HI_UNF_AVPLAY_MEDIA_CHAN_AUD  = 0x01,  /**<Audio channel*//**<CNcomment: 音频通道 */
+    HI_UNF_AVPLAY_MEDIA_CHAN_VID  = 0x02,  /**<Video channel*//**<CNcomment: 视频通道 */
+
+    HI_UNF_AVPLAY_MEDIA_CHAN_BUTT = 0x8
+} HI_UNF_AVPLAY_MEDIA_CHAN_E;
+
+/**Defines the type of an input stream interface.*/
+/**CNcomment:定义数据输入流接口类型 */
+typedef enum hiUNF_AVPLAY_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_TS = 0,   /**<Transport stream (TS)*//**<CNcomment:TS码流 */
+    HI_UNF_AVPLAY_STREAM_TYPE_ES,       /**<ES stream*//**<CNcomment:ES码流 */
+
+    HI_UNF_AVPLAY_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_STREAM_TYPE_E;
+
+/**Defines the stream attributes.*/
+/**CNcomment:定义码流属性的结构体 */
+typedef struct hiUNF_AVPLAY_STREAM_ATTR_S
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_E enStreamType;   /**<Stream type*//**<CNcomment:码流类型 */
+
+    HI_U32                      u32VidBufSize;  /**<Video buffer size*//**<CNcomment: 视频缓冲大小 */
+    HI_U32                      u32AudBufSize;  /**<Audio buffer size*//**<CNcomment: 音频缓冲大小 */
+
+} HI_UNF_AVPLAY_STREAM_ATTR_S;
+
+/**Supported synchronization control mode*/
+/**CNcomment:支持的同步控制模式 */
+typedef enum hiUNF_SYNC_REF_E
+{
+    HI_UNF_SYNC_REF_NONE = 0, /**<Free playing without synchronization*//**<CNcomment: 自由播放 */
+    HI_UNF_SYNC_REF_AUDIO,    /**<Audio-based synchronization*//**<CNcomment: 以音频为准 */
+    HI_UNF_SYNC_REF_VIDEO,    /**<Video-based synchronization*//**<CNcomment: 以视频为准 */
+    HI_UNF_SYNC_REF_PCR,      /**<Program Clock Reference (PCR)-based synchronization*//**<CNcomment: 以PCR（Program Clock Reference）为准 */
+    HI_UNF_SYNC_REF_SCR,      /**<System Clock Reference (SCR)-based synchronization*//**<CNcomment: 以SCR (System Clock Reference) 为准 */
+
+    HI_UNF_AVPLAY_SYNC_REF_BUTT
+} HI_UNF_SYNC_REF_E;
+
+/**Defines the status of a buffer.*/
+/**CNcomment:定义使用的缓冲区状态枚举类型 */
+typedef enum hiUNF_AVPLAY_BUF_STATE_E
+{
+    HI_UNF_AVPLAY_BUF_STATE_EMPTY = 0,   /**<The buffer is idle.*//**<CNcomment: 缓冲区空闲 */
+    HI_UNF_AVPLAY_BUF_STATE_LOW,         /**<The buffer usage is too low.*//**<CNcomment: 缓冲区占用率过低 */
+    HI_UNF_AVPLAY_BUF_STATE_NORMAL,      /**<The buffer works normally.*//**<CNcomment: 缓冲区使用正常 */
+    HI_UNF_AVPLAY_BUF_STATE_HIGH,        /**<The buffer usage is too high.*//**<CNcomment: 缓冲区占用率过高 */
+    HI_UNF_AVPLAY_BUF_STATE_FULL,        /**<The buffer is full.*//**<CNcomment: 缓冲区已满 */
+
+    HI_UNF_AVPLAY_BUF_STATE_BUTT
+}HI_UNF_AVPLAY_BUF_STATE_E;
+
+/**Defines the type of pts channel.*/
+/** CNcomment:定义PTS通道类型 */
+typedef enum hiUNF_SYNC_PTS_CHAN_E
+{
+    HI_UNF_SYNC_PTS_CHAN_VID,   /**<Video pts channel.*//**<CNcomment:视频PTS通道 */
+    HI_UNF_SYNC_PTS_CHAN_AUD,   /**<Audio pts channel.*//**<CNcomment:音频PTS通道 */
+    HI_UNF_SYNC_PTS_CHAN_PCR,   /**<Pcr channel.*//**<CNcomment:PCR通道 */
+
+    HI_UNF_SYNC_PTS_CHAN_BUTT
+}HI_UNF_SYNC_PTS_CHAN_E;
+
+/**Defines the parameters of pts jump.*/
+/** CNcomment:定义PTS跳变参数的结构体 */
+typedef struct hiUNF_SYNC_PTSJUMP_PARAM_S
+{
+    HI_UNF_SYNC_PTS_CHAN_E  enPtsChan;  /**<Pts channel.*//**<CNcomment:PTS通道 */
+    HI_BOOL                 bLoopback;  /**<Loopback or not.*//**<CNcomment:是否环回 */
+    HI_U32                  u32FirstPts;/**<The first pts.*//**<CNcomment:第一个PTS */
+    HI_U32                  u32FirstValidPts;/**<The first valid pts.*//**<CNcomment:第一个有效PTS */
+    HI_U32                  u32CurSrcPts;   /**<The current src pts.*//**<CNcomment:当前原始PTS */
+    HI_U32                  u32CurPts;      /**<The current pts.*//**<CNcomment:当前PTS */
+    HI_U32                  u32LastSrcPts;  /**<The last src pts.*//**<CNcomment:上一个原始PTS */
+    HI_U32                  u32LastPts;     /**<The last pts.*//**<CNcomment:上一个PTS */
+}HI_UNF_SYNC_PTSJUMP_PARAM_S;
+
+/**Defines the parameters of synchronization status change*/
+/** CNcomment:定义同步状态变更参数的结构体 */
+typedef struct hiUNF_SYNC_STAT_PARAM_S
+{
+     HI_S32          s32VidAudDiff;     /**<The diffrence between video and audio frames*//**<CNcomment: 音视频差值 */
+     HI_S32          s32VidPcrDiff;     /**<The diffrence between video frame and pcr*//**<CNcomment: 视频PCR差值 */
+     HI_S32          s32AudPcrDiff;     /**<The diffrence between audio frame and pcr*//**<CNcomment: 音频PCR差值 */
+     HI_U32          u32VidLocalTime;   /**<Local video synchronization reference time*//**<CNcomment: 视频本地时间 */
+     HI_U32          u32AudLocalTime;   /**<Local audio synchronization reference time*//**<CNcomment: 音频本地时间 */
+     HI_U32          u32PcrLocalTime;   /**<Local pcr synchronization reference time*//**<CNcomment: PCR本地时间 */
+}HI_UNF_SYNC_STAT_PARAM_S;
+
+/*Type of the event callback function*/
+/**CNcomment: 事件回调函数类型 */
+typedef enum hiUNF_AVPLAY_EVENT_E
+{
+    HI_UNF_AVPLAY_EVENT_EOS,                   /**<The end of stream (EOS) operation is performed, NULL*//**<CNcomment: EOS执行结束, NULL.*/
+    HI_UNF_AVPLAY_EVENT_STOP,                  /**<The stop operation is performed, NULL*//**<CNcomment: STOP执行结束, NULL.*/
+    HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*//**<CNcomment: 媒体缓存队列状态变化, HI_UNF_AVPLAY_BUF_STATE_E.*/
+    HI_UNF_AVPLAY_EVENT_NORM_SWITCH,           /**<Standard switch, HI_UNF_NORMCHANGE_PARAM_S*//**<CNcomment: 制式切换, HI_UNF_NORMCHANGE_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE,   /**<3D Frame packing change, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E*//**<CNcomment: 3D帧类型变化, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E .*/
+    HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME,         /**<New video frame, HI_UNF_VO_FRAMEINFO_S*//**<CNcomment: 新视频帧, HI_UNF_VO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME,         /**<New audio frame, HI_UNF_AO_FRAMEINFO_S*//**<CNcomment: 新音频帧, HI_UNF_AO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_USER_DATA,         /**<New video user data, HI_UNF_VIDEO_USERDATA_S*//**<CNcomment: 新视频用户数据, HI_UNF_VIDEO_USERDATA_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_AUD_ES,            /**<New audio ES data, HI_UNF_ES_BUF_S*//**<CNcomment: 新音频ES数据, HI_UNF_ES_BUF_S .*/
+    HI_UNF_AVPLAY_EVENT_IFRAME_ERR,            /**<I frame decode error*//**<CNcomment: 解码I帧错误 .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP,         /**<Pts Jump, HI_UNF_SYNC_PTSJUMP_PARAM_S * *//**<CNcomment: PTS跳变, HI_UNF_SYNC_PTSJUMP_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE,      /**<Synchronization status change, HI_UNF_SYNC_STAT_PARAM_S * *//**<CNcomment: 同步状态变更, HI_UNF_SYNC_STAT_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_VID_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE*//**<CNcomment: 视频缓存队列状态变化, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE*//**<CNcomment: 音频缓存队列状态变化, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT,         /**<The video stream is unsupport*//**<CNcomment: 视频码流不支持*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO,         /**<frame error ratio *//**<CNcomment: 图像帧出错比例*/
+    HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE,       /**<audio info change, HI_UNF_ACODEC_STREAMINFO_S *//**<CNcomment: 音频信息变化，HI_UNF_ACODEC_STREAMINFO_S*/
+    HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT,         /**<unsupported audio *//**<CNcomment: 不支持的音频*/
+    HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR,         /**<audio frame error *//**<CNcomment: 音频帧出错*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE,          /**<the setting vid codec type is error, HI_UNF_VCODEC_TYPE_E*//**<CNcomment: 设置的视频协议类型错误, HI_UNF_VCODEC_TYPE_E*/
+    HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED, /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: 第一帧已被显示*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME,         /**<vid frame decode error.*/ /**<CNcomment: 解码视频帧错误*/
+    HI_UNF_AVPLAY_EVENT_STATUS_REPORT,         /**<avplay status info, HI_UNF_AVPLAY_STATUS_INFO_S*/ /**<CNcomment: 播放器状态信息*/
+    HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO,        /**<Video frame status info, HI_UNF_VIDEO_FRM_STATUS_INFO_S*/ /**<CNcomment: 视频帧状态信息*/
+    HI_UNF_AVPLAY_EVENT_VID_START_POS,         /**<the peek frame first pts, HI_U32*/ /**<CNcomment: peek帧pts, HI_U32*/
+    HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME,    /**<Estimated time of display, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/ /**<CNcomment: 视频帧预显示时间, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/
+    HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE,   /**<HDCP strategy change, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S*//**<CNcomment:HDCP 保护策略改变, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_BUTT
+} HI_UNF_AVPLAY_EVENT_E;
+
+/**Mode of processing the buffer overflow*/
+/**CNcomment: 缓冲溢出处理类型  */
+typedef enum hiUNF_AVPLAY_OVERFLOW_E
+{
+    HI_UNF_AVPLAY_OVERFLOW_RESET,              /**<Reset during overflow*//**<CNcomment: 溢出时进行复位  */
+    HI_UNF_AVPLAY_OVERFLOW_DISCARD,            /**<Discard during overflow*//**<CNcomment: 溢出时进行丢弃  */
+    HI_UNF_AVPLAY_OVERFLOW_BUTT
+} HI_UNF_AVPLAY_OVERFLOW_E;
+
+/**Defines the parameters of HDCP output control */
+/**CNcomment: 定义HDCP输出控制相关参数*/
+typedef struct hiUNF_AVPLAY_HDCPSTRATEGY_PARAM_S
+{
+    HI_U32 u32ImageWidth;                     /**<Width of image allowed by HDCP strategy*/ /**<CNcomment: 当前码流 HDCP 策略允许输出的图像分辨率宽度(仅在tvp模式下有效)*/
+    HI_U32 u32ImageHeight;                    /**<Height of image allowed by HDCP strategy*/ /**<CNcomment: 当前码流 HDCP 策略允许输出的图像分辨率高度(仅在tvp模式下有效)*/
+}HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S;
+
+/**Defines the type of the event callback function.*/
+/**CNcomment: 定义事件回调函数枚举类型 */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para);
+
+/**Defines the type of the event callback function.*/
+/**CNcomment: 定义事件回调函数枚举类型 */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN64)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID *pPara);
+
+/**Defines the attribute of audio security.*/
+/**CNcomment: 定义音频安全属性结构体*/
+typedef struct hiUNF_AVPLAY_AUD_SECURITY_ATTR_S
+{
+    HI_BOOL    bEnable; /**<Audio dmx channel is security mode or not*//**<CNcomment: 音频DMX通道是否为安全模式*/
+}HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S;
+
+/**Defines the attribute ID of an AVPLAY.*/
+/**CNcomment: 定义AV播放器属性ID枚举类型 */
+typedef enum hiUNF_AVPLAY_ATTR_ID_E
+{
+    HI_UNF_AVPLAY_ATTR_ID_STREAM_MODE = 0,  /**<Playing mode, HI_UNF_AVPLAY_ATTR_S*//**<CNcomment: 播放模式, HI_UNF_AVPLAY_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_ADEC,             /**<Audio attribute, HI_UNF_ACODEC_ATTR_S*//**<CNcomment: 音频属性, HI_UNF_ACODEC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_VDEC,             /**<Video attribute, HI_UNF_VCODEC_ATTR_S*//**<CNcomment: 视频属性, HI_UNF_VCODEC_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_AUD_PID,          /**<Audio packet identifier (PID), HI_U32*//**<CNcomment: 音频PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_VID_PID,          /**<Video PID, HI_U32*//**<CNcomment: 视频PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_PCR_PID,          /**<PCR PID, HI_U32*//**<CNcomment: PCR PID, HI_U32.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_SYNC,             /**<Synchronization attribute, HI_UNF_SYNC_ATTR_S*//**<CNcomment: 同步属性, HI_UNF_SYNC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_AFD,              /**<Whether to enable the active format descriptor (AFD), HI_BOOL* *//**<CNcomment: AFD 是否开启， HI_BOOL * .*/
+    HI_UNF_AVPLAY_ATTR_ID_OVERFLOW,         /**<Overflow processing type, HI_UNF_AVPLAY_OVERFLOW_E* *//**<CNcomment: 溢出处理类型 , HI_UNF_AVPLAY_OVERFLOW_E * .*/
+
+    HI_UNF_AVPLAY_ATTR_ID_MULTIAUD,         /**<Multiple audio attribute,  HI_UNF_AVPLAY_MULTIAUD_ATTR_S **//**<CNcomment: 多音轨属性, HI_UNF_AVPLAY_MULTIAUD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM,    /**<Frame Rate Parameter, HI_UNF_AVPLAY_FRMRATE_PARAM_S * *//**<CNcomment:帧率参数,HI_UNF_AVPLAY_FRMRATE_PARAM_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMPACK_TYPE,     /**<3D Frame Packing Type, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * *//**<CNcomment:3D帧的打包类型,HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * .*/
+    HI_UNF_AVPLAY_ATTR_ID_LOW_DELAY,        /**<Low Delay Attr, HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * *//**<CNcomment: 低延时属性 , HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_TVP,              /**<Trusted Video Path Attr, HI_UNF_AVPLAY_TVP_ATTR_S * *//**<CNcomment: 安全视频通路属性 , HI_UNF_AVPLAY_TVP_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD,               /**<MS12 Attr, HI_UNF_AVPLAY_AD_ATTR_S * *//**<CNcomment: MS12通路属性 , HI_UNF_AVPLAY_AD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_HDR,              /**<HDR Attr, HI_UNF_AVPLAY_HDR_ATTR_S * *//**<CNcomment: HDR通路属性 , HI_UNF_AVPLAY_HDR_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AUD_SECURITY,     /**<Dmx audio channel security mode, HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * *//**<CNcomment: 音频安全属性 , HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD_PID,           /**<AD program id*/ /**<CNcomment: AD流PID,HI_S32*/
+    HI_UNF_AVPLAY_ATTR_ID_START_POSITION,   /**< Set video start play position, HI_UNF_AVPLAY_START_POSITION_ATTR_S * *//**<CNcomment: 设置视频起播点， HI_UNF_AVPLAY_START_POSITION_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_BUTT
+} HI_UNF_AVPLAY_ATTR_ID_E;
+
+/**Defines the stream type of HDR.*/
+/**CNcomment: 定义DOLBY HDR码流类型 */
+typedef enum hiUNF_AVPLAY_HDR_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_SINGLE_VES = 0,    /**<Dolby Vision Dual layer Single VES Format*/ /**<CNcomment: 单流双层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_DUAL_VES,          /**<Dolby Vision Dual Layer Dual VES Format*/ /**<CNcomment: 双流双层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_SL_VES,               /**<Dolby Vision Single Layer VES Format*/ /**<CNcomment: 单流单层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_HDR_STREAM_TYPE_E;
+
+/**Defines the attribute of low delay.*/
+/**CNcomment: 定义低延时属性结构体*/
+typedef struct hiUNF_AVPLAY_LOW_DELAY_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is low delay enable or not*//**<CNcomment: 低延时是否使能*/
+}HI_UNF_AVPLAY_LOW_DELAY_ATTR_S;
+
+/**Defines the attribute of trust video path.*/
+/**CNcomment: 定义安全视频通路属性结构体*/
+typedef struct hiUNF_AVPLAY_TVP_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is trusted video path enable or not*//**<CNcomment: 安全视频通路是否使能*/
+}HI_UNF_AVPLAY_TVP_ATTR_S;
+
+/**Defines the audio/video synchronization .*/
+/**CNcomment: 定义音视频同步调整区间 */
+typedef struct hiUNF_SYNC_REGION_S
+{
+    HI_S32                s32VidPlusTime;        /**<Plus time range during video synchronization*//**<CNcomment: 视频同步超前的时间范围 */
+    HI_S32                s32VidNegativeTime;    /**<Negative time range during video synchronization*//**<CNcomment: 视频同步落后的时间范围 */
+    HI_BOOL               bSmoothPlay;           /**<Slow playing enable*//**<CNcomment: 慢放使能 */
+} HI_UNF_SYNC_REGION_S;
+
+/**Defines the audio/video synchronization attributes.*/
+/**CNcomment: 定义音视频同步属性 */
+typedef struct hiUNF_SYNC_ATTR_S
+{
+    HI_UNF_SYNC_REF_E     enSyncRef;             /**<Audio-based synchronization, PCR-based synchronization, and free playing without synchronization*//**<CNcomment: 音频为准，PCR为准，自由播放等 */
+    HI_UNF_SYNC_REGION_S  stSyncStartRegion;     /**<Synchronization start region*//**<CNcomment: 同步起调区间 */
+    HI_UNF_SYNC_REGION_S  stSyncNovelRegion;     /**<Synchronization exception region*//**<CNcomment: 同步异常区间 */
+    HI_S32                s32VidPtsAdjust;       /**<Video presentation time stamp (PTS) adjustment*//**<CNcomment: 视频PTS调整 */
+    HI_S32                s32AudPtsAdjust;       /**<Audio PTS adjustment*//**<CNcomment: 音频PTS调整 */
+
+    HI_U32                u32PreSyncTimeoutMs;   /**<Pre-synchronization timeout, in ms*//**<CNcomment: 预同步的超时时间，单位为毫秒 */
+    HI_BOOL               bQuickOutput;          /**<Fast output enable*//**<CNcomment: 快速输出使能 */
+} HI_UNF_SYNC_ATTR_S;
+
+/**Defines the playing attributes of an AVPLAY.*/
+/**CNcomment: 定义AV播放属性 */
+typedef struct hiUNF_AVPLAY_ATTR_S
+{
+    HI_U32                       u32DemuxId;   /**<ID of the DEMUX used by an AVPLAY*//**<CNcomment: AVPLAY所使用的DEMUX ID 仅当码流类型为TS时有效 */
+    HI_UNF_AVPLAY_STREAM_ATTR_S  stStreamAttr; /**<Stream attributes*//**<CNcomment: 码流属性 */
+} HI_UNF_AVPLAY_ATTR_S;
+
+/**Defines the synchronization status when an AVPLAY is running.*/
+/**CNcomment: 定义播放器运行状态信息中同步状态信息类型 */
+typedef struct hiUNF_SYNC_STATUS_S
+{
+    HI_U32 u32FirstAudPts;    /**<PTS of the first audio frame*//**<CNcomment: 第一个音频帧 PTS .*/
+    HI_U32 u32FirstVidPts;    /**<PTS of the first video frame*//**<CNcomment: 第一个视频帧 PTS .*/
+    HI_U32 u32LastAudPts;     /**<PTS of the last audio frame*//**<CNcomment: 最近播放的一个音频帧 PTS .*/
+    HI_U32 u32LastVidPts;     /**<PTS of the last video frame*//**<CNcomment: 最近播放的一个视频帧 PTS .*/
+    HI_S32 s32DiffAvPlayTime; /**<Playing time difference between audio and video frames*//**<CNcomment: 音视频 播放时差 .*/
+    HI_U32 u32PlayTime;       /**<Playing time*//**<CNcomment: 当前已播放时间 .*/
+    HI_U32 u32LocalTime;      /**<Local synchronization reference time*//**<CNcomment: 本地同步参考时间 .*/
+} HI_UNF_SYNC_STATUS_S;
+
+/**Defines the status of a media buffer.*/
+/**CNcomment:定义媒体缓冲区的状态信息 */
+typedef struct hiUNF_AVPLAY_BUF_STATUS_S
+{
+    HI_U32 u32BufId;                /**<Media buffer ID*//**<CNcomment: 媒体缓冲 标识 */
+    HI_U32 u32BufSize;              /**<Media buffer size*//**<CNcomment: 媒体缓冲大小 */
+    HI_U32 u32BufRptr;              /*Read pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: 媒体缓冲读指针,Ts播放时有效 */
+    HI_U32 u32BufWptr;              /*Write pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: 媒体缓冲写指针,Ts播放时有效 */
+    HI_U32 u32UsedSize;             /**<Used size of the media buffer*//**<CNcomment: 媒体缓冲已使用大小 */
+    HI_U32 u32CurrentAvailableSize; /**<Current available size of the media buffer for HI_UNF_AVPLAY_GetBuf()*//**<CNcomment: 媒体缓冲可使用大小 */
+    HI_U32 u32FrameBufTime;         /**<Frame buffer time*//**<CNcomment: 帧缓冲时间 */
+    HI_U32 u32FrameBufNum;          /**<The number of frames in frame buffer*//**<CNcomment: 帧缓冲数目 仅VIDEO有效 */
+    HI_BOOL bEndOfStream;           /**<Flag to indicate end of stream*//**<CNcomment: 缓冲中码流解码完毕标识 仅VIDEO有效 */
+} HI_UNF_AVPLAY_BUF_STATUS_S;
+
+/**Defines the playing status of an AVPLAY.*/
+/**CNcomment:定义AV的播放状态 */
+typedef enum hiUNF_AVPLAY_STATUS_E
+{
+    HI_UNF_AVPLAY_STATUS_STOP = 0,  /**<Stop*/      /**<CNcomment: 停止 */
+    HI_UNF_AVPLAY_STATUS_PREPLAY,   /**<Buffer*/    /**<CNcomment: 缓冲 */
+    HI_UNF_AVPLAY_STATUS_PLAY,      /**<Play*/      /**<CNcomment: 播放 */
+    HI_UNF_AVPLAY_STATUS_TPLAY,     /**<Trick play, such as fast forward and rewind*/   /**<CNcomment: TPlay, 快进快退 */
+    HI_UNF_AVPLAY_STATUS_PAUSE,     /**<Pause*/     /**<CNcomment: 暂停 */
+    HI_UNF_AVPLAY_STATUS_EOS,       /**<EOS*/       /**<CNcomment: 码流播放结束 */
+    HI_UNF_AVPLAY_STATUS_SEEK ,     /**<Seek play*/ /**<CNcomment: 定位播放 */
+
+    HI_UNF_AVPLAY_STATUS_BUTT
+} HI_UNF_AVPLAY_STATUS_E;
+
+/**Defines the output value after the playing status of an AVPLAY is queried.*/
+/**CNcomment:定义AV播放状态查询输出值类型 */
+typedef struct hiUNF_AVPLAY_STATUS_INFO_S
+{
+    HI_UNF_SYNC_STATUS_S       stSyncStatus;      /**<Synchronization status*//**<CNcomment: 同步状态 */
+    HI_UNF_AVPLAY_STATUS_E     enRunStatus;       /**<Running status*//**< CNcomment:运行状态 */
+    HI_U32                     u32VidFrameCount;  /**<Count of played video frames*//**<CNcomment: 视频已播放帧数 */
+    HI_U32                     u32AuddFrameCount; /**<Count of played audio frames*//**<CNcomment: 音频已播放帧数 */
+    HI_UNF_AVPLAY_BUF_STATUS_S stBufStatus[HI_UNF_AVPLAY_BUF_ID_BUTT]; /**<Status of the media buffer*//**<CNcomment:媒体缓冲状态 */
+    HI_U32                     u32VidErrorFrameCount; /**<Number of error frames during video decoding*/ /**<CNcomment: 视频解码错误帧数 */
+    HI_U32                     u32AudErrorFrameCount; /**<Number of error frames during audio decoding*//**<CNcomment: 音频解码错误帧数 */
+} HI_UNF_AVPLAY_STATUS_INFO_S;
+
+/**Defines the information about the playing program streams to be queried.*/
+/**CNcomment: 定义播放节目流查询信息类型 */
+typedef struct hiUNF_AVPLAY_STREAM_INFO_S
+{
+    HI_UNF_VCODEC_STREAMINFO_S stVidStreamInfo; /**<Video stream information*//**<CNcomment:视频流信息 */
+    HI_UNF_ACODEC_STREAMINFO_S stAudStreamInfo; /**<Audio stream information*//**<CNcomment:音频流信息 */
+} HI_UNF_AVPLAY_STREAM_INFO_S;
+
+/**Defines the information about an I frame.*//**CNcomment:定义I帧数据信息类型 */
+typedef struct hiUNF_AVPLAY_I_FRAME_S
+{
+    HI_U8                *pu8Addr;    /**<User-state virtual address of a frame*//**<CNcomment:帧数据用户态虚拟地址 */
+    HI_U32               u32BufSize; /**<Frame size, in byte*//**<CNcomment:帧数据大小，单位字节 */
+    HI_UNF_VCODEC_TYPE_E enType;     /*Protocol type of a data segment*//**<CNcomment:该片数据的协议类型 */
+} HI_UNF_AVPLAY_I_FRAME_S;
+
+/**Defines the decoder type. The occupied memory varies according to decoders.*/
+/**CNcomment:定义解码器类型 不同类型的解码器占用内存不同 */
+typedef enum hiHI_UNF_VCODEC_DEC_TYPE_E
+{
+    HI_UNF_VCODEC_DEC_TYPE_NORMAL,            /**<Normal type.*//**<CNcomment:普通类型 */
+
+    /**<I frame decoding type. If an AVPLAY is used to decode I frames only (HI_UNF_AVPLAY_DecodeIFrame), you can select this type to reduce the memory usage.*/
+    /**<CNcomment:I帧解码类型 如果avplay仅用于I帧解码(HI_UNF_AVPLAY_DecodeIFrame) 设置为此类型可以节省内存 */
+    HI_UNF_VCODEC_DEC_TYPE_ISINGLE,
+
+    HI_UNF_VCODEC_DEC_TYPE_BUTT
+}HI_UNF_VCODEC_DEC_TYPE_E;
+
+/**Defines the level of the protocol supported by the decoder. This value affects the number of frame buffers allocated by the normal decoder.
+The greater the value, the more the required frame buffers.*/
+/**CNcomment:定义解码器支持的协议级别 影响NORMAL类型解码器分配的帧存个数 值越大需要的帧存数目越多 */
+typedef enum hiHI_UNF_VCODEC_PRTCL_LEVEL_E
+{
+    HI_UNF_VCODEC_PRTCL_LEVEL_MPEG = 0,     /**<All protocols except MVC *//**<CNcomment:除MVC外的所有协议 */
+    HI_UNF_VCODEC_PRTCL_LEVEL_H264 = 1,     /**<Same as HI_UNF_VCODEC_PRTCL_LEVEL_MPEG now *//**<CNcomment:和HI_UNF_VCODEC_PRTCL_LEVEL_MPEG相同*/
+    HI_UNF_VCODEC_PRTCL_LEVEL_MVC,
+    HI_UNF_VCODEC_PRTCL_LEVEL_BUTT
+}HI_UNF_VCODEC_PRTCL_LEVEL_E;
+
+/**Defines the attributes when an AVPLAY enables the video decoder. The settings affect the memory occupied by the video decoder and decoding performance.*/
+/**CNcomment:定义AV播放器打开视频解码器时属性设置结构体 影响视频解码器占用内存大小及解码能力 */
+typedef struct hiHI_UNF_AVPLAY_OPEN_OPT_S
+{
+    HI_UNF_VCODEC_DEC_TYPE_E    enDecType;       /**<Decoder type.*//**<CNcomment:解码器类型*/
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;      /**<Maximum resolution supported by the decoder. This value affects the size of each frame buffer.*//**<CNcomment:解码器支持的最大分辨率 影响每个帧存的大小 */
+    HI_UNF_VCODEC_PRTCL_LEVEL_E enProtocolLevel; /**<Supported protocol level. This value affects the number of frame buffers.*//**<CNcomment:支持的协议级别 影响帧存数目 */
+}HI_UNF_AVPLAY_OPEN_OPT_S;
+
+/**Defines the attribute of MS12.*/
+/**CNcomment: 定义音频MS12属性结构体*/
+typedef struct hiUNF_AVPLAY_AD_ATTR_S
+{
+    HI_BOOL             bAdEnble;       /**<whether enable ad service (on/off)*/ /**<CNcomment: 是否使能AD.*/
+    HI_BOOL             bAdToSomePort;  /**<whether enable ad only to some port,such as speaker/headphone etc*/ /**<CNcomment: 是否使能所有输出都混音，默认为false.*/
+    HI_U32              u32AdPid;       /**<AD program id*/ /**<CNcomment: AD流PID.*/
+    HI_S16              s16AdBalance;   /**<AD Balance*/ /**<CNcomment: AD音量.*/
+} HI_UNF_AVPLAY_AD_ATTR_S;
+
+/**Defines the attribute of HDR.*/
+/**CNcomment: 定义HDR属性结构体*/
+typedef struct hiUNF_AVPLAY_HDR_ATTR_S
+{
+    HI_BOOL                           bEnable;          /**<Is Dolby HDR enable or not*/ /**<CNcomment: Dolby HDR是否使能.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_E   enHDRStreamType;  /**<Dolby Vision VES Format*/ /**<CNcomment: Dolby HDR流类型.*/
+    HI_UNF_VCODEC_TYPE_E              enElType;         /**<Video encoding type*/ /**<CNcomment: EL视频编码类型*/
+    HI_UNF_AVPLAY_OPEN_OPT_S          stElCodecOpt;     /**<Video decoding option*/ /**<CNcomment: 视频解码能力级设置*/
+    HI_BOOL                           bCompatible;      /**<Dolby frame is compatible or not.*/ /**<CNcomment: Dolby帧是否兼容.*/
+} HI_UNF_AVPLAY_HDR_ATTR_S;
+
+/**Defines the video display mode after an AVPLAY is stopped.*/
+/**CNcomment:定义AV播放器停止时视频显示模式 */
+typedef enum hiUNF_AVPLAY_STOP_MODE_E
+{
+    HI_UNF_AVPLAY_STOP_MODE_STILL = 0,  /**<The last frame is still after an AVPLAY is stopped.*//**<CNcomment:stop后保留最后一帧 */
+    HI_UNF_AVPLAY_STOP_MODE_BLACK = 1,  /**<The blank screen is displayed after an AVPLAY is stopped.*//**<CNcomment:stop后黑屏 */
+    HI_UNF_AVPLAY_STOP_MODE_BUTT
+} HI_UNF_AVPLAY_STOP_MODE_E;
+
+
+/**Defines the attributes when an AVPLAY is prestarted.*/
+/**CNcomment:定义AV播放器预启动时属性设置结构体 */
+typedef struct hiAVPLAY_PRESTART_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTART_OPT_S;
+
+/**Defines the attributes when an AVPLAY is started.*/
+/**CNcomment:定义AV播放器启动时属性设置结构体 */
+typedef struct hiAVPLAY_START_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_START_OPT_S;
+
+/**Defines the attributes when an AVPLAY is prestoped.*/
+/**CNcomment:定义AV播放器预停止时属性设置结构体 */
+typedef struct hiAVPLAY_PRESTOP_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTOP_OPT_S;
+
+
+/**Defines the attributes when an AVPLAY is stopped.*/
+/**CNcomment:定义AV播放器停止时属性设置结构体 */
+typedef struct hiAVPLAY_STOP_OPT_S
+{
+    /*
+         s32Timeout: end of stream timeout
+         s32Timeout = 0   Wait until streams are played in non-block mode, that is, the interface is returned immediately. CNcomment:非阻塞等待码流播放结束，立即返回 CNend
+         s32Timeout > 0   Block timeout, in ms, CNcomment:阻塞超时时间，单位为毫秒 CNend
+         s32Timeout = -1  Infinite wait,CNcomment:无限等待 CNend
+     */
+    HI_U32                    u32TimeoutMs;    /**<Timeout*//**<CNcomment:超时值 */
+    HI_UNF_AVPLAY_STOP_MODE_E enMode;          /**<Video display mode*//**<CNcomment:视频显示模式 */
+} HI_UNF_AVPLAY_STOP_OPT_S;
+
+/*Defines the attributes when an AVPLAY is paused.*/
+/**CNcomment:定义AV播放器暂停时属性设置结构体 */
+typedef struct hiAVPLAY_PAUSE_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PAUSE_OPT_S;
+
+/**Defines the direction of tplay*/
+/**CNcomment:定义AV播放器TPLAY的方向 */
+typedef enum hiUNF_AVPLAY_TPLAY_DIRECT_E
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_FORWARD,     /**<Tplay forward*//**<CNcomment: 向前TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BACKWARD,    /**<Tplay backward*//**<CNcomment: 向后TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BUTT
+
+} HI_UNF_AVPLAY_TPLAY_DIRECT_E;
+
+/**Defines the attributes when the playing mode of an AVPLAY is tplay.*/
+/**CNcomment:定义AV播放器TPALY时属性设置结构体 */
+typedef struct hiAVPLAY_TPLAY_OPT_S
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_E    enTplayDirect;      /**<Tplay direction*//**<CNcomment: TPLAY方向 */
+    HI_U32                          u32SpeedInteger;    /**<Integral part of tplay speed*//**<CNcomment: TPLAY倍数的整数部分 */
+    HI_U32                          u32SpeedDecimal;    /**<Fractional part (calculated to three decimal places) of tplay speed*//**<CNcomment: TPLAY倍数的小数部分，保留3位小数 */
+} HI_UNF_AVPLAY_TPLAY_OPT_S;
+
+/**Defines the attributes when an AVPLAY is resumed.*/
+/**CNcomment:定义AV播放器恢复时属性设置结构体 */
+typedef struct hiAVPLAY_RESUME_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_RESUME_OPT_S;
+
+/**Defines the attributes when an AVPLAY is reset.*/
+/**CNcomment:定义AV播放器复位时属性设置结构体 */
+typedef struct hiAVPLAY_RESET_OPT_S
+{
+    HI_U32        u32SeekPtsMs;   /**<clear these datas which pts is smaller than u32SeekPtsMs in buffer *//**<CNcomment:清空buffer内u32SeekPtsMs之前的数据 */
+} HI_UNF_AVPLAY_RESET_OPT_S;
+
+/**Defines the attributes when an AVPLAY is step.*/
+/**CNcomment:定义AV播放器步进时属性设置结构体 */
+typedef struct hiUNF_AVPLAY_STEP_OPT_S
+{
+    HI_U32       u32Reserved;
+}HI_UNF_AVPLAY_STEP_OPT_S;
+
+/**Defines the attributes when an AVPLAY is in Flushing Stream Status.*/
+/**CNcomment:定义AV播放器Flush Stream时属性设置结构体 */
+typedef struct hiUNF_AVPLAY_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S;
+
+/**Defines the attributes of multiple audio.*/
+/**CNcomment:定义多音轨属性结构体 */
+typedef struct hiUNF_AVPLAY_MULTIAUD_ATTR_S
+{
+    HI_U32                  u32PidNum;      /**<the number of Audio PID *//**< CNcomment:音频PID个数 */
+    HI_U32                  *pu32AudPid;    /**<Pointer to the array of audio PID*//**< CNcomment:指向PID数组的指针 */
+    HI_UNF_ACODEC_ATTR_S    *pstAcodecAttr; /**<Pointer to the array of audio attribute*//**< CNcomment:指向音频属性数组的指针 */
+}HI_UNF_AVPLAY_MULTIAUD_ATTR_S;
+
+/**Defines the source of frame rate.*/
+/**CNcomment: 定义帧率来源类型的枚举 */
+typedef enum hiUNF_AVPLAY_FRMRATE_TYPE_E
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_PTS,         /**<Use the frame rate calculates from PTS*//**<CNcomment: 采用PTS计算帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_STREAM,      /**<Use the frame rate comes from stream*//**<CNcomment: 采用码流信息中的帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER,        /**<Use the frame rate set by user*//**<CNcomment: 采用用户设置的帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER_PTS,    /**<Use the frame rate set by user until the 2nd I frame comes, then use the frame rate calculates from PTS*//**<CNcomment: 第二个I帧来之前采用用户设置的帧率，之后根据PTS计算帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_BUTT
+}HI_UNF_AVPLAY_FRMRATE_TYPE_E;
+
+/**Defines the parameter of frame rate.*/
+/**CNcomment: 定义帧率属性参数的结构体 */
+typedef struct hiUNF_AVPLAY_FRMRATE_PARAM_S
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_E    enFrmRateType;  /**<The source of frame rate*//**<CNcomment: 帧率来源类型 */
+    HI_UNF_VCODEC_FRMRATE_S         stSetFrmRate;   /**<Setting frame rate*//**<CNcomment: 设置的帧率 */
+}HI_UNF_AVPLAY_FRMRATE_PARAM_S;
+
+/**Defines commond to get vdec information, the parameter is HI_UNF_AVPLAY_VDEC_INFO_S.*/
+/**CNcomment: 获取解码器信息命令，参数对应类型为HI_UNF_AVPLAY_VDEC_INFO_S */
+#define HI_UNF_AVPLAY_GET_VDEC_INFO_CMD         0x20
+/**Defines commond to set TPLAY parameter, the parameter is HI_UNF_AVPLAY_TPLAY_OPT_S.*/
+/**CNcomment: 设置TPLAY参数命令，参数对应类型为HI_UNF_AVPLAY_TPLAY_OPT_S*/
+#define HI_UNF_AVPLAY_SET_TPLAY_PARA_CMD        0x21
+/**Defines commond to set special control information of stream, the parameter is HI_UNF_AVPLAY_CONTROL_INFO_S*/
+/**CNcomment: 用来设置一些码流的特殊控制信息，参数对应类型为HI_UNF_AVPLAY_CONTROL_INFO_S*/
+#define HI_UNF_AVPLAY_SET_CTRL_INFO_CMD         0x22
+
+/**Defines commond to set video sample type, HI_BOOL *, HI_TRUE: force Progressive, HI_FALSE: auto recognise Progressive or Interlance */
+/**CNcomment: 设置视频逐行信息, HI_TRUE: 强制逐行, HI_FALSE: 自动识别逐隔行*/
+#define HI_UNF_AVPLAY_SET_PROGRESSIVE_CMD       0x23
+
+/**Defines commond to set video color space, the parameter is HI_UNF_COLOR_SPACE_E*/
+/**CNcomment: 设置视频色彩空间, 参数对应类型为HI_UNF_COLOR_SPACE_E*/
+#define HI_UNF_AVPLAY_SET_COLORSPACE_CMD        0x24
+
+/**Defines commond to set dpb full control, HI_BOOL* ,HI_TRUE:force delete min poc frame when dpb is full,HI_FALSE:return error when dpb is full*/
+/**CNcomment:设置dpb满的时候的处理策略, 参数对应类型为HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_DPBFULL_CTRL_CMD      0x25
+
+/***fix  videophone scene by AVPLAY ,  format MJPEG**/
+#define HI_UNF_AVPLAY_SET_SCENE_MODE_CMD        0x26
+
+/***Defines commond to get vdec handle, the parameter is HI_U32**/
+#define HI_UNF_AVPLAY_GET_VDEC_HANDLE_CMD       0x28
+
+/**Defines the mode of videophone.*/
+/**CNcomment: 定义Videophone 场景类型的枚举 */
+typedef enum hiUNF_AVPLAY_SCENE_MODE_E
+{
+   HI_UNF_AVPLAY_SCENE_MODE_NORMAL,     /**<Normal scene of non-voip*//**<CNcomment: 非可视电视场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_PREVIEW,   /**<Voip scene of the local end*//**<CNcomment: 可视电话近端场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_REMOTE,   /**<Voip scene of the remote end*//**<CNcomment: 可视电话远端场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_BUTT,
+} HI_UNF_AVPLAY_SCENE_MODE_E;
+
+
+/**Defines the type of AVPLAY invoke.*/
+/**CNcomment: 定义AVPLAY Invoke调用类型的枚举 */
+typedef enum hiUNF_AVPLAY_INVOKE_E
+{
+    HI_UNF_AVPLAY_INVOKE_ACODEC  = 0,   /**<Invoke commond to control audio codec*//**<CNcomment: 控制音频解码器的Invoke调用 */
+    HI_UNF_AVPLAY_INVOKE_VCODEC,        /**<Invoke commond to control video codec, HI_CODEC_VIDEO_CMD_S*//**<CNcomment: 控制视频解码器的Invoke调用 */
+    HI_UNF_AVPLAY_INVOKE_GET_PRIV_PLAYINFO, /**<Invoke commond to get private play infomation,the parameter is HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S*//**<CNcomment: 获取私有播放信息的Invoke调用， 参数为HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S * */
+    HI_UNF_AVPLAY_INVOKE_SET_DISP_OPTIMIZE_FLAG, /**Defines commond to set Display Optimize Flag, The Parameter is HI_U32, 1: Enable, 0: Disable */
+    HI_UNF_AVPLAY_INVOKE_GET_GLOBAL_PLAYINFO,   /**<Get global play information of avplay*//**<CNcomment: 获取AVPLAY全局播放信息 */
+    HI_UNF_AVPLAY_INVOKE_SET_SYNC_MODE,  /**<Invoke commond to set sync mode, HI_U32, 0 normal sync, 1 use sync replace frc*//**<CNcomment: 设置同步模式，HI_U32，0: 正常模式, 1: 使用同步替代帧率转换*/
+    HI_UNF_AVPLAY_INVOKE_BUTT
+} HI_UNF_AVPLAY_INVOKE_E;
+
+/**Defines the decoding information of video codec.*/
+/**CNcomment: 定义VDEC解码信息的结构体 */
+typedef struct hiUNF_AVPLAY_VDEC_INFO_S
+{
+    HI_U32                  u32DispFrmBufNum;   /**<the number of display frame*//**<CNcomment: 显示帧存个数 */
+    HI_U32                  u32FieldFlag;       /**<The encoding mode of image, 0 frame mode, 1 filed mode*//**<CNcomment: 图像编码方式, 0 帧模式，1 场模式 */
+    HI_UNF_VCODEC_FRMRATE_S stDecFrmRate;      /**<decoding frame rate*//**<CNcomment: 解码帧率 */
+    HI_U32                  u32UndecFrmNum;     /**<the number of undecoded frame*//**<CNcomment: 未解码帧个数 */
+}HI_UNF_AVPLAY_VDEC_INFO_S;
+
+/**Defines the private status information.*/
+/**CNcomment: 定义AVPLAY私有状态信息 */
+typedef struct hiUNF_AVPLAY_PRIVATE_STATUS_INFO_S
+{
+    HI_U32 u32LastPts;   /**<PTS of the last audio or video frame*/ /**<CNcomment: 最近播放的一个音频帧 PTS或视频PTS*/
+    HI_U32 u32LastPlayTime; /**< PlayTime of the last audio or video frame */ /**<CNcomment: 最近播放的一个音频帧 PlayTime或视PlayTime  */
+    HI_U32 u32DispOptimizeFlag; /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: 显示优化标志*/
+} HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S;
+
+/**Defines the special control information of stream.*/
+/**CNcomment: 定义特殊控制信息 */
+typedef struct hiUNF_AVPLAY_CONTROL_INFO_S
+{
+    HI_U32 u32IDRFlag;               /**<IDR frame Flag, 1 means IDR(instantaneous decoding refresh) frame.*/ /**<CNcomment: 是否是IDR(此帧前后无参考关系)帧，1表示是*/
+    HI_U32 u32BFrmRefFlag;           /**<Whether B frame is refer frame, 1 means B frame is refer frame.*/ /**<CNcomment: B帧是否是参考帧，1表示是*/
+    HI_U32 u32ContinuousFlag;        /**<Whether send frame is continusous. 1 means continusous*/ /**<CNcomment: 帧是否连续，1表示连续*/
+    HI_U32 u32BackwardOptimizeFlag;  /**<The Backward Optimize Flag*//**<CNcomment: 快退优化使能标志.*/
+    HI_U32 u32DispOptimizeFlag;      /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: 显示优化标志*/
+}HI_UNF_AVPLAY_CONTROL_INFO_S;
+
+/**Defines the parameter when the stream is send by HI_UNF_AVPLAY_PutBufEx.*/
+/**CNcomment: 定义按PutBufEx模式送码流的参数结构体 */
+typedef struct hiUNF_AVPLAY_PUTBUFEX_OPT_S
+{
+    HI_BOOL bEndOfFrm;      /**<whether this package of stream is the end of one frame*//**<CNcomment: 该包码流是否为一帧的最后一包 */
+    HI_BOOL bContinue;      /**<whether this package of stream is contnued with the last package*//**<CNcomment: 该包码流是否与之前连续 */
+}HI_UNF_AVPLAY_PUTBUFEX_OPT_S;
+
+typedef struct hiUNF_AVPLAY_GLOBAL_PLAY_INFO_S
+{
+    HI_U32 u32ContentCount;
+} HI_UNF_AVPLAY_GLOBAL_PLAY_INFO_S;
+
+typedef struct hiUNF_AVPLAY_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: 原始图像宽*/
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: 原始图像高*/
+    HI_U32                              u32AspectWidth;     /**<aspect ratio: width*/ /**<CNcomment:宽高比之宽值 */
+    HI_U32                              u32AspectHeight;    /**<aspect ratio: height*/ /**<CNcomment:宽高比之高值 */
+    HI_U32                              u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32                              u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+} HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S;
+
+/**Defines the avplay video start position .*/
+/**CNcomment: 视频起播点属性 */
+typedef struct hiUNF_AVPLAY_START_POSITION_ATTR_S
+{
+    HI_U32                              u32StartPosPts;     /**<Start play Pts*/ /**<CNcomment: 起播Pts*/
+    HI_U32                              u32IdrPts;          /**<Instantaneous Decoding Refresh Pts */ /**<CNcomment: I帧Pts*/
+}HI_UNF_AVPLAY_START_POSITION_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**
+\brief Initializes the AVPLAY module.CNcomment:初始化AVPLAY模块 CNend
+\attention \n
+Before calling ::HI_UNF_AVPLAY_Create to create an AVPLAY, you must call this application programming interface (API).
+CNcomment 在调用AVPLAY模块其他接口前，要求首先调用本接口 CNend
+\param  N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NOT_EXIST There is no AVPLAY. CNcomment:AVPLAY设备不存在 CNend
+\retval ::HI_ERR_AVPLAY_NOT_DEV_FILE  The file is not an AVPLAY file. CNcomment:AVPLAY非设备 CNend
+\retval ::HI_ERR_AVPLAY_DEV_OPEN_ERR  An AVPLAY fails to be started. CNcomment:AVPLAY打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Init(HI_VOID);
+
+/**
+\brief Deinitializes the AVPLAY module. CNcomment:去初始化AVPLAY模块 CNend
+\attention \n
+Please call this API function, before call anyother API of AVPLAY module.
+CNcomment: 在调用::HI_UNF_AVPLAY_Destroy接口销毁所有的播放器后，调用本接口 CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT  The operation is invalid.  CNcomment:操作非法 CNend
+\retval ::HI_ERR_AVPLAY_DEV_CLOSE_ERR  An AVPLAY fails to be stopped. CNcomment:AVPLAY关闭失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DeInit(HI_VOID);
+
+/**
+\brief Get video frame info. CNcomment:获取视频帧信息 CNend
+\attention \n
+\param[out] pstVideoFrameInfo  Pointer to video frame info. For details, see the description of ::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNcomment:指针类型，视频帧信息，请参见::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNend
+\param[in] hAvplay    AVPLAY handle . CNcomment:AVPLAY句柄 . CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The pointer is null.  CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_FAILURE  Failure. CNcomment:失败. CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetVideoFrameInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S *pstVideoFrameInfo);
+
+/**
+\brief Obtains the default configuration of an AVPLAY. CNcomment:获取缺省的AV播放配置 CNend
+\attention \n
+When calling this API to set the enCfg parameter, you must enter correct mode of the player to be created.\n
+It is recommended that you call this API to obtain the default AVPLAY attributes before creating an AVPLAY. This avoids creation failures due to incomplete or incorrect parameters.
+CNcomment:调用本接口输入enCfg参数时，请正确输入想要创建播放器模式\n
+创建AV播放器前建议调用本接口，获取到AV播放器默认属性，避免创建AV播放器时由于参数不全或参数错误导致播放器创建不成功现象 CNend
+\param[out] pstAvAttr  Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment: 指针类型，AV播放属性，请参见::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[in] enCfg       AVPLAY type. For details, see the description of ::HI_UNF_AVPLAY_STREAM_TYPE_E. CNcomment: AV播放的类型，请参见::HI_UNF_AVPLAY_STREAM_TYPE_E. CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_UNF_AVPLAY_STREAM_TYPE_E enCfg);
+
+/**
+\brief Registers a dynamic audio decoding library. CNcomment:注册音频动态解码库 CNend
+\attention \n
+\param[in] pFileName Name of the file in the audio decoding library CNcomment:音频解码库文件名 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterAcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Registers a dynamic video decoding library. CNcomment:注册视频动态解码库 CNend
+\attention \n
+\param[in] pFileName Name of the file in the video decoding library CNcomment:视频解码库文件名 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterVcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Searches for registered dynamic audio decoding libraries based on the audio format.
+CNcomment:根据音频格式, 查找注册音频动态解码库 CNend
+\attention \n
+\param[in] enFormat Audio format CNcomment:音频格式 CNend
+\param[out] penDstCodecID If an audio decoding library is found, its codec ID is returned.
+CNcomment:成功则返回音频解码库CodecID CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FoundSupportDeoder(const HA_FORMAT_E enFormat,HI_U32 * penDstCodecID);
+
+
+/**
+\brief Sets private commands for a dynamic audio decoding library. These commands are used to call ha_codec.
+CNcomment:设置私有命令给音频动态解码库, 调用ha_codec 方法  CNend
+HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID * hDecoder, HI_VOID * pstConfigStructure);
+\attention \n
+\param[in] enDstCodecID  The audio Codec ID  CNcomment:音频解码库ID CNend
+\param[in] pPara  Attribute structure CNcomment:属性结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ConfigAcodec(const HI_U32 enDstCodecID, HI_VOID *pPara);
+
+/**
+\brief Creates an AVPLAY. CNcomment:创建AV播放器 CNend
+\attention \n
+Note the following point when setting the input parameter pstAttr: The stream source can be HI_UNF_AVPLAY_STREAM_TYPE_ES (ESs input from the memory) or HI_UNF_AVPLAY_STREAM_TYPE_TS (ESs input from the memory and TSs input from the Tuner).
+CNcomment:输入属性参数pstAttr中有几点需要注意：码流源支持HI_UNF_AVPLAY_STREAM_TYPE_ES（内存输入ES流）、HI_UNF_AVPLAY_STREAM_TYPE_TS（内存输入TS流或TUNER输入TS 流）CNend
+\param[in]  pstAvAttr   Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment:指针类型，AV播放属性，请参见::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[out] phAvplay    Pointer to the handle of a created AVPLAY.CNcomment:指针类型，创建的AV播放句柄 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_CREATE_ERR       The AVPLAY fails to be created. CNcomment:AVPLAY创建失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_HANDLE *phAvplay);
+
+/**
+\brief Destroys an AVPLAY. CNcomment:销毁AV播放器 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay);
+
+/**
+\brief Sets the attributes of an AVPLAY. CNcomment:设置AV播放属性 CNend
+\attention \n
+You can set the audio/video PID, audio/video decoding type, and synchronization mode by calling this API.\n
+Different attribute IDs correspond to different data types. For details, see the Note part of HI_UNF_AVPLAY_ATTR_ID_E. The attribute types of the pPara and enAttrID parameters must be the same.\n
+Before setting HI_UNF_AVPLAY_ATTR_ID_ADEC (audio decoding attribute) and HI_UNF_AVPLAY_ATTR_ID_VDEC (video decoding attribute),\n
+you must disable the audio channel or video channel. The new attributes take effect when you enable the audio channel or video channel again.
+CNcomment:调用本接口可实现设置音视频PID、设置音视频解码类型、设置同步方式等功能\n
+不同的属性ID对应的结构体请参见结构体HI_UNF_AVPLAY_ATTR_ID_E的[注意], pPara参数要与enAttrID对应的属性结构体类型保持一致\n
+当需要设置HI_UNF_AVPLAY_ATTR_ID_ADEC(音频解码属性),HI_UNF_AVPLAY_ATTR_ID_VDEC(视频解码属性)时\n
+需要先关闭音频或视频通道，再设置新属性，然后再重新打开音频或视频通道新属性才可以生效。 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enAttrID        Attribute ID CNcomment:属性ID CNend
+\param[in] pPara  Data type corresponding to an attribute ID CNcomment:属性ID对应结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Obtains the attributes of an AVPLAY. CNcomment:获取AV播放属性 CNend
+\attention \n
+N/A
+\param[in] hAvplay          AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enAttrID         Attribute ID CNcomment:属性ID CNend
+\param[in] pPara   Data type corresponding to an attribute ID, CNcomment:属性ID对应结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Decodes I frames. CNcomment:解码I帧码流 CNend
+\attention \n
+If pstCapPicture is null, the decoded I frames are displayed in the window,and do not need release memory; \n
+if pstCapPicture is not null, the information about I frames is reported, and need invoke ::HI_UNF_AVPLAY_ReleaseIFrame to release memory.
+You must stop the video decoder before calling this API. If I frames are being processed, do not enable the video decoder.
+CNcomment:当pstCapPicture为空指针时，解完的I帧将在window上显示，不需释放内存，如果非空，则不会显示而是将I帧信息上报,同时I帧处理完毕后，需要调用HI_UNF_AVPLAY_ReleaseIFrame来释放I帧
+调用该接口前，需停止视频解码器；I帧处理没有完成时，也不能启动视频解码器 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstFrame        Pointer to frame attributes CNcomment:指针类型，帧数据属性 CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment:指针类型，帧信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DecodeIFrame(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_I_FRAME_S *pstFrame, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Release memory of I frame. CNcomment:释放I帧帧存 CNend
+\attention \n
+If you call HI_UNF_AVPLAY_DecodeIFrame with non-null pstCapPicture, you need call this API to release the memory.
+CNcomment:如果调用HI_UNF_AVPLAY_DecodeIFrame时pstCapPicture不为空，需要调用此接口来释放内存 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment:指针类型，释放的帧信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ReleaseIFrame(HI_HANDLE hAvplay, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Sets the mode of a video decoder. CNcomment:设置视频解码器的模式 CNend
+\attention \n
+This API is used in trick play mode. Before switching the mode to the trick play mode, you must enable a decoder to decode only I frames by calling this API.\n
+Before switching the mode to the normal mode, you also need to set the mode of a decoder to normal by calling this API.
+CNcomment:本接口主要应用在快进播放的场景，当切换到快进播放前，可以先调用本接口将解码器设置为只解I帧，\n
+当切换回正常播放前，先调用本接口将解码器设置为NORMAL。 CNend
+\param[in] hAvplay            AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enDecodeMode       Decoding mode CNcomment:解码模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetDecodeMode(HI_HANDLE hAvplay, HI_UNF_VCODEC_MODE_E enDecodeMode);
+
+/**
+\brief Registers an event on 32bit system. CNcomment:注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent     Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment:回调函数指针，指向与注册事件对应的回调函数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB);
+/**
+\brief Registers an event on 64bit system. CNcomment:64位系统注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent     Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment:回调函数指针，指向与注册事件对应的回调函数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent64(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN64 pfnEventCB);
+
+/**
+\brief Deregisters an event. CNcomment:取消注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent   Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent);
+
+/**
+\brief Enables an AVPLAY channel. CNcomment:打开AV播放器通道 CNend
+\attention \n
+You can enable an audio channel and a video channel for each AVPLAY. If you only need to play videos or audios, you can enable the corresponding channel to save resources.
+CNcomment:每个AV播放器仅支持打开音视频通道各1个。如果只播放音频或视频，只需要打开相应通道，以节省资源。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pPara    Pointer type. For details, see the description of ::HI_UNF_AVPLAY_OPEN_OPT_S. CNcomment:指针类型，请参见::HI_UNF_AVPLAY_OPEN_OPT_S. CNend
+    If enChn is set to HI_UNF_AVPLAY_MEDIA_CHAN_VID, this API is used to specify the maximum decoding performance of the video decoder.
+    If enChn is set to NULL, the maximum performance H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD is used by default.
+    The higher the configured decoding performance, the larger the required MMZ. It is recommended that you configure the performance as required.
+    CNcomment:enChn为HI_UNF_AVPLAY_MEDIA_CHAN_VID时用来指定视频解码器的最大解码能力。
+    如果设为NULL，将默认为最大能力: H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD。
+    配置支持的能力越大，需要的MMZ物理内存也就越大，建议按需配置即可。 CNend
+\retval ::HI_SUCCESS Success             CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_VOID *pPara);
+
+/**
+\brief Disables an AVPLAY channel. CNcomment:关闭AV播放器通道 CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn     Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn);
+
+/**
+\brief Start an AVPLAY to prepare play mode, which just demux ts stream. CNcomment:启动播放器进入仅仅做解复用TS的PREPLAY状态 CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in prepare play mode. The audios and videos can be prepared play separately or simultaneously.
+CNcomment:当完成通道打开和属性设置后，调用本接口启动预播放，进入PREPLAY状态。支持分别和同时启动音视频预播放。 CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为NULL即可. CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStart(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTART_OPT_S *pstPreStartOpt);
+
+/**
+\brief Starts an AVPLAY. The AVPLAY is in play mode. CNcomment:启动播放器，进入PLAY状态 CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in play mode. The audios and videos can be played separately or simultaneously.
+CNcomment:当完成通道打开和属性设置后，调用本接口启动播放，进入PLAY状态。支持分别和同时启动音视频播放。 CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为NULL即可. CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt);
+
+/**
+\brief Stop an AVPLAY to prepare stop mode,the interface is reserved for future use. CNcomment:停止AV播放使其进入PRESTOP状态,该接口保留备用 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStopOpt   Pointer to stop mode. For details, see the description of ::HI_UNF_AVPLAY_PRESTOP_OPT_S. CNcomment:指针类型，清屏模式，请参见::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_ERR_AVPLAY_NOT_SUPPORT not support for the moment  CNcomment:暂不支持 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTOP_OPT_S *pstPreStopOpt);
+
+/**
+\brief Stops an AVPLAY. Then the AVPLAY is in stop mode. CNcomment:停止AV播放，进入STOP状态 CNend
+\attention \n
+If you call this API, all selected channels stop playing. The playing audios and videos can be stopped separately or simultaneously.\n
+The parameter pstStopOpt->enMode takes effect only when a video channel is selected.\n
+If pstStopOpt->enMode is set to NULL or HI_UNF_AVPLAY_STOP_MODE_STILL, the last frame is kept still.\n
+If pstStopOpt->enMode is set to HI_UNF_AVPLAY_STOP_MODE_BLACK, the last frame is cleared, and the blank screen appears.\n
+When pstStopOpt->u32TimeoutMs is 0, the AVPLAY stops and this API is returned.\n
+When pstStopOpt->u32TimeoutMs is greater than 0, this API is blocked until the data in the buffer is used up.\n
+When pstStopOpt->u32TimeoutMs is greater than -1, this API is blocked until the data in the buffer is used up.\n
+To stop the audio or video separately when both the audio and video are enabled, you must set pstStopOpt->u32TimeoutMs to 0.
+CNcomment:调用本接口将停止所选通道的播放，支持分别和同时停止音视频播放。\n
+当所选通道中包含视频通道时，参数pstStopOpt->enMode才有意义。\n
+当pstStopOpt->enMode为空或者为HI_UNF_AVPLAY_STOP_MODE_STILL时，保留最后一帧视频图像。\n
+当pstStopOpt->enMode为HI_UNF_AVPLAY_STOP_MODE_BLACK时，清除视频最后一帧，视频输出为黑屏。\n
+当pstStopOpt->u32TimeoutMs为0时将离开停止播放并返回。\n
+当pstStopOpt->u32TimeoutMs>0时将阻塞相应时间，直到缓冲中的数据播完。\n
+当pstStopOpt->u32TimeoutMs=-1时将一直阻塞到缓冲中的数据播完。\n
+当音视频都处于开启状态时,要单独停止音频和视频，必须设置pstStopOpt->u32TimeoutMs为0. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStopOpt   Pointer to the clear screen mode. For details, see the description of ::HI_UNF_AVPLAY_STOP_OPT_S. CNcomment:指针类型，清屏模式，请参见::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Pauses an AVPLAY. Then the AVPLAY is in pause mode. CNcomment:暂停AV播放，进入PAUSE状态 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstPauseOpt  Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt);
+
+/**
+\brief Plays videos or audios in trick play mode. Then the AVPLAY is in TPLAY mode. CNcomment:倍速播放，进入TPLAY状态 CNend
+\attention \n
+pstTplayOpt->u32SpeedInteger is the integer part of speed, the range is 0-64.
+pstTplayOpt->u32SpeedDecimal is the decimal part of speed, the range is 0-999.
+CNcomment: pstTplayOpt->u32SpeedInteger为速度的整数部分，取值范围为0-64. CNend
+CNcomment: pstTplayOpt->u32SpeedDecimal为速度的小数部分，保留3位小数，取值范围为0-999. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstTplayOpt   The pointer of Tplay parameter,For details, see the description of ::HI_UNF_AVPLAY_TPLAY_OPT_S . CNcomment:指针类型，TPLAY参数指针,请参见HI_UNF_AVPLAY_TPLAY_OPT_S结构体定义 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Tplay(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_TPLAY_OPT_S *pstTplayOpt);
+
+/**
+\brief Resumes an AVPLAY. Then the AVPLAY is in play mode. CNcomment:恢复AV播放，进入PLAY状态 CNend
+\attention \n
+By calling this API, you can resume an AVPLAY from the trick play mode or pause mode rather than the stop mode.
+CNcomment:本接口用来将倍速或暂停状态恢复为播放状态，但无法将停止状态恢复为播放状态。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstResumeOpt  Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，暂置为空即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt);
+
+/**
+\brief Resets an AVPLAY. In this case, the play mode is not changed. CNcomment:复位AV播放，不改变状态 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstResetOpt   Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Reset(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESET_OPT_S *pstResetOpt);
+
+/**
+\brief Step play. CNcomment:步进播放 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstStepOpt   Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Step(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_STEP_OPT_S *pstStepOpt);
+
+/**
+\brief Applies for a buffer for storing the streams played by an AVPLAY. CNcomment:申请AV播放的码流缓冲 CNend
+\attention \n
+This API is used only when you want to play the ESs obtained from Internet or local ESs.\n
+The pstData parameter is used to return the start address and size of the buffer applied for.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates that the API waits for an infinite time; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, an error code indicating full buffer is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the audio and video buffers are full. In this case, you need to call the usleep(N*1000) function to release the CPU.
+Therefore, other threads can be scheduled.
+CNcomment:当播放网络或本地ES流时才需要使用本接口。\n
+参数pstData用来返回成功申请到的Buffer的首地址以及大小。\n
+u32TimeOutMs设置为0表示不等待，设置为0xffffffff表示一直等待，设置为其他值表示等待u32TimeOutMs毫秒。\n
+若超过阻塞时间，还无法申请到Buffer，则返回buffer满错误码\n
+u32TimeOutMs配置为0时，如果申请不到Buffer，说明此时音视频的Buffer已满，需要通过usleep(N*1000)释放cpu
+以使其它线程能够得到调度。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID CNend
+\param[in] u32ReqLen   Size of the buffer applied for CNcomment:申请缓存的大小 CNend
+\param[out] pstData    Pointer to the returned buffer CNcomment:返回缓存指针 CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms CNcomment:等待超时时间，单位ms. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay,
+                            HI_UNF_AVPLAY_BUFID_E enBufId,
+                            HI_U32                u32ReqLen,
+                            HI_UNF_STREAM_BUF_S  *pstData,
+                            HI_U32                u32TimeOutMs);
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment:拷贝数据成功后，更新写指针 CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:在向申请到的缓冲区内送码流完毕后，调用本接口更新音视频缓冲区的写指针。\n
+如果本次送入的码流没有对应的PTS，u32ptsMs必须为-1。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID. CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment:实际写入缓冲区的字节数 CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:时间戳,以毫秒为单位 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                         HI_U32 u32ValidDataLen, HI_U32 u32PtsMs);
+
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment:拷贝数据成功后，更新写指针 CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:在向申请到的缓冲区内送码流完毕后，调用本接口更新音视频缓冲区的写指针, 本接口可由于一帧码流分多包送入。\n
+如果本次送入的码流没有对应的PTS，u32ptsMs必须为-1。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment:实际写入缓冲区的字节数 CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:时间戳,以毫秒为单位 CNend
+\param[in] pPutOpt   the extern parameter of PutBufEx, see the description of ::HI_UNF_AVPLAY_PUTBUFEX_OPT_S.CNcomment:PutBufEx的额外参数，请参见::HI_UNF_AVPLAY_PUTBUFEX_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBufEx(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                                       HI_U32 u32ValidDataLen, HI_U32 u32Pts, HI_UNF_AVPLAY_PUTBUFEX_OPT_S *pPutOpt);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TS模式时获取AV播放器使用的DMX音频通道的Handle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMX音频通道Handle指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAudChn);
+
+/**
+\brief Obtains the handle of the DMX video channel used by an AVPLAY in TS mode. CNcomment:TS模式时获取AV播放器使用的DMX视频通道的Handle. CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] phDmxVidChn    Pointer to the handle of a DMX video channel CNcomment:DMX视频通道Handle指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxVidChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxVidChn);
+
+
+/**
+\brief Obtains the status information about an AVPLAY. CNcomment:获取AV播放状态信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[out] pstStatusInfo  Pointer to the status of an AVPLAY. For details, see the description of HI_UNF_AVPLAY_STATUS_INFO_S. CNcomment:指针类型，AV播放状态信息，请参见HI_UNF_AVPLAY_STATUS_INFO_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE          hAvplay,
+                                 HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo);
+
+
+/**
+\brief Obtains the information about audio and video streams. CNcomment:获取音视频码流信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] pstStreamInfo     Pointer to the information about audio and video streams. For details, see the description of HI_UNF_AVPLAY_STREAM_INFO_S. CNcomment:指针类型，音视频码流信息，请参见HI_UNF_AVPLAY_STREAM_INFO_S CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE          hAvplay,
+                                   HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo);
+
+/**
+\brief Obtains the information audio spectrums. CNcomment:获取音频能量信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] pSpectrum      Pointer to the array of audio spectrums. CNcomment:指针类型，音频能量信息数组指针 CNend
+\param[in] u32BandNum     Length of an audio spectrum array CNcomment:音频能量信息数组长度 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAudioSpectrum(HI_HANDLE hAvplay, HI_U16 *pSpectrum, HI_U32 u32BandNum);
+
+/**
+\brief Queries whether the AVPLAY buffer is empty. CNcomment:查询AVPLAY buffer是否已经为空 CNend
+\attention \n
+N/A
+\param[in] hAvplay        AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[out] pbIsEmpty      Pointer type. This pointer indicates whether the AVPLAY buffer is empty (the playing ends). CNcomment:指针类型，指示buffer是否已经为空(播放完成) CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsBuffEmpty(HI_HANDLE hAvplay, HI_BOOL * pbIsEmpty);
+
+/**
+\brief Switch the demux audio channel CNcomment:切换音频DEMUX句柄 CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] hNewDmxAud     New demux audio handle CNcomment:新DMX句柄 CNend
+\param[out] phOldDmxAud     Old  demux audio handle CNcomment:旧DMX句柄指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchDmxAudChn(HI_HANDLE hAvplay, HI_HANDLE hNewDmxAud, HI_HANDLE *phOldDmxAud);
+
+/**
+\brief Notify an AVPLAY the stream is end CNcomment:通知AVPLAY码流已经送完 CNend
+\attention \n
+Call this interface to notice AVPLAY when the last package of stream has been sent,
+then check whether the last frame has been output by eos event or by invoking ::HI_UNF_AVPLAY_IsBuffEmpty,
+this interface is only apply to ES mode.
+CNcomment: 当用户送完最后一包码流时，调用该接口通知AVPLAY，之后可以通过检测EOS事件或者调用::HI_UNF_AVPLAY_IsBuffEmpty判断最后一帧是否输出
+目前该接口仅适用于ES模式 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstFlushOpt   Pointer used for expansion. You can set it to NULL.CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FlushStream(HI_HANDLE hAvplay, HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S *pstFlushOpt);
+
+/**
+\brief AVPLAY private command invoking. CNcomment: AVPLAY私有命令调用 CNend
+\attention \n
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enInvokeType  Type of private command invoking.CNcomment:私有命令调用类型 CNend
+\param[in] pPara         Pointer to the parameter of invoking. CNcomment:指针类型，指向Invoke调用的参数 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Invoke(HI_HANDLE hAvplay, HI_UNF_AVPLAY_INVOKE_E enInvokeType, HI_VOID *pPara);
+
+/**
+\brief Accquire user dada. CNcomment: 获取用户数据 CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: 仅支持CC数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[out] pstUserData  user data.CNcomment:用户数据 CNend
+\param[out] penType      user data type. CNcomment:用户数据类型 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S *pstUserData, HI_UNF_VIDEO_USERDATA_TYPE_E *penType);
+
+/**
+\brief Accquire user dada. CNcomment: 释放用户数据 CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: 仅支持CC数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstUserData  user data.CNcomment:用户数据 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S* pstUserData);
+
+/**
+\brief Extended interface for Accquire user data. CNcomment: 获取用户数据的扩展接口 CNend
+\attention \n
+support Closed Caption Data,Active Format Description.
+CNcomment: 支持CC、AFD数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enType      user data type. CNcomment:用户数据类型 CNend
+\param[out] pstUserData  user data.CNcomment:用户数据 CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Extended interface for Release user dada. CNcomment: 释放用户数据的扩展接口 CNend
+\attention \n
+Only support Closed Caption Data,Active Format Description..
+CNcomment: 仅支持CC、AFD数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enType      user data type. CNcomment:用户数据类型 CNend
+\param[in] pstUserData  user data.CNcomment:用户数据 CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Obtains the left video frame tahr are not decoded CNcomment: 获取视频流缓冲区中未被解码的帧数目 CNend
+\attention \n
+Only support AVPLAY buffer by frame mode.
+CNcomment: 仅支持按帧送数据流方式 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pLeftStreamFrm  This pointer indicates the AVPLAY buffer left video frame that are not decoded.CNcomment:视频流缓存区中没有被解码的帧数目 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetLeftStreamFrm(HI_HANDLE hAvplay, HI_U32 *pLeftStreamFrm);
+
+/**
+\brief set stream HDR information. CNcomment: 设置HDR信息接口 CNend
+\attention \n
+Only support VP9 HDR.
+CNcomment: 仅支持VP9 HDR 信息 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR信息 CNend
+\param[in] bPaddingHdrInfo    if need padding HDR information to frame information. CNcomment:是否需要填充HDR信息到帧信息中 CNend
+\param[in] u32PtsMs  current pts of HDR information.it must be set invaild(-1),when that can not available.CNcomment:当前HDR信息对应的pts CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetHDRInfo(HI_HANDLE hAvplay, HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo, HI_BOOL bPaddingHdrInfo, HI_U32 u32PtsMs);
+
+/**
+\brief Queries whether the AudioFormat is supported. CNcomment:查询 AudioFormat 是否支持 CNend
+\attention \n
+N/A
+\param[in] enFormat        Audio Format CNcomment:音频码流类型 CNend
+\param[out] pbSupport      Pointer support. This pointer indicates whether the AudioFormat is supported. CNcomment:指针类型，指示AudioFormat是否支持 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsAudioFormatSupport(const HA_FORMAT_E enFormat, HI_BOOL* pbSupport);
+
+HI_S32 HI_UNF_AVPLAY_DiscardFrame(HI_HANDLE hAvplay, HI_BOOL isDiscard);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff -uNr git/xbmc/linux/hisi/hi_unf_common.h unlib/xbmc/linux/hisi/hi_unf_common.h
--- git/xbmc/linux/hisi/hi_unf_common.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_common.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,82 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_common.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_COMMON_H__
+#define __HI_UNF_COMMON_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Media_Common */
+/** @{ */  /** <!-- [Media_Common] */
+
+/**Defines the stream buffer.*/
+/**CNcomment: 定义码流缓冲结构体 */
+typedef struct hiUNF_STREAM_BUF_S
+{
+    HI_U8   *pu8Data;        /**<Data pointer*/ /**<CNcomment: 数据指针 */
+    HI_U32  u32Size;         /**<Data size*/ /**<CNcomment: 数据长度 */
+} HI_UNF_STREAM_BUF_S;
+
+/**Defines the structure of the ES buffer.*/
+/**CNcomment: 定义ES码流缓冲结构体 */
+typedef struct hiUNF_ES_BUF_S
+{
+    HI_U8 * pu8Buf;    /**<User-state virtual address of the buffer*/ /**<CNcomment: buffer的用户态虚地址*/
+    HI_U32 u32BufLen;  /**<Buffer length*/ /**<CNcomment: buffer的长度*/
+    HI_U32 u32PtsMs;   /**<Presentation time stamp (PTS) value corresponding to the start of the stream. The invalid value is 0xFFFFFFFF.*/
+                       /**<CNcomment: 码流开始处对应的PTS值，无效为0xffffffff*/
+}HI_UNF_ES_BUF_S;
+
+/* Crop parameter */
+typedef struct hiUNF_CROP_RECT_S
+{
+    HI_U32 u32LeftOffset;
+    HI_U32 u32TopOffset;
+    HI_U32 u32RightOffset;
+    HI_U32 u32BottomOffset;
+}HI_UNF_CROP_RECT_S;
+
+/**Defines the signal status of the input source.*/
+/**CNcomment: 定义输入源的信号状态 */
+typedef enum hiUNF_SIG_STATUS_E
+{
+    HI_UNF_SIG_SUPPORT = 0,  /**<Stable signal*/            /**<CNcomment:识别稳定信号 */
+    HI_UNF_SIG_NO_SIGNAL,    /**<No signal*/                /**<CNcomment:无信号 */
+    HI_UNF_SIG_NOT_SUPPORT,  /**<Not support the signal*/   /**<CNcomment:信号不支持 */
+    HI_UNF_SIG_UNSTABLE,     /**<Unstable signal*/          /**<CNcomment:信号不稳定 */
+    HI_UNF_SIG_BUTT          /**<Invalid value*/            /**<CNcomment:非法边界值 */
+} HI_UNF_SIG_STATUS_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_COMMON_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_disp.h unlib/xbmc/linux/hisi/hi_unf_disp.h
--- git/xbmc/linux/hisi/hi_unf_disp.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_disp.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,1519 @@
+/******************************************************************************
+
+   Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_disp.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2009/12/15
+   Description   :
+   History       :
+   1.Date        : 2009/12/15
+    Author      : w58735
+    Modification: Created file
+
+ *******************************************************************************/
+
+
+/**
+ * \file
+ **\brief : define DISPLAY module information
+ * \brief supply infor about display.
+ */
+
+#ifndef  __HI_UNF_DISP_H__
+#define  __HI_UNF_DISP_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_hdmi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+/**enum define about DISPLAY channel*/
+/**CNcomment:定义DISPLAY通道枚举*/
+typedef enum hiUNF_DISP_E
+{
+    HI_UNF_DISPLAY0 = 0x0,  /**< DISPLAY0,Compatible with SD */ /**<CNcomment:高清DISPLAY0，兼容标清 */
+    HI_UNF_DISPLAY1,        /**< DISPLAY1 *//**<CNcomment: 高清DISPLAY1 */
+    HI_UNF_DISPLAY2,        /**< DISPLAY2 *//**<CNcomment: 高清DISPLAY2 */
+    HI_UNF_DISPLAY_BUTT
+}HI_UNF_DISP_E;
+
+/**max DAC count*/
+/**CNcomment:最大的DAC数目*/
+#define MAX_DAC_NUM ( 6 )
+
+/**define the LCD data format*/
+/**CNcomment:定义LCD的数据格式*/
+typedef enum hiHI_UNF_DISP_INTF_DATA_FMT
+{
+    HI_UNF_DISP_INTF_DATA_FMT_YUV422   = 0,         /**<YUV422,data width is 16*//**<CNcomment:YUV422，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB565   = 0x8,       /**<RGB565,data width is 16*//**<CNcomment:RGB565，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB444   = 0xa,       /**<RGB444,data width is 16*//**<CNcomment:RGB444，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB666   = 0xb,       /**<RGB666,data width is 24*//**<CNcomment:RGB666，位宽为24*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB888   = 0xc,       /**<RGB888,data widht is 24*//**<CNcomment:RGB888，位宽为24*/
+    HI_UNF_DISP_INTF_DATA_FMT_BUTT
+}HI_UNF_DISP_INTF_DATA_FMT_E;
+
+/**define LCD output data width*/
+/**CNcomment:定义LCD输出的数据位宽*/
+typedef enum hiUNF_DISP_INTF_DATA_WIDTH_E
+{
+    HI_UNF_DISP_INTF_DATA_WIDTH8 = 0,       /**<8 bits*//**<CNcomment:8位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH16,          /**<16 bits*//**<CNcomment:16位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH24,          /**<24 bits*//**<CNcomment:24位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_BUTT
+}HI_UNF_DISP_INTF_DATA_WIDTH_E;
+
+/**define LCD timing */
+/**CNcomment:定义LCD的时序参数*/
+typedef struct hiUNF_DISP_TIMING_S
+{
+    HI_U32                        VFB;            /**<vertical front blank*//**<CNcomment:垂直前消隐*/
+    HI_U32                        VBB;            /**<vertical back blank*//**<CNcomment:垂直后消隐*/
+    HI_U32                        VACT;           /**<vertical active area*//**<CNcomment:垂直有效区*/
+    HI_U32                        HFB;            /**<horizonal front blank*//**<CNcomment:水平前消隐*/
+    HI_U32                        HBB;            /**<horizonal back blank*//**<CNcomment:水平后消隐*/
+    HI_U32                        HACT;           /**<horizonal active area*/ /**<CNcomment:水平有效区*/
+    HI_U32                        VPW;            /**<vertical sync pluse width*//**<CNcomment:垂直脉冲宽度*/
+    HI_U32                        HPW;            /**<horizonal sync pluse width*/ /**<CNcomment:水平脉冲宽度*/
+    HI_BOOL                       IDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:有效数据信号是否翻转*/
+    HI_BOOL                       IHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:水平同步脉冲信号是否翻转*/
+    HI_BOOL                       IVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:垂直同步脉冲信号是否翻转*/
+    HI_BOOL                       ClockReversal;  /**<flag of clock is needed flip*//**<CNcomment:时钟是否翻转*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_E DataWidth;      /**<data width*/ /**<CNcomment:数据位宽*/
+    HI_UNF_DISP_INTF_DATA_FMT_E   ItfFormat;      /**<data format.*//**<CNcomment:数据格式.*/
+
+    HI_BOOL DitherEnable;                           /**< flag of is enable Dither*//**<CNcomment:数据格式.*/
+    HI_U32  ClkPara0;                               /**<PLL  register SC_VPLL1FREQCTRL0  value *//**<CNcomment:PLL  SC_VPLL1FREQCTRL0  寄存器*/
+    HI_U32  ClkPara1;                               /**<PLL  register SC_VPLL1FREQCTRL1 value*//**<CNcomment:PLL   SC_VPLL1FREQCTRL1寄存器*/
+
+    HI_BOOL bInterlace;                             /**<progressive or interlace*//**<CNcomment:逐行或者隔行*/
+    HI_U32  PixFreq;                                /**<pixel clock*//**<CNcomment:像素时钟*/
+    HI_U32  VertFreq;                               /**<display rate*//**<CNcomment:刷新率*/
+    HI_U32  AspectRatioW;                           /**<width of screen*//**<CNcomment:屏幕宽度*/
+    HI_U32  AspectRatioH;                           /**<height of screen*//**<CNcomment:屏幕高度*/
+    HI_BOOL bUseGamma;                              /**<gamma modulation*//**<CNcomment:伽马调节*/
+    HI_U32  Reserve0;                               /**<reserved byte*//**<CNcomment:保留位*/
+    HI_U32  Reserve1;                               /**<reserved byte*//**<CNcomment:保留位*/
+} HI_UNF_DISP_TIMING_S;
+
+/**define video and graphics layers */
+/**CNcomment:视频和图形层*/
+typedef enum hiUNF_DISP_LAYER_E
+{
+    HI_UNF_DISP_LAYER_VIDEO = 0,                   /**<video layer *//**<CNcomment:视频层*/
+    HI_UNF_DISP_LAYER_GFX,                  /**<graphics layer *//**<CNcomment:图形层*/
+    HI_UNF_DISP_LAYER_BUTT
+}HI_UNF_DISP_LAYER_E;
+
+/**bt1120 interface ID */
+/**CNcomment:bt1120 接口ID  */
+typedef enum hiUNF_DISP_BT1120_E
+{
+    HI_UNF_DISP_BT1120_0,    /**<BT1120 interface 0 *//**<CNcomment:BT1120接口0 */
+    HI_UNF_DISP_BT1120_BUTT,
+}HI_UNF_DISP_BT1120_E;
+
+/**BT656 interface ID */
+/**CNcomment:BT656 接口ID  */
+typedef enum hiUNF_DISP_BT656_E
+{
+    HI_UNF_DISP_BT656_0,    /**<BT656 interface 0 *//**<CNcomment:BT656接口0 */
+    HI_UNF_DISP_BT656_BUTT,
+}HI_UNF_DISP_BT656_E;
+
+/**LCD interface ID */
+/**CNcomment:LCD 接口ID  */
+typedef enum hiUNF_LCD_E
+{
+    HI_UNF_DISP_LCD_0,    /**<LCD interface 0 *//**<CNcomment:LCD接口0 */
+    HI_UNF_DISP_LCD_BUTT,
+}HI_UNF_DISP_LCD_E;
+
+/**define the type of interface*/
+/**CNcomment:定义接口类型*/
+typedef enum  hiUNF_DISP_INTF_TYPE_E
+{
+    HI_UNF_DISP_INTF_TYPE_HDMI,     /**<HDMI interface type *//**<CNcomment:HDMI接口类型*/
+    HI_UNF_DISP_INTF_TYPE_LCD,      /**<LCD interface type *//**<CNcomment:LCD接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BT1120,   /**<bt1120 digital interface type *//**<CNcomment:BT1120数字接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BT656,    /**<bt656 digital interface type*//**<CNcomment:BT656数字接口类型*/
+    HI_UNF_DISP_INTF_TYPE_YPBPR,    /**<YPBPR interface type*//**<CNcomment:YPBPR接口类型*/
+    HI_UNF_DISP_INTF_TYPE_RGB,      /**<RGB interface type*//**<CNcomment:RGB接口类型*/
+    HI_UNF_DISP_INTF_TYPE_CVBS,     /**<CVBS interface type*//**<CNcomment:CVBS接口类型*/
+    HI_UNF_DISP_INTF_TYPE_SVIDEO,   /**<SVIDEO interface type*//**<CNcomment:SVIDEO接口类型*/
+    HI_UNF_DISP_INTF_TYPE_VGA,      /**<VGA interface type*//**<CNcomment:VGA接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BUTT
+}HI_UNF_DISP_INTF_TYPE_E;
+
+/**define the YPBPR type struct of interface*/
+/**CNcomment:定义YPBPR接口结构*/
+typedef struct  hiUNF_DISP_INTF_YPBPR_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Y分量dac端口号*/
+    HI_U8 u8DacPb;            /**<DAC num of Pb  *//**<CNcomment:Pb分量dac端口号*/
+    HI_U8 u8DacPr;            /**<DAC num of Pr  *//**<CNcomment:Pr分量dac端口号*/
+}HI_UNF_DISP_INTF_YPBPR_S;
+
+/**define the RGB type struct of interface*/
+/**CNcomment:定义RGB接口结构*/
+typedef struct  hiUNF_DISP_INTF_RGB_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:R分量dac端口号*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:G分量dac端口号*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:B分量dac端口号*/
+    HI_BOOL bDacSync;         /**<G without sync signal  *//**<CNcomment:G分量不带同步信号*/
+}HI_UNF_DISP_INTF_RGB_S;
+
+/**define the VGA type struct of interface*/
+/**CNcomment:定义VGA接口结构*/
+typedef struct  hiUNF_DISP_INTF_VGA_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:R分量dac端口号*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:G分量dac端口号*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:B分量dac端口号*/
+}HI_UNF_DISP_INTF_VGA_S;
+
+/**define the CVBS type struct of interface*/
+/**CNcomment:定义CVBS接口结构*/
+typedef struct  hiUNF_DISP_INTF_CVBS_S
+{
+    HI_U8 u8Dac;              /**<DAC num of CVBS  *//**<CNcomment:CVBS端子dac端口号*/
+}HI_UNF_DISP_INTF_CVBS_S;
+
+/**define the SVIDEO type struct of interface*/
+/**CNcomment:定义SVIDEO接口结构*/
+typedef struct  hiUNF_DISP_INTF_SVIDEO_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Y分量dac端口号*/
+    HI_U8 u8DacC;             /**<DAC num of C   *//**<CNcomment:C分量dac端口号*/
+}HI_UNF_DISP_INTF_SVIDEO_S;
+
+/**define display interface struct*/
+/**CNcomment:定义显示接口结构*/
+typedef struct  hiUNF_DISP_INTF_S
+{
+    HI_UNF_DISP_INTF_TYPE_E enIntfType;         /**<interface type *//**<CNcomment:接口类型*/
+    union
+    {
+        HI_UNF_HDMI_ID_E        enHdmi;         /**<hdmi id *//**<CNcomment:HDMI 序号*/
+        HI_UNF_DISP_BT1120_E    enBT1120;       /**<bt1120 id *//**<CNcomment:BT1120序号*/
+        HI_UNF_DISP_BT656_E     enBT656;        /**<bt656 id *//**<CNcomment:BT656序号*/
+        HI_UNF_DISP_LCD_E       enLcd;          /**<lcd id *//**<CNcomment:LCD序号*/
+
+        HI_UNF_DISP_INTF_YPBPR_S    stYPbPr;    /**<intf config of YPBPR  *//**<CNcomment:YPBPR接口配置*/
+        HI_UNF_DISP_INTF_RGB_S      stRGB;      /**<intf config of RGB  *//**<CNcomment:RGB接口配置*/
+        HI_UNF_DISP_INTF_VGA_S      stVGA;      /**<intf config of VGA  *//**<CNcomment:VGA接口配置*/
+        HI_UNF_DISP_INTF_CVBS_S     stCVBS;     /**<intf config of CVBS  *//**<CNcomment:CVBS接口配置*/
+        HI_UNF_DISP_INTF_SVIDEO_S   stSVideo;   /**<intf config of SVIDEO  *//**<CNcomment:SVIDEO接口配置*/
+    }unIntf;
+}HI_UNF_DISP_INTF_S;
+
+
+/**Defines the device aspect ratio.*/
+/**CNcomment: 定义设备宽高比枚举*/
+typedef enum hiUNF_DISP_ASPECT_RATIO_E
+{
+    HI_UNF_DISP_ASPECT_RATIO_AUTO,              /**<aspect ratio as device Resolution*//**<CNcomment: 宽高比与设备分辨率一致*/
+    HI_UNF_DISP_ASPECT_RATIO_4TO3,              /**<4:3*//**<CNcomment: 4比3*/
+    HI_UNF_DISP_ASPECT_RATIO_16TO9,             /**<16:9*//**<CNcomment: 16比9*/
+    HI_UNF_DISP_ASPECT_RATIO_221TO1,            /**<221:100*//**<CNcomment: 221比100*/
+    HI_UNF_DISP_ASPECT_RATIO_USER,              /**<user define*//**<CNcomment: 用户定义*/
+
+    HI_UNF_DISP_ASPECT_RATIO_BUTT
+}HI_UNF_DISP_ASPECT_RATIO_E;
+
+/**Defines the device aspect ratio struct.*/
+/**CNcomment: 定义设备宽高比结构*/
+typedef struct hiUNF_DISP_ASPECT_RATIO_S
+{
+    HI_UNF_DISP_ASPECT_RATIO_E enDispAspectRatio;   /**<aspect ratio type of device*//**<CNcomment: 设备宽高比类型*/
+    HI_U32                     u32UserAspectWidth;  /**<user define width of device*//**<CNcomment: 用户定义设备宽度*/
+    HI_U32                     u32UserAspectHeight; /**<user define height of device*//**<CNcomment: 用户定义设备高度*/
+}HI_UNF_DISP_ASPECT_RATIO_S;
+
+/**Defines algorithmic  control struct of display device.*/
+/**CNcomment: 定义显示设备算法控制结构*/
+typedef struct hiUNF_DISP_ALG_CFG_S
+{
+    HI_BOOL bAccEnable;                             /**<acc alg*//**<CNcomment: acc算法*/
+    HI_BOOL bSharpEnable;                           /**<sharp alg*//**<CNcomment: sharp算法*/
+}HI_UNF_DISP_ALG_CFG_S;
+
+/**Defines VBI type.*/
+/**CNcomment: 定义VBI数据类型*/
+typedef enum hiUNF_DISP_VBI_TYPE_E
+{
+    HI_UNF_DISP_VBI_TYPE_TTX = 0,                   /**<Teltext type*//**<CNcomment:teltext类型*/
+    HI_UNF_DISP_VBI_TYPE_CC,                        /**<Closed caption/V-Chip type *//**<CNcomment: 隐藏字幕/V-Chip类型*/
+    HI_UNF_DISP_VBI_TYPE_WSS,                       /**<Wide screen signal*//**<CNcomment:宽屏信令*/
+    HI_UNF_DISP_VBI_TYPE_BUTT
+} HI_UNF_DISP_VBI_TYPE_E;
+
+/**Defines VBI config struct.*/
+/**CNcomment: 定义VBI配置结构*/
+typedef struct hiUNF_DISP_VBI_CFG_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI 类型*/
+    HI_U32                  u32InBufferSize;        /**<VBI data(pes) buffer size,more than 4K,suggest 4K*//**<CNcomment:VBI pes 数据输入缓冲大小,不小于4K，推荐值4K*/
+    HI_U32                  u32WorkBufferSize;      /**<VBI data buffer size used in driver,more than 2K,suggest 2K*//**<CNcomment:VBI解析后数据在驱动中接收缓冲大小不小于2K，推荐值2K*/
+} HI_UNF_DISP_VBI_CFG_S;
+
+/** define VBI information structure*/
+/**CNcomment: 定义VBI信息数据结构*/
+typedef struct hiUNF_DISP_VBI_DATA_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI 类型*/
+    HI_U8                   *pu8DataAddr;           /**<Vbi data buffer virtual address*//**<CNcomment:Vbi数据用户虚拟地址*/
+    HI_U32                  u32DataLen;             /**<Vbi data lenght*//**<CNcomment:Vbi数据长度*/
+} HI_UNF_DISP_VBI_DATA_S;
+
+/**Defines the MAX buffer number.*/
+/** CNcomment:定义最大的buffer 分配数*/
+#define HI_DISP_CAST_BUFFER_MAX_NUMBER ( 16 )
+
+/**define CAST config */
+/**CNcomment:定义屏幕投影配置*/
+typedef struct hiUNF_DISP_CAST_ATTR_S
+{
+    HI_UNF_VIDEO_FORMAT_E enFormat;                                        /**<the output video format.*//**<CNcomment:定义输出视频格式*/
+    HI_U32                u32Width;                                       /**<the output video width.*//**<CNcomment:定义输出视频的宽*/
+    HI_U32                u32Height;                                      /**<the output video height.*//**<CNcomment:定义输出视频的高*/
+    HI_BOOL               bLowDelay;                                      /**<work at low delay mode.*//**<CNcomment:启用低延迟模式*/
+    HI_U32                u32BufNum;                                      /**<the buffer number.*//**<CNcomment:定义分配buffer 数*/
+    HI_BOOL               bUserAlloc;                                     /**<whether is user alloc memory*//**<CNcomment:定义是否用户分配内存*/
+    HI_U32                u32BufSize;                                     /**<each the buffer size.*//**<CNcomment:定义用户分配每个buffer 大小*/
+    HI_U32                u32BufStride;                                   /**<the horizonal stride.*//**<CNcomment:定义行对齐*/
+    HI_U32                u32BufPhyAddr[HI_DISP_CAST_BUFFER_MAX_NUMBER];  /**<the buffer physics address.*//**<CNcomment:分配内存buffer 成员的物理地址*/
+    HI_BOOL               bCrop;                                          /**<whether enable crop .*//**<CNcomment:定义是否进行crop*/
+    HI_UNF_CROP_RECT_S    stCropRect;                                     /**<the crop wise .*//**<CNcomment:定义crop 范围*/
+} HI_UNF_DISP_CAST_ATTR_S;
+
+/**define color setting */
+/**CNcomment:定义色彩设置*/
+typedef struct hiUNF_DISP_COLOR_SETTING_S
+{
+    HI_BOOL bGammaEnable;         /**<whether Gamma enable.*//**<CNcomment:定义Gamma 使能*/
+    HI_BOOL bUseCustGammaTable;   /**<whether use custom GammaTable.*//**<CNcomment:是否使用用户Gamma表*/
+    HI_BOOL bColorCorrectEnable;  /**<whether Color Correct.*//**<CNcomment:是否色彩校正*/
+    HI_S32  s32ColorTemp;         /**<color Temp.*//**<CNcomment:色温*/
+    HI_U32  u32Reserve;           /**<Reserve.*//**<CNcomment:保留*/
+    HI_VOID *pPrivate;            /**<Private.*//**<CNcomment:私有体指针*/
+}HI_UNF_DISP_COLOR_SETTING_S;
+
+/**define the struct about color */
+/**CNcomment:定义显示颜色的结构体 */
+typedef struct  hiUNF_DISP_BG_COLOR_S
+{
+    HI_U8 u8Red;                  /**<red *//**<CNcomment:红色分量*/
+    HI_U8 u8Green;                /**<green*//**<CNcomment:绿色分量*/
+    HI_U8 u8Blue;                 /**<blue*//**<CNcomment:蓝色分量*/
+} HI_UNF_DISP_BG_COLOR_S;
+
+/**define the struct about isogeny attributes */
+/**CNcomment:定义同源属性 */
+typedef struct  hiUNF_DISP_ISOGENY_ATTR_S
+{
+    HI_UNF_DISP_E          enDisp; /**<channel id*//**<CNcomment: 通道号*/
+    HI_UNF_ENC_FMT_E       enFormat;/**<format type*//**<CNcomment:制式类型*/
+}HI_UNF_DISP_ISOGENY_ATTR_S ;
+
+
+/********************************ENCODER STRUCT********************************/
+/** define the enum of Macrovision output type*/
+/** CNcomment:显示输出Macrovision模式枚举定义*/
+typedef enum hiUNF_DISP_MACROVISION_MODE_E
+{
+    HI_UNF_DISP_MACROVISION_MODE_TYPE0,     /**<type 0 *//**<CNcomment:典型配置0 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE1,     /**<type 1 *//**<CNcomment:典型配置1 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE2,     /**<type 2 *//**<CNcomment:典型配置2 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE3,     /**<type 3 *//**<CNcomment:典型配置3 */
+    HI_UNF_DISP_MACROVISION_MODE_CUSTOM,    /**<type of configure by user *//**<CNcomment:用户自定义配置 */
+    HI_UNF_DISP_MACROVISION_MODE_BUTT
+} HI_UNF_DISP_MACROVISION_MODE_E;
+
+/** CGMS type select */
+/**CNcomment:CGMS 类型选择*/
+typedef enum hiUNF_DISP_CGMS_TYPE_E
+{
+    HI_UNF_DISP_CGMS_TYPE_A = 0x00,     /**<CGMS type  A*//**<CNcomment:CGMS 类型A*/
+    HI_UNF_DISP_CGMS_TYPE_B,            /**<CGMS type  B*//**<CNcomment:CGMS 类型B*/
+
+    HI_UNF_DISP_CGMS_TYPE_BUTT
+}HI_UNF_DISP_CGMS_TYPE_E;
+
+/** definition of CGMS mode */
+/**CNcomment:定义CGMS 模式*/
+typedef enum hiUNF_DISP_CGMS_MODE_E
+{
+    HI_UNF_DISP_CGMS_MODE_COPY_FREELY  = 0,     /**<copying is permitted without restriction *//**<CNcomment:无限制拷贝*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NO_MORE = 0x01,  /**<No more copies are allowed (one generation copy has been made)*//**<CNcomment:拷贝一次后不允许再被拷贝*/
+    HI_UNF_DISP_CGMS_MODE_COPY_ONCE    = 0x02,  /**<One generation of copies may be made *//**<CNcomment:仅允许拷贝一次*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NEVER   = 0x03,  /**<No copying is permitted *//**<CNcomment:不允许拷贝*/
+
+    HI_UNF_DISP_CGMS_MODE_BUTT
+}HI_UNF_DISP_CGMS_MODE_E;
+
+/** definition of CGMS configuration */
+typedef struct hiUNF_DISP_CGMS_CFG_S
+{
+    HI_BOOL                 bEnable;            /**<HI_TRUE:CGMS is enabled; HI_FALSE:CGMS is disabled *//**<CNcomment:CGMS 使能选项*/
+    HI_UNF_DISP_CGMS_TYPE_E enType;             /**<type-A or type-B or None(BUTT) *//**<CNcomment:CGMS 类型*/
+    HI_UNF_DISP_CGMS_MODE_E enMode;             /**<CGMS mode. *//**<CNcomment:CGMS 模式*/
+}HI_UNF_DISP_CGMS_CFG_S;
+
+/**define WSS information structure*/
+/**CNcomment:定义图文信息数据结构 */
+typedef struct hiUNF_DISP_WSS_DATA_S
+{
+    HI_BOOL bEnable;                            /**<WSS configure enable HI_TRUE: enable,HI_FALSE: disnable*//**<CNcomment:WSS配置使能。HI_TRUE：使能；HI_FALSE：禁止*/
+    HI_U16  u16Data;                            /**<Wss data */ /**<CNcomment:Wss数据*/
+}HI_UNF_DISP_WSS_DATA_S;
+
+
+/**define display 3D mode stucture*/
+/**CNcomment:定义显示模式结构体 */
+typedef enum hiUNF_DISP_3D_E
+{
+    HI_UNF_DISP_3D_NONE = 0,
+    HI_UNF_DISP_3D_FRAME_PACKING,                   /**<3d type:Frame Packing*//**<CNcomment:3d 模式:帧封装*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_HALF,               /**<3d type:Side by side half*//**<CNcomment:3d 模式:并排式 左右半边*/
+    HI_UNF_DISP_3D_TOP_AND_BOTTOM,                  /**<3d type:Top and Bottom*//**<CNcomment:3d 模式:上下模式*/
+    HI_UNF_DISP_3D_FIELD_ALTERNATIVE,               /**<3d type:Field alternative*//**<CNcomment:3d 模式:场交错*/
+    HI_UNF_DISP_3D_LINE_ALTERNATIVE,                /**<3d type:Field alternative*//**<CNcomment:3d 模式:行交错*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_FULL,               /**<3d type:Side by side full*//**<CNcomment:3d 模式:并排式 左右全场*/
+    HI_UNF_DISP_3D_L_DEPTH,                         /**<3d type:L+depth*//**<CNcomment:3d 模式:L+DEPTH*/
+    HI_UNF_DISP_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d 模式:L+depth+Graphics+Graphics-depth*/
+    HI_UNF_DISP_3D_BUTT
+}HI_UNF_DISP_3D_E;
+
+/**define display margin stucture*/
+/**CNcomment:定义显示空白区域结构体 */
+typedef struct hiUNF_DISP_OFFSET_S
+{
+    HI_U32 u32Left;    /**<left offset *//**<CNcomment:左侧偏移*/
+    HI_U32 u32Top;     /**<top offset *//**<CNcomment:上方偏移*/
+    HI_U32 u32Right;   /**<right offset *//**<CNcomment:右侧偏移*/
+    HI_U32 u32Bottom;  /**<bottom offset *//**<CNcomment:下方偏移*/
+}HI_UNF_DISP_OFFSET_S;
+
+/**define output signal type.*/
+/**CNcomment:定义输出信号类型*/
+typedef enum hiUNF_DISP_HDR_TYPE_E
+{
+    HI_UNF_DISP_HDR_TYPE_NONE = 0,      /**<Normal SDR signal output type *//**<CNcomment:普通SDR 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_AUTO,          /**<Optimum signal output type automatically *//**<CNcomment:自动适配最佳信号输出*/
+    HI_UNF_DISP_HDR_TYPE_DOLBY,         /**<DolbyVision signal output type *//**<CNcomment:DolbyVision 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_HDR10,         /**<HDR10 signal output type *//**<CNcomment:HDR10 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_HLG,           /**<HLG signal output type *//**<CNcomment:HLG 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_BUTT
+} HI_UNF_DISP_HDR_TYPE_E;
+
+/**SD format should use BT601*/
+/**CNcomment:标清制式强制使用色彩空间BT601*/
+typedef enum hiHI_UNF_DISP_COLOR_SPACE_E
+{
+    HI_UNF_DISP_COLOR_SPACE_AUTO = 0x0,     /**<  optimum output color space *//**<CNcomment:最佳色彩空间输出*/
+    HI_UNF_DISP_COLOR_SPACE_BT709,          /**< output  color space BT709*//**<CNcomment:输出色彩空间BT709*/
+    HI_UNF_DISP_COLOR_SPACE_BT2020,         /**< output  color space BT2020*//**<CNcomment:输出色彩空间BT2020*/
+    HI_UNF_DISP_COLOR_SPACE_BUTT
+}HI_UNF_DISP_COLOR_SPACE_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+
+/**
+   \brief Initiallization DISP module.CNcomment:初始化DISP模块 CNend
+   \attention \n
+   Please call this API function, before call anyother API of DISP module.
+   CNcomment:调用DISP模块其它接口前要求首先调用本接口 CNend
+   \param  none.CNcomment:无 CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_DEV_NOT_EXIST DISP device not exist.CNcomment:设备不存在 CNend
+   \retval ::HI_ERR_DISP_NOT_DEV_FILE  DISP  not device file .CNcomment:非设备 CNend
+   \retval ::HI_ERR_DISP_DEV_OPEN_ERR  DISP  open fail.CNcomment:打开失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Init( HI_VOID );
+
+
+/**
+   \brief deinital.CNcomment:去初始化DISP模块 CNend
+   \attention \n
+   please call API HI_UNF_DISP_Close and open all the DISP device, before call this API.
+   CNcomment:在调用::HI_UNF_DISP_Close接口关闭所有打开的DISP后调用本接口 CNend
+   \param none.CNcomment:无 CNend
+   \retval ::HI_SUCCESS success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_DEV_CLOSE_ERR  DISP close fail.CNcomment:关闭失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DeInit( HI_VOID );
+
+
+/**
+   \brief Attach one DISP channel to anoter.CNcomment:将两个DISP通道绑定 CNend
+   \attention \n
+   Please finish the attach operation before the DISP channel has been open, and currently we only support HD channel attach to SD channel.
+   CNcomment:目前支持将高清DISP绑定到标清DISP通道上，绑定在打开DISP通道前必须完成绑定操作。 CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:目标DISP通道号 CNend
+   \param[in] enSrcDisp   source DISP channel.CNcomment:  源DISP通道号 CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT  display not be initialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid opeation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Attach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief dettach DISP.CNcomment:将两个DISP通道解绑定 CNend
+   \attention \n
+   should  close the DISP channels, before do detach operation.
+   CNcomment:只有在关闭两个DISP通道后才能进行解绑定操作。 CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:目标DISP通道号 CNend
+   \param[in] enSrcDisp    source DISP channel.CNcomment: 源DISP通道号 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Detach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief open DISP channel.CNcomment:打开指定DISP通道 CNend
+   \attention \n
+   Please config the valid parameters before open DISP.
+   CNcomment:在打开DISP之前，先完成对其的参数设置，避免画面闪烁 CNend
+   \param[in] enDisp   DISP channel ID, please reference the define of HI_UNF_DISP_E.CNcomment:DISP通道号，请参见::HI_UNF_DISP_E CNend
+   \retval ::HI_SUCCESS success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    DISP create fail.CNcomment:DISP创建失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Open( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  coase DISP channel.CNcomment:关闭指定DISP CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP通道号 CNend
+   \retval ::HI_SUCCESS success. CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Close( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  set DISP interface parameter.CNcomment:设置DISP的接口参数 CNend
+   \attention \n
+   The API is uesed for set  interface attach .If the interface has been attached,must be detach it ,or return HI_ERR_DISP_INVALID_OPT;\n
+   There are 4 DAC provided by SOC 3712 v300. suggest, DAC 0/1/2 used by HD channel, DAC3 used by SD channel CVBS. \n
+   There are 6 DAC provided by SOC 3716 v100/v200/v300. suggest, DAC 0/1/2 used by HD channel, DAC3/4/5 used by SD channel.
+   CNcomment:该API 用来设置输出接口的绑定关系，如果设置已被绑定过的接口，则需要先进行Detach操作\n
+   解除绑定关系，否则返回错误HI_ERR_DISP_INVALID_OPT;\n
+   3712 v300 芯片共有4个DAC，推荐0，1，2用作高清输出，3用作标清CVBS输出。\n
+   3716 v100/v200/v300 芯片共有6个DAC，推荐0，1，2用作高清输出，3，4，5用作标清输出。CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32IntfNum  DISP intf num of DISP channel.CNcomment:DISP通道上的接口数目 CNend
+   \param[in] pstIntf  DISP intf para.CNcomment:DISP接口参数 CNend
+   \retval ::HI_SUCCESS   success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR      Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AttachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief cancel DISP interface parameter.CNcomment:取消DISP的接口参数 CNend
+   \attention \n
+   The API is uesed to  detach  interface.
+   CNcomment:这个API 用来解除接口的绑定关系。 CNend
+   \param[in] enDisp        DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32IntfNum  DISP interface number of DISP channel.CNcomment:DISP通道上的接口数目 CNend
+   \param[in] pstIntf  DISP interface para.CNcomment:DISP接口参数 CNend
+   \retval ::HI_SUCCESS   success. CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR        Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DetachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief set DISP output format.CNcomment:设置DISP的制式 CNend
+   \attention \n
+   for HD DISP channel please set HD display format, and for SD DISP channel please set SD display format.\n
+   for scenario of HD,SD use same source, only support format which frame rate is 50Hz or 60Hz.
+   CNcomment:对高清的DISP，只能设置高清的制式；对标清的DISP，只能设置标清的制式。\n
+   在同源显示场景下，暂不支持刷新率非50Hz/60Hz的制式，如：暂不支持1080P24/1080P25/1080P30 CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enEncodingFormat    DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E enEncodingFormat );
+
+
+/**
+   \brief get DISP format.CNcomment:获取DISP的制式 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] penEncodingFormat    poiner of DISP format.DCNcomment:ISP的制式指针 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E *penEncodingFormat );
+
+
+/**
+   \brief set user define LCD clock parameter.CNcomment:设置用户定义的LCD时序参数 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstTiming    poiner of DISP format.CNcomment:LCD时序参数 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief  get LCD parameter which had been config.CNcomment:获取DISP的LCD参数 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstTiming      pointer of LCD paramter.CNcomment:指针类型，LCD参数 CNend
+   \retval ::HI_SUCCESS success.CNcomment: 成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief   set DISP layers Z order.CNcomment:设置DISP上叠加层的Z序 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP通道号 CNend
+   \param[in] enLayer        layer ID which needed overlay to the DISP channel.CNcomment: DISP上的叠加层 CNend
+   \param[in] enZFlag        the way of overlay.CNcomment:Z序调节方式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_LAYER_ZORDER_E enZFlag );
+
+
+/**
+   \brief  get DISP overlay z order.CNcomment:获取DISP上叠加层的Z序 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enLayer           CNcomment:DISP上的叠加层 CNend
+   \param[in] pu32Zorder        CNcomment:叠加层Z序数值，数值越大优先级越高 CNend
+   \retval ::HI_SUCCESS success.CNcomment: 成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_U32 *pu32Zorder );
+
+
+/**
+   \brief set DISP back ground color.CNcomment:设置DISP背景色 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp       CNcomment:DISP通道号 CNend
+   \param[in] pstBgColor   CNcomment:指针类型，待配置的显示输出背景色。请参见::HI_UNF_BG_COLOR_S CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetBgColor( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP back ground color.CNcomment:获取DISP背景色 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstBgColor   pointer of back ground color.CNcomment: 指针类型，显示输出背景色 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetBgColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP brightness.CNcomment:设置DISP亮度 CNend
+   \attention \n
+   if the value seted more than 100, we clip it to 100.CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Brightness   brightness value. the range is 0~100, 0 means the min brightness value.
+   CNcomment:待设置的显示输出亮度值。取值范围为0～100。0：最小亮度；100：最大亮度 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetBrightness( HI_UNF_DISP_E enDisp, HI_U32 u32Brightness );
+
+
+/**
+   \brief   get the DISP brightness.CNcomment:获取DISP亮度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:查询的默认亮度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Brightness    pointer of brightness. CNcomment:指针类型，显示输出亮度值 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetBrightness( HI_UNF_DISP_E enDisp, HI_U32 *pu32Brightness );
+
+
+/**
+   \brief  set DISP contrast value.CNcomment:设置DISP对比度 CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Contrast    contrast value. the range is 0~100, 0 means the min contrast value. \n
+   CNcomment:待设置的显示输出对比度值。取值范围为0～100。0：最小对比度；100：最大对比度 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetContrast( HI_UNF_DISP_E enDisp, HI_U32 u32Contrast );
+
+
+/**
+   \brief  get DISP contrast value.CNcomment:获取DISP对比度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认对比度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Contrast   pointer of contrast. CNcomment:指针类型，显示输出对比度值 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetContrast( HI_UNF_DISP_E enDisp, HI_U32 *pu32Contrast );
+
+
+/**
+   \brief   set DISP saturation.CNcomment:设置DISP饱和度 CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp             DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Saturation      saturation value. the range is 0~100, 0 means the min saturation value. \n
+   CNcomment:待设置的显示输出饱和度值。取值范围为0～100。0：最小饱和度；100：最大饱和度 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_DISP_SetSaturation( HI_UNF_DISP_E enDisp, HI_U32 u32Saturation );
+
+
+/**
+   \brief   get DISP saturation.CNcomment:获取DISP饱和度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认饱和度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp                 DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Saturation    pointer of saturation. CNcomment:指针类型，显示输出饱和度值 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetSaturation( HI_UNF_DISP_E enDisp, HI_U32 *pu32Saturation );
+
+
+/**
+   \brief  set DISP hueplus.CNcomment:设置DISP色调 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32HuePlus       hueplus value. the range is 0~100, 0 means the min hueplus value. \n
+   CNcomment:显示输出色调增益值。范围为0～100。0：表示最小色调增益；100：表示最大色调增益 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 u32HuePlus );
+
+
+/**
+   \brief get DISP hueplus.CNcomment:获取DISP色调 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认色调值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP通道号 CNend
+   \param[out] pu32HuePlus     pointer of hueplus. CNcomment:指针类型，显示输出色调增益值 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 *pu32HuePlus );
+
+
+/**
+   \brief  set Wss.CNcomment:直接设置WSS（Wide Screen Singnalling）数据 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstWssData        pointer of Wss data description structure.CNcomment:指针类型，指向WSS数据的指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetWss( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_WSS_DATA_S *pstWssData );
+
+
+/**
+   \brief  set Macrovision mode.CNcomment:设置Macrovision模式 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enMode        Macrovision mode.  CNcomment:Macrovision模式，请参见::HI_UNF_MACROVISION_MODE_E CNend
+   \param[in] pData          pointer of Macrovision control data CNcomment: 指针类型，自定义的Macrovision控制数据 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E enMode, const HI_VOID *pData );
+
+
+/**
+   \brief get Macrovision mode.CNcomment: 获取Macrovision模式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penMode    pointer of Macrovision mode. CNcomment:指针类型，MACROVISION模式 CNend
+   \param[out] pData      a data pointer only valid whenpenMode=HI_MACROVISION_MODE_CUSTOM.\n
+   CNcomment:指针类型，仅当penMode=HI_MACROVISION_MODE_CUSTOM时有效 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E *penMode, const HI_VOID *pData );
+
+
+/**
+   \brief   set CGMS data.CNcomment:设置CGMS（Copy Generation Management System）数据 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp                   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstCgmsCfg             pointer of CGMS configuration  CNcomment:指针类型，指向CGMS配置数据的指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCgms( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_CGMS_CFG_S *pstCgmsCfg );
+
+
+/**
+   \brief chip do or not support Macrovision.CNcomment: 获取芯片是否支持Macrovision CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pbSupport    pointer of Macrovision flag. CNcomment:指针类型，Macrovision 标志 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovisionSupport( HI_UNF_DISP_E enDisp, HI_BOOL *pbSupport );
+
+/**
+   \brief set aspect ratio attribute of display device.CNcomment: 设置设备宽高比 CNend
+   \attention \n
+   If set AspectRatio USER mode ,must be set u32UserAspectWidth and u32UserAspectHeight \n
+   (theWidth/Height range is 1/64~64,if set zero means using current screen AspectRatio.) \n
+   If not AspectRatio USER mode ,it will be set value by enumeration means;In this mode u32UserAspectWidth and u32UserAspectHeight are invalid ;\n
+   If set AspectRatio AUTO mode , use current screen AspectRatio;
+   CNcomment:如果设置USER模式则需设置u32UserAspectWidth 和u32UserAspectHeight的值，\n
+   赋值范围为两者比值1/64~64,如果设置0则表示使用当前屏幕的宽高比；\n
+   非USER模式则按照对应的比值起效u32UserAspectWidth 和u32UserAspectHeight的值无效\n
+   其中设置AUTO模式则设备宽高比值自动设置为当前屏幕的宽高比。 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment:指针类型，显示设备宽高比信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief get aspect ratio attribute of display device.CNcomment: 获得设备宽高比属性 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment:指针类型，显示设备宽高比信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief set algorithmic attribute of display device.CNcomment: 设置设备算法属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstAlg    pointer of algorithmic attribute of display device . CNcomment:指针类型，显示设备算法属性 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief get algorithmic status of display device.CNcomment: 获取设备算法属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstAlg    pointer of algorithmic attribute of display device . CNcomment:指针类型，显示设备算法属性 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief create VBI data channel.CNcomment: 创建VBI数据通道 CNend
+   \attention \n
+   Each VBI type can not  created  repeatedly,if created more than one time,it will be return HI_ERR_DISP_CREATE_ERR;
+   CNcomment:每种VBI类型只能创建一次，多次创建则返回HI_ERR_DISP_CREATE_ERR CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstCfg    pointer of parameter of VBI channel . CNcomment:指针类型，VBI通道参数 CNend
+   \param[out] phVbi    pointer of VBI handle . CNcomment:指针类型，VBI通道句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    invalid operation. CNcomment:创建失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_CreateVBI( HI_UNF_DISP_E enDisp, HI_UNF_DISP_VBI_CFG_S *pstCfg, HI_HANDLE *phVbi );
+
+
+/**
+   \brief destroy VBI data channel.CNcomment: 销毁VBI数据通道 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI 通道句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyVBI( HI_HANDLE hVbi );
+
+
+/**
+   \brief send data to vbi channel.CNcomment: 发送数据到VBI通道 CNend
+   \attention \n
+   After  call HI_UNF_DISP_CreateVBI creat VBI handle sucess,you can call API HI_UNF_DISP_SendVBIData send VBI data .
+   CNcomment:调用HI_UNF_DISP_CreateVBI 创建VBI通道成功后，才能调用HI_UNF_DISP_SendVBIData  发送数据 CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI 通路句柄 CNend
+   \param[in] pstVbiData      pointer of VBI data.CNcomment:VBI数据指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SendVBIData(HI_HANDLE hVbi, HI_UNF_DISP_VBI_DATA_S *pstVbiData);
+
+/**
+   \brief Get default attributes of screen share channel.CNcomment: 获取屏幕投影通道的默认属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[out]pstAttr     pointer of parameter .CNcomment:指针,配置参数 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetDefaultCastAttr(HI_UNF_DISP_E enDisp,HI_UNF_DISP_CAST_ATTR_S *pstAttr);
+
+
+/**
+   \brief create screen share channel.CNcomment: 创建屏幕投影通道 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstAttr      pointer of parameter .CNcomment:指针,配置参数 CNend
+   \param[out] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_CreateCast(HI_UNF_DISP_E enDisp, HI_UNF_DISP_CAST_ATTR_S * pstAttr, HI_HANDLE *phCast);
+
+
+/**
+   \brief destroy screen share channel.CNcomment: 销毁屏幕投影通道 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyCast( HI_HANDLE hCast );
+
+
+/**
+   \brief enable screen share.CNcomment: 使能屏幕投影功能 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[in] bEnable      enable screen share .CNcomment:使能屏幕投影 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCastEnable( HI_HANDLE hCast, HI_BOOL bEnable );
+
+
+/**
+   \brief get enable flag of screen share.CNcomment: 获取屏幕投影是否使能 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[out] bEnable     flag .CNcomment:标志 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetCastEnable( HI_HANDLE hCast, HI_BOOL *pbEnable );
+
+
+/**
+   \brief get frame info of screen share.CNcomment: 获取屏幕投影帧信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] hCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[out] pstFrameInfo        frame info.CNcomment:帧信息 CNend
+   \param[in] u32TimeoutMs wait time in ms.CNcomment:等待时间，毫秒为单位 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \retval ::HI_ERR_DISP_TIMEOUT          operation timeout. CNcomment:操作超时 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo, HI_U32 u32TimeoutMs);
+
+
+/**
+   \brief release frame info of screen share.CNcomment: 释放屏幕投影帧信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] hCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[in] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseCastFrame( HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo );
+
+
+/**
+   \brief professional color modulation.CNcomment: 专业色彩调节 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstCS      struct of color modulation.CNcomment:色彩调节结构 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \brief get color modulation parameter.CNcomment: 获取色彩调节信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstCS      struct of color modulation.CNcomment:色彩调节结构 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \Snapshot truncation screen connection, intercepts the screen complete picture;CNcomment:截取屏幕完整画面; CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[out] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+/**
+   \Release Snapshot picture;CNcomment:释放截屏画面; CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+
+/**
+   \brief get color modulation parameter.CNcomment:设置DISP的默认属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetDefaultPara( HI_UNF_DISP_E enDisp);
+
+
+/**
+   \brief set DISP 3D format.CNcomment:设置DISP的3D制式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] en3D             DISP 3D mode.CNcomment:DISP 3D模式 CNend
+   \param[in] enEncodingFormat DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Set3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E en3D, HI_UNF_ENC_FMT_E enEncFormat);
+
+/**
+   \brief get DISP 3D format.CNcomment:查询DISP的3D制式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pen3D           DISP 3D mode.CNcomment:DISP 3D模式 CNend
+   \param[out] penEncFormat    DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Get3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E *pen3D, HI_UNF_ENC_FMT_E *penEncFormat);
+
+/**
+   \brief set right eye first for 3D output.CNcomment:设置3D输出右眼优先 CNend
+   \attention \n
+   Only take effect in 3D output mode. CNcomment: 仅在3D输出时有效 CNend
+   \param[in] enDisp     DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] bEnable   Right-Eye-First.CNcomment:右眼优先 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetRightEyeFirst(HI_UNF_DISP_E enDisp, HI_BOOL bEnable);
+
+/**
+   \brief set virtual screen size of display.CNcomment:设置显示通道的虚拟屏幕大小 CNend
+   \attention \n
+   if not set ,default value is 1280*720. CNcomment: 如果不设置此函数，默认的虚拟屏幕大小是720p. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Width  virtual screen width, the range is [480, 3840].CNcomment:虚拟屏幕宽度，取值范围为[480, 3840]. CNend
+   \param[in] u32Height  virtual screen height, the range is [480, 3840].CNcomment:虚拟屏幕高度，取值范围为[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 u32Width, HI_U32 u32Height);
+
+/**
+   \brief get virtual screen size of display.CNcomment:获取显示通道的虚拟屏幕大小 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] u32Width  virtual screen width, the range is [480, 3840].CNcomment:虚拟屏幕宽度，取值范围为[480, 3840]. CNend
+   \param[out] u32Height  virtual screen height, the range is [480, 3840].CNcomment:虚拟屏幕高度，取值范围为[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 *u32Width, HI_U32 *u32Height);
+
+
+/**
+   \brief set offset of display area in real screen.CNcomment:设置显示区域在实体屏幕上的偏移量,为物理像素点 CNend
+   \attention \n
+   must be 4 pixels aligned,if not set, the default value is 0. CNcomment: offset 值必须是4对齐,如果不设置默认的值为0. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstOffset  offset in pixel, the range is [0, 200].CNcomment:偏移像素数目，取值范围为[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief get offset of display area in real screen.CNcomment:获取显示区域在实体屏幕上的偏移量,为物理像素点 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstOffset  offset in pixel, the range is [0, 200].CNcomment:偏移像素数目，取值范围为[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief set isogeny attributes.CNcomment: 设置同源属性 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] pstIsogeny isogenous attributes.CNcomment:同源模式下，要设置的属性信息 CNend
+   \param[in] u32ChannelNum  channel counts to be set in isogenous mode.CNcomment:同源模式下，要设置属性的通道个数 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetIsogenyAttr(const HI_UNF_DISP_ISOGENY_ATTR_S *pstIsogeny, const HI_U32 u32ChannelNum);
+
+/**
+   \brief set display output type.CNcomment: 设置显示输出类型 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enHDRType   DISP type.CNcomment:HDR 输出类型CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRType(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_HDR_TYPE_E enHDRType);
+
+/**
+   \brief Get display output type.CNcomment: 获取显示输出类型 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penHDRType   DISP type.CNcomment:HDR输出类型CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRType(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_TYPE_E *penHDRType);
+
+/**
+   \brief Set display output color space.CNcomment: 设置输出色彩空间 CNend
+   \attention \n
+   should set sink capability with HI_UNF_DISP_SetSinkCapability api when set auto out color space.
+   CNcomment: 设置AUTO输出时，必须先调用HI_UNF_DISP_SetSinkCapability接口 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enColorSpace output color space.CNcomment:设置输出色彩空间CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_COLOR_SPACE_E enColorSpace);
+
+/**
+   \brief Get display output color space.CNcomment: 获取输出色彩空间 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penColorSpace output color space.CNcomment:获取输出色彩空间CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputColorSpace(HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SPACE_E *penColorSpace);
+
+/**
+   \brief Set capability of sink .CNcomment: 设置Sink端能力集CNend
+   \attention \n
+    Sink capability can acquire from hdmi, Strongly recommend to set sink capability when detect hdmi hot-plot event .
+    CNcomment: 可从HDMI接口中获取到Sink端的能力集，强烈建议在每一次热插拔事件被检测到时重新设置Sink 能力集 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstSinkCap output color space.CNcomment:设置Sink端能力集CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetSinkCapability( HI_UNF_DISP_E enDisp, const HI_UNF_EDID_BASE_INFO_S *pstSinkCap);
+
+/**
+   \brief Set alpha of video .CNcomment: 设置视频alpha值CNend
+   \attention \n
+    none  CNcomment: 无CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Alpha video alpha value.CNcomment:视频的alpha值CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetVideoAlpha( HI_UNF_DISP_E enDisp, HI_U32 u32Alpha );
+
+/**
+   \brief Get alpha of video .CNcomment: 获取视频alpha值CNend
+   \attention \n
+    none CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pu32Alpha video alpha value.CNcomment:获取的视频alpha值CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetVideoAlpha(HI_UNF_DISP_E enDisp, HI_U32 *pu32Alpha);
+
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif
+/************************************** The End Of File **************************************/
diff -uNr git/xbmc/linux/hisi/hi_unf_video.h unlib/xbmc/linux/hisi/hi_unf_video.h
--- git/xbmc/linux/hisi/hi_unf_video.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_video.h	2018-01-29 11:05:38.382234400 +0800
@@ -0,0 +1,646 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_video.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_VIDEO_H__
+#define __HI_UNF_VIDEO_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include "hi_common.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VIDEO */
+/** @{ */  /** <!-- [VIDEO] */
+
+/**Defines the oversample mode.*/
+/**CNcomment: 定义过采样模式*/
+typedef enum hiUNF_OVERSAMPLE_MODE_E
+{
+    HI_UNF_OVERSAMPLE_1X = 0,
+    HI_UNF_OVERSAMPLE_2X,
+    HI_UNF_OVERSAMPLE_4X,
+    HI_UNF_OVERSAMPLE_BUTT,
+} HI_UNF_OVERSAMPLE_MODE_E;
+
+/**Defines the pixel width.*/
+/**CNcomment: 定义像素位宽*/
+typedef enum hiUNF_PIXEL_BITWIDTH_E
+{
+    HI_UNF_PIXEL_BITWIDTH_8BIT = 0,
+    HI_UNF_PIXEL_BITWIDTH_10BIT,
+    HI_UNF_PIXEL_BITWIDTH_12BIT,
+    HI_UNF_PIXEL_BITWIDTH_BUTT,
+} HI_UNF_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: 定义颜色空间枚举*/
+typedef enum hiUNF_COLOR_SPACE_E
+{
+    HI_UNF_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_UNF_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_UNF_COLOR_SPACE_BT601_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_UNF_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_UNF_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_UNF_COLOR_SPACE_BT709_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT709_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_UNF_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_UNF_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_UNF_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_UNF_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_UNF_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_UNF_COLOR_SPACE_JPEG = 0x90,
+    HI_UNF_COLOR_SPACE_RGB = 0xa0,
+
+    HI_UNF_COLOR_SPACE_BUTT
+} HI_UNF_COLOR_SPACE_E;
+
+/**Defines the RGB range.*/
+/**CNcomment: 定义RGB 范围*/
+typedef enum hiUNF_RGB_RANGE_E
+{
+    HI_UNF_RGB_DEFAULT,
+    HI_UNF_RGB_LIMIT_RANGE,
+    HI_UNF_RGB_FULL_RANGE,
+    HI_UNF_RGB_RANGE_BUTT
+} HI_UNF_RGB_RANGE_E;
+/**Defines the video norm.*/
+/**CNcomment: 定义视频制式枚举*/
+typedef enum hiUNF_ENC_FMT_E
+{
+    HI_UNF_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/
+    HI_UNF_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/
+    HI_UNF_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/
+    HI_UNF_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/
+    HI_UNF_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/
+
+    HI_UNF_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/
+    HI_UNF_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/
+
+    HI_UNF_ENC_FMT_720P_60,          /**<720p 60 Hz*/
+    HI_UNF_ENC_FMT_720P_50,          /**<720p 50 Hz */
+
+    HI_UNF_ENC_FMT_576P_50,          /**<576p 50 Hz*/
+    HI_UNF_ENC_FMT_480P_60,          /**<480p 60 Hz*/
+
+    HI_UNF_ENC_FMT_PAL,              /* B D G H I PAL */
+    HI_UNF_ENC_FMT_PAL_N,            /* (N)PAL        */
+    HI_UNF_ENC_FMT_PAL_Nc,           /* (Nc)PAL       */
+
+    HI_UNF_ENC_FMT_NTSC,             /* (M)NTSC       */
+    HI_UNF_ENC_FMT_NTSC_J,           /* NTSC-J        */
+    HI_UNF_ENC_FMT_NTSC_PAL_M,       /* (M)PAL        */
+
+    HI_UNF_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/
+    HI_UNF_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/
+
+    HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_50_FRAME_PACKING,
+
+    HI_UNF_ENC_FMT_861D_640X480_60,
+    HI_UNF_ENC_FMT_VESA_800X600_60,
+    HI_UNF_ENC_FMT_VESA_1024X768_60,
+    HI_UNF_ENC_FMT_VESA_1280X720_60,
+    HI_UNF_ENC_FMT_VESA_1280X800_60,
+    HI_UNF_ENC_FMT_VESA_1280X1024_60,
+    HI_UNF_ENC_FMT_VESA_1360X768_60,
+    HI_UNF_ENC_FMT_VESA_1366X768_60,
+    HI_UNF_ENC_FMT_VESA_1400X1050_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X1200_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60_RB,
+    HI_UNF_ENC_FMT_VESA_1920X1080_60,
+    HI_UNF_ENC_FMT_VESA_1920X1200_60,
+    HI_UNF_ENC_FMT_VESA_1920X1440_60,
+    HI_UNF_ENC_FMT_VESA_2048X1152_60,
+    HI_UNF_ENC_FMT_VESA_2560X1440_60_RB,
+    HI_UNF_ENC_FMT_VESA_2560X1600_60_RB,
+
+    HI_UNF_ENC_FMT_3840X2160_24 = 0x40,
+    HI_UNF_ENC_FMT_3840X2160_25,
+    HI_UNF_ENC_FMT_3840X2160_30,
+    HI_UNF_ENC_FMT_3840X2160_50,
+    HI_UNF_ENC_FMT_3840X2160_60,
+
+    HI_UNF_ENC_FMT_4096X2160_24,
+    HI_UNF_ENC_FMT_4096X2160_25,
+    HI_UNF_ENC_FMT_4096X2160_30,
+    HI_UNF_ENC_FMT_4096X2160_50,
+    HI_UNF_ENC_FMT_4096X2160_60,
+
+    HI_UNF_ENC_FMT_3840X2160_23_976,
+    HI_UNF_ENC_FMT_3840X2160_29_97,
+    HI_UNF_ENC_FMT_720P_59_94,
+    HI_UNF_ENC_FMT_1080P_59_94,
+    HI_UNF_ENC_FMT_1080P_29_97,
+    HI_UNF_ENC_FMT_1080P_23_976,
+    HI_UNF_ENC_FMT_1080i_59_94,
+    HI_UNF_ENC_FMT_BUTT
+}HI_UNF_ENC_FMT_E;
+
+/**Defines the mode of the video decoder.*/
+/**CNcomment: 定义视频解码器模式枚举*/
+typedef enum hiUNF_VCODEC_MODE_E
+{
+    HI_UNF_VCODEC_MODE_NORMAL = 0,   /**<Decode all frames.*/ /**<CNcomment: 解所有帧*/
+    HI_UNF_VCODEC_MODE_IP,           /**<Decode only I frames and P frames.*/ /**<CNcomment: 只解IP帧*/
+    HI_UNF_VCODEC_MODE_I,            /**<Decode only I frames.*/ /**<CNcomment: 只解I帧*/
+    HI_UNF_VCODEC_MODE_DROP_INVALID_B,  /**<Decode all frames except the first B frame sequence behind I frames */ /**<CNcomment: 解所有帧，除了紧跟着I帧后面的B帧*/
+    HI_UNF_VCODEC_MODE_BUTT
+} HI_UNF_VCODEC_MODE_E;
+
+/**Defines special control operation of decoder*/
+/**CNcomment: 定义解码器解码的特殊控制选项 */
+typedef enum hiHI_UNF_VCODEC_CTRL_OPTION_E
+{
+    HI_UNF_VCODEC_CTRL_OPTION_NORMAL_DPB = 0x0,
+    HI_UNF_VCODEC_CTRL_OPTION_SIMPLE_DPB = 0x1
+} HI_UNF_VCODEC_CTRL_OPTION_E;
+
+/**Defines the decoding capability (resolution) of the decoder.*/
+/**CNcomment: 定义解码器解码能力(分辨率) */
+typedef enum hiUNF_VCODEC_CAP_LEVEL_E
+{
+    HI_UNF_VCODEC_CAP_LEVEL_NULL = 0, /**<Do not decode.*/ /**<CNcomment: 不需要解码 */
+    HI_UNF_VCODEC_CAP_LEVEL_QCIF = 0, /**<The resolution of the picture to be decoded is less than or equal to 176x144.*/ /**<CNcomment: 解码的图像大小不超过176*144 */
+    HI_UNF_VCODEC_CAP_LEVEL_CIF,      /**<The resolution of the picture to be decoded less than or equal to 352x288.*/ /**<CNcomment: 解码的图像大小不超过352*288 */
+    HI_UNF_VCODEC_CAP_LEVEL_D1,       /**<The resolution of the picture to be decoded less than or equal to 720x576.*/ /**<CNcomment: 解码的图像大小不超过720*576 */
+    HI_UNF_VCODEC_CAP_LEVEL_720P,     /**<The resolution of the picture to be decoded is less than or equal to 1280x720.*/ /**<CNcomment: 解码的图像大小不超过1280*720 */
+    HI_UNF_VCODEC_CAP_LEVEL_FULLHD,   /**<The resolution of the picture to be decoded is less than or equal to 1920x1080.*/ /**<CNcomment: 解码的图像大小不超过1920*1080 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_1280x800, /**<The resolution of the picture to be decoded is less than or equal to 1280x800.*/ /**<CNcomment: 解码的图像大小不超过1280x800*/
+    HI_UNF_VCODEC_CAP_LEVEL_800x1280, /**<The resolution of the picture to be decoded is less than or equal to 800x1280.*/ /**<CNcomment: 解码的图像大小不超过800x1280*/
+    HI_UNF_VCODEC_CAP_LEVEL_1488x1280, /**<The resolution of the picture to be decoded is less than or equal to 1488x1280.*/ /**<CNcomment: 解码的图像大小不超过1488x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x1488, /**<The resolution of the picture to be decoded is less than or equal to 1280x1488.*/ /**<CNcomment: 解码的图像大小不超过1280x1488 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x1280, /**<The resolution of the picture to be decoded is less than or equal to 2160x1280.*/ /**<CNcomment: 解码的图像大小不超过2160x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x2160, /**<The resolution of the picture to be decoded is less than or equal to 1280x2160.*/ /**<CNcomment: 解码的图像大小不超过1280x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x2160, /**<The resolution of the picture to be decoded is less than or equal to 2160x2160.*/ /**<CNcomment: 解码的图像大小不超过2160x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x2160, /**<The resolution of the picture to be decoded is less than or equal to 4096x2160.*/ /**<CNcomment: 解码的图像大小不超过4096x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x4096, /**<The resolution of the picture to be decoded is less than or equal to 2160x4096.*/ /**<CNcomment: 解码的图像大小不超过2160x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x4096, /**<The resolution of the picture to be decoded is less than or equal to 4096x4096.*/ /**<CNcomment: 解码的图像大小不超过4096x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x4096, /**<The resolution of the picture to be decoded is less than or equal to 8192x4096.*/ /**<CNcomment: 解码的图像大小不超过8192x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x8192, /**<The resolution of the picture to be decoded is less than or equal to 4096x8192.*/ /**<CNcomment: 解码的图像大小不超过4096x8192 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x8192, /**<The resolution of the picture to be decoded is less than or equal to 8192x8192.*/ /**<CNcomment: 解码的图像大小不超过8192x8192 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_BUTT
+} HI_UNF_VCODEC_CAP_LEVEL_E;
+
+/**Defines the stream type supported by the decoder.*/
+/**CNcomment: 定义解码器支持的码流类型 */
+typedef enum hiUNF_VCODEC_TYPE_E
+{
+    HI_UNF_VCODEC_TYPE_MPEG2,
+    HI_UNF_VCODEC_TYPE_MPEG4,       /**<MPEG4 DIVX4 DIVX5 */
+    HI_UNF_VCODEC_TYPE_AVS,
+    HI_UNF_VCODEC_TYPE_H263,
+    HI_UNF_VCODEC_TYPE_H264,
+    HI_UNF_VCODEC_TYPE_REAL8,
+    HI_UNF_VCODEC_TYPE_REAL9,
+    HI_UNF_VCODEC_TYPE_VC1,
+    HI_UNF_VCODEC_TYPE_VP6,
+    HI_UNF_VCODEC_TYPE_VP6F,
+    HI_UNF_VCODEC_TYPE_VP6A,
+    HI_UNF_VCODEC_TYPE_MJPEG,
+    HI_UNF_VCODEC_TYPE_SORENSON,    /**<SORENSON SPARK */
+    HI_UNF_VCODEC_TYPE_DIVX3,
+    HI_UNF_VCODEC_TYPE_RAW,
+    HI_UNF_VCODEC_TYPE_JPEG,        /**<Used only for VENC */
+    HI_UNF_VCODEC_TYPE_VP8,
+    HI_UNF_VCODEC_TYPE_MSMPEG4V1,   /**<MS private MPEG4 */
+    HI_UNF_VCODEC_TYPE_MSMPEG4V2,
+    HI_UNF_VCODEC_TYPE_MSVIDEO1,    /**<MS video */
+    HI_UNF_VCODEC_TYPE_WMV1,
+    HI_UNF_VCODEC_TYPE_WMV2,
+    HI_UNF_VCODEC_TYPE_RV10,
+    HI_UNF_VCODEC_TYPE_RV20,
+    HI_UNF_VCODEC_TYPE_SVQ1,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_SVQ3,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_H261,
+    HI_UNF_VCODEC_TYPE_VP3,
+    HI_UNF_VCODEC_TYPE_VP5,
+    HI_UNF_VCODEC_TYPE_CINEPAK,
+    HI_UNF_VCODEC_TYPE_INDEO2,
+    HI_UNF_VCODEC_TYPE_INDEO3,
+    HI_UNF_VCODEC_TYPE_INDEO4,
+    HI_UNF_VCODEC_TYPE_INDEO5,
+    HI_UNF_VCODEC_TYPE_MJPEGB,
+    HI_UNF_VCODEC_TYPE_MVC,
+    HI_UNF_VCODEC_TYPE_HEVC,
+    HI_UNF_VCODEC_TYPE_DV,
+    HI_UNF_VCODEC_TYPE_VP9,
+    HI_UNF_VCODEC_TYPE_AVS2,
+    HI_UNF_VCODEC_TYPE_BUTT
+}HI_UNF_VCODEC_TYPE_E;
+
+/**Defines the H264 profile of the video encoder.*/
+/**CNcomment: 定义视频解码器 H264协议档次*/
+typedef enum hiUNF_H264_PROFILE_E
+{
+    HI_UNF_H264_PROFILE_BASELINE = 0,   /**<Encode H264 stream by baseline profile.*/ /**<CNcomment: 采用基线档次编码H264码流*/
+    HI_UNF_H264_PROFILE_MAIN,           /**<Encode H264 stream by main profile.*/     /**<CNcomment:采用主要档次编码H264码流*/
+    HI_UNF_H264_PROFILE_EXTENDED,       /**<Encode H264 stream by extended profile.*/ /**<CNcomment:采用扩展档次编码H264码流*/
+    HI_UNF_H264_PROFILE_HIGH,           /**<Encode H264 stream by high profile.*/     /**<CNcomment: 采用高级档次编码H264码流*/
+    HI_UNF_H264_PROFILE_BUTT
+}HI_UNF_H264_PROFILE_E;
+
+typedef enum hiUNF_VIDEO_HDR_TYPE_E
+{
+    HI_UNF_VIDEO_HDR_TYPE_HDR10 = 0,
+    HI_UNF_VIDEO_HDR_TYPE_HLG,
+    HI_UNF_VIDEO_HDR_TYPE_BUTT
+}HI_UNF_VIDEO_HDR_TYPE_E;
+
+typedef struct hiUNF_VCODEC_VC1_ATTR_S
+{
+    HI_BOOL  bAdvancedProfile;   /**<Whether the profile is an advanced profile*/ /**<CNcomment: 是否Advanced Profile*/
+    HI_U32   u32CodecVersion;    /**<Version number*/ /**<CNcomment: 版本号*/
+}HI_UNF_VCODEC_VC1_ATTR_S;
+
+typedef struct hiUNF_VCODEC_VP6_ATTR_S
+{
+    HI_BOOL  bReversed;     /**<To reverse a picture, set this parameter to 1. In this cases, set it to 0.*/ /**<CNcomment: 图像需要倒转时置1，否则置0*/
+    HI_U16   u16DispWidth;  /**<Display Width.*/ /**<CNcomment: 图像的显示宽度*/
+    HI_U16   u16DispHeight; /**<Display Height.*/ /**<CNcomment: 图像的显示高度*/
+}HI_UNF_VCODEC_VP6_ATTR_S;
+
+typedef union hiUNF_VCODEC_EXTATTR_U
+{
+    HI_UNF_VCODEC_VC1_ATTR_S stVC1Attr;
+    HI_UNF_VCODEC_VP6_ATTR_S stVP6Attr;
+}HI_UNF_VCODEC_EXTATTR_U;
+
+/**Defines the attributes of a video decoder.*/
+/**CNcomment: 定义视频解码器属性结构*/
+typedef struct hiUNF_VCODEC_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enType;          /**<Video encoding type*/ /**<CNcomment: 视频编码类型*/
+    HI_UNF_VCODEC_EXTATTR_U     unExtAttr;       /**<Extra attributes related to the video encoding type*/ /**<CNcomment: 视频编码类型相关的额外属性*/
+    HI_UNF_VCODEC_MODE_E        enMode;          /**<Mode of a video decoder*/ /**<CNcomment: 视频解码器模式模式*/
+    HI_U32                      u32ErrCover;     /**<Error concealment threshold of the output frames of a video decoder. The value 0 indicates that no frames are output if an error occurs; the value 100 indicates that all frames are output no matter whether errors occur.*/
+                                                 /**<CNcomment: 视频解码器的输出帧错误隐藏门限，0:出现错误即不输出；100:不管错误比例全部输出*/
+    HI_U32                      u32Priority;     /**<Priority of a video decoder. The value range is [1, HI_UNF_VCODEC_MAX_PRIORITY]. The value 0 is a reserved value. If you set the value to 0, no error message is displayed, but the value 1 is used automatically. The smaller the value, the lower the priority.*/
+                                                 /**<CNcomment: 视频解码器优先级, 取值范围: 大于等于1，小于等于HI_UNF_VCODEC_MAX_PRIORITY, 0是保留值，配置为0不会报错，但是会自动取值为1,数值越小优先级越低 */
+    HI_BOOL                     bOrderOutput;    /**<Whether the videos are output by the decoding sequence. You are advised to set this parameter to HI_TRUE in VP mode, and HI_FALSE in other modes.*/
+                                                 /**<CNcomment: 是否按解码序输出，VP模式下推荐配置为HI_TRUE, 一般模式下配置为HI_FALSE */
+    HI_S32                      s32CtrlOptions;  /**<The value is HI_UNF_VCODEC_CTRL_OPTION_E, or the 'or' value of several enum type*/
+                                                 /**<CNcomment: 取值为HI_UNF_VCODEC_CTRL_OPTION_E，或者几个枚举的'或'  */
+    HI_VOID*                    pCodecContext;   /**<Private codec context */
+}HI_UNF_VCODEC_ATTR_S;
+
+/**Defines the hdr attributes of a video decoder.*/
+/**CNcomment: 定义视频HDR属性结构*/
+typedef struct hiUNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S
+{
+    HI_U16 u16DisplayPrimaries_x[3];
+    HI_U16 u16DisplayPrimaries_y[3];
+    HI_U16 u16WhitePoint_x;
+    HI_U16 u16WhitePoint_y;
+    HI_U32 u32MaxDisplayMasteringLuminance;
+    HI_U32 u32MinDisplayMasteringLuminance;
+} HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S;
+
+typedef struct hiUNF_VIDEO_CONTENT_LIGHT_LEVEL_S
+{
+    HI_U32 u32MaxContentLightLevel;
+    HI_U32 u32MaxPicAverageLightLevel;
+} HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S;
+
+typedef struct hiUNF_VIDEO_HDR10__S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering数据是否可用,0:不可用；1:可用*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content数据是否可用,0:不可用；1:可用*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+} HI_UNF_VIDEO_HDR10_INFO_S;
+
+typedef struct hiUNF_VIDEO_HLG_INFO_S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering数据是否可用,0:不可用；1:可用*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content数据是否可用,0:不可用；1:可用*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+    HI_U8  u8BackWardsCompatible;
+} HI_UNF_VIDEO_HLG_INFO_S;
+
+typedef union hiUNF_VIDEO_HDR_METADATA_U
+{
+    HI_UNF_VIDEO_HDR10_INFO_S stHdr10Info;
+    HI_UNF_VIDEO_HLG_INFO_S   stHlgInfo;
+}HI_UNF_VIDEO_HDR_METADATA_U;
+
+typedef struct hiUNF_VIDEO_HDR_INFO_S
+{
+    HI_UNF_VIDEO_HDR_TYPE_E          enHdrType;
+    HI_UNF_VIDEO_HDR_METADATA_U      unHdrMetadata;
+} HI_UNF_VIDEO_HDR_INFO_S;
+
+/**Defines the sub stream protocol.*/
+/**CNcomment: 定义码流的协议分支枚举*/
+typedef enum hiUNF_VIDEO_SUB_STANDARD_E
+{
+    HI_UNF_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: 未知协议分支*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2协议族可以兼容MPEG1 */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4协议族可以兼容SHV*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4协议包含XVID分支*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4协议包含DIVX分支*/
+
+    HI_UNF_VIDEO_SUB_STANDARD_BUTT
+}HI_UNF_VIDEO_SUB_STANDARD_E;
+
+/**Defines the frame rate of the video stream.*/
+/**CNcomment: 定义视频码流帧率结构*/
+typedef struct hiUNF_VCODEC_FRMRATE_S
+{
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+                              /**<CNcomment: 码流的帧率的小数部分（保留3位）, fps */
+}HI_UNF_VCODEC_FRMRATE_S;
+
+/**Defines the information about video streams.*/
+/**CNcomment: 定义视频码流信息结构*/
+typedef struct hiUNF_VCODEC_STREAMINFO_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Stream type*/ /**<CNcomment: 码流类型 */
+    HI_UNF_VIDEO_SUB_STANDARD_E enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment: 码流的协议分支 */
+    HI_U32                      u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment: 码流子协议版本号 */
+    HI_U32                      u32Profile;     /**<Stream profile*/ /**<CNcomment: 码流的profile */
+    HI_U32                      u32Level;       /**<Stream level*/ /**<CNcomment: 码流的level */
+    HI_UNF_ENC_FMT_E            enDisplayNorm;  /**<Display norm (PAL or NTSC)*/ /**<CNcomment: 显示标准(P/N) */
+    HI_BOOL                     bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_U32                      u32AspectWidth; /**<Output aspect ratio: width*/ /**<CNcomment: 输出宽高比之宽值 */
+    HI_U32                      u32AspectHeight;/**<Output aspect ratio: height*/ /**<CNcomment: 输出宽高比之高值 */
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: 码流的码率, Kbps */
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的小数部分（保留3位）, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment: 解码图像宽 */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment: 解码图像高 */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment: 显示图像宽 */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment: 显示图像高 */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心横坐标，以原始图像的左上角为坐标原点 */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心纵坐标，以原始图像的左上角为坐标原点 */
+}HI_UNF_VCODEC_STREAMINFO_S;
+
+
+/**Defines the types of the user data in the video information.*/
+/**CNcomment: 定义视频信息中的用户数据类型 */
+typedef enum hiHI_UNF_VIDEO_USERDATA_TYPE_E
+{
+    HI_UNF_VIDEO_USERDATA_UNKNOWN = 0,      /**<Unknown type*/ /**<CNcomment: 未知类型*/
+    HI_UNF_VIDEO_USERDATA_DVB1_CC = 0x1,    /**<Closed Caption Data*/ /**<CNcomment: 字幕数据*/
+    HI_UNF_VIDEO_USERDATA_DVB1_BAR = 0x2,   /**<Bar Data*/ /**<CNcomment: Bar数据*/
+    HI_UNF_VIDEO_USERDATA_AFD = 0x10000,    /**<Active Format Description*/ /**<CNcomment: 模式描述数据*/
+    HI_UNF_VIDEO_USERDATA_BUTT
+}HI_UNF_VIDEO_USERDATA_TYPE_E;
+
+/**Defines the profile of video broadcasting.*/
+/**CNcomment: 定义视频广播的profile枚举*/
+typedef enum hiUNF_VIDEO_BROADCAST_PROFILE_E
+{
+    HI_UNF_VIDEO_BROADCAST_DVB,        /**<Digital video broadcasting (DVB)*/ /**<CNcomment: 数字视频广播DVB*/
+    HI_UNF_VIDEO_BROADCAST_DIRECTV,    /**<American live broadcast operator DirecTV*/ /**<CNcomment: 美国直播运营商DirecTV*/
+    HI_UNF_VIDEO_BROADCAST_ATSC,       /**<Advanced Television Systems Committee (ATSC)*/ /**<CNcomment: 先进电视制式委员会ATSC（Advanced Television Systems Committee）*/
+    HI_UNF_VIDEO_BROADCAST_DVD,        /**<Digital video disc (DVD)*/ /**<CNcomment: 数字视频光盘*/
+    HI_UNF_VIDEO_BROADCAST_ARIB,       /**<Association of Radio Industries and Businesses (ARIB)*/ /**<CNcomment: 无线电工业及商业协会规格*/
+    HI_UNF_VIDEO_BROADCAST_BUTT
+}HI_UNF_VIDEO_BROADCAST_PROFILE_E;
+
+/**Defines the position of the user data in the video information.*/
+/**CNcomment: 定义视频信息中用户数据的位置枚举*/
+typedef enum hiUNF_VIDEO_USER_DATA_POSITION_E
+{
+    HI_UNF_VIDEO_USER_DATA_POSITION_UNKNOWN,       /**<Unknown*/ /**<CNcomment: 未知位置*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_SEQ,     /**<The data is parsed from sequences under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从序列中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_GOP,     /**<The data is parsed from the group of pictures (GOP) under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从GOP（Group Of Pictures）中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_FRAME,   /**<The data is parsed from picture frames under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从图像帧中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSOS,    /**<The data is parsed from the sequences of visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从可视对像序列中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSO,     /**<The data is parsed from visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从可视对像中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VOL,     /**<The data is parsed from the video object layer under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从视频对像层中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_GOP,     /**<The data is parsed from the GOP under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从GOP中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_REG,      /**<The data is parsed from the user_data_regestered_itu_t_t35() syntax under the H.264 protocol.*/ /**<CNcomment: 从H.264协议的user_data_regestered_itu_t_t35()语法中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_UNREG,    /**<The data is parsed from the user_data_unregestered() syntax under the H.264 protocol.*/ /**<CNcomment: 从H.264协议的user_data_unregestered()语法中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_BUTT
+}HI_UNF_VIDEO_USER_DATA_POSITION_E;
+
+/**Defines the structure of the user data in the video information.*/
+/**CNcomment: 定义视频信息中的用户数据结构*/
+typedef struct hiUNF_VIDEO_USERDATA_S
+{
+    HI_UNF_VIDEO_BROADCAST_PROFILE_E   enBroadcastProfile;   /**<Broadcasting profile of the user data*/ /**<CNcomment: 用户数据的广播profile*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_E  enPositionInStream;   /**<Position of the user data in video streams*/ /**<CNcomment: 用户数据在视频流中的位置*/
+    HI_U32                             u32Pts;               /**<PTS corresponding to the user data*/ /**<CNcomment: 用户数据对应的时间戳*/
+    HI_U32                             u32SeqCnt;            /**<Sequence ID of the user data*/ /**<CNcomment: 用户数据的前一序列数*/
+    HI_U32                             u32SeqFrameCnt;       /**<Frame number of the user data*/ /**<CNcomment: 用户数据的前一帧数*/
+    HI_U8                              *pu8Buffer;           /**<Initial address of the user data memory, output parameter*/ /**<CNcomment: 用户数据内存区的初始地址,输出参数*/
+    HI_U32                             u32Length;            /**<User data size (a multiple of 1 byte)*/ /**<CNcomment: 用户数据的大小，以1byte为单位*/
+    HI_BOOL                            bBufferOverflow;      /**<Indicate that whether the user data size exceeds the maximum size defined by MAX_USER_DATA_LEN.*/ /**<CNcomment: 标志用户数据的长度是否超过了MAX_USER_DATA_LEN定义的最大值*/
+    HI_BOOL                            bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: 顶场优先标志*/
+}HI_UNF_VIDEO_USERDATA_S;
+
+/**Defines the parameters of format changing */
+/**CNcomment: 定义制式切换时的相关参数*/
+typedef struct hiUNF_NORMCHANGE_PARAM_S
+{
+    HI_UNF_ENC_FMT_E            enNewFormat;            /**<New format*/ /**<CNcomment: 新的制式*/
+    HI_U32                      u32ImageWidth;          /**<Width of image*/ /**<CNcomment: 图像宽度*/
+    HI_U32                      u32ImageHeight;         /**<Height of image*/ /**<CNcomment: 图像高度*/
+    HI_BOOL                     bProgressive;           /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_U32                      u32FrameRate;           /**<Frame rate*//**<CNcomment:帧率*/
+}HI_UNF_NORMCHANGE_PARAM_S;
+
+/**Defines the video format.*/
+/**CNcomment: 定义视频格式枚举*/
+typedef enum hiUNF_VIDEO_FORMAT_E
+{
+    /* Semi-Planner */
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422,       /**<The YUV spatial sampling format is 4:2:2.*/ /**<CNcomment: YUV空间采样格式为4:2:2*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is 4:2:0, V first.*/ /**<CNcomment: YUV空间采样格式为4:2:0，V在低位*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_400,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_411,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_444,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420_UV,   /**<The YUV spatial sampling format is 4:2:0,U first.*/ /**<CNcomment: YUV空间采样格式为4:2:0, U在低位*/
+
+
+    /* Package */
+    HI_UNF_FORMAT_YUV_PACKAGE_UYVY,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为UYVY*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YUYV,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YUYV*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YVYU,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YVYU*/
+
+    /* Planner */
+    HI_UNF_FORMAT_YUV_PLANAR_400,
+    HI_UNF_FORMAT_YUV_PLANAR_411,
+    HI_UNF_FORMAT_YUV_PLANAR_420,
+    HI_UNF_FORMAT_YUV_PLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_PLANAR_422_2X1,
+    HI_UNF_FORMAT_YUV_PLANAR_444,
+    HI_UNF_FORMAT_YUV_PLANAR_410,
+    HI_UNF_FORMAT_YUV_TILE_420,	            /**<The YUV spatial sampling format is TILE 4:2:0, V first.*/
+    HI_UNF_FORMAT_YUV_TILE_420_UV,          /**<The YUV spatial sampling format is TILE 4:2:0, U first.*/
+    HI_UNF_FORMAT_YUV_BUTT,
+
+    HI_UNF_FORMAT_RGB_SEMIPLANAR_444,
+    HI_UNF_FORMAT_RGB_BUTT
+}HI_UNF_VIDEO_FORMAT_E;
+
+/**Defines the type of the video frame.*/
+/**CNcomment: 定义视频帧的类型枚举*/
+typedef enum hiUNF_VIDEO_FRAME_TYPE_E
+{
+    HI_UNF_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: 未知的帧类型*/
+    HI_UNF_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I帧*/
+    HI_UNF_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P帧*/
+    HI_UNF_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B帧*/
+	HI_UNF_FRAME_TYPE_IDR,       /**<IDR frame*/ /**<CNcomment: IDR帧*/
+    HI_UNF_FRAME_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode.*/
+/**CNcomment: 定义视频帧场模式枚举*/
+typedef enum hiUNF_VIDEO_FIELD_MODE_E
+{
+    HI_UNF_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: 帧模式*/
+    HI_UNF_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: 顶场模式*/
+    HI_UNF_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: 底场模式*/
+    HI_UNF_VIDEO_FIELD_BUTT
+}HI_UNF_VIDEO_FIELD_MODE_E;
+
+
+/**Defines 3D frame packing type*/
+typedef enum hiUNF_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_UNF_FRAME_PACKING_TYPE_NONE,             /**< Normal frame, not a 3D frame */
+    HI_UNF_FRAME_PACKING_TYPE_SIDE_BY_SIDE,     /**< Side by side */
+    HI_UNF_FRAME_PACKING_TYPE_TOP_AND_BOTTOM,   /**< Top and bottom */
+    HI_UNF_FRAME_PACKING_TYPE_TIME_INTERLACED,  /**< Time interlaced: one frame for left eye, the next frame for right eye */
+    HI_UNF_FRAME_PACKING_TYPE_FRAME_PACKING,    /**< frame packing */
+    HI_UNF_FRAME_PACKING_TYPE_3D_TILE,          /**< Tile 3D */
+    HI_UNF_FRAME_PACKING_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_PACKING_TYPE_E;
+
+typedef struct hiUNF_VIDEO_FRAME_ADDR_S
+{
+    HI_U32             u32YAddr;    /**<Address of the Y component in the current frame*/ /**<CNcomment: 当前帧Y分量数据的地址*/
+    HI_U32             u32CAddr;    /**<Address of the C component in the current frame*/ /**<CNcomment: 当前帧C分量数据的地址*/
+    HI_U32             u32CrAddr;   /**<Address of the Cr component in the current frame*/ /**<CNcomment: 当前帧Cr分量数据的地址*/
+
+    HI_U32             u32YStride;  /**<Stride of the Y component*/ /**<CNcomment: Y分量数据的跨幅*/
+    HI_U32             u32CStride;  /**<Stride of the C component*/ /**<CNcomment: C分量数据的跨幅*/
+    HI_U32             u32CrStride; /**<Stride of the Cr component*/ /**<CNcomment: Cr分量数据的跨幅*/
+}HI_UNF_VIDEO_FRAME_ADDR_S;
+
+typedef struct hiUNF_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32FrameIndex;      /**<Frame index ID of a video sequence*/ /**<CNcomment: 视频序列中的帧索引号*/
+    HI_UNF_VIDEO_FRAME_ADDR_S           stVideoFrameAddr[2];
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: 原始图像宽*/
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: 原始图像高*/
+    HI_U32                              u32SrcPts;          /**<Original PTS of a video frame*/ /**<CNcomment: 视频帧的原始时间戳*/
+    HI_U32                              u32Pts;             /**<PTS of a video frame*/ /**<CNcomment: 视频帧的时间戳*/
+    HI_U32                              u32AspectWidth;
+    HI_U32                              u32AspectHeight;
+    HI_UNF_VCODEC_FRMRATE_S             stFrameRate;
+
+    HI_UNF_VIDEO_FORMAT_E               enVideoFormat;      /**<Video YUV format*/ /**<CNcomment: 视频YUV格式*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_UNF_VIDEO_FIELD_MODE_E           enFieldMode;        /**<Frame or field encoding mode*/ /**<CNcomment: 帧或场编码模式*/
+    HI_BOOL                             bTopFieldFirst;     /**<Top field first flag*/ /**<CNcomment: 顶场优先标志*/
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+    HI_U32                              u32Circumrotate;    /**<Need circumrotate, 1 need */
+    HI_BOOL                             bVerticalMirror;
+    HI_BOOL                             bHorizontalMirror;
+    HI_U32                              u32DisplayWidth;    /**<Width of the displayed picture*/ /**<CNcomment: 显示图像宽*/
+    HI_U32                              u32DisplayHeight;   /**<Height of the displayed picture*/ /**<CNcomment: 显示图像高*/
+    HI_U32                              u32DisplayCenterX;  /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: 显示中心x坐标，原始图像左上角为坐标原点*/
+    HI_U32                              u32DisplayCenterY;  /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: 显示中心y坐标，原始图像左上角为坐标原点*/
+    HI_U32                              u32ErrorLevel;      /**<Error percentage of a decoded picture, ranging from 0% to 100%*/ /**<CNcomment: 一幅解码图像中的错误比例，取值为0～100*/
+    HI_U32                              u32Private[64];     /**<Private data for every frame: 
+                                                                u32Private[0]: securty flag, if u32Private[0] == 1, this is a secure frame;
+                                                                */
+    
+    
+}HI_UNF_VIDEO_FRAME_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_STATUS_INFO_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E enVidFrmType; /**<Type of video frame*/ /**<CNcomment: 视频帧类型*/ 
+    HI_U32 u32VidFrmStreamSize;             /**<Size of video frame*/ /**<CNcomment: 视频帧大小*/ 
+    HI_U32 u32VidFrmQP;                     /**<QP of video frame*/ /**<CNcomment: 视频帧QP*/ 
+    HI_U32 u32VidFrmPTS;                    /**<PTS of video frame*/ /**<CNcomment: 视频帧pts*/
+    HI_U32 u32MaxMV;                        /**<MAX MV*/ /**<CNcomment: 视频帧最大MV*/
+    HI_U32 u32MinMV;                        /**<MIN MV*/ /**<CNcomment: 视频帧最小MV*/
+    HI_U32 u32AvgMV;                        /**<AVG MV*/ /**<CNcomment: 视频帧MV平均值*/
+    HI_U32 u32SkipRatio;                    /**<MB ratio */ /**<CNcomment: 视频帧MB比例0~100*/
+}HI_UNF_VIDEO_FRM_STATUS_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_DISPLAY_TIME_S
+{
+    HI_S64 s64PTS;                          /**<PTS of video frame*/ /**<CNcomment: 视频帧PTS*/
+    HI_S64 s64DisplayTime;                  /**<Estimated time of display */ /**<CNcomment: 视频帧预计显示时间*/
+} HI_UNF_VIDEO_FRM_DISPLAY_TIME_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_VIDEO_ H*/
diff -uNr git/xbmc/linux/hisi/hi_unf_vo.h unlib/xbmc/linux/hisi/hi_unf_vo.h
--- git/xbmc/linux/hisi/hi_unf_vo.h	1970-01-01 08:00:00.000000000 +0800
+++ unlib/xbmc/linux/hisi/hi_unf_vo.h	2017-12-26 11:16:33.512551400 +0800
@@ -0,0 +1,823 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vo.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/16
+  Description   :
+  History       :
+  1.Date        : 2009/12/16
+    Author      : w58735
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief  supply info of vo module.
+ */
+
+#ifndef  __HI_UNF_VO_H__
+#define  __HI_UNF_VO_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+
+
+/**defines the ROTATION type.*/
+/**CNcomment:定义视频旋转角度*/
+typedef enum hiUNF_VO_ROTATION_E
+{
+    HI_UNF_VO_ROTATION_0, /**< 0 degree rotation*//**<CNcomment: 0度旋转*/
+    HI_UNF_VO_ROTATION_90, /**< 90 degree rotation*//**<CNcomment: 90度旋转*/
+    HI_UNF_VO_ROTATION_180, /**< 180 degree rotation*//**<CNcomment: 180度旋转*/
+    HI_UNF_VO_ROTATION_270, /**< 270 degree rotation*//**<CNcomment: 270度旋转*/
+    HI_UNF_VO_ROTATION_BUTT
+}HI_UNF_VO_ROTATION_E;
+
+
+/**conversion mode of AspectRatio.*/
+/**CNcomment:宽高比转换模式*/
+typedef enum hiUNF_VO_ASPECT_CVRS_E
+{
+    HI_UNF_VO_ASPECT_CVRS_IGNORE = 0x0,
+    HI_UNF_VO_ASPECT_CVRS_LETTERBOX,      /**<Add black borders*//**<CNcomment: 加黑边*/
+    HI_UNF_VO_ASPECT_CVRS_PAN_SCAN,      /**<Clip the picture*//**<CNcomment: 裁减*/
+    HI_UNF_VO_ASPECT_CVRS_COMBINED,       /**<Add black borders and clip the picture*//**<CNcomment: 加黑边和裁减混合*/
+
+    HI_UNF_VO_ASPECT_CVRS_HORIZONTAL_FULL,  /**<keep picture's HORIZONTAL be full*//**<CNcomment: 保持水平方向铺满*/
+    HI_UNF_VO_ASPECT_CVRS_VERTICAL_FULL,    /**<keep picture's VERTICAL be full*//**<CNcomment: 保持垂直方向铺满*/
+    HI_UNF_VO_ASPECT_CVRS_BUTT,
+} HI_UNF_VO_ASPECT_CVRS_E;
+
+/** AspectRatio attribute.*/
+/**CNcomment:宽高比属性*/
+typedef struct hiUNF_WINDOW_ASPECT_ATTR_S
+{
+    HI_UNF_VO_ASPECT_CVRS_E   enAspectCvrs;  /**<the method to the aspect ratio transfer.\n*//**<CNcomment: 窗口的宽高转换方式 */
+    HI_BOOL                   bUserDefAspectRatio;  /**<use or not user define aspectratio. \n
+                                                     if this is true, u32UserAspectWidth and u32UserAspectHeight will be effective.\n*/
+                                                    /**<CNcomment: 是否使用用户设定的宽高比, 为TRUE时，u32UserAspectWidth和u32UserAspectHeight生效*/
+    HI_U32                    u32UserAspectWidth; /**<aspect width of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                  /**<CNcomment: 用户期望显示的视频宽度 \n
+                                                   设置值范围在0~3840之间 \n
+                                                   0代表使用视频源分辨率*/
+    HI_U32                    u32UserAspectHeight; /**<aspect height of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                    /**<CNcomment: 用户期望显示的视频高度 \n
+                                                    设置值范围需要在0~3840的范围内 \n
+                                                    0代表使用视频源分辨率*/
+} HI_UNF_WINDOW_ASPECT_ATTR_S;
+
+/**define the attribution of window.*/
+/**CNcomment:定义WINDOW属性*/
+typedef struct hiUNF_WINDOW_ATTR_S
+{
+    HI_UNF_DISP_E             enDisp;          /**<the display channel where window locate in. can not be modified.\n*//**<CNcomment: 窗口所在的显示通道, 创建后不可修改 */
+    HI_BOOL                   bVirtual;      /**< whether is virtual window or not. can not be modified.\n*//**<CNcomment: 是否为虚拟窗口，创建后不可修改 */
+    HI_UNF_VIDEO_FORMAT_E     enVideoFormat; /**<the data format of virtual window.\n*//**<CNcomment: 虚拟窗口数据格式 */
+    HI_UNF_WINDOW_ASPECT_ATTR_S     stWinAspectAttr;  /**<the AspectRatio of window.\n*//**<CNcomment:  窗口的宽高比属性*/
+    HI_BOOL                   bUseCropRect;     /**<cut video frame as stCropRect struct or as stInputRect struct \n
+                                                    if this is TRUE, stCropRect will be effective \n
+                                                    if this is false, stInputRect will be effective.*/
+                                                   /**<CNcomment: 是否使用stCropRect对视频输入进行裁剪 \n
+                                                    为TRUE时，stCropRect设置生效 \n
+                                                    为FALSE时，stInputRect设置生效*/
+
+    HI_UNF_CROP_RECT_S        stCropRect;   /**<clip window of user define ,clip pix num of top,buttom,left,right.\n*/
+                                            /**<CNcomment: 用户定义的视频裁剪结构体类型, 上下左右裁剪的像素个数*/
+
+    HI_RECT_S                 stInputRect;       /**<the crop area .\n
+                                                  all values are zero indicate outputing whole video stream \n
+                                                  if the value is bigger than video frame, the whole video frame will be displayed \n
+                                                  width and height should not be less than 64.\n*/
+                                                 /**<CNcomment: 窗口的裁减区域  \n
+                                                  所有值为0代表显示整个视频图像 \n
+                                                  大于视频源大小的设置, 显示整个视频图像。\n
+                                                  宽度和高度不能小于64，将限制到64*64*/
+
+    HI_RECT_S                 stOutputRect;  /**<the window display area on the virtual screen. \n
+                                                The width and height of display area should not larger than virtual screen,\n
+                                                and all parameters are zero means to fill whole virtual screen.\n
+                                                The area could move out of virtual screen, and the outside part will not display.\n*/
+                                                /**<CNcomment: 窗口在虚拟屏幕上的显示区域。\n
+                                                显示区域的宽度与高度不能大于虚拟屏幕的宽度和高度，全部为0表示填满虚拟屏幕。\n
+                                                显示区域可以移出虚拟屏幕，移出屏幕部分不显示*/
+
+
+
+} HI_UNF_WINDOW_ATTR_S;
+
+
+/**define user buffer management attribute.*/
+/**CNcomment:定义用户缓冲区管理属性*/
+typedef struct hiUNF_BUFFER_ATTR_S
+{
+    HI_S32              s32Stride;          /**<the stride of the buffer.*//**<CNcomment: 缓冲区步长*/
+    HI_U32              u32PhyAddr[16];     /**<start physics addrss of the buffer.*//**<CNcomment: 缓冲区物理起始地址*/
+    HI_U32              u32BuffIndex[16];   /**<Stride of the buffer.*//**<CNcomment: 缓冲区索引编号*/
+    HI_S32              s32BuffNum;         /**<the number of the buffer.*//**<CNcomment: 缓冲区个数*/
+} HI_UNF_BUFFER_ATTR_S;
+
+/** the running mode of vo*/
+/**CNcomment:VO设备的运行模式 */
+typedef enum hiUNF_VO_DEV_MODE_E
+{
+    HI_UNF_VO_DEV_MODE_NORMAL,  /**<normal mode:
+                                  3716 V100/V200 :no more than 2 windows to be created.
+                                  3716 v300:no more than 3 windows to be created.
+                                  3712 v300:no more than 1 windows to be created.*/
+                                  /**<CNcomment: 正常模式，
+                                   3716 V100/V200:只能创建2个WINDOW
+                                   3716 v300: 只能创建3个WINDOW
+                                   3712 v300: 只能创建1个WINDOW*/
+    HI_UNF_VO_DEV_MODE_MOSAIC,  /**<mosaic mode: can create more than 2 windows.
+                                 3712 v300: not support*/
+                                /**<CNcomment: 马赛克模式，可以创建多个WINDOW
+                                 3712 v300: 不支持*/
+    HI_UNF_VO_DEV_MODE_STANDALONE,  /**<seperate mode,only 1 window can be created,and  the aspect ratio set seperately.
+                                        3716 v300: not support*/
+                                    /**<CNcomment: standalone模式，高标清显示宽高比转换单独处理模式
+                                     3716 v300 : 不支持*/
+    HI_UNF_VO_DEV_MODE_BUTT
+} HI_UNF_VO_DEV_MODE_E;
+
+/**define the freeze mode enumeration.*/
+/**CNcomment:定义Freeze模式枚举*/
+typedef enum hiUNF_WINDOW_FREEZE_MODE_E
+{
+    HI_UNF_WINDOW_FREEZE_MODE_LAST = 0,   /**<display the last frame when freeze.*//**<CNcomment: freeze时显示最后一帧*/
+    HI_UNF_WINDOW_FREEZE_MODE_BLACK = 1,  /**<display a black frame when freeze.*//**<CNcomment: freeze时显示后黑屏*/
+    HI_UNF_WINDOW_FREEZE_MODE_BUTT
+} HI_UNF_WINDOW_FREEZE_MODE_E;
+
+/**<Frosted glass effect level*/
+/**<CNcomment:定义毛玻璃效果强度 CNend*/
+typedef enum hiUNF_WINDOW_FROST_E
+{
+    HI_UNF_WINDOW_FROST_CLOSE = 0x0 ,       /**<Close  */ /**<CNcomment:关闭 CNend*/
+    HI_UNF_WINDOW_FROST_LOW         ,       /**<Low    */ /**<CNcomment:弱   CNend*/
+    HI_UNF_WINDOW_FROST_MIDDLE      ,       /**<Middle */ /**<CNcomment:中   CNend*/
+    HI_UNF_WINDOW_FROST_HIGH        ,       /**<High   */ /**<CNcomment:强   CNend*/
+
+    HI_UNF_WINDOW_FROST_BUTT
+}HI_UNF_WINDOW_FROST_E;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+/**
+\brief  init vo module.CNcomment:初始化VO模块 CNend
+\attention \n
+Before call this func, you should confirm that HI_UNF_DISP_Init and HI_UNF_DISP_Open have been called yet.
+call this func before any other vo funcs .
+CNcomment:需先初始化并打开DISPLAY后才能调用该接口。调用VO模块要求首先调用本接口 CNend
+\param[in]   enDevMode  the vo running mode.  CNcomment:VO模块的运行模式 CNend
+\retval ::HI_SUCCESS successs.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_DEV_NOT_EXIST  vo device not exist. CNcomment:VO设备不存在 CNend
+\retval ::HI_ERR_VO_NOT_DEV_FILE   not vo device. CNcomment:VO非设备 CNend
+\retval ::HI_ERR_VO_DEV_OPEN_ERR   open vo failed. CNcomment:VO打开失败 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal param. CNcomment:输入参数非法 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+/**
+\brief  deinit vo module.CNcomment:去初始化VO模块 CNend
+\attention \n
+before calling this func ,you should call HI_UNF_VO_Close to close all the windows first.
+CNcomment:在调用::HI_UNF_VO_Close接口关闭所有打开的VO后调用本接口 CNend
+\param CNcomment:无 CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_DEV_CLOSE_ERR  vo deinited failed. CNcomment:VO关闭失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DeInit(HI_VOID);
+
+/**
+\brief create the window.CNcomment:创建WINDOW CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO属性结构指针 CNend
+\param[in] phWindow   the window handler to be created.CNcomment:创建的WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment:创建失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S *pWinAttr, HI_HANDLE *phWindow);
+
+/**
+\brief create the window.CNcomment:创建采用物理坐标系的WINDOW CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO属性结构指针 CNend
+\param[in] phWindow   the window handler to be created.CNcomment:创建的WINDOW句柄 CNend
+\param[in] bVirtScreen   flag indicates whether creating with virtscreen coordinate.CNcomment:是否采用虚拟坐标系 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment:创建失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindowExt(const HI_UNF_WINDOW_ATTR_S* pWinAttr,
+                                  HI_HANDLE *phWindow,
+                                  HI_BOOL bVirtScreen);
+
+/**
+\brief  destroy the given window.CNcomment:销毁WINDOW CNend
+\attention \n
+user should disable window before call this func
+CNcomment:请先调用接口disable窗口， 再调用此接口 CNend
+\param[in] hWindow    the input window handler. CNcomment:WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow);
+
+
+/**
+\brief to enable or disable the given window.CNcomment:使能/禁止WINDOW CNend
+\attention \n
+Window can only be disabled after the corresponding avplay is stopped, else data will overflow.
+CNcomment:只有先将AVPLAY的VID通道stop后，才能禁止window，否则将引起数据的溢出 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable     the flag  of enable or disable window. CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief get the status of the given window: enable or not.CNcomment:获取WINDOW的使能状态 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pbEnable    the status of window:enable or disable.CNcomment:使能/禁止标志. CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowEnable(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+/**
+\brief set the attribution of the given window.CNcomment:设置WINDOW属性 CNend
+\attention \n
+the two members of pWinAttr:enDisp and bVirtual are fixed when window created, and they can't be modified here.
+Each value as HI_UNF_WINDOW_ATTR_S Definition
+CNcomment:enDisp和bVirtual参数一旦创建后就不能再进行修改。参数修改参照HI_UNF_WINDOW_ATTR_S的参数说明。 CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pWinAttr   the pointer of windows attr.CNcomment:WINDO属性结构指针 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowAttr(HI_HANDLE hWindow, const HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the attribution of the given window.CNcomment:获取WINDOW属性 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pWinAttr    the pointer of windows attr. CNcomment:WINDO属性结构指针 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowAttr(HI_HANDLE hWindow, HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the frame from given window.CNcomment:获取WINDOW的Frame信息 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pstFrameinfo  frame information. CNcomment:Frame信息 CNend
+\param[in] u32TimeoutMs wait time in ms.CNcomment:等待时间，毫秒为单位 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited.CNcomment: VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AcquireFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief return the frame back to the given window, used for 3d graphics testing.CNcomment:释放用户获取WINDOW的Frame，专门用于3D图形测试 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_ReleaseFrame(HI_HANDLE hWindow,HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief set the zorder of the given window.CNcomment:设置WINDOW的Z序 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enZFlag    how to adjust zorder. CNcomment:Z序调节方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowZorder(HI_HANDLE hWindow, HI_LAYER_ZORDER_E enZFlag);
+
+/**
+\brief get the zorder of the given window.CNcomment:获取WINDOW的Z序 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow       the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pu32Zorder    value of zoder, bigger value means higher prioty. CNcomment:Z序数值，数值越大优先级越高 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowZorder(HI_HANDLE hWindow, HI_U32 *pu32Zorder);
+
+/**
+\brief attach the window with video source such as vi/avplay.CNcomment:把WINDOW与指定的AVPLAY/VI绑定 CNend
+\attention \n
+it can attach the handler of avplay or vi to the window.
+CNcomment:可以将AVPLAY或VI的句柄绑定到WINDOW上。 CNend
+\param[in] hWindow     the input window handler. CNcomment:WINDOW句柄 CNend
+\param[in] hSrc        the handler of video source. CNcomment:数据源句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+
+/**
+\brief detach the window from the video source such as avplay or vi.CNcomment:把WINDOW与指定的AVPLAY/VI解绑定 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] hSrc        the handler of video source.CNcomment:数据源句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+/**
+\brief Set frost glass effect level at one window .CNcomment:在窗口中设置毛玻璃效果的等级 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow         the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enWinFrostMode  Frost glass level.CNcomment:效果强度等级 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E enWinFrostMode);
+
+/**
+\brief Get frost glass effect level at one window .CNcomment:获取窗口中设置毛玻璃效果的等级 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] *penWinFrostMode  Frost glass level.CNcomment:效果强度等级 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E* penWinFrostMode);
+
+/**
+\brief  to freeze the video content of given window.CNcomment:冻结WINDOW的显示内容 CNend
+\attention \n
+the display will be freezed after calling this func, but backgrounddly,the data flow is normal from video decoder.
+so when freezing is cacelled, the newest video content can be display at once.
+CNcomment:此功能用于在播放过程中冻结屏幕显示内容，此时WINDOW中的数据流继续运行，\n
+因此取消冻结后，会立刻显示最新的内容。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable           shows whether to freeze window.CNcomment:使能/禁止标志 CNend
+\param[in] enWinFreezeMode   the mode of freeze.CNcomment:冻结的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_FreezeWindow(HI_HANDLE hWindow, HI_BOOL bEnable, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief  to get the freeze status of the given window.CNcomment:获取窗口的冻结状态 CNend
+\attention \n
+\param[in] hWindow            the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbEnable           shows whether to freeze window.CNcomment:使能/禁止标志 CNend
+\param[out] penWinFreezeMode   the mode of freeze.CNcomment:冻结的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFreezeStatus(HI_HANDLE hWindow, HI_BOOL *pbEnable, HI_UNF_WINDOW_FREEZE_MODE_E *penWinFreezeMode);
+
+
+/**
+\brief reset the window.CNcomment:复位WINDOW CNend
+\attention \n
+this function can reset buffers of the given window, and black frame or the last frame will be displayed according configuration.
+CNcomment:此功能清空window中的缓冲，根据参数显示黑帧或最后一帧。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enWinFreezeMode   method of freeze the window.CNcomment:复位的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_ResetWindow(HI_HANDLE hWindow, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief pass the external allocated buffer to this function to test 3d graphics.CNcomment:向WINDOW传递用户外部分配的buffer，专门用于3D图形测试 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstBufAttr  external buffer.CNcomment:外部的buffer CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AttachExternBuffer(HI_HANDLE hWindow,HI_UNF_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+\brief to set the work mode of window: quick output or not. Deinterlace alg will be disabled when quick output is enabled.
+CNcomment:设置WINDOW是否工作在快速输出模式，快速输出模式强制关闭去隔行算法 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bQuickOutputEnable  whether determine the output mode of window. CNcomment:快速输出模式使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetQuickOutputEnable(HI_HANDLE hWindow, HI_BOOL bQuickOutputEnable);
+
+/**
+\brief to get the work mode of window: quick output or not.
+CNcomment:获取WINDOW是否工作在快速输出模式 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in]  hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbQuickOutputEnable  whether determine the output mode of window. CNcomment:快速输出模式使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetQuickOutputStatus(HI_HANDLE hWindow, HI_BOOL *pbQuickOutputEnable);
+
+/**
+\brief  to set the filed mode of given window.CNcomment:设置窗口的场播放模式 CNend
+\attention \n
+when fast-backward playing, there will be no abnormity through calling this func. But calling of this
+func is forbidden when normal playing. It should be called after HI_UNF_VO_AttachWindow.
+CNcomment:通过设置此接口使能，保证快退不会出现场图像回退的现象，在正常播放时，\n
+请设置为禁止，默认为禁止。HI_UNF_VO_AttachWindow调用之后使用有效。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable           wether to enable field play.CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment:操作不支持 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief  to get the filed mode of given window.CNcomment:获取窗口的场播放模式 CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbEnable         wether to enable field play.CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment:操作不支持 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+
+/**
+\brief capture the current frame of given window.CNcomment:捕获WINDOW的当前帧 CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment: 操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CapturePicture(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief if you capture picture is finished, release the memory.CNcomment:捕获完毕，释放捕获的内存区域 CNend
+\attention \n
+this function will release captured picture, so user should call this function
+after you used this captured picture.
+CNcomment:由于该函数会释放被捕获的一帧，所以用户需要在用完捕获帧之后再调用此接口 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment: 操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CapturePictureRelease(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+/**
+\brief set window rotion type.CNcomment:设置窗口的旋转类型 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] enRotation    rotion type.CNcomment:旋转类型 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E enRotation);
+
+
+/**
+\brief get window rotion type.CNcomment:获取窗口的旋转句柄 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] enRotation    rotion type.CNcomment:旋转类型 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E *penRotation);
+
+/**
+\brief flip window.CNcomment:翻转window CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] bHoriFlip    horizon flip.CNcomment:水平翻转 CNend
+\param[in] bVertFlip    vertical flip.CNcomment:垂直翻转 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetFlip(HI_HANDLE hWindow, HI_BOOL bHoriFlip, HI_BOOL bVertFlip);
+
+/**
+\brief get fliping tpye of window.CNcomment:获得窗口的翻转类型 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] bHoriFlip    horizon flip flag.CNcomment:水平翻转标志 CNend
+\param[in] bVertFlip    vertical flip flag.CNcomment:垂直翻转标志 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetFlip(HI_HANDLE hWindow, HI_BOOL *pbHoriFlip, HI_BOOL *pbVertFlip);
+
+/**
+\brief set video stereo depth for 3D output.CNcomment:设置3D输出视频景深 CNend
+\attention \n
+3716/3712: not support.Only take effect in 3D output mode.
+CNcomment: 3716/3712不支持 .仅在3D输出时有效 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] s32Depth Depth of filed. the range is [-50,50].CNcomment:景深，取值为[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_SetStereoDetpth(HI_HANDLE hWindow, HI_S32 s32Depth);
+
+/**
+\brief get video stereo depth for 3D output.CNcomment: 获取3D输出视频景深 CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[out] ps32Depth Depth of filed. the range is [-50,50].CNcomment:景深，取值为[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_GetStereoDetpth(HI_HANDLE hWindow, HI_S32 *ps32Depth);
+
+/**
+\brief Queue frame into the specified window.CNcomment: 向特定窗口中推帧，用于显示。 CNend
+\attention \n
+\param[in] hWindow    window handle. CNcomment:窗口句柄 CNend
+\param[in] pstFrameinfo  frame infor to be passed into. CNcomment:要传入的帧信息. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment:空指针 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\retval ::HI_ERR_VO_BUFQUE_FULL   buffer is full .CNcomment:buffer 处于满的状态 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   invalid opt.CNcomment:无效操作 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_QueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief dequeue frame from window.CNcomment: 回收推到窗口的帧CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[out] pstFrameinfo  frame infor dequeued from window .CNcomment:从窗口中获取的帧信息. CNend
+\param[in] u32TimeoutMs  timeout when get frame failed .CNcomment:超时值，用于获取帧失败时的超时退出. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment:空指针 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_DeQueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief set  window alpha.CNcomment: 设置窗口的alpha值CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] u32Alpha  window alpha .CNcomment:窗口的alpha值. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_SetWindowAlpha(HI_HANDLE hWindow, HI_U32 u32Alpha);
+/**
+\brief get  window alpha.CNcomment: 获取窗口的alpha值CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] pu32Alpha  window alpha .CNcomment:窗口的alpha值. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_GetWindowAlpha(HI_HANDLE hWindow, HI_U32 *pu32Alpha);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+/************************************** The End Of File **************************************/
diff -uNr git/xbmc/utils/posix/PosixInterfaceForCLog.cpp unlib/xbmc/utils/posix/PosixInterfaceForCLog.cpp
--- git/xbmc/utils/posix/PosixInterfaceForCLog.cpp	2018-03-30 11:39:25.371652212 +0800
+++ unlib/xbmc/utils/posix/PosixInterfaceForCLog.cpp	2018-04-11 10:18:57.937901226 +0800
@@ -91,6 +91,8 @@
 #elif defined(TARGET_ANDROID)
   //print to adb
   CXBMCApp::android_printf("Debug Print: %s", debugString.c_str());
+#else
+  printf("%s\n", debugString.c_str());
 #endif // TARGET_ANDROID
 #endif // _DEBUG
 }

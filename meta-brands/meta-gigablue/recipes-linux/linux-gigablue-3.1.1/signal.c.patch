--- a/kernel/signal.c	2012-08-12 16:47:40.000000000 +0200
+++ b/kernel/signal.c	2012-08-12 17:02:02.000000000 +0200
@@ -2413,26 +2413,22 @@
 }
 
 SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,
-		siginfo_t __user *, uinfo)
-{
-	siginfo_t info;
-
-	if (copy_from_user(&info, uinfo, sizeof(siginfo_t)))
-		return -EFAULT;
-
-	/* Not even root can pretend to send signals from the kernel.
-	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
-	 */
-	if (info.si_code != SI_QUEUE) {
-		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info.si_code < 0);
-		return -EPERM;
-	}
-	info.si_signo = sig;
-
-	/* POSIX.1b doesn't mention process groups.  */
-	return kill_proc_info(sig, &info, pid);
-}
+                 siginfo_t __user *, uinfo)
+ {
+         siginfo_t info;
+ 
+         if (copy_from_user(&info, uinfo, sizeof(siginfo_t)))
+                 return -EFAULT;
+ 
+         /* Not even root can pretend to send signals from the kernel.
+            Nor can they impersonate a kill(), which adds source info.  */
+         if (info.si_code >= 0)
+                 return -EPERM;
+         info.si_signo = sig;
+ 
+         /* POSIX.1b doesn't mention process groups.  */
+         return kill_proc_info(sig, &info, pid);
+ }
 
 long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 {
@@ -2447,7 +2443,7 @@
 		/* We used to allow any < 0 si_code */
 		WARN_ON_ONCE(info->si_code < 0);
 		return -EPERM;
-	}
+}
 	info->si_signo = sig;
 
 	return do_send_specific(tgid, pid, sig, info);

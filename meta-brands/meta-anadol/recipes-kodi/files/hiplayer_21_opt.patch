From 80e32d181352ead292be59934f1c89fda3c18349 Mon Sep 17 00:00:00 2001
From: Captain <openatv@gmail.com>
Date: Sat, 18 May 2024 07:22:58 +0200
Subject: [PATCH] hiplayer_21_opt

---
 .../resources/strings.po                      |   11 +
 cmake/platform/linux/stb.cmake                |    4 +-
 cmake/treedata/common/cores.txt               |    1 +
 cmake/treedata/linux/subdirs.txt              |    1 +
 system/settings/settings.xml                  |    6 +
 xbmc/application/Application.cpp              |    7 +
 .../application/ApplicationVolumeHandling.cpp |   14 +-
 xbmc/commons/ilog.h                           |    1 +
 xbmc/cores/VideoPlayer/VideoPlayer.cpp        |  125 +-
 xbmc/cores/VideoPlayer/VideoPlayer.h          |    7 +
 .../VideoRenderers/HwDecRender/CMakeLists.txt |    3 +
 .../HwDecRender/RendererHisi.cpp              |  164 ++
 .../VideoRenderers/HwDecRender/RendererHisi.h |   56 +
 xbmc/cores/hiplayer/CMakeLists.txt            |   17 +
 xbmc/cores/hiplayer/HiAdec.cpp                |  114 +
 xbmc/cores/hiplayer/HiAdec.h                  |   59 +
 xbmc/cores/hiplayer/HiCodecAudio.cpp          |  419 +++
 xbmc/cores/hiplayer/HiCodecAudio.h            |   93 +
 xbmc/cores/hiplayer/HiCodecVideo.cpp          |  577 ++++
 xbmc/cores/hiplayer/HiCodecVideo.h            |   97 +
 xbmc/cores/hiplayer/HiDecoder.cpp             | 1461 ++++++++++
 xbmc/cores/hiplayer/HiDecoder.h               |  164 ++
 xbmc/cores/hiplayer/HiPlayerAudio.cpp         |  817 ++++++
 xbmc/cores/hiplayer/HiPlayerAudio.h           |  139 +
 xbmc/cores/hiplayer/HiPlayerVideo.cpp         |  999 +++++++
 xbmc/cores/hiplayer/HiPlayerVideo.h           |  159 +
 xbmc/cores/hiplayer/HiVdec.cpp                |  590 ++++
 xbmc/cores/hiplayer/HiVdec.h                  |  112 +
 xbmc/platform/linux/hisi/CMakeLists.txt       |    9 +
 .../platform/linux/hisi/HA.AUDIO.AAC.decode.h |  100 +
 .../platform/linux/hisi/HA.AUDIO.AAC.encode.h |   87 +
 .../hisi/HA.AUDIO.AC3PASSTHROUGH.decode.h     |   49 +
 .../linux/hisi/HA.AUDIO.AMRNB.codec.h         |  113 +
 .../linux/hisi/HA.AUDIO.AMRWB.codec.h         |  112 +
 .../linux/hisi/HA.AUDIO.BLURAYLPCM.decode.h   |   62 +
 .../linux/hisi/HA.AUDIO.COOK.decode.h         |   69 +
 .../linux/hisi/HA.AUDIO.DOLBYMS12.decode.h    |  332 +++
 .../linux/hisi/HA.AUDIO.DOLBYMS12EXT.decode.h |  318 ++
 .../linux/hisi/HA.AUDIO.DOLBYPLUS.decode.h    |  278 ++
 .../linux/hisi/HA.AUDIO.DOLBYTRUEHD.decode.h  |   87 +
 .../platform/linux/hisi/HA.AUDIO.DRA.decode.h |   93 +
 .../linux/hisi/HA.AUDIO.DTSHD.decode.h        |   73 +
 .../linux/hisi/HA.AUDIO.DTSM6.decode.h        |  113 +
 .../hisi/HA.AUDIO.DTSPASSTHROUGH.decode.h     |   49 +
 .../hisi/HA.AUDIO.FFMPEG_DECODE.decode.h      |  114 +
 .../linux/hisi/HA.AUDIO.FFMPEG_DTS.decode.h   |  139 +
 .../linux/hisi/HA.AUDIO.FFMPEG_EAC3.decode.h  |  200 ++
 .../linux/hisi/HA.AUDIO.FFMPEG_LPCM.decode.h  |   94 +
 .../hisi/HA.AUDIO.FFMPEG_TRUEHD.decode.h      |   93 +
 .../linux/hisi/HA.AUDIO.FFMPEG_WMA.decode.h   |  126 +
 .../hisi/HA.AUDIO.FFMPEG_WMAPRO.decode.h      |   70 +
 .../hisi/HA.AUDIO.FFMPEG_WMA_PRO.decode.h     |  126 +
 .../platform/linux/hisi/HA.AUDIO.G711.codec.h |   70 +
 .../platform/linux/hisi/HA.AUDIO.G722.codec.h |   67 +
 .../platform/linux/hisi/HA.AUDIO.MP2.decode.h |   65 +
 .../platform/linux/hisi/HA.AUDIO.MP3.decode.h |   71 +
 .../platform/linux/hisi/HA.AUDIO.OPUS.codec.h |   63 +
 .../platform/linux/hisi/HA.AUDIO.PCM.decode.h |   67 +
 .../hisi/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h  |   49 +
 .../linux/hisi/HA.AUDIO.VOICE.codec.h         |  116 +
 .../linux/hisi/HA.AUDIO.VORBIS.codec.h        |   46 +
 .../linux/hisi/HA.AUDIO.WMA9STD.decode.h      |  146 +
 .../linux/hisi/HA.AUDIO.codec.common.h        |   28 +
 xbmc/platform/linux/hisi/hi_adp.h             |  131 +
 xbmc/platform/linux/hisi/hi_adp_boardcfg.h    |  117 +
 xbmc/platform/linux/hisi/hi_adp_data.h        |  138 +
 xbmc/platform/linux/hisi/hi_adp_hdmi.c        |  572 ++++
 xbmc/platform/linux/hisi/hi_adp_hdmi.h        |   16 +
 xbmc/platform/linux/hisi/hi_adp_ini.c         |  219 ++
 xbmc/platform/linux/hisi/hi_adp_ini.h         |   35 +
 xbmc/platform/linux/hisi/hi_adp_mpi.c         | 1704 +++++++++++
 xbmc/platform/linux/hisi/hi_adp_mpi.h         |   95 +
 xbmc/platform/linux/hisi/hi_adp_search.h      |  382 +++
 xbmc/platform/linux/hisi/hi_audio_codec.h     |  863 ++++++
 xbmc/platform/linux/hisi/hi_common.h          |   39 +
 xbmc/platform/linux/hisi/hi_debug.h           |  239 ++
 xbmc/platform/linux/hisi/hi_error_mpi.h       |  936 ++++++
 xbmc/platform/linux/hisi/hi_go.h              |   36 +
 xbmc/platform/linux/hisi/hi_go_bliter.h       |  636 ++++
 xbmc/platform/linux/hisi/hi_go_comm.h         |  242 ++
 xbmc/platform/linux/hisi/hi_go_cursor.h       |  217 ++
 xbmc/platform/linux/hisi/hi_go_decoder.h      |  439 +++
 xbmc/platform/linux/hisi/hi_go_encoder.h      |  164 ++
 xbmc/platform/linux/hisi/hi_go_errno.h        |  554 ++++
 xbmc/platform/linux/hisi/hi_go_gdev.h         | 1022 +++++++
 xbmc/platform/linux/hisi/hi_go_surface.h      |  808 ++++++
 xbmc/platform/linux/hisi/hi_go_text.h         |  480 ++++
 xbmc/platform/linux/hisi/hi_memory.h          |  200 ++
 xbmc/platform/linux/hisi/hi_module.h          |  204 ++
 xbmc/platform/linux/hisi/hi_system.h          |  435 +++
 xbmc/platform/linux/hisi/hi_type.h            |  152 +
 xbmc/platform/linux/hisi/hi_unf_advca.h       | 1923 +++++++++++++
 xbmc/platform/linux/hisi/hi_unf_aenc.h        |  271 ++
 xbmc/platform/linux/hisi/hi_unf_ai.h          |  340 +++
 xbmc/platform/linux/hisi/hi_unf_audio.h       |  238 ++
 xbmc/platform/linux/hisi/hi_unf_avplay.h      | 1639 +++++++++++
 xbmc/platform/linux/hisi/hi_unf_cc.h          |  739 +++++
 xbmc/platform/linux/hisi/hi_unf_ci.h          |  691 +++++
 xbmc/platform/linux/hisi/hi_unf_cipher.h      | 1319 +++++++++
 xbmc/platform/linux/hisi/hi_unf_common.h      |   90 +
 xbmc/platform/linux/hisi/hi_unf_demux.h       | 2238 +++++++++++++++
 xbmc/platform/linux/hisi/hi_unf_descrambler.h |  360 +++
 xbmc/platform/linux/hisi/hi_unf_disp.h        | 1588 ++++++++++
 xbmc/platform/linux/hisi/hi_unf_ecs.h         |   28 +
 xbmc/platform/linux/hisi/hi_unf_edid.h        |  500 ++++
 xbmc/platform/linux/hisi/hi_unf_frontend.h    | 2547 +++++++++++++++++
 xbmc/platform/linux/hisi/hi_unf_gpio.h        |  269 ++
 xbmc/platform/linux/hisi/hi_unf_hdcp.h        |   77 +
 xbmc/platform/linux/hisi/hi_unf_hdmi.h        | 1326 +++++++++
 xbmc/platform/linux/hisi/hi_unf_i2c.h         |  248 ++
 xbmc/platform/linux/hisi/hi_unf_ir.h          |  408 +++
 xbmc/platform/linux/hisi/hi_unf_keyled.h      |  476 +++
 xbmc/platform/linux/hisi/hi_unf_klad.h        |  270 ++
 .../linux/hisi/hi_unf_klad_common_ca.h        |   82 +
 xbmc/platform/linux/hisi/hi_unf_klad_dcas.h   |   81 +
 xbmc/platform/linux/hisi/hi_unf_mailbox.h     |  151 +
 xbmc/platform/linux/hisi/hi_unf_mce.h         |  253 ++
 xbmc/platform/linux/hisi/hi_unf_otp.h         | 1121 ++++++++
 .../linux/hisi/hi_unf_otp_common_ca.h         |  267 ++
 .../linux/hisi/hi_unf_otp_customize.h         |   45 +
 xbmc/platform/linux/hisi/hi_unf_otp_dcas.h    |   61 +
 .../linux/hisi/hi_unf_payloadcipher.h         |  239 ++
 xbmc/platform/linux/hisi/hi_unf_pdm.h         |  443 +++
 xbmc/platform/linux/hisi/hi_unf_pmoc.h        |  479 ++++
 xbmc/platform/linux/hisi/hi_unf_pq.h          |  636 ++++
 xbmc/platform/linux/hisi/hi_unf_pvr.h         | 1530 ++++++++++
 xbmc/platform/linux/hisi/hi_unf_pwm.h         |  162 ++
 xbmc/platform/linux/hisi/hi_unf_sci.h         |  652 +++++
 .../linux/hisi/hi_unf_session_manager.h       |  189 ++
 xbmc/platform/linux/hisi/hi_unf_so.h          |  449 +++
 xbmc/platform/linux/hisi/hi_unf_sound.h       | 1931 +++++++++++++
 xbmc/platform/linux/hisi/hi_unf_spi.h         |  277 ++
 xbmc/platform/linux/hisi/hi_unf_subt.h        |  221 ++
 xbmc/platform/linux/hisi/hi_unf_ttx.h         |  550 ++++
 xbmc/platform/linux/hisi/hi_unf_venc.h        |  570 ++++
 xbmc/platform/linux/hisi/hi_unf_version.h     |   52 +
 xbmc/platform/linux/hisi/hi_unf_vi.h          |  351 +++
 xbmc/platform/linux/hisi/hi_unf_video.h       |  662 +++++
 xbmc/platform/linux/hisi/hi_unf_vo.h          |  857 ++++++
 xbmc/platform/linux/hisi/hi_unf_vp.h          |  531 ++++
 xbmc/platform/linux/hisi/hi_unf_wdg.h         |  189 ++
 xbmc/platform/linux/hisi/hi_user_proc.h       |  117 +
 xbmc/platform/linux/hisi/hi_video_codec.h     |  827 ++++++
 xbmc/platform/posix/PlatformDefs.h            |    4 +
 xbmc/settings/SettingConditions.cpp           |    3 +
 xbmc/settings/Settings.h                      |    1 +
 xbmc/windowing/egl/WinSystemSTBContext.cpp    |    3 +
 147 files changed, 52551 insertions(+), 6 deletions(-)
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.cpp
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.h
 create mode 100644 xbmc/cores/hiplayer/CMakeLists.txt
 create mode 100644 xbmc/cores/hiplayer/HiAdec.cpp
 create mode 100644 xbmc/cores/hiplayer/HiAdec.h
 create mode 100644 xbmc/cores/hiplayer/HiCodecAudio.cpp
 create mode 100644 xbmc/cores/hiplayer/HiCodecAudio.h
 create mode 100644 xbmc/cores/hiplayer/HiCodecVideo.cpp
 create mode 100644 xbmc/cores/hiplayer/HiCodecVideo.h
 create mode 100644 xbmc/cores/hiplayer/HiDecoder.cpp
 create mode 100644 xbmc/cores/hiplayer/HiDecoder.h
 create mode 100644 xbmc/cores/hiplayer/HiPlayerAudio.cpp
 create mode 100644 xbmc/cores/hiplayer/HiPlayerAudio.h
 create mode 100644 xbmc/cores/hiplayer/HiPlayerVideo.cpp
 create mode 100644 xbmc/cores/hiplayer/HiPlayerVideo.h
 create mode 100644 xbmc/cores/hiplayer/HiVdec.cpp
 create mode 100644 xbmc/cores/hiplayer/HiVdec.h
 create mode 100644 xbmc/platform/linux/hisi/CMakeLists.txt
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.AAC.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.AAC.encode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.AC3PASSTHROUGH.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.AMRNB.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.AMRWB.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.BLURAYLPCM.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.COOK.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12EXT.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DOLBYPLUS.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DOLBYTRUEHD.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DRA.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DTSHD.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DTSM6.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.DTSPASSTHROUGH.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DECODE.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DTS.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_EAC3.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_LPCM.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_TRUEHD.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMAPRO.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA_PRO.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.G711.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.G722.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.MP2.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.MP3.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.OPUS.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.PCM.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.VOICE.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.VORBIS.codec.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.WMA9STD.decode.h
 create mode 100644 xbmc/platform/linux/hisi/HA.AUDIO.codec.common.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_boardcfg.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_data.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_hdmi.c
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_hdmi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_ini.c
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_ini.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_mpi.c
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_mpi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_adp_search.h
 create mode 100644 xbmc/platform/linux/hisi/hi_audio_codec.h
 create mode 100644 xbmc/platform/linux/hisi/hi_common.h
 create mode 100644 xbmc/platform/linux/hisi/hi_debug.h
 create mode 100644 xbmc/platform/linux/hisi/hi_error_mpi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_bliter.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_comm.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_cursor.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_decoder.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_encoder.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_errno.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_gdev.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_surface.h
 create mode 100644 xbmc/platform/linux/hisi/hi_go_text.h
 create mode 100644 xbmc/platform/linux/hisi/hi_memory.h
 create mode 100644 xbmc/platform/linux/hisi/hi_module.h
 create mode 100644 xbmc/platform/linux/hisi/hi_system.h
 create mode 100644 xbmc/platform/linux/hisi/hi_type.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_advca.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_aenc.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_ai.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_audio.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_avplay.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_cc.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_ci.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_cipher.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_common.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_demux.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_descrambler.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_disp.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_ecs.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_edid.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_frontend.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_gpio.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_hdcp.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_hdmi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_i2c.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_ir.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_keyled.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_klad.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_klad_common_ca.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_klad_dcas.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_mailbox.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_mce.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_otp.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_otp_common_ca.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_otp_customize.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_otp_dcas.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_payloadcipher.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_pdm.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_pmoc.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_pq.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_pvr.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_pwm.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_sci.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_session_manager.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_so.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_sound.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_spi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_subt.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_ttx.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_venc.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_version.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_vi.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_video.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_vo.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_vp.h
 create mode 100644 xbmc/platform/linux/hisi/hi_unf_wdg.h
 create mode 100644 xbmc/platform/linux/hisi/hi_user_proc.h
 create mode 100644 xbmc/platform/linux/hisi/hi_video_codec.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 9fb3dcb2b0..c8c3e40a69 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -7469,6 +7469,17 @@ msgstr ""
 
 #empty strings from id 13458 to 13459
 
+#: system/settings/settings.xml
+msgctxt "#13458"
+msgid "Allow hardware acceleration - HiPlayer"
+msgstr ""
+
+#. Description of setting with label #13457 "Allow hardware acceleration (HiPlayer)"
+#: system/settings/settings.xml
+msgctxt "#13459"
+msgid "Use HiPlayer for decoding of video files."
+msgstr ""
+
 #: system/settings/settings.xml
 msgctxt "#13460"
 msgid "Use HEVC VAAPI"
diff --git a/cmake/platform/linux/stb.cmake b/cmake/platform/linux/stb.cmake
index 7d7e14205f..f6452f9643 100644
--- a/cmake/platform/linux/stb.cmake
+++ b/cmake/platform/linux/stb.cmake
@@ -59,9 +59,7 @@ elseif(WITH_PLATFORM STREQUAL "edision-cortexa15")
   list(APPEND DEPLIBS EGL GLESv2 v3dplatform)
 elseif(WITH_PLATFORM STREQUAL "clap-cortexa15")
   list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI -DUSE_HIPLAYER")
-#  list(APPEND DEPLIBS ${CMAKE_SOURCE_DIR}xbmc/cores/hiplayer/hiplayer.a ${CMAKE_SOURCE_DIR}xbmc/linux/hisi/hiadp.a)
-#  list(APPEND DEPLIBS EGL GLESv2 jpeg hi_common hi_msp)
-  list(APPEND DEPLIBS EGL GLESv2 jpeg)
+  list(APPEND DEPLIBS EGL GLESv2 jpeg hi_common hi_msp)
 endif()
 
 
diff --git a/cmake/treedata/common/cores.txt b/cmake/treedata/common/cores.txt
index cbde630e7d..b111eac095 100644
--- a/cmake/treedata/common/cores.txt
+++ b/cmake/treedata/common/cores.txt
@@ -8,3 +8,4 @@ xbmc/cores/Enigma2Player               cores/enigma2player
 xbmc/cores/GstPlayer                   cores/gstplayer
 xbmc/cores/paplayer                    cores/paplayer
 xbmc/cores/playercorefactory           cores/playercorefactory
+xbmc/cores/hiplayer                    cores/hiplayer
diff --git a/cmake/treedata/linux/subdirs.txt b/cmake/treedata/linux/subdirs.txt
index a8e8194038..391bc65e97 100644
--- a/cmake/treedata/linux/subdirs.txt
+++ b/cmake/treedata/linux/subdirs.txt
@@ -2,6 +2,7 @@ xbmc/input/touch                    input/touch
 xbmc/input/touch/generic            input/touch/generic
 xbmc/platform/common/speech         platform/common/speech
 xbmc/platform/linux                 platform/linux
+xbmc/platform/linux/hisi            platform/linux/hisi
 xbmc/platform/linux/input           platform/linux/input
 xbmc/platform/linux/network         platform/linux/network
 xbmc/platform/linux/peripherals     platform/linux/peripherals
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 1acec8255d..db66ba0ea6 100755
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -60,6 +60,12 @@
           </constraints>
           <control type="list" format="string" />
         </setting>
+	<setting id="videoplayer.usehiplayer" type="boolean" label="13458" help="13459">
+          <requirement>USE_HIPLAYER</requirement>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="winsystem.ishdrdisplay" type="boolean" label="13436" help="36299">
           <dependencies>
             <dependency type="visible">
diff --git a/xbmc/application/Application.cpp b/xbmc/application/Application.cpp
index e1db281f08..0dd3a62431 100644
--- a/xbmc/application/Application.cpp
+++ b/xbmc/application/Application.cpp
@@ -174,6 +174,7 @@
 #endif
 
 #include <cmath>
+#include <fstream>
 #include <memory>
 #include <mutex>
 
@@ -373,6 +374,9 @@ bool CApplication::Create()
   // Init our DllLoaders emu env
   init_emu_environ();
 
+  std::string cmd("echo \"0\" > /proc/stb/vmpeg/0/enable");
+  system(cmd.c_str());
+  CLog::Log(LOGNOTICE,  "Hisi Clear Video backgroud: {}",cmd.c_str());
   PrintStartupLog();
 
   // initialize network protocols
@@ -2080,6 +2084,9 @@ bool CApplication::Stop(int exitCode)
   const auto appPlayer = GetComponent<CApplicationPlayer>();
   appPlayer->ClosePlayer();
 
+  std::string cmd("echo \"1\" > /proc/stb/vmpeg/0/enable");
+  system(cmd.c_str());
+  CLog::Log(LOGNOTICE,  "Hisi Clear Video backgroud: {}",cmd.c_str());
   {
     // close inbound port
     CServiceBroker::UnregisterAppPort();
diff --git a/xbmc/application/ApplicationVolumeHandling.cpp b/xbmc/application/ApplicationVolumeHandling.cpp
index 25229be7da..e84970a715 100644
--- a/xbmc/application/ApplicationVolumeHandling.cpp
+++ b/xbmc/application/ApplicationVolumeHandling.cpp
@@ -23,7 +23,7 @@
 #include "utils/XMLUtils.h"
 
 #include <tinyxml.h>
-
+#include <fstream>
 float CApplicationVolumeHandling::GetVolumePercent() const
 {
   // converts the hardware volume to a percentage
@@ -42,6 +42,18 @@ void CApplicationVolumeHandling::SetHardwareVolume(float hardwareVolume)
   IAE* ae = CServiceBroker::GetActiveAE();
   if (ae)
     ae->SetVolume(m_volumeLevel);
+	
+#ifdef USE_HIPLAYER
+  #include <fstream>
+  int vol = m_muted?0:(int)(m_volumeLevel*100);
+  std::ostringstream sstreamer;
+  sstreamer << "echo ";
+  sstreamer << vol;
+  sstreamer << " > /proc/stb/avs/0/volume";
+  std::string cmd(sstreamer.str());
+  system(cmd.c_str());
+  
+#endif
 }
 
 void CApplicationVolumeHandling::VolumeChanged()
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 9fe074af41..2c522196a9 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -21,6 +21,7 @@ constexpr int LOGWARNING = 2;
 constexpr int LOGERROR = 3;
 constexpr int LOGFATAL = 4;
 constexpr int LOGNONE = 5;
+constexpr int LOGNOTICE = LOGINFO;
 
 // extra masks - from bit 5
 constexpr int LOGMASKBIT = 5;
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index f3d3db772c..67b687a5a0 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -61,6 +61,10 @@
 #include "utils/log.h"
 #include "video/Bookmark.h"
 #include "video/VideoInfoTag.h"
+#ifdef USE_HIPLAYER
+#include "cores/hiplayer/HiPlayerVideo.h"
+#include "cores/hiplayer/HiPlayerAudio.h"
+#endif
 #include "windowing/WinSystem.h"
 
 #include <iterator>
@@ -576,11 +580,28 @@ int CSelectionStreams::CountType(StreamType type) const
 
 void CVideoPlayer::CreatePlayers()
 {
+#ifdef USE_HIPLAYER
+  if (m_hiplayer_mode && m_player_recreate)
+  {
+    DestroyPlayers();
+    m_player_recreate = false;
+  }
+#endif
+
   if (m_players_created)
     return;
 
-  m_VideoPlayerVideo = new CVideoPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
-  m_VideoPlayerAudio = new CVideoPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+#ifdef USE_HIPLAYER
+  if(m_hiplayer_mode && m_use_hicodec)
+  {
+	  m_VideoPlayerVideo = new CHiPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
+	  m_VideoPlayerAudio = new CHiPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+  }else
+#endif
+  {
+  	m_VideoPlayerVideo = new CVideoPlayerVideo(&m_clock, &m_overlayContainer, m_messenger, m_renderManager, *m_processInfo);
+  	m_VideoPlayerAudio = new CVideoPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+  }
   m_VideoPlayerSubtitle = new CVideoPlayerSubtitle(&m_overlayContainer, *m_processInfo);
   m_VideoPlayerTeletext = new CDVDTeletextData(*m_processInfo);
   m_VideoPlayerRadioRDS = new CDVDRadioRDSData(*m_processInfo);
@@ -634,6 +655,14 @@ CVideoPlayer::CVideoPlayer(IPlayerCallback& callback)
   m_HasAudio = false;
   m_UpdateStreamDetails = false;
 
+#ifdef USE_HIPLAYER
+  m_hiplayer_mode		= CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEHIPLAYER);
+  m_use_hicodec			= m_hiplayer_mode;
+  m_player_recreate	= false;
+#else
+  m_hiplayer_mode		= false;
+#endif
+
   m_SkipCommercials = true;
 
   m_processInfo.reset(CProcessInfo::CreateInstance());
@@ -668,6 +697,83 @@ bool CVideoPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options
 {
   CLog::Log(LOGINFO, "VideoPlayer::OpenFile: {}", CURL::GetRedacted(file.GetPath()));
 
+#ifdef USE_HIPLAYER
+  bool need_recreate_now = false;
+  if (m_hiplayer_mode)
+  {
+    CLog::Log(LOGNOTICE, "VideoPlayer hicodec checking decoder switch");
+    if (m_use_hicodec && !(file.IsType(".dts") || file.IsType(".mp3") || file.IsType(".wav") ||
+                           file.IsType(".wave") || file.IsType(".oga") || file.IsType(".ogg") ||
+                           file.IsType(".flac") || file.IsType(".m4a") || file.IsType(".mp2") ||
+                           file.IsType(".m2a") || file.IsType(".ac3") || file.IsType(".mka") ||
+                           file.IsType(".aac") || file.IsType(".ape") || file.IsType(".alac") ||
+                           file.IsType(".mpg") || file.IsType(".vob") || file.IsType(".m4v") ||
+                           file.IsType(".mkv") || file.IsType(".avi") || file.IsType(".divx") ||
+                           file.IsType(".dat") || file.IsType(".flv") || file.IsType(".mp4") ||
+                           file.IsType(".mov") || file.IsType(".wmv") || file.IsType(".rm") ||
+                           file.IsType(".rmvb") || file.IsType(".ogm") || file.IsType(".ogv") ||
+                           file.IsType(".stream") || file.IsType(".amr") || file.IsType(".au") ||
+                           file.IsType(".mid") || file.IsType(".wv") || file.IsType(".pva") ||
+                           file.IsType(".wtv") || file.IsType(".ts") || file.IsType(".m2ts")))
+    {
+      CLog::Log(LOGNOTICE, "find drm use, switch to default player");
+
+      m_use_hicodec = false;
+
+      if (!IsRunning())
+      {
+        need_recreate_now = true;
+      }
+      else
+      {
+        m_player_recreate = true;
+      }
+    }
+    else if (!m_use_hicodec &&
+             (file.IsType(".dts") || file.IsType(".mp3") || file.IsType(".wav") ||
+              file.IsType(".wave") || file.IsType(".oga") || file.IsType(".ogg") ||
+              file.IsType(".flac") || file.IsType(".m4a") || file.IsType(".mp2") ||
+              file.IsType(".m2a") || file.IsType(".ac3") || file.IsType(".mka") ||
+              file.IsType(".aac") || file.IsType(".ape") || file.IsType(".alac") ||
+              file.IsType(".mpg") || file.IsType(".vob") || file.IsType(".m4v") ||
+              file.IsType(".mkv") || file.IsType(".avi") || file.IsType(".divx") ||
+              file.IsType(".dat") || file.IsType(".flv") || file.IsType(".mp4") ||
+              file.IsType(".mov") || file.IsType(".wmv") || file.IsType(".rm") ||
+              file.IsType(".rmvb") || file.IsType(".ogm") || file.IsType(".ogv") ||
+              file.IsType(".stream") || file.IsType(".amr") || file.IsType(".au") ||
+              file.IsType(".mid") || file.IsType(".wv") || file.IsType(".pva") ||
+              file.IsType(".wtv") || file.IsType(".ts") || file.IsType(".m2ts")))
+    {
+      CLog::Log(LOGNOTICE, "find no drm use, switch to hicodec");
+
+      m_use_hicodec = true;
+
+      if (!IsRunning())
+      {
+        need_recreate_now = true;
+      }
+      else
+      {
+        m_player_recreate = true;
+      }
+    }
+
+    if (need_recreate_now)
+    {
+      if (m_VideoPlayerVideo)
+        delete m_VideoPlayerVideo;
+      if (m_VideoPlayerAudio)
+        delete m_VideoPlayerAudio;
+
+      m_renderManager.UnInit();
+      m_renderManager.PreInit();
+
+      m_VideoPlayerVideo = new CHiPlayerVideo(&m_clock, &m_overlayContainer, m_messenger,
+                                              m_renderManager, *m_processInfo);
+      m_VideoPlayerAudio = new CHiPlayerAudio(&m_clock, m_messenger, *m_processInfo);
+    }
+  }
+#endif
   if (IsRunning())
   {
     CDVDMsgOpenFile::FileParams params;
@@ -1533,6 +1639,12 @@ void CVideoPlayer::Process()
       {
         m_VideoPlayerVideo->SendMessage(std::make_shared<CDVDMsg>(CDVDMsg::VIDEO_DRAIN));
       }
+#ifdef USE_HIPLAYER
+      if (m_CurrentAudio.inited)
+      {
+        m_VideoPlayerAudio->SendMessage(std::make_shared<CDVDMsg>(CDVDMsg::GENERAL_EOF));
+      }
+#endif
 
       m_CurrentAudio.inited = false;
       m_CurrentVideo.inited = false;
@@ -2633,6 +2745,15 @@ void CVideoPlayer::HandleMessages()
 
       FlushBuffers(DVD_NOPTS_VALUE, true, true);
       m_renderManager.Flush(false, false);
+
+#ifdef USE_HIPLAYER
+      if(m_hiplayer_mode && m_player_recreate)
+      {
+          m_renderManager.UnInit();
+          m_renderManager.PreInit();
+      }
+#endif
+
       m_pDemuxer.reset();
       m_pSubtitleDemuxer.reset();
       m_subtitleDemuxerMap.clear();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.h b/xbmc/cores/VideoPlayer/VideoPlayer.h
index 01cbca0119..8960c382b2 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.h
@@ -589,4 +589,11 @@ protected:
   bool m_UpdateStreamDetails;
 
   std::atomic<bool> m_displayLost;
+  bool m_hiplayer_mode;				// using hiplayer acceleration
+#ifdef USE_HIPLAYER
+  bool m_use_hicodec;
+  bool m_player_recreate;
+  friend class CHiPlayerVideo;
+  friend class CHiPlayerAudio;
+#endif
 };
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
index 8598052b41..963e0001e8 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
@@ -69,6 +69,9 @@ if("webos" IN_LIST CORE_PLATFORM_NAME_LC)
   list(APPEND HEADERS RendererStarfish.h)
 endif()
 
+list(APPEND SOURCES RendererHisi.cpp)
+list(APPEND HEADERS RendererHisi.h)
+
 # we might want to build on linux systems
 # with ENABLE_VDPAU=OFF and ENABLE_VAAPI=OFF
 if(SOURCES)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.cpp
new file mode 100644
index 0000000000..c7117c66c6
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.cpp
@@ -0,0 +1,164 @@
+/*
+ *  Copyright (C) 2007-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RendererHisi.h"
+
+#include "utils/log.h"
+//#include "utils/SysfsUtils.h"
+#include "settings/MediaSettings.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "settings/AdvancedSettings.h"
+
+class CVideoBufferHisi;
+
+CRendererHisi::CRendererHisi()
+ : m_prevVPts(-1)
+ , m_bConfigured(false)
+{
+  CLog::Log(LOGNOTICE, "Constructing CRendererHisi");
+}
+
+CRendererHisi::~CRendererHisi()
+{
+  Reset();
+}
+
+CBaseRenderer* CRendererHisi::Create(CVideoBuffer *buffer)
+{
+  if(buffer)
+  {
+      CLog::Log(LOGNOTICE, "CRendererHisi::Create in, buffer:");
+      //CLog::Log(LOGNOTICE, "format: %s", buffer->GetFormat());
+      //CLog::Log(LOGNOTICE, "id: %d", buffer->GetId());
+      if( AV_PIX_FMT_NONE != buffer->GetFormat())
+        return nullptr;
+  }
+
+  return new CRendererHisi();
+}
+
+bool CRendererHisi::Register()
+{
+  CLog::Log(LOGNOTICE, "CRendererHisi::Register");
+  VIDEOPLAYER::CRendererFactory::RegisterRenderer("hisi", CRendererHisi::Create);
+  return true;
+}
+
+bool CRendererHisi::Configure(const VideoPicture &picture, float fps, unsigned int orientation)
+{
+    CLog::Log(LOGNOTICE, "CRendererHisi::Configure");
+
+  m_sourceWidth = picture.iWidth;
+  m_sourceHeight = picture.iHeight;
+  m_renderOrientation = orientation;
+
+  m_iFlags = GetFlagsChromaPosition(picture.chroma_position) |
+             GetFlagsColorMatrix(picture.color_space, picture.iWidth, picture.iHeight) |
+             GetFlagsColorPrimaries(picture.color_primaries) |
+             GetFlagsStereoMode(picture.stereoMode);
+
+  // Calculate the input frame aspect ratio.
+  CalculateFrameAspectRatio(picture.iDisplayWidth, picture.iDisplayHeight);
+  SetViewMode(m_videoSettings.m_ViewMode);
+  ManageRenderArea();
+
+  m_bConfigured = true;
+
+  return true;
+}
+
+CRenderInfo CRendererHisi::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.max_buffer_size = m_numRenderBuffers;
+  info.opaque_pointer = (void *)this;
+  return info;
+}
+
+bool CRendererHisi::RenderCapture(int index, CRenderCapture* capture)
+{
+  capture->BeginRender();
+  capture->EndRender();
+  //CScreenshotAML::CaptureVideoFrame((unsigned char *)capture->GetRenderBuffer(), capture->GetWidth(), capture->GetHeight());
+  return true;
+}
+
+void CRendererHisi::AddVideoPicture(const VideoPicture &picture, int index)
+{
+
+  ReleaseBuffer(index);
+
+  BUFFER &buf(m_buffers[index]);
+  if (picture.videoBuffer)
+  {
+    buf.videoBuffer = picture.videoBuffer;
+    buf.videoBuffer->Acquire();
+  }
+}
+
+void CRendererHisi::ReleaseBuffer(int idx)
+{
+  BUFFER &buf(m_buffers[idx]);
+  if (buf.videoBuffer)
+  {
+    buf.videoBuffer->Release();
+    buf.videoBuffer = nullptr;
+  }
+}
+
+bool CRendererHisi::Supports(ERENDERFEATURE feature) const
+{
+  if (feature == RENDERFEATURE_ZOOM ||
+      feature == RENDERFEATURE_CONTRAST ||
+      feature == RENDERFEATURE_BRIGHTNESS ||
+      feature == RENDERFEATURE_NONLINSTRETCH ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT ||
+      feature == RENDERFEATURE_STRETCH ||
+      feature == RENDERFEATURE_PIXEL_RATIO ||
+      feature == RENDERFEATURE_ROTATION)
+    return true;
+
+  return false;
+}
+
+void CRendererHisi::Reset()
+{
+  m_prevVPts = -1;
+  for (int i = 0 ; i < m_numRenderBuffers ; ++i)
+  {
+    if (m_buffers[i].videoBuffer)
+    {
+      m_buffers[i].videoBuffer->Release();
+      m_buffers[i].videoBuffer = nullptr;
+    }
+  }
+}
+
+void CRendererHisi::RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha)
+{
+  ManageRenderArea();
+
+/*
+  CVideoBufferHisi *amli = dynamic_cast<CVideoBufferHisi *>(m_buffers[index].videoBuffer);
+  if(amli && amli->m_amlCodec)
+  {
+    int pts = amli->m_omxPts;
+    if (pts != m_prevVPts)
+    {
+      amli->m_amlCodec->ReleaseFrame(amli->m_bufferIndex);
+      amli->m_amlCodec->SetVideoRect(m_sourceRect, m_destRect);
+      amli->m_amlCodec = nullptr; //Mark frame as processed
+      m_prevVPts = pts;
+    }
+  }
+  CAMLCodec::PollFrame();*/
+}
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.h
new file mode 100644
index 0000000000..9d2bee2faa
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.h
@@ -0,0 +1,56 @@
+/*
+ *  Copyright (C) 2007-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+
+class CRendererHisi : public CBaseRenderer
+{
+public:
+  CRendererHisi();
+  virtual ~CRendererHisi();
+
+  // Registration
+  static CBaseRenderer* Create(CVideoBuffer *buffer);
+  static bool Register();
+
+  virtual bool RenderCapture(int index, CRenderCapture* capture) override;
+  virtual void AddVideoPicture(const VideoPicture &picture, int index) override;
+  virtual void ReleaseBuffer(int idx) override;
+  virtual bool Configure(const VideoPicture &picture, float fps, unsigned int orientation) override;
+  virtual bool IsConfigured() override { return m_bConfigured; };
+  virtual bool ConfigChanged(const VideoPicture &picture) { return false; };
+  virtual CRenderInfo GetRenderInfo() override;
+  virtual void UnInit() override {};
+  virtual void Update() override {};
+  virtual void RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha) override;
+  virtual bool SupportsMultiPassRendering()override { return false; };
+
+  // Player functions
+  virtual bool IsGuiLayer() override { return false; };
+
+  // Feature support
+  virtual bool Supports(ESCALINGMETHOD method) const override { return false; };
+  virtual bool Supports(ERENDERFEATURE feature) const override;
+
+private:
+  void Reset();
+
+  static const int m_numRenderBuffers = 4;
+
+  struct BUFFER
+  {
+    BUFFER() : videoBuffer(nullptr) {};
+    CVideoBuffer *videoBuffer;
+    int duration;
+  } m_buffers[m_numRenderBuffers];
+
+  int m_prevVPts;
+  bool m_bConfigured;
+};
diff --git a/xbmc/cores/hiplayer/CMakeLists.txt b/xbmc/cores/hiplayer/CMakeLists.txt
new file mode 100644
index 0000000000..c7997c58e9
--- /dev/null
+++ b/xbmc/cores/hiplayer/CMakeLists.txt
@@ -0,0 +1,17 @@
+set(SOURCES HiAdec.cpp
+            HiCodecAudio.cpp
+            HiCodecVideo.cpp
+            HiDecoder.cpp
+            HiPlayerAudio.cpp
+            HiPlayerVideo.cpp
+            HiVdec.cpp)
+
+set(HEADERS HiAdec.h
+            HiCodecAudio.h
+            HiCodecVideo.h
+            HiDecoder.h
+            HiPlayerAudio.h
+            HiPlayerVideo.h
+            HiVdec.h)
+
+core_add_library(hiplayer)
diff --git a/xbmc/cores/hiplayer/HiAdec.cpp b/xbmc/cores/hiplayer/HiAdec.cpp
new file mode 100644
index 0000000000..c5aa93a4f7
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiAdec.cpp
@@ -0,0 +1,114 @@
+#include "HiAdec.h"
+
+#include "cores/VideoPlayer/DVDClock.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+
+CHiAudio::CHiAudio()
+    : CThread("CHiAudio")
+{
+  hwDec = HisiAvDecoder::GetInstance();
+}
+
+CHiAudio::~CHiAudio()
+{
+}
+
+bool CHiAudio::open(CDVDStreamInfo hints)
+{
+  //Create();
+  return hwDec->AudioOpen(hints);
+}
+
+bool CHiAudio::close()
+{
+  m_bStop = true;
+  //StopThread();
+  return hwDec->AudioClose();
+}
+
+bool CHiAudio::PlayStarted()
+{
+  if (FirstPts() == DVD_NOPTS_VALUE)
+    return false;
+
+  return true;
+}
+
+bool CHiAudio::EOS()
+{
+  return hwDec->IsEOS();
+}
+
+bool CHiAudio::Full()
+{
+  return hwDec->AudioBufferFull();
+}
+
+bool CHiAudio::Ready()
+{
+  return hwDec->AudioBufferReady();
+}
+
+double CHiAudio::Delay()
+{
+  return hwDec->AudioDelay();
+}
+
+double CHiAudio::CacheTime()
+{
+  return hwDec->AudioCachetime();
+}
+
+double CHiAudio::CacheTotal()
+{
+  return hwDec->AudioCacheTotal();
+}
+
+double CHiAudio::FirstPts()
+{
+  double pts = hwDec->AudioFirstPts();
+  if (pts != DVD_NOPTS_VALUE)
+    return pts;
+
+  return DVD_NOPTS_VALUE;
+}
+
+double CHiAudio::CurrentPts()
+{
+  return hwDec->AudioCurrentPts();
+}
+
+void CHiAudio::reset()
+{
+  hwDec->AudioReset();
+}
+
+void CHiAudio::reSync(double pts)
+{
+  hwDec->AudioReSync(pts);
+}
+
+void CHiAudio::SubmitEos()
+{
+  hwDec->AudioSubmitEOS();
+}
+
+bool CHiAudio::Push(uint8_t* pData, size_t iSize, unsigned int pts_ms)
+{
+  return hwDec->AudioWrite(pData, iSize, pts_ms);
+}
+
+bool CHiAudio::PushEx(uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last)
+{
+  return hwDec->AudioWriteEx(pData, iSize, pts_ms, continues, last);
+}
+
+void CHiAudio::SetVolume(int Volume)
+{
+  hwDec->SetVolume(Volume);
+}
+
+void CHiAudio::SetMute(bool bOnOff)
+{
+  hwDec->Mute(bOnOff);
+}
diff --git a/xbmc/cores/hiplayer/HiAdec.h b/xbmc/cores/hiplayer/HiAdec.h
new file mode 100644
index 0000000000..0cb2ac23d7
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiAdec.h
@@ -0,0 +1,59 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiDecoder.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Thread.h"
+
+class CHiAudio : public CThread
+{
+public:
+  CHiAudio();
+  virtual ~CHiAudio();
+
+  bool open(CDVDStreamInfo hints);
+  bool close();
+
+  bool PlayStarted();
+  bool EOS();
+  bool Ready();
+  bool Full();
+
+  double Delay();
+  double CacheTime();
+  double CacheTotal();
+  double FirstPts();
+  double CurrentPts();
+
+  void SubmitEos();
+  void reset();
+  void reSync(double pts);
+
+  bool Push(uint8_t* pData, size_t iSize, unsigned int pts_ms);
+  bool PushEx(uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+  void SetVolume(int Volume);
+  void SetMute(bool bOnOff);
+
+private:
+  HisiAvDecoder* hwDec;
+  bool m_bStop;
+};
diff --git a/xbmc/cores/hiplayer/HiCodecAudio.cpp b/xbmc/cores/hiplayer/HiCodecAudio.cpp
new file mode 100644
index 0000000000..0786a86283
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiCodecAudio.cpp
@@ -0,0 +1,419 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiCodecAudio.h"
+
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+#include "system.h"
+// the size of the audio_render output port buffers
+#define AUDIO_DECODE_OUTPUT_BUFFER (32 * 1024)
+static const char rounded_up_channels_shift[] = {0, 0, 1, 2, 2, 3, 3, 3, 3};
+
+CDVDAudioCodecHisi::CDVDAudioCodecHisi(CProcessInfo& processInfo)
+    : m_processInfo(processInfo)
+{
+  m_pBufferOutput = NULL;
+  m_iBufferOutputAlloced = 0;
+  m_iBufferOutputUsed = 0;
+
+  m_pCodecContext = NULL;
+  m_pConvert = NULL;
+
+  m_channels = 0;
+  m_pFrame1 = NULL;
+  m_frameSize = 0;
+  m_bGotFrame = false;
+  m_bNoConcatenate = false;
+
+  m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = AV_SAMPLE_FMT_NONE;
+
+  m_desiredchannels = 2;
+}
+
+CDVDAudioCodecHisi::~CDVDAudioCodecHisi()
+{
+  if (m_pBufferOutput)
+    av_free(m_pBufferOutput);
+  m_pBufferOutput = NULL;
+  m_iBufferOutputAlloced = 0;
+  m_iBufferOutputUsed = 0;
+  Dispose();
+}
+
+bool CDVDAudioCodecHisi::Open(CDVDStreamInfo& hints)
+{
+  const AVCodec* pCodec = NULL;
+
+  if (hints.codec == AV_CODEC_ID_DTS)
+  {
+    pCodec = avcodec_find_decoder_by_name("dcadec");
+  }
+
+  if (!pCodec)
+    pCodec = avcodec_find_decoder(hints.codec);
+
+  if (!pCodec)
+  {
+    CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::Open() Unable to find codec {}", hints.codec);
+    return false;
+  }
+
+  m_bFirstFrame = true;
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
+  if (!m_pCodecContext)
+    return false;
+
+//   m_pCodecContext->debug_mv = 0;
+  m_pCodecContext->debug = 0;
+  m_pCodecContext->workaround_bugs = 1;
+
+//  if (pCodec->capabilities & AV_CODEC_CAP_TRUNCATED)
+//    m_pCodecContext->flags |= AV_CODEC_FLAG_TRUNCATED;
+
+  m_channels = 0;
+  m_pCodecContext->channels = hints.channels;
+  m_pCodecContext->sample_rate = hints.samplerate;
+  m_pCodecContext->block_align = hints.blockalign;
+  m_pCodecContext->bit_rate = hints.bitrate;
+  m_pCodecContext->bits_per_coded_sample = hints.bitspersample;
+  m_pCodecContext->request_channel_layout = AV_CH_LAYOUT_STEREO;
+
+  if (m_pCodecContext->request_channel_layout)
+    CLog::Log(LOGNOTICE, "CDVDAudioCodecHisi::Open() Requesting channel layout of  {}",
+              (unsigned)m_pCodecContext->request_channel_layout);
+
+  if (m_pCodecContext->bits_per_coded_sample == 0)
+    m_pCodecContext->bits_per_coded_sample = 16;
+
+  if (hints.extradata.GetData() && hints.extradata.GetSize() > 0)
+  {
+    m_pCodecContext->extradata =
+        (uint8_t*)av_mallocz(hints.extradata.GetSize() + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (m_pCodecContext->extradata)
+    {
+      m_pCodecContext->extradata_size = hints.extradata.GetSize();
+      memcpy(m_pCodecContext->extradata, hints.extradata.GetData(), hints.extradata.GetSize());
+    }
+  }
+
+  if (avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
+  {
+    CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::Open() Unable to open codec");
+    Dispose();
+    return false;
+  }
+
+  m_pFrame1 = av_frame_alloc();
+  if (!m_pFrame1)
+  {
+    Dispose();
+    return false;
+  }
+
+  m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = AV_SAMPLE_FMT_S16;
+  m_processInfo.SetAudioDecoderName(m_pCodecContext->codec->name);
+  return true;
+}
+
+void CDVDAudioCodecHisi::Dispose()
+{
+  av_frame_free(&m_pFrame1);
+  swr_free(&m_pConvert);
+  avcodec_free_context(&m_pCodecContext);
+  m_bGotFrame = false;
+}
+
+int CDVDAudioCodecHisi::Decode(BYTE* pData, int iSize, double dts, double pts)
+{
+  int iBytesUsed;
+  bool got_frame;
+  if (!m_pCodecContext)
+    return -1;
+
+  AVPacket avpkt;
+  if (!m_iBufferOutputUsed)
+  {
+    m_dts = dts;
+    m_pts = pts;
+  }
+
+  if (m_bGotFrame)
+    return 0;
+
+  av_init_packet(&avpkt);
+  avpkt.data = pData;
+  avpkt.size = iSize;
+  // iBytesUsed = avcodec_decode_audio4(m_pCodecContext, m_pFrame1, &got_frame, &avpkt);
+  iBytesUsed = avcodec_receive_frame(m_pCodecContext, m_pFrame1);
+  if (iBytesUsed == 0)
+    got_frame = true;
+  if(iBytesUsed == AVERROR(EAGAIN))
+    iBytesUsed = 0;
+  if (iBytesUsed == 0)
+    iBytesUsed = avcodec_send_packet(m_pCodecContext, &avpkt);
+  if (iBytesUsed == AVERROR(EAGAIN))
+    iBytesUsed = 0;
+  if (iBytesUsed >= 0)
+    iBytesUsed = avpkt.size;
+  if (iBytesUsed < 0 || !got_frame)
+  {
+    return iBytesUsed;
+  }
+  /* some codecs will attempt to consume more data than what we gave */
+  if (iBytesUsed > iSize)
+  {
+    CLog::Log(LOGWARNING,
+              "CDVDAudioCodecHisi::Decode - decoder attempted to consume more data than given");
+    iBytesUsed = iSize;
+  }
+
+  // if (m_bFirstFrame)
+  // {
+  //   // CLog::Log(LOGDEBUG,
+  //   //           "CDVDAudioCodecHisi::Decode(%p,%d) format=%d(%d) chan=%d samples=%d size=%d "
+  //   //           "data=%p,%p,%p,%p,%p,%p,%p,%p",
+  //   //           pData, iSize, m_pCodecContext->sample_fmt, m_desiredSampleFormat,
+  //   //           m_pCodecContext->channels, m_pFrame1->nb_samples, m_pFrame1->linesize[0],
+  //   //           m_pFrame1->data[0], m_pFrame1->data[1], m_pFrame1->data[2], m_pFrame1->data[3],
+  //   //           m_pFrame1->data[4], m_pFrame1->data[5], m_pFrame1->data[6], m_pFrame1->data[7]);
+  // }
+
+  m_bGotFrame = true;
+  return iBytesUsed;
+}
+
+int CDVDAudioCodecHisi::GetData(BYTE** dst, double& dts, double& pts)
+{
+  if (!m_bGotFrame)
+    return 0;
+  int inLineSize, outLineSize;
+  /* input audio is aligned */
+  int inputSize = av_samples_get_buffer_size(&inLineSize, m_pCodecContext->channels,
+                                             m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 0);
+  /* output audio will be packed */
+  int outputSize = av_samples_get_buffer_size(&outLineSize, m_desiredchannels,
+                                              m_pFrame1->nb_samples, m_desiredSampleFormat, 1);
+
+  if (!m_bNoConcatenate && m_iBufferOutputUsed && (int)m_frameSize != outputSize)
+  {
+    CLog::Log(LOGERROR, "CDVDAudioCodecHisi::GetData Unexpected change of size ({}->{})",
+              m_frameSize, outputSize);
+    m_bNoConcatenate = true;
+  }
+
+  // if this buffer won't fit then flush out what we have
+  int desired_size = AUDIO_DECODE_OUTPUT_BUFFER * (m_desiredchannels * GetBitsPerSample()) >>
+                     (rounded_up_channels_shift[m_desiredchannels] + 4);
+  if (m_iBufferOutputUsed && (m_iBufferOutputUsed + outputSize > desired_size || m_bNoConcatenate))
+  {
+    int ret = m_iBufferOutputUsed;
+    m_iBufferOutputUsed = 0;
+    m_bNoConcatenate = false;
+    dts = m_dts;
+    pts = m_pts;
+    *dst = m_pBufferOutput;
+    return ret;
+  }
+
+  m_frameSize = outputSize;
+
+  if (m_iBufferOutputAlloced < m_iBufferOutputUsed + outputSize)
+  {
+    m_pBufferOutput = (BYTE*)av_realloc(m_pBufferOutput, m_iBufferOutputUsed + outputSize +
+                                                             AV_INPUT_BUFFER_PADDING_SIZE);
+    m_iBufferOutputAlloced = m_iBufferOutputUsed + outputSize;
+  }
+
+  /* need to convert format */
+  if (m_pCodecContext->sample_fmt != m_desiredSampleFormat ||
+      m_pCodecContext->channels != m_desiredchannels)
+  {
+    if (m_pConvert &&
+        (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
+    {
+      swr_free(&m_pConvert);
+      m_channels = m_pCodecContext->channels;
+    }
+
+    if (!m_pConvert)
+    {
+      m_iSampleFormat = m_pCodecContext->sample_fmt;
+      m_pConvert = swr_alloc_set_opts(
+          NULL, av_get_default_channel_layout(m_desiredchannels), m_desiredSampleFormat,
+          m_pCodecContext->sample_rate, av_get_default_channel_layout(m_pCodecContext->channels),
+          m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate, 0, NULL);
+
+      if (!m_pConvert || swr_init(m_pConvert) < 0)
+      {
+        CLog::Log(LOGERROR,
+                  "CDVDAudioCodecHisi::Decode - Unable to initialise convert format {} to {}",
+                  m_pCodecContext->sample_fmt, m_desiredSampleFormat);
+        return 0;
+      }
+    }
+
+    /* use unaligned flag to keep output packed */
+    uint8_t* out_planes[m_pCodecContext->channels];
+    if (av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput + m_iBufferOutputUsed,
+                               m_desiredchannels, m_pFrame1->nb_samples, m_desiredSampleFormat,
+                               1) < 0 ||
+        swr_convert(m_pConvert, out_planes, m_pFrame1->nb_samples, (const uint8_t**)m_pFrame1->data,
+                    m_pFrame1->nb_samples) < 0)
+    {
+      CLog::Log(LOGERROR, "CDVDAudioCodecHisi::Decode - Unable to convert format {} to {}",
+                (int)m_pCodecContext->sample_fmt, m_desiredSampleFormat);
+      outputSize = 0;
+    }
+  }
+  else
+  {
+    /* copy to a contiguous buffer */
+    uint8_t* out_planes[m_pCodecContext->channels];
+    if (av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput + m_iBufferOutputUsed,
+                               m_pCodecContext->channels, m_pFrame1->nb_samples,
+                               m_desiredSampleFormat, 1) < 0 ||
+        av_samples_copy(out_planes, m_pFrame1->data, 0, 0, m_pFrame1->nb_samples,
+                        m_pCodecContext->channels, m_desiredSampleFormat) < 0)
+    {
+      outputSize = 0;
+    }
+  }
+
+  m_bGotFrame = false;
+
+  if (m_bFirstFrame)
+  {
+//    CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::GetData size={}/{} line={}/{} buf={}, desired={}",
+//              inputSize, outputSize, inLineSize, outLineSize, m_pBufferOutput, desired_size);
+    m_bFirstFrame = false;
+  }
+  m_iBufferOutputUsed += outputSize;
+  return 0;
+}
+
+void CDVDAudioCodecHisi::Reset()
+{
+  if (m_pCodecContext)
+    avcodec_flush_buffers(m_pCodecContext);
+  m_bGotFrame = false;
+  m_iBufferOutputUsed = 0;
+}
+
+int CDVDAudioCodecHisi::GetChannels()
+{
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->channels;
+}
+
+int CDVDAudioCodecHisi::GetSampleRate()
+{
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->sample_rate;
+}
+
+int CDVDAudioCodecHisi::GetBitsPerSample()
+{
+  if (!m_pCodecContext)
+    return 0;
+  return m_desiredSampleFormat == AV_SAMPLE_FMT_S16 ? 16 : 32;
+}
+
+int CDVDAudioCodecHisi::GetBitRate()
+{
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->bit_rate;
+}
+
+static unsigned count_bits(uint64_t value)
+{
+  unsigned bits = 0;
+  for (; value; ++bits)
+    value &= value - 1;
+  return bits;
+}
+
+void CDVDAudioCodecHisi::BuildChannelMap()
+{
+  uint64_t layout;
+  int bits = count_bits(m_pCodecContext->channel_layout);
+  if (bits == m_pCodecContext->channels)
+    layout = m_pCodecContext->channel_layout;
+  else
+  {
+    CLog::Log(LOGINFO,
+              "CDVDAudioCodecHisi::GetChannelMap - FFmpeg reported {} channels, but the layout "
+              "contains {} ignoring",
+              m_pCodecContext->channels, bits);
+    layout = av_get_default_channel_layout(m_pCodecContext->channels);
+  }
+
+  m_channelLayout.Reset();
+
+  if (layout & AV_CH_FRONT_LEFT)
+    m_channelLayout += AE_CH_FL;
+  if (layout & AV_CH_FRONT_RIGHT)
+    m_channelLayout += AE_CH_FR;
+  if (layout & AV_CH_FRONT_CENTER)
+    m_channelLayout += AE_CH_FC;
+  if (layout & AV_CH_LOW_FREQUENCY)
+    m_channelLayout += AE_CH_LFE;
+  if (layout & AV_CH_BACK_LEFT)
+    m_channelLayout += AE_CH_BL;
+  if (layout & AV_CH_BACK_RIGHT)
+    m_channelLayout += AE_CH_BR;
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER)
+    m_channelLayout += AE_CH_FLOC;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER)
+    m_channelLayout += AE_CH_FROC;
+  if (layout & AV_CH_BACK_CENTER)
+    m_channelLayout += AE_CH_BC;
+  if (layout & AV_CH_SIDE_LEFT)
+    m_channelLayout += AE_CH_SL;
+  if (layout & AV_CH_SIDE_RIGHT)
+    m_channelLayout += AE_CH_SR;
+  if (layout & AV_CH_TOP_CENTER)
+    m_channelLayout += AE_CH_TC;
+  if (layout & AV_CH_TOP_FRONT_LEFT)
+    m_channelLayout += AE_CH_TFL;
+  if (layout & AV_CH_TOP_FRONT_CENTER)
+    m_channelLayout += AE_CH_TFC;
+  if (layout & AV_CH_TOP_FRONT_RIGHT)
+    m_channelLayout += AE_CH_TFR;
+  if (layout & AV_CH_TOP_BACK_LEFT)
+    m_channelLayout += AE_CH_BL;
+  if (layout & AV_CH_TOP_BACK_CENTER)
+    m_channelLayout += AE_CH_BC;
+  if (layout & AV_CH_TOP_BACK_RIGHT)
+    m_channelLayout += AE_CH_BR;
+}
+
+CAEChannelInfo CDVDAudioCodecHisi::GetChannelMap()
+{
+  BuildChannelMap();
+  return m_channelLayout;
+}
diff --git a/xbmc/cores/hiplayer/HiCodecAudio.h b/xbmc/cores/hiplayer/HiCodecAudio.h
new file mode 100644
index 0000000000..fdeec19c5f
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiCodecAudio.h
@@ -0,0 +1,93 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDStreamInfo.h"
+#include "cores/AudioEngine/AEResampleFactory.h"
+#include "cores/AudioEngine/Utils/AEAudioFormat.h"
+#include "cores/AudioEngine/Utils/AEStreamInfo.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+#include "PlatformDefs.h"
+
+extern "C"
+{
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+class CProcessInfo;
+
+class CDVDAudioCodecHisi
+{
+public:
+  CDVDAudioCodecHisi(CProcessInfo& processInfo);
+  virtual ~CDVDAudioCodecHisi();
+  bool Open(CDVDStreamInfo& hints);
+  void Dispose();
+  int Decode(BYTE* pData, int iSize, double dts, double pts);
+  int GetData(BYTE** dst, double& dts, double& pts);
+  void Reset();
+  int GetChannels();
+  void BuildChannelMap();
+  CAEChannelInfo GetChannelMap();
+  int GetSampleRate();
+  int GetBitsPerSample();
+  static const char* GetName()
+  {
+    return "FFmpeg";
+  }
+  int GetBitRate();
+  unsigned int GetFrameSize()
+  {
+    return m_frameSize;
+  }
+
+protected:
+  CProcessInfo& m_processInfo;
+  AVCodecContext* m_pCodecContext;
+  SwrContext* m_pConvert;
+  enum AVSampleFormat m_iSampleFormat;
+  enum AVSampleFormat m_desiredSampleFormat;
+
+  AVFrame* m_pFrame1;
+
+  BYTE* m_pBufferOutput;
+  int m_iBufferOutputUsed;
+  int m_iBufferOutputAlloced;
+
+  int m_channels;
+  CAEChannelInfo m_channelLayout;
+  int m_desiredchannels;
+  CAEChannelInfo m_desiredchannelLayout;
+
+  bool m_bFirstFrame;
+  bool m_bGotFrame;
+  bool m_bNoConcatenate;
+  unsigned int m_frameSize;
+  double m_dts, m_pts;
+
+  unsigned char m_buffer[10240];
+};
diff --git a/xbmc/cores/hiplayer/HiCodecVideo.cpp b/xbmc/cores/hiplayer/HiCodecVideo.cpp
new file mode 100644
index 0000000000..f68c0ff6d6
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiCodecVideo.cpp
@@ -0,0 +1,577 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiCodecVideo.h"
+
+#include "DVDClock.h"
+#include "DVDStreamInfo.h"
+#include "HiVdec.h"
+#include "Util.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "settings/Settings.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/log.h"
+
+#include <math.h>
+
+#define __MODULE_NAME__ "DVDVideoCodecHisi"
+
+#define _4CC(c1, c2, c3, c4) \
+  (((uint32_t)(c4) << 24) | ((uint32_t)(c3) << 16) | ((uint32_t)(c2) << 8) | (uint32_t)(c1))
+
+typedef struct frame_queue
+{
+  double dts;
+  double pts;
+  double sort_time;
+  struct frame_queue* nextframe;
+} frame_queue;
+
+CDVDVideoCodecHisi::CDVDVideoCodecHisi(CProcessInfo& processInfo)
+    : CDVDVideoCodec(processInfo)
+    , m_Codec(NULL)
+    , m_pFormatName("hisicodec")
+    , m_last_pts(0.0)
+    , m_frame_queue(NULL)
+    , m_queue_depth(0)
+    , m_framerate(0.0)
+    , m_video_rate(0)
+    , m_mpeg2_sequence(NULL)
+    , m_bitparser(NULL)
+    , m_bitstream(nullptr)
+    , m_opened(false)
+    , m_drop(false)
+{
+  pthread_mutex_init(&m_queue_mutex, NULL);
+}
+
+CDVDVideoCodecHisi::~CDVDVideoCodecHisi()
+{
+  Dispose();
+  pthread_mutex_destroy(&m_queue_mutex);
+}
+
+bool CDVDVideoCodecHisi::AddData(const DemuxPacket& packet)
+{
+  return true;
+}
+
+bool CDVDVideoCodecHisi::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
+{
+  if (hints.stills)
+    return false;
+
+  m_hints = hints;
+  switch (hints.codec)
+  {
+    case AV_CODEC_ID_MJPEG:
+      m_pFormatName = "hi-mjpeg";
+      break;
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      // case AV_CODEC_ID_MPEG2VIDEO_XVMC:
+      m_pFormatName = "hi-mpeg2";
+      break;
+    case AV_CODEC_ID_H264:
+      m_pFormatName = "hi-h264";
+      // convert h264-avcC to h264-annex-b as h264-avcC
+      // under streamers can have issues when seeking.
+      if (m_hints.extradata && !m_hints.cryptoSession)
+      {
+        m_bitstream = std::make_unique<CBitstreamConverter>();
+        if (!m_bitstream->Open(m_hints.codec, m_hints.extradata.GetData(), m_hints.extradata.GetSize(), true))
+        // make sure we do not leak the existing m_hints.extradata
+        {
+          // make sure we do not leak the existing m_hints.extradata
+          // free(m_hints.extradata);
+          // m_hints.extrasize = m_bitstream->GetExtraSize();
+          // m_hints.extradata = malloc(m_hints.extrasize);
+          m_bitstream.reset();
+        }
+      }
+      break;
+    case AV_CODEC_ID_HEVC:
+      m_pFormatName = "hi-h265";
+      if (m_hints.extradata.GetSize() && m_hints.extradata.GetSize() >= 23)
+      {
+        m_bitstream = std::make_unique<CBitstreamConverter>();
+        if (!m_bitstream->Open(m_hints.codec, m_hints.extradata.GetData(), m_hints.extradata.GetSize(), true))
+        {
+          // make sure we do not leak the existing m_hints.extradata
+          // free(m_hints.extradata);
+          // m_hints.extrasize = m_bitstream->GetExtraSize();
+          // m_hints.extradata = malloc(m_hints.extrasize);
+          m_bitstream.reset();
+        }
+      }
+      break;
+    case AV_CODEC_ID_H263:
+    case AV_CODEC_ID_H263P:
+    case AV_CODEC_ID_H263I:
+      m_pFormatName = "hi-h263";
+      break;
+    case AV_CODEC_ID_FLV1:
+      m_pFormatName = "hi-flv1";
+      break;
+    case AV_CODEC_ID_RV10:
+    case AV_CODEC_ID_RV20:
+    case AV_CODEC_ID_RV30:
+    case AV_CODEC_ID_RV40:
+      m_pFormatName = "hi-rv";
+      break;
+    case AV_CODEC_ID_VC1:
+      m_pFormatName = "hi-vc1";
+      //m_hints.extrasize = sizeof(vc1_header);
+      //m_hints.extradata = malloc(m_hints.extrasize);
+      //memcpy(m_hints.extradata, vc1_header, m_hints.extrasize);
+      break;
+    case AV_CODEC_ID_WMV3:
+      m_pFormatName = "hi-wmv3";
+      break;
+    case AV_CODEC_ID_AVS:
+    case AV_CODEC_ID_CAVS:
+      m_pFormatName = "hi-avs";
+      break;
+    case AV_CODEC_ID_MPEG4:
+    case AV_CODEC_ID_MSMPEG4V2:
+    case AV_CODEC_ID_MSMPEG4V3:
+      m_pFormatName = "hi-mpeg4";
+    default:
+      CLog::Log(LOGDEBUG, "{}: Unknown hints.codec: {}!", __MODULE_NAME__, m_hints.codec);
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "{}: format:{}", __MODULE_NAME__, m_pFormatName);
+
+  m_aspect_ratio = m_hints.aspect;
+  m_Codec = new CHisiVdec();
+  if (!m_Codec)
+  {
+    CLog::Log(LOGERROR, "{}: Failed to create Codec", __MODULE_NAME__);
+    return false;
+  }
+  m_opened = false;
+
+  // allocate a dummy VideoPicture buffer.
+  // first make sure all properties are reset.
+  m_videobuffer.Reset();
+
+  m_videobuffer.dts = DVD_NOPTS_VALUE;
+  m_videobuffer.pts = DVD_NOPTS_VALUE;
+  //m_videobuffer.format = RENDER_FMT_HISI;
+  m_videobuffer.iFlags = 0;
+  m_videobuffer.iWidth = m_hints.width;
+  m_videobuffer.iHeight = m_hints.height;
+  //m_videobuffer.hisicodec = NULL;
+
+  m_videobuffer.iDisplayWidth = m_videobuffer.iWidth;
+  m_videobuffer.iDisplayHeight = m_videobuffer.iHeight;
+  if (m_hints.aspect > 0.0 && !m_hints.forced_aspect)
+  {
+    m_videobuffer.iDisplayWidth = ((int)lrint(m_videobuffer.iHeight * m_hints.aspect)) & ~3;
+    if (m_videobuffer.iDisplayWidth > m_videobuffer.iWidth)
+    {
+      m_videobuffer.iDisplayWidth = m_videobuffer.iWidth;
+      m_videobuffer.iDisplayHeight = ((int)lrint(m_videobuffer.iWidth / m_hints.aspect)) & ~3;
+    }
+  }
+
+  m_processInfo.SetVideoDecoderName(m_pFormatName, true);
+  m_processInfo.SetVideoDimensions(m_hints.width, m_hints.height);
+  m_processInfo.SetVideoDeintMethod("hardware");
+
+  CLog::Log(LOGINFO, "{}: Opened Hisi Codec", __MODULE_NAME__);
+  return true;
+}
+
+void CDVDVideoCodecHisi::Dispose(void)
+{
+  if (m_Codec)
+    m_Codec->CloseDecoder(), delete m_Codec, m_Codec = NULL;
+
+  if (m_videobuffer.iFlags)
+    m_videobuffer.iFlags = 0;
+
+  if (m_mpeg2_sequence)
+    delete m_mpeg2_sequence, m_mpeg2_sequence = NULL;
+
+  if (m_bitstream)
+    m_bitstream->ResetStartDecode();
+
+  if (m_bitparser)
+    delete m_bitparser, m_bitparser = NULL;
+
+  while (m_queue_depth)
+    FrameQueuePop();
+}
+
+int CDVDVideoCodecHisi::Decode(uint8_t* pData, int iSize, double dts, double pts)
+{
+  std::atomic_bool abort(false);
+  return Decode(pData, iSize, dts, pts, abort);
+}
+
+int CDVDVideoCodecHisi::Decode(
+    uint8_t* pData, int iSize, double dts, double pts, std::atomic_bool& abort)
+{
+  // Handle Input, add demuxer packet to input queue, we must accept it or
+  // it will be discarded as VideoPlayerVideo has no concept of "try again".
+  if (pData)
+  {
+    if (m_bitstream)
+    {
+      if (!m_bitstream->Convert(pData, iSize))
+        return VC_ERROR;
+
+      pData = m_bitstream->GetConvertBuffer();
+      iSize = m_bitstream->GetConvertSize();
+    }
+
+    //if (m_bitparser)
+    //  m_bitparser->FindIdrSlice(pData, iSize);
+
+    FrameRateTracking(pData, iSize, dts, pts);
+  }
+
+  if (!m_opened)
+  {
+    if (m_Codec && !m_Codec->OpenDecoder(m_hints))
+      CLog::Log(LOGERROR, "{}: Failed to open hisi Codec", __MODULE_NAME__);
+    m_opened = true;
+  }
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  return m_Codec->Decode(pData, iSize, dts, pts, abort);
+}
+
+void CDVDVideoCodecHisi::Reset(void)
+{
+  while (m_queue_depth)
+    FrameQueuePop();
+
+  m_Codec->Reset();
+  m_mpeg2_sequence_pts = 0;
+}
+
+void CDVDVideoCodecHisi::ReSync(double pts)
+{
+  while (m_queue_depth)
+    FrameQueuePop();
+
+  m_Codec->ReSync(pts);
+  m_mpeg2_sequence_pts = 0;
+}
+
+void CDVDVideoCodecHisi::SubmitEOS()
+{
+  m_Codec->SubmitEos();
+}
+
+bool CDVDVideoCodecHisi::IsEOS()
+{
+  return m_Codec->EOS();
+}
+
+bool CDVDVideoCodecHisi::PlayStarted()
+{
+  return m_Codec->PlayStarted();
+}
+
+bool CDVDVideoCodecHisi::BufferFull()
+{
+  return m_Codec->BufferFull();
+}
+
+bool CDVDVideoCodecHisi::BufferReady()
+{
+  return m_Codec->BufferReady();
+}
+
+double CDVDVideoCodecHisi::FirstPts()
+{
+  return m_Codec->FirstPts();
+}
+
+double CDVDVideoCodecHisi::GetCurrentPts()
+{
+  return m_Codec->GetCurrentPts();
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecHisi::GetPicture(VideoPicture* pDvdVideoPicture)
+{
+  CDVDVideoCodec::VCReturn ret = VC_PICTURE;
+  if (m_Codec)
+    m_Codec->GetPicture(&m_videobuffer);
+
+  pDvdVideoPicture->SetParams(m_videobuffer);
+  //get thumb file
+
+  // check for mpeg2 aspect ratio changes
+  if (m_mpeg2_sequence && pDvdVideoPicture->pts >= m_mpeg2_sequence_pts)
+    m_aspect_ratio = m_mpeg2_sequence->ratio;
+
+  pDvdVideoPicture->iDisplayWidth = pDvdVideoPicture->iWidth;
+  pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
+  if (m_aspect_ratio > 1.0f && !m_hints.forced_aspect)
+  {
+    pDvdVideoPicture->iDisplayWidth = ((int)lrint(pDvdVideoPicture->iHeight * m_aspect_ratio)) & ~3;
+    if (pDvdVideoPicture->iDisplayWidth > pDvdVideoPicture->iWidth)
+    {
+      pDvdVideoPicture->iDisplayWidth = pDvdVideoPicture->iWidth;
+      pDvdVideoPicture->iDisplayHeight =
+          ((int)lrint(pDvdVideoPicture->iWidth / m_aspect_ratio)) & ~3;
+    }
+  }
+
+  //printf("CDVDVideoCodecHisi::GetPicture flags:{}\n", pDvdVideoPicture->iFlags);
+  return ret;
+}
+
+bool CDVDVideoCodecHisi::ClearPicture(VideoPicture* pDvdVideoPicture)
+{
+  return true;
+}
+
+void CDVDVideoCodecHisi::SetDropState(bool bDrop)
+{
+  if (bDrop == m_drop)
+    return;
+
+  m_drop = bDrop;
+  if (bDrop)
+    m_videobuffer.iFlags |= DVP_FLAG_DROPPED;
+  else
+    m_videobuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+  // Freerun mode causes amvideo driver to ignore timing and process frames
+  // as quickly as they are coming from decoder. By enabling freerun mode we can
+  // skip rendering of the frames that are requested to be dropped by VideoPlayer.
+
+  if (m_Codec)
+    m_Codec->SetFreeRun(bDrop);
+  //SysfsUtils::SetInt("/sys/class/video/freerun_mode", bDrop ? 1 : 0);
+  //set free run mode
+}
+
+void CDVDVideoCodecHisi::SetSpeed(int iSpeed)
+{
+  if (m_Codec)
+  {
+    CLog::Log(LOGERROR, "{}: {}", __FUNCTION__, iSpeed);
+    m_Codec->SetSpeed(iSpeed);
+  }
+  else
+    CLog::Log(LOGERROR, "{}: Codec not ready", __FUNCTION__);
+}
+
+int CDVDVideoCodecHisi::GetDataSize(void)
+{
+  if (m_Codec)
+    return m_Codec->GetDataSize();
+
+  return 0;
+}
+
+double CDVDVideoCodecHisi::GetTimeSize(void)
+{
+  if (m_Codec)
+    return m_Codec->GetTimeSize();
+
+  return 0.0;
+}
+
+void CDVDVideoCodecHisi::FrameQueuePop(void)
+{
+  if (!m_frame_queue || m_queue_depth == 0)
+    return;
+
+  pthread_mutex_lock(&m_queue_mutex);
+  // pop the top frame off the queue
+  frame_queue* top = m_frame_queue;
+  m_frame_queue = top->nextframe;
+  m_queue_depth--;
+  pthread_mutex_unlock(&m_queue_mutex);
+
+  // and release it
+  free(top);
+}
+
+void CDVDVideoCodecHisi::FrameQueuePush(double dts, double pts)
+{
+  frame_queue* newframe = (frame_queue*)calloc(sizeof(frame_queue), 1);
+  newframe->dts = dts;
+  newframe->pts = pts;
+  // if both dts or pts are good we use those, else use decoder insert time for frame sort
+  if ((newframe->pts != DVD_NOPTS_VALUE) || (newframe->dts != DVD_NOPTS_VALUE))
+  {
+    // if pts is borked (stupid avi's), use dts for frame sort
+    if (newframe->pts == DVD_NOPTS_VALUE)
+      newframe->sort_time = newframe->dts;
+    else
+      newframe->sort_time = newframe->pts;
+  }
+
+  pthread_mutex_lock(&m_queue_mutex);
+  frame_queue* queueWalker = m_frame_queue;
+  if (!queueWalker || (newframe->sort_time < queueWalker->sort_time))
+  {
+    // we have an empty queue, or this frame earlier than the current queue head.
+    newframe->nextframe = queueWalker;
+    m_frame_queue = newframe;
+  }
+  else
+  {
+    // walk the queue and insert this frame where it belongs in display order.
+    bool ptrInserted = false;
+    frame_queue* nextframe = NULL;
+    //
+    while (!ptrInserted)
+    {
+      nextframe = queueWalker->nextframe;
+      if (!nextframe || (newframe->sort_time < nextframe->sort_time))
+      {
+        // if the next frame is the tail of the queue, or our new frame is earlier.
+        newframe->nextframe = nextframe;
+        queueWalker->nextframe = newframe;
+        ptrInserted = true;
+      }
+      queueWalker = nextframe;
+    }
+  }
+  m_queue_depth++;
+  pthread_mutex_unlock(&m_queue_mutex);
+}
+
+void CDVDVideoCodecHisi::FrameRateTracking(uint8_t* pData, int iSize, double dts, double pts)
+{
+  // mpeg2 handling
+  if (m_mpeg2_sequence)
+  {
+    // probe demux for sequence_header_code NAL and
+    // decode aspect ratio and frame rate.
+    if (CBitstreamConverter::mpeg2_sequence_header(pData, iSize, m_mpeg2_sequence))
+    {
+      m_mpeg2_sequence_pts = pts;
+      if (m_mpeg2_sequence_pts == DVD_NOPTS_VALUE)
+        m_mpeg2_sequence_pts = dts;
+
+      m_hints.fpsrate = m_mpeg2_sequence->fps_rate;
+      m_hints.fpsscale = m_mpeg2_sequence->fps_scale;
+      m_framerate = static_cast<double>(m_mpeg2_sequence->fps_rate) / m_mpeg2_sequence->fps_scale;
+      m_video_rate = (int)(0.5 + (96000.0 / m_framerate));
+
+      m_hints.width = m_mpeg2_sequence->width;
+      m_hints.height = m_mpeg2_sequence->height;
+      m_hints.aspect = static_cast<double> (m_mpeg2_sequence->ratio);
+    }
+    return;
+  }
+
+#if 0
+  // everything else
+  FrameQueuePush(dts, pts);
+
+  // we might have out-of-order pts,
+  // so make sure we wait for at least 8 values in sorted queue.
+  if (m_queue_depth > 16)
+  {
+    pthread_mutex_lock(&m_queue_mutex);
+
+    float cur_pts = m_frame_queue->pts;
+    if (cur_pts == DVD_NOPTS_VALUE)
+      cur_pts = m_frame_queue->dts;
+
+    pthread_mutex_unlock(&m_queue_mutex);	
+
+    float duration = cur_pts - m_last_pts;
+    m_last_pts = cur_pts;
+
+    // clamp duration to sensible range,
+    // 66 fsp to 20 fsp
+    if (duration >= 15000.0 && duration <= 50000.0)
+    {
+      double framerate;
+      switch((int)(0.5 + duration))
+      {
+        // 59.940 (16683.333333)
+        case 16000 ... 17000:
+          framerate = 60000.0 / 1001.0;
+          break;
+
+        // 50.000 (20000.000000)
+        case 20000:
+          framerate = 50000.0 / 1000.0;
+          break;
+
+        // 49.950 (20020.000000)
+        case 20020:
+          framerate = 50000.0 / 1001.0;
+          break;
+
+        // 29.970 (33366.666656)
+        case 32000 ... 35000:
+          framerate = 30000.0 / 1001.0;
+          break;
+
+        // 25.000 (40000.000000)
+        case 40000:
+          framerate = 25000.0 / 1000.0;
+          break;
+
+        // 24.975 (40040.000000)
+        case 40040:
+          framerate = 25000.0 / 1001.0;
+          break;
+
+        /*
+        // 24.000 (41666.666666)
+        case 41667:
+          framerate = 24000.0 / 1000.0;
+          break;
+        */
+
+        // 23.976 (41708.33333)
+        case 40200 ... 43200:
+          // 23.976 seems to have the crappiest encodings :)
+          framerate = 24000.0 / 1001.0;
+          break;
+
+        default:
+          framerate = 0.0;
+          //CLog::Log(LOGDEBUG, "{}: unknown duration(%f), cur_pts(%f)",
+          //  __MODULE_NAME__, duration, cur_pts);
+          break;
+      }
+
+      if (framerate > 0.0 && (int)m_framerate != (int)framerate)
+      {
+        m_framerate = framerate;
+        m_video_rate = (int)(0.5 + (96000.0 / framerate));
+        CLog::Log(LOGDEBUG, "{}: hiplayer detected new frame rate({:f}), video_rate({})",
+          __MODULE_NAME__, m_framerate, m_video_rate);
+      }
+    }
+
+    FrameQueuePop();
+  }
+#endif
+}
diff --git a/xbmc/cores/hiplayer/HiCodecVideo.h b/xbmc/cores/hiplayer/HiCodecVideo.h
new file mode 100644
index 0000000000..1cdcfab3ab
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiCodecVideo.h
@@ -0,0 +1,97 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDStreamInfo.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "threads/CriticalSection.h"
+
+#include <atomic>
+#include <set>
+
+class CHisiVdec;
+struct frame_queue;
+struct mpeg2_sequence;
+class CBitstreamParser;
+class CBitstreamConverter;
+
+class CDVDVideoCodecHisi : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecHisi(CProcessInfo& processInfo);
+  virtual ~CDVDVideoCodecHisi();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo& hints, CDVDCodecOptions& options);
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual CDVDVideoCodec::VCReturn GetPicture(VideoPicture* pDvdVideoPicture);
+  virtual bool ClearPicture(VideoPicture* pDvdVideoPicture);
+  virtual void SetSpeed(int iSpeed);
+  virtual void SetDropState(bool bDrop);
+  virtual int GetDataSize(void);
+  virtual double GetTimeSize(void);
+  virtual const char* GetName(void)
+  {
+    return (const char*)m_pFormatName;
+  }
+  virtual bool AddData(const DemuxPacket& packet);
+
+  int Decode(uint8_t* pData, int iSize, double dts, double pts, std::atomic_bool& abort);
+
+  bool PlayStarted();
+
+  bool BufferReady();
+  bool BufferFull();
+  bool IsEOS();
+  void SubmitEOS();
+  void ReSync(double pts);
+  double FirstPts();
+  double GetCurrentPts();
+
+protected:
+  void Dispose(void);
+  void FrameQueuePop(void);
+  void FrameQueuePush(double dts, double pts);
+  void FrameRateTracking(uint8_t* pData, int iSize, double dts, double pts);
+
+  CHisiVdec* m_Codec;
+  const char* m_pFormatName;
+  VideoPicture m_videobuffer;
+  CDVDStreamInfo m_hints;
+  double m_last_pts;
+  frame_queue* m_frame_queue;
+  int32_t m_queue_depth;
+  pthread_mutex_t m_queue_mutex;
+  double m_framerate;
+  int m_video_rate;
+  float m_aspect_ratio;
+  mpeg2_sequence* m_mpeg2_sequence;
+  double m_mpeg2_sequence_pts;
+
+  CBitstreamParser* m_bitparser;
+  std::unique_ptr<CBitstreamConverter> m_bitstream;
+
+  bool m_opened;
+  bool m_drop;
+
+private:
+  CCriticalSection m_secure;
+};
diff --git a/xbmc/cores/hiplayer/HiDecoder.cpp b/xbmc/cores/hiplayer/HiDecoder.cpp
new file mode 100644
index 0000000000..1369e9b9d7
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiDecoder.cpp
@@ -0,0 +1,1461 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiDecoder.h"
+
+#include "cores/VideoPlayer/DVDClock.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+
+#include <functional>
+#include <queue>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <vector>
+
+#include <fcntl.h>
+#include <semaphore.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include "system.h"
+// amcodec include
+
+/*************************************************************************/
+#define __MODULE_NAME__ "DVDCodecHisi"
+
+//#define DEBUG_
+#ifdef DEBUG_
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+    CLog::Log(LOGNOTICE, "HiDec[{}:{}]" fmt, __FUNCTION__, __LINE__, ##args);                      \
+  } while (0)
+#else
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+  } while (0)
+#endif
+#define HISI_INFO(fmt, args...)                                                                    \
+  do                                                                                               \
+  {                                                                                                \
+    CLog::Log(LOGNOTICE, "HiDec[{}:{}]" fmt, __FUNCTION__, __LINE__, ##args);                      \
+  } while (0)
+
+/*************************************************************************/
+
+/*************************************************************************/
+HI_S32 AVEventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara)
+{
+  return HisiAvDecoder::GetInstance()->EventReport(hAvplay, enEvent, pPara);
+}
+
+HisiAvDecoder::HisiAvDecoder()
+{
+  m_disp = HI_UNF_DISPLAY1;
+  m_hAvplay = 0;
+  m_hWin = 0;
+
+  m_opened = false;
+
+  m_audio_opend = false;
+  m_video_opend = false;
+
+  m_audio_full = false;
+  m_video_full = false;
+
+  m_dump = false;
+  m_speed = DVD_PLAYSPEED_NORMAL;
+
+  m_hTrack = 0;
+}
+
+HisiAvDecoder::~HisiAvDecoder()
+{
+}
+
+HisiAvDecoder* HisiAvDecoder::GetInstance()
+{
+  static HisiAvDecoder sHisiAvDecoder;
+  return &sHisiAvDecoder;
+}
+
+bool HisiAvDecoder::Init()
+{
+  CSingleExit lock(m_section);
+
+  if (m_opened)
+    return true;
+
+  HI_UNF_AVPLAY_ATTR_S AvplayAttr;
+  HI_UNF_SYNC_ATTR_S AvSyncAttr;
+
+  if (HI_SYS_Init() != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_SYS_Init exception");
+    goto SYS_DEINIT;
+  }
+
+  if (HIADP_VO_Init(HI_UNF_VO_DEV_MODE_NORMAL) != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_VO_Init exception");
+    goto ADP_VO_DEINIT;
+  }
+
+  if (HI_UNF_AVPLAY_Init() != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_AVPlay_Init exception");
+    goto AVPLAY_DEINIT;
+  }
+
+  if (HIADP_Snd_Init() != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_Snd_Init exception");
+    goto ADP_Snd_Init;
+  }
+
+  if (HIADP_AVPlay_RegADecLib() != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_AVPlay_RegADecLib exception");
+    goto ADP_Snd_Init;
+  }
+
+  if (HI_UNF_AVPLAY_GetDefaultConfig(&AvplayAttr, HI_UNF_AVPLAY_STREAM_TYPE_ES) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_AVPLAY_GetDefaultConfig exception");
+    goto AVPLAY_DEINIT;
+  }
+
+  AvplayAttr.u32DemuxId = 0;
+  AvplayAttr.stStreamAttr.u32AudBufSize = 2 * 1024 * 1024;
+  AvplayAttr.stStreamAttr.u32VidBufSize = 20 * 1024 * 1024;
+
+  if (HI_UNF_AVPLAY_Create(&AvplayAttr, &m_hAvplay) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_AVPLAY_Create exception");
+    goto AVPLAY_DESTROY;
+  }
+
+  for (int AvEvent = (int)HI_UNF_AVPLAY_EVENT_EOS; AvEvent < (int)HI_UNF_AVPLAY_EVENT_BUTT;
+       AvEvent++)
+  {
+    if (HI_UNF_AVPLAY_RegisterEvent64(m_hAvplay, (HI_UNF_AVPLAY_EVENT_E)AvEvent, AVEventReport) !=
+        HI_SUCCESS)
+    {
+      HISI_TRACE("registe avplay AvEvent {} fail!", AvEvent);
+      goto AVPLAY_DESTROY;
+    }
+  }
+
+  if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr) != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_MCE_Exit exception");
+    goto AVPLAY_DESTROY;
+  }
+
+  AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_NONE;
+  if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_AVPLAY_ATTR_ID_SYNC exception");
+    return false;
+  }
+
+  if (HIADP_VO_CreatWin(HI_NULL, &m_hWin) != HI_SUCCESS)
+  {
+    HISI_TRACE("HIADP_VO_CreatWin exception");
+    goto VO_DEINIT;
+  }
+
+  HISI_INFO("HisiAvDecoder::Init success");
+
+  m_video_opend = false;
+  m_audio_opend = false;
+
+  m_opened = true;
+
+  return true;
+
+VO_DEINIT:
+  HI_UNF_VO_DestroyWindow(m_hWin);
+  m_hWin = 0;
+
+AVPLAY_DESTROY:
+  HI_UNF_AVPLAY_Destroy(m_hAvplay);
+  m_hAvplay = 0;
+
+ADP_Snd_Init:
+  HIADP_Snd_DeInit();
+
+AVPLAY_DEINIT:
+  HI_UNF_AVPLAY_DeInit();
+
+ADP_VO_DEINIT:
+  HIADP_VO_DeInit();
+
+SYS_DEINIT:
+  HI_SYS_DeInit();
+
+  m_opened = false;
+  return false;
+}
+
+bool HisiAvDecoder::Deinit()
+{
+  CSingleExit lock(m_section);
+
+  if (m_video_opend || m_audio_opend)
+    return false;
+
+  for (int AvEvent = (int)HI_UNF_AVPLAY_EVENT_EOS; AvEvent < (int)HI_UNF_AVPLAY_EVENT_BUTT;
+       AvEvent++)
+  {
+    HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, (HI_UNF_AVPLAY_EVENT_E)AvEvent);
+  }
+
+  if (m_hWin)
+  {
+    HI_UNF_VO_DestroyWindow(m_hWin);
+    m_hWin = 0;
+  }
+
+  if (m_hAvplay)
+  {
+    HI_UNF_AVPLAY_Destroy(m_hAvplay);
+    m_hAvplay = 0;
+  }
+
+  HI_UNF_AVPLAY_DeInit();
+  HIADP_Snd_DeInit();
+
+  HI_SYS_DeInit();
+
+  m_opened = false;
+
+  HISI_TRACE("Deinit Success");
+
+  return true;
+}
+
+bool HisiAvDecoder::AudioOpen(CDVDStreamInfo& hints)
+{
+  Init();
+
+  CSingleExit lock(m_section);
+
+  int ret;
+  HA_CODEC_ID_E AdecType = codec2adec(hints.codec);
+  HI_UNF_AUDIOTRACK_ATTR_S stTrackAttr;
+  HI_UNF_ACODEC_ATTR_S AdecAttr;
+
+  if (HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_AVPLAY_ChnOpen audio exception");
+    goto ACHN_CLOSE;
+  }
+
+  if (HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_MASTER, &stTrackAttr) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_SND_TRACK_TYPE_MASTER exception");
+    goto ACHN_CLOSE;
+  }
+
+  if (HI_UNF_SND_CreateTrack(HI_UNF_SND_0, &stTrackAttr, &m_hTrack) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_SND_CreateTrack exception");
+    goto TRACK_DESTORY;
+  }
+
+  if (HI_UNF_SND_Attach(m_hTrack, m_hAvplay) != HI_SUCCESS)
+  {
+    HISI_TRACE("HI_UNF_SND_Attach exception");
+    goto TRACK_DETATCH;
+  }
+
+  if (hints.codecOptions & CODEC_FORCE_SOFTWARE)
+  {
+    HISI_TRACE("AudioOpen set as software pcm mode");
+
+    WAV_FORMAT_S stWavFormat;
+
+    stWavFormat.nChannels = 2;
+    stWavFormat.nSamplesPerSec = hints.samplerate;
+    stWavFormat.wBitsPerSample = 16;
+
+    m_audio_bytes_pes_sec = hints.samplerate * 16 * 2 >> 3;
+
+    if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr) != HI_SUCCESS)
+    {
+      HISI_TRACE("Get HI_UNF_AVPLAY_ATTR_ID_ADEC exception");
+      goto TRACK_DETATCH;
+    }
+
+    AdecAttr.enType = HA_AUDIO_ID_PCM;
+    HA_PCM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), &stWavFormat);
+
+    AdecAttr.stDecodeParam.sPcmformat.u32DesiredOutChannels = 2;
+    AdecAttr.stDecodeParam.sPcmformat.u32BitPerSample = 16;
+    AdecAttr.stDecodeParam.sPcmformat.u32DesiredSampleRate = hints.samplerate;
+
+    HISI_TRACE("AdecAttr Set sample rate: {}", hints.samplerate);
+
+    if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr) != HI_SUCCESS)
+    {
+      HISI_TRACE("Set HI_UNF_AVPLAY_ATTR_ID_ADEC exception");
+      goto TRACK_DETATCH;
+    }
+  }
+  else
+  {
+    switch (hints.codec)
+    {
+      case AV_CODEC_ID_AC3:
+        AdecType = HA_AUDIO_ID_AC3PASSTHROUGH;
+        break;
+      case AV_CODEC_ID_EAC3:
+        AdecType = HA_AUDIO_ID_AC3PASSTHROUGH;
+        break;
+      case AV_CODEC_ID_DTS:
+        AdecType = HA_AUDIO_ID_DTSPASSTHROUGH;
+        break;
+      case AV_CODEC_ID_TRUEHD:
+        AdecType = HA_AUDIO_ID_TRUEHD;
+        break;
+      default:
+        break;
+    }
+
+    HISI_TRACE("passthrough start, code :{}", hints.codec);
+    ret = HIADP_AVPlay_SetAdecAttr(m_hAvplay, AdecType, HD_DEC_MODE_THRU, 0);
+    if (ret != HI_SUCCESS)
+    {
+      HISI_TRACE("HIADP_AVPlay_SetAdecAttr exception");
+      goto TRACK_DETATCH;
+    }
+
+    ret =
+        HI_UNF_SND_SetHdmiMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, HI_UNF_SND_HDMI_MODE_RAW);
+    if (ret != HI_SUCCESS)
+    {
+      HISI_TRACE("call HI_UNF_SND_SetHdmiMode failed.");
+      goto TRACK_DETATCH;
+    }
+    ret = HI_UNF_SND_SetSpdifMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_SPDIF0,
+                                  HI_UNF_SND_SPDIF_MODE_RAW);
+    if (ret != HI_SUCCESS)
+    {
+      HISI_TRACE("call HI_UNF_SND_SetSpdifMode failed.");
+      goto TRACK_DETATCH;
+    }
+  }
+
+  HI_UNF_SYNC_ATTR_S AvSyncAttr;
+  HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+  AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_AUDIO;
+  AvSyncAttr.stSyncStartRegion.s32VidPlusTime = 60;
+  AvSyncAttr.stSyncStartRegion.s32VidNegativeTime = -20;
+  AvSyncAttr.u32PreSyncTimeoutMs = 1000;
+  AvSyncAttr.bQuickOutput = HI_FALSE;
+  HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+
+  ret = HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+  if (ret != HI_SUCCESS)
+  {
+    HISI_TRACE("AUD HI_UNF_AVPLAY_Start exception:{}", ret);
+    goto AVPLAY_ASTOP;
+  }
+
+  HISI_TRACE("OpenAudio Success, Bps :{}", m_audio_bytes_pes_sec);
+
+  m_audio_opend = true;
+  m_audio_full = false;
+  m_audio_eos = false;
+  m_audio_ready = false;
+  m_audio_1st_pts = DVD_NOPTS_VALUE;
+  m_audio_play_started = false;
+
+  m_aptsQueue.clear();
+
+  return true;
+
+AVPLAY_ASTOP:
+  HI_UNF_AVPLAY_STOP_OPT_S Stop;
+  Stop.u32TimeoutMs = 0;
+  Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+  HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+
+TRACK_DETATCH:
+  HI_UNF_SND_Detach(m_hTrack, m_hAvplay);
+
+TRACK_DESTORY:
+  HI_UNF_SND_DestroyTrack(m_hTrack);
+  m_hTrack = 0;
+
+ACHN_CLOSE:
+  HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD);
+  return false;
+}
+
+bool HisiAvDecoder::AudioClose()
+{
+  {
+    CSingleExit lock(m_section);
+
+    if (!m_hTrack)
+      return false;
+
+    HI_UNF_AVPLAY_STOP_OPT_S Stop;
+    Stop.u32TimeoutMs = 0;
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+
+    if (HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop) != HI_SUCCESS)
+    {
+      HISI_TRACE("HI_UNF_AVPLAY_Stop");
+      return false;
+    }
+
+    HISI_TRACE("CloseAudio, track {}", m_hTrack);
+    if (HI_UNF_SND_Detach(m_hTrack, m_hAvplay) != HI_SUCCESS)
+    {
+      HISI_TRACE("HI_UNF_SND_Detach AdecType exception");
+      return false;
+    }
+
+    if (HI_UNF_SND_DestroyTrack(m_hTrack) != HI_SUCCESS)
+    {
+      HISI_TRACE("HI_UNF_SND_DestroyTrack exception");
+      return false;
+    }
+
+    m_hTrack = 0;
+
+    if (HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD) != HI_SUCCESS)
+    {
+      HISI_TRACE("HI_UNF_SND_DestroyTrack exception");
+      return false;
+    }
+
+    HI_UNF_SYNC_ATTR_S AvSyncAttr;
+    HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+    AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_NONE;
+    HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+
+    AudioReset();
+
+    m_audio_opend = false;
+
+    HISI_TRACE("CloseAudio Success");
+  }
+
+  return true;
+}
+
+void HisiAvDecoder::AudioReset()
+{
+  m_audio_full = false;
+  m_audio_eos = false;
+  m_audio_1st_pts = DVD_NOPTS_VALUE;
+  m_audio_play_started = false;
+  m_audio_ready = false;
+
+  m_aptsQueue.clear();
+
+  HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+
+  HISI_INFO("HisiAvDecoder::AudioReset");
+}
+
+void HisiAvDecoder::AudioReSync(unsigned int ms)
+{
+  return;
+
+  HI_UNF_AVPLAY_RESET_OPT_S opt;
+  opt.u32SeekPtsMs = (HI_U32)ms;
+
+  HI_UNF_AVPLAY_Reset(m_hAvplay, &opt);
+}
+
+double HisiAvDecoder::AudioFirstPts()
+{
+  CSingleExit lock(m_EventMutex);
+
+  if (!m_audio_opend)
+    return false;
+
+  if (m_aptsQueue.size() > 0 && m_audio_1st_pts != DVD_NOPTS_VALUE)
+  {
+    return m_audio_1st_pts;
+  }
+
+  return DVD_NOPTS_VALUE;
+}
+
+double HisiAvDecoder::AudioCurrentPts()
+{
+  if (!m_audio_opend)
+    return DVD_NOPTS_VALUE;
+
+  double pts = DVD_NOPTS_VALUE;
+  HI_UNF_AVPLAY_STATUS_INFO_S av_status;
+  if (HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &av_status) == HI_SUCCESS)
+  {
+    pts = (double)PTS_MS_TO_US(av_status.stSyncStatus.u32LastAudPts);
+  }
+
+  //HISI_TRACE("AudioGetPts %f!", pts);
+  return pts;
+}
+
+bool HisiAvDecoder::AudioPlayStarted()
+{
+  return m_audio_play_started;
+}
+
+bool HisiAvDecoder::AudioBufferReady()
+{
+  return m_audio_ready && m_video_ready;
+}
+
+bool HisiAvDecoder::AudioBufferFull()
+{
+  return m_audio_full;
+}
+
+bool HisiAvDecoder::AudioWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms)
+{
+  CSingleExit lock(m_section);
+
+  if (!m_audio_opend)
+    return false;
+
+  m_audio_last_package_pts = pts_ms;
+
+  HI_UNF_STREAM_BUF_S StreamBuf;
+  if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, &StreamBuf, 0) !=
+      HI_SUCCESS)
+    return false;
+
+  memcpy(StreamBuf.pu8Data, pData, iSize);
+
+  if (HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, pts_ms) != HI_SUCCESS)
+    return false;
+
+  //HISI_TRACE("WriteAudioPackage size:{}, ms:{}",iSize, pts_ms);
+
+  return true;
+}
+
+bool HisiAvDecoder::AudioWriteEx(
+    uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last)
+{
+  CSingleExit lock(m_section);
+
+  if (!m_audio_opend)
+    return false;
+
+  m_audio_last_package_pts = pts_ms;
+
+  HI_UNF_STREAM_BUF_S StreamBuf;
+  if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, &StreamBuf, 0) !=
+      HI_SUCCESS)
+    return false;
+
+  memcpy(StreamBuf.pu8Data, pData, iSize);
+
+  HI_UNF_AVPLAY_PUTBUFEX_OPT_S stExOpt;
+  stExOpt.bContinue = continues ? HI_FALSE : HI_TRUE;
+  stExOpt.bEndOfFrm = last ? HI_FALSE : HI_TRUE;
+  if (HI_UNF_AVPLAY_PutBufEx(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, pts_ms, &stExOpt) !=
+      HI_SUCCESS)
+  {
+    //HISI_TRACE("Putbuf Audio error!!!");
+    return false;
+  }
+
+  //HISI_TRACE("WriteAudioPackageEx size:{}, ms:{}",iSize, pts_ms);
+  return true;
+}
+
+double HisiAvDecoder::AudioCacheTotal()
+{
+  return m_audio_cache_total / DVD_TIME_BASE * 1000.0;
+}
+
+double HisiAvDecoder::AudioCachetime()
+{
+  return m_audio_cache_time / DVD_TIME_BASE * 1000.0;
+}
+
+double HisiAvDecoder::AudioDelay()
+{
+  int cur = 0;
+  if (m_aptsQueue.size() > 0)
+    cur = m_aptsQueue.front();
+  else
+    return m_audio_cache_time / DVD_TIME_BASE * 1000.0;
+
+  HISI_TRACE("AudioDelay :{} - {}", m_audio_last_package_pts, cur);
+
+  return (m_audio_last_package_pts - cur) / DVD_TIME_BASE * 1000.0;
+}
+
+void HisiAvDecoder::AudioSubmitEOS()
+{
+  if (m_audio_eos)
+    return;
+
+  HISI_TRACE("Hisi Audio submit eos.");
+
+  m_audio_eos = true;
+  SubmitEOS();
+}
+
+bool HisiAvDecoder::VideoOpen(CDVDStreamInfo& hints)
+{
+  Init();
+
+  if (m_video_opend)
+    VideoClose();
+
+  CSingleExit lock(m_section);
+
+  HISI_TRACE("HisiAvDecoder::OpenVideo");
+
+  HI_UNF_VCODEC_TYPE_E VdecType = codec2vdec(hints.codec);
+
+  HI_UNF_AVPLAY_OPEN_OPT_S* pMaxCapbility = HI_NULL;
+  HI_UNF_AVPLAY_OPEN_OPT_S stMaxCapbility;
+
+  if (HI_UNF_VCODEC_TYPE_MVC == VdecType)
+  {
+    stMaxCapbility.enCapLevel = HI_UNF_VCODEC_CAP_LEVEL_FULLHD;
+    stMaxCapbility.enDecType = HI_UNF_VCODEC_DEC_TYPE_BUTT;
+    stMaxCapbility.enProtocolLevel = HI_UNF_VCODEC_PRTCL_LEVEL_MVC;
+    pMaxCapbility = &stMaxCapbility;
+  }
+
+  if (HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, pMaxCapbility) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_AVPLAY_ChnOpen exception");
+    goto VCHN_CLOSE;
+  }
+
+  HI_UNF_VCODEC_ATTR_S VcodecAttr;
+  if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_AVPLAY_GetAttr exception");
+    goto VCHN_CLOSE;
+  }
+
+  if (HI_UNF_VCODEC_TYPE_VC1 == VdecType)
+  {
+    VcodecAttr.unExtAttr.stVC1Attr.bAdvancedProfile =
+        (FF_PROFILE_VC1_ADVANCED == hints.profile) ? HI_TRUE : HI_FALSE;
+    VcodecAttr.unExtAttr.stVC1Attr.u32CodecVersion = 8;
+
+    HISI_INFO("stVC1Attr bAdvancedProfile {}, version:{}",
+              VcodecAttr.unExtAttr.stVC1Attr.bAdvancedProfile,
+              VcodecAttr.unExtAttr.stVC1Attr.u32CodecVersion);
+  }
+
+  if (HI_UNF_VCODEC_TYPE_VP6 == VdecType)
+  {
+    VcodecAttr.unExtAttr.stVP6Attr.bReversed = HI_FALSE;
+  }
+
+  VcodecAttr.enType = VdecType;
+  if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_AVPLAY_ChnOpen exception");
+    goto VCHN_CLOSE;
+  }
+
+  if (HI_UNF_VO_AttachWindow(m_hWin, m_hAvplay) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_VO_AttachWindow exception");
+    goto WIN_DETATCH;
+  }
+
+  if (HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_VO_SetWindowEnable exception");
+    goto WIN_DETATCH;
+  }
+
+  if (HIADP_AVPlay_SetVdecAttr(m_hAvplay, VdecType, HI_UNF_VCODEC_MODE_NORMAL) != HI_SUCCESS)
+  {
+    HISI_INFO("HIADP_AVPlay_SetVdecAttr exception");
+    goto WIN_DETATCH;
+  }
+
+  //if (hints.fpsrate > 0 && hints.fpsscale != 0)
+  {
+    HI_UNF_AVPLAY_FRMRATE_PARAM_S stFramerate;
+    HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM, &stFramerate);
+    stFramerate.enFrmRateType = HI_UNF_AVPLAY_FRMRATE_TYPE_PTS;
+    stFramerate.stSetFrmRate.u32fpsInteger = 0;
+    stFramerate.stSetFrmRate.u32fpsDecimal = 0;
+    HISI_INFO("HI_UNF_AVPLAY_SetAttr , frame rate : {}.{}", stFramerate.stSetFrmRate.u32fpsInteger,
+              stFramerate.stSetFrmRate.u32fpsDecimal);
+    if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM, &stFramerate) !=
+        HI_SUCCESS)
+    {
+      HISI_TRACE("HI_UNF_AVPLAY_SetAttr exception, frame rate {}.{}",
+                 stFramerate.stSetFrmRate.u32fpsInteger, stFramerate.stSetFrmRate.u32fpsDecimal);
+      goto WIN_DETATCH;
+    }
+  }
+
+  if (HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, HI_NULL) != HI_SUCCESS)
+  {
+    HISI_INFO("HI_UNF_AVPLAY_Start exception");
+    goto AVPLAY_VSTOP;
+  }
+
+  HISI_INFO("Open Video success");
+
+  m_video_opend = true;
+  m_video_full = false;
+  m_video_eos = false;
+  m_video_1st_pts = DVD_NOPTS_VALUE;
+  m_video_play_started = false;
+  m_video_ready = false;
+  m_vptsQueue.clear();
+
+  return true;
+
+AVPLAY_VSTOP:
+  HI_UNF_AVPLAY_STOP_OPT_S Stop;
+  Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+  Stop.u32TimeoutMs = 0;
+  HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &Stop);
+
+WIN_DETATCH:
+  HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+  HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay);
+
+VCHN_CLOSE:
+  HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID);
+
+  return false;
+}
+
+bool HisiAvDecoder::VideoClose()
+{
+  {
+    CSingleExit lock(m_section);
+
+    HISI_INFO("HisiAvDecoder::CloseVideo");
+
+    if (m_video_opend == false)
+      return false;
+
+    HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+    if (HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) != HI_SUCCESS)
+    {
+      HISI_INFO("HI_UNF_AVPLAY_GetStatusInfo exception");
+      return false;
+    }
+
+    if (stStatusInfo.enRunStatus == HI_UNF_AVPLAY_STATUS_PAUSE)
+    {
+      if (HI_UNF_AVPLAY_Resume(m_hAvplay, HI_NULL) != HI_SUCCESS)
+      {
+        HISI_INFO("HI_UNF_AVPLAY_Resume exception");
+        return false;
+      }
+    }
+
+    HI_UNF_AVPLAY_STOP_OPT_S Stop;
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    if (HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &Stop) != HI_SUCCESS)
+    {
+      HISI_INFO("HI_UNF_AVPLAY_Stop exception");
+      return false;
+    }
+
+    if (HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE) != HI_SUCCESS)
+    {
+      HISI_INFO("HI_UNF_VO_SetWindowEnable exception");
+      return false;
+    }
+
+    if (HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay) != HI_SUCCESS)
+    {
+      HISI_INFO("HI_UNF_VO_DetachWindow exception");
+      return false;
+    }
+
+    if (HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID) != HI_SUCCESS)
+    {
+      HISI_INFO("HI_UNF_AVPLAY_ChnClose exception");
+      return false;
+    }
+
+    VideoReset();
+
+    m_video_opend = false;
+    m_video_eos = true;
+    m_vptsQueue.clear();
+  }
+
+  return true;
+}
+
+void HisiAvDecoder::VideoReset()
+{
+  m_video_full = false;
+  m_video_eos = false;
+  m_video_1st_pts = DVD_NOPTS_VALUE;
+  m_video_play_started = false;
+  m_video_ready = false;
+
+  m_vptsQueue.clear();
+
+  HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+
+  HI_BOOL bIsEmpty = HI_FALSE;
+  HI_UNF_AVPLAY_IsBuffEmpty(m_hAvplay, &bIsEmpty);
+
+  HISI_TRACE("HisiAvDecoder::VideoReset , check buffer empty:{}", bIsEmpty);
+}
+
+void HisiAvDecoder::VideoReSync(unsigned int ms)
+{
+  return;
+
+  HI_UNF_AVPLAY_RESET_OPT_S opt;
+  opt.u32SeekPtsMs = (HI_U32)ms;
+
+  HI_UNF_AVPLAY_Reset(m_hAvplay, &opt);
+
+  CLog::Log(LOGDEBUG, "HisiAvDecoder::VideoReSync ({})", ms);
+}
+
+void HisiAvDecoder::VideoSetSpeed(int speed)
+{
+  // of if we are open or not.
+  CLog::Log(LOGNOTICE, "HisiAvDecoder::SetSpeed ({})", speed);
+  HI_S32 ret = 0;
+
+  if (!m_opened)
+    return;
+
+  if (speed == m_speed)
+    return;
+
+  switch (speed)
+  {
+    case DVD_PLAYSPEED_PAUSE:
+      CLog::Log(LOGDEBUG, "HisiAvDecoder speed do pause");
+
+      //if (m_mode == VIDEO_MODE_FORWARD ||m_mode == VIDEO_MODE_BACKWARD)
+      //	HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+
+      m_mode = VIDEO_MODE_PAUSE;
+      HI_UNF_AVPLAY_Pause(m_hAvplay, NULL);
+      //HI_UNF_AVPLAY_SetDecodeMode(m_hAvplay, HI_UNF_VCODEC_MODE_NORMAL);
+      m_speed = speed;
+      break;
+    case DVD_PLAYSPEED_NORMAL:
+      CLog::Log(LOGDEBUG, "HisiAvDecoder speed do normal");
+
+      //if (m_mode == VIDEO_MODE_FORWARD ||m_mode == VIDEO_MODE_BACKWARD)
+      //HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+
+      m_mode = VIDEO_MODE_NORMAL;
+      //HI_UNF_AVPLAY_SetDecodeMode(m_hAvplay, HI_UNF_VCODEC_MODE_NORMAL);
+      ret = HI_UNF_AVPLAY_Resume(m_hAvplay, NULL);
+      CLog::Log(LOGDEBUG, "HisiAvDecoder speed do normal ret:{}", ret);
+      m_speed = speed;
+      break;
+    default:
+      break;
+
+      HI_UNF_AVPLAY_TPLAY_OPT_S stTplayOpt;
+      if (speed > 0 && speed <= 32)
+      {
+        //CLog::Log(LOGDEBUG, "CHisiCodec::SetSpeed goes forward, speed:{}", speed);
+        stTplayOpt.enTplayDirect = HI_UNF_AVPLAY_TPLAY_DIRECT_FORWARD;
+        if (m_mode != VIDEO_MODE_FORWARD)
+          HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+        m_mode = VIDEO_MODE_FORWARD;
+      }
+      else if (speed < 0 && speed >= -32)
+      {
+        //CLog::Log(LOGDEBUG, "CHisiCodec::SetSpeed goes backward, speed:{}", speed);
+        stTplayOpt.enTplayDirect = HI_UNF_AVPLAY_TPLAY_DIRECT_BACKWARD;
+        speed = -speed;
+        if (m_mode != VIDEO_MODE_BACKWARD)
+          HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+        m_mode = VIDEO_MODE_BACKWARD;
+      }
+      else
+        break;
+
+      m_speed = speed;
+      stTplayOpt.u32SpeedInteger = speed;
+      stTplayOpt.u32SpeedDecimal = 0;
+      HI_UNF_AVPLAY_SetDecodeMode(m_hAvplay, HI_UNF_VCODEC_MODE_I);
+      HI_UNF_AVPLAY_Tplay(m_hAvplay, &stTplayOpt);
+      break;
+  }
+}
+
+double HisiAvDecoder::VideoCurrentPts()
+{
+  if (!m_opened)
+    return DVD_NOPTS_VALUE;
+
+  double pts = DVD_NOPTS_VALUE;
+  HI_UNF_AVPLAY_STATUS_INFO_S av_status;
+  if (HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &av_status) == HI_SUCCESS)
+  {
+    pts = (double)PTS_MS_TO_US(av_status.stSyncStatus.u32LastVidPts);
+  }
+
+  return pts;
+}
+
+bool HisiAvDecoder::VideoPlayStarted()
+{
+  return m_video_play_started;
+}
+
+bool HisiAvDecoder::VideoFramePts(int& pts)
+{
+  CSingleExit lock(m_EventMutex);
+
+  if (m_vptsQueue.size() != 0)
+  {
+    pts = m_vptsQueue.front();
+    m_vptsQueue.pop_front();
+    return true;
+  }
+
+  return false;
+}
+
+double HisiAvDecoder::VideoFirstPts()
+{
+  if (!m_video_opend)
+    return false;
+
+  if (m_vptsQueue.size() > 0 && m_video_1st_pts != DVD_NOPTS_VALUE)
+  {
+    return m_video_1st_pts;
+  }
+
+  return DVD_NOPTS_VALUE;
+}
+
+bool HisiAvDecoder::VideoBufferFull()
+{
+  return m_video_full;
+}
+
+bool HisiAvDecoder::VideoBufferReady()
+{
+  return m_audio_ready && m_video_ready;
+}
+
+bool HisiAvDecoder::VideoWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms)
+{
+  if (!m_video_opend)
+    return false;
+
+  HI_UNF_STREAM_BUF_S StreamBuf;
+  if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, &StreamBuf, 0) !=
+      HI_SUCCESS)
+  {
+    //HISI_TRACE("Getbuf Audio full!!!");
+    return false;
+  }
+
+  memcpy(StreamBuf.pu8Data, pData, iSize);
+
+  if (HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, pts_ms) != HI_SUCCESS)
+  {
+    //HISI_TRACE("Putbuf Audio error!!!");
+    return false;
+  }
+
+  //HISI_TRACE("WriteVideoPackage size:{}, ms:{}",iSize, pts_ms);
+
+  return true;
+}
+
+bool HisiAvDecoder::VideoWriteEx(
+    uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last)
+{
+  if (!m_video_opend)
+    return false;
+
+  HI_UNF_STREAM_BUF_S StreamBuf;
+  if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, &StreamBuf, 0) !=
+      HI_SUCCESS)
+  {
+    //HISI_TRACE("Getbuf Audio full!!!");
+    return false;
+  }
+
+  memcpy(StreamBuf.pu8Data, pData, iSize);
+
+  HI_UNF_AVPLAY_PUTBUFEX_OPT_S stExOpt;
+  stExOpt.bContinue = continues ? HI_FALSE : HI_TRUE;
+  stExOpt.bEndOfFrm = last ? HI_FALSE : HI_TRUE;
+  if (HI_UNF_AVPLAY_PutBufEx(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, pts_ms, &stExOpt) !=
+      HI_SUCCESS)
+  {
+    //HISI_TRACE("Putbuf Audio error!!!");
+    return false;
+  }
+
+  //HISI_TRACE("WriteVideoPackageEx size:{}, ms:{}",iSize, pts_ms);
+  return true;
+}
+
+void HisiAvDecoder::VideoSubmitEOS()
+{
+  if (m_video_eos)
+    return;
+
+  HISI_TRACE("Hisi Video submit eos.");
+
+  m_video_eos = true;
+  SubmitEOS();
+}
+
+void HisiAvDecoder::VideoSetRect(int x, int y, int width, int height)
+{
+  CLog::Log(LOGINFO, "Hisi Video VideoSetRect {} {} {} {}.", x, y, width, height);
+
+  HI_UNF_WINDOW_ATTR_S attrs;
+  if (HI_UNF_VO_GetWindowAttr(m_hWin, &attrs) != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "HI_UNF_VO_GetWindowAttr error");
+    return;
+  }
+
+  attrs.stOutputRect.s32X = x;
+  attrs.stOutputRect.s32Y = y;
+  attrs.stOutputRect.s32Width = width;
+  attrs.stOutputRect.s32Height = height;
+  if (HI_UNF_VO_SetWindowAttr(m_hWin, &attrs) != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "HI_UNF_VO_GetWindowAttr error");
+    return;
+  }
+}
+
+bool HisiAvDecoder::IsEOS()
+{
+  if (((m_audio_opend && m_audio_eos) || !m_audio_opend) &&
+      ((m_video_opend && m_video_eos) || !m_video_opend))
+  {
+    HI_BOOL bIsEmpty = HI_FALSE;
+    HI_UNF_AVPLAY_IsBuffEmpty(m_hAvplay, &bIsEmpty);
+
+    HISI_TRACE("IsEOS , check buffer empty:{}", bIsEmpty);
+
+    if (bIsEmpty != HI_FALSE)
+      return m_eos;
+  }
+
+  return false;
+}
+
+void HisiAvDecoder::SubmitEOS()
+{
+  m_eos = false;
+  if (((m_audio_opend && m_audio_eos) || !m_audio_opend) &&
+      ((m_video_opend && m_video_eos) || !m_video_opend))
+  {
+    HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S stFlushOpt;
+    HI_UNF_AVPLAY_FlushStream(m_hAvplay, &stFlushOpt);
+
+    HISI_TRACE("Hisi eos , flush stream.");
+  }
+}
+
+HA_CODEC_ID_E HisiAvDecoder::codec2adec(int enc)
+{
+  switch (enc)
+  {
+    case AV_CODEC_ID_PCM_BLURAY:
+      return HA_AUDIO_ID_BLYRAYLPCM;
+
+    case AV_CODEC_ID_PCM_S16LE ... AV_CODEC_ID_PCM_F64LE:
+    case AV_CODEC_ID_PCM_LXF ... AV_CODEC_ID_PCM_S16BE_PLANAR:
+      return HA_AUDIO_ID_PCM;
+
+    case AV_CODEC_ID_ADPCM_IMA_QT ... AV_CODEC_ID_ADPCM_G726LE:
+      return HA_AUDIO_ID_ADPCM;
+
+    case AV_CODEC_ID_AMR_NB ... AV_CODEC_ID_SOL_DPCM:
+      return HA_AUDIO_ID_AMRNB;
+
+    case AV_CODEC_ID_MP2:
+      return HA_AUDIO_ID_MP2;
+
+    case AV_CODEC_ID_MP3:
+    case AV_CODEC_ID_MP3ADU:
+    case AV_CODEC_ID_MP3ON4:
+      return HA_AUDIO_ID_MP3;
+
+    case AV_CODEC_ID_AAC:
+      return HA_AUDIO_ID_AAC;
+
+    case AV_CODEC_ID_AC3:
+      return HA_AUDIO_ID_CUSTOM_0;
+
+    case AV_CODEC_ID_DTS:
+      return HA_AUDIO_ID_DTSHD;
+
+    case AV_CODEC_ID_WMAV1:
+    case AV_CODEC_ID_WMAV2:
+      return HA_AUDIO_ID_WMA9STD;
+
+    case AV_CODEC_ID_COOK:
+      return HA_AUDIO_ID_COOK;
+
+    case AV_CODEC_ID_VORBIS:
+      return HA_AUDIO_ID_VORBIS;
+
+    //case AV_CODEC_ID_TRUEHD:
+    //return HA_AUDIO_ID_CUSTOM_3;
+    default:
+      return HA_AUDIO_ID_MP3;
+  }
+
+  return HA_AUDIO_ID_MP3;
+}
+
+HI_UNF_VCODEC_TYPE_E HisiAvDecoder::codec2vdec(int enc)
+{
+  switch (enc)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      return HI_UNF_VCODEC_TYPE_MPEG2;
+    case AV_CODEC_ID_MPEG4:
+      return HI_UNF_VCODEC_TYPE_MPEG4; /**<MPEG4 DIVX4 DIVX5 */
+    case AV_CODEC_ID_AVS:
+      return HI_UNF_VCODEC_TYPE_AVS;
+    case AV_CODEC_ID_H263:
+      return HI_UNF_VCODEC_TYPE_H263;
+    case AV_CODEC_ID_H264:
+      return HI_UNF_VCODEC_TYPE_H264;
+    case AV_CODEC_ID_RV30:
+      return HI_UNF_VCODEC_TYPE_REAL8;
+    case AV_CODEC_ID_RV40:
+      return HI_UNF_VCODEC_TYPE_REAL9;
+    case AV_CODEC_ID_VC1:
+      return HI_UNF_VCODEC_TYPE_VC1;
+    case AV_CODEC_ID_VP6:
+      return HI_UNF_VCODEC_TYPE_VP6;
+    case AV_CODEC_ID_VP6F:
+      return HI_UNF_VCODEC_TYPE_VP6F;
+    case AV_CODEC_ID_VP6A:
+      return HI_UNF_VCODEC_TYPE_VP6A;
+    case AV_CODEC_ID_MJPEG:
+      return HI_UNF_VCODEC_TYPE_MJPEG;
+    case AV_CODEC_ID_FLV1:
+      return HI_UNF_VCODEC_TYPE_SORENSON; /**<SORENSON SPARK */
+    case AV_CODEC_ID_MSMPEG4V3:
+      return HI_UNF_VCODEC_TYPE_DIVX3;
+    case AV_CODEC_ID_RAWVIDEO:
+      return HI_UNF_VCODEC_TYPE_RAW;
+    case AV_CODEC_ID_LJPEG:
+    case AV_CODEC_ID_JPEG2000:
+      return HI_UNF_VCODEC_TYPE_JPEG; /**<Used only for VENC */
+    case AV_CODEC_ID_VP8:
+      return HI_UNF_VCODEC_TYPE_VP8;
+    case AV_CODEC_ID_MSMPEG4V1:
+      return HI_UNF_VCODEC_TYPE_MSMPEG4V1; /**<MS private MPEG4 */
+    case AV_CODEC_ID_MSMPEG4V2:
+      return HI_UNF_VCODEC_TYPE_MSMPEG4V2;
+    case AV_CODEC_ID_MSVIDEO1:
+      return HI_UNF_VCODEC_TYPE_MSVIDEO1; /**<MS video */
+    case AV_CODEC_ID_WMV1:
+      return HI_UNF_VCODEC_TYPE_WMV1;
+    case AV_CODEC_ID_WMV2:
+      return HI_UNF_VCODEC_TYPE_WMV2;
+    case AV_CODEC_ID_RV10:
+      return HI_UNF_VCODEC_TYPE_RV10;
+    case AV_CODEC_ID_RV20:
+      return HI_UNF_VCODEC_TYPE_RV20;
+    case AV_CODEC_ID_SVQ1:
+      return HI_UNF_VCODEC_TYPE_SVQ1; /**<Apple video */
+    case AV_CODEC_ID_SVQ3:
+      return HI_UNF_VCODEC_TYPE_SVQ3; /**<Apple video */
+    case AV_CODEC_ID_H261:
+      return HI_UNF_VCODEC_TYPE_H261;
+    case AV_CODEC_ID_VP3:
+      return HI_UNF_VCODEC_TYPE_VP3;
+    case AV_CODEC_ID_VP5:
+      return HI_UNF_VCODEC_TYPE_VP5;
+    case AV_CODEC_ID_CINEPAK:
+      return HI_UNF_VCODEC_TYPE_CINEPAK;
+    case AV_CODEC_ID_INDEO2:
+      return HI_UNF_VCODEC_TYPE_INDEO2;
+    case AV_CODEC_ID_INDEO3:
+      return HI_UNF_VCODEC_TYPE_INDEO3;
+    case AV_CODEC_ID_INDEO4:
+      return HI_UNF_VCODEC_TYPE_INDEO4;
+    case AV_CODEC_ID_INDEO5:
+      return HI_UNF_VCODEC_TYPE_INDEO5;
+    case AV_CODEC_ID_MJPEGB:
+      return HI_UNF_VCODEC_TYPE_MJPEGB;
+    case AV_CODEC_ID_KMVC:
+      return HI_UNF_VCODEC_TYPE_MVC;
+    case AV_CODEC_ID_HEVC:
+      return HI_UNF_VCODEC_TYPE_HEVC;
+    case AV_CODEC_ID_DVVIDEO:
+      return HI_UNF_VCODEC_TYPE_DV;
+    case AV_CODEC_ID_VP9:
+      return HI_UNF_VCODEC_TYPE_VP9;
+    case AV_CODEC_ID_CAVS:
+      return HI_UNF_VCODEC_TYPE_AVS2;
+    default:
+      break;
+  }
+
+  return HI_UNF_VCODEC_TYPE_BUTT;
+}
+
+HI_S32 HisiAvDecoder::EventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara)
+{
+  CSingleExit lock(m_EventMutex);
+
+  switch (enEvent)
+  {
+    /**<The end of stream (EOS) operation is performed, NULL*/
+    case HI_UNF_AVPLAY_EVENT_EOS:
+      HISI_TRACE("HI_UNF_AVPLAY_EVENT_EOS.");
+      m_eos = true;
+      break;
+    /**<The stop operation is performed, NULL*/
+    case HI_UNF_AVPLAY_EVENT_STOP: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_STOP");
+      break;
+    /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*/
+    case HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE");
+    {
+      HI_UNF_AVPLAY_BUF_STATE_E* state = (HI_UNF_AVPLAY_BUF_STATE_E*)pPara;
+      //HISI_TRACE("buff level: {}", (int)(*state));
+    }
+    break;
+    /**<Standard switch, HI_UNF_NORMCHANGE_PARAM_S*/
+    case HI_UNF_AVPLAY_EVENT_NORM_SWITCH: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_NORM_SWITCH");
+      break;
+    /**<3D Frame packing change, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E*/
+    case HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE");
+      break;
+    /**<New video frame, HI_UNF_VIDEO_FRAME_INFO_S*/
+    case HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME:
+    {
+      HI_UNF_VIDEO_FRAME_INFO_S* frame = (HI_UNF_VIDEO_FRAME_INFO_S*)pPara;
+      if (m_vptsQueue.empty())
+        m_video_1st_pts = (double)PTS_MS_TO_US(frame->u32Pts);
+
+      m_vptsQueue.push_back(frame->u32Pts);
+
+      //HISI_TRACE("HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME, pts :{}", frame->u32Pts);
+    }
+    break;
+    /**<New audio frame, HI_UNF_AO_FRAMEINFO_S*/
+    case HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME:
+    {
+      HI_UNF_AO_FRAMEINFO_S* frame = (HI_UNF_AO_FRAMEINFO_S*)pPara;
+      if (m_aptsQueue.empty())
+        m_audio_1st_pts = (double)PTS_MS_TO_US(frame->u32PtsMs);
+
+      m_aptsQueue.push_back(frame->u32PtsMs);
+
+      m_audio_play_started = true;
+      //printf("HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME, pts :{}, framesize:{}",frame->u32PtsMs,  frame->s32BitPerSample);
+      //HISI_TRACE("HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME, pts :{}", frame->u32PtsMs);
+    }
+    break;
+    /**<New video user data, HI_UNF_VIDEO_USERDATA_S*/
+    case HI_UNF_AVPLAY_EVENT_NEW_USER_DATA: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_NEW_USER_DATA");
+      break;
+    /**<New audio ES data, HI_UNF_ES_BUF_S*/
+    case HI_UNF_AVPLAY_EVENT_GET_AUD_ES: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_GET_AUD_ES");
+      break;
+    /**<I frame decode error, NULL*/
+    case HI_UNF_AVPLAY_EVENT_IFRAME_ERR: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_IFRAME_ERR");
+      break;
+    /**<Pts Jump, HI_UNF_SYNC_PTSJUMP_PARAM_S * */
+    case HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP");
+      break;
+    /**<Synchronization status change, HI_UNF_SYNC_STAT_PARAM_S * */
+    case HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE");
+    {
+      HI_UNF_SYNC_STAT_PARAM_S* sync_info = (HI_UNF_SYNC_STAT_PARAM_S*)pPara;
+      HISI_TRACE("sync info, vid&aud:{}, vid&pcr:{}, aud&pcr:{}, vid@local:{}, aud@local:{}, "
+                 "pcr@local:{}",
+                 sync_info->s32VidAudDiff, sync_info->s32VidPcrDiff, sync_info->s32AudPcrDiff,
+                 sync_info->u32VidLocalTime, sync_info->u32AudLocalTime,
+                 sync_info->u32PcrLocalTime);
+    }
+    break;
+    /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*/
+    case HI_UNF_AVPLAY_EVENT_VID_BUF_STATE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_BUF_STATE");
+    {
+      HI_UNF_AVPLAY_BUF_STATE_E* state = (HI_UNF_AVPLAY_BUF_STATE_E*)pPara;
+      if (*state > HI_UNF_AVPLAY_BUF_STATE_NORMAL)
+      {
+        m_video_full = true;
+      }
+      else
+      {
+        m_video_full = false;
+      }
+
+      if (!m_video_ready && *state >= HI_UNF_AVPLAY_BUF_STATE_LOW)
+      {
+        m_video_ready = true;
+      }
+
+      //HISI_TRACE("video buffer level: {}", (int)(*state));
+    }
+    break;
+    /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*/
+    case HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE");
+    {
+      HI_UNF_AVPLAY_BUF_STATE_E* state = (HI_UNF_AVPLAY_BUF_STATE_E*)pPara;
+      if (*state > HI_UNF_AVPLAY_BUF_STATE_NORMAL)
+      {
+        m_audio_full = true;
+      }
+      else
+      {
+        m_audio_full = false;
+      }
+
+      if (!m_audio_ready && *state >= HI_UNF_AVPLAY_BUF_STATE_LOW)
+      {
+        m_audio_ready = true;
+      }
+
+      //HISI_TRACE("aud buf level: {}", (int)(*state));
+    }
+    break;
+    /**<The video stream is unsupport,NULL*/
+    case HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT");
+      break;
+    /**<frame error ratio,HI_U32 */
+    case HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO");
+      break;
+    /**<audio info change, HI_UNF_ACODEC_STREAMINFO_S */
+    case HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE");
+      break;
+    /**<unsupported audio,NULL */
+    case HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT");
+      break;
+    /**<audio frame error, NULL */
+    case HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR");
+      break;
+    /**<the setting vid codec type is error, HI_UNF_VCODEC_TYPE_E*/
+    case HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE");
+      break;
+    /**<the first deocded frame have been displayed out by the tv. NULL*/
+    case HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED:
+      HISI_TRACE("HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED");
+      m_video_play_started = true;
+      break;
+    /**<vid frame decode error. NULL*/
+    case HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME");
+      break;
+    /**<avplay status info, HI_UNF_AVPLAY_STATUS_INFO_S*/
+    case HI_UNF_AVPLAY_EVENT_STATUS_REPORT:
+    {
+      HI_UNF_AVPLAY_STATUS_INFO_S* AvplayStatus = (HI_UNF_AVPLAY_STATUS_INFO_S*)pPara;
+      //HI_UNF_AVPLAY_STATUS_E playstatus = AvplayStatus->enRunStatus;
+      //HI_UNF_AVPLAY_BUF_STATUS_S VideoStatus = AvplayStatus->stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID];
+      HI_UNF_AVPLAY_BUF_STATUS_S AudioStatus =
+          AvplayStatus->stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD];
+      m_audio_cache_time = AudioStatus.u32FrameBufTime;
+      m_audio_cache_total =
+          AudioStatus.u32UsedSize / (m_audio_bytes_pes_sec / 1000.0) + m_audio_cache_time;
+      //printf("[Hiplayer][Report]:Audio BufTime {}, Audio UsedSize {}", AudioStatus.u32FrameBufTime, AudioStatus.u32UsedSize);
+      //printf("[Hiplayer][Report]:playstatus {}", playstatus);
+      /*HISI_TRACE("[Hiplayer][Report]:"
+					"\tu32LastVidPts :{}"
+					"\tu32VidFrameCount:{}"
+					"\tu32VidErrorFrameCount:{}"
+					"\tu32FrameBufTime:{}"
+					"\tu32FrameBufNum:{}",
+					AvplayStatus->stSyncStatus.u32LastVidPts, 
+					AvplayStatus->u32VidFrameCount, 
+					AvplayStatus->u32VidErrorFrameCount,
+					AvplayStatus->stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32FrameBufTime,
+					AvplayStatus->stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32FrameBufNum);*/
+      break;
+    }
+    /**<Video frame status info, HI_UNF_VIDEO_FRM_STATUS_INFO_S*/
+    case HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO");
+    {
+    }
+    break;
+    /**<the peek frame first pts, HI_U32*/
+    case HI_UNF_AVPLAY_EVENT_VID_START_POS: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_VID_START_POS");
+      break;
+    /**<Estimated time of display, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/
+    case HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME");
+    {
+      //HI_UNF_VIDEO_FRM_DISPLAY_TIME_S *frame_status = (HI_UNF_VIDEO_FRM_DISPLAY_TIME_S *)pPara;
+      //HISI_TRACE("display time, pts : %lld, time: %lld", frame_status->s64PTS, frame_status->s64DisplayTime);
+    }
+    break;
+    /**<HDCP strategy change, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S*/
+    case HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE: //HISI_TRACE("HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE");
+      break;
+    default:
+      break;
+  }
+
+  return HI_SUCCESS;
+}
+
+void HisiAvDecoder::SetVolume(int Volume)
+{
+  HISI_TRACE("HisiAvDecoder::SetVolume {}", Volume);
+
+  Init();
+
+  HI_UNF_SND_GAIN_ATTR_S Vol;
+  Vol.bLinearMode = HI_TRUE;
+  Vol.s32Gain = Volume;
+  HI_UNF_SND_SetVolume(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_ALL, &Vol);
+}
+
+void HisiAvDecoder::Mute(bool Mute)
+{
+  HISI_TRACE("HisiAvDecoder::Mute {}", Mute);
+
+  Init();
+
+  HI_UNF_SND_SetMute(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_ALL, (HI_BOOL)Mute);
+}
diff --git a/xbmc/cores/hiplayer/HiDecoder.h b/xbmc/cores/hiplayer/HiDecoder.h
new file mode 100644
index 0000000000..d4cb7c6fce
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiDecoder.h
@@ -0,0 +1,164 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Thread.h"
+
+#include <deque>
+
+extern "C"
+{
+#include "hisi/HA.AUDIO.PCM.decode.h"
+
+#include <hisi/hi_adp_mpi.h>
+#include <hisi/hi_audio_codec.h>
+#include <hisi/hi_type.h>
+#include <hisi/hi_unf_advca.h>
+#include <hisi/hi_unf_audio.h>
+#include <hisi/hi_unf_common.h>
+#include <hisi/hi_unf_disp.h>
+#include <hisi/hi_unf_otp.h>
+#include <hisi/hi_unf_video.h>
+#include <hisi/hi_unf_vo.h>
+
+} // extern "C"
+
+#define PTS_FREQ 90000
+#define UNIT_FREQ 96000
+#define AV_SYNC_THRESH PTS_FREQ * 30
+#define PTS_US_TO_MS(PTS_US) ((PTS_US) / 1000.0)
+#define PTS_MS_TO_US(PTS_MS) ((PTS_MS)*1000.0)
+#define PTS_90KHZ_TO_MS(PTS_90MS) ((PTS_90MS) / 90.0)
+#define PTS_MS_TO_90KHZ(PTS_MS) ((PTS_MS)*90.0)
+
+enum
+{
+  VIDEO_MODE_NORMAL,
+  VIDEO_MODE_PAUSE,
+  VIDEO_MODE_FORWARD,
+  VIDEO_MODE_BACKWARD
+};
+
+class HisiAvDecoder
+{
+public:
+  static HisiAvDecoder* GetInstance();
+
+  HisiAvDecoder();
+  virtual ~HisiAvDecoder();
+
+  bool IsEOS();
+
+  bool VideoOpen(CDVDStreamInfo& hints);
+  bool VideoClose();
+  void VideoReset();
+  void VideoReSync(unsigned int pts);
+
+  bool VideoWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms);
+  bool VideoWriteEx(uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+  double VideoFirstPts();
+  double VideoCurrentPts();
+  bool VideoFramePts(int& pts);
+
+  bool VideoBufferReady();
+  bool VideoBufferFull();
+  bool VideoPlayStarted();
+  void VideoSetSpeed(int speed);
+  void VideoSubmitEOS();
+  void VideoSetRect(int x, int y, int width, int height);
+
+  bool AudioOpen(CDVDStreamInfo& hints);
+  bool AudioClose();
+  void AudioReset();
+  void AudioReSync(unsigned int pts);
+
+  bool AudioBufferReady();
+  bool AudioBufferFull();
+  bool AudioWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms);
+  bool AudioWriteEx(uint8_t* pData, size_t iSize, unsigned int pts_ms, bool continues, bool last);
+
+  bool AudioPlayStarted();
+  double AudioCurrentPts();
+  double AudioFirstPts();
+  double AudioCacheTotal();
+  double AudioCachetime();
+  double AudioDelay();
+
+  void AudioSubmitEOS();
+
+  HI_S32 EventReport(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara);
+
+  void SetVolume(int Volume);
+  void Mute(bool Mute);
+
+protected:
+  bool Init();
+  bool Deinit();
+  void SubmitEOS();
+
+  HI_UNF_VCODEC_TYPE_E codec2vdec(int enc);
+  HA_CODEC_ID_E codec2adec(int enc);
+
+private:
+  bool m_opened;
+  bool m_video_opend;
+  bool m_audio_opend;
+  bool m_dump;
+
+  unsigned int m_hAvplay;
+  unsigned int m_hWin;
+  unsigned int m_hTrack;
+
+  //video play
+  int m_mode;
+  int m_speed;
+
+  HI_UNF_DISP_E m_disp;
+  bool m_freerun;
+
+  CCriticalSection m_section;
+  CCriticalSection m_EventMutex;
+
+  std::deque<int> m_aptsQueue;
+  std::deque<int> m_vptsQueue;
+
+  bool m_audio_full;
+  bool m_video_full;
+  bool m_video_eos;
+  bool m_audio_eos;
+  bool m_eos;
+
+  int m_audio_last_package_pts;
+  int m_audio_bytes_pes_sec;
+  double m_audio_cache_total;
+  double m_audio_cache_time;
+  double m_audio_delay;
+
+  double m_video_1st_pts;
+  double m_audio_1st_pts;
+
+  bool m_audio_play_started;
+  bool m_video_play_started;
+
+  bool m_audio_ready;
+  bool m_video_ready;
+};
diff --git a/xbmc/cores/hiplayer/HiPlayerAudio.cpp b/xbmc/cores/hiplayer/HiPlayerAudio.cpp
new file mode 100644
index 0000000000..2769cc96b1
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiPlayerAudio.cpp
@@ -0,0 +1,817 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiPlayerAudio.h"
+
+#include "DVDDemuxers/DVDDemuxUtils.h"
+#include "HiAdec.h"
+#include "HiCodecAudio.h"
+#include "HiDecoder.h"
+#include "ServiceBroker.h"
+#include "cores/AudioEngine/AEResampleFactory.h"
+#include "cores/AudioEngine/Utils/AEStreamInfo.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "cores/DataCacheCore.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDCodecs.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
+#include "utils/BitstreamStats.h"
+#include "utils/MathUtils.h"
+#include "utils/Variant.h"
+#include "utils/XTimeUtils.h"
+#include "utils/log.h"
+
+#include <algorithm>
+#include <iomanip>
+#include <iostream>
+#include <sstream>
+#include <stdio.h>
+#include <chrono>
+
+#include <unistd.h>
+
+#include "system.h"
+
+using namespace std::chrono_literals;
+
+static unsigned char DefaultAACHeader[] = {
+    0xff, 0xf1,
+    /*0x00, 0x00*/
+    0x50, //((Profile & 0x03) << 6)  | (SampleIndex << 2) | ((Channels >> 2) & 0x01);s
+    0x80, //(Channels & 0x03) << 6;
+    0x00, 0x1f, 0xfc};
+
+#define AAC_HEADER_LENGTH 7
+
+class CHisiMsgAudioCodecChange : public CDVDMsg
+{
+public:
+  CHisiMsgAudioCodecChange(const CDVDStreamInfo& hints, CDVDAudioCodecHisi* codec)
+      : CDVDMsg(GENERAL_STREAMCHANGE)
+      , m_codec(codec)
+      , m_hints(hints)
+  {
+  }
+  ~CHisiMsgAudioCodecChange()
+  {
+    delete m_codec;
+  }
+
+  CDVDAudioCodecHisi* m_codec;
+  CDVDStreamInfo m_hints;
+};
+
+CHiPlayerAudio::CHiPlayerAudio(CDVDClock* av_clock,
+                               CDVDMessageQueue& parent,
+                               CProcessInfo& processInfo)
+    : CThread("CHiPlayerAudio")
+    , IDVDStreamPlayerAudio(processInfo)
+    , m_messageQueue("audio")
+    , m_messageParent(parent)
+    , m_hisiAudio(new CHiAudio())
+{
+  m_av_clock = av_clock;
+  m_pAudioCodec = NULL;
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+  m_stalled = false;
+  m_audioClock = DVD_NOPTS_VALUE;
+  m_buffer_empty = false;
+  m_DecoderOpen = false;
+  m_bad_state = false;
+  m_bStop = false;
+  m_start_pts = DVD_NOPTS_VALUE;
+  m_bAbortOutput = false;
+
+  m_hints_current.Clear();
+
+  m_messageQueue.SetMaxDataSize(6 * 1024 * 1024);
+  m_messageQueue.SetMaxTimeSize(8.0);
+
+  m_passthrough = false;
+  m_flush = false;
+}
+
+CHiPlayerAudio::~CHiPlayerAudio()
+{
+  CloseStream(false);
+  SAFE_DELETE(m_hisiAudio);
+}
+
+bool CHiPlayerAudio::OpenStream(CDVDStreamInfo hints)
+{
+  m_bad_state = false;
+
+  m_processInfo.ResetAudioCodecInfo();
+
+  CDVDCodecOptions options;
+  if (!m_processInfo.AllowDTSHDDecode())
+    options.m_keys.push_back(CDVDCodecOption("allowdtshddecode", "0"));
+
+  CDVDAudioCodecHisi* codec = new CDVDAudioCodecHisi(m_processInfo);
+
+  CLog::Log(LOGNOTICE, "CHiPlayerAudio in, Param:");
+  CLog::Log(LOGNOTICE, "hints.codec        : {}", hints.codec);
+  CLog::Log(LOGNOTICE, "hints.channels     : {}", hints.channels);
+  CLog::Log(LOGNOTICE, "hints.samplerate   : {}", hints.samplerate);
+  CLog::Log(LOGNOTICE, "hints.bitspersample: {}", hints.bitspersample);
+  CLog::Log(LOGNOTICE, "hints.extrasize    : {}", hints.extradata.GetSize());
+
+  if (hints.bitspersample == 0)
+    hints.bitspersample = 16;
+  if (hints.samplerate == 0)
+    hints.samplerate = 48000;
+  if (hints.channels == 0)
+    hints.channels = 2;
+
+  if (!codec || !codec->Open(hints))
+  {
+    CLog::Log(LOGERROR, "Unsupported audio codec");
+    SAFE_DELETE(codec);
+    return false;
+  }
+
+  if (m_messageQueue.IsInited())
+    m_messageQueue.Put(std::make_shared<CHisiMsgAudioCodecChange>(hints, codec), 0);
+  else
+  {
+    OpenStream(hints, codec);
+    m_messageQueue.Init();
+    CLog::Log(LOGNOTICE, "Creating audio thread");
+    Create();
+  }
+
+  return true;
+}
+
+void CHiPlayerAudio::OpenStream(CDVDStreamInfo& hints, CDVDAudioCodecHisi* codec)
+{
+  SAFE_DELETE(m_pAudioCodec);
+
+  m_pAudioCodec = codec;
+  m_hints = hints;
+  m_bStop = false;
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_audioClock = DVD_NOPTS_VALUE;
+  m_start_pts = DVD_NOPTS_VALUE;
+  m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+  m_flush = false;
+  m_bAbortOutput = false;
+  m_stalled = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
+  m_format = GetDataFormat(m_hints);
+  m_format.m_sampleRate = 0;
+  m_format.m_channelLayout = 0;
+
+  if (CodecChange())
+  {
+    CLog::Log(LOGNOTICE, "OpenStream CodecChanged");
+
+    m_DecoderOpen = OpenDecoder();
+    if (!m_DecoderOpen)
+      return;
+  }
+
+  CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+
+  m_messageParent.Put(std::make_shared<CDVDMsg>(CDVDMsg::PLAYER_AVCHANGE));
+}
+
+void CHiPlayerAudio::CloseStream(bool bWaitForBuffers)
+{
+  // wait until buffers are empty
+  if (bWaitForBuffers && m_speed > 0)
+    m_messageQueue.WaitUntilEmpty();
+
+  m_messageQueue.Abort();
+
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_bStop = true;
+  m_bAbortOutput = true;
+
+  if (IsRunning())
+    StopThread();
+
+  m_messageQueue.End();
+
+  if (m_pAudioCodec)
+  {
+    m_pAudioCodec->Dispose();
+    SAFE_DELETE(m_pAudioCodec);
+  }
+
+  CloseDecoder();
+}
+
+void CHiPlayerAudio::OnStartup()
+{
+  CLog::Log(LOGNOTICE, "CHiPlayerAudio::OnStartup");
+}
+
+void CHiPlayerAudio::OnExit()
+{
+  CLog::Log(LOGNOTICE, "thread end: CHiPlayerAudio::OnExit()");
+}
+
+bool CHiPlayerAudio::CodecChange()
+{
+  unsigned int old_bitrate = m_hints.bitrate;
+  unsigned int new_bitrate = m_hints_current.bitrate;
+
+  if (m_pAudioCodec)
+  {
+    m_hints.channels = m_pAudioCodec->GetChannels();
+    m_hints.samplerate = m_pAudioCodec->GetSampleRate();
+    m_hints.bitspersample = m_pAudioCodec->GetBitsPerSample();
+  }
+
+  /* only check bitrate changes on AV_CODEC_ID_DTS, AV_CODEC_ID_AC3, AV_CODEC_ID_EAC3 */
+  if (m_hints.codec != AV_CODEC_ID_DTS && m_hints.codec != AV_CODEC_ID_AC3 &&
+      m_hints.codec != AV_CODEC_ID_EAC3)
+  {
+    new_bitrate = old_bitrate = 0;
+  }
+
+  // for passthrough we only care about the codec and the samplerate
+  bool minor_change = m_hints_current.channels != m_hints.channels ||
+                      m_hints_current.bitspersample != m_hints.bitspersample ||
+                      old_bitrate != new_bitrate;
+
+  if (m_hints_current.codec != m_hints.codec || m_hints_current.samplerate != m_hints.samplerate ||
+      (!m_passthrough && minor_change) || !m_DecoderOpen)
+  {
+    CLog::Log(LOGNOTICE, "CHiPlayerAudio, CodecChanged");
+
+    m_hints_current = m_hints;
+    m_processInfo.SetAudioSampleRate(m_hints.samplerate);
+    m_processInfo.SetAudioBitsPerSample(m_hints.bitspersample);
+
+    CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+    return true;
+  }
+
+  return false;
+}
+
+bool CHiPlayerAudio::Decode(DemuxPacket* pkt, bool bDropPacket, bool bTrickPlay)
+{
+  if (!pkt || m_bad_state || !m_pAudioCodec)
+    return false;
+
+  int try_times = 0;
+  const uint8_t* data_dec = pkt->pData;
+  int data_len = pkt->iSize;
+  double dts = pkt->dts, pts = pkt->pts;
+  /*
+	if(CodecChange())
+	{
+		m_DecoderOpen = OpenDecoder();
+		if(!m_DecoderOpen)
+			return false;
+	}*/
+
+  m_bAbortOutput = false;
+
+  if (bTrickPlay)
+  {
+  }
+  else if (m_format.m_dataFormat != AE_FMT_RAW && !bDropPacket)
+  {
+    while (!m_bStop && !m_bAbortOutput && data_len > 0)
+    {
+      int len = m_pAudioCodec->Decode((BYTE*)data_dec, data_len, dts, pts);
+      if ((len < 0) || (len > data_len))
+      {
+        m_pAudioCodec->Reset();
+        break;
+      }
+
+      data_dec += len;
+      data_len -= len;
+
+      uint8_t* decoded;
+      int decoded_size = m_pAudioCodec->GetData(&decoded, dts, pts);
+
+      if (decoded_size <= 0)
+        continue;
+
+      m_audioStats.AddSampleBytes(decoded_size);
+
+      if (pts != DVD_NOPTS_VALUE && m_audioClock != DVD_NOPTS_VALUE && m_audioClock > pts)
+      {
+        CLog::Log(LOGDEBUG, "CHiPlayerAudio package need drop, seek pts:{}, package pts:{}",
+                  m_audioClock, pts);
+      }
+
+      if (m_start_pts == DVD_NOPTS_VALUE && pts != DVD_NOPTS_VALUE)
+      {
+        m_start_pts = pts;
+      }
+
+      while (!m_bStop && !m_bAbortOutput)
+      {
+        if (m_hisiAudio->Full())
+        {
+          KODI::TIME::Sleep(10ms);
+          if (++try_times > 1000)
+          {
+            CLog::Log(LOGDEBUG, "CHiPlayerAudio full, push blocking, just drop package");
+            break;
+          }
+
+          continue;
+        }
+
+        if (!m_hisiAudio->Push((uint8_t*)decoded, decoded_size, PTS_US_TO_MS(pts)))
+        {
+          KODI::TIME::Sleep(10ms);
+          continue;
+        }
+
+        m_audioClock = pts;
+        break;
+      }
+    }
+  }
+  else if (!bDropPacket)
+  {
+    while (!m_bStop && !m_bAbortOutput)
+    {
+      if (m_flush)
+        break;
+
+      unsigned char* pData = pkt->pData;
+      int iSize = pkt->iSize;
+      if (pData)
+      {
+        AVPacket avpkt;
+        av_init_packet(&avpkt);
+        avpkt.data = pData;
+        avpkt.size = iSize;
+        /* if (av_packet_split_side_data(&avpkt))
+        {
+          pData = avpkt.data;
+          iSize = avpkt.size;
+          av_packet_free_side_data(&avpkt);
+        } */
+      }
+
+      while (!m_bAbortOutput)
+      {
+        if (m_hisiAudio->Full())
+        {
+          KODI::TIME::Sleep(10ms);
+          if (++try_times > 1000)
+          {
+            CLog::Log(LOGDEBUG, "CHiPlayerAudio blocking, quit");
+            break;
+          }
+          continue;
+        }
+
+        bool ret = m_hisiAudio->PushEx(pData, iSize, PTS_US_TO_MS(pkt->pts), true, true);
+        if (!ret)
+        {
+          KODI::TIME::Sleep(10ms);
+          continue;
+        }
+
+        break;
+      }
+
+      break;
+    }
+
+    m_audioStats.AddSampleBytes(pkt->iSize);
+  }
+
+  if (m_syncState == IDVDStreamPlayer::SYNC_STARTING && !bDropPacket &&
+      m_start_pts != DVD_NOPTS_VALUE
+      /*&&	m_hisiAudio->Ready()*/)
+  {
+    SStartMsg msg;
+    msg.player = VideoPlayer_AUDIO;
+    msg.cachetotal = DVD_SEC_TO_TIME(GetCacheTotal());
+    msg.cachetime = DVD_SEC_TO_TIME(GetCacheTime());
+    msg.timestamp = m_start_pts;
+    m_messageParent.Put(std::make_shared<CDVDMsgType<SStartMsg>>(CDVDMsg::PLAYER_STARTED, msg));
+    CLog::Log(LOGINFO, "CHiPlayerAudio PLAYER_STARTED, pts : {}", m_start_pts);
+
+    m_syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
+  }
+
+  return true;
+}
+
+void CHiPlayerAudio::Process()
+{
+  m_audioStats.Start();
+
+  while (!m_bStop)
+  {
+    std::shared_ptr<CDVDMsg> pMsg;
+    std::chrono::milliseconds timeout = 1000ms;
+
+    // read next packet and return -1 on error
+    int priority = 1;
+    //Do we want a new audio frame?
+    if (m_syncState == IDVDStreamPlayer::SYNC_STARTING || /* when not started */
+        m_speed == DVD_PLAYSPEED_NORMAL ||                /* when playing normally */
+        m_speed < DVD_PLAYSPEED_PAUSE ||                  /* when rewinding */
+        (m_speed > DVD_PLAYSPEED_NORMAL &&
+         m_audioClock < m_av_clock->GetClock())) /* when behind clock in ff */
+      priority = 0;
+
+    if (m_syncState == IDVDStreamPlayer::SYNC_WAITSYNC)
+      priority = 1;
+
+    // consider stream stalled if queue is empty
+    // we can't sync audio to clock with an empty queue
+    if (m_speed == DVD_PLAYSPEED_NORMAL)
+    {
+      timeout = 0ms;
+    }
+
+    MsgQueueReturnCode ret = m_messageQueue.Get(pMsg, timeout, priority);
+
+    if (ret == MSGQ_TIMEOUT)
+    {
+      KODI::TIME::Sleep(10ms);
+      continue;
+    }
+
+    if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
+    {
+      KODI::TIME::Sleep(10ms);
+      continue;
+    }
+
+    if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
+    {
+      DemuxPacket* pPacket = std::static_pointer_cast<CDVDMsgDemuxerPacket>(pMsg)->GetPacket();
+      bool bPacketDrop = std::static_pointer_cast<CDVDMsgDemuxerPacket>(pMsg)->GetPacketDrop();
+
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::DEMUXER_PACKET({}), pts:{}", bPacketDrop,
+                pPacket->pts);
+
+      if (Decode(pPacket, bPacketDrop, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0))
+      {
+        // we are not running until something is cached in output device
+        if (m_stalled && GetCacheTime() > 0.0)
+        {
+          CLog::Log(LOGINFO, "CCHiPlayerAudio - Switching to normal playback");
+          m_stalled = false;
+        }
+      }
+
+      //CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::DEMUXER_PACKET (%f) ", pPacket->pts);
+      // signal to our parent that we have initialized
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
+    {
+      if (std::static_pointer_cast<CDVDMsgGeneralSynchronize>(pMsg)->Wait(100ms, SYNCSOURCE_AUDIO))
+        CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_SYNCHRONIZE");
+      else
+        m_messageQueue.Put(pMsg, 1); // push back as prio message, to process other prio messages
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_RESYNC))
+    {
+      //player asked us to set internal clock
+      double pts = std::static_pointer_cast<CDVDMsgDouble>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_RESYNC({})", pts);
+
+      m_start_pts = DVD_NOPTS_VALUE;
+      m_audioClock = pts;
+      m_syncState = IDVDStreamPlayer::SYNC_INSYNC;
+
+      m_hisiAudio->reSync(PTS_90KHZ_TO_MS(pts));
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
+    {
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_RESET");
+      m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+      m_audioClock = 0;
+      m_pAudioCodec->Reset();
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
+    {
+      bool sync = std::static_pointer_cast<CDVDMsgBool>(pMsg)->m_value;
+
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_FLUSH({}), m_start_pts:{}", sync,
+                m_start_pts);
+
+      m_flush = false;
+      m_stalled = true;
+      m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+      m_start_pts = DVD_NOPTS_VALUE;
+      m_audioClock = 0;
+      m_hisiAudio->reset();
+      m_pAudioCodec->Reset();
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_EOF))
+    {
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_EOF");
+      SignalEndOfStream();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
+    {
+      double speed = std::static_pointer_cast<CDVDMsgInt>(pMsg)->m_value;
+      if (m_speed != speed)
+      {
+        m_speed = speed;
+        CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::PLAYER_SETSPEED {}", m_speed);
+      }
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
+    {
+      auto msg = std::static_pointer_cast<CHisiMsgAudioCodecChange>(pMsg);
+      OpenStream(msg->m_hints, std::move(msg->m_codec));
+      msg->m_codec = NULL;
+
+      CLog::Log(LOGDEBUG, "CCHiPlayerAudio - CDVDMsg::GENERAL_STREAMCHANGE");
+    }
+  }
+}
+
+void CHiPlayerAudio::Flush(bool sync)
+{
+  CLog::Log(LOGINFO, "CCHiPlayerAudio - Flush, sync: {}", sync);
+  m_flush = sync;
+  m_messageQueue.Flush();
+  m_messageQueue.Put(std::make_shared<CDVDMsgBool>(CDVDMsg::GENERAL_FLUSH, sync), 1);
+  m_bAbortOutput = true;
+}
+
+void CHiPlayerAudio::WaitForBuffers()
+{
+  // make sure there are no more packets available
+  m_messageQueue.WaitUntilEmpty();
+
+  // make sure almost all has been rendered
+  // leave 500ms to avound buffer underruns
+  if (GetCacheTime() > 0.5)
+  {
+    int delay = (int)(1000 * (GetCacheTime() - 0.5));
+    KODI::TIME::Sleep(std::chrono::duration<long long, std::milli>(delay));
+  }
+}
+
+bool CHiPlayerAudio::IsPassthrough() const
+{
+  return m_passthrough;
+}
+
+AEAudioFormat CHiPlayerAudio::GetDataFormat(CDVDStreamInfo hints)
+{
+  AEAudioFormat format;
+  format.m_dataFormat = AE_FMT_RAW;
+  format.m_sampleRate = hints.samplerate;
+  switch (hints.codec)
+  {
+    case AV_CODEC_ID_AC3:
+      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_AC3;
+      format.m_streamInfo.m_sampleRate = hints.samplerate;
+      break;
+
+    case AV_CODEC_ID_EAC3:
+      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_EAC3;
+      format.m_streamInfo.m_sampleRate = hints.samplerate * 4;
+      break;
+
+    case AV_CODEC_ID_DTS:
+      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTSHD;
+      format.m_streamInfo.m_sampleRate = hints.samplerate;
+      break;
+
+    case AV_CODEC_ID_TRUEHD:
+      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_TRUEHD;
+      format.m_streamInfo.m_sampleRate = hints.samplerate;
+      break;
+
+    default:
+      format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_NULL;
+  }
+
+  // check if passthrough is enabled
+  char szLine[128] = {0};
+  bool ac3_passthrough = false;
+  bool dts_passthrough = false;
+  bool truehd_passthrough = false;
+
+  FILE* m_file = fopen("/proc/stb/audio/ac3", "rb");
+  if (m_file)
+  {
+    fgets(szLine, 128, m_file);
+    if (!strncmp(szLine, "passthrough", strlen("passthrough")))
+    {
+      ac3_passthrough = true;
+    }
+    fclose(m_file);
+  }
+
+  m_file = fopen("/proc/stb/audio/dts", "rb");
+  if (m_file)
+  {
+    fgets(szLine, 128, m_file);
+    if (!strncmp(szLine, "passthrough", strlen("passthrough")))
+    {
+      dts_passthrough = true;
+    }
+    fclose(m_file);
+  }
+
+  if (ac3_passthrough && dts_passthrough)
+  {
+    truehd_passthrough = true;
+  }
+
+  m_passthrough = false;
+  // check if the format is enabled in settings
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_AC3 && ac3_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_DTS_512 && dts_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_DTS_1024 && dts_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_DTS_2048 && dts_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_DTSHD_CORE && dts_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_EAC3 && ac3_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_TRUEHD && truehd_passthrough)
+    m_passthrough = true;
+  if (format.m_streamInfo.m_type == CAEStreamInfo::STREAM_TYPE_DTSHD && dts_passthrough)
+    m_passthrough = true;
+
+  CLog::Log(LOGDEBUG, "m_passthrough - {}", m_passthrough);
+
+  if (!m_passthrough)
+  {
+    if (m_pAudioCodec && m_pAudioCodec->GetBitsPerSample() == 16)
+      format.m_dataFormat = AE_FMT_S16NE;
+    else
+      format.m_dataFormat = AE_FMT_FLOAT;
+  }
+
+  return format;
+}
+
+bool CHiPlayerAudio::OpenDecoder()
+{
+  m_passthrough = false;
+
+  if (m_DecoderOpen)
+  {
+    m_hisiAudio->close();
+    m_DecoderOpen = false;
+  }
+
+  /* setup audi format for audio render */
+  m_format = GetDataFormat(m_hints);
+
+  CAEChannelInfo channelMap;
+  if (m_pAudioCodec && !m_passthrough)
+  {
+    channelMap = m_pAudioCodec->GetChannelMap();
+  }
+  else if (m_passthrough)
+  {
+    // we just want to get the channel count right to stop OMXAudio.cpp rejecting stream
+    // the actual layout is not used
+    channelMap = AE_CH_LAYOUT_5_1;
+
+    if (m_hints.codec == AV_CODEC_ID_AC3)
+      m_processInfo.SetAudioDecoderName("PT_AC3");
+    else if (m_hints.codec == AV_CODEC_ID_EAC3)
+      m_processInfo.SetAudioDecoderName("PT_EAC3");
+    else
+      m_processInfo.SetAudioDecoderName("PT_DTS");
+  }
+
+  m_processInfo.SetAudioChannels(channelMap);
+
+  CLog::Log(LOGNOTICE, "Audio codec {} channels {} samplerate {} bitspersample {}",
+            m_codec_name.c_str(), m_hints.channels, m_hints.samplerate, m_hints.bitspersample);
+
+  if (m_passthrough)
+    m_hints.codecOptions &= ~CODEC_FORCE_SOFTWARE;
+  else
+    m_hints.codecOptions |= CODEC_FORCE_SOFTWARE;
+
+  CLog::Log(LOGNOTICE, "OpenDecoder passthrough : {}, codecOptions:{}", m_passthrough,
+            m_hints.codecOptions);
+
+  bool bAudioRenderOpen = m_hisiAudio->open(m_hints);
+  //m_omxAudio.Initialize(m_format, m_av_clock, m_hints, channelMap, m_passthrough);
+
+  m_codec_name = "";
+  m_bad_state = !bAudioRenderOpen;
+
+  if (!bAudioRenderOpen)
+  {
+    CLog::Log(LOGERROR, "CHiPlayerAudio : Error open audio output");
+    m_hisiAudio->close();
+  }
+  else
+  {
+    CLog::Log(LOGINFO, "Audio codec {} channels {} samplerate {} bitspersample {}",
+              m_codec_name.c_str(), m_hints.channels, m_hints.samplerate, m_hints.bitspersample);
+  }
+
+  return bAudioRenderOpen;
+}
+
+void CHiPlayerAudio::CloseDecoder()
+{
+  m_hisiAudio->close();
+  m_DecoderOpen = false;
+}
+
+double CHiPlayerAudio::GetDelay()
+{
+  return m_hisiAudio->Delay();
+}
+
+double CHiPlayerAudio::GetCacheTime()
+{
+  return m_hisiAudio->CacheTime();
+}
+
+double CHiPlayerAudio::GetCacheTotal()
+{
+  return m_hisiAudio->CacheTotal();
+}
+
+void CHiPlayerAudio::SignalEndOfStream()
+{
+  m_hisiAudio->SubmitEos();
+}
+
+bool CHiPlayerAudio::IsEOS()
+{
+  return m_bad_state || m_hisiAudio->EOS();
+}
+
+bool CHiPlayerAudio::HasData() const
+{
+  return m_messageQueue.GetDataSize() > 0 || !m_hisiAudio->EOS();
+}
+
+void CHiPlayerAudio::SetSpeed(int speed)
+{
+  if (m_messageQueue.IsInited())
+    m_messageQueue.Put(std::make_shared<CDVDMsgInt>(CDVDMsg::PLAYER_SETSPEED, speed), 1);
+  else
+    m_speed = speed;
+
+  CLog::Log(LOGINFO, "CHiPlayerAudio SetSpeed: {}", speed);
+}
+
+int CHiPlayerAudio::GetAudioBitrate()
+{
+  return (int)m_audioStats.GetBitrate();
+}
+
+int CHiPlayerAudio::GetAudioChannels()
+{
+  return m_hints.channels;
+}
+
+std::string CHiPlayerAudio::GetPlayerInfo()
+{
+  std::ostringstream s;
+  s << "aq:" << std::setw(2) << std::min(99, m_messageQueue.GetLevel()) << "%";
+  s << ", Kb/s:" << std::fixed << std::setprecision(2) << (double)GetAudioBitrate() / 1024.0;
+
+  return s.str();
+}
+
+void CHiPlayerAudio::SetVolume(float fVolume)
+{
+  int vol = (int)(fVolume * 100);
+  m_hisiAudio->SetVolume(vol);
+  CLog::Log(LOGINFO, "CHiPlayerAudio SetVolume: {}", vol);
+}
+
+void CHiPlayerAudio::SetMute(bool bOnOff)
+{
+  m_hisiAudio->SetMute(bOnOff);
+  CLog::Log(LOGINFO, "CHiPlayerAudio SetMute: {}", bOnOff);
+}
\ No newline at end of file
diff --git a/xbmc/cores/hiplayer/HiPlayerAudio.h b/xbmc/cores/hiplayer/HiPlayerAudio.h
new file mode 100644
index 0000000000..7a42121fa2
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiPlayerAudio.h
@@ -0,0 +1,139 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDMessageQueue.h"
+#include "DVDStreamInfo.h"
+#include "IVideoPlayer.h"
+#include "cores/AudioEngine/Utils/AEAudioFormat.h"
+#include "threads/Thread.h"
+#include "utils/BitstreamStats.h"
+
+#include <deque>
+
+#include <sys/types.h>
+
+class CHiAudio;
+class CDVDAudioCodecHisi;
+
+class CHiPlayerAudio : public CThread, public IDVDStreamPlayerAudio
+{
+public:
+  CHiPlayerAudio(CDVDClock* av_clock, CDVDMessageQueue& parent, CProcessInfo& processInfo);
+  ~CHiPlayerAudio();
+  bool OpenStream(CDVDStreamInfo hints);
+  void SendMessage(std::shared_ptr<CDVDMsg> pMsg, int priority = 0) override
+  {
+    m_messageQueue.Put(pMsg, priority);
+  }
+  void FlushMessages()
+  {
+    m_messageQueue.Flush();
+  }
+  bool AcceptsData() const
+  {
+    return !m_messageQueue.IsFull();
+  }
+  bool HasData() const;
+  bool IsInited() const
+  {
+    return m_messageQueue.IsInited();
+  }
+  int GetLevel() const
+  {
+    return m_messageQueue.GetLevel();
+  }
+  bool IsStalled() const
+  {
+    return m_stalled;
+  }
+  bool IsEOS();
+  void WaitForBuffers();
+  void CloseStream(bool bWaitForBuffers);
+  bool CodecChange();
+  bool Decode(DemuxPacket* pkt, bool bDropPacket, bool bTrickPlay);
+  void Flush(bool sync);
+  AEAudioFormat GetDataFormat(CDVDStreamInfo hints);
+  bool IsPassthrough() const;
+  bool OpenDecoder();
+  void CloseDecoder();
+  double GetDelay();
+  double GetCacheTime();
+  double GetCacheTotal();
+  double GetCurrentPts()
+  {
+    return m_audioClock;
+  };
+  void SignalEndOfStream();
+
+  void SetDynamicRangeCompression(long drc)
+  {
+  }
+  float GetDynamicRangeAmplification() const
+  {
+    return 0.0f;
+  }
+  void SetSpeed(int iSpeed);
+  int GetAudioBitrate();
+  int GetAudioChannels();
+  std::string GetPlayerInfo();
+
+  void SetVolume(float fVolume);
+  void SetMute(bool bOnOff);
+  bool BadState()
+  {
+    return m_bad_state;
+  }
+
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+  void OpenStream(CDVDStreamInfo& hints, CDVDAudioCodecHisi* codec);
+
+  CDVDMessageQueue m_messageQueue;
+  CDVDMessageQueue& m_messageParent;
+
+  CDVDStreamInfo m_hints_current;
+  CDVDStreamInfo m_hints;
+  CDVDClock* m_av_clock;
+  CHiAudio* m_hisiAudio;
+  AEAudioFormat m_format;
+  CDVDAudioCodecHisi* m_pAudioCodec;
+  std::string m_codec_name;
+  bool m_passthrough;
+  int m_speed;
+  bool m_silence;
+  double m_audioClock;
+  double m_start_pts;
+  bool m_stalled;
+
+  bool m_buffer_empty;
+  bool m_flush;
+  bool m_DecoderOpen;
+
+  bool m_bad_state;
+  bool m_eos;
+  std::atomic_bool m_bAbortOutput;
+  IDVDStreamPlayer::ESyncState m_syncState;
+  BitstreamStats m_audioStats;
+};
diff --git a/xbmc/cores/hiplayer/HiPlayerVideo.cpp b/xbmc/cores/hiplayer/HiPlayerVideo.cpp
new file mode 100644
index 0000000000..8f02fac416
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiPlayerVideo.cpp
@@ -0,0 +1,999 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "HiPlayerVideo.h"
+
+#include "DVDCodecs/DVDCodecUtils.h"
+#include "DVDCodecs/DVDFactoryCodec.h"
+#include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "HiCodecVideo.h"
+#include "HiDecoder.h"
+#include "HiVdec.h"
+#include "ServiceBroker.h"
+#include "Util.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/Geometry.h"
+#include "utils/MathUtils.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/WinSystem.h"
+
+#include <chrono>
+#include <iomanip>
+#include <iterator>
+#include <numeric>
+#include <sstream>
+
+#include <sys/time.h>
+
+#include "system.h"
+
+//using namespace RenderManager;
+using namespace std::chrono_literals;
+
+#define DF_TINIT()                                                                                 \
+  struct timeval tv_start, tv_end;                                                                 \
+  unsigned int time_cost, line_start
+#define DF_TSTART()                                                                                \
+  gettimeofday(&tv_start, NULL);                                                                   \
+  line_start = __LINE__
+#define DF_TEND()                                                                                  \
+  gettimeofday(&tv_end, NULL);                                                                     \
+  time_cost = ((tv_end.tv_usec - tv_start.tv_usec) + (tv_end.tv_sec - tv_start.tv_sec) * 1000000); \
+  CLog::Log(LOGINFO, "=======================================================\n");                 \
+  CLog::Log(LOGINFO, "FROM LINE: {} TO LINE: {} COST: {} us = {} ms\n", line_start, __LINE__,      \
+            time_cost, time_cost / 1000);                                                          \
+  CLog::Log(LOGINFO, "=======================================================\n")
+
+CDVDVideoCodecHisi* m_pVideoCodec;
+
+class CVideoBufferHisi : public CVideoBuffer
+{
+public:
+  CVideoBufferHisi(IVideoBufferPool& pool, int id);
+  ~CVideoBufferHisi() override;
+
+  void SetRef(AVFrame* frame);
+  void Unref();
+
+protected:
+  AVFrame* m_pFrame;
+};
+
+CVideoBufferHisi::CVideoBufferHisi(IVideoBufferPool& pool, int id)
+    : CVideoBuffer(id)
+{
+  m_pFrame = av_frame_alloc();
+}
+
+CVideoBufferHisi::~CVideoBufferHisi()
+{
+  av_frame_free(&m_pFrame);
+}
+
+void CVideoBufferHisi::SetRef(AVFrame* frame)
+{
+  av_frame_unref(m_pFrame);
+  av_frame_move_ref(m_pFrame, frame);
+  m_pixFormat = (AVPixelFormat)m_pFrame->format;
+}
+
+void CVideoBufferHisi::Unref()
+{
+  av_frame_unref(m_pFrame);
+}
+
+//------------------------------------------------------------------------------
+
+class CVideoBufferPoolHisi : public IVideoBufferPool
+{
+public:
+  ~CVideoBufferPoolHisi() override;
+  void Return(int id) override;
+  CVideoBuffer* Get() override;
+
+protected:
+  CCriticalSection m_critSection;
+  std::vector<CVideoBufferHisi*> m_all;
+  std::deque<int> m_used;
+  std::deque<int> m_free;
+};
+
+CVideoBufferPoolHisi::~CVideoBufferPoolHisi()
+{
+  for (auto buf : m_all)
+  {
+    delete buf;
+  }
+}
+
+CVideoBuffer* CVideoBufferPoolHisi::Get()
+{
+  CSingleExit lock(m_critSection);
+
+  CVideoBufferHisi* buf = nullptr;
+  if (!m_free.empty())
+  {
+    int idx = m_free.front();
+    m_free.pop_front();
+    m_used.push_back(idx);
+    buf = m_all[idx];
+  }
+  else
+  {
+    int id = m_all.size();
+    buf = new CVideoBufferHisi(*this, id);
+    m_all.push_back(buf);
+    m_used.push_back(id);
+  }
+
+  buf->Acquire(GetPtr());
+  return buf;
+}
+
+void CVideoBufferPoolHisi::Return(int id)
+{
+  CSingleExit lock(m_critSection);
+
+  m_all[id]->Unref();
+  auto it = m_used.begin();
+  while (it != m_used.end())
+  {
+    if (*it == id)
+    {
+      m_used.erase(it);
+      break;
+    }
+    else
+      ++it;
+  }
+  m_free.push_back(id);
+}
+
+class CDVDMsgVideoCodecChangeHi : public CDVDMsg
+{
+public:
+  CDVDMsgVideoCodecChangeHi(const CDVDStreamInfo& hints, CDVDVideoCodecHisi* codec)
+      : CDVDMsg(GENERAL_STREAMCHANGE)
+      , m_codec(codec)
+      , m_hints(hints)
+  {
+  }
+
+  ~CDVDMsgVideoCodecChangeHi()
+  {
+    delete m_codec;
+  }
+
+  CDVDVideoCodecHisi* m_codec;
+  CDVDStreamInfo m_hints;
+};
+
+CHiPlayerVideo::CHiPlayerVideo(CDVDClock* pClock,
+                               CDVDOverlayContainer* pOverlayContainer,
+                               CDVDMessageQueue& parent,
+                               CRenderManager& renderManager,
+                               CProcessInfo& processInfo)
+    : CThread("VideoPlayerVideo")
+    , IDVDStreamPlayerVideo(processInfo)
+    , m_messageQueue("video")
+    , m_messageParent(parent)
+    , m_renderManager(renderManager)
+{
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_pOverlayContainer = pOverlayContainer;
+  m_bRenderSubs = false;
+  m_stalled = false;
+  m_paused = false;
+  m_iSubtitleDelay = 0;
+  m_fFrameRate = 25;
+  m_bAllowFullscreen = false;
+  m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+  m_pVideoCodec = NULL;
+  m_start_pts = DVD_NOPTS_VALUE;
+
+  m_videoBufferPool = std::make_shared<CVideoBufferPoolHisi>();
+
+  m_messageQueue.SetMaxDataSize(40 * 1024 * 1024);
+  m_messageQueue.SetMaxTimeSize(8.0);
+}
+
+CHiPlayerVideo::~CHiPlayerVideo()
+{
+  m_bAbortOutput = true;
+
+  StopThread();
+
+  SAFE_DELETE(m_pVideoCodec);
+}
+
+bool CHiPlayerVideo::OpenStream(CDVDStreamInfo hint)
+{
+  CLog::Log(LOGINFO, "CHiPlayerVideo::OpenStream");
+
+  m_processInfo.ResetVideoCodecInfo();
+
+  //CRenderInfo info = m_renderManager.GetRenderInfo();
+
+  CDVDVideoCodecHisi* codec = new CDVDVideoCodecHisi(m_processInfo);
+  CDVDCodecOptions options;
+  if (!codec || !codec->Open(hint, options))
+  {
+    CLog::Log(LOGERROR, "Unsupported video codec");
+    return false;
+  }
+
+  //todo  open vdec
+  if (m_messageQueue.IsInited())
+  {
+    SendMessage(std::make_shared<CDVDMsgVideoCodecChangeHi>(hint, codec), 0);
+    //m_messageQueue.Put(new CDVDMsgVideoCodecChangeHi(hint, codec), 0);
+  }
+  else
+  {
+    OpenStream(hint, codec);
+    CLog::Log(LOGINFO, "Creating video thread");
+    m_messageQueue.Init();
+    Create();
+  }
+
+  CLog::Log(LOGINFO, "CHiPlayerVideo in, Param:\n");
+  CLog::Log(LOGINFO, "|codec              : {}", hint.codec);
+  CLog::Log(LOGINFO, "|type               : {}", hint.type);
+  CLog::Log(LOGINFO, "|uniqueId           : {}", hint.uniqueId);
+  CLog::Log(LOGINFO, "|filename           : {}", hint.filename);
+  CLog::Log(LOGINFO, "|flags              : {}", hint.flags);
+  CLog::Log(LOGINFO, "|dvd                : {}", hint.dvd);
+  CLog::Log(LOGINFO, "|fpsscale           : {}", hint.fpsscale);
+  CLog::Log(LOGINFO, "|fpsrate            : {}", hint.fpsrate);
+  CLog::Log(LOGINFO, "|height             : {}", hint.height);
+  CLog::Log(LOGINFO, "|width              : {}", hint.width);
+  CLog::Log(LOGINFO, "|aspect             : {}", hint.aspect);
+  CLog::Log(LOGINFO, "|vfr                : {}", hint.vfr);
+  CLog::Log(LOGINFO, "|stills             : {}", hint.stills);
+  CLog::Log(LOGINFO, "|level              : {}", hint.level);
+  CLog::Log(LOGINFO, "|profile            : {}", hint.profile);
+  CLog::Log(LOGINFO, "|ptsinvalid         : {}", hint.ptsinvalid);
+  CLog::Log(LOGINFO, "|orientation        : {}", hint.orientation);
+  CLog::Log(LOGINFO, "|bitsperpixel       : {}", hint.bitsperpixel);
+  CLog::Log(LOGINFO, "|forced_aspect      : {}", hint.forced_aspect);
+
+  return true;
+}
+
+void CHiPlayerVideo::OpenStream(CDVDStreamInfo& hint, CDVDVideoCodecHisi* codec)
+{
+  //CLog::Log(LOGDEBUG, "CHiPlayerVideo::OpenStream, code changed");
+
+  m_hints = hint;
+
+  if (hint.fpsrate && hint.fpsscale)
+  {
+    m_fFrameRate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration(
+                                       (double)DVD_TIME_BASE * hint.fpsscale / hint.fpsrate);
+    m_bFpsInvalid = false;
+    m_processInfo.SetVideoFps(m_fFrameRate);
+  }
+  else
+  {
+    m_fFrameRate = 25;
+    m_bFpsInvalid = true;
+    m_processInfo.SetVideoFps(0);
+  }
+
+  if (m_fFrameRate > 120 || m_fFrameRate < 5)
+  {
+    CLog::Log(LOGERROR,
+              "CHiPlayerVideo::OpenStream - Invalid framerate {}, using forced 25fps and just "
+              "trust timestamps",
+              (int)m_fFrameRate);
+    m_fFrameRate = 25;
+  }
+
+  // use aspect in stream if available
+  if (hint.forced_aspect)
+    m_fForcedAspectRatio = hint.aspect;
+  else
+    m_fForcedAspectRatio = 0.0;
+
+  if (m_pVideoCodec)
+  {
+    CLog::Log(LOGINFO, "CHiPlayerVideo::OpenStream  deleting video codec");
+    m_pVideoCodec->ClearPicture(&m_picture);
+    SAFE_DELETE(m_pVideoCodec);
+  }
+
+  //CLog::Log(LOGDEBUG, "CHiPlayerVideo::OpenStream, assign new codec");
+
+  m_pVideoCodec = codec;
+  m_hints = hint;
+  m_stalled = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
+  m_rewindStalled = false;
+  m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+  m_start_pts = DVD_NOPTS_VALUE;
+  m_renderManager.ShowVideo(false);
+
+  m_src_rect.SetRect(0, 0, 0, 0);
+  m_dst_rect.SetRect(0, 0, 0, 0);
+}
+
+void CHiPlayerVideo::CloseStream(bool bWaitForBuffers)
+{
+  CLog::Log(LOGINFO, "CHiPlayerVideo::CloseStream");
+
+  // wait until buffers are empty
+  if (bWaitForBuffers && m_speed > 0)
+  {
+    SendMessage(std::make_shared<CDVDMsg>(CDVDMsg::VIDEO_DRAIN), 0);
+    m_messageQueue.WaitUntilEmpty();
+  }
+
+  m_messageQueue.Abort();
+
+  // wait for decode_video thread to end
+  CLog::Log(LOGINFO, "waiting for video thread to exit");
+
+  m_bAbortOutput = true;
+  StopThread();
+
+  m_messageQueue.End();
+
+  if (m_pVideoCodec)
+  {
+    m_pVideoCodec->ClearPicture(&m_picture);
+    SAFE_DELETE(m_pVideoCodec);
+  }
+
+  CLog::Log(LOGINFO, "CHiPlayerVideo::CloseStream  success");
+  //todo  close vdec
+}
+
+inline void CHiPlayerVideo::SendMessage(std::shared_ptr<CDVDMsg> pMsg, int priority)
+{
+  m_messageQueue.Put(pMsg, priority);
+  m_processInfo.SetLevelVQ(m_messageQueue.GetLevel());
+}
+
+inline void CHiPlayerVideo::SendMessageBack(const std::shared_ptr<CDVDMsg>& pMsg, int priority)
+{
+  m_messageQueue.PutBack(pMsg, priority);
+  m_processInfo.SetLevelVQ(m_messageQueue.GetLevel());
+}
+
+inline void CHiPlayerVideo::FlushMessages()
+{
+  m_messageQueue.Flush();
+  m_processInfo.SetLevelVQ(m_messageQueue.GetLevel());
+}
+
+inline MsgQueueReturnCode CHiPlayerVideo::GetMessage(std::shared_ptr<CDVDMsg>& pMsg,
+                                                     std::chrono::milliseconds timeout,
+                                                     int& priority)
+{
+  MsgQueueReturnCode ret = m_messageQueue.Get(pMsg, timeout, priority);
+  m_processInfo.SetLevelVQ(m_messageQueue.GetLevel());
+  return ret;
+}
+
+void CHiPlayerVideo::Process()
+{
+  CLog::Log(LOGINFO, "running thread: video_thread");
+
+  double pts = 0;
+  double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
+
+  //bool bRequestDrop = false;
+
+  m_rewindStalled = false;
+
+  m_videoStats.Start();
+
+  while (!m_bStop)
+  {
+    // int iQueueTimeOut = (int)(m_stalled ? frametime : frametime * 10) / 1000;
+    auto timeout = std::chrono::duration_cast<std::chrono::milliseconds>(
+        std::chrono::duration<double, std::micro>(m_stalled ? frametime : frametime * 10));
+
+    int iPriority =
+        (m_speed == DVD_PLAYSPEED_PAUSE && m_syncState == IDVDStreamPlayer::SYNC_INSYNC) ? 1 : 0;
+
+    if (m_syncState == IDVDStreamPlayer::SYNC_WAITSYNC)
+      iPriority = 0;
+
+    std::shared_ptr<CDVDMsg> pMsg;
+    MsgQueueReturnCode ret = GetMessage(pMsg, timeout, iPriority);
+
+    //CLog::Log(LOGERROR, "CHiPlayerVideo - GetLevel(): {}, MsgQueueReturnCode :{}", GetLevel(), ret);
+
+    if (MSGQ_IS_ERROR(ret))
+    {
+      CLog::Log(LOGERROR, "Got MSGQ_ABORT or MSGO_IS_ERROR return true");
+      break;
+    }
+    else if (ret == MSGQ_TIMEOUT)
+    {
+      // if we only wanted priority messages, this isn't a stall
+      continue;
+    }
+
+    if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
+    {
+      if (std::static_pointer_cast<CDVDMsgGeneralSynchronize>(pMsg)->Wait(100ms, SYNCSOURCE_VIDEO))
+      {
+        CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::GENERAL_SYNCHRONIZE");
+      }
+      else
+        SendMessage(pMsg, 1); /* push back as prio message, to process other prio messages */
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_RESYNC))
+    {
+      pts = std::static_pointer_cast<CDVDMsgDouble>(pMsg)->m_value;
+      m_syncState = IDVDStreamPlayer::SYNC_INSYNC;
+      m_pVideoCodec->ReSync(pts);
+      m_renderManager.ShowVideo(true);
+
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::GENERAL_RESYNC({})", pts);
+    }
+    else if (pMsg->IsType(CDVDMsg::VIDEO_SET_ASPECT))
+    {
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::VIDEO_SET_ASPECT");
+      m_fForcedAspectRatio = static_cast<float>(*std::static_pointer_cast<CDVDMsgDouble>(pMsg));
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
+    {
+      if (m_pVideoCodec)
+        m_pVideoCodec->Reset();
+
+      if (m_picture.videoBuffer)
+      {
+        m_picture.videoBuffer->Release();
+        m_picture.videoBuffer = nullptr;
+      }
+
+      m_stalled = true;
+      m_start_pts = DVD_NOPTS_VALUE;
+      m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+
+      m_renderManager.ShowVideo(false);
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::GENERAL_RESET");
+    }
+    else if (pMsg->IsType(
+                 CDVDMsg::GENERAL_FLUSH)) // private message sent by (CHiPlayerVideo::Flush())
+    {
+      bool sync = std::static_pointer_cast<CDVDMsgBool>(pMsg)->m_value;
+
+      CLog::Log(LOGINFO, "CHiPlayerVideo - CDVDMsg::GENERAL_FLUSH({})", sync);
+
+      if (m_pVideoCodec)
+        m_pVideoCodec->Reset();
+
+      if (m_picture.videoBuffer)
+      {
+        m_picture.videoBuffer->Release();
+        m_picture.videoBuffer = nullptr;
+      }
+
+      m_stalled = true;
+      m_start_pts = DVD_NOPTS_VALUE;
+
+      if (sync)
+      {
+        m_syncState = IDVDStreamPlayer::SYNC_STARTING;
+        m_renderManager.ShowVideo(false);
+      }
+
+      m_renderManager.DiscardBuffer();
+      FlushMessages();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
+    {
+      if (m_speed != std::static_pointer_cast<CDVDMsgInt>(pMsg)->m_value)
+      {
+        m_speed = std::static_pointer_cast<CDVDMsgInt>(pMsg)->m_value;
+        m_pVideoCodec->SetSpeed(m_speed);
+        CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::PLAYER_SETSPEED {}", m_speed);
+      }
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
+    {
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::GENERAL_STREAMCHANGE");
+      //CDVDMsgVideoCodecChangeHi* msg(static_cast<CDVDMsgVideoCodecChangeHi*>(pMsg));
+      auto msg = std::static_pointer_cast<CDVDMsgVideoCodecChangeHi>(pMsg);
+      OpenStream(msg->m_hints, msg->m_codec);
+      msg->m_codec = NULL;
+    }
+    else if (pMsg->IsType(CDVDMsg::VIDEO_DRAIN))
+    {
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::VIDEO_DRAIN");
+      SignalEndOfStream();
+      {
+        //TODO:need wait end here
+      }
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_PAUSE))
+    {
+      m_paused = std::static_pointer_cast<CDVDMsgBool>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "CHiPlayerVideo - CDVDMsg::GENERAL_PAUSE: {}", m_paused);
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_EOF))
+    {
+      CLog::Log(LOGERROR, "CHiPlayerVideo - CDVDMsg::GENERAL_EOF");
+      SignalEndOfStream();
+    }
+    else if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
+    {
+      DemuxPacket* pPacket = std::static_pointer_cast<CDVDMsgDemuxerPacket>(pMsg)->GetPacket();
+      bool bPacketDrop = std::static_pointer_cast<CDVDMsgDemuxerPacket>(pMsg)->GetPacketDrop();
+
+      //CLog::Log(LOGDEBUG, "CCHiPlayerVideo - CDVDMsg::DEMUXER_PACKET({}), pts:{}, dts:{}", bPacketDrop, pPacket->pts, pPacket->dts);
+
+      if (!bPacketDrop)
+      {
+        m_bAbortOutput = false;
+
+        int iDecoderState = m_pVideoCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts,
+                                                  pPacket->pts, m_bAbortOutput);
+
+        pts = pPacket->pts != DVD_NOPTS_VALUE ? pPacket->pts : pPacket->dts;
+
+        if (iDecoderState == CDVDVideoCodec::VC_PICTURE)
+        {
+          m_pVideoCodec->ClearPicture(&m_picture);
+          if (m_pVideoCodec->GetPicture(&m_picture))
+          {
+
+            if (m_picture.dts == DVD_NOPTS_VALUE && m_picture.pts == DVD_NOPTS_VALUE)
+            {
+              m_picture.pts = pts;
+            }
+            else if (m_picture.pts == DVD_NOPTS_VALUE)
+              m_picture.pts = m_picture.dts;
+
+            if (m_picture.pts != DVD_NOPTS_VALUE)
+            {
+              pts = m_picture.pts;
+            }
+            Output(pts, bPacketDrop);
+          }
+        }
+
+        if (m_start_pts == DVD_NOPTS_VALUE && pts != DVD_NOPTS_VALUE)
+        {
+          m_start_pts = pts;
+        }
+
+        if (m_stalled && m_pVideoCodec->PlayStarted())
+        {
+          CLog::Log(LOGINFO, "CHiPlayerVideo - Stillframe left, switching to normal playback");
+          m_stalled = false;
+        }
+
+        ResolutionUpdateCallBack();
+      }
+      else
+      {
+        ////CLog::Log(LOGDEBUG, "CCHiPlayerVideo - CDVDMsg::DEMUXER_PACKET({}), pts:{}", bPacketDrop, pPacket->pts);
+      }
+
+      if (m_syncState == IDVDStreamPlayer::SYNC_STARTING && m_start_pts != DVD_NOPTS_VALUE
+          /*&& m_pVideoCodec->BufferReady()*/)
+      {
+        m_processInfo.SetVideoDecoderName("hi_video", true);
+        m_syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
+
+        SStartMsg msg;
+        msg.player = VideoPlayer_VIDEO;
+        msg.cachetime = DVD_MSEC_TO_TIME(20);  //! @todo implement
+        msg.cachetotal = DVD_MSEC_TO_TIME(50); //! @todo implement
+        msg.timestamp = m_start_pts;
+        m_messageParent.Put(std::make_shared<CDVDMsgType<SStartMsg>>(CDVDMsg::PLAYER_STARTED, msg));
+        CLog::Log(LOGINFO, "CCHiPlayerVideo PLAYER_STARTED, pts : {}\n", msg.timestamp);
+      }
+    }
+  }
+
+  // we need to let decoder release any picture retained resources.
+  m_pVideoCodec->ClearPicture(&m_picture);
+}
+
+void CHiPlayerVideo::OnStartup()
+{
+  CLog::Log(LOGINFO, "thread start: video_thread");
+}
+
+void CHiPlayerVideo::OnExit()
+{
+  CLog::Log(LOGINFO, "thread end: video_thread");
+}
+
+void CHiPlayerVideo::SetSpeed(int speed)
+{
+  if (m_messageQueue.IsInited())
+    SendMessage(std::make_shared<CDVDMsgInt>(CDVDMsg::PLAYER_SETSPEED, speed), 1);
+  else
+    m_speed = speed;
+
+  CLog::Log(LOGINFO, "CHiPlayerVideo SetSpeed: {}", speed);
+}
+
+void CHiPlayerVideo::Flush(bool sync)
+{
+  CLog::Log(LOGINFO, "CHiPlayerVideo Flush");
+  /* flush using message as this get's called from VideoPlayer thread */
+  /* and any demux packet that has been taken out of queue need to */
+  /* be disposed of before we flush */
+  m_messageQueue.Flush();
+  SendMessage(std::make_shared<CDVDMsgBool>(CDVDMsg::GENERAL_FLUSH, sync), 1);
+  m_bAbortOutput = true;
+  m_renderManager.Flush(false, false);
+}
+
+bool CHiPlayerVideo::HasData() const
+{
+  return m_messageQueue.GetDataSize() > 0 || !m_pVideoCodec->IsEOS();
+}
+
+void CHiPlayerVideo::SignalEndOfStream()
+{
+  m_pVideoCodec->SubmitEOS();
+}
+
+void CHiPlayerVideo::Output(double pts, bool bDropPacket)
+{
+  if (!m_renderManager.IsConfigured())
+  {
+    CLog::Log(LOGINFO, "{} - renderer not configured", __PRETTY_FUNCTION__);
+    return;
+  }
+
+  if (CThread::m_bStop)
+    return;
+
+  CRect SrcRect, DestRect, viewRect;
+  m_renderManager.GetVideoRect(SrcRect, DestRect, viewRect);
+  SetVideoRect(SrcRect, DestRect);
+
+  m_bAbortOutput = false;
+  int buffer = m_renderManager.WaitForBuffer(m_bAbortOutput, 150ms);
+  if (buffer < 0)
+  {
+    double renderPts;
+    int queued, discard;
+    int lateframes;
+    m_renderManager.GetStats(lateframes, renderPts, queued, discard);
+    CLog::Log(
+        LOGINFO,
+        "m_renderManager.WaitForBuffer failed, lateframes:{}, renderPts:{}, queued{}, discard:{} ",
+        lateframes, renderPts, queued, discard);
+    m_renderManager.DiscardBuffer();
+    return;
+  }
+
+  ProcessOverlays(pts);
+
+  VideoPicture picture = {};
+  picture.pts = pts;
+  CVideoBufferHisi* vbuffer = dynamic_cast<CVideoBufferHisi*>(m_videoBufferPool->Get());
+  picture.videoBuffer = vbuffer;
+
+  m_renderManager.AddVideoPicture(picture, m_bAbortOutput,
+                                  EINTERLACEMETHOD::VS_INTERLACEMETHOD_NONE, false);
+}
+
+double CHiPlayerVideo::GetOutputDelay()
+{
+  double time = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET);
+  if (m_fFrameRate)
+    time = (time * DVD_TIME_BASE) / m_fFrameRate;
+  else
+    time = 0.0;
+
+  if (m_speed != 0)
+    time = time * DVD_PLAYSPEED_NORMAL / abs(m_speed);
+
+  printf("CHiPlayerVideo GetOutputDelay {}\n", time);
+
+  return time;
+}
+
+void CHiPlayerVideo::ProcessOverlays(double pts)
+{
+  // remove any overlays that are out of time
+  if (m_syncState == IDVDStreamPlayer::SYNC_INSYNC)
+    m_pOverlayContainer->CleanUp(pts - m_iSubtitleDelay);
+
+  VecOverlays overlays;
+  {
+    CSingleExit lock(*m_pOverlayContainer);
+
+    VecOverlays* pVecOverlays = m_pOverlayContainer->GetOverlays();
+    auto it = pVecOverlays->begin();
+
+    //Check all overlays and render those that should be rendered, based on time and forced
+    //Both forced and subs should check timing
+    while (it != pVecOverlays->end())
+    {
+      std::shared_ptr<CDVDOverlay>& pOverlay = *it++;
+      if (!pOverlay->bForced && !m_bRenderSubs)
+        continue;
+
+      double pts2 = pOverlay->bForced ? pts : pts - m_iSubtitleDelay;
+
+      if ((pOverlay->iPTSStartTime <= pts2 &&
+           (pOverlay->iPTSStopTime > pts2 || pOverlay->iPTSStopTime == 0LL)))
+      {
+        if (pOverlay->IsOverlayType(DVDOVERLAY_TYPE_GROUP))
+          overlays.insert(overlays.end(),
+                          static_cast<CDVDOverlayGroup&>(*pOverlay).m_overlays.begin(),
+                          static_cast<CDVDOverlayGroup&>(*pOverlay).m_overlays.end());
+        else
+          overlays.push_back(pOverlay);
+      }
+    }
+
+    for (it = overlays.begin(); it != overlays.end(); ++it)
+    {
+      double pts2 = (*it)->bForced ? pts : pts - m_iSubtitleDelay;
+      m_renderManager.AddOverlay(*it, pts2);
+    }
+  }
+}
+
+std::string CHiPlayerVideo::GetStereoMode()
+{
+  std::string stereo_mode;
+
+  switch (CMediaSettings::GetInstance().GetDefaultVideoSettings().m_StereoMode)
+  {
+    case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+      stereo_mode = "left_right";
+      break;
+    case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+      stereo_mode = "top_bottom";
+      break;
+    default:
+      stereo_mode = m_hints.stereo_mode;
+      break;
+  }
+
+  if (CMediaSettings::GetInstance().GetDefaultVideoSettings().m_StereoInvert)
+    stereo_mode = GetFlagsStereoMode(stereo_mode);
+
+  return stereo_mode;
+}
+
+std::string CHiPlayerVideo::GetPlayerInfo()
+{
+  std::ostringstream s;
+  s << "vq:" << std::setw(2) << std::min(99, m_processInfo.GetLevelVQ()) << "%";
+  s << ", Mb/s:" << std::fixed << std::setprecision(2)
+    << (double)GetVideoBitrate() / (1024.0 * 1024.0);
+  s << ", fr:" << std::fixed << std::setprecision(3) << m_fFrameRate;
+
+  return s.str();
+}
+
+int CHiPlayerVideo::GetVideoBitrate()
+{
+  return (int)m_videoStats.GetBitrate();
+}
+
+double CHiPlayerVideo::GetCurrentPts()
+{
+  CLog::Log(LOGINFO, "GetCurrentPts");
+
+  if (m_stalled)
+    return DVD_NOPTS_VALUE;
+
+  return m_pVideoCodec->GetCurrentPts();
+}
+
+void CHiPlayerVideo::ResolutionUpdateCallBack()
+{
+  if (m_renderManager.IsConfigured())
+  {
+    ////CLog::Log(LOGDEBUG, "%s - renderer configured", __PRETTY_FUNCTION__);
+    return;
+  }
+
+  uint32_t width = m_hints.width;
+  uint32_t height = m_hints.height;
+  //	float framerate = m_fFrameRate;
+  float display_aspect = 0.0f;
+
+  RESOLUTION res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
+  uint32_t video_width = CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenWidth;
+  uint32_t video_height = CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenHeight;
+
+  //ERenderFormat format = RENDER_FMT_BYPASS;
+
+  /* figure out steremode expected based on user settings and hints */
+  unsigned flags = GetFlagsStereoMode(GetStereoMode());
+
+  if (m_bAllowFullscreen)
+  {
+    flags |= CONF_FLAGS_FULLSCREEN;
+    m_bAllowFullscreen = false; // only allow on first configure
+  }
+
+  unsigned int iDisplayWidth = width;
+  unsigned int iDisplayHeight = height;
+
+  /* use forced aspect if any */
+  if (m_fForcedAspectRatio != 0.0f)
+    iDisplayWidth = (int)(iDisplayHeight * m_fForcedAspectRatio);
+  else if (display_aspect != 0.0f)
+    iDisplayWidth = (int)(iDisplayHeight * display_aspect);
+
+  //m_fFrameRate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration((double)DVD_TIME_BASE / framerate);
+  m_processInfo.SetVideoFps(m_fFrameRate);
+  m_processInfo.SetVideoDimensions(width, height);
+  m_processInfo.SetVideoDAR((float)iDisplayWidth / (float)iDisplayHeight);
+  m_processInfo.SetVideoStereoMode(m_hints.stereo_mode);
+
+  CLog::Log(LOGINFO, "{} - change configuration, framerate:{}, orientation :{}",
+            __PRETTY_FUNCTION__, m_fFrameRate, m_hints.orientation);
+
+  VideoPicture picture = {};
+  picture.iWidth = width;
+  picture.iHeight = height;
+  picture.iDisplayWidth = iDisplayWidth;
+  picture.iDisplayHeight = iDisplayHeight;
+
+  CVideoBufferHisi* buffer = dynamic_cast<CVideoBufferHisi*>(m_videoBufferPool->Get());
+  picture.videoBuffer = buffer;
+
+  if (!m_renderManager.Configure(picture, m_fFrameRate, m_hints.orientation))
+  {
+    CLog::Log(LOGERROR, "{} - failed to configure renderer", __PRETTY_FUNCTION__);
+    return;
+  }
+
+  m_src_rect.SetRect(0, 0, 0, 0);
+  m_dst_rect.SetRect(0, 0, 0, 0);
+}
+
+void CHiPlayerVideo::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
+{
+  CRect SrcRect = InSrcRect, DestRect = InDestRect;
+  unsigned flags = GetFlagsStereoMode(GetStereoMode());
+  RENDER_STEREO_MODE video_stereo_mode =
+      (flags & CONF_FLAGS_STEREO_MODE_SBS)   ? RENDER_STEREO_MODE_SPLIT_VERTICAL
+      : (flags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL
+                                             : RENDER_STEREO_MODE_OFF;
+  bool stereo_invert = (flags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
+
+  RENDER_STEREO_MODE display_stereo_mode =
+      CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
+
+  // ignore video stereo mode when 3D display mode is disabled
+  if (display_stereo_mode == RENDER_STEREO_MODE_OFF)
+    video_stereo_mode = RENDER_STEREO_MODE_OFF;
+
+  // fix up transposed video
+  if (m_hints.orientation == 90 || m_hints.orientation == 270)
+  {
+    float newWidth, newHeight;
+    float aspectRatio = m_renderManager.GetAspectRatio();
+    // clamp width if too wide
+    if (DestRect.Height() > DestRect.Width())
+    {
+      newWidth = DestRect.Width(); // clamp to the width of the old dest rect
+      newHeight = newWidth * aspectRatio;
+    }
+    else // else clamp to height
+    {
+      newHeight = DestRect.Height(); // clamp to the height of the old dest rect
+      newWidth = newHeight / aspectRatio;
+    }
+
+    // calculate the center point of the view and offsets
+    float centerX = DestRect.x1 + DestRect.Width() * 0.5f;
+    float centerY = DestRect.y1 + DestRect.Height() * 0.5f;
+    float diffX = newWidth * 0.5f;
+    float diffY = newHeight * 0.5f;
+
+    DestRect.x1 = centerX - diffX;
+    DestRect.x2 = centerX + diffX;
+    DestRect.y1 = centerY - diffY;
+    DestRect.y2 = centerY + diffY;
+  }
+
+  // check if destination rect or video view mode has changed
+  if (!(m_dst_rect != DestRect) && !(m_src_rect != SrcRect) &&
+      m_video_stereo_mode == video_stereo_mode && m_display_stereo_mode == display_stereo_mode &&
+      m_StereoInvert == stereo_invert)
+    return;
+  /*
+	if(m_src_rect != SrcRect)
+		//CLog::Log(LOGDEBUG, "m_src_rect ({},{},{},{}) SrcRect({},{},{},{})",
+					(int)m_src_rect.x1, (int)m_src_rect.y1, (int)m_src_rect.x2, (int)m_src_rect.y2,
+					(int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2);
+
+	if(m_dst_rect != DestRect)
+		//CLog::Log(LOGDEBUG, "m_dst_rect ({},{},{},{}) DestRect({},{},{},{})",
+					(int)m_dst_rect.x1, (int)m_dst_rect.y1, (int)m_dst_rect.x2, (int)m_dst_rect.y2,
+					(int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2);
+
+	if(m_video_stereo_mode != video_stereo_mode)
+		//CLog::Log(LOGDEBUG, "m_video_stereo_mode ({} ) video_stereo_mode({} )",
+					(int)m_video_stereo_mode, (int)video_stereo_mode);
+
+	if(m_display_stereo_mode != display_stereo_mode)
+		//CLog::Log(LOGDEBUG, "m_display_stereo_mode ({} ) display_stereo_mode({} )",
+					(int)m_display_stereo_mode, (int)display_stereo_mode);
+
+	if(m_StereoInvert != stereo_invert)
+		//CLog::Log(LOGDEBUG, "m_StereoInvert ({} ) stereo_invert({} )",
+	  				(int)m_StereoInvert, (int)stereo_invert);
+*/
+  /*CLog::Log(LOGINFO, "CHiPlayerVideo::%s {},{},{},{} -> {},{},{},{} ({},{},{},{},%s)", __func__,
+      	(int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2,
+      	(int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2,
+      	video_stereo_mode, display_stereo_mode, m_processInfo.GetVideoSettings().m_StereoInvert, CServiceBroker::GetWinSystem().GetGfxContext().GetStereoView(), CHiPlayerVideo::GetStereoMode().c_str());*/
+
+  m_src_rect = SrcRect;
+  m_dst_rect = DestRect;
+  m_video_stereo_mode = video_stereo_mode;
+  m_display_stereo_mode = display_stereo_mode;
+  m_StereoInvert = stereo_invert;
+
+  // might need to scale up m_dst_rect to display size as video decodes
+  // to separate video plane that is at display size.
+  RESOLUTION res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
+  CRect gui(0, 0, CDisplaySettings::GetInstance().GetResolutionInfo(res).iWidth,
+            CDisplaySettings::GetInstance().GetResolutionInfo(res).iHeight);
+  CRect display(0, 0, CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenWidth,
+                CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenHeight);
+
+  if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  {
+    float width = DestRect.x2 - DestRect.x1;
+    DestRect.x1 *= 2.0f;
+    DestRect.x2 = DestRect.x1 + 2.0f * width;
+  }
+  else if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  {
+    float height = DestRect.y2 - DestRect.y1;
+    DestRect.y1 *= 2.0f;
+    DestRect.y2 = DestRect.y1 + 2.0f * height;
+  }
+
+  if (gui != display)
+  {
+    float xscale = display.Width() / gui.Width();
+    float yscale = display.Height() / gui.Height();
+    DestRect.x1 *= xscale;
+    DestRect.x2 *= xscale;
+    DestRect.y1 *= yscale;
+    DestRect.y2 *= yscale;
+  }
+
+  HisiAvDecoder::GetInstance()->VideoSetRect(DestRect.x1, DestRect.y1, DestRect.Width(),
+                                             DestRect.Height());
+  //m_omxVideo.SetVideoRect(SrcRect, DestRect, m_video_stereo_mode, m_display_stereo_mode, m_StereoInvert);
+}
diff --git a/xbmc/cores/hiplayer/HiPlayerVideo.h b/xbmc/cores/hiplayer/HiPlayerVideo.h
new file mode 100644
index 0000000000..a7eceb1f9f
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiPlayerVideo.h
@@ -0,0 +1,159 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDClock.h"
+#include "DVDCodecs/Video/DVDVideoCodec.h"
+#include "DVDMessageQueue.h"
+#include "DVDOverlayContainer.h"
+#include "DVDStreamInfo.h"
+#include "IVideoPlayer.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "rendering/RenderSystem.h"
+#include "threads/Thread.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/BitstreamStats.h"
+#include "utils/Geometry.h"
+
+#include <atomic>
+
+class CVideoBufferPoolHisi;
+class CDVDVideoCodecHisi;
+
+class CHiPlayerVideo : public CThread, public IDVDStreamPlayerVideo
+{
+public:
+  CHiPlayerVideo(CDVDClock* pClock,
+                 CDVDOverlayContainer* pOverlayContainer,
+                 CDVDMessageQueue& parent,
+                 CRenderManager& renderManager,
+                 CProcessInfo& processInfo);
+
+  virtual ~CHiPlayerVideo();
+
+  bool OpenStream(CDVDStreamInfo hint) override;
+  void CloseStream(bool bWaitForBuffers) override;
+
+  void Flush(bool sync);
+  bool AcceptsData() const
+  {
+    return !m_messageQueue.IsFull();
+  }
+  bool HasData() const;
+  bool IsInited() const
+  {
+    return m_messageQueue.IsInited();
+  }
+  void SendMessage(std::shared_ptr<CDVDMsg> pMsg, int priority = 0) override;
+  void FlushMessages() override;
+
+  void EnableSubtitle(bool bEnable)
+  {
+    m_bRenderSubs = bEnable;
+  }
+  bool IsSubtitleEnabled()
+  {
+    return m_bRenderSubs;
+  }
+  double GetSubtitleDelay()
+  {
+    return m_iSubtitleDelay;
+  }
+  void SetSubtitleDelay(double delay)
+  {
+    m_iSubtitleDelay = delay;
+  }
+  bool IsStalled() const override
+  {
+    return m_stalled;
+  }
+  bool IsRewindStalled() const override
+  {
+    return m_rewindStalled;
+  }
+  double GetCurrentPts();
+  double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
+  std::string GetPlayerInfo();
+  int GetVideoBitrate();
+  std::string GetStereoMode();
+  void SetSpeed(int iSpeed);
+
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
+
+  void OpenStream(CDVDStreamInfo& hint, CDVDVideoCodecHisi* codec);
+  void ProcessOverlays(double pts);
+  void ResolutionUpdateCallBack();
+  void Output(double pts, bool bDropPacket);
+  void SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect);
+  void SignalEndOfStream();
+
+  void SendMessageBack(const std::shared_ptr<CDVDMsg>& pMsg, int priority = 0);
+  MsgQueueReturnCode GetMessage(std::shared_ptr<CDVDMsg>& pMsg,
+                                std::chrono::milliseconds timeout,
+                                int& priority);
+
+  CDVDStreamInfo m_hints;
+
+  std::shared_ptr<CVideoBufferPoolHisi> m_videoBufferPool;
+
+  int m_speed;
+
+  bool m_bRenderSubs;
+  bool m_bAllowFullscreen;
+  bool m_paused;
+  bool m_bFpsInvalid; // needed to ignore fps (e.g. dvd stills)
+
+  float m_fForcedAspectRatio;
+
+  double m_fFrameRate; //framerate of the video currently playing
+  double m_iSubtitleDelay;
+
+  bool m_stalled;
+  std::atomic_bool m_rewindStalled;
+  std::atomic_bool m_bAbortOutput;
+
+  BitstreamStats m_videoStats;
+
+  CDVDMessageQueue m_messageQueue;
+  CDVDMessageQueue& m_messageParent;
+
+  CRenderManager& m_renderManager;
+
+  CDVDOverlayContainer* m_pOverlayContainer;
+
+  CBitstreamConverter* m_bitstream;
+
+  IDVDStreamPlayer::ESyncState m_syncState;
+
+  CDVDVideoCodecHisi* m_pVideoCodec;
+
+  CRect m_src_rect;
+  CRect m_dst_rect;
+  RENDER_STEREO_MODE m_video_stereo_mode;
+  RENDER_STEREO_MODE m_display_stereo_mode;
+  bool m_StereoInvert;
+  double m_start_pts;
+
+  VideoPicture m_picture;
+};
diff --git a/xbmc/cores/hiplayer/HiVdec.cpp b/xbmc/cores/hiplayer/HiVdec.cpp
new file mode 100644
index 0000000000..d09ae38044
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiVdec.cpp
@@ -0,0 +1,590 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiVdec.h"
+
+#include "DynamicDll.h"
+#include "cores/VideoPlayer/DVDClock.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "cores/hiplayer/HiDecoder.h"
+
+#include "system.h"
+//#include "guilib/GraphicContext.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "settings/Settings.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+//#include "utils/SysfsUtils.h"
+#include "threads/SingleLock.h"
+#include "utils/XTimeUtils.h"
+
+extern "C"
+{
+#include "libavutil/avutil.h"
+} // extern "C"
+
+#include <functional>
+#include <queue>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <vector>
+
+#include <fcntl.h>
+#include <linux/videodev2.h>
+#include <semaphore.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+// amcodec include
+
+/*************************************************************************/
+#define __MODULE_NAME__ "DVDVideoCodecHisi"
+
+//#define DEBUG_
+#ifdef DEBUG_
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+    CLog::Log(LOGERROR, "[{}:{}]" fmt, __FUNCTION__, __LINE__, ##args);                            \
+  } while (0)
+#else
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+  } while (0)
+#endif
+#define HISI_INFO(fmt, args...)                                                                    \
+  do                                                                                               \
+  {                                                                                                \
+    CLog::Log(LOGINFO, "[{}:{}]" fmt, __FUNCTION__, __LINE__, ##args);                             \
+  } while (0)
+
+/*************************************************************************/
+
+using namespace std::chrono_literals;
+/*************************************************************************/
+
+/*************************************************************************/
+
+CHisiVdec::CHisiVdec()
+    : CThread("CHisiVdec")
+{
+  m_opened = false;
+
+  m_extradata = NULL;
+  m_extrasize = 0;
+
+  m_header = NULL;
+  m_headersize = 0;
+
+  hwDec = HisiAvDecoder::GetInstance();
+}
+
+CHisiVdec::~CHisiVdec()
+{
+  StopThread();
+}
+
+bool CHisiVdec::OpenDecoder(CDVDStreamInfo& hints)
+{
+  m_mode = VIDEO_MODE_NORMAL;
+  m_zoom = -1;
+  m_contrast = -1;
+  m_brightness = -1;
+  m_hints = hints;
+  m_extraneed = true;
+
+  m_dst_rect.SetRect(0, 0, 0, 0);
+
+  CLog::Log(LOGNOTICE, "CHisiVdec::OpenDecoder in, Param:\n");
+  CLog::Log(LOGNOTICE, "\t|codec        : {}", hints.codec);
+  CLog::Log(LOGNOTICE, "\t|type         : {}", hints.type);
+  CLog::Log(LOGNOTICE, "\t|uniqueId     : {}", hints.uniqueId);
+  CLog::Log(LOGNOTICE, "\t|filename     : {}", hints.filename);
+  CLog::Log(LOGNOTICE, "\t|flags        : {}", hints.flags);
+  CLog::Log(LOGNOTICE, "\t|dvd          : {}", hints.dvd);
+  CLog::Log(LOGNOTICE, "\t|fpsscale     : {}", hints.fpsscale);
+  CLog::Log(LOGNOTICE, "\t|fpsrate      : {}", hints.fpsrate);
+  CLog::Log(LOGNOTICE, "\t|vfr          : {}", hints.vfr);
+  CLog::Log(LOGNOTICE, "\t|stills       : {}", hints.stills);
+  CLog::Log(LOGNOTICE, "\t|height       : {}", hints.height);
+  CLog::Log(LOGNOTICE, "\t|width        : {}", hints.width);
+  CLog::Log(LOGNOTICE, "\t|aspect       : {:f}", hints.aspect);
+  CLog::Log(LOGNOTICE, "\t|level        : {}", hints.level);
+  CLog::Log(LOGNOTICE, "\t|profile      : {}", hints.profile);
+  CLog::Log(LOGNOTICE, "\t|ptsinvalid   : {}", hints.ptsinvalid);
+  CLog::Log(LOGNOTICE, "\t|orientation  : {}", hints.orientation);
+  CLog::Log(LOGNOTICE, "\t|bitsperpixel : {}", hints.bitsperpixel);
+
+  m_extradata = (unsigned char*)malloc(hints.extradata.GetSize());
+  m_extrasize = hints.extradata.GetSize();
+  memcpy(m_extradata, hints.extradata.GetData(), m_extrasize);
+
+  SetHeader();
+
+  CLog::Log(LOGNOTICE, "CHisiVdec::OpenDecoder extra size %d", m_extrasize);
+
+  // handle video rate
+  if (hints.fpsrate > 0 && hints.fpsscale != 0)
+  {
+    // then ffmpeg avg_frame_rate next
+    m_video_rate = 0.5f + (float)UNIT_FREQ * hints.fpsscale / hints.fpsrate;
+  }
+
+  // check for 1920x1080, interlaced, 25 fps
+  // incorrectly reported as 50 fps (yes, video_rate == 1920)
+  if (hints.width == 1920 && m_video_rate == 1920)
+  {
+    //CLog::Log(LOGNOTICE, "CHisiVdec::OpenDecoder video_rate exception");
+    m_video_rate = 0.5f + (float)UNIT_FREQ * 1001 / 25000;
+  }
+
+  // check for SD h264 content incorrectly reported as 60 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720 && m_video_rate == 1602)
+  {
+    //CLog::Log(LOGNOTICE, "CHisiVdec::OpenDecoder video_rate exception");
+    m_video_rate = 0.5f + (float)UNIT_FREQ * 1001 / 24000;
+  }
+
+  // check for SD h264 content incorrectly reported as some form of 30 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720)
+  {
+    if (m_video_rate >= 3200 && m_video_rate <= 3210)
+    {
+      //CLog::Log(LOGNOTICE, "CHisiVdec::OpenDecoder video_rate exception");
+      m_video_rate = 0.5f + (float)UNIT_FREQ * 1001 / 24000;
+    }
+  }
+
+  //   CLog::Log(LOGNOTICE, "%s: new frame_rate(%lf), video_rate(%d)", __MODULE_NAME__,
+  //             hints.fpsscale == 0 ? 0 : (double)hints.fpsrate / hints.fpsscale, m_video_rate);
+
+  //   CLog::Log(LOGNOTICE, "Update Current resolution %d,%d,%s,%s,%s\n",
+  //             CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth,
+  //             CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight,
+  //             CDisplaySettings::GetInstance().GetCurrentResolutionInfo().strMode.c_str(),
+  //             CDisplaySettings::GetInstance().GetCurrentResolutionInfo().strId.c_str(),
+  //             CDisplaySettings::GetInstance().GetCurrentResolutionInfo().strOutput.c_str());
+
+  if (hwDec->VideoOpen(hints) == false)
+  {
+    HISI_INFO("OpenVideo return falied");
+    return false;
+  }
+
+  HISI_INFO("OpenDecoder success");
+
+  Create();
+
+  m_opened = true;
+
+  return m_opened;
+}
+
+void CHisiVdec::CloseDecoder()
+{
+  m_opened = false;
+
+  StopThread();
+
+  hwDec->VideoClose();
+
+  SAFE_DELETE(m_extradata);
+  SAFE_DELETE(m_header);
+
+  //CLog::Log(LOGNOTICE, "CHisiVdec::CloseDecoder");
+}
+
+void CHisiVdec::Reset()
+{
+  //CLog::Log(LOGNOTICE, "CHisiVdec::Reset!");
+
+  if (!m_opened)
+    return;
+
+  m_extraneed = true;
+
+  //SetHeader();
+  m_ptsQueue.clear();
+  hwDec->VideoReset();
+}
+
+void CHisiVdec::ReSync(double pts)
+{
+  //CLog::Log(LOGNOTICE, "CHisiVdec::ReSync!");
+
+  if (!m_opened)
+    return;
+
+  pts = pts < 0 ? 0.0 : pts;
+
+  m_extraneed = true;
+
+  SetHeader();
+  m_ptsQueue.clear();
+  hwDec->VideoReSync(PTS_US_TO_MS(pts));
+}
+
+CDVDVideoCodec::VCReturn CHisiVdec::Decode(
+    uint8_t* pData, size_t iSize, double dts, double pts, std::atomic_bool& abort)
+{
+  if (!m_opened)
+    return CDVDVideoCodec::VC_ERROR;
+
+  unsigned int package_pts_ms = 0;
+  unsigned int package_dts_ms = 0;
+
+  if (m_extraneed)
+  {
+    hwDec->VideoWrite((uint8_t*)m_hints.extradata.GetData(), m_hints.extradata.GetSize(), 0);
+    m_extraneed = false;
+  }
+
+  if (pData)
+  {
+    package_dts_ms = (dts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : PTS_US_TO_MS(dts);
+    package_pts_ms = (pts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : PTS_US_TO_MS(pts);
+
+    if (pts == DVD_NOPTS_VALUE && dts != DVD_NOPTS_VALUE)
+    {
+      package_pts_ms = package_dts_ms;
+      //HISI_TRACE("fix pts , pts %u, dts:%u",package_pts_ms, package_dts_ms);
+    }
+
+    /*HISI_TRACE( "HisiCodec::Decode:  dts(%.1f) pts(%.1f), pts:%u, dts:%u, DVD_NOPTS_VALUE:%u, bool check:%d,%d",  dts, pts, package_pts_ms,package_dts_ms,
+		DVD_NOPTS_VALUE,(pts == DVD_NOPTS_VALUE), (dts == DVD_NOPTS_VALUE));*/
+
+    // some formats need header/data tweaks.
+    // the actual write occurs once in write_av_packet
+    // and is controlled by am_pkt.newflag.
+    //set_header_info(am_private);
+
+    // loop until we write all into codec, am_pkt.isvalid
+    // will get set to zero once everything is consumed.
+    // PLAYER_SUCCESS means all is ok, not all bytes were written.
+    while (m_opened && !abort)
+    {
+      if (hwDec->VideoBufferFull())
+      {
+        KODI::TIME::Sleep(10ms);
+        continue;
+      }
+
+      if (m_headersize != 0)
+      {
+        bool ret = hwDec->VideoWriteEx(m_header, m_headersize, package_pts_ms, false, false);
+        ret |= hwDec->VideoWriteEx(pData, iSize, package_pts_ms, true, true);
+
+        if (!ret)
+        {
+          KODI::TIME::Sleep(10ms);
+          continue;
+        }
+      }
+      else
+      {
+        bool ret = hwDec->VideoWrite(pData, iSize, package_pts_ms);
+        if (!ret)
+        {
+          KODI::TIME::Sleep(10ms);
+          continue;
+        }
+      }
+
+      break;
+    }
+  }
+
+  // if we have still frames, demux size will be small
+  // and we need to pre-buffer more.
+
+  CDVDVideoCodec::VCReturn rtn = CDVDVideoCodec::VC_NONE;
+  // keep hw buffered demux above 1 second
+  if (!hwDec->VideoBufferFull())
+    rtn = CDVDVideoCodec::VC_BUFFER;
+
+  // wait until we get a new frame or 25ms,
+  if (m_ptsQueue.size() == 0)
+    m_ready_event.Wait(25ms);
+
+  if (m_ptsQueue.size() > 0)
+  {
+    CSingleExit lock(m_ptsQueueMutex);
+    m_ptsQueue.pop_front();
+    rtn = CDVDVideoCodec::VC_PICTURE;
+  }
+
+  //   HISI_TRACE("CHisiVdec::Decode : %d, pts:%d\n", rtn, package_pts_ms);
+  return rtn;
+}
+
+bool CHisiVdec::GetFramePts(int& pts)
+{
+  return hwDec->VideoFramePts(pts);
+}
+
+bool CHisiVdec::PlayStarted()
+{
+  return hwDec->VideoPlayStarted();
+}
+
+bool CHisiVdec::BufferFull()
+{
+  return hwDec->VideoBufferFull();
+}
+
+bool CHisiVdec::BufferReady()
+{
+  return hwDec->VideoBufferReady();
+}
+
+double CHisiVdec::FirstPts()
+{
+  return hwDec->VideoFirstPts();
+}
+
+double CHisiVdec::GetCurrentPts()
+{
+  return hwDec->VideoCurrentPts();
+}
+
+void CHisiVdec::SetHeader()
+{
+  unsigned char vc1_header[] = {0x00, 0x00, 0x01, 0x0d};
+
+  SAFE_DELETE(m_header);
+
+  switch (m_hints.codec)
+  {
+    case AV_CODEC_ID_VC1:
+    {
+      m_headersize = sizeof(vc1_header);
+      m_header = (unsigned char*)malloc(m_headersize);
+      memcpy(m_header, vc1_header, m_headersize);
+    }
+    break;
+    default:
+      m_headersize = 0;
+      break;
+  }
+}
+
+bool CHisiVdec::GetPicture(VideoPicture* pDvdVideoPicture)
+{
+  if (!m_opened)
+    return false;
+
+  //pDvdVideoPicture->iFlags		= 0;
+  //pDvdVideoPicture->format		= RENDER_FMT_HISI;
+  pDvdVideoPicture->iDuration = (double)(m_video_rate * DVD_TIME_BASE) / UNIT_FREQ;
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->pts = hwDec->VideoCurrentPts();
+
+  return true;
+}
+
+void CHisiVdec::SetSpeed(int speed)
+{
+  if (!m_opened)
+  {
+    //CLog::Log(LOGNOTICE, "CHisiVdec::SetSpeed (%d) not ready, store as mspeed %d", speed, m_speed);
+    return;
+  }
+
+  hwDec->VideoSetSpeed(speed);
+
+  CLog::Log(LOGNOTICE, "CHisiVdec::SetSpeed ({})", speed);
+}
+
+int CHisiVdec::GetDataSize()
+{
+  //CLog::Log(LOGNOTICE, "CHisiVdec::GetDataSize");
+
+  return 0;
+}
+
+double CHisiVdec::GetTimeSize()
+{
+  return 0;
+}
+
+void CHisiVdec::Process()
+{
+  //CLog::Log(LOGNOTICE, "CHisiVdec::Process Started");
+
+  while (!m_bStop)
+  {
+    KODI::TIME::Sleep(10ms);
+    {
+      CSingleExit lock(m_ptsQueueMutex);
+      int pts = 0;
+      if (GetFramePts(pts))
+      {
+        m_ptsQueue.push_back(pts);
+        m_ready_event.Set();
+      }
+    }
+  }
+
+  //CLog::Log(LOGNOTICE, "CHisiVdec::Process Stopped");
+}
+#if 0
+void CHisiVdec::ShowMainVideo(const bool show)
+{
+//	HI_UNF_VO_SetWindowEnable(m_hWin, (HI_BOOL)show);
+}
+
+void CHisiVdec::SetVideoZoom(const float zoom)
+{
+
+}
+
+void CHisiVdec::SetVideoContrast(const int contrast)
+{
+	HI_UNF_DISP_SetContrast(m_disp, contrast);
+}
+
+void CHisiVdec::SetVideoBrightness(const int brightness)
+{
+	HI_UNF_DISP_SetBrightness(m_disp, brightness);
+}
+
+void CHisiVdec::SetVideoSaturation(const int saturation)
+{
+	HI_UNF_DISP_SetSaturation(m_disp, saturation);
+}
+
+bool CHisiVdec::SetVideo3dMode(const int mode3d)
+{
+  bool result = true;
+  std::string strId = CSettings::GetInstance().GetString(CSettings::SETTING_VIDEOSCREEN_SCREENMODE);
+  
+  HI_UNF_DISP_3D_E himode3d = HI_UNF_DISP_3D_NONE;
+  HI_UNF_ENC_FMT_E fmt = (HI_UNF_ENC_FMT_E)HIADP_Disp_StrToFmt((HI_CHAR*)strId.c_str()); 
+
+  HI_UNF_DISP_Set3DMode(m_disp, himode3d, fmt);
+
+  return result;
+}
+
+std::string CHisiVdec::GetStereoMode()
+{
+	std::string  stereo_mode;
+
+	switch(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_StereoMode)
+	{
+		case RENDER_STEREO_MODE_SPLIT_VERTICAL:   stereo_mode = "left_right"; break;
+		case RENDER_STEREO_MODE_SPLIT_HORIZONTAL: stereo_mode = "top_bottom"; break;
+		default:                                  stereo_mode = m_hints.stereo_mode; break;
+	}
+
+	if(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_StereoInvert)
+		stereo_mode = RenderManager::GetStereoModeInvert(stereo_mode);
+
+	return stereo_mode;
+}
+#endif
+
+void CHisiVdec::SetFreeRun(const bool freerun)
+{
+}
+
+void CHisiVdec::SubmitEos()
+{
+  hwDec->VideoSubmitEOS();
+}
+
+bool CHisiVdec::EOS()
+{
+  return hwDec->IsEOS();
+}
+
+void CHisiVdec::SetVideoRect(const CRect& SrcRect, const CRect& DestRect)
+{
+#if 0
+  // this routine gets called every video frame
+  // and is in the context of the renderer thread so
+  // do not do anything stupid here.
+    bool update = false;
+	float zoom = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_CustomZoomAmount;
+	if ((int)(zoom * 1000) != (int)(m_zoom * 1000))
+	{
+		m_zoom = zoom;
+	}
+	
+	int contrast = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Contrast;
+	if (contrast != m_contrast)
+	{
+		SetVideoContrast(contrast);
+		m_contrast = contrast;
+	}
+	
+	// video brightness adjustment.
+	int brightness = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Brightness;
+	if (brightness != m_brightness)
+	{
+		SetVideoBrightness(brightness);
+		m_brightness = brightness;
+	}
+
+	// video view mode
+	int view_mode = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode;
+	if (m_view_mode != view_mode)
+	{
+		m_view_mode = view_mode;
+		update = true;
+	}
+
+	// video stereo mode/view.
+	RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
+	if (m_stereo_mode != stereo_mode)
+	{
+		m_stereo_mode = stereo_mode;
+		update = true;
+	}
+	RENDER_STEREO_VIEW stereo_view = g_graphicsContext.GetStereoView();
+	if (m_stereo_view != stereo_view)
+	{
+	// left/right/top/bottom eye,
+	// this might change every other frame.
+	// we do not care but just track it.
+		m_stereo_view = stereo_view;
+	}
+	
+	if(m_VideoRect != DestRect)
+	{
+		m_VideoRect = DestRect;
+		update = true;
+		
+		hwDec->VideoSetRect(DestRect.x1, DestRect.y1, DestRect.Width(), DestRect.Height());
+		CLog::Log(LOGNOTICE, "CHisiVdec::SetVideoRect src %f %f %f %f", SrcRect.x1, SrcRect.y1, SrcRect.x2, SrcRect.y2);
+		CLog::Log(LOGNOTICE, "CHisiVdec::SetVideoRect dst %f %f %f %f", DestRect.x1, DestRect.y1, DestRect.x2, DestRect.y2);
+	}
+	
+    if(!update)
+		return;
+#endif
+}
diff --git a/xbmc/cores/hiplayer/HiVdec.h b/xbmc/cores/hiplayer/HiVdec.h
new file mode 100644
index 0000000000..945872ad07
--- /dev/null
+++ b/xbmc/cores/hiplayer/HiVdec.h
@@ -0,0 +1,112 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HiDecoder.h"
+#include "cores/IPlayer.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "rendering/RenderSystem.h"
+#include "threads/Thread.h"
+
+#include <deque>
+
+class PosixFile;
+typedef std::shared_ptr<PosixFile> PosixFilePtr;
+
+class CHisiVdec : public CThread
+{
+public:
+  CHisiVdec();
+  virtual ~CHisiVdec();
+
+  bool OpenDecoder(CDVDStreamInfo& hints);
+  void CloseDecoder();
+  void Reset();
+  void ReSync(double pts);
+
+  CDVDVideoCodec::VCReturn Decode(
+      uint8_t* pData, size_t size, double dts, double pts, std::atomic_bool& abort);
+
+  bool GetPicture(VideoPicture* pDvdVideoPicture);
+  bool GetFramePts(int& pts);
+  void SetSpeed(int speed);
+  int GetDataSize();
+  double GetTimeSize();
+  void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
+  void SetFreeRun(const bool freerun);
+
+  void SubmitEos();
+  bool EOS();
+  bool PlayStarted();
+
+  bool BufferReady();
+  bool BufferFull();
+  double FirstPts();
+  double GetCurrentPts();
+
+protected:
+  virtual void Process();
+
+private:
+#if 0
+  void          ShowMainVideo(const bool show);
+  void          SetVideoZoom(const float zoom);
+  void          SetVideoContrast(const int contrast);
+  void          SetVideoBrightness(const int brightness);
+  void          SetVideoSaturation(const int saturation);
+  bool          SetVideo3dMode(const int mode3d);
+  std::string   GetStereoMode();
+#endif
+  void SetHeader();
+
+private:
+  bool m_opened;
+  CDVDStreamInfo m_hints;
+  volatile int m_mode;
+
+  CEvent m_ready_event;
+
+  CRect m_dst_rect;
+  CRect m_display_rect;
+  int m_view_mode;
+
+  RENDER_STEREO_MODE m_stereo_mode;
+  RENDER_STEREO_VIEW m_stereo_view;
+
+  float m_zoom;
+  int m_contrast;
+  int m_brightness;
+
+  std::deque<int> m_ptsQueue;
+  CCriticalSection m_ptsQueueMutex;
+
+  unsigned int m_video_rate;
+  unsigned char* m_extradata;
+  unsigned int m_extrasize;
+  bool m_extraneed;
+
+  unsigned char* m_header;
+  unsigned int m_headersize;
+
+  CRect m_VideoRect;
+
+  HisiAvDecoder* hwDec;
+};
diff --git a/xbmc/platform/linux/hisi/CMakeLists.txt b/xbmc/platform/linux/hisi/CMakeLists.txt
new file mode 100644
index 0000000000..a21c4f619c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(SOURCES hi_adp_mpi.c
+            hi_adp_hdmi.c
+            hi_adp_ini.c)
+
+set(HEADERS hi_adp_mpi.h
+            hi_adp_hdmi.h
+            hi_adp_ini.h)
+
+core_add_library(hiadp)
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.AAC.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.AAC.decode.h
new file mode 100644
index 0000000000..b1789eb1b6
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.AAC.decode.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.AAC.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_AAC_H__
+#define __HISI_AUDIO_DECODER_AAC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_AAC_ID 0x001
+
+#define HA_CODEC_AAC_SET_TRANSPORT_TYPE_CMD  ((((HI_U32)HA_AAC_ID) << 16) | 0x1000)
+#define HA_CODEC_AAC_SET_CONFIGRAW_CMD       ((((HI_U32)HA_AAC_ID) << 16) | 0x1001)
+#define FILEREAD_MAX_LAYERS 2
+
+#define HA_CODEC_AAC_GET_CHNANEL_MODE_CMD    ((((HI_U32)HA_AAC_ID) << 16) | 0x1002)
+
+/**
+ * Transport type identifiers.
+ */
+typedef enum
+{
+  HA_TT_UNKNOWN           = -1, /**< Unknown format.            */
+  HA_TT_MP4_RAW           = 0,  /**< "as is" access units (packet based since there is obviously no sync layer) */
+  HA_TT_MP4_ADIF          = 1,  /**< ADIF bitstream format.     */
+  HA_TT_MP4_ADTS          = 2,  /**< ADTS bitstream format.     */
+
+  HA_TT_MP4_LATM_MCP1     = 6,  /**< Audio Mux Elements with muxConfigPresent = 1 */
+  HA_TT_MP4_LATM_MCP0     = 7,  /**< Audio Mux Elements with muxConfigPresent = 0, out of band StreamMuxConfig */
+
+  HA_TT_MP4_LOAS          = 10, /**< Audio Sync Stream.         */
+
+  HA_TT_DRM               = 12, /**< Digital Radio Mondial (DRM30/DRM+) bitstream format. */
+
+  HA_TT_MP1_L1            = 16, /**< MPEG 1 Audio Layer 1 audio bitstream. */
+  HA_TT_MP1_L2            = 17, /**< MPEG 1 Audio Layer 2 audio bitstream. */
+  HA_TT_MP1_L3            = 18, /**< MPEG 1 Audio Layer 3 audio bitstream. */
+
+  HA_TT_RSVD50            = 50 /**< */
+
+} HA_AAC_TRANSPORT_TYPE;
+
+
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_AAC_TRANSPORT_TYPE stType;
+} HA_AAC_SET_TRANSPORT_TYPE_S;
+
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_UCHAR *conf[FILEREAD_MAX_LAYERS];
+    HI_U32 length[FILEREAD_MAX_LAYERS];
+} HA_AAC_SET_CONFIGRAW_S;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_AAC_GET_CHNANEL_MODE_CMD */
+    HI_S32* ps32ChannelConfig;
+} HA_AAC_GET_CHNANEL_MODE_S;
+
+#define HA_AAC_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 8; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_FALSE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_AAC_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.AAC.encode.h b/xbmc/platform/linux/hisi/HA.AUDIO.AAC.encode.h
new file mode 100644
index 0000000000..d316a0a241
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.AAC.encode.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AAC.encode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_ENCODER_AAC_H__
+#define __HISI_AUDIO_ENCODER_AAC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AAC_ID 0x001         
+
+typedef enum
+{
+    AAC_QualityExcellent = 0,
+    AAC_QualityHigh   = 1,
+    AAC_QualityMedium = 2,
+    AAC_QualityLow = 3,
+} AAC_AuQuality;
+
+typedef enum
+{
+    AAC_FORMAT_LC = 0,                  /**< AAC LC */
+    AAC_FORMAT_EAAC = 1,                    /**< eAAC  (HEAAC or AAC+  or aacPlusV1) */
+    AAC_FORMAT_EAACPLUS = 2,            /**< eAAC+ (AAC++ or aacPlusV2) */
+} AAC_AuEncoderFormat;
+
+typedef  struct
+{
+    AAC_AuQuality       quality;
+    AAC_AuEncoderFormat coderFormat;
+    HI_S16          bitsPerSample;
+    HI_S32          sampleRate;    /**< audio file sample rate */
+    HI_S32          bitRate;            /**< encoder bit rate in bits/sec */
+    HI_S16          nChannelsIn;    /**< number of channels on input (1,2) */
+    HI_S16          nChannelsOut;  /**< number of channels on output (1,2) */
+    HI_S16          bandWidth;       /**< targeted audio bandwidth in Hz */
+} AAC_ENC_CONFIG;
+
+#define HA_AAC_GetDefaultConfig(pstConfig) \
+do{ ((AAC_ENC_CONFIG *)(pstConfig))->coderFormat = AAC_FORMAT_LC; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bitsPerSample = 16; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->quality = AAC_QualityHigh; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bitRate = 128000; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->sampleRate = 48000; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bandWidth    = ((AAC_ENC_CONFIG *)(pstConfig))->sampleRate / 2; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->nChannelsIn  = 2; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->nChannelsOut = 2; \
+}while(0)
+
+#define HA_AAC_GetEncDefaultOpenParam(pOpenParam, pstPrvateConfig) \
+do{ HI_U32 inSamplePerFrame; \
+    inSamplePerFrame = 1024; \
+    if ((((AAC_ENC_CONFIG *)pstPrvateConfig)->coderFormat == AAC_FORMAT_EAAC) || (((AAC_ENC_CONFIG *)pstPrvateConfig)->coderFormat == AAC_FORMAT_EAACPLUS)) \
+    { \
+        inSamplePerFrame <<= 1; \
+    } \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = ((AAC_ENC_CONFIG *)pstPrvateConfig)->nChannelsOut; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = ((AAC_ENC_CONFIG *)pstPrvateConfig)->bitsPerSample; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = ((AAC_ENC_CONFIG *)pstPrvateConfig)->sampleRate; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = inSamplePerFrame; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AAC_ENC_CONFIG); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_ENCODER_AAC_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.AC3PASSTHROUGH.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.AC3PASSTHROUGH.decode.h
new file mode 100644
index 0000000000..915450e1e7
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.AC3PASSTHROUGH.decode.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.AC3PASSTHROUGH.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__
+#define __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_AC3PASSTHROUGH_ID 0x0055        
+
+#define HA_AC3PASSTHROUGH_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.AMRNB.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.AMRNB.codec.h
new file mode 100644
index 0000000000..dd4dd1353d
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.AMRNB.codec.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AMRNB.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_AMRNB_H__
+#define __HISI_AUDIO_CODEC_AMRNB_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AMRNB_ID 0x0100        
+
+
+#ifndef AMR_MAGIC_NUMBER
+ #define AMR_MAGIC_NUMBER "#!AMR\n"/*magic number for AMR-NB*/
+#endif
+
+typedef enum
+{
+    AMRNB_MR475 = 0,     /*4.75kbit/s*/
+    AMRNB_MR515,
+    AMRNB_MR59,
+    AMRNB_MR67,
+    AMRNB_MR74,
+    AMRNB_MR795,
+    AMRNB_MR102,
+    AMRNB_MR122,
+    AMRNB_MRDTX,             /*SID mode*/
+    AMRNB_N_MODES                /* number of (SPC) modes */
+} AMRNB_MODE_E;
+
+typedef enum
+{
+    AMRNB_MIME = 0,     /*4.75kbit/s*/
+    AMRNB_IF1,
+    AMRNB_IF2,
+} AMRNB_FORMAT_E;
+
+typedef struct
+{
+    AMRNB_FORMAT_E enFormat;
+
+    AMRNB_MODE_E enMode;
+
+    HI_BOOL bDTX;  /* HI_TRUE=enable dtx, HI_FALSE=disable dtx  */
+} AMRNB_ENCODE_OPENCONFIG_S;
+
+typedef struct
+{
+    AMRNB_FORMAT_E enFormat;
+} AMRNB_DECODE_OPENCONFIG_S;
+
+typedef enum
+{
+    AMRNB_CONFIGCMD_MODE = 0,
+}  AMRNB_CONFIG_COMMAND_E;
+
+/* struct for 
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID * hEncoder, HI_VOID *pstConfigStructure);
+*/
+typedef struct
+{
+    AMRNB_CONFIG_COMMAND_E enCmd;
+
+    HI_VOID *pstPrivateParams;
+} AMRNB_ENCODE_CONFIG_MODE_S;
+
+#define HA_AMRNB_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved  = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 160; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRNB_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+#define HA_AMRNB_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRNB_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_AMRNB_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.AMRWB.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.AMRWB.codec.h
new file mode 100644
index 0000000000..9c94afe1e0
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.AMRWB.codec.h
@@ -0,0 +1,112 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AMRWB.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_AMRWB_H__
+#define __HISI_AUDIO_CODEC_AMRWB_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AMRWB_ID 0x0110
+
+#ifndef AMRWB_MAGIC_NUMBER
+ #define AMRWB_MAGIC_NUMBER "#!AMR-WB\n" /*magic number for AMR-WB*/
+#endif
+
+#if 1
+typedef enum
+{
+    AMRWB_MR66 = 0,                /* AMR-WB 6.60 kbit/s  */
+    AMRWB_MR885,                    /* AMR-WB 8.85 kbit/s  */
+    AMRWB_MR1265,                  /* AMR-WB 12.65 kbit/s */
+    AMRWB_MR1425,                  /* AMR-WB 14.25 kbit/s */
+    AMRWB_MR1585,                  /* AMR-WB 15.85 kbit/s */
+    AMRWB_MR1825,                  /* AMR-WB 18.25 kbit/s */
+    AMRWB_MR1985,                  /* AMR-WB 19.85 kbit/s */
+    AMRWB_MR2305,                  /* AMR-WB 23.05 kbit/s */
+    AMRWB_MR2385                   /* AMR-WB 23.85 kbit/s */
+}AMRWB_MODE_E;
+#endif
+
+typedef enum
+{
+    AMRWB_FORMAT_MIME, 
+    AMRWB_FORMAT_IF2
+} AMRWB_FORMAT_E;
+
+typedef struct
+{
+    AMRWB_FORMAT_E enFormat;
+
+    AMRWB_MODE_E enMode;
+
+    HI_BOOL bDTX;  /* HI_TRUE=enable dtx, HI_FALSE=disable dtx  */
+} AMRWB_ENCODE_OPENCONFIG_S;
+
+typedef struct
+{
+    AMRWB_FORMAT_E enFormat;
+} AMRWB_DECODE_OPENCONFIG_S;
+
+typedef enum
+{
+    AMRWB_CONFIGCMD_MODE = 0,
+}  AMRWB_CONFIG_COMMAND_E;
+
+/* struct for 
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID * hEncoder, HI_VOID *pstConfigStructure);
+*/
+typedef struct
+{
+    AMRWB_CONFIG_COMMAND_E enCmd;
+
+    HI_VOID *pstPrivateParams;
+} AMRWB_ENCODE_CONFIG_MODE_S;
+
+#define HA_AMRWB_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved  = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 16000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 320; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRWB_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+#define HA_AMRWB_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 16000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRWB_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_AMRWB_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.BLURAYLPCM.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.BLURAYLPCM.decode.h
new file mode 100644
index 0000000000..16a583b8cf
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.BLURAYLPCM.decode.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.BLURAYLPCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_BLURAYLPCM_H__
+#define __HISI_AUDIO_DECODER_BLURAYLPCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_BLYRAYLPCM_ID 0x021        
+
+typedef struct  hiHA_BLURAYLPCM_DECODE_OPENCONFIG_S
+{
+    HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+    HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+} HA_BLURAYLPCM_DECODE_OPENCONFIG_S;
+
+#define HA_BLYRAYLPCM_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_BLURAYLPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+        ((HA_BLURAYLPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+
+#define HA_BLYRAYLPCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(HA_BLURAYLPCM_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_BLURAYLPCM_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.COOK.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.COOK.decode.h
new file mode 100644
index 0000000000..2f1bd8849d
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.COOK.decode.h
@@ -0,0 +1,69 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.COOK.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_COOK_H__
+#define __HISI_AUDIO_DECODER_COOK_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_COOK_ID 0x0009        
+
+/*
+ * ra_format_info struct
+ *
+ */
+
+typedef struct  hiRA_FORMAT_INFO_S
+{
+    HI_U32 ulSampleRate;
+    HI_U32 ulActualRate;
+    HI_U16 usBitsPerSample;
+    HI_U16 usNumChannels;
+    HI_U16 usAudioQuality;
+    HI_U16 usFlavorIndex;
+    HI_U32 ulBitsPerFrame;
+    HI_U32 ulGranularity;
+    HI_U32 ulOpaqueDataSize;
+    HI_U8*  pOpaqueData;
+} RA_FORMAT_INFO_S;
+
+
+#define HA_COOK_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+		do { HI_S32 i; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+			 for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+			 { \
+				 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+			 } \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(RA_FORMAT_INFO_S); \
+		} while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_COOK_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12.decode.h
new file mode 100644
index 0000000000..2b57d0f7ac
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12.decode.h
@@ -0,0 +1,332 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYMS12.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYMS12_DECODE_H__
+#define __HA_AUDIO_DOLBYMS12_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define  HA_MS12_ID         (0x2050)
+
+#define  HA_CODEC_MS12_SET_VOLUME_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x1000)
+#define  HA_CODEC_MS12_GET_VOLUME_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x1001)
+#define  HA_CODEC_MS12_SET_DRC_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1002)
+#define  HA_CODEC_MS12_SET_LFE_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1003)
+#define  HA_CODEC_MS12_SET_DMX_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1004)
+#define  HA_CODEC_MS12_SET_DYNSCALE_MODE_CMD      ((((HI_U32)HA_MS12_ID) << 16) | 0x1005)
+#define  HA_CODEC_MS12_SET_AD_BALANCE_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x1006)
+#define  HA_CODEC_MS12_SET_PASSTHROUGH_STATUS_CMD ((((HI_U32)HA_MS12_ID) << 16) | 0x1007)
+#define  HA_CODEC_MS12_SET_MIN_VOLUME_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x1008)
+#define  HA_CODEC_MS12_SET_PTS_MUTE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1009)
+#define  HA_CODEC_MS12_GET_STREAM_INFO_CMD        ((((HI_U32)HA_MS12_ID) << 16) | 0x100A)
+#define  HA_CODEC_MS12_GET_AD_STREAM_INFO_CMD     ((((HI_U32)HA_MS12_ID) << 16) | 0x100B)
+#define  HA_CODEC_MS12_SET_DRC_SCALE_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x100C)
+#define  HA_CODEC_MS12_SET_DUAL_MODE_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x100D)
+#define  HA_CODEC_MS12_SET_SUBSTREAMID_CMD        ((((HI_U32)HA_MS12_ID) << 16) | 0x100E)
+
+/** Define DAP configuration:
+    - 0: No DAP (default)
+    - 1: Content processing only;
+    - 2: Device processing only
+    - 3: Both with two DAP instances
+    - 4: Both with single instance DAP processing */
+typedef enum
+{
+    MS12_DAP_NO_PROC = 0,
+    MS12_DAP_CONTENT_PROC,
+    MS12_DAP_DEVICE_PROC,
+    MS12_DAP_DEVICE_CONTENT_PROC,
+    MS12_DAP_SI_PROC,
+} MS12_DAP_MODE_E;
+
+/** Define input stream type:
+    - 0: Dolby digital (plus) stream (default)
+    - 1: AAC or HEAAC stream
+    - 2: AC4 stream
+    - 3: PCM stream */
+typedef enum
+{
+    MS12_DOLBY_DIGITAL_PLUS = 0,
+    MS12_HEAAC,
+    MS12_AC4,
+    MS12_EXTERNAL_PCM,
+    MS12_MPEG,
+} MS12_INPUT_TYPE_E;
+
+/** Define volume curve type:
+    - 0: Linear curve, up:g(x)=x, down:f(x)=1-x (default)
+    - 1: In cube curve, up:g(x)=x^3, down:f(x)=1-x^3
+    - 2: Out cube curve, up:g(x)=1-(1-x)^3, down:f(x)=(1-x)^3 */
+typedef enum
+{
+    MS12_VOLCURVE_LINEAR = 0,
+    MS12_VOLCURVE_INCUBE,
+    MS12_VOLCURVE_OUTCUBE,
+} MS12_VOLUME_CURVE_E;
+
+/** Define stereo down mix mode:
+    - 0: 2/0 Dolby Surround compatible (Lt/Rt) (default)
+    - 1: 2/0 Stereo without surround
+    - 2: Only HEAAC and AC4 stream are vaild */
+typedef enum
+{
+    MS12_DMX_LTRT = 0,
+    MS12_DMX_LORO,
+    MS12_DMX_ARIB,
+} MS12_STEREODMX_MODE_E;
+
+/** Define decoder compression mode:
+    - 0: Line out mode, used in DMA
+    - 1: RF out mode, used in broadcast or iptv (default) */
+typedef enum
+{
+    MS12_DRC_LINE = 0,
+    MS12_DRC_RF,
+} MS12_DRC_MODE_E;
+
+/** Define LFE Downmixing mode
+     - 0 = Properly downmixes the LFE channel according to the lfemixlevcod parameter
+           when DRC is set to Line mode
+     - 1 = LFE channel is not downmixed when DRC is set to RF mode (default) */
+typedef enum
+{
+    MS12_LFEOUT_OFF = 0,
+    MS12_LFEOUT_ON,
+} MS12_LFEOUT_MODE_E;
+
+/** Define Decoder dual mono mode (Only when <i>acmod</i> is 1/1 (acmod=0))
+     - 0 = Stereo (default)
+     - 1 = Left mono
+     - 2 = Right mono */
+typedef enum
+{
+    MS12_DUAL_STEREO = 0,
+    MS12_DUAL_LEFTMONO,
+    MS12_DUAL_RIGHTMONO,
+} MS12_DUAL_MODE_E;
+
+/** Define stream type:
+    - 0: Dolby digital
+    - 1: Dolby digital plus
+    - 2: Dolby atmos stream
+    - 3: AAC stream
+    - 4: AC4 stream
+    - 5: PCM stream
+    - 6: MP1/MP2/MP3 stream */
+typedef enum
+{
+    MS12_STREAM_DD = 0,
+    MS12_STREAM_DDP,
+    MS12_STREAM_ATMOS,
+    MS12_STREAM_AAC,
+    MS12_STREAM_AC4,
+    MS12_STREAM_PCM,
+    MS12_STREAM_MPEG,
+} MS12_STREAM_TYPE_E;
+
+/** Define Setting and getting volume parameter
+    - enCmd: HA_CODEC_MS12_SET_VOLUME_CMD or HA_CODEC_MS12_GET_VOLUME_CMD
+    - s32VolumedB: -96 ~ 0 (dB)
+    - u32FadeMs: Fade time:0 ~ 60000 (ms) */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_VOLUME_CURVE_E enVolumeCurve;
+    HI_S32 s32VolumedB;
+    HI_U32 u32FadeMs;
+} HA_MS12_VOLUME_S;
+
+/** Define Setting parameter of drc mode
+    - enCmd: HA_CODEC_MS12_SET_DRC_MODE_CMD */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_DRC_MODE_E enDrcMode;
+} HA_MS12_SET_DRC_MODE_S;
+
+/** Define Setting parameter of drc scale
+    - enCmd: HA_CODEC_MS12_SET_DRC_SCALE_CMD */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32DrcCut;
+    HI_U32  u32DrcBoost;
+} HA_MS12_SET_DRC_SCALE_S;
+
+/** Define Setting parameter of lfe mode
+    - enCmd: HA_CODEC_MS12_SET_LFE_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_LFEOUT_MODE_E enLfeMode;
+} HA_MS12_SET_LFE_MODE_S;
+
+/** Define Setting parameter of downmix mode
+    - enCmd: HA_CODEC_SET_DMX_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_STEREODMX_MODE_E enDmxMode;
+} HA_MS12_SET_DMX_MODE_S;
+
+/** Define Setting parameter of dual mode
+    - enCmd: HA_CODEC_MS12_SET_DUAL_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_DUAL_MODE_E enDualMode;
+} HA_MS12_SET_DUAL_MODE_S;
+
+/** Define Setting parameter of dynamic scale mode
+    -enCmd:       HA_CODEC_MS12_SET_DYNSCALE_MODE_CMD
+    -u32DrcCut:   Scale factor for incoming DRC cut value: 0 ~ 100
+    -u32DrcBoost: Scale factor for incoming DRC boost value: 0 ~ 100 */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U16 u32DrcCut;
+    HI_U16 u32DrcBoost;
+} HA_MS12_SET_DYNSCALE_MODE_S;
+
+/** Define Setting parameter of ad balance
+    -enCmd:      HA_CODEC_MS12_SET_AD_BALANCE_CMD
+    -s32Balance: User defined balance between main and associated signal
+                 Value range is between -32 and +32 (in dB)
+                 -32dB indicates main only (mute associated)
+                 +32dB indicates associated only (mute main) */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_S32 s32Balance;
+} HA_MS12_SET_AD_BALANCE_S;
+
+/** Define Setting parameter of pts mute
+    -enCmd:       HA_CODEC_MS12_SET_PTS_MUTE_CMD
+    -u32StartPts: Start mute pts
+    -u32StopPts:  Stop mute pts */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32StartPts;
+    HI_U32 u32StopPts;
+} HA_MS12_SET_PTS_MUTE_S;
+
+/** Define Setting parameter of SubstreamID
+    -enCmd:       HA_CODEC_MS12_SET_SUBSTREAMID_CMD
+    -u32SubStreamID: The ID of SubStream, normally the value is [1, 3] */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32SubStreamID;
+} HA_MS12_SET_SUBSTREAMID_S;
+
+/** Define Getting parameter of stream info
+    -enCmd:         HA_CODEC_MS12_GET_STREAM_INFO_CMD
+    -enStreamType:  Detail stream type
+    -u32Acmod:      Acmod
+                    0  = 1/1 (dual mono)
+                    1  = 1/0 (C)
+                    2  = 2/0 (L, R)
+                    3  = 3/0 (L, R, C)
+                    4  = 2/1 (L, R, l)
+                    5  = 3/1 (L, R, C, l)
+                    6  = 2/2 (L, R, l, r)
+                    7  = 3/2 (L, R, C, l, r)
+                    9  = 2/2/1 (L, R, l, r, Ts)
+                    10 = 3/2/1 (L, R, C, l, r, Ts)
+                    11 = 3/2/1 (L, R, C, l, r, Cvh)
+                    12 = 3/0/2 (L, R, C, Lc, Rc)
+                    13 = 2/2/2 (L, R, l, r, Lw, Rw)
+                    14 = 2/2/2 (L, R, l, r, Lvh, Rvh)
+                    15 = 2/2/2 (L, R, l, r, Lsd, Rsd)
+                    16 = 2/2/2 (L, R, l, r, Lrs, Rrs)
+                    17 = 3/2/2 (L, R, C, l, r, Lc, Rc)
+                    18 = 3/2/2 (L, R, C, l, r, Lw, Rw)
+                    19 = 3/2/2 (L, R, C, l, r, Lvh, Rvh)
+                    20 = 3/2/2 (L, R, C, l, r, Lsd, Rsd)
+                    21 = 3/2/2 (L, R, C, l, r, Lrs, Rrs)
+                    22 = 3/2/2 (L, R, C, l, r, Ts, Cvh)
+    -bLfeExist      Whether LFE is exist
+    -u32BitRate:    Stream bitrate (bps)
+    -u32SampleRate: Stream original sample rate */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_STREAM_TYPE_E enStreamType;
+    HI_U32  u32Acmod;
+    HI_BOOL bLfeExist;
+    HI_U32  u32BitRate;
+    HI_U32  u32SampleRate;
+} HA_MS12_GET_STREAM_INFO_S;
+
+/** Define opening parameter of MS12 decoder
+    -u32DrcCut:   Determines the percentage of application of DRC
+                  attenuation factors for the 2 channel output.0 ~ 100 default: 100
+    -u32DrcBoost: Determines the percentage of application of DRC
+                  boost factors for the 2 channel output. 0 ~ 100 default: 100
+    -s32Balance:  User defined balance between main and associated signal
+                  Value range is between -32 and +32 (in dB)
+                  -32dB indicates main only (mute associated)
+                  +32dB indicates associated only (mute main) */
+typedef struct
+{
+    MS12_INPUT_TYPE_E       enInputType;
+    MS12_DAP_MODE_E         enDapMode;
+    MS12_LFEOUT_MODE_E      enLfeOutMode;
+    MS12_STEREODMX_MODE_E   enDmxMode;
+    MS12_DRC_MODE_E         enDrcMode;
+    HI_U32                  u32DrcCut;
+    HI_U32                  u32DrcBoost;
+    HI_S32                  s32AdBalance;
+} DOLBYMS12_CODEC_OPENCONFIG_S;
+
+#define HA_DOLBYMS12_CodecGetDefaultOpenConfig(pConfigParam) \
+    do { \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enInputType   = MS12_DOLBY_DIGITAL_PLUS; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDapMode     = MS12_DAP_NO_PROC; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enLfeOutMode  = MS12_LFEOUT_ON; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDmxMode     = MS12_DMX_LTRT; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDrcMode     = MS12_DRC_RF; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->u32DrcCut     = 100; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->u32DrcBoost   = 100; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->s32AdBalance  = 0; \
+    } while (0)
+
+#define HA_DOLBYMS12_CodecGetDefaultOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_U32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved    = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate  = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DOLBYMS12_CODEC_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYMS12_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12EXT.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12EXT.decode.h
new file mode 100644
index 0000000000..e3c1e43f41
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYMS12EXT.decode.h
@@ -0,0 +1,318 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYMS12EXT.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYMS12EXT_DECODE_H__
+#define __HA_AUDIO_DOLBYMS12EXT_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+#include "HA.AUDIO.DOLBYMS12.decode.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define  MS12_MAX_STREAM_NUM         (6)
+#define  MS12_MIXER_NUM              (2)
+#define  MS12_MIXER_MAX_SOURCE_NUM   (3)
+
+#define  MS12_SUPPORT_FORMAT_DDP     (1 << 0)
+#define  MS12_SUPPORT_FORMAT_AAC     (1 << 1)
+#define  MS12_SUPPORT_FORMAT_AC4     (1 << 2)
+#define  MS12_SUPPORT_FORMAT_MP3     (1 << 3)
+
+#define  HA_CODEC_MS12_DECODE_FRAME_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x2000)
+#define  HA_CODEC_MS12_ENABLE_DECODE_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x2001)
+#define  HA_CODEC_MS12_ENABLE_MIX_CMD                 ((((HI_U32)HA_MS12_ID) << 16) | 0x2002)
+#define  HA_CODEC_MS12_DROP_FRAME_CMD                 ((((HI_U32)HA_MS12_ID) << 16) | 0x2003)
+#define  HA_CODEC_MS12_SET_STREAM_INDEX_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x2004)
+#define  HA_CODEC_MS12_ADJUST_STRATEGY_CMD            ((((HI_U32)HA_MS12_ID) << 16) | 0x2005)
+#define  HA_CODEC_MS12_RESET_CMD                      ((((HI_U32)HA_MS12_ID) << 16) | 0x2006)
+#define  HA_CODEC_MS12_SET_EOSFLAG_CMD                ((((HI_U32)HA_MS12_ID) << 16) | 0x2007)
+#define  HA_CODEC_MS12_SET_MEDIAVOLATTENUATE_CMD      ((((HI_U32)HA_MS12_ID) << 16) | 0x2008)
+#define  HA_CODEC_MS12_SET_PROCINFO_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x2009)
+#define  HA_CODEC_MS12_SET_MIXER1_VOLUME_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x200A)
+#define  HA_CODEC_MS12_GET_CAPABILITY_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x200B)
+#define  HA_CODEC_MS12_SET_DEC_POLICY_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x200C)
+#define  HA_CODEC_MS12_SOFTRESET_CMD                  ((((HI_U32)HA_MS12_ID) << 16) | 0x200D)
+#define  HA_CODEC_MS12_SET_PES_DATA_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x200E)
+#define  HA_CODEC_MS12_SET_INPUTTYPE_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x200F)
+#define  HA_CODEC_MS12_SET_ATMOSLOCK_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x2010)
+#define  HA_CODEC_MS12_SET_SOURCEMUTE_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x2011)
+#define  HA_CODEC_MS12_SET_SOURCEPRESCALE_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x2012)
+
+typedef enum
+{
+    MS11_CONFIG,
+    MS12_CONFIG_B,
+    MS12_CONFIG_D,
+} MS12_CONFIG_E;
+
+typedef enum
+{
+    MS12_STREAM_IDLE = 0,
+    MS12_STREAM_RUNNING,
+    MS12_STREAM_PAUSE,
+    MS12_STREAM_STOP,
+    MS12_STREAM_ACTIVATE,
+} MS12_STREAM_STATE_E;
+
+/** Define Dec Policy mode
+    - 0: Only dec main
+    - 1: Only dec assoc
+    - 2: dec dual */
+typedef enum
+{
+    MS12_DEC_MAIN = 0,
+    MS12_DEC_ASSOC,
+    MS12_DEC_DUAL,
+} MS12_DEC_POLICY_E;
+
+typedef struct
+{
+    HI_U32 u32TryCnt;
+    HI_U32 u32OkCnt;
+    HI_U32 u32PriUnderRunCnt;
+    HI_U32 u32SecUnderRunCnt;
+    HI_U32 u32ThirdUnderRunCnt;
+    HI_U32 u32InBufBytes[MS12_MIXER_MAX_SOURCE_NUM];
+} MS12_MIXER_PROC_S;
+
+/** Define proc info of stream */
+typedef struct
+{
+    MS12_STREAM_TYPE_E enStreamType;
+    HI_BOOL            bDecodeEnable;
+    HI_BOOL            bMixEnable;
+    HI_BOOL            bLfeExist;
+    HI_U32             u32StreamLeftBytes;
+    HI_U32             u32SampleRate;
+    HI_U32             u32BitRate;
+    HI_U32             u32Acmod;
+    HI_U32             u32LeftDropMs;
+    HI_S32             s32Volume;
+    HI_U32             u32CurOutFrameMs;
+    HI_U32             u32NotEnoughCnt;
+    HI_U32             u32DecodeTryCnt;
+    HI_U32             u32DecodeOkCnt;
+    HI_U32             u32DecodeErrCnt;
+    HI_U32             u32DecodeInBufBytes;
+    HI_BOOL            bMute;
+    HI_U32             u32IntPrescale;
+    HI_S32             s32DecPrescale;
+} MS12_STREAM_PROC_S;
+
+typedef struct
+{
+    MS12_CONFIG_E      enConfig;
+    HI_BOOL            bSupportHeaac;
+    HI_U32             u32OutChannels;
+    HI_U32             u32OutSampleRate;
+    HI_U32             u32DebugLevel;
+    HI_BOOL            bDumpFile;
+    HI_BOOL            bDumpSectionFile;
+    HI_U32             u32FlushCnt;
+    HI_U32             u32SoftResetCnt;
+    HI_BOOL            bExtMain;
+    MS12_MIXER_PROC_S  stMixerProc[MS12_MIXER_NUM];
+    MS12_STREAM_PROC_S stStreamProc[MS12_MAX_STREAM_NUM];
+    DOLBYMS12_CODEC_OPENCONFIG_S stCodecConfig;
+    HI_BOOL            bAtmosOutput;
+} HA_MS12_PROC_S;
+
+typedef struct
+{
+    MS12_STREAM_STATE_E     enStreamState[MS12_MAX_STREAM_NUM];
+    HI_HADECODE_INPACKET_S* pstInPack[MS12_MAX_STREAM_NUM];
+
+    HI_BOOL  bPassthruBypass;
+    HI_U32   u32TrackDelayMs;
+    HI_CHAR* acUnifyWorkBuf[2];
+    HI_U32   u32UseCase;
+} MS12_INPUT_S;
+
+typedef struct
+{
+    HI_U32  u32OutFrameMs[MS12_MAX_STREAM_NUM];
+    HI_U32  u32DecodeLeftBytes[MS12_MAX_STREAM_NUM];
+    HI_U32  u32PcmDelayMs[MS12_MAX_STREAM_NUM];
+    HI_U32  u32DecoderStaticDelay[MS12_MAX_STREAM_NUM];
+    HI_S32  s32ErrState[MS12_MAX_STREAM_NUM];
+    HI_BOOL bStreamEnough[MS12_MAX_STREAM_NUM];
+    HI_HADECODE_OUTPUT_S* pstOutput;
+    HI_BOOL bAtmosOutActive;
+    HI_U32  u32AddMediaPauseMuteMs;
+    HI_U32  u32AddMediaMixerMuteMs;
+} MS12_OUTPUT_S;
+
+typedef struct
+{
+    MS12_INPUT_S  stInput;
+    MS12_OUTPUT_S stOutput;
+} HA_MS12_STREAM_S;
+
+/** Define decoding parameter
+    - enCmd: HA_CODEC_MS12_DECODE_FRAME_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    HA_MS12_STREAM_S stStream;
+} HA_MS12_DECODE_STREAM_S;
+
+/** Define Setting proc info parameter
+    - enCmd: HA_CODEC_MS12_SET_PROCINFO_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    HA_MS12_PROC_S stProc;
+} HA_MS12_SET_PROCINFO_S;
+
+/** Define Setting stream index parameter
+    - enCmd: HA_CODEC_MS12_SET_STREAM_INDEX_CMD
+    - u32Index: Indicates the stream index, support 0 ~ 3 */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32Index;
+} HA_MS12_SET_STREAM_INDEX_S;
+
+/** Define adjusting strategy parameter
+    - enCmd: HA_CODEC_MS12_ADJUST_STRATEGY_CMD
+    - s32AdjustTime: The time to adjust (ms) */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S32  s32AdjustTime;
+} HA_MS12_ADJUST_STRATEGY_S;
+
+/** Define enable decode parameter
+    -enCmd: HA_CODEC_ENABLE_DECODE_CMD
+    -bEnable: Indicates whether to decode */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_DECODE_ENABLE_S;
+
+/** Define parameter of enable mix
+    -enCmd: HA_CODEC_ENABLE_MIX_CMD
+    -bEnable: Indicates whether to mix to the output */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_MIX_ENABLE_S;
+
+/** Define dropping frame parameter
+    -enCmd: HA_CODEC_DROP_FRAME_CMD
+    -u32FrameCnt: frame count to drop for one stream */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32FrameCnt;
+} HA_MS12_DROP_FRAME_S;
+
+/** Define Setting parameter of eos flag
+    -enCmd: HA_CODEC_SET_EOSFLAG_CMD
+    -bEosFlag: Is the stream reach the end */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEosFlag;
+} HA_MS12_SET_EOSFLAG_S;
+
+/** Define Setting parameter of media volume attenuation
+    -enCmd: HA_CODEC_SET_MEDIAVOLATTENUATE_CMD
+    -bEnable: Indicates whether to attenuate media volume */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_MEDIAVOLATTENUATE_S;
+
+/** Define Getting MS12 Capability
+    -enCmd: HA_CODEC_MS12_GET_CAPABILITY_CMD
+    -u32Capability: Indicates MS12 support all format */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32Capability;
+} HA_MS12_GET_CAPABILITY_S;
+
+/** Define Setting parameter of dec policy mode
+    - enCmd: HA_CODEC_MS12_SET_DEC_POLICY_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_DEC_POLICY_E enPolicy;
+} HA_MS12_DEC_POLICY_S;
+
+/** Define Setting parameter of Audio Description
+    -enCmd:          HA_CODEC_MS12_SET_PES_DATA_CMD
+    -au8Data[0]:  fade_byte
+    -au8Data[1]:  gain_byte_center
+    -au8Data[2]:  gain_byte_front
+    -au8Data[3]:  gain_byte_surround
+    -au8Data[4]:  pan_byte */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U8  au8Data[5];
+} HA_MS12_SET_PES_DATA_S;
+
+/** Define Setting parameter of main input type
+    -enCmd: HA_CODEC_MS12_SET_INPUTTYPE_CMD
+    -enInputType: Indicates main input type */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_INPUT_TYPE_E enInputType;
+} HA_MS12_SET_INPUTTYPE_S;
+
+/** Define Setting parameter of atmos lock
+    -enCmd: HA_CODEC_MS12_SET_ATMOSLOCK_CMD
+    -bEnable: Indicates atmos lock */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_ATMOSLOCK_S;
+
+/** Define Setting parameter of source mute
+    -enCmd: HA_CODEC_MS12_SET_SOURCEMUTE_CMD
+    -bEnable: Indicates mute status */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_SOURCEMUTE_S;
+
+/** Define Setting parameter of source prescale
+    -enCmd: HA_CODEC_MS12_SET_SOURCEPRESCALE_CMD
+    -s32IntegerGain: Interger part of high preicision gain
+    -s32DecimalGain: decimal part of high preicision gain, if -0.125dB, value is -125 */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S32  s32IntegerGain;
+    HI_S32  s32DecimalGain;
+} HA_MS12_SET_SOURCEPRESCALE_S;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYMS12EXT_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYPLUS.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYPLUS.decode.h
new file mode 100644
index 0000000000..9e422719f6
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYPLUS.decode.h
@@ -0,0 +1,278 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYPLUS.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYPLUS_DECODE_H__
+#define __HA_AUDIO_DOLBYPLUS_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+
+
+#define HA_DOLBYPLUS_ID 0x1010
+
+/* The Command of online setting DRC mode, etc. */
+#define HA_CODEC_DOLBYPLUS_SET_DRC_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1000)
+#define HA_CODEC_DOLBYPLUS_SET_LFE_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1001)
+#define HA_CODEC_DOLBYPLUS_SET_DMX_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1002)
+#define HA_CODEC_DOLBYPLUS_SET_DYNSCALE_MODE_CMD  ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1003)
+
+/* The Command of set stop flag (normally only used in chip certification). */
+#define HA_CODEC_SET_STOP_FLAG_CMD                ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1004)
+
+#define IEC61937_PAYLOAD_SIZE_EAC3_HD             (6144 * 4 + 1536 * 4)
+
+
+
+/*!< Decoder dynamic range compression mode
+     - 0 = custom mode, analog dialnorm
+     - 1 = custom mode, digital dialnorm
+     - 2 = line out mode
+     - 3 = RF remod mode (default)
+     - 4 = Portable mode -8dB (output reference level is -8dB)
+     - 5 = Portable mode -11dB (output reference level is -11dB)
+     - 6 = Portable mode -14dB (output reference level is -14dB)
+     - t = Portable mode test (use this ONLY for bit-for-bit validation)
+     - x = Dynamic range control suppression mode */
+typedef enum
+{
+    DOLBYPLUS_DRC_CUSTOM_0 = 0,
+    DOLBYPLUS_DRC_CUSTOM_1,
+    DOLBYPLUS_DRC_LINE,
+    DOLBYPLUS_DRC_RF,            // (default)
+    DOLBYPLUS_DRC_PORTABLE_L8,
+    DOLBYPLUS_DRC_PORTABLE_L11,
+    DOLBYPLUS_DRC_PORTABLE_L14,
+    DOLBYPLUS_DRC_PORTABLE_TEST
+} DOLBYPLUS_DRC_MODE_E;
+
+/*!< Define LFE Downmixing mode
+     - 0 = Properly downmixes the LFE channel according to the lfemixlevcod parameter
+           when DRC is set to Line mode
+     - 1 = LFE channel is not downmixed when DRC is set to RF mode
+     - 2 = .2 channels (only available for 7.1 PCM output) */
+typedef enum
+{
+    DOLBYPLUS_LFEOUTOFF = 0,
+    DOLBYPLUS_LFEOUTON,
+    DOLBYPLUS_LFEDOWNMIX    = DOLBYPLUS_LFEOUTOFF,
+    DOLBYPLUS_LFENOTDOWNMIX = DOLBYPLUS_LFEOUTON,    // (default)
+    DOLBYPLUS_LFEOUTDUAL,
+} DOLBYPLUS_LFEOUT_MODE;
+
+/*!< Decoder output mode. If the output mode does not equal the bitstream audio 
+     coding mode (acmod), then the decoder will perform downmixing or fill channels
+     with zero values to meet the desired output configuration.
+
+     Note: only the first main output can support values > 7
+     - r = raw mode (outputs all standard (non-replaced) channels in 7.1-channel
+           bitstream; no channel mixing or remapping performed)
+     - 0 = reserved
+     - 1 = 1/0 (C)
+     - 2 = 2/0 (L, R)
+     - 3 = 3/0 (L, R, C)
+     - 4 = 2/1 (L, R, l)
+     - 5 = 3/1 (L, R, C, l)
+     - 6 = 2/2 (L, R, l, r)
+     - 7 = 3/2 (L, R, C, l, r)
+     - 9 = 2/2/1 (L, R, l, r, Ts)
+     - 10 = 3/2/1 (L, R, C, l, r, Ts)
+     - 11 = 3/2/1 (L, R, C, l, r, Cvh)
+     - 12 = 3/0/2 (L, R, C, Lc, Rc)
+     - 13 = 2/2/2 (L, R, l, r, Lw, Rw)
+     - 14 = 2/2/2 (L, R, l, r, Lvh, Rvh)
+     - 15 = 2/2/2 (L, R, l, r, Lsd, Rsd)
+     - 16 = 2/2/2 (L, R, l, r, Lrs, Rrs)
+     - 17 = 3/2/2 (L, R, C, l, r, Lc, Rc)
+     - 18 = 3/2/2 (L, R, C, l, r, Lw, Rw)
+     - 19 = 3/2/2 (L, R, C, l, r, Lvh, Rvh)
+     - 20 = 3/2/2 (L, R, C, l, r, Lsd, Rsd)
+     - 21 = 3/2/2 (L, R, C, l, r, Lrs, Rrs)
+     - 22 = 3/2/2 (L, R, C, l, r, Ts, Cvh)
+     - 23 = Follow (not yet implemented)  */
+typedef enum
+{
+    DOLBYPLUS_OUT_MODE11 = 0,
+    DOLBYPLUS_OUT_MODE10,
+    DOLBYPLUS_OUT_MODE20,          // (default)
+    DOLBYPLUS_OUT_MODE30,
+    DOLBYPLUS_OUT_MODE21,
+    DOLBYPLUS_OUT_MODE31,
+    DOLBYPLUS_OUT_MODE22,
+    DOLBYPLUS_OUT_MODE32,
+} DOLBYPLUS_OUTPUT_MODE_E;
+
+/*!< Decoder dual mono mode (Only when <i>acmod</i> is 1/1)
+     - 0 = Stereo
+     - 1 = Left mono
+     - 2 = Right mono
+     - 3 = Mixed mono */
+typedef enum
+{
+    DOLBYPLUS_DUAL_STEREO = 0,   // (default)
+    DOLBYPLUS_DUAL_LEFTMONO,
+    DOLBYPLUS_DUAL_RGHTMONO,
+    DOLBYPLUS_DUAL_MIXMONO,
+} DOLBYPLUS_DUAL_MODE_E;
+
+/*!< Decoder stereo output mode.  This parameter specifies the
+     reproduction mode associated with stereo output(output mode = 2/0).
+     - 0 = Automatically detects stereo mode based on setting in the bit stream.
+     - 1 = 2/0 Dolby Surround compatible (Lt/Rt)
+     - 2 = 2/0 Stereo (Lo/Ro)
+     - 3 = Reserved */
+typedef enum
+{
+    DOLBYPLUS_DMX_AUTO = 0,
+    DOLBYPLUS_DMX_SRND,
+    DOLBYPLUS_DMX_STEREO,
+    DOLBYPLUS_DMX_LTRT = DOLBYPLUS_DMX_SRND,    // (default)
+    DOLBYPLUS_DMX_LORO = DOLBYPLUS_DMX_STEREO,
+} DOLBYPLUS_STEREODMX_MODE_E;
+
+/*!< Define DDP convert on/off */
+typedef enum
+{
+    DOLBYPLUS_CONVERTER_OFF = 0,
+    DOLBYPLUS_CONVERTER_ON                      // (default)
+} DOLBYPLUS_CONVERTER_MODE;
+
+
+typedef struct
+{
+    HI_U32  enCmd;          /* HA_CODEC_SET_STOP_FLAG_CMD */
+    HI_BOOL bStopFlag;
+    HI_BOOL bADStopFlag;
+} HA_SET_STOP_FLAG_S;
+
+/** DDP  HA_DOLBYPLUS_EVENT_SOURCE_CHANGE event, stream information user data definition */
+typedef struct  hiDOLBYPLUS_STREAM_INFO_S
+{
+    HI_S16 s16StreamType;   /* 0: dolby digital, 1: dolby digital plus */
+    HI_S16 s16Acmod;
+    HI_S32 s32BitRate;
+    HI_S32 s32SampleRateRate;
+} DOLBYPLUS_STREAM_INFO_S;
+
+/* Define the struct for set drc mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_DRC_MODE_E eDrcMode;
+} HA_DOLBYPLUS_SET_DRC_MODE_S;
+
+/* Define the struct for set lfe out mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_LFEOUT_MODE eLfeMode;
+} HA_DOLBYPLUS_SET_LFE_MODE_S;
+
+/* Define the struct for set downmix mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_STEREODMX_MODE_E eDmxMode;
+} HA_DOLBYPLUS_SET_DMX_MODE_S;
+
+/* Define the struct for set dynamic scale value from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S16  s16DynScaleHigh;
+    HI_S16  s16DynScaleLow;
+} HA_DOLBYPLUS_SET_DYNSCALE_MODE_S;
+
+/** DDP callback event defination */
+typedef enum
+{
+    HA_DOLBYPLUS_EVENT_SOURCE_CHANGE = 0,     /**< stream information change event, DOLBYPLUS_STREAM_INFO_S */
+    HA_DOLBYPLUS_EVENT_BUTT
+} DOLBYPLUS_EVENT_E;
+
+
+/** DDP callback method definition */
+typedef HI_VOID (*DOLBYPLUS_EVENT_CB_FN)(DOLBYPLUS_EVENT_E enEvent, HI_VOID* pAppData);
+
+
+typedef struct  hiDOLBYPLUS_DECODE_OPENCONFIG_S
+{
+    DOLBYPLUS_DRC_MODE_E       enDrcMode;      /* dynamic range compression mode */
+    DOLBYPLUS_LFEOUT_MODE      enOutLfe;       /* output LFE channel present     */
+    DOLBYPLUS_OUTPUT_MODE_E    enOutputMode;   /* output channel configuration   */
+    DOLBYPLUS_STEREODMX_MODE_E enDmxMode;      /* stereo output mode    */
+    DOLBYPLUS_DUAL_MODE_E      enDualMode;     /* dual mono reproduction mode   */
+    HI_S16                     s16PcmScale;    /* PCM scale factor, 0~100,default:100,  100 means 1.0, 33 means 0.33,etc */
+    HI_S16                     s16DynScaleHigh;/* dynamic range compression cut scale factor, 0~100,default:100,  100 means 1.0, 33 means 0.33,etc*/
+    HI_S16                     s16DynScaleLow; /* dynamic range compression boost scale factor, 0~100,default:100, 100 means 1.0, 33 means 0.33,etc   */
+    DOLBYPLUS_CONVERTER_MODE   enConvertMode;  /* ddp decoder-converter on/off     */
+    HI_S16                     PirvateControl; /* private test control(0~255), default:0. */
+    HI_CHAR                    szInputFileName[256]; /*  private test params */
+    DOLBYPLUS_EVENT_CB_FN      pfnEvtCbFunc[HA_DOLBYPLUS_EVENT_BUTT];      /* ddp call back method */
+    HI_VOID*                   pAppData[HA_DOLBYPLUS_EVENT_BUTT];          /* application defined value for ddp call back method */
+} DOLBYPLUS_DECODE_OPENCONFIG_S;
+
+
+#define HA_DOLBYPLUS_DecGetDefalutOpenConfig(pConfigParam) \
+    do { HI_S32 n; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDrcMode = DOLBYPLUS_DRC_RF; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enOutLfe  = DOLBYPLUS_LFEOUTON; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enOutputMode = DOLBYPLUS_OUT_MODE20; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDmxMode    = DOLBYPLUS_DMX_SRND; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDualMode   = DOLBYPLUS_DUAL_STEREO; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16PcmScale  = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16DynScaleHigh = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16DynScaleLow  = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enConvertMode   = DOLBYPLUS_CONVERTER_OFF; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->PirvateControl  = 0; \
+        for (n = 0; n < HA_DOLBYPLUS_EVENT_BUTT; n++) \
+        { \
+            ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->pfnEvtCbFunc[n] = HI_NULL; \
+            ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->pAppData[n] = HI_NULL; \
+        } \
+    } while (0)
+
+
+#define HA_DOLBYPLUS_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DOLBYPLUS_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+
+#define HA_DOLBYPLUS_DecSetMode(pOpenParam, eDecMode) \
+    do { ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = eDecMode; } while (0)
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYPLUS_DECODE_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYTRUEHD.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYTRUEHD.decode.h
new file mode 100644
index 0000000000..b72ce9b68c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DOLBYTRUEHD.decode.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DOLBY_TRUEHD_H__
+#define __HISI_AUDIO_DECODER_DOLBY_TRUEHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */  
+
+
+typedef enum hiTRUEHD_DRC_STATEMODE_TYPE_E
+{
+    TRUEHD_DRC_STATEMODE_TYPE_OFF,
+    TRUEHD_DRC_STATEMODE_TYPE_FOLLOW,      /**<default*/ /**< */
+    TRUEHD_DRC_STATEMODE_TYPE_ON
+} TRUEHD_DRC_STATEMODE_TYPE_E;
+
+
+typedef struct hiTRUEHD_DECODE_OPENCONFIG_S
+{
+    HI_S32            				startByte ;
+    HI_S32           				s32chanflag;
+    HI_BOOL           			    fbaChannelOrder;
+
+    HI_BOOL           			    lossless;
+    TRUEHD_DRC_STATEMODE_TYPE_E     enDrcMode;
+    HI_S32            				drcBoost;
+    HI_S32            				drcCut;            
+    HI_BOOL           			    verbose;
+    HI_S32			  				lenSamp ;
+    HI_S32            				lenByte ;
+    HI_BOOL           			    archive;
+} TRUEHD_DECODE_OPENCONFIG_S;
+
+
+#define HA_DOLBY_TRUEHD_DecGetDefalutOpenConfig(pConfigParam) \
+do { ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->s32chanflag = 0x2; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->startByte   = 0; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lenByte   = 0x7fffffff; \
+	 ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lenSamp   = 0x7fffffff; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->fbaChannelOrder = HI_FALSE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lossless = HI_TRUE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enDrcMode   = TRUEHD_DRC_STATEMODE_TYPE_FOLLOW; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->drcBoost  = 100; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->drcCut = 100; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->verbose = HI_FALSE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->archive = HI_FALSE; \
+} while (0)
+
+#define HA_DOLBY_TRUEHD_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(TRUEHD_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_TRUEHD_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DRA.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DRA.decode.h
new file mode 100644
index 0000000000..de371c4f49
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DRA.decode.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.DRA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DRA_H__
+#define __HISI_AUDIO_DECODER_DRA_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_DRA_ID 0x007        
+
+#define HA_CODEC_GET_DRA_DonwmixMultich_MODE_CMD  ((((HI_U32)HA_DRA_ID) << 16) | 0x1000)
+#define HA_CODEC_GET_DRA_RAWCHANNEL_MODE_CMD      ((((HI_U32)HA_DRA_ID) << 16) | 0x1001)
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_DRA_GET_DonwmixMultich_MODE_S */
+    HI_BOOL  *pbDonwmixMultichMode;
+} HA_DRA_GET_DonwmixMultich_MODE_S;
+
+typedef enum
+{
+    DRA_RAWCHANNEL_MODE10 = 0,
+    DRA_RAWCHANNEL_MODE11,
+    DRA_RAWCHANNEL_MODE20,
+    DRA_RAWCHANNEL_MODE21,
+    DRA_RAWCHANNEL_MODE30,
+    DRA_RAWCHANNEL_MODE31,
+    DRA_RAWCHANNEL_MODE40,
+    DRA_RAWCHANNEL_MODE41,
+    DRA_RAWCHANNEL_MODE50,
+    DRA_RAWCHANNEL_MODE51,
+    DRA_RAWCHANNEL_BUTT = 0x100,   /* Unsupported Channel Mode */
+} HA_DRA_RAWCHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_DRA_RAWCHANNEL_MODE_CMD */
+    HA_DRA_RAWCHANNEL_MODE  eRawChannelMode;
+} HA_DRA_GET_RawChannel_MODE_S;
+
+#define HA_DRA_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#define HA_DRA_DecGetOpenParam_MultichPcm(pOpenParam) \
+    do{ HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 8; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    }while(0)
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DRA_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DTSHD.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DTSHD.decode.h
new file mode 100644
index 0000000000..d2b6f664a4
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DTSHD.decode.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DTSHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSHD_H__
+#define __HISI_AUDIO_DECODER_DTSHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+typedef  struct
+{
+    HI_U32  spkrOut;              /* set as a result of spkrout ,default is 2(Lo/Ro) */
+    HI_BOOL enableDownmix; /* default true */
+    HI_BOOL coreOnly;       /**< true: core decode only, false: dts hd decode,default value is true */
+	HI_BOOL lfeMixedToFrontWhenNoDedicatedLFEOutput;         /**< true: enable lfe,default value is false */    
+    HI_U32 outputBitWidth;        /**< 16: 16bit, 24: 24bit, 0,:native, defalut is 24 */
+    HI_BOOL enableDialNorm; /* true: enable , default value is true */
+    HI_U32  DRCPercent;      /* 0~100 - default is 0 ,no DRC */
+    HI_BOOL enableHDPassThrough;       /* true: enable , default value is true */
+    HI_U32  PirvateControl;     
+} DTSHD_DECODE_OPENCONFIG_S;
+
+#define HA_DTSHD_DecGetDefalutOpenConfig(pConfigParam) \
+    do {  \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->spkrOut = 2; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableDownmix = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->coreOnly = HI_TRUE; \
+		 ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lfeMixedToFrontWhenNoDedicatedLFEOutput = HI_FALSE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->outputBitWidth   = 24; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableDialNorm  = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->DRCPercent = 0; \
+		((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableHDPassThrough = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->PirvateControl = 0; \
+    } while (0)
+
+#define HA_DTSHD_DecGetDefalutOpenParam(pOpenParam, pstPrvateConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DTSHD_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSHD_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DTSM6.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DTSM6.decode.h
new file mode 100644
index 0000000000..e893f985a3
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DTSM6.decode.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DTSHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSM6_H__
+#define __HISI_AUDIO_DECODER_DTSM6_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+
+
+/** DTSM6 HA_DOLBYPLUS_EVENT_SOURCE_CHANGE event, stream information user data defination
+    u32StreamType:
+        DTSDECSTRMTYPE_UNKNOWN              = 0x00000000,(indicator: Unkown)
+        DTSDECSTRMTYPE_DTS_LEGACY           = 0x00000001,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_MATRIX        = 0x00000002,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_DISCRETE      = 0x00000004,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_9624             = 0x00000008,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_8CH_DISCRETE  = 0x00000010,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_HIRES            = 0x00000020,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_MA               = 0x00000040,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_LBR              = 0x00000080,(indicator: DTS Express)
+        DTSDECSTRMTYPE_DTS_LOSSLESS         = 0x00000100,(indicator: DTS-HD Mater Audio/DTS-HD MSTR)
+*/
+
+typedef struct
+{
+    HI_U32 u32StreamType;
+    HI_S32 s32BitRate;
+    HI_S32 s32SampleRate;
+} DTSM6_STREAM_INFO_S;
+
+/** DTSM6 callback event defination */
+typedef enum
+{
+    HA_DTSM6_EVENT_SOURCE_CHANGE = 0,     /**< stream information change event, DTSM6_STREAM_INFO_S */
+    HA_DTSM6_EVENT_BUTT
+} DTSM6_EVENT_E;
+
+/** DTSM6 callback method definition */
+typedef HI_VOID (*DTSM6_EVENT_CB_FN)(DTSM6_EVENT_E enEvent, HI_VOID* pAppData);
+
+
+typedef struct
+{
+    HI_U32  spkrOut;              /* set as a result of spkrout ,default is 2(Lo/Ro) */
+    HI_BOOL coreOnly;             /**< true: core decode only, false: dts hd decode,default value is false */
+    HI_U32  outputBitWidth;       /**< 16: 16bit, 24: 24bit, 0,:native, defalut is 16 */
+    HI_U32  DRCPercent;           /* 0~100 - default is 0 ,no DRC */
+    HI_BOOL enableHDPassThrough;  /* true: enable , default value is true */
+    HI_BOOL enableSPDIFOutput;    /* true: enable , default value is true */
+    HI_BOOL enableTransEncode;    /* true: enable , default value is false */
+    HI_U32  transEncodeMode;      /* 0,DTSTRANSCODEMODE_5_1_MIXOUT;1,DTSTRANSCODEMODE_FULL_MIXOUT;default 1 */
+    HI_BOOL allowUalignWord;      /* true: allow , default value is true */
+    DTSM6_EVENT_CB_FN  pfnEvtCbFunc[HA_DTSM6_EVENT_BUTT];   /* dtsm6 call back method */
+    HI_VOID*           pAppData[HA_DTSM6_EVENT_BUTT];       /* application defined value for dtsm6 call back method */
+} DTSM6_DECODE_OPENCONFIG_S;
+
+#define HA_DTSM6_DecGetDefalutOpenConfig(pConfigParam) \
+    do { HI_S32 n; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->spkrOut = 2; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->coreOnly = HI_FALSE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->outputBitWidth  = 24; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->DRCPercent = 0; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableHDPassThrough = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableSPDIFOutput = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableTransEncode = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->transEncodeMode = 1; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->allowUalignWord = HI_TRUE; \
+        for (n = 0; n < HA_DTSM6_EVENT_BUTT; n++) \
+        { \
+            ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->pfnEvtCbFunc[n] = HI_NULL; \
+            ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->pAppData[n] = HI_NULL; \
+        } \
+    } while (0)
+
+#define HA_DTSM6_DecGetDefalutOpenParam(pOpenParam, pstPrvateConfig) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DTSM6_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSM6_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.DTSPASSTHROUGH.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.DTSPASSTHROUGH.decode.h
new file mode 100644
index 0000000000..49c4c972d3
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.DTSPASSTHROUGH.decode.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.DTSPASSTHROUGH.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__
+#define __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_DTSPASSTHROUGH_ID 0x1025      
+
+#define HA_DTSPASSTHROUGH_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DECODE.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DECODE.decode.h
new file mode 100644
index 0000000000..da8882cdec
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DECODE.decode.h
@@ -0,0 +1,114 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_DECODE.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+#define HA_FFMPEG_ID 0x03ff        
+
+/**define status parameter of update information*/ /**CNcomment:*/
+typedef struct  hiFFMPEG_STATUS_INFO_S
+{
+    HI_CHAR *name;
+    HI_S32  codec_id;
+    HI_S32  codec_type;
+    HI_S32  sample_fmt;
+    HI_S32  channels;
+    HI_S32  sample_rate;
+    HI_S32  bit_rate;
+    HI_S32  block_align;
+} FFMPEG_STATUS_INFO_S;
+
+
+/** Audio stream information */
+/** CNcomment: */
+typedef struct hiFFMPEG_AUD_INFO_S
+{
+    HI_S32   codec_id;
+    HI_S32   s32StreamIndex;
+    HI_U32   u32Format;
+    HI_U32   u32Profile;
+    HI_U32   u32SampleRate;
+    HI_U16   u16BitPerSample;
+    HI_U16   u16Channels;
+    HI_U32   u32BlockAlign;
+    HI_U32   u32Bitrate;
+    HI_BOOL  bBigEndian;
+    HI_U32   u32ExtradataSize;
+    HI_U8   *pu8Extradata;
+} FFMPEG_AUD_INFO_S;
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+    HA_FFMPEG_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+    HA_FFMPEG_EVENT_BUTT
+} HA_FFMPEG_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_DECODE_OPENCONFIG_S
+{
+    HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+    HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+    HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+    FFMPEG_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_EVENT_BUTT];    /* call back method */
+    HI_VOID*                pAppData1[HA_FFMPEG_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+    HI_VOID*                pAppData2[HA_FFMPEG_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+    FFMPEG_AUD_INFO_S       stFfmpeg_AudInfo;
+} HA_FFMPEG_DECODE_OPENCONFIG_S;
+
+#define HA_FFMPEG_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+        ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEGC_DecGetDefalutOpenParam(pOpenParam, pFfmpegConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_DECODE_OPENCONFIG_S); \
+         for (i = 0; i < HA_FFMPEG_EVENT_BUTT; i++) \
+         { \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pAppData1[i] = HI_NULL; \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pAppData2[i] = HI_NULL; \
+         } \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DTS.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DTS.decode.h
new file mode 100644
index 0000000000..4ad55c8177
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_DTS.decode.h
@@ -0,0 +1,139 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_DTS.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_DTS_ID 0x0340     
+#define HA_CODEC_SET_DTS_DOWNMIX_INFO_CMD  	((((HI_U32)HA_FFMPEG_DTS_ID) << 16) | 0x1000)
+
+typedef struct hiFFMPEG_DTS_DownmixInfo_S {
+    /**
+     * Type of downmix preferred by the mastering engineer.
+     */
+	int preferred_downmix_type;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during a regular downmix.
+     */
+	double center_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during an Lt/Rt compatible downmix.
+     */
+	double center_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during a regular downmix.
+     */
+	double surround_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during an Lt/Rt compatible downmix.
+     */
+	double surround_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the level at which the LFE data is
+     * mixed into L/R channels during downmixing.
+     */
+	double lfe_mix_level;
+}FFMPEG_DTS_DownmixInfo_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_DTS_DOWNMIX_INFO_CMD */
+	FFMPEG_DTS_DownmixInfo_S* peDTSDownmixInfo;
+} HA_FFMPEG_DTS_DOWNMIX_INFO_S;
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_DTS_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_DTS_EVENT_BUTT
+} HA_FFMPEG_DTS_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_DTS_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_DTS_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_DTS_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_DTS_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_DTS_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_DTS_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_DTS_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_DTS_DECODE_OPENCONFIG_S;
+
+#define FFMPEDTS_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEDTS_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegDTSConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegDTSConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_DTS_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_DTS_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEDTS_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_EAC3.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_EAC3.decode.h
new file mode 100644
index 0000000000..baf4103eb8
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_EAC3.decode.h
@@ -0,0 +1,200 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_EAC3.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_EAC3_ID 0x0320     
+#define HA_CODEC_SET_EAC3_DEC_CONTEXT_CMD  		((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_EAC3_DOWNMIX_INFO_CMD  	((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1001)
+#define HA_CODEC_SET_EAC3_CLEAR_CMD  			((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1003)
+
+/**define status parameter of update information*/ /**CNcomment:*/
+typedef struct hiFFMPEG_EAC3_DecodeContext_S {
+	int frame_type;                         ///< frame type                             (strmtyp)
+	int substreamid;                        ///< substream identification
+	int frame_size;                         ///< current frame size, in bytes
+	int bit_rate;                           ///< stream bit rate, in bits-per-second
+	int sample_rate;                        ///< sample frequency, in Hz
+	int num_blocks;                         ///< number of audio blocks
+	int bitstream_id;                       ///< bitstream id                           (bsid)
+	int bitstream_mode;                     ///< bitstream mode                         (bsmod)
+	int channel_mode;                       ///< channel mode                           (acmod)
+	int lfe_on;                             ///< lfe channel in use
+	int dialog_normalization[2];            ///< dialog level in dBFS                   (dialnorm)
+	int compression_exists[2];              ///< compression field is valid for frame   (compre)
+	int compression_gain[2];                ///< gain to apply for heavy compression    (compr)
+	int channel_map;                        ///< custom channel map
+	int preferred_downmix;                  ///< Preferred 2-channel downmix mode       (dmixmod)
+	int center_mix_level;                   ///< Center mix level index
+	int center_mix_level_ltrt;              ///< Center mix level index for Lt/Rt       (ltrtcmixlev)
+	int surround_mix_level;                 ///< Surround mix level index
+	int surround_mix_level_ltrt;            ///< Surround mix level index for Lt/Rt     (ltrtsurmixlev)
+	int lfe_mix_level_exists;               ///< indicates if lfemixlevcod is specified (lfemixlevcode)
+	int lfe_mix_level;                      ///< LFE mix level index                    (lfemixlevcod)
+	int eac3;                               ///< indicates if current frame is E-AC-3
+	int eac3_frame_dependent_found;         ///< bitstream has E-AC-3 dependent frame(s)
+	int eac3_subsbtreamid_found;            ///< bitstream has E-AC-3 additional substream(s)
+	int dolby_surround_mode;                ///< dolby surround mode                    (dsurmod)
+	int dolby_surround_ex_mode;             ///< dolby surround ex mode                 (dsurexmod)
+	int dolby_headphone_mode;               ///< dolby headphone mode                   (dheadphonmod)
+
+	int snr_offset_strategy;                ///< SNR offset strategy                    (snroffststr)
+	int block_switch_syntax;                ///< block switch syntax enabled            (blkswe)
+	int dither_flag_syntax;                 ///< dither flag syntax enabled             (dithflage)
+	int bit_allocation_syntax;              ///< bit allocation model syntax enabled    (bamode)
+	int fast_gain_syntax;                   ///< fast gain codes enabled                (frmfgaincode)
+	int dba_syntax;                         ///< delta bit allocation syntax enabled    (dbaflde)
+	int skip_syntax;                        ///< skip field syntax enabled              (skipflde)
+
+	int fbw_channels;                           ///< number of full-bandwidth channels
+	int channels;                               ///< number of total channels
+	int lfe_ch;                                 ///< index of LFE channel
+	int16_t *downmix_coeffs[2];              ///< stereo downmix coefficients
+	int downmixed;                              ///< indicates if coeffs are currently downmixed
+	int output_mode;                            ///< output channel configuration
+	int out_channels;                           ///< number of output channels
+}FFMPEG_EAC3_DecodeContext_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_DEC_CONTEXT_CMD */
+	FFMPEG_EAC3_DecodeContext_S* peEAc3DecodeContext;
+} HA_FFMPEG_EAC3_DEC_CONTEXT_S;
+
+typedef struct hiFFMPEG_EAC3_DownmixInfo_S {
+    /**
+     * Type of downmix preferred by the mastering engineer.
+     */
+	int preferred_downmix_type;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during a regular downmix.
+     */
+	double center_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during an Lt/Rt compatible downmix.
+     */
+	double center_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during a regular downmix.
+     */
+	double surround_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during an Lt/Rt compatible downmix.
+     */
+	double surround_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the level at which the LFE data is
+     * mixed into L/R channels during downmixing.
+     */
+	double lfe_mix_level;
+}FFMPEG_EAC3_DownmixInfo_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_DOWNMIX_INFO_CMD */
+	FFMPEG_EAC3_DownmixInfo_S* peEAc3DownmixInfo;
+} HA_FFMPEG_EAC3_DOWNMIX_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_EAC3_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_EAC3_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_EAC3_EVENT_BUTT
+} HA_FFMPEG_EAC3_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_EAC3_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_EAC3_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_EAC3_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_EAC3_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_EAC3_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_EAC3_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_EAC3_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S;
+
+#define FFMPEEAC3_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEEAC3_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegEAc3Config) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegEAc3Config; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_EAC3_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEEAC3_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_LPCM.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_LPCM.decode.h
new file mode 100644
index 0000000000..13de40ff54
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_LPCM.decode.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_LPCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_LPCM_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_LPCM_EVENT_BUTT
+} HA_FFMPEG_LPCM_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_LPCM_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_LPCM_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_LPCM_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_LPCM_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_LPCM_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_LPCM_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_LPCM_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S;
+
+#define FFMPELPCM_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPELPCM_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegLPCMConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegLPCMConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_LPCM_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPELPCM_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_TRUEHD.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_TRUEHD.decode.h
new file mode 100644
index 0000000000..cf47e2b117
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_TRUEHD.decode.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_TRUEHD_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_TRUEHD_EVENT_BUTT
+} HA_FFMPEG_TRUEHD_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_TRUEHD_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_TRUEHD_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_TRUEHD_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_TRUEHD_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_TRUEHD_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_TRUEHD_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S;
+
+#define FFMPETRUEHD_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPETRUEHD_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegTrueHDConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegTrueHDConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_TRUEHD_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPETRUEHD_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA.decode.h
new file mode 100644
index 0000000000..21116a359b
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA.decode.h
@@ -0,0 +1,126 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_WMA_ID 0x0300        
+#define HA_CODEC_SET_WMA_INFO_CMD  ((((HI_U32)HA_FFMPEG_WMA_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_WMA_CLEAR_CMD  ((((HI_U32)HA_FFMPEG_WMA_ID) << 16) | 0x1001)
+
+/**define status parameter of update information*/ /**CNcomment:*/
+typedef struct  hiFFMPEG_WMA_INFO_S
+{
+	HI_S32  wma_version;
+	HI_S32  codec_id;
+	HI_S32  codec_type;
+	HI_S32  codec_tag;
+	HI_S32  sample_fmt;
+	HI_S32  channels;
+	HI_S32  sample_rate;
+	HI_S32  bit_rate;
+	HI_S32  block_align;
+	HI_S32  word_size;
+	HI_UCHAR extradata[1024];
+	HI_S32 extradata_size;
+} FFMPEG_WMA_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_INFO_CMD */
+	FFMPEG_WMA_INFO_S* peWmaInfo;
+} HA_FFMPEG_WMA_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_WMA_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_WMA_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_WMA_EVENT_BUTT
+} HA_FFMPEG_WMA_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_WMA_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_WMA_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_WMA_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_WMA_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_WMA_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_WMA_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_WMA_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_WMA_DECODE_OPENCONFIG_S;
+
+#define FFMPEWMA_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEWMA_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegWmaConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegWmaConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_WMA_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_WMA_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEWMA_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMAPRO.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMAPRO.decode.h
new file mode 100644
index 0000000000..0b76155853
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMAPRO.decode.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMAPRO.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+#define HA_WMAPRO_ID 0x041f
+#define HA_AUDIO_ID_FFMPEG_WMAPRO   HA_BUILD_CODEC_ID(VENDOR_HISI,FORMAT_WMAPRO,HA_WMAPRO_ID)  /* support FORMAT_WMAPRO */
+
+
+typedef struct hiWMAPro_FORMAT_S
+{
+    HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+
+    HI_U16 wFormatTag;          /* format type,0x160->WMAV1,0x161->WMAV2, 0x162->WMAV3 */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* block size of data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* the count in bytes of the size of */
+    HI_U8 cbExtWord[32];       /* extra information (after cbSize).
+                                WMAV1: need  4 Bytes extra information at least
+                                    WMAV2: need 10 Bytes extra information at least
+                                WMAV3: need 18 Bytes extra information at least
+                                 */
+} WMAPro_FORMAT_S;
+
+
+#define HA_FFMPEGC_WMAPROC_DecGetDefalutOpenParam(pOpenParam, pstWmaProConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pstWmaProConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(WMAPro_FORMAT_S); \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA_PRO.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA_PRO.decode.h
new file mode 100644
index 0000000000..53d541d123
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.FFMPEG_WMA_PRO.decode.h
@@ -0,0 +1,126 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMAPRO.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMA_PRO_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMA_PRO_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_WMAPRO_ID 0x0310        
+#define HA_CODEC_SET_WMAPRO_INFO_CMD  ((((HI_U32)HA_FFMPEG_WMAPRO_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_WMAPRO_CLEAR_CMD  ((((HI_U32)HA_FFMPEG_WMAPRO_ID) << 16) | 0x1001)
+
+/**define status parameter of update information*/ /**CNcomment:*/
+typedef struct  hiFFMPEG_WMAPRO_INFO_S
+{
+	HI_S32  wma_version;
+	HI_S32  codec_id;
+	HI_S32  codec_type;
+	HI_S32  codec_tag;
+	HI_S32  sample_fmt;
+	HI_S32  channels;
+	HI_S32  sample_rate;
+	HI_S32  bit_rate;
+	HI_S32  block_align;
+	HI_S32  word_size;
+	HI_UCHAR extradata[1024];
+	HI_S32 extradata_size;
+} FFMPEG_WMAPRO_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_INFO_CMD */
+	FFMPEG_WMAPRO_INFO_S* peWmaProInfo;
+} HA_FFMPEG_WMAPRO_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMAPRO_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_WMAPRO_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:*/
+typedef enum
+{
+	HA_FFMPEG_WMAPRO_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:, */
+	HA_FFMPEG_WMAPRO_EVENT_BUTT
+} HA_FFMPEG_WMAPRO_EVENT_E;
+
+/**define callback function*/ /**CNcomment:*/
+typedef HI_VOID (*FFMPEG_WMAPRO_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_WMAPRO_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_WMAPRO_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_WMAPRO_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_WMAPRO_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_WMAPRO_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S;
+
+#define FFMPEWMAPRO_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEWMAPRO_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegWmaProConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegWmaProConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_WMAPRO_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEWMAPRO_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.G711.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.G711.codec.h
new file mode 100644
index 0000000000..04ebd961d2
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.G711.codec.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G711.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_G711_H__
+#define __HISI_AUDIO_CODEC_G711_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define G711_FRAME_BLOCK_LEN_10MS  80
+
+typedef struct
+{
+    HI_S32  isAlaw;  /* 1=A Law, 0= u Law  */
+    HI_BOOL bVAD;  /* HI_TRUE=enable vad, HI_FALSE=disable vad  */
+} G711_ENCODE_OPENCONFIG_S;
+
+#define HA_G711_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = G711_FRAME_BLOCK_LEN_10MS; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G711_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+typedef struct
+{
+    HI_S32  isAlaw;  /* 1=A Law, 0= u Law  */
+    HI_U32 u32SamplePerFrame;
+} G711_DECODE_OPENCONFIG_S;
+
+#define HA_G711_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G711_DECODE_OPENCONFIG_S); \
+}while(0)
+    
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_G711_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.G722.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.G722.codec.h
new file mode 100644
index 0000000000..85602a10c9
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.G722.codec.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G722.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_G722_H__
+#define __HISI_AUDIO_CODEC_G722_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_G722_ID 0x0105        
+
+#define G722_FRAME_BLOCK_LEN_10MS  160
+#define G722_FRAME_BLOCK_LEN_20MS  320
+
+#define HA_G722_GetEncDefaultOpenParam(pOpenParam) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 16000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = G722_FRAME_BLOCK_LEN_10MS; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+}while(0)
+
+typedef struct
+{
+    HI_S32  mode;  /* 1=64kbps, 2= 56kbps, 3= 48kbps  */
+} G722_DECODE_OPENCONFIG_S;
+
+#define HA_G722_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 16000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G722_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+
+#endif /* __HISI_AUDIO_CODEC_G722_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.MP2.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.MP2.decode.h
new file mode 100644
index 0000000000..45c38b544f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.MP2.decode.h
@@ -0,0 +1,65 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.MP2.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_MP2_H__
+#define __HISI_AUDIO_DECODER_MP2_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_MP2_ID 0x0002        
+       
+#define HA_CODEC_GET_MP2_CHNANEL_MODE_CMD  ((((HI_U32)HA_MP2_ID) << 16) | 0x1000)
+
+typedef enum
+{
+    MP2_CHANNEL_MODE_STEREO = 0,
+    MP2_CHANNEL_MODE_JOINTSTERERO,
+    MP2_CHANNEL_MODE_DUALSTERERO,
+    MP2_CHANNEL_MODE_MONO,
+}HA_MP2_CHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_MP2_CHNANEL_MODE_CMD */
+    HA_MP2_CHANNEL_MODE *peChannelMode;
+} HA_MP2_GET_CHNANEL_MODE_S;
+
+#define HA_MP2_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_MP2_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.MP3.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.MP3.decode.h
new file mode 100644
index 0000000000..9677c958b0
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.MP3.decode.h
@@ -0,0 +1,71 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.MP3.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_MP3_H__
+#define __HISI_AUDIO_DECODER_MP3_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HA_MP3_ID 0x0003
+#define HA_CODEC_GET_MP3_CHNANEL_MODE_CMD  ((((HI_U32)HA_MP3_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_MP3_CHECKONESYNC_CMD  ((((HI_U32)HA_MP3_ID) << 16) | 0x1001)
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_SET_MP3_CHECKONESYNC_CMD */
+    HI_BOOL bCheckOneSync;
+} HA_MP3_CHECKONESYNC_FLAG_S;
+
+typedef enum
+{
+    MP3_CHANNEL_MODE_STEREO = 0,
+    MP3_CHANNEL_MODE_JOINTSTERERO,
+    MP3_CHANNEL_MODE_DUALSTERERO,
+    MP3_CHANNEL_MODE_MONO,
+} HA_MP3_CHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_MP3_CHNANEL_MODE_CMD */
+    HA_MP3_CHANNEL_MODE* peChannelMode;
+} HA_MP3_GET_CHNANEL_MODE_S;
+
+#define HA_MP3_DecGetDefalutOpenParam(pOpenParam) \
+    do{ HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    }while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_MP3_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.OPUS.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.OPUS.codec.h
new file mode 100644
index 0000000000..3b0e4267b1
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.OPUS.codec.h
@@ -0,0 +1,63 @@
+#ifndef __HA_AUDIO_OPUS_CODEC_H__
+#define __HA_AUDIO_OPUS_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef struct {
+   HI_S32 s32Version;
+   HI_U32 u32Channels; /* Number of channels: 1..255 */
+   HI_S32 s32Preskip;
+   HI_U32 u32SampleRate;
+   HI_S32 s32Gain; /* in dB S7.8 should be zero whenever possible */
+   HI_S32 s32ChannelMap;
+   /* The rest is only used if channel_mapping != 0 */
+   HI_S32 s32NBStreams;
+   HI_S32 s32NBCoupled;
+   HI_U8  u8StreamMap[255];
+} OPUS_HEAD_CONFIG_S;
+
+#define HA_OPUS_DecGetDefalutHeadConfig(pConfigParam) \
+    do { \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Version = 1; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u32Channels = 2; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Preskip = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u32SampleRate = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Gain = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32ChannelMap = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32NBStreams = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32NBCoupled = 0; \
+        memset(((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u8StreamMap, 0, 255); \
+    } while (0)
+
+#define HA_OPUS_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(OPUS_HEAD_CONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_OPUS_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.PCM.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.PCM.decode.h
new file mode 100644
index 0000000000..e06b8a7a28
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.PCM.decode.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.PCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_PCM_H__
+#define __HISI_AUDIO_DECODER_PCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_PCM_ID 0x0000        
+
+typedef struct hiWAV_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format category */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* the block alignment (in bytes) of the
+                                      waveform data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* number of bytes of wave raw data cbExtWord*/
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).                      */
+   /* note: big-endian pcm supprt(microsoft wav file only support little-endian pcm format):
+        cbSize = 4;
+        cbExtWord[0] = 1;
+        cbExtWord[1] ; //reserved
+   */
+} WAV_FORMAT_S;
+
+#define HA_PCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(WAV_FORMAT_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_PCM_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h
new file mode 100644
index 0000000000..7fe575bca4
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_TRUEHD_H__
+#define __HISI_AUDIO_DECODER_TRUEHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_TRUEHD_ID 0x0008        
+
+#define HA_TRUEHD_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_TRUEHD_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.VOICE.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.VOICE.codec.h
new file mode 100644
index 0000000000..1fd59e1591
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.VOICE.codec.h
@@ -0,0 +1,116 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G726.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HI_AUDIO_VOICE_CODEC_H__
+#define __HI_AUDIO_VOICE_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef enum
+{
+    HA_VOICE_G711_A      = 0x01,  /**<64kbps G.711 A, see RFC3551.txt  4.5.14 PCMA */ /**<CNcomment: G711 A*/
+    HA_VOICE_G711_U      = 0x02,  /**<64kbps G.711 U, see RFC3551.txt  4.5.14 PCMU */ /**<CNcomment: G711 U*/
+    HA_VOICE_ADPCM_DVI4  = 0x03,  /**<32kbps ADPCM(DVI4) for RTP; see DVI4 diiffers in three respects from the IMA ADPCM at RFC3551.txt 4.5.1 DVI4 */
+                                                /**<CNcomment: RTP ADPCM DVI4*/
+    HA_VOICE_G726_16KBPS = 0x04,  /**<16kbps G.726, see RFC3551.txt  4.5.4 G726-16 */ /**<CNcomment: G726 16kbps*/
+    HA_VOICE_G726_24KBPS = 0x05,  /**<24kbps G.726, see RFC3551.txt  4.5.4 G726-24 */ /**<CNcomment: G726 24kbps*/
+    HA_VOICE_G726_32KBPS = 0x06,  /**<32kbps G.726, see RFC3551.txt  4.5.4 G726-32 */ /**<CNcomment: G726 32kbps*/
+    HA_VOICE_G726_40KBPS = 0x07,  /**<40kbps G.726, see RFC3551.txt  4.5.4 G726-40 */ /**<CNcomment: G726 40kbps*/
+
+    HA_VOICE_ADPCM_IMA   = 0x23,  /**<32kbps ADPCM(IMA) */ /**<CNcomment: 32kbps ADPCM IMA*/
+
+    /**
+    An example of the packing scheme for G726-32 codewords is as shown, and bit A3 is the least significant bit of the first codeword:
+    RTP G726-32:
+    0                   1
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    |B B B B|A A A A|D D D D|C C C C| ...
+    |0 1 2 3|0 1 2 3|0 1 2 3|0 1 2 3|
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+
+    MEDIA G726-32:
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    |A A A A|B B B B|C C C C|D D D D| ...
+    |3 2 1 0|3 2 1 0|3 2 1 0|3 2 1 0|
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    */
+    HA_VOICE_MEDIA_G726_16KBPS = 0x24,  /**<media G726 16kbps for ASF ... */ /**<CNcomment: G726 16kbps*/
+    HA_VOICE_MEDIA_G726_24KBPS = 0x25,  /**<media G726 24kbps for ASF ... */ /**<CNcomment: G726 24kbps*/
+    HA_VOICE_MEDIA_G726_32KBPS = 0x26,  /**<media G726 32kbps for ASF ... */ /**<CNcomment: G726 32kbps*/
+    HA_VOICE_MEDIA_G726_40KBPS = 0x27,  /**<media G726 40kbps for ASF ... */ /**<CNcomment: G726 40kbps*/
+
+    /* ORIGINE VERSION CODEC */
+    HA_VOICE_G711_ORG_A        = 0x41,  /**<original version 64kbps G.711 A */ /**<CNcomment: G711 A*/
+    HA_VOICE_G711_ORG_U        = 0x42,  /**<original version 64kbps G.711 U */ /**<CNcomment: G711 U*/
+    HA_VOICE_ADPCM_ORG_DVI4    = 0x43,  /**<original version 32kbps ADPCM */ /**<CNcomment: ADPCM DVI4*/
+    HA_VOICE_G726_ORG_16KBPS   = 0x44,  /**<original version(DVS1.0) 16kbps G.726 */ /**<CNcomment: G726 16kbps*/
+} HA_VOICE_FORMAT_E;
+
+typedef struct
+{
+    HA_VOICE_FORMAT_E  enVoiceFormat;
+    HI_U32             u32SamplePerFrame;
+} HA_VOICE_OPENCONFIG_S;
+
+#define HA_VOICE_EncGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->enVoiceFormat = HA_VOICE_G711_A; \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->u32SamplePerFrame = 320; \
+    } while (0)
+
+#define HA_VOICE_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 160; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_VOICE_OPENCONFIG_S); \
+} while(0)
+
+#define HA_VOICE_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->enVoiceFormat = HA_VOICE_G711_A; \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->u32SamplePerFrame = 320; \
+    } while (0)
+
+#define HA_VOICE_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_VOICE_OPENCONFIG_S); \
+} while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_AUDIO_VOICE_CODEC_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.VORBIS.codec.h b/xbmc/platform/linux/hisi/HA.AUDIO.VORBIS.codec.h
new file mode 100644
index 0000000000..f7549e50a2
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.VORBIS.codec.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.VORBIS.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_VORBIS_CODEC_H__
+#define __HA_AUDIO_VORBIS_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_VORBIS_DecGetDefalutOpenParam(pOpenParam) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    } while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_VORBIS_CODEC_H__ */
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.WMA9STD.decode.h b/xbmc/platform/linux/hisi/HA.AUDIO.WMA9STD.decode.h
new file mode 100644
index 0000000000..87d5cc899f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.WMA9STD.decode.h
@@ -0,0 +1,146 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.WMA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_WMA_H__
+#define __HISI_AUDIO_DECODER_WMA_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_WMA9STD_ID 0x0006        
+
+typedef struct hiWMA_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format type,0x160->WMAV1,0x161->WMAV2, 0x162->WMAV3 */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* block size of data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* the count in bytes of the size of */
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).
+                                WMAV1: need  4 Bytes extra information at least
+                                    WMAV2: need 10 Bytes extra information at least
+                                WMAV3: need 18 Bytes extra information at least
+                                 */
+} WMA_FORMAT_S;
+
+#define HA_WMA_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_FALSE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(WMA_FORMAT_S); \
+}while(0)
+
+/*=====================================================================
+	CMP demux, only use for debug
+=====================================================================*/
+
+#if 1
+#define HA_WMA_ParseCmp(pfcmp, pstWfx) \
+({ HI_S32 nRead; \
+    nRead=0; \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->wFormatTag), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nChannels), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nSamplesPerSec), sizeof(HI_U32), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nAvgBytesPerSec), sizeof(HI_U32), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nBlockAlign), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->wBitsPerSample), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->cbSize), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    nRead += 7*sizeof(HI_U16)+ 2*sizeof(HI_U32); \
+    if (((WMA_FORMAT_S *)pstWfx)->wFormatTag != 1) \
+    { \
+    } \
+    if (((WMA_FORMAT_S *)pstWfx)->cbSize == 4) \
+    { \
+        ((WMA_FORMAT_S *)pstWfx)->wFormatTag = 0x160; \
+        fread(&(((WMA_FORMAT_S *)pstWfx)->cbExtWord), 1, ((WMA_FORMAT_S *)pstWfx)->cbSize, (FILE *)pfcmp); \
+       	nRead +=((WMA_FORMAT_S *)pstWfx)->cbSize; \
+    } \
+    else if ((((WMA_FORMAT_S *)pstWfx)->cbSize == 10) || (((WMA_FORMAT_S *)pstWfx)->cbSize == (10 + 22))) \
+    { \
+        ((WMA_FORMAT_S *)pstWfx)->wFormatTag = 0x161; \
+        fread(&(((WMA_FORMAT_S *)pstWfx)->cbExtWord), 1, ((WMA_FORMAT_S *)pstWfx)->cbSize, (FILE *)pfcmp); \
+       	nRead +=((WMA_FORMAT_S *)pstWfx)->cbSize; \
+    } \
+    else \
+    { \
+    } \
+    nRead; \
+})
+
+#else
+static HI_S32 HA_WMA_ParseCmp(FILE *pfcmp, WMA_FORMAT_S *pstWfx)
+{
+       HI_S32 nRead=0;
+
+#if 1                                                                 
+	fread(&(pstWfx->wFormatTag), sizeof(HI_U16), 1, pfcmp);       
+	fread(&(pstWfx->nChannels), sizeof(HI_U16), 1, pfcmp);        
+	fread(&(pstWfx->nSamplesPerSec), sizeof(HI_U32), 1, pfcmp);   
+	fread(&(pstWfx->nAvgBytesPerSec), sizeof(HI_U32), 1, pfcmp);  
+	fread(&(pstWfx->nBlockAlign), sizeof(HI_U16), 1, pfcmp);      
+	fread(&(pstWfx->wBitsPerSample), sizeof(HI_U16), 1, pfcmp);   
+	fread(&(pstWfx->cbSize), sizeof(HI_U16), 1, pfcmp);           
+	nRead += 7*sizeof(HI_U16)+ 2*sizeof(HI_U32);                  
+#endif                                                                
+	if (pstWfx->wFormatTag != 1) // not v1 or v2
+	{
+		//HA_PRINT("Support only CMP V1 format wFormatTag=0x%x!\n",pstWfx->wFormatTag);
+		return -1;
+	}
+
+	if (pstWfx->cbSize == 4)  //g45208
+	{
+		//WMA v1 bitstream
+		pstWfx->wFormatTag = 0x160;
+		fread(&pstWfx->cbExtWord, 1, pstWfx->cbSize, pfcmp);
+       	nRead +=pstWfx->cbSize;
+	}
+	else if ((pstWfx->cbSize == 10) || (pstWfx->cbSize == (10 + 22) ) )  //g45208
+	{
+		//WMA v2/v3 bitstream
+		pstWfx->wFormatTag = 0x161;
+		fread(&pstWfx->cbExtWord, 1, pstWfx->cbSize, pfcmp);
+       	nRead +=pstWfx->cbSize;
+	}
+	else
+	{
+		//HA_PRINT("Error cbSize=%d\n",pstWfx->cbSize);
+		return -1;
+	}
+	return nRead;
+}
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_WMA_H__ */
+
diff --git a/xbmc/platform/linux/hisi/HA.AUDIO.codec.common.h b/xbmc/platform/linux/hisi/HA.AUDIO.codec.common.h
new file mode 100644
index 0000000000..5a1d14e92e
--- /dev/null
+++ b/xbmc/platform/linux/hisi/HA.AUDIO.codec.common.h
@@ -0,0 +1,28 @@
+#ifndef __HISI_AUDIO_CODEC_COMMON_H__
+#define __HISI_AUDIO_CODEC_COMMON_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HA_CHECK_MEM_SUCCESS(api)\
+do {\
+    errno_t _ret_mem_ = (api); \
+    if(EOK != _ret_mem_) { \
+        HA_ERR_PRINT("%s[%d]:%s failed(0x%x)\n", __FUNCTION__, __LINE__, #api, _ret_mem_); \
+    } \
+} while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_COMMON_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_adp.h b/xbmc/platform/linux/hisi/hi_adp.h
new file mode 100644
index 0000000000..5c5629cd0f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp.h
@@ -0,0 +1,131 @@
+#ifndef __HI_ADP_H__
+#define __HI_ADP_H__
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "hi_type.h"
+
+#if defined(ANDROID)
+extern void LogPrint(const char *format, ...);
+#endif
+
+#ifdef CONFIG_SUPPORT_CA_RELEASE
+#define sample_common_printf
+#else
+#if defined(ANDROID)
+#define sample_common_printf LogPrint
+#else
+#define sample_common_printf printf
+#endif
+#endif
+
+#define HIAPI_RUN(api, ret) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            ret |= errCode; \
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN(api) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN_FN(api, fn) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            fn; \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_ERR_PRINTF(ret) \
+    do {\
+        sample_common_printf("\033[0;31m" " [Function: %s line: %d]  ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, ret); \
+    } while (0)\
+
+
+#define PRINT_SMP(fmt...) sample_common_printf(fmt)
+
+#define SAMPLE_RUN(api, ret) \
+    do { \
+        HI_S32 l_ret = api; \
+        if (l_ret != HI_SUCCESS) \
+        { \
+            PRINT_SMP("run %s failed, ERRNO:%#x.\n", # api, l_ret); \
+        } \
+        else \
+        {\
+            /*printf("sample %s: run %s ok.\n", __FUNCTION__, #api);}*/ \
+        } \
+        ret = l_ret; \
+    } while (0)
+
+#define SAMPLE_CheckNullPTR(pointer) \
+    do  \
+    { \
+        if (NULL == pointer) \
+        {   \
+            PRINT_SMP("%s failed:NULL Pointer in Line:%d!\n", __FUNCTION__, __LINE__); \
+            return HI_FAILURE;  \
+        }   \
+    } while (0)
+
+#ifdef ANDROID
+#define SAMPLE_GET_INPUTCMD(InputCmd)   \
+    do { \
+        memset(InputCmd, 0, sizeof(InputCmd)); \
+        read(0, InputCmd, sizeof(InputCmd)); \
+    } while (0)
+
+#define HISI_SAMPLE_FIFO "/dev/hisi_sample_fifo"
+
+#define HI_GET_INPUTCMD(InputCmd)   \
+    do { \
+        int t_fd; \
+        unlink(HISI_SAMPLE_FIFO); \
+        if (mkfifo(HISI_SAMPLE_FIFO, 0777) != -1) \
+        { \
+            t_fd = open(HISI_SAMPLE_FIFO, O_RDONLY); \
+            if (t_fd != -1)  \
+            { \
+                memset(InputCmd, 0, sizeof(InputCmd));   \
+                read(t_fd, InputCmd, sizeof(InputCmd));  \
+                close(t_fd); \
+            } \
+            else  \
+            { \
+                perror("Can't open the FIFO:");  \
+                exit(0); \
+            } \
+        } \
+        else  \
+        { \
+            perror("Can't create FIFO channel:"); \
+            exit(0); \
+        } \
+    } while (0)
+#else
+#define SAMPLE_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+
+#define HI_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+#endif
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_adp_boardcfg.h b/xbmc/platform/linux/hisi/hi_adp_boardcfg.h
new file mode 100644
index 0000000000..e8dabe7383
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_boardcfg.h
@@ -0,0 +1,117 @@
+#ifndef __BOARDCFG_H__
+#define __BOARDCFG_H__
+
+#include "hi_unf_demux.h"
+#include "hi_unf_frontend.h"
+#include "hi_adp_ini.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HI_TUNER_NUMBER
+#define HI_TUNER_NUMBER         8
+#endif
+
+#ifdef ANDROID
+#define FRONTEND_CONFIG_PATH  "/system/lib/"
+#else
+#define FRONTEND_CONFIG_PATH  "/usr/local/cfg/"
+#endif
+#define FRONTEND_CONFIG_FILE  FRONTEND_CONFIG_PATH "frontend_config.ini"
+#define TUNERNUM_SECTION      "tunernum"
+#define SECTION_MAX_LENGTH    (64)
+
+#define USE_I2C      (0)
+#define NOT_MODIFY   (0)
+#define NEED_RESET   (1)
+#define USER_DEFINED (1)
+
+/* The default value when read failed. */
+#define DEFAULT_TUNER_NUM        (1)
+#define DEFAULT_SIG_TYPE         (HI_UNF_TUNER_SIG_TYPE_CAB)
+
+/* Tuner and Demod device and info. */
+#define DEFAULT_TUNER_TYPE        (HI_UNF_TUNER_DEV_TYPE_TDA18250B)
+#define DEFAULT_TUNER_ADDR        (0xc0)
+#define DEFAULT_DEMOD_TYPE        (HI_UNF_DEMOD_DEV_TYPE_3130E)
+#define DEFAULT_DEMOD_ADDR        (0xa0)
+#define DEFAULT_DEMOD_OUTPUT_MODE (HI_UNF_TUNER_OUTPUT_MODE_SERIAL)
+#define DEFAULT_DEMOD_RST_TYPE    (NEED_RESET)
+#define DEFAULT_DEMOD_RST_GPIO    (0)
+#define DEFAULT_MEMORY_MODE       (0)
+
+/* I2C */
+#define DEFAULT_I2C_TYPE          (USE_I2C)
+#define DEFAULT_I2C_CHNUM         (1)
+#define DEFAULT_GPIOI2C_SCL       (0)
+#define DEFAULT_GPIOI2C_SDA       (0)
+
+/* TSOUT  */
+#define DEFAULT_DEMOD_TSOUT_MODE    (NOT_MODIFY)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT0 (HI_UNF_TUNER_OUTPUT_TSDAT0)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT1 (HI_UNF_TUNER_OUTPUT_TSDAT1)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT2 (HI_UNF_TUNER_OUTPUT_TSDAT2)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT3 (HI_UNF_TUNER_OUTPUT_TSDAT3)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT4 (HI_UNF_TUNER_OUTPUT_TSDAT4)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT5 (HI_UNF_TUNER_OUTPUT_TSDAT5)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT6 (HI_UNF_TUNER_OUTPUT_TSDAT6)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT7 (HI_UNF_TUNER_OUTPUT_TSDAT7)
+#define DEFAULT_DEMOD_OUTPUT_TSSYNC (HI_UNF_TUNER_OUTPUT_TSSYNC)
+#define DEFAULT_DEMOD_OUTPUT_TSVLD  (HI_UNF_TUNER_OUTPUT_TSVLD)
+#define DEFAULT_DEMOD_OUTPUT_TSERR  (HI_UNF_TUNER_OUTPUT_TSERR)
+
+/* Demux Attr */
+#define DEFAULT_DEMUX_PORT          (HI_UNF_DMX_PORT_TSI_0)
+#define DEFAULT_DEMUX_PORT_TYPE     (HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC)
+#define DEFAULT_DEMUX_PORT_SHARECLK (HI_UNF_DMX_PORT_TSI_0)
+#define DEFAULT_DEMUX_BITSEL        (1)
+#define DEFAULT_DEMUX_INCLK         (0)
+
+/*  Cable Attr */
+#define DEFAULT_CAB_DEMOD_CLK       (24000) /*KHz*/
+#define DEFAULT_CAB_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+
+/*  Sat Attr */
+#define DEFAULT_SAT_DEMOD_CLK       (16000) /*KHz*/
+#define DEFAULT_SAT_TUNER_MAXLPF    (34)    /*MHz*/
+#define DEFAULT_SAT_TUNER_I2CCLK    (400)   /*KHz*/
+#define DEFAULT_SAT_RF_AGC          (HI_UNF_TUNER_RFAGC_INVERT)
+#define DEFAULT_SAT_IQ_SPECTRUM     (HI_UNF_TUNER_IQSPECTRUM_NORMAL)
+#define DEFAULT_SAT_TS_CLK_POLAR    (HI_UNF_TUNER_TSCLK_POLAR_RISING)
+#define DEFAULT_SAT_TS_FORMAT       (HI_UNF_TUNER_TS_FORMAT_TS)
+#define DEFAULT_SAT_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+#define DEFAULT_SAT_DISEQC_WAVE     (HI_UNF_TUNER_DISEQCWAVE_NORMAL)
+#define DEFAULT_SAT_LNBCTRL_DEV     (HI_UNF_LNBCTRL_DEV_TYPE_MPS8125)
+#define DEFAULT_SAT_LNBCTRL_DEV_ADDR (0)
+
+/* Ter Attr */
+#define DEFAULT_TER_DEMOD_CLK       (24000) /*KHz*/
+#define DEFAULT_TER_TUNER_MAXLPF    (34)    /*MHz*/
+#define DEFAULT_TER_TUNER_I2CCLK    (400)   /*KHz*/
+#define DEFAULT_TER_RF_AGC          (HI_UNF_TUNER_RFAGC_INVERT)
+#define DEFAULT_TER_IQ_SPECTRUM     (HI_UNF_TUNER_IQSPECTRUM_NORMAL)
+#define DEFAULT_TER_TS_CLK_POLAR    (HI_UNF_TUNER_TSCLK_POLAR_RISING)
+#define DEFAULT_TER_TS_FORMAT       (HI_UNF_TUNER_TS_FORMAT_TS)
+#define DEFAULT_TER_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+#define DEFAULT_TER_TS_SYNC_HEAD    (HI_UNF_TUNER_TS_SYNC_HEAD_AUTO)
+
+/* TSO */
+#define DEFAULT_DEMUX_TSO_NUM       (1)
+/* TSO Attr */
+#define DEFAULT_DEMUX_TSO_CLK       (HI_UNF_DMX_TSO_CLK_1200M)
+#define DEFAULT_DEMUX_TSO_CLK_MODE  (HI_UNF_DMX_TSO_CLK_MODE_NORMAL)
+#define DEFAULT_DEMUX_TSO_VLD_MODE  (HI_UNF_DMX_TSO_VALID_ACTIVE_HIGH)
+#define DEFAULT_DEMUX_TSO_PORT_TYPE (HI_UNF_DMX_PORT_TYPE_SERIAL)
+#define DEFAULT_DEMUX_TSO_BITSEL    (HI_UNF_DMX_TSO_SERIAL_BIT_0)
+
+
+#define TUNER_USE        (0)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/xbmc/platform/linux/hisi/hi_adp_data.h b/xbmc/platform/linux/hisi/hi_adp_data.h
new file mode 100644
index 0000000000..ed4695f0fa
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_data.h
@@ -0,0 +1,138 @@
+#ifndef _COMMON_DATA_H
+#define _COMMON_DATA_H
+
+#include "hi_type.h"
+
+#define     MAX_PROGNAME_LENGTH 32
+#define     MAX_AUDIO_LANGUAGE 5
+#define     MAX_PROG_COUNT 200
+#define     MAX_FRONTEND_COUNT 30
+
+#define     SEARCHING_FRONTEND_ID	0xffff
+
+typedef enum hiFRONTEND_TYPE_E
+{
+    FE_TYPE_RF   = 1,
+    FE_TYPE_IP   = 2,
+    FE_TYPE_FILE = 3
+} FRONTEND_TYPE_E;
+
+typedef enum hiFILE_TYPE_E
+{
+    FILE_TYPE_TS = 0,
+    FILE_TYPE_ES = 1,
+}FILE_TYPE_E;
+
+typedef enum hiFILE_AUDIO_TYPE_E
+{
+    FILE_AUDIO_TYPE_NONE = 0,
+    FILE_AUDIO_TYPE_AAC   = 1,
+    FILE_AUDIO_TYPE_MP3   = 2,
+    FILE_AUDIO_TYPE_AC3   = 3,
+    FILE_AUDIO_TYPE_DTS = 4,
+    FILE_AUDIO_TYPE_DRA = 5
+} FILE_AUDIO_TYPE_E;
+
+typedef enum hiFILE_VIDEO_TYPE_E
+{
+    FILE_VIDEO_TYPE_NONE = 0,
+    FILE_VIDEO_TYPE_MPEG2   = 1,
+    FILE_VIDEO_TYPE_MPEG4   = 2,
+    FILE_VIDEO_TYPE_H263 = 3,
+    FILE_VIDEO_TYPE_H264 = 4,
+    FILE_VIDEO_TYPE_AVS = 5,
+    FILE_VIDEO_TYPE_REAL = 6,
+    FILE_VIDEO_TYPE_AV1 = 7
+} FILE_VIDEO_TYPE_E;
+
+typedef struct hiFE_TYPEIP_S
+{
+    HI_CHAR multiIPAddr[20];
+    HI_U32  port;
+} FE_TYPE_IP_S;
+
+typedef struct hiFE_TYPERF_S
+{
+    HI_U32 u32TunerPort; /*Tuner port*/
+    HI_U32 u32Frequency;  /*unit:MHZ */
+    HI_U32 u32SymbolRate; /*unit:KHZ*/
+    HI_U32 u32Modulation;  /* 0:16QAM 1:32QAM 2:64QAM 3:128QAM 4:256QAM*/
+} FE_TYPE_RF_S;
+
+typedef struct hiFE_TYPEFILE_S
+{
+    HI_CHAR path[256];
+    FILE_TYPE_E filetype;
+    FILE_VIDEO_TYPE_E videotype;
+    FILE_AUDIO_TYPE_E audiotype;
+} FE_TYPE_FILE_S;
+
+/* channel dot struct */
+typedef struct hiDB_FRONTEND_S
+{
+    FRONTEND_TYPE_E eFEType;
+    HI_U16          u16NetworkID;
+    HI_U16          u16TsID;
+    union
+    {
+	 FE_TYPE_FILE_S  sFEParaFile;  //file type
+        FE_TYPE_IP_S    sFEParaIp;  //IP type
+        FE_TYPE_RF_S    sFEParaRf; //RF type
+    }unFEtype;
+
+} DB_FRONTEND_S;
+
+/* program struct */
+typedef struct hiDB_VIDEOEX_S
+{
+    HI_U16 u16VideoPid;
+    HI_U32 u32VideoEncType;
+} DB_VIDEOEX_S;
+
+typedef struct hiDB_AUDIOEX_S
+{
+    HI_U16 u16audiopid;
+    HI_U16 u16audiolan;
+    HI_U32 u32AudioEncType;
+} DB_AUDIOEX_S;
+
+typedef struct  hiDB_PROGRAM_S
+{
+    HI_U16 u16FrontendID;
+    HI_U16 u16NetworkID;
+    HI_U16 u16TsID;
+    HI_U16 u16ServiceID;
+
+    HI_U8 enServiceType;
+
+    HI_S8 ProgramName[MAX_PROGNAME_LENGTH];
+
+    HI_U16 u16PmtPid;
+    HI_U16 u16PcrPid;
+
+    HI_U32 u16ProgProperty;
+
+    HI_U16 u16AudioVol;
+    HI_U8  u8AudioChannel;
+    HI_U8  u8VideoChannel;
+
+    DB_VIDEOEX_S VideoEX;
+    DB_AUDIOEX_S AudioEX[MAX_AUDIO_LANGUAGE];
+
+    HI_U16 Reserved;
+} DB_PROGRAM_S;
+
+HI_S32   DB_GetDVBProgInfoByServiceID(HI_U16 u16ServiceID, DB_PROGRAM_S *proginfo );
+HI_S32	DB_GetDVBProgInfo(HI_U32 prognum, DB_PROGRAM_S *proginfo );
+HI_S32	DB_SetDVBProgInfo(HI_U32 prognum, DB_PROGRAM_S *proginfo );
+HI_S32	DB_AddDVBProg(DB_PROGRAM_S *proginfo );
+HI_S32	DB_GetProgTotalCount(void);
+HI_S32	DB_GetFEChanInfo(HI_U32 channum, DB_FRONTEND_S *chaninfo );
+HI_S32	DB_SetFEChanInfo(HI_U32 channum, DB_FRONTEND_S *chaninfo );
+HI_S32	DB_AddFEChan(DB_FRONTEND_S *chaninfo);
+HI_S32	DB_GetFEChanTotalCount(void);
+HI_S32	DB_Reset(void);
+HI_S32	DB_RestoreFromFile(FILE *filestream);
+HI_S32	DB_SaveToFile(FILE *filestream);
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_adp_hdmi.c b/xbmc/platform/linux/hisi/hi_adp_hdmi.c
new file mode 100644
index 0000000000..57a125a850
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_hdmi.c
@@ -0,0 +1,572 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "hi_unf_hdmi.h"
+#include "hi_unf_edid.h"
+#include "hi_unf_disp.h"
+#include "hi_adp.h"
+#include "hi_adp_hdmi.h"
+#include "hi_unf_pdm.h"
+
+typedef struct
+{
+    HI_UNF_HDMI_ID_E  enHdmi;
+    HI_U32            u32HdcpVersion;
+} HDMI_ARGS_S;
+
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+static HI_BOOL s_bFirstTiming = HI_TRUE;
+static HI_UNF_ENC_FMT_E s_enHdmiFormat;
+static HI_UNF_ENC_FMT_E s_enCvbsFormat;
+#endif
+
+static HDMI_ARGS_S g_stHdmiArgs;
+HI_U32 g_HDCPFlag         = HI_FALSE;
+HI_U32 g_HDMI_Bebug       = HI_FALSE;
+HI_U32 g_HDMIUserCallbackFlag = HI_FALSE;
+HI_U32 g_enDefaultMode    = HI_UNF_HDMI_DEFAULT_ACTION_HDMI;//HI_UNF_HDMI_DEFAULT_ACTION_NULL;
+HI_UNF_HDMI_CALLBACK_FUNC_S g_stCallbackFunc;
+
+User_HDMI_CallBack pfnHdmiUserCallback = NULL;
+
+#ifdef HI_HDCP_SUPPORT
+const HI_CHAR * pstencryptedHdcpKey = "EncryptedKey_332bytes.bin";
+#endif
+
+static HI_CHAR *g_pDispFmtString[HI_UNF_ENC_FMT_BUTT+1] = {
+    "1080P_60",
+    "1080P_50",
+    "1080P_30",
+    "1080P_25",
+
+    "1080P_24",
+    "1080i_60",
+    "1080i_50",
+
+    "720P_60",
+    "720P_50",
+
+    "576P_50",
+    "480P_60",
+
+    "PAL",
+    "PAL_N",
+    "PAL_Nc",
+
+    "NTSC",
+    "NTSC_J",
+    "NTSC_PAL_M",
+
+    "SECAM_SIN",
+    "SECAM_COS",
+
+    "1080P_24_FP",
+    "720P_60_FP",
+    "720P_50_FP",
+
+    "861D_640X480_60",
+    "VESA_800X600_60",
+    "VESA_1024X768_60",
+    "VESA_1280X720_60",
+    "VESA_1280X800_60",
+    "VESA_1280X1024_60",
+    "VESA_1360X768_60",
+    "VESA_1366X768_60",
+    "VESA_1400X1050_60",
+    "VESA_1440X900_60",
+    "VESA_1440X900_60_RB",
+    "VESA_1600X900_60_RB",
+    "VESA_1600X1200_60",
+    "VESA_1680X1050_60",
+    "VESA_1680X1050_60_RB",
+    "VESA_1920X1080_60",
+    "VESA_1920X1200_60",
+    "VESA_1920X1440_60",
+    "VESA_2048X1152_60",
+    "VESA_2560X1440_60_RB",
+    "VESA_2560X1600_60_RB",
+
+    "2160P_24",
+    "2160P_25",
+    "2160P_30",
+    "4090X2160_24",
+
+    "BUTT"
+};
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt)
+{
+    HI_S32 i;
+    HI_UNF_ENC_FMT_E fmtReturn = HI_UNF_ENC_FMT_BUTT;
+
+    if (NULL == pszFmt)
+    {
+        return HI_UNF_ENC_FMT_BUTT;
+    }
+
+    for (i = 0; i < HI_UNF_ENC_FMT_BUTT; i++)
+    {
+        if (strcasestr(pszFmt, g_pDispFmtString[i]))
+        {
+            fmtReturn = i;
+            break;
+        }
+    }
+
+    if (i >= HI_UNF_ENC_FMT_BUTT)
+    {
+        i = HI_UNF_ENC_FMT_720P_50;
+        fmtReturn = i;
+        sample_common_printf("\n!!! Can NOT match format, set format to is '%s'/%d.\n\n", g_pDispFmtString[i], i);
+    }
+    else
+    {
+        sample_common_printf("\n!!! The format is '%s'/%d.\n\n", g_pDispFmtString[i], i);
+    }
+    return fmtReturn;
+}
+
+static HI_VOID HDMI_PrintAttr(HI_UNF_HDMI_ATTR_S *pstHDMIAttr)
+{
+    if (HI_TRUE != g_HDMI_Bebug)
+    {
+        return;
+    }
+
+    sample_common_printf("=====HI_UNF_HDMI_SetAttr=====\n"
+           "bEnableHdmi:%d\n"
+           "bEnableVideo:%d\n"
+           "enVidOutMode:%d\n"
+           "enDeepColorMode:%d\n"
+           "bxvYCCMode:%d\n\n"
+           "bEnableAudio:%d\n"
+           "bEnableAviInfoFrame:%d\n"
+           "bEnableAudInfoFrame:%d\n"
+           "bEnableSpdInfoFrame:%d\n"
+           "bEnableMpegInfoFrame:%d\n\n"
+           "==============================\n",
+           pstHDMIAttr->bEnableHdmi,
+           pstHDMIAttr->bEnableVideo,
+           pstHDMIAttr->enVidOutMode,pstHDMIAttr->enDeepColorMode,pstHDMIAttr->bxvYCCMode,
+           pstHDMIAttr->bEnableAudio,
+           pstHDMIAttr->bEnableAudInfoFrame,pstHDMIAttr->bEnableAudInfoFrame,
+           pstHDMIAttr->bEnableSpdInfoFrame,pstHDMIAttr->bEnableMpegInfoFrame);
+    return;
+}
+
+void HDMI_HotPlug_Proc(HI_VOID *pPrivateData)
+{
+    HI_S32          ret = HI_SUCCESS;
+    HDMI_ARGS_S     *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E       hHdmi   =  pArgs->enHdmi;
+    HI_UNF_HDMI_ATTR_S             stHdmiAttr;
+    //HI_UNF_HDMI_INFOFRAME_S        stInfoFrame;
+    HI_UNF_EDID_BASE_INFO_S        stSinkCap;
+    HI_UNF_HDMI_STATUS_S           stHdmiStatus;
+
+#ifdef HI_HDCP_SUPPORT
+    static HI_U8 u8FirstTimeSetting = HI_TRUE;
+#endif
+
+    sample_common_printf("\n --- Get HDMI event: HOTPLUG. --- \n");
+
+    HI_UNF_HDMI_GetStatus(hHdmi,&stHdmiStatus);
+    if (HI_FALSE == stHdmiStatus.bConnected)
+    {
+        sample_common_printf("No Connect\n");
+        return;
+    }
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    {
+        HI_UNF_DISP_INTF_S          DispIntf;
+
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        sample_common_printf("switch to hdmi output\n");
+        if (s_bFirstTiming)
+        {
+            s_bFirstTiming = HI_FALSE;
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY0, &s_enCvbsFormat);
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY1, &s_enHdmiFormat);
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        }
+        else
+        {
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+            HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, s_enHdmiFormat);
+            //HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_AUTO);
+            //HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISPLAY1, HI_UNF_DISP_COLOR_SPACE_AUTO);
+        }
+    }
+#endif
+
+    HI_UNF_HDMI_GetAttr(hHdmi, &stHdmiAttr);
+    ret = HI_UNF_HDMI_GetSinkCapability(hHdmi, &stSinkCap);
+    if (ret == HI_SUCCESS)
+    {
+        //stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_YCBCR444;
+        if(HI_TRUE == stSinkCap.bSupportHdmi)
+        {
+            stHdmiAttr.bEnableHdmi = HI_TRUE;
+            if(HI_TRUE != stSinkCap.stColorSpace.bYCbCr444)
+            {
+                stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+            }
+            /* no change attr to make sure app smoothly */
+            //else
+            //{
+            //    stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_YCBCR444;  /* user can choicen RGB/YUV*/
+            //}
+        }
+        else
+        {
+            stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+            //edidhdmidvi
+            //read real edid ok && sink not support hdmi,then we run in dvi mode
+            stHdmiAttr.bEnableHdmi = HI_FALSE;
+        }
+    }
+    else
+    {
+        //when get capability fail,use default mode
+        if (g_enDefaultMode != HI_UNF_HDMI_DEFAULT_ACTION_DVI)
+            stHdmiAttr.bEnableHdmi = HI_TRUE;
+        else
+            stHdmiAttr.bEnableHdmi = HI_FALSE;
+    }
+
+    if (HI_TRUE == stHdmiAttr.bEnableHdmi)
+    {
+        stHdmiAttr.bEnableAudio = HI_TRUE;
+        stHdmiAttr.bEnableVideo = HI_TRUE;
+        stHdmiAttr.bEnableAudInfoFrame = HI_TRUE;
+        stHdmiAttr.bEnableAviInfoFrame = HI_TRUE;
+    }
+    else
+    {
+        stHdmiAttr.bEnableAudio = HI_FALSE;
+        stHdmiAttr.bEnableVideo = HI_TRUE;
+        stHdmiAttr.bEnableAudInfoFrame = HI_FALSE;
+        stHdmiAttr.bEnableAviInfoFrame = HI_FALSE;
+        stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+    }
+
+#ifdef HI_HDCP_SUPPORT
+    if (u8FirstTimeSetting == HI_TRUE)
+    {
+        u8FirstTimeSetting = HI_FALSE;
+        if (g_HDCPFlag == HI_TRUE)
+        {
+            stHdmiAttr.bHDCPEnable = HI_TRUE;//Enable HDCP
+        }
+        else
+        {
+            stHdmiAttr.bHDCPEnable= HI_FALSE;
+        }
+    }
+    else
+    {
+        //HDCP Enable use default setting!!
+    }
+#endif
+
+    ret = HI_UNF_HDMI_SetAttr(hHdmi, &stHdmiAttr);
+#if 0/*TODU: maybe need enable*/
+    HI_UNF_HDMI_HDCP_PARAM_S stHdcpParam;
+
+    if (stSinkCap.stHDCPSupport.bHdcp22Support == HI_TRUE)
+    {
+        stHdcpParam.bHdcpEnable = HI_TRUE;
+        stHdcpParam.enHdcpMode = HI_UNF_HDMI_HDCP_MODE_2_2;
+        HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_0, &stHdcpParam);
+    }
+    else if (stSinkCap.stHDCPSupport.bHdcp14Support == HI_TRUE)
+    {
+        //HIADP_HDMI_SetHDCPKey(HI_UNF_HDMI_ID_0);
+        stHdcpParam.bHdcpEnable = HI_TRUE;
+        stHdcpParam.enHdcpMode = HI_UNF_HDMI_HDCP_MODE_1_4;
+        HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_0, &stHdcpParam);
+    }
+#endif
+    /* HI_UNF_HDMI_SetAttr must before HI_UNF_HDMI_Start! */
+    ret = HI_UNF_HDMI_Start(hHdmi);
+
+    HDMI_PrintAttr(&stHdmiAttr);
+
+    return;
+}
+
+HI_VOID HDMI_UnPlug_Proc(HI_VOID *pPrivateData)
+{
+    HDMI_ARGS_S     *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E       hHdmi   =  pArgs->enHdmi;
+
+    sample_common_printf("\n --- Get HDMI event: UnPlug. --- \n");
+    HI_UNF_HDMI_Stop(hHdmi);
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    {
+        HI_UNF_DISP_INTF_S          DispIntf;
+
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        sample_common_printf("switch to cvbs output\n");
+        if (s_bFirstTiming)
+        {
+            s_bFirstTiming = HI_FALSE;
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY0, &s_enCvbsFormat);
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY1, &s_enHdmiFormat);
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        }
+        else
+        {
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+            HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, s_enCvbsFormat);
+            //HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_NONE);
+        }
+    }
+#endif
+    return;
+}
+
+static HI_U32 HDCPFailCount = 0;
+
+HI_VOID HDMI_HdcpFail_Proc(HI_VOID *pPrivateData)
+{
+    HI_UNF_HDMI_STATUS_S        stHdmiStatus;
+    HDMI_ARGS_S                 *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E            hHdmi   =  pArgs->enHdmi;
+    HI_U32                      u32Ret  = HI_FAILURE;
+
+    memset(&stHdmiStatus, 0, sizeof(HI_UNF_HDMI_STATUS_S));
+    u32Ret = HI_UNF_HDMI_GetStatus(hHdmi, &stHdmiStatus);
+    if(u32Ret != HI_SUCCESS)
+    {
+        sample_common_printf("get hdmi status failed! \n");
+    }
+#ifdef HI_HDCP_SUPPORT
+#if defined(HI_HDMI_SUPPORT_2_0)
+    {
+        HI_UNF_HDCP_STATUS_S        stHdcpStatus ;
+        HI_UNF_HDMI_GetHdcpStatus(hHdmi,&stHdcpStatus );
+    	sample_common_printf("\nSTATUS:bHdcpEnable=%d,enHdcpVersion=%d,enHdcpErrCode=%d\n\n",
+            stHdcpStatus.bHdcpEnable,stHdcpStatus.enHdcpVersion,stHdcpStatus.enHdcpErrCode);
+    }
+#endif
+#endif
+    sample_common_printf("\n --- Get HDMI event: HDCP_FAIL, version(%d). --- \n", stHdmiStatus.enHDCPVersion);
+    HDCPFailCount ++ ;
+    if(HDCPFailCount >= 50)
+    {
+        HDCPFailCount = 0;
+        sample_common_printf("\nWarrning:Customer need to deal with HDCP Fail!!!!!!\n");
+    }
+#if 0
+    HI_UNF_HDMI_GetAttr(0, &stHdmiAttr);
+
+    stHdmiAttr.bHDCPEnable = HI_FALSE;
+
+    HI_UNF_HDMI_SetAttr(0, &stHdmiAttr);
+#endif
+    return;
+}
+
+HI_VOID HDMI_HdcpSuccess_Proc(HI_VOID *pPrivateData)
+{
+    HI_UNF_HDMI_STATUS_S        stHdmiStatus;
+    HDMI_ARGS_S                 *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E            hHdmi   =  pArgs->enHdmi;
+    HI_U32                      u32Ret  = HI_FAILURE;
+
+    memset(&stHdmiStatus, 0, sizeof(HI_UNF_HDMI_STATUS_S));
+    u32Ret = HI_UNF_HDMI_GetStatus(hHdmi, &stHdmiStatus);
+    if(u32Ret != HI_SUCCESS)
+    {
+        sample_common_printf("get hdmi status failed! \n");
+    }
+#ifdef HI_HDCP_SUPPORT
+#if defined(HI_HDMI_SUPPORT_2_0)
+    {
+        HI_UNF_HDCP_STATUS_S        stHdcpStatus ;
+        HI_UNF_HDMI_GetHdcpStatus(hHdmi,&stHdcpStatus );
+        sample_common_printf("\nSTATUS:bHdcpEnable=%d,enHdcpVersion=%d,enHdcpErrCode=%d\n\n",
+            stHdcpStatus.bHdcpEnable,stHdcpStatus.enHdcpVersion,stHdcpStatus.enHdcpErrCode);
+    }
+#endif
+#endif
+
+    sample_common_printf("\n --- Get HDMI event: HDCP_SUCCESS, version(%d) --- \n", stHdmiStatus.enHDCPVersion);
+    return;
+}
+
+HI_VOID HDMI_Event_Proc(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData)
+{
+    switch (event)
+    {
+        case HI_UNF_HDMI_EVENT_HOTPLUG:
+            HDMI_HotPlug_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_NO_PLUG:
+            HDMI_UnPlug_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_EDID_FAIL:
+            break;
+        case HI_UNF_HDMI_EVENT_HDCP_FAIL:
+            HDMI_HdcpFail_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_HDCP_SUCCESS:
+            HDMI_HdcpSuccess_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_RSEN_CONNECT:
+            //printf("HI_UNF_HDMI_EVENT_RSEN_CONNECT**********\n");
+            break;
+        case HI_UNF_HDMI_EVENT_RSEN_DISCONNECT:
+            //printf("HI_UNF_HDMI_EVENT_RSEN_DISCONNECT**********\n");
+            break;
+        default:
+            break;
+    }
+    /* Private Usage */
+    if ((g_HDMIUserCallbackFlag == HI_TRUE) && (pfnHdmiUserCallback != NULL))
+    {
+        pfnHdmiUserCallback(event, NULL);
+    }
+
+    return;
+}
+
+#ifdef HI_HDCP_SUPPORT
+#define ENCRYPTED_HDCP_KEY_MAX_LEN  332
+
+HI_S32 HIADP_HDMI_SetHDCPKey(HI_UNF_HDMI_ID_E HDMIId)
+{
+    HI_S32                  Ret;
+    FILE                   *pKeyFile;
+    HI_U8                   Key[ENCRYPTED_HDCP_KEY_MAX_LEN];
+    HI_S32                  Len;
+    HI_UNF_HDMI_LOAD_KEY_S  LoadKey;
+
+    pKeyFile = fopen(pstencryptedHdcpKey, "rb");
+    if (HI_NULL == pKeyFile)
+    {
+        sample_common_printf("can't open key file %s\n", pstencryptedHdcpKey);
+        return HI_FAILURE;
+    }
+
+    Len = fread(Key, 1, ENCRYPTED_HDCP_KEY_MAX_LEN, pKeyFile);
+
+    fclose(pKeyFile);
+
+    if (Len != ENCRYPTED_HDCP_KEY_MAX_LEN)
+    {
+        sample_common_printf("%s is error key file!\n", pstencryptedHdcpKey);
+        return HI_FAILURE;
+    }
+
+    LoadKey.u32KeyLength = ENCRYPTED_HDCP_KEY_MAX_LEN;
+    LoadKey.pu8InputEncryptedKey = Key;
+
+    Ret = HI_UNF_HDMI_LoadHDCPKey(HDMIId, &LoadKey);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_HDMI_LoadHDCPKey failed 0x%x\n", Ret);
+        return HI_FAILURE;
+    }
+
+    sample_common_printf("Load HDCP Key: SUCCESS!!!\n");
+
+    return HI_SUCCESS;
+}
+#endif
+
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId)
+{
+    HI_S32 Ret = HI_FAILURE;
+    HI_UNF_HDMI_OPEN_PARA_S stOpenParam;
+    HI_UNF_HDMI_DELAY_S  stDelay;
+
+    g_stHdmiArgs.enHdmi       = enHDMIId;
+
+    Ret = HI_UNF_HDMI_Init();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_HDMI_Init failed:%#x\n",Ret);
+        return HI_FAILURE;
+    }
+
+#ifdef HI_HDCP_SUPPORT
+    Ret = HIADP_HDMI_SetHDCPKey(enHDMIId);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("Set hdcp error\n");
+    }
+#endif
+
+    HI_UNF_HDMI_GetDelay(0,&stDelay);
+    stDelay.bForceFmtDelay = HI_TRUE;
+    stDelay.bForceMuteDelay = HI_TRUE;
+
+#if defined(CHIP_TYPE_hi3798mv200) || defined(CHIP_TYPE_hi3798mv300)
+    stDelay.u32FmtDelay  = 1;
+    stDelay.u32MuteDelay = 50;
+#else
+    stDelay.u32FmtDelay = 500;
+    stDelay.u32MuteDelay = 120;
+#endif
+    HI_UNF_HDMI_SetDelay(0,&stDelay);
+
+    g_stCallbackFunc.pfnHdmiEventCallback = HDMI_Event_Proc;
+    g_stCallbackFunc.pPrivateData = &g_stHdmiArgs;
+
+    Ret = HI_UNF_HDMI_RegCallbackFunc(enHDMIId, &g_stCallbackFunc);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("hdmi reg failed:%#x\n",Ret);
+        HI_UNF_HDMI_DeInit();
+        return HI_FAILURE;
+    }
+
+    stOpenParam.enDefaultMode = g_enDefaultMode;//HI_UNF_HDMI_FORCE_NULL;
+    Ret = HI_UNF_HDMI_Open(enHDMIId, &stOpenParam);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_HDMI_Open failed:%#x\n",Ret);
+        HI_UNF_HDMI_DeInit();
+        return HI_FAILURE;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId)
+{
+//    HI_UNF_HDMI_Stop(enHDMIId);
+
+    HI_UNF_HDMI_Close(enHDMIId);
+
+    HI_UNF_HDMI_UnRegCallbackFunc(enHDMIId, &g_stCallbackFunc);
+
+    HI_UNF_HDMI_DeInit();
+
+    return HI_SUCCESS;
+}
+
+HI_VOID HDMI_SaveFmt(HI_UNF_ENC_FMT_E enFmt)
+{
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    if (enFmt < HI_UNF_ENC_FMT_BUTT)
+    {
+        s_enHdmiFormat = enFmt;
+    }
+    else
+    {
+        s_enHdmiFormat = HI_UNF_ENC_FMT_720P_60;
+    }
+#endif
+    return ;
+}
+
+
diff --git a/xbmc/platform/linux/hisi/hi_adp_hdmi.h b/xbmc/platform/linux/hisi/hi_adp_hdmi.h
new file mode 100644
index 0000000000..71e8ab7b44
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_hdmi.h
@@ -0,0 +1,16 @@
+#ifndef __SAMPLE_HDMI_COMMON_H__
+#define __SAMPLE_HDMI_COMMON_H__
+
+#include "hi_unf_hdmi.h"
+
+typedef void (*User_HDMI_CallBack)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt);
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId);
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId);
+//HI_S32 HIADP_HDMI_SetAdecAttr(HI_UNF_SND_INTERFACE_E enInterface, HI_UNF_SAMPLE_RATE_E enRate);
+HI_VOID HDMI_PrintSinkCap(HI_UNF_EDID_BASE_INFO_S *pCapbility);
+HI_VOID HDMI_SaveFmt(HI_UNF_ENC_FMT_E enFmt);
+
+#endif /* #if pub_HDMI_H_ */
+
diff --git a/xbmc/platform/linux/hisi/hi_adp_ini.c b/xbmc/platform/linux/hisi/hi_adp_ini.c
new file mode 100644
index 0000000000..06341ce87c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_ini.c
@@ -0,0 +1,219 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2018. Hisilicon Technologies Co., Ltd. All rights reserved.
+
+******************************************************************************
+    File Name     : hi_adp_ini.c
+    Version       : Initial Draft
+    Author        : Device Chipset STB Development Dept
+    Created       : 2018/08/23
+    Description   : Read value from ini file.
+******************************************************************************/
+
+#include <assert.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "hi_adp_ini.h"
+
+static HI_CHAR *skiphead(const HI_CHAR *str)
+{
+    while (*str != '\0' && *str <= ' ')
+    {
+        str++;
+    }
+    return (HI_CHAR *)str;
+}
+
+static HI_CHAR *skiptail(const HI_CHAR *str, const HI_CHAR *base)
+{
+    while (str > base && *(str-1) <= ' ')
+    {
+        str--;
+    }
+    return (HI_CHAR *)str;
+}
+
+static HI_CHAR *striptail(HI_CHAR *str)
+{
+    HI_CHAR *p = skiptail(strchr(str, '\0'), str);
+    if(p != NULL)
+    {
+        *p = '\0';
+    }
+    return str;
+}
+
+static HI_CHAR * copystring(HI_CHAR *dest, const HI_CHAR *source, HI_U32 len)
+{
+    HI_U32 i;
+
+    for (i = 0; i < len - 1 && source[i] != '\0'; i++)
+    {
+        dest[i] = source[i];
+    }
+
+    dest[i] = '\0';
+
+    return dest;
+}
+
+static HI_CHAR *cleanstring(HI_CHAR *string)
+{
+    HI_S32 isstring;
+    HI_CHAR *p;
+
+    isstring = 0;
+    for (p = string; *p != '\0' && ((*p != ';' && *p != '#') || isstring); p++)
+    {
+        if (*p == '"')
+        {
+            if (*(p + 1) == '"')
+            {
+                p++;
+            }
+            else
+            {
+                isstring = !isstring;
+            }
+        }
+        else if (*p == '\\' && *(p + 1) == '"')
+        {
+            p++;
+        }
+    }
+
+    *p = '\0';
+    striptail(string);
+    if (*string == '"' && (p = strchr(string, '\0')) != NULL && *(p - 1) == '"')
+    {
+        string++;
+        *--p = '\0';
+    }
+
+    return string;
+}
+
+static HI_S32 getstring(FILE **fp, const HI_CHAR *section, const HI_CHAR *key, HI_CHAR *buffer, HI_S32 size)
+{
+    HI_CHAR *start, *end;
+    HI_S32 len;
+    HI_CHAR buf[HI_INI_BUFSIZE];
+
+
+    len = (section != NULL) ? strlen(section) : 0;
+
+    if (len > 0)
+    {
+        do
+        {
+            if (!HIADP_INI_Read(buf, HI_INI_BUFSIZE, fp))
+            {
+                return 0;
+            }
+            start = skiphead(buf);
+            end = strchr(start, ']');
+        } while (*start != '[' || end == NULL || ((HI_S32)(end-start-1) != len || strncasecmp(start+1,section,len) != 0));
+    }
+
+    len = (key != NULL) ? (HI_S32)strlen(key) : 0;
+    do
+    {
+        if (!HIADP_INI_Read(buf,HI_INI_BUFSIZE,fp) || *(start = skiphead(buf)) == '[')
+        {
+            return 0;
+        }
+        start = skiphead(buf);
+        end = strchr(start, '=');
+        if (end == NULL)
+        {
+            end = strchr(start, ':');
+        }
+    } while (*start == ';' || *start == '#' || end == NULL || ((HI_S32)(skiptail(end,start)-start) != len || strncasecmp(start,key,len) != 0));
+
+    start = skiphead(end + 1);
+    start = cleanstring(start);
+    copystring(buffer, start, size);
+
+    return 1;
+}
+
+HI_S32 HIADP_INI_Gets(const HI_CHAR *section, const HI_CHAR *key, const HI_CHAR *default_value,
+             HI_CHAR *buffer, HI_S32 size, const HI_CHAR *file)
+{
+    FILE *fp;
+    HI_S32 Ret = 0;
+
+    if (buffer == NULL || size <= 0 || key == NULL)
+    {
+        return 0;
+    }
+
+    if (HIADP_INI_OpenRead(file, &fp))
+    {
+        Ret = getstring(&fp, section, key, buffer, size);
+        (void)HIADP_INI_Close(&fp);
+    }
+    else if (HIADP_INI_OpenRead(basename(file), &fp))
+    {
+        Ret = getstring(&fp, section, key, buffer, size);
+        (void)HIADP_INI_Close(&fp);
+    }
+    else
+    {
+        printf("open file:%s or %s failed!\n",file,basename(file));
+        return HI_FAILURE;
+    }
+
+    if (!Ret)
+    {
+        copystring(buffer, default_value, size);
+    }
+
+    return strlen(buffer);
+}
+
+long HIADP_INI_Getl(const HI_CHAR *section, const HI_CHAR *key, long default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[64];
+
+    HI_S32 len = HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+    return (len == 0) ? default_value
+                    : ((len >= 2 && toupper(buf[1]) == 'X') ? strtol(buf, NULL, 16)
+                                                            : strtol(buf, NULL, 10));
+}
+
+float HIADP_INI_Getf(const HI_CHAR *section, const HI_CHAR *key, float default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[64];
+
+    HI_S32 len = HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+    return (len == 0) ? default_value : HIADP_INI_Atof(buf);
+}
+
+HI_BOOL HIADP_INI_Getbool(const HI_CHAR *section, const HI_CHAR *key, HI_BOOL default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[2];
+    HI_S32 Ret;
+
+    HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+
+    buf[0] = (HI_CHAR)toupper(buf[0]);
+
+    if (buf[0] == 'Y' || buf[0] == '1' || buf[0] == 'T')
+    {
+        Ret = HI_TRUE;
+    }
+    else if (buf[0] == 'N' || buf[0] == '0' || buf[0] == 'F')
+    {
+        Ret = HI_FALSE;
+    }
+    else
+    {
+        Ret = default_value;
+    }
+
+    return(Ret);
+}
+
diff --git a/xbmc/platform/linux/hisi/hi_adp_ini.h b/xbmc/platform/linux/hisi/hi_adp_ini.h
new file mode 100644
index 0000000000..07dd332f26
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_ini.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2018. Hisilicon Technologies Co., Ltd. All rights reserved.
+
+******************************************************************************
+    File Name     : hi_adp_ini.h
+    Version       : Initial Draft
+    Author        : Device Chipset STB Development Dept
+    Created       : 2018/08/23
+    Description   : head file
+
+******************************************************************************/
+
+#ifndef HI_ADP_INI_H
+#define HI_ADP_INI_H
+
+#include <stdio.h>
+#include "hi_type.h"
+
+#define HI_INI_BUFSIZE  512
+
+#define HIADP_INI_OpenRead(filename,file)   ((*(file) = fopen((filename),"rb")) != NULL)
+#define HIADP_INI_Close(file)               (fclose(*(file)) == 0)
+#define HIADP_INI_Read(buffer,size,file)    (fgets((buffer),(size),*(file)) != NULL)
+#define HIADP_INI_Atof(string)              (float)strtod((string),NULL)
+
+
+HI_BOOL  HIADP_INI_Getbool(const HI_CHAR *section, const HI_CHAR *key, HI_BOOL default_value, const HI_CHAR *file);
+long     HIADP_INI_Getl(const HI_CHAR *section, const HI_CHAR *key, long default_value, const HI_CHAR *file);
+HI_S32   HIADP_INI_Gets(const HI_CHAR *section, const HI_CHAR *key, const HI_CHAR *default_value, HI_CHAR *buffer, HI_S32 size, const HI_CHAR *file);
+float    HIADP_INI_Getf(const HI_CHAR *section, const HI_CHAR *key, float default_value, const HI_CHAR *file);
+
+
+
+#endif /* HI_ADP_INI_H */
diff --git a/xbmc/platform/linux/hisi/hi_adp_mpi.c b/xbmc/platform/linux/hisi/hi_adp_mpi.c
new file mode 100644
index 0000000000..fe1f1c2831
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_mpi.c
@@ -0,0 +1,1704 @@
+#include <string.h>
+#include <sys/time.h>
+
+#include "hi_unf_demux.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_common.h"
+#include "hi_unf_vo.h"
+#include "hi_unf_sound.h"
+#include "hi_unf_ai.h"
+#include "hi_common.h"
+#include "hi_unf_disp.h"
+#include "hi_unf_hdmi.h"
+#include "hi_audio_codec.h"
+#include "hi_error_mpi.h"
+#include "hi_unf_mce.h"
+#include "hi_unf_pdm.h"
+
+#include "hi_adp_mpi.h"
+#include "hi_adp.h"
+#include "hi_adp_data.h"
+#include "hi_adp_hdmi.h"
+#include "hi_adp_boardcfg.h"
+
+#include "HA.AUDIO.G711.codec.h"
+#include "HA.AUDIO.MP3.decode.h"
+#include "HA.AUDIO.MP2.decode.h"
+#include "HA.AUDIO.AAC.decode.h"
+#include "HA.AUDIO.DRA.decode.h"
+#include "HA.AUDIO.PCM.decode.h"
+#include "HA.AUDIO.WMA9STD.decode.h"
+#include "HA.AUDIO.AMRNB.codec.h"
+#include "HA.AUDIO.AMRWB.codec.h"
+#include "HA.AUDIO.TRUEHDPASSTHROUGH.decode.h"
+#include "HA.AUDIO.DOLBYTRUEHD.decode.h"
+#include "HA.AUDIO.DTSHD.decode.h"
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+ #include "HA.AUDIO.DOLBYPLUS.decode.h"
+#endif
+#include "HA.AUDIO.AC3PASSTHROUGH.decode.h"
+#include "HA.AUDIO.DTSM6.decode.h"
+
+#include "HA.AUDIO.DTSPASSTHROUGH.decode.h"
+#include "HA.AUDIO.FFMPEG_DECODE.decode.h"
+#include "HA.AUDIO.AAC.encode.h"
+
+#include "HA.AUDIO.DOLBYMS12.decode.h"
+#include "HA.AUDIO.VOICE.codec.h"
+#include "HA.AUDIO.OPUS.codec.h"
+#include "HA.AUDIO.VORBIS.codec.h"
+
+#ifdef ANDROID
+#include <utils/Log.h>
+#include "hi_adp_osd.h"
+#endif
+
+#define MPI_DEMUX_NUM 5
+#define MPI_DEMUX_PLAY 0
+#define MPI_DEMUX_REC_0 1
+#define MPI_DEMUX_REC_1 2
+#define MPI_DEMUX_TIMETHIFT 3
+#define MPI_DEMUX_PLAYBACK 4
+
+/*
+big-endian pcm output format, if extword is 1, choose normal pcm decoder,
+                                            if extword is 2, choose wifidsp_lpcm decoder(Frame Header:0xA0,0x06)
+                                            if others, fail to decode.
+*/
+#define NORMAL_PCM_EXTWORD    1
+#define WIFIDSP_LPCM_EXTWORD  2
+
+
+HI_U8 u8DecOpenBuf[1024];
+HI_U8 u8EncOpenBuf[1024];
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+
+DOLBYPLUS_STREAM_INFO_S g_stDDpStreamInfo;
+
+/*dolby Dual Mono type control*/
+HI_U32  g_u32DolbyAcmod = 0;
+HI_BOOL g_bDrawChnBar = HI_TRUE;
+
+#endif
+
+#ifdef ANDROID
+static HI_HANDLE               g_hSurface;
+
+#define LOG_MAX_LEN 1024
+
+void LogPrint(const char *format, ...)
+{
+    char LogStr[LOG_MAX_LEN];
+    va_list args = {0};
+
+    va_start(args, format);
+    vsnprintf(LogStr, LOG_MAX_LEN, format, args);
+    va_end(args);
+    android_printLog(ANDROID_LOG_ERROR, "SAMPLE", "%s", LogStr);
+}
+#endif
+
+/************************************DISPLAY Common Interface*******************************/
+HI_S32 HIADP_Disp_StrToFmt(HI_CHAR *pszFmt)
+{
+    HI_UNF_ENC_FMT_E fmtReturn = HI_UNF_ENC_FMT_BUTT;
+
+    if (NULL == pszFmt)
+    {
+        return HI_UNF_ENC_FMT_BUTT;
+    }
+
+    if (0 == strcasecmp(pszFmt, "1080P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_30"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_30;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_25"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_25;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_24"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_24;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080i_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080i_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080i_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080i_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "576P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_576P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "480P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_480P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "PAL"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_PAL;
+    }
+    else if (0 == strcasecmp(pszFmt, "NTSC"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_NTSC;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_24_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_60_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_60_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_50_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_24"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_24;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_25"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_25;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_30"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_30;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_60;
+    }
+    else
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50;
+        sample_common_printf("\n!!! Can NOT match format, set format to is '720P_50'/%d.\n\n", HI_UNF_ENC_FMT_720P_50);
+    }
+
+    return fmtReturn;
+}
+
+#ifdef HI_BOOT_HOMOLOGOUS_SUPPORT
+HI_S32 hi_adp_disp_init_mutex(HI_UNF_ENC_FMT_E input_format)
+{
+    HI_S32                      ret;
+    HI_UNF_DISP_BG_COLOR_S      BgColor;
+    HI_UNF_DISP_INTF_S          DispIntf;
+    HI_UNF_DISP_OFFSET_S        offset;
+    HI_UNF_ENC_FMT_E            set_format = HI_UNF_ENC_FMT_PAL;
+    HI_UNF_HDMI_STATUS_S        get_hdmi_status = {0};
+
+    ret = HI_UNF_DISP_Init();
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_Init failed 0x%x\n", ret);
+        return ret;
+    }
+
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_HDMI;
+    DispIntf.unIntf.enHdmi = HI_UNF_HDMI_ID_0;
+    ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_AttachIntf hdmi failed 0x%x\n", ret);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HIADP_HDMI_Init(HI_UNF_HDMI_ID_0);
+    if (ret != HI_SUCCESS) {
+        printf("get HIADP_HDMI_Init failed ! \n");
+    }
+
+    ret = HI_UNF_HDMI_GetStatus(HI_UNF_HDMI_ID_0, &get_hdmi_status);
+    if (ret != HI_SUCCESS) {
+        printf("get hdmi status failed ! \n");
+    }
+
+    if (get_hdmi_status.bConnected == HI_TRUE) {
+#ifdef HI_DAC_CVBS
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        ret = HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        if (ret != HI_SUCCESS) {
+            sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", ret);
+            HI_UNF_DISP_DeInit();
+            return ret;
+        }
+#endif
+        set_format = input_format;
+    }
+    else {
+#ifdef HI_DAC_CVBS
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        if (ret != HI_SUCCESS) {
+            sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", ret);
+            HI_UNF_DISP_DeInit();
+            return ret;
+        }
+#endif
+
+        switch (input_format) {
+            case HI_UNF_ENC_FMT_4096X2160_60 :
+            case HI_UNF_ENC_FMT_4096X2160_30 :
+            case HI_UNF_ENC_FMT_4096X2160_24 :
+            case HI_UNF_ENC_FMT_3840X2160_60 :
+            case HI_UNF_ENC_FMT_3840X2160_30 :
+            case HI_UNF_ENC_FMT_3840X2160_24 :
+            case HI_UNF_ENC_FMT_1080P_60 :
+            case HI_UNF_ENC_FMT_1080P_30 :
+            case HI_UNF_ENC_FMT_1080i_60 :
+            case HI_UNF_ENC_FMT_720P_60 :
+            case HI_UNF_ENC_FMT_480P_60 :
+            case HI_UNF_ENC_FMT_NTSC :
+                set_format = HI_UNF_ENC_FMT_NTSC;
+                break;
+
+            case HI_UNF_ENC_FMT_4096X2160_50 :
+            case HI_UNF_ENC_FMT_4096X2160_25 :
+            case HI_UNF_ENC_FMT_3840X2160_50 :
+            case HI_UNF_ENC_FMT_3840X2160_25 :
+            case HI_UNF_ENC_FMT_1080P_50 :
+            case HI_UNF_ENC_FMT_1080P_25 :
+            case HI_UNF_ENC_FMT_1080i_50 :
+            case HI_UNF_ENC_FMT_720P_50 :
+            case HI_UNF_ENC_FMT_576P_50 :
+            case HI_UNF_ENC_FMT_PAL :
+                set_format = HI_UNF_ENC_FMT_PAL;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, set_format);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY1 0x%x failed 0x%x\n", input_format, ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISPLAY1, 1280, 720);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetVirtualScreen failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    offset.u32Left      = 0;
+    offset.u32Top       = 0;
+    offset.u32Right     = 0;
+    offset.u32Bottom    = 0;
+
+    ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY1, &offset);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY1 failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    BgColor.u8Red   = 0;
+    BgColor.u8Green = 0;
+    BgColor.u8Blue  = 0;
+
+    ret = HI_UNF_DISP_SetBgColor(HI_UNF_DISPLAY1, &BgColor);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetBgColor failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY1);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY1 failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+    return HI_SUCCESS;
+}
+#endif
+
+HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat)
+{
+    HI_S32                      Ret;
+    HI_UNF_DISP_BG_COLOR_S      BgColor;
+    HI_UNF_DISP_INTF_S          DispIntf;
+    HI_UNF_DISP_OFFSET_S        offset;
+    HI_UNF_ENC_FMT_E            SdFmt = HI_UNF_ENC_FMT_PAL;
+
+#if    defined(CHIP_TYPE_hi3798cv200) \
+    || defined(CHIP_TYPE_hi3798mv200) \
+    || defined(CHIP_TYPE_hi3796mv200) \
+    || defined(CHIP_TYPE_hi3716mv450)
+
+    HI_UNF_EDID_BASE_INFO_S     stSinkAttr;
+#endif
+
+    Ret = HI_UNF_DISP_Init();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Init failed 0x%x\n", Ret);
+        return Ret;
+    }
+
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_HDMI;
+    DispIntf.unIntf.enHdmi = HI_UNF_HDMI_ID_0;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf hdmi failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#if defined(HI_DAC_YPBPR_Y) && defined(HI_DAC_YPBPR_PB) && defined(HI_DAC_YPBPR_PR)
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_YPBPR;
+    DispIntf.unIntf.stYPbPr.u8DacY  = HI_DAC_YPBPR_Y;
+    DispIntf.unIntf.stYPbPr.u8DacPb = HI_DAC_YPBPR_PB;
+    DispIntf.unIntf.stYPbPr.u8DacPr = HI_DAC_YPBPR_PR;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf ypbpr failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+#if defined(HI_DAC_VGA_R) && defined(HI_DAC_VGA_G) && defined(HI_DAC_VGA_B)
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_VGA;
+    DispIntf.unIntf.stYPbPr.u8DacY  = HI_DAC_VGA_R;
+    DispIntf.unIntf.stYPbPr.u8DacPb = HI_DAC_VGA_G;
+    DispIntf.unIntf.stYPbPr.u8DacPr = HI_DAC_VGA_B;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf VGA failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+#ifdef HI_DAC_CVBS
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+    DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+    Ret = HI_UNF_DISP_Attach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Attach failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, enFormat);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY1 0x%x failed 0x%x\n", enFormat, Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    switch (enFormat)
+    {
+        case HI_UNF_ENC_FMT_4096X2160_60 :
+        case HI_UNF_ENC_FMT_4096X2160_30 :
+        case HI_UNF_ENC_FMT_4096X2160_24 :
+        case HI_UNF_ENC_FMT_3840X2160_60 :
+        case HI_UNF_ENC_FMT_3840X2160_30 :
+        case HI_UNF_ENC_FMT_3840X2160_24 :
+        case HI_UNF_ENC_FMT_1080P_60 :
+        case HI_UNF_ENC_FMT_1080P_30 :
+        case HI_UNF_ENC_FMT_1080i_60 :
+        case HI_UNF_ENC_FMT_720P_60 :
+        case HI_UNF_ENC_FMT_480P_60 :
+        case HI_UNF_ENC_FMT_NTSC :
+            SdFmt = HI_UNF_ENC_FMT_NTSC;
+            break;
+
+        case HI_UNF_ENC_FMT_4096X2160_50 :
+        case HI_UNF_ENC_FMT_4096X2160_25 :
+        case HI_UNF_ENC_FMT_3840X2160_50 :
+        case HI_UNF_ENC_FMT_3840X2160_25 :
+        case HI_UNF_ENC_FMT_1080P_50 :
+        case HI_UNF_ENC_FMT_1080P_25 :
+        case HI_UNF_ENC_FMT_1080i_50 :
+        case HI_UNF_ENC_FMT_720P_50 :
+        case HI_UNF_ENC_FMT_576P_50 :
+        case HI_UNF_ENC_FMT_PAL :
+            SdFmt = HI_UNF_ENC_FMT_PAL;
+            break;
+
+        default:
+            break;
+    }
+
+    Ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY0, SdFmt);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY0 0x%x failed 0x%x\n", SdFmt, Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#ifndef ANDROID
+    Ret = HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISPLAY1, 1280, 720);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetVirtualScreen failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    offset.u32Left      = 0;
+    offset.u32Top       = 0;
+    offset.u32Right     = 0;
+    offset.u32Bottom    = 0;
+    /*set display1 screen offset*/
+    Ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY1, &offset);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY1 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    /*set display0 screen offset*/
+    Ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY0, &offset);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY0 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+    BgColor.u8Red   = 0;
+    BgColor.u8Green = 0;
+    BgColor.u8Blue  = 0;
+
+    Ret = HI_UNF_DISP_SetBgColor(HI_UNF_DISPLAY1, &BgColor);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetBgColor failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY1 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY0);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY0 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HIADP_HDMI_Init(HI_UNF_HDMI_ID_0);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HIADP_HDMI_Init failed 0x%x\n", Ret);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#if    defined(CHIP_TYPE_hi3798cv200) \
+    || defined(CHIP_TYPE_hi3798mv200) \
+    || defined(CHIP_TYPE_hi3796mv200) \
+    || defined(CHIP_TYPE_hi3716mv450)
+
+    Ret = HI_UNF_HDMI_GetSinkCapability(HI_UNF_HDMI_ID_0, &stSinkAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_HDMI_GetSinkCapability failed:%#x.\n",Ret);
+    }
+    else
+    {
+        Ret = HI_UNF_DISP_SetSinkCapability(HI_UNF_DISPLAY1, &stSinkAttr);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetSinkCapability failed:%#x.\n",Ret);
+        }
+
+        Ret = HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISPLAY1, HI_UNF_DISP_COLOR_SPACE_AUTO);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetOutputColorSpace failed:%#x.\n",Ret);
+        }
+
+        Ret = HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_AUTO);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetHDRType: failed:%#x.\n",Ret);
+            return Ret;
+        }
+    }
+#endif
+
+#ifdef ANDROID
+    HIADP_SURFACE_ATTR_S    stSurAttr;
+    HI_UNF_PDM_DISP_PARAM_S stDispParam;
+
+    HIADP_OSD_Init();
+
+    Ret = HI_UNF_PDM_GetBaseParam(HI_UNF_PDM_BASEPARAM_DISP0, &stDispParam);
+    if (HI_SUCCESS != Ret)
+    {
+        stSurAttr.u32Width = 1280;
+        stSurAttr.u32Height = 720;
+    }
+    else
+    {
+        stSurAttr.u32Width = stDispParam.u32VirtScreenWidth;
+        stSurAttr.u32Height = stDispParam.u32VirtScreenHeight;
+    }
+
+    stSurAttr.enPixelFormat = HIADP_PF_8888;
+    Ret = HIADP_OSD_CreateSurface(&stSurAttr, &g_hSurface);
+    if (HI_SUCCESS != Ret)
+    {
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        HIADP_OSD_DeInit();
+        return Ret;
+    }
+#endif
+
+    return HI_SUCCESS;
+}
+
+
+HI_S32 HIADP_Disp_DeInit(HI_VOID)
+{
+    HI_S32                      Ret;
+
+#ifdef ANDROID
+    Ret = HIADP_OSD_DestroySurface(g_hSurface);
+    if (HI_SUCCESS != Ret)
+    {
+        return Ret;
+    }
+
+    HIADP_OSD_DeInit();
+#endif
+
+    Ret = HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Close failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Close failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Detach failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_DeInit();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_DeInit failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_0);
+
+    return HI_SUCCESS;
+}
+
+/****************************VO Common Interface********************************************/
+HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode)
+{
+    HI_S32             Ret;
+
+
+    Ret = HI_UNF_VO_Init(enDevMode);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Init failed.\n");
+        return Ret;
+    }
+
+#if 0
+    Ret = HI_UNF_VO_Open(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Open failed.\n");
+        HI_UNF_VO_DeInit();
+        return Ret;
+    }
+#endif
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_CreatWin(HI_RECT_S *pstWinRect,HI_HANDLE *phWin)
+{
+    HI_S32 Ret;
+    HI_UNF_WINDOW_ATTR_S   WinAttr;
+    memset(&WinAttr, 0, sizeof(HI_UNF_WINDOW_ATTR_S));
+    WinAttr.enDisp = HI_UNF_DISPLAY1;
+    WinAttr.bVirtual = HI_FALSE;
+    WinAttr.stWinAspectAttr.enAspectCvrs = HI_UNF_VO_ASPECT_CVRS_IGNORE;
+    WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+    WinAttr.stWinAspectAttr.u32UserAspectWidth  = 0;
+    WinAttr.stWinAspectAttr.u32UserAspectHeight = 0;
+    WinAttr.bUseCropRect = HI_FALSE;
+    WinAttr.stInputRect.s32X = 0;
+    WinAttr.stInputRect.s32Y = 0;
+    WinAttr.stInputRect.s32Width = 0;
+    WinAttr.stInputRect.s32Height = 0;
+
+    if (HI_NULL == pstWinRect)
+    {
+        memset(&WinAttr.stOutputRect, 0x0, sizeof(HI_RECT_S));
+    }
+    else
+    {
+        memcpy(&WinAttr.stOutputRect,pstWinRect,sizeof(HI_RECT_S));
+    }
+
+    Ret = HI_UNF_VO_CreateWindow(&WinAttr, phWin);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_CreateWindow failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_CreatWinExt(HI_RECT_S *pstWinRect,HI_HANDLE *phWin,HI_BOOL bVirtScreen)
+{
+    HI_S32 Ret;
+    HI_UNF_WINDOW_ATTR_S   WinAttr;
+    memset(&WinAttr, 0, sizeof(HI_UNF_WINDOW_ATTR_S));
+    WinAttr.enDisp = HI_UNF_DISPLAY1;
+    WinAttr.bVirtual = HI_FALSE;
+    WinAttr.stWinAspectAttr.enAspectCvrs = HI_UNF_VO_ASPECT_CVRS_IGNORE;
+    WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+    WinAttr.stWinAspectAttr.u32UserAspectWidth  = 0;
+    WinAttr.stWinAspectAttr.u32UserAspectHeight = 0;
+    WinAttr.bUseCropRect = HI_FALSE;
+    WinAttr.stInputRect.s32X = 0;
+    WinAttr.stInputRect.s32Y = 0;
+    WinAttr.stInputRect.s32Width = 0;
+    WinAttr.stInputRect.s32Height = 0;
+
+    if (HI_NULL == pstWinRect)
+    {
+        memset(&WinAttr.stOutputRect, 0x0, sizeof(HI_RECT_S));
+    }
+    else
+    {
+        memcpy(&WinAttr.stOutputRect,pstWinRect,sizeof(HI_RECT_S));
+    }
+
+    Ret =  HI_UNF_VO_CreateWindowExt(&WinAttr, phWin, bVirtScreen);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_CreateWindowExt failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_DeInit()
+{
+    HI_S32         Ret;
+
+#if 0
+    Ret = HI_UNF_VO_Close(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Close failed.\n");
+        return Ret;
+    }
+#endif
+    Ret = HI_UNF_VO_DeInit();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+/*****************************************SOUND Common Interface************************************/
+HI_S32 HIADP_Snd_Init(HI_VOID)
+{
+    HI_S32                  Ret;
+    HI_UNF_SND_ATTR_S       stAttr;
+
+    Ret = HI_UNF_SND_Init();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Init failed.\n");
+        return Ret;
+    }
+    Ret = HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_0, &stAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultOpenAttr failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Open(HI_UNF_SND_0, &stAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Open failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_Snd_DeInit(HI_VOID)
+{
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_SND_Close(HI_UNF_SND_0);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_SND_Close failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_DeInit();
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_SND_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+#ifdef HI_AUDIO_AI_SUPPORT
+/*****************************************AI Common Interface************************************/
+HI_S32 HIADP_AI_Init(HI_UNF_AI_E enAISrc, HI_HANDLE *pAIHandle, HI_HANDLE *pTrackSlave, HI_HANDLE *pATrackVir)
+{
+    HI_S32                  Ret;
+    HI_UNF_AI_ATTR_S        stAitAttr = {0};
+    HI_UNF_AUDIOTRACK_ATTR_S  stTrackAttr;
+
+    Ret = HI_UNF_AI_Init();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_Init failed.\n");
+    }
+
+    Ret = HI_UNF_AI_GetDefaultAttr(enAISrc,&stAitAttr);
+    stAitAttr.u32PcmFrameMaxNum = 8;
+    if(HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_GetDefaultAttr Failed \n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_AI_Create(enAISrc, &stAitAttr, pAIHandle);
+    if(HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_Create Failed \n");
+        return Ret;
+    }
+
+
+    Ret = HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_SLAVE, &stTrackAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultTrackAttr failed.\n");
+        return Ret;
+    }
+    Ret = HI_UNF_SND_CreateTrack(HI_UNF_SND_0,&stTrackAttr, pTrackSlave);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_CreateTrack failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Attach(*pTrackSlave, *pAIHandle);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Attach failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_VIRTUAL, &stTrackAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultTrackAttr failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_CreateTrack(HI_UNF_SND_0,&stTrackAttr,pATrackVir);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_CreateTrack failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Attach(*pATrackVir, *pAIHandle);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Attach failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_AI_SetEnable(*pAIHandle, HI_TRUE);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AI_SetEnable failed.\n");
+        return Ret;
+    }
+
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AI_DeInit(HI_HANDLE hAI, HI_HANDLE hAISlave, HI_HANDLE hAIVir)
+{
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_AI_SetEnable(hAI, HI_FALSE);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_SetEnable failed.\n");
+        return Ret;
+    }
+
+    HI_UNF_SND_Detach(hAIVir, hAI);
+    HI_UNF_SND_DestroyTrack(hAIVir);
+    HI_UNF_SND_Detach(hAISlave, hAI);
+    HI_UNF_SND_DestroyTrack(hAISlave);
+
+    HI_UNF_AI_Destroy(hAI);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_Destroy failed.\n");
+        return Ret;
+    }
+
+    HI_UNF_AI_DeInit();
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+#endif
+#if 0  //v1r3
+HI_S32 HIADP_Snd_RegAefAuthLib()
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    Ret = HI_UNF_SND_RegisterAefAuthLib("libHA.AUDIO.SRS.effect.auth.so");
+
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("\n\n!!! some audio effect authorize lib NOT found. you may NOT able to realize some audio effect process.\n\n");
+    }
+
+    return HI_SUCCESS;
+}
+#endif
+
+HI_S32 HIADP_AVPlay_RegADecLib()
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    Ret = HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRWB.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP3.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP2.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AAC.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYTRUEHD.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRNB.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.COOK.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.VOICE.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.G711.codec.so");
+#ifdef DOLBYPLUS_HACODEC_SUPPORT
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYPLUS.decode.so");
+#endif
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSHD.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSM6.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSPASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AC3PASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.PCM.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.OPUS.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.VORBIS.codec.so");
+
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("\n\n!!! some audio codec NOT found. you may NOT able to decode some audio type.\n\n");
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_Init()
+{
+    HI_S32 Ret;
+    Ret = HIADP_AVPlay_RegADecLib();
+    Ret |= HI_UNF_AVPLAY_Init();
+    return Ret;
+}
+
+HI_S32 HIADP_AVPlay_Create(HI_HANDLE *avplay,
+                                 HI_U32 u32DemuxId,
+                                 HI_UNF_AVPLAY_STREAM_TYPE_E streamtype,
+                                 HI_UNF_VCODEC_CAP_LEVEL_E vdeccap,
+                                 HI_U32 channelflag)
+{
+    HI_UNF_AVPLAY_ATTR_S attr;
+    HI_HANDLE avhandle;
+    HI_UNF_AVPLAY_OPEN_OPT_S maxCapbility;
+
+    if(avplay == HI_NULL)
+        return HI_FAILURE;
+
+    if ((u32DemuxId != MPI_DEMUX_PLAY) && (u32DemuxId != MPI_DEMUX_PLAYBACK))
+    {
+        sample_common_printf("%d is not a play demux , please select play demux \n", u32DemuxId);
+        return HI_FAILURE;
+    }
+
+    if(streamtype >= HI_UNF_AVPLAY_STREAM_TYPE_BUTT)
+        return HI_FAILURE;
+
+    if(vdeccap >= HI_UNF_VCODEC_CAP_LEVEL_BUTT)
+        return HI_FAILURE;
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_GetDefaultConfig(&attr, streamtype));
+
+    attr.u32DemuxId = u32DemuxId;
+    attr.stStreamAttr.u32VidBufSize = 0x300000;
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_Create(&attr, &avhandle));
+    maxCapbility.enDecType = HI_UNF_VCODEC_DEC_TYPE_NORMAL;
+    maxCapbility.enCapLevel = vdeccap;
+    maxCapbility.enProtocolLevel = HI_UNF_VCODEC_PRTCL_LEVEL_H264;
+
+    if(channelflag&HI_UNF_AVPLAY_MEDIA_CHAN_AUD)
+        HIAPI_RUN_RETURN(HI_UNF_AVPLAY_ChnOpen(avhandle, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, NULL));
+
+    if(channelflag&HI_UNF_AVPLAY_MEDIA_CHAN_VID)
+        HIAPI_RUN_RETURN(HI_UNF_AVPLAY_ChnOpen(avhandle, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &maxCapbility));
+
+    *avplay = avhandle;
+
+    sample_common_printf("demux %d create avplay 0x%x  \n", u32DemuxId, avhandle);
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode)
+{
+    HI_S32 Ret;
+    HI_UNF_VCODEC_ATTR_S        VdecAttr;
+
+    Ret = HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_AVPLAY_GetAttr failed:%#x\n",Ret);
+        return Ret;
+    }
+
+    VdecAttr.enType = enType;
+    VdecAttr.enMode = enMode;
+    VdecAttr.u32ErrCover = 100;
+    VdecAttr.u32Priority = 3;
+
+    Ret = HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_SetAttr failed.\n");
+        return Ret;
+    }
+
+    return Ret;
+}
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+static HI_VOID DDPlusCallBack(DOLBYPLUS_EVENT_E Event, HI_VOID *pUserData)
+{
+    DOLBYPLUS_STREAM_INFO_S *pstInfo = (DOLBYPLUS_STREAM_INFO_S *)pUserData;
+#if 0
+    sample_common_printf( "DDPlusCallBack show info:\n \
+                s16StreamType          = %d\n \
+                s16Acmod               = %d\n \
+                s32BitRate             = %d\n \
+                s32SampleRateRate      = %d\n \
+                Event                  = %d\n",
+                pstInfo->s16StreamType, pstInfo->s16Acmod, pstInfo->s32BitRate, pstInfo->s32SampleRateRate,Event);
+#endif
+    g_u32DolbyAcmod = pstInfo->s16Acmod;
+
+    if (HA_DOLBYPLUS_EVENT_SOURCE_CHANGE == Event)
+    {
+        g_bDrawChnBar = HI_TRUE;
+        //printf("DDPlusCallBack enent !\n");
+    }
+    return;
+}
+#endif
+
+HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay, HI_U32 enADecType, HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly)
+{
+    HI_UNF_ACODEC_ATTR_S AdecAttr;
+    WAV_FORMAT_S stWavFormat;
+    DOLBYMS12_CODEC_OPENCONFIG_S stMs12Cfg; //NOTE Static mem when being called
+    OPUS_HEAD_CONFIG_S stOpusHeadCfg;
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr));
+    AdecAttr.enType = enADecType;
+
+    if (HA_AUDIO_ID_PCM == AdecAttr.enType)
+    {
+        HI_BOOL isBigEndian;
+
+        /* if big-endian pcm */
+        isBigEndian = HI_FALSE;
+        if(HI_TRUE == isBigEndian)
+        {
+            stWavFormat.cbSize = 4;
+            stWavFormat.cbExtWord[0] = NORMAL_PCM_EXTWORD; //choose normal pcm decoder
+            //stWavFormat.cbExtWord[0] = WIFIDSP_LPCM_EXTWORD; //choose wifi_dsp_lpcm decoder
+        }
+
+        if(stWavFormat.cbExtWord[0] == NORMAL_PCM_EXTWORD || HI_FALSE == isBigEndian)
+        {
+        /*
+            if choose normal pcm decoder, set attribute
+            if choose wifi_dsp_lpcm decoder, need not to set attribute by follows, ignore it
+        */
+            /* set pcm wav format here base on pcm file */
+            stWavFormat.nChannels = 1;
+            stWavFormat.nSamplesPerSec = 48000;
+            stWavFormat.wBitsPerSample = 16;
+        }
+        HA_PCM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam),&stWavFormat);
+        sample_common_printf("please make sure the attributes of PCM stream is tme same as defined in function of \"HIADP_AVPlay_SetAdecAttr\"? \n");
+        sample_common_printf("(nChannels = 1, wBitsPerSample = 16, nSamplesPerSec = 48000, isBigEndian = HI_FALSE) \n");
+    }
+    else if (HA_AUDIO_ID_MP2 == AdecAttr.enType)
+    {
+         HA_MP2_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AAC == AdecAttr.enType)
+    {
+         HA_AAC_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_MP3 == AdecAttr.enType)
+    {
+         HA_MP3_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AMRNB == AdecAttr.enType)
+    {
+        AMRNB_DECODE_OPENCONFIG_S *pstConfig = (AMRNB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRNB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRNB_MIME;
+    }
+    else if (HA_AUDIO_ID_AMRWB == AdecAttr.enType)
+    {
+        AMRWB_DECODE_OPENCONFIG_S *pstConfig = (AMRWB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRWB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRWB_FORMAT_MIME;
+    }
+
+    else if (HA_AUDIO_ID_G711 == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_G711_A;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_G726 == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_G726_40KBPS;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_ADPCM == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_ADPCM_DVI4;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+
+#if 0
+    else if (HA_AUDIO_ID_G711 == AdecAttr.enType)
+    {
+        G711_DECODE_OPENCONFIG_S *pstConfig = (G711_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        pstConfig->isAlaw = 1;
+        pstConfig->u32SamplePerFrame = G711_FRAME_LEN;
+        HA_G711_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+#endif
+    else if (HA_AUDIO_ID_AC3PASSTHROUGH == AdecAttr.enType)
+    {
+        HA_AC3PASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if(HA_AUDIO_ID_DTSPASSTHROUGH == AdecAttr.enType)
+    {
+        HA_DTSPASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if (HA_AUDIO_ID_TRUEHD == AdecAttr.enType)
+    {
+        HA_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        if (HD_DEC_MODE_THRU != enMode)
+        {
+            sample_common_printf(" MLP decoder enMode(%d) error (mlp only support hbr Pass-through only).\n", enMode);
+            return -1;
+        }
+
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;        /* truehd just support pass-through */
+        sample_common_printf(" TrueHD decoder(HBR Pass-through only).\n");
+    }
+    else if (HA_AUDIO_ID_DOLBY_TRUEHD == AdecAttr.enType)
+    {
+        TRUEHD_DECODE_OPENCONFIG_S *pstConfig = (TRUEHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_DTSHD == AdecAttr.enType)
+    {
+        DTSHD_DECODE_OPENCONFIG_S *pstConfig = (DTSHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+    else if (HA_AUDIO_ID_DTSM6 == AdecAttr.enType)
+    {
+        DTSM6_DECODE_OPENCONFIG_S *pstConfig = (DTSM6_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSM6_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSM6_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+    else if (HA_AUDIO_ID_DOLBY_PLUS == AdecAttr.enType)
+    {
+        DOLBYPLUS_DECODE_OPENCONFIG_S *pstConfig = (DOLBYPLUS_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBYPLUS_DecGetDefalutOpenConfig(pstConfig);
+        pstConfig->pfnEvtCbFunc[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = DDPlusCallBack;
+        pstConfig->pAppData[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = &g_stDDpStreamInfo;
+        /* Dolby DVB Broadcast default settings */
+        pstConfig->enDrcMode = DOLBYPLUS_DRC_RF;
+        pstConfig->enDmxMode = DOLBYPLUS_DMX_SRND;
+        HA_DOLBYPLUS_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+#endif
+    else if (HA_AUDIO_ID_MS12_DDP == AdecAttr.enType)
+    {
+        HA_DOLBYMS12_CodecGetDefaultOpenConfig(&stMs12Cfg);
+        HA_DOLBYMS12_CodecGetDefaultOpenParam(&AdecAttr.stDecodeParam, &stMs12Cfg);
+    }
+    else if (HA_AUDIO_ID_MS12_AAC == AdecAttr.enType)
+    {
+        HA_DOLBYMS12_CodecGetDefaultOpenConfig(&stMs12Cfg);
+        stMs12Cfg.enInputType = MS12_HEAAC;
+        HA_DOLBYMS12_CodecGetDefaultOpenParam(&AdecAttr.stDecodeParam, &stMs12Cfg);
+    }
+    else if (HA_AUDIO_ID_VORBIS == AdecAttr.enType)
+    {
+        HA_VORBIS_DecGetDefalutOpenParam(&AdecAttr.stDecodeParam);
+    }
+    else if (HA_AUDIO_ID_OPUS == AdecAttr.enType)
+    {
+        /*
+        Opus decoder support 1 2 6 8 channels 8 16 24 32 bits
+        Opus stream with sample rate not less than 8000 and not more than 48000
+        After the upper de-encapsulation need to provide code stream information This information can be found in the front page
+        The format is as follows:
+              0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |      'O'           |      'p'             |      'u'          |      's'         |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |      'H'           |      'e'             |      'a'          |      'd'         |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |  Version = 1  |Channel Count |           Pre-skip                |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |                     Input Sample Rate (Hz)                               |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |   Output Gain (Q7.8 in dB)      | Mapping Family|               |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |                                                                                      |
+        :               Optional Channel Mapping Table...
+        |                                                                                      |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+        The parsed out stream information needs to be stored in the OpusHeader structure
+        like this:
+        */
+        HA_OPUS_DecGetDefalutHeadConfig(&stOpusHeadCfg);
+
+#if 0
+        //test for 2 channel
+        stOpusHeadCfg.s32Version = 1;
+        stOpusHeadCfg.u32Channels = 2;
+        stOpusHeadCfg.s32Preskip = 0;
+        stOpusHeadCfg.u32SampleRate = 48000;
+        stOpusHeadCfg.s32ChannelMap = 0;
+#else
+        //test for 5.1 channel
+        stOpusHeadCfg.s32Version = 1;
+        stOpusHeadCfg.u32Channels = 6;
+        stOpusHeadCfg.s32Preskip = 312;
+        stOpusHeadCfg.s32Gain = 0;
+        stOpusHeadCfg.u32SampleRate = 48000;
+        stOpusHeadCfg.s32NBStreams = 4;
+        stOpusHeadCfg.s32NBCoupled = 2;
+        stOpusHeadCfg.s32ChannelMap = 1;
+
+        stOpusHeadCfg.u8StreamMap[0] = 0;
+        stOpusHeadCfg.u8StreamMap[1] = 4;
+        stOpusHeadCfg.u8StreamMap[2] = 1;
+        stOpusHeadCfg.u8StreamMap[3] = 2;
+        stOpusHeadCfg.u8StreamMap[4] = 3;
+        stOpusHeadCfg.u8StreamMap[5] = 5;
+#endif
+
+        HA_OPUS_DecGetDefalutOpenParam(&AdecAttr.stDecodeParam, &stOpusHeadCfg);
+    }
+    else
+    {
+         HA_DRA_DecGetOpenParam_MultichPcm(&(AdecAttr.stDecodeParam));
+    }
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr));
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayProg(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum,HI_BOOL bAudPlay)
+{
+    HI_UNF_AVPLAY_STOP_OPT_S    Stop;
+    HI_U32                  VidPid;
+    HI_U32                  AudPid;
+    HI_U32                  PcrPid;
+    HI_UNF_VCODEC_TYPE_E    enVidType;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID | HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    ProgNum = ProgNum % pProgTbl->prog_num;
+    if (pProgTbl->proginfo[ProgNum].VElementNum > 0 )
+    {
+        VidPid = pProgTbl->proginfo[ProgNum].VElementPid;
+        enVidType = pProgTbl->proginfo[ProgNum].VideoType;
+    }
+    else
+    {
+        VidPid = INVALID_TSPID;
+        enVidType = HI_UNF_VCODEC_TYPE_BUTT;
+    }
+
+    if (pProgTbl->proginfo[ProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[ProgNum].AElementPid;
+        u32AudType = pProgTbl->proginfo[ProgNum].AudioType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    PcrPid = pProgTbl->proginfo[ProgNum].PcrPid;
+    if (INVALID_TSPID != PcrPid)
+    {
+        HI_UNF_SYNC_ATTR_S  SyncAttr;
+
+        Ret = HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &SyncAttr);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HI_UNF_AVPLAY_GetAttr Sync failed 0x%x\n", Ret);
+            return Ret;
+        }
+
+        if (HI_UNF_SYNC_REF_PCR == SyncAttr.enSyncRef)
+        {
+            Ret = HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_PCR_PID, &PcrPid);
+            if (HI_SUCCESS != Ret)
+            {
+                sample_common_printf("HI_UNF_AVPLAY_SetAttr Sync failed 0x%x\n", Ret);
+                return Ret;
+            }
+        }
+    }
+
+    if (VidPid != INVALID_TSPID)
+    {
+        Ret = HIADP_AVPlay_SetVdecAttr(hAvplay,enVidType,HI_UNF_VCODEC_MODE_NORMAL);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VID_PID,&VidPid);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HIADP_AVPlay_SetVdecAttr failed.\n");
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+            return Ret;
+        }
+    }
+
+    if (HI_TRUE == bAudPlay && AudPid != INVALID_TSPID)
+    {
+        //u32AudType = HA_AUDIO_ID_DTSHD;
+        //printf("u32AudType = %#x\n",u32AudType);
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            printf("call HI_UNF_AVPLAY_Start to start audio failed.\n");
+            //return Ret;
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayProg_MS12(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum)
+{
+    HI_UNF_AVPLAY_STOP_OPT_S    Stop;
+    HI_U32                  AudPid;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+    HI_S32                  MainProgNum = 0;
+    HI_S32                  PIDNum = 0;
+
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    PIDNum = ProgNum % pProgTbl->proginfo[MainProgNum].AElementNum;
+
+    if (pProgTbl->proginfo[MainProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[MainProgNum].Audioinfo[PIDNum].u16AudioPid;
+        u32AudType = pProgTbl->proginfo[MainProgNum].Audioinfo[PIDNum].u32AudioEncType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    if (AudPid != INVALID_TSPID)
+    {
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            printf("call HI_UNF_AVPLAY_Start to start audio failed.\n");
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayAud(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum)
+{
+    HI_U32                  AudPid;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay,HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    ProgNum = ProgNum % pProgTbl->prog_num;
+    if (pProgTbl->proginfo[ProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[ProgNum].AElementPid;
+        u32AudType = pProgTbl->proginfo[ProgNum].AudioType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    if (AudPid != INVALID_TSPID)
+    {
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+            return Ret;
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_SwitchAud(HI_HANDLE hAvplay,HI_U32 AudPid, HI_U32 u32AudType)
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    if (AudPid == INVALID_TSPID)
+    {
+        sample_common_printf("%s, audio pid is invalid!\n", __func__);
+        return HI_FAILURE;
+    }
+
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay,HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+
+    Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+    Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+
+HI_S32 HIADP_MCE_Exit(HI_VOID)
+{
+#ifndef ANDROID
+    HI_S32                  Ret;
+    HI_UNF_MCE_STOPPARM_S   stStop;
+
+    Ret = HI_UNF_MCE_Init(HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Init failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_MCE_ClearLogo();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_ClearLogo failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    stStop.enStopMode = HI_UNF_AVPLAY_STOP_MODE_STILL;
+    stStop.enCtrlMode = HI_UNF_MCE_PLAYCTRL_BY_TIME;
+    stStop.u32PlayTimeMs = 0;
+    Ret = HI_UNF_MCE_Stop(&stStop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Stop failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_MCE_Exit(HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Exit failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    HI_UNF_MCE_DeInit();
+#endif
+    return HI_SUCCESS;
+}
+HI_S32 HIADP_DMX_AttachTSPort(HI_U32 Dmxid, HI_U32 TunerID)
+{
+    HI_S32                      Ret;
+    HI_UNF_DMX_PORT_E           DmxAttachPort;
+    HI_UNF_DMX_PORT_ATTR_S      DmxAttachPortAttr;
+    HI_CHAR SectionName[SECTION_MAX_LENGTH] = {0};
+
+    snprintf(SectionName,SECTION_MAX_LENGTH,"tuner%dinfo",TunerID);
+    DmxAttachPort = HIADP_INI_Getl(SectionName, "DemuxPort", DEFAULT_DEMUX_PORT, FRONTEND_CONFIG_FILE);
+
+    Ret = HI_UNF_DMX_GetTSPortAttr(DmxAttachPort, &DmxAttachPortAttr);
+
+    DmxAttachPortAttr.enPortType           = HIADP_INI_Getl(SectionName, "DemuxPortType", DEFAULT_DEMUX_PORT_TYPE, FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.u32SerialBitSelector = HIADP_INI_Getl(SectionName, "DemuxBitSel",   DEFAULT_DEMUX_BITSEL,    FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.u32TunerInClk        = HIADP_INI_Getl(SectionName, "DemuxInClk",    DEFAULT_DEMUX_INCLK,     FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.enSerialPortShareClk = HIADP_INI_Getl(SectionName, "DemuxPortShareClk", DEFAULT_DEMUX_PORT_SHARECLK, FRONTEND_CONFIG_FILE);
+
+    Ret |= HI_UNF_DMX_SetTSPortAttr(DmxAttachPort, &DmxAttachPortAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        printf("call HI_UNF_DMX_SetTSPortAttr failed.\n");
+        return HI_FAILURE;
+    }
+
+    Ret = HI_UNF_DMX_AttachTSPort(Dmxid, DmxAttachPort);
+    if (HI_SUCCESS != Ret)
+    {
+        printf("call HI_UNF_DMX_AttachTSPort.\n");
+        return HI_FAILURE;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_DMX_PushTsBuffer(HI_HANDLE hTsBuf, HI_UNF_STREAM_BUF_S *pstBuf, HI_U32 u32StartPos, HI_U32 u32ValidLen)
+{
+    HI_S32 s32Ret = HI_SUCCESS;
+
+#ifdef HI_DMX_TSBUF_MULTI_THREAD_SUPPORT
+    HI_UNF_STREAM_BUF_S stData;
+
+    if ((HI_NULL == pstBuf) || (HI_NULL == pstBuf->pu8Data) || (pstBuf->u32Size < u32StartPos + u32ValidLen))
+    {
+        printf("invalided parameter!\n");
+        return HI_FAILURE;
+    }
+    stData.pu8Data = pstBuf->pu8Data + u32StartPos;
+    stData.u32Size = u32ValidLen;
+    s32Ret = HI_UNF_DMX_PushTSBuffer(hTsBuf, &stData);
+    if (HI_SUCCESS != s32Ret)
+    {
+        printf("[%s_%d]calling HI_UNF_DMX_PushTSBuffer failed! ret = 0x%08x\n", __FILE__, __LINE__, s32Ret);
+        return HI_FAILURE;
+    }
+
+    s32Ret = HI_UNF_DMX_ReleaseTSBuffer(hTsBuf, pstBuf);
+#else
+    if ((HI_NULL == pstBuf) || (HI_NULL == pstBuf->pu8Data) || (pstBuf->u32Size < u32StartPos + u32ValidLen))
+    {
+        printf("invalided parameter!\n");
+        return HI_FAILURE;
+    }
+    s32Ret = HI_UNF_DMX_PutTSBuffer(hTsBuf, u32ValidLen);
+#endif
+
+    if (HI_SUCCESS != s32Ret)
+    {
+        printf("[pu8Data, u32StartPos, u32ValidLen, s32Ret] = [%p, %u, %u, 0x%x]\n", pstBuf->pu8Data, u32StartPos, u32ValidLen, s32Ret);
+    }
+
+    return s32Ret;
+}
diff --git a/xbmc/platform/linux/hisi/hi_adp_mpi.h b/xbmc/platform/linux/hisi/hi_adp_mpi.h
new file mode 100644
index 0000000000..f825d9ed8e
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_mpi.h
@@ -0,0 +1,95 @@
+#ifndef  __HI_ADP_MPI_H__
+#define  __HI_ADP_MPI_H__
+
+#include "hi_type.h"
+#include "hi_unf_common.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_vo.h"
+#include "hi_adp.h"
+#include "hi_adp_search.h"
+#include "hi_adp_boardcfg.h"
+#include "hi_unf_ai.h"
+
+#define DOLBYPLUS_HACODEC_SUPPORT
+#define SLIC_AUDIO_DEVICE_ENABLE
+
+#define G711_FRAME_LEN 320
+
+/********************************* Demux Common Interface *******************************/
+HI_S32 HIADP_Demux_Init(HI_U32 DmxPortID,HI_U32 TsPortID);
+
+HI_S32 HIADP_Demux_DeInit(HI_U32 DmxPortID);
+
+/************************************DISPLAY  Common Interface*******************************/
+HI_S32 HIADP_Disp_StrToFmt(HI_CHAR *pszFmt);
+
+HI_S32 hi_adp_disp_init_mutex(HI_UNF_ENC_FMT_E enFormat);
+
+HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat);
+
+HI_S32 HIADP_Disp_DeInit(HI_VOID);
+
+
+/****************************VO  Common Interface********************************************/
+HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+HI_S32 HIADP_VO_CreatWin(HI_RECT_S * pstWinRect, HI_HANDLE * phWin);
+
+HI_S32 HIADP_VO_CreatWinExt(HI_RECT_S * pstWinRect, HI_HANDLE * phWin, HI_BOOL bVirtScreen);
+
+HI_S32 HIADP_VO_DeInit();
+
+/*****************************************SOUND  Common Interface************************************/
+HI_S32 HIADP_Snd_Init(HI_VOID);
+
+
+HI_S32 HIADP_Snd_DeInit(HI_VOID);
+
+#ifdef HI_AUDIO_AI_SUPPORT
+/*Only Support Single AI Chn*/
+HI_S32 HIADP_AI_Init(HI_UNF_AI_E enAISrc, HI_HANDLE *pAIHandle, HI_HANDLE *pTrackSlave, HI_HANDLE *pATrackVir);
+HI_S32 HIADP_AI_DeInit(HI_HANDLE hAI, HI_HANDLE hAISlave, HI_HANDLE hAIVir);
+#endif
+
+/*****************************************AIAO  Common Interface************************************/
+HI_S32 HIADP_AIAO_Init(HI_S32 DevId, HI_S32 AI_Ch, HI_S32 AO_Ch, HI_UNF_SAMPLE_RATE_E enSamplerate, HI_U32 u32SamplePerFrame);
+
+
+HI_S32 HIADP_AIAO_DeInit(HI_VOID);
+
+HI_S32 HIADP_SLIC_Open(HI_VOID);
+HI_S32 HIADP_SLIC_Close(HI_VOID);
+HI_S32 HIADP_SLIC_GetHookOff(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_GetHookOn(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_SetRinging(HI_BOOL bEnable);
+
+
+/**************************************AVPLAY  Common Interface***************************************/
+HI_S32 HIADP_AVPlay_RegADecLib();
+
+HI_S32 HIADP_AVPlay_Init();
+
+HI_S32 HIADP_AVPlay_Create(HI_HANDLE *avplay,HI_U32 u32DemuxId,
+                                 HI_UNF_AVPLAY_STREAM_TYPE_E streamtype,
+                                 HI_UNF_VCODEC_CAP_LEVEL_E vdeccap,
+                                 HI_U32 channelflag);
+
+HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode);
+
+HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly);
+
+HI_S32 HIADP_AVPlay_PlayProg(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum,HI_BOOL bAudPlay);
+
+HI_S32 HIADP_AVPlay_PlayProg_MS12(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum);
+
+HI_S32 HIADP_AVPlay_PlayAud(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum);
+
+HI_S32 HIADP_AVPlay_SwitchAud(HI_HANDLE hAvplay,HI_U32 AudPid, HI_U32 u32AudType);
+
+HI_S32 HIADP_MCE_Exit(HI_VOID);
+
+HI_S32 HIADP_DMX_AttachTSPort(HI_U32 Dmxid, HI_U32 TunerID);
+HI_S32 HIADP_DMX_PushTsBuffer(HI_HANDLE hTsBuf, HI_UNF_STREAM_BUF_S *pstBuf, HI_U32 u32StartPos, HI_U32 u32ValidLen);
+
+#endif
+
diff --git a/xbmc/platform/linux/hisi/hi_adp_search.h b/xbmc/platform/linux/hisi/hi_adp_search.h
new file mode 100644
index 0000000000..2f2c644b10
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_adp_search.h
@@ -0,0 +1,382 @@
+#ifndef _COMMON_SEARCH_H__
+#define _COMMON_SEARCH_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/********************Descriptor flag definition******************/
+/********************CNcomment:******************/
+
+#define STREAM_TYPE_11172_VIDEO         0x01
+#define STREAM_TYPE_13818_VIDEO         0x02
+#define STREAM_TYPE_11172_AUDIO         0x03
+#define STREAM_TYPE_13818_AUDIO         0x04
+#define STREAM_TYPE_14496_2_VIDEO       0x10    // MPEG4
+#define STREAM_TYPE_14496_10_VIDEO      0x1B    // H264
+#define STREAM_TYPE_AVS_VIDEO           0x42    // AVS
+#define STREAM_TYPE_AVS2_VIDEO          0xD2    // AVS2
+#define STREAM_TYPE_HEVC_VIDEO          0x24    // HEVC
+#define STREAM_TYPE_13818_7_AUDIO       0x0F    // AAC
+#define STREAM_TYPE_14496_3_AUDIO       0x11    // AAC
+#define STREAM_TYPE_AC3_AUDIO           0x81    // AC3
+#define STREAM_TYPE_SCTE                0x82    // TS packets containing SCTE data
+#define STREAM_TYPE_DTS_AUDIO           0x82    // DTS
+#define STREAM_TYPE_DOLBY_TRUEHD_AUDIO  0x83    // dolby true HD
+#define STREAM_TYPE_DTS_MA				0x86	// DTS MA which conflict with CAPTION_SERVICE_DESCRIPTOR
+#define STREAM_TYPE_PRIVATE             0x06    // PES packets containing private data
+
+#define VIDEO_STREAM_DESCRIPTOR             0x02
+#define AUDIO_STREAM_DESCRIPTOR             0x03
+#define HIERACHY_DESCRIPTOR                 0x04
+#define REGISTRATION_DESCRIPTOR             0x05
+#define DATA_STREAM_ALIGNMENT_DESCRIPTOR    0x06
+#define TARGET_BACKGROUND_GRID_DESCRIPTOR   0x07
+#define VIDEO_WINDOW_DESCRIPTOR             0x08
+#define CA_DESCRIPTOR                       0x09
+#define LANGUAGE_DESCRIPTOR                 0x0A
+#define SYSTEM_CLOCK_DESCRIPTOR             0x0B
+#define MULTIPLEX_BUFFER_USAGE_DESCRIPTOR   0x0C
+#define COPYRIGHT_DESCRIPTOR                0x0D
+#define MAXIMUM_BITRATE_DESCRIPTOR          0x0E
+#define PRIVATE_DATA_INDICATOR_DESCRIPTOR   0x0F
+#define SMOOTHING_BUFFER_DESCRIPTOR         0x10
+#define STD_DESCRIPTOR                      0x11
+#define IBP_DESCRIPTOR                      0x12
+#define AC4_DESCRIPTOR                      0x15
+
+#define NETWORK_NAME_DESCRIPTOR 0x40
+#define SERVICE_LIST_DESCRIPTOR 0x41
+#define STUFFING_DESCRIPTOR 0x42
+#define SATELLITE_DELIVERY_DESCRIPTOR 0x43
+#define CABLE_DELIVERY_DESCRIPTOR 0x44
+#define BOUQUET_NAME_DESCRIPTOR 0x47
+#define SERVICE_DESCRIPTOR 0x48
+#define COUNTRY_AVAILABILITY_DESCRIPTOR 0x49
+#define LINKAGE_DESCRIPTOR 0x4A
+#define NVOD_REFERENCE_DESCRIPTOR 0x4B
+#define TIME_SHIFTED_SERVICE_DESCRIPTOR 0x4C
+#define SHORT_EVENT_DESCRIPTOR 0x4D
+#define EXTENDED_EVENT_DESCRIPTOR 0x4E
+#define TIME_SHIFTED_EVENT_DESCRIPTOR 0x4F
+#define COMPONENT_DESCRIPTOR 0x50
+#define MOSAIC_DESCRIPTOR 0x51
+#define STREAM_IDENTIFIER_DESCRIPTOR 0x52
+#define CA_IDENTIFIER_DESCRIPTOR 0x53
+#define CONTENT_DESCRIPTOR 0x54
+#define PARENTAL_RATING_DESCRIPTOR 0x55
+#define TELETEXT_DESCRIPTOR 0x56
+#define TELEPHONE_DESCRIPTOR 0x57
+#define LOCAL_TIME_OFFSET_DESCRIPTOR 0x58
+#define SUBTITLING_DESCRIPTOR 0x59
+#define TERRESTRIAL_DELIVERY_DESCRIPTOR 0x5A
+#define MULTILINGUAL_NETWORK_NAME_DESCRIPTOR 0x5B
+#define MULTILINGUAL_BOUQUET_NAME_DESCRIPTOR 0x5C
+#define MULTILINGUAL_SERVICE_NAME_DESCRIPTOR 0x5D
+#define MULTILINGUAL_COMPONENT_DESCRIPTOR 0x5E
+#define PRIVATE_DATA_SPECIFIER_DESCRIPTOR 0x5F
+#define SERVICE_MOVE_DESCRIPTOR 0x60
+#define SHORT_SMOOTHING_BUFFER_DESCRIPTOR 0x61
+#define FREQUENCY_LIST_DESCRIPTOR 0x62
+#define PARTIAL_TRANSPORT_STREAM_DESCRIPTOR 0x63
+#define DATA_BROADCAST_DESCRIPTOR 0x64
+#define CA_SYSTEM_DESCRIPTOR 0x65
+#define DATA_BROADCAST_ID_DESCRIPTOR 0x66
+#define TRANSPORT_STREAM_DESCRIPTOR 0x67
+#define DSNG_DESCRIPTOR 0x68
+#define PDC_DESCRIPTOR 0x69
+#define AC3_DESCRIPTOR 0x6A
+#define AC3_PLUS_DESCRIPTOR 0x7A
+#define ANCILLARY_DATA_DESCRIPTOR 0x6B
+#define CELL_LIST_DESCRIPTOR 0x6C
+#define CELL_FREQUENCY_LINK_DESCRIPTOR 0x6D
+#define ANNOUNCEMENT_SUPPORT_DESCRIPTOR 0x6E
+#define DRA_DESCRIPTOR 0x05
+
+#define AC3_EXT_DESCRIPTOR 0x52
+
+#define CAPTION_SERVICE_DESCRIPTOR 0x86
+#define EXTENSION_DESCRIPTOR 0x7F
+#define SUPPLEMENTARY_AUDIO_DESCRIPTOR 0x06
+
+#define STREAM_TYPE_HEVC_VIDEO_IDENTIFY 0x48455643
+#define STREAM_TYPE_DTS1_AUDIO_IDENTIFY 0x44545331
+#define STREAM_TYPE_DTS2_AUDIO_IDENTIFY 0x44545332
+#define STREAM_TYPE_DTS3_AUDIO_IDENTIFY 0x44545333
+
+#define MAX_PMT_LEN     1024
+/***********TS PID defintion**************/
+
+#define PAT_TSPID (0x0000)
+#define CAT_TSPID (0x0001)
+#define NIT_TSPID (0x0010)
+#define EIT_TSPID (0x0012)
+#define TOT_TSPID (0x0014)
+#define TDT_TSPID (0x0014)
+#define SDT_TSPID (0x0011)
+#define BAT_TSPID (0x0011)
+
+#define INVALID_TSPID (0x1fff)
+
+/***********Table ID defintion**************/
+#define PAT_TABLE_ID (0x00)
+#define CAT_TABLE_ID (0x01)
+#define PMT_TABLE_ID (0x02)
+#define NIT_TABLE_ID_ACTUAL (0x40)
+#define NIT_TABLE_ID_OTHER (0x41)
+
+#define SDT_TABLE_ID_ACTUAL (0x42)
+#define SDT_TABLE_ID_OTHER (0x46)
+
+#define BAT_TABLE_ID (0x4A)
+#define EIT_TABLE_ID_PF_ACTUAL (0x4E)
+#define EIT_TABLE_ID_PF_OTHER (0x4F)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_LOW (0x50)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_HIGH (0x5F)
+
+#define EIT_TABLE_ID_SCHEDULE_OTHER_LOW (0x60)
+#define EIT_TABLE_ID_SCHEDULE_OTHER_HIGH (0x6F)
+
+#define TDT_TABLE_ID (0x70)
+#define TOT_TABLE_ID (0x73)
+
+#define INVALID_TABLE_ID (0xff)
+#define CHANNEL_MAX_PROG    256
+#define PROG_MAX_VIDEO      8
+#define PROG_MAX_AUDIO      8
+#define PROG_MAX_CA         15
+
+#define SUBTDES_INFO_MAX 10
+#define SUBTITLING_MAX 1500
+#define CAPTION_SERVICE_MAX 16
+#define TTX_DES_MAX    10
+#define TTX_MAX        15
+
+#define SUBT_TYPE_DVB  (0x1)
+#define SUBT_TYPE_SCTE (0x2)
+#define SUBT_TYPE_BOTH (SUBT_TYPE_DVB | SUBT_TYPE_SCTE)
+
+typedef struct hiPAT_INFO_S
+{
+    HI_U16 u16ServiceID;    /*Progam 's SERVICE ID*/
+    HI_U16 u16PmtPid;        /*Progam 's PMT ID*/
+} PAT_INFO;
+
+typedef struct hiPAT_TB_S
+{
+    HI_U16 u16ProgNum;
+    HI_U16 u16TsID;
+    PAT_INFO PatInfo[CHANNEL_MAX_PROG];
+} PAT_TB;
+
+typedef struct hiPMT_VIDEO_S
+{
+    HI_U32 u32VideoEncType;
+    HI_U16 u16VideoPid;
+} PMT_VIDEO;
+
+typedef struct hiPMT_AUDIO_S
+{
+    HI_U32         u32AudioEncType;
+    HI_U16         u16AudioPid;
+    HI_U16         u16ADType;
+    HI_U8          u8AudLang[3];
+} PMT_AUDIO;
+typedef struct hiPMT_CA_S
+{
+    HI_U16 u16CASystemID;
+    HI_U16 u16CAPID ;
+} PMT_CA;
+
+typedef struct hiPMP_SUBTITLE_DES_S
+{
+    HI_U32 u32LangCode; /* low 24-bit valid */
+    HI_U8  u8SubtitleType;
+    HI_U16 u16PageID;
+    HI_U16 u16AncillaryPageID;
+
+} PMP_SUBTITLE_DES;
+
+typedef struct hiPMT_SUBTITLE_S
+{
+    HI_U16 u16SubtitlingPID;
+
+    HI_U8 u8DesTag; /*  */
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMP_SUBTITLE_DES DesInfo[SUBTDES_INFO_MAX];
+
+} PMT_SUBTITLE;
+
+typedef struct hiPMT_SCTE_SUBTITLE_S
+{
+
+    HI_U16 u16SCTESubtPID;
+    HI_U32 u32LanguageCode;
+} PMT_SCTE_SUBTITLE_S;
+
+typedef struct hiPMT_CLOSED_CAPTION_S
+{
+    HI_U32 u32LangCode;
+    HI_U8 u8IsDigitalCC;
+    HI_U8 u8ServiceNumber;
+    HI_U8 u8IsEasyReader;
+    HI_U8 u8IsWideAspectRatio;
+} PMT_CLOSED_CAPTION_S;
+
+typedef struct hiPMT_TTX_DES_S
+{
+    HI_U32 u32ISO639LanguageCode; /* low 24-bit valid */
+    HI_U8  u8TtxType;
+    HI_U8  u8TtxMagazineNumber;
+    HI_U8  u8TtxPageNumber;
+} PMT_TTX_DES_S;
+
+typedef struct hiPMT_TTX_S
+{
+    HI_U16 u16TtxPID;
+
+    HI_U8 u8DesTag;
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMT_TTX_DES_S stTtxDes[TTX_DES_MAX];
+
+} PMT_TTX_S;
+
+
+typedef struct hiPMT_TB_S
+{
+    HI_U16 u16ServiceID;
+    HI_U16 u16PcrPid;
+    HI_U16 u16VideoNum;
+    HI_U16 u16AudoNum;
+    HI_U16 u16CANum;
+    PMT_VIDEO Videoinfo[PROG_MAX_VIDEO];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];
+    PMT_CA CASystem[PROG_MAX_CA];
+
+    HI_U16 u16SubtitlingNum;
+    PMT_SUBTITLE SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16 u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16 u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_TB;
+
+typedef enum hiRUN_STATE_E
+{
+    UnDefined = 0,
+    NotRun,
+    StartInSeconds,
+    Pause,
+    Running,
+    Run_Reserved1,
+    Run_Reserved2,
+    Run_Reserved3
+} RUN_STATE_E;
+
+typedef enum hiCA_MODE_E
+{
+    CA_NotNeed = 0,
+    CA_Need
+} CA_MODE_E;
+
+typedef struct hiSDT_INFO_S
+{
+    HI_U16          u16ServiceID;
+    HI_U8       u8EitFlag;
+    HI_U8       u8EitFlag_PF;
+    RUN_STATE_E RunState;
+    CA_MODE_E   CAMode;
+
+    HI_U32      u32ServiceType;
+    HI_S8   s8ProgName[32];
+} SDT_INFO;
+
+typedef struct hiSDT_TB_S
+{
+    HI_U32 u32ProgNum;
+    HI_U16 u16TsId;
+    HI_U16 u16NetID;
+    SDT_INFO SdtInfo[CHANNEL_MAX_PROG];
+} SDT_TB;
+
+
+typedef struct hiPMT_COMPACT_PROG_S
+{
+    HI_U32 ProgID;          /* program ID */
+    HI_U32 PmtPid;          /*program PMT PID*/
+    HI_U32 PmtRemapPid; /* overlapped when remux, remap to new pid */
+    HI_U32 PcrPid;          /*program PCR PID*/
+
+    HI_U32   VideoType;
+    HI_U16               VElementNum;        /* video stream number */
+    HI_U16               VElementPid;        /* the first video stream PID*/
+    HI_U16               VElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U32   AudioFormat;
+    HI_U32   AudioType;
+    HI_U16               AElementNum;        /* audio stream number */
+    HI_U16               AElementPid;        /* the first audio stream PID*/
+    HI_U16               AElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U16 u16CANum;
+    PMT_CA CASystem[PROG_MAX_CA];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];     /* multi-audio info, added by gaoyanfeng 00182102 */
+
+    HI_U32              SubtType;            /*0---NONE,1---DVB,2---SCTE,3---BOTH*/
+    HI_U16              u16SubtitlingNum;
+    PMT_SUBTITLE        SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16               u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16              u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_COMPACT_PROG;
+
+typedef struct hiPMT_COMPACT_TBL_S
+{
+    HI_U32            prog_num;
+    PMT_COMPACT_PROG* proginfo;
+} PMT_COMPACT_TBL;
+
+HI_S32      DVB_SearchStart(HI_U32 u32DmxID);
+HI_VOID     DVB_SaveSearch(HI_U32 u32FrontendID);
+HI_VOID     DVB_ListProg();
+HI_S32      SRH_ParseSDT(const HI_U8* pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_ParsePMT ( const HI_U8* pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_ParsePAT( const HI_U8*  pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_PATRequest(HI_U32 u32DmxID, PAT_TB* pat_tb);
+HI_S32      SRH_PMTRequest(HI_U32 u32DmxID, PMT_TB* pmt_tb, HI_U16 u16PmtPid, HI_U16 u16ServiceId);
+HI_S32      SRH_PATRequestExt(HI_U32 u32DmxID, PAT_TB* pat_tb, HI_BOOL bTeeEnable);
+HI_S32      SRH_PMTRequestExt(HI_U32 u32DmxID, PMT_TB* pmt_tb, HI_U16 u16PmtPid, HI_U16 u16ServiceId, HI_BOOL bTeeEnable);
+HI_S32      SRH_SDTRequest(HI_U32 u32DmxID, SDT_TB* sdt_tb);
+/******************************************Search public interface***********************************/
+HI_VOID     HIADP_Search_Init();
+HI_S32      HIADP_Search_GetAllPmt(HI_U32 u32DmxId, PMT_COMPACT_TBL** ppProgTable);
+HI_S32      HIADP_Search_FreeAllPmt(PMT_COMPACT_TBL* pProgTable);
+HI_VOID     HIADP_Search_DeInit();
+HI_S32      HIADP_Search_GetAllPmtExt(HI_U32 u32DmxId, PMT_COMPACT_TBL **ppProgTable, HI_BOOL bTeeEnable);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /*__SEARCH_H__*/
diff --git a/xbmc/platform/linux/hisi/hi_audio_codec.h b/xbmc/platform/linux/hisi/hi_audio_codec.h
new file mode 100644
index 0000000000..524306b43b
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_audio_codec.h
@@ -0,0 +1,863 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_audio_codec.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2009/11/01
+Last Modified :
+Description   : define audio common data structure
+  History       :
+  1.Date        : 2009/11/10
+    Author      : zgjie
+    Modification: Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the audio codec. CNcomment:AUDIO_CODEC CNend
+ */
+
+#ifndef __HI_AUDIO_CODEC_H__
+#define __HI_AUDIO_CODEC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**Define HA codec Print Level*/
+/**CNcomment:HA codec*/
+#define HA_TRACE_LEVEL_FATAL    (0)
+#define HA_TRACE_LEVEL_ERROR    (1)
+#define HA_TRACE_LEVEL_WARN     (2)
+#define HA_TRACE_LEVEL_INFO     (3)
+#define HA_TRACE_LEVEL_DBG      (4)
+
+
+#ifndef HI_ADVCA_FUNCTION_RELEASE
+
+#ifndef CFG_HA_LOG_LEVEL
+#define CFG_HA_LOG_LEVEL         (HA_TRACE_LEVEL_ERROR)
+#endif
+
+#if (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_FATAL)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_ERROR)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRIN(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_WARN)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_INFO)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_DBG)
+
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)     do{printf(fmt);}while(0)
+
+#endif
+
+#else
+
+#define HA_FATAL_PRINT(fmt...)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#endif
+
+/**Define software dual decode*/
+/**CNcomment:*/
+#define HA_SW_DUALDEC_SUPPORT
+
+/**Define HA codec ID*/
+/**CNcomment:HA codec ID*/
+/*
+*                HA CODEC_ID defination
+*   |      7bit                9bit                3bit                   13bit  |
+*   |---vendor---|---format---|---reserved---|---id---|
+*/
+#define VENDOR_HISI 0x040
+#define VENDOR_NONE 0x010
+#define HA_VENDOR_OFFSETK  25 /* (32-7) */
+#define HA_VENDOR_MASK     (0x007fUL << HA_VENDOR_OFFSETK)
+#define HA_FORMAT_OFFSETK  16 /* (32-7-9) */
+#define HA_FORMAT_MASK     (0x01ffUL << HA_FORMAT_OFFSETK)
+#define HA_RESERVED_OFFSET 13 /* (32-7-9-3) */
+#define HA_RESERVED_MASK   (0x007UL << HA_RESERVED_OFFSET)
+#define HA_ID_OFFSET       0 /* (32-7-9-3-13) */
+#define HA_ID_MASK         (0x1fffUL<< HA_ID_OFFSET)
+
+#define HA_BUILD_CODEC_ID(vendor, format, id) (((((HI_U32)vendor) << HA_VENDOR_OFFSETK) & HA_VENDOR_MASK) | ((((HI_U32)format) << HA_FORMAT_OFFSETK) & HA_FORMAT_MASK) | (((HI_U32)id) & HA_ID_MASK))
+#define HA_GET_VENDOR(codec) ((HI_U32)(codec&HA_VENDOR_MASK)>>HA_VENDOR_OFFSETK)
+#define HA_GET_FORMAT(codec) ((HI_U32)(codec&HA_FORMAT_MASK)>>HA_FORMAT_OFFSETK)
+#define HA_GET_ID(codec)     ((HI_U32)(codec&HA_ID_MASK)>>HA_ID_OFFSET)
+
+/********************************Macro Definition********************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!-- ACODEC */
+
+/**Define HA codec common command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_COMMON_CMD_ID   0xffff
+
+/**Define HA codec format query command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_FORMAT_QUERY_CMD         ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1000)
+
+/**Define HA codec decoder open parameter command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_GET_DECOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1001)
+
+/**Define HA codec encoder open parameter command ID*/
+/**CNcomment:HA codec CMD ID*/
+#define HA_CODEC_GET_ENCOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1002)
+
+/**Define HA codec packet query command ID*/
+/**CNcomment:HA codec packetCMD ID*/
+#define HA_CODEC_PACKETDECODER_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1003)
+
+/**Define HA codec hwdecode query command ID*/
+/**CNcomment:HA codec hwdecodeCMD ID*/
+#define HA_CODEC_HARDWARECODEC_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1004)
+
+/**Define HA codec set outbuf addr command ID  only for hardware codec*/
+/**CNcomment:BufferCMD ID*/
+#define HA_CODEC_OUTBUFADDR_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1005)
+
+/**Define dual decode capability support query command ID*/
+/**CNcomment:CMD ID*/
+#define HA_CODEC_DUAL_DECODE_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1006)
+
+/**Define dual decode set ad output mode command ID*/
+/**CNcomment:ADCMD ID*/
+#define HA_CODEC_AD_OUTPUTMODE_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1007)
+
+/**Define AD Balance Setting command ID*/
+/**CNcomment:AD CMD ID*/
+#define HA_CODEC_AD_BALANCE_SET_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1008)
+
+/**Define PTS Delay command ID*/
+/**CNcomment:PTS Delay CMD ID*/
+#define HA_CODEC_PTS_DELAY_SET_CMD      ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1009)
+
+/**Define HA codec set whether work in compress mode command ID */
+/**CNcomment:CMD ID*/
+#define HA_CODEC_COMPRESSMODE_SET_CMD ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100A)
+
+/**Define HA codec get codec output delay ms*/
+/**CNcomment:CMD ID*/
+#define HA_CODEC_OUTPUTDELAY_GET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100B)
+
+/**Define HA codec maximum audio channel*/
+/**CNcomment:HA codec  */
+#define HA_AUDIO_MAXCHANNELS 8
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!--  ACODEC */
+
+/**HA format definition*/
+/**CNcomment:HA format */
+typedef enum hiHA_FORMAT_E
+{
+    FORMAT_MP2 = 0x000,  /**<MPEG audio layer 1, 2.*/ /**<CNcomment:MPEG */
+    FORMAT_MP3, /**<MPEG audio layer 1, 2, 3.*/ /**<CNcomment:MPEG */
+    FORMAT_AAC,
+    FORMAT_AC3,
+    FORMAT_DTS,
+    FORMAT_VORBIS,
+    FORMAT_DVAUDIO,
+    FORMAT_WMAV1,
+    FORMAT_WMAV2,
+    FORMAT_MACE3,
+    FORMAT_MACE6,
+    FORMAT_VMDAUDIO,
+    FORMAT_SONIC,
+    FORMAT_SONIC_LS,
+    FORMAT_FLAC,
+    FORMAT_MP3ADU,
+    FORMAT_MP3ON4,
+    FORMAT_SHORTEN,
+    FORMAT_ALAC,
+    FORMAT_WESTWOOD_SND1,
+    FORMAT_GSM,
+    FORMAT_QDM2,
+    FORMAT_COOK,
+    FORMAT_TRUESPEECH,
+    FORMAT_TTA,
+    FORMAT_SMACKAUDIO,
+    FORMAT_QCELP,
+    FORMAT_WAVPACK,
+    FORMAT_DSICINAUDIO,
+    FORMAT_IMC,
+    FORMAT_MUSEPACK7,
+    FORMAT_MLP,
+    FORMAT_GSM_MS, /**<as found in WAV.*/ /**<CNcomment:WAV */
+    FORMAT_ATRAC3,
+    FORMAT_VOXWARE,
+    FORMAT_APE,
+    FORMAT_NELLYMOSER,
+    FORMAT_MUSEPACK8,
+    FORMAT_SPEEX,
+    FORMAT_WMAVOICE,
+    FORMAT_WMAPRO,
+    FORMAT_WMALOSSLESS,
+    FORMAT_ATRAC3P,
+    FORMAT_EAC3,
+    FORMAT_SIPR,
+    FORMAT_MP1,
+    FORMAT_TWINVQ,
+    FORMAT_TRUEHD,
+    FORMAT_MP4ALS,
+    FORMAT_ATRAC1,
+    FORMAT_BINKAUDIO_RDFT,
+    FORMAT_BINKAUDIO_DCT,
+    FORMAT_DRA,
+
+    FORMAT_PCM = 0x100,/**<various PCM codecs.*/ /**<CNcomment:PCM */
+    FORMAT_PCM_BLURAY = 0x121,
+
+    FORMAT_ADPCM = 0x130,/**<various ADPCM codecs.*/ /**<CNcomment:ADPCM */
+
+    FORMAT_AMR_NB = 0x160,/**<various AMR codecs.*/ /**<CNcomment:AMR */
+    FORMAT_AMR_WB,
+    FORMAT_AMR_AWB,
+
+    FORMAT_RA_144 = 0x170,/**<RealAudio codecs.*/ /**<CNcomment:RealAudio */
+    FORMAT_RA_288,
+
+    FORMAT_DPCM = 0x180,/**<various DPCM codecs.*/ /**<CNcomment:DPCM */
+
+    FORMAT_G711 = 0x190,/**<various G.7xx codecs.*/ /**<CNcomment:G.7xx */
+    FORMAT_G722,
+    FORMAT_G7231,
+    FORMAT_G726,
+    FORMAT_G728,
+    FORMAT_G729AB,
+
+    FORMAT_OPUS = 0x1a0,
+
+    FORMAT_MULTI = 0x1f0,/**<support multi codecs.*/ /**<CNcomment: */
+/*ZHTQ ADD*/
+	FORMAT_MULTI_TRUEHD = 0x1f6,
+	FORMAT_MULTI_LPCM = 0x1f7,
+	FORMAT_MULTI_WMA = 0x1f8,
+	FORMAT_MULTI_WMAPRO = 0x1f9,
+    FORMAT_BUTT = 0x1ff,
+} HA_FORMAT_E;
+
+/**HA format definition*/
+/**CNcomment:HA_Codec*/
+typedef enum hiHA_CODEC_ID_E
+{
+    /** HISI Codec*/
+    HA_AUDIO_ID_PCM             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM, 0x0000),
+    HA_AUDIO_ID_MP2             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MP2, 0x0002),
+    HA_AUDIO_ID_MP3             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0003),
+    HA_AUDIO_ID_AAC             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AAC, 0x001),
+    HA_AUDIO_ID_BLYRAYLPCM      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM_BLURAY, 0x021),
+    HA_AUDIO_ID_COOK            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_COOK, 0x0009),
+    HA_AUDIO_ID_DRA             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DRA, 0x007),
+    HA_AUDIO_ID_WMA9STD         = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0006),
+    HA_AUDIO_ID_AMRNB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_NB, 0x0100),
+    HA_AUDIO_ID_AMRWB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_WB, 0x0110),
+    HA_AUDIO_ID_G711            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G711, 0x0102),
+    HA_AUDIO_ID_G722            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G722, 0x0105),
+    HA_AUDIO_ID_G726            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G726, 0x0106),
+    HA_AUDIO_ID_ADPCM           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_ADPCM, 0x0107),
+    HA_AUDIO_ID_VOICE           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0108),
+    HA_AUDIO_ID_TRUEHD          = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x0008),
+    HA_AUDIO_ID_AC3PASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0055),
+    HA_AUDIO_ID_DTSPASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DTS, 0x1025),
+    HA_AUDIO_ID_OPUS            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_OPUS, 0x1006),
+    HA_AUDIO_ID_VORBIS          = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_VORBIS, 0x1007),
+
+    /** DOLBY/DTS IPR Codec*/
+    HA_AUDIO_ID_DOLBY_PLUS      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x1010),
+    HA_AUDIO_ID_DOLBY_TRUEHD    = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x1011),
+    HA_AUDIO_ID_MS12_DDP        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1012),
+    HA_AUDIO_ID_MS12_AAC        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1013),
+    HA_AUDIO_ID_MS12_AC4        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1014),
+    HA_AUDIO_ID_DTSHD           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1020),
+    HA_AUDIO_ID_DTSM6           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1030),
+
+    /** FFMPEG Codec*/
+    HA_AUDIO_ID_FFMPEG_DECODE   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI,  0x03ff),
+    HA_AUDIO_ID_FFMPEG_WMAPRO   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_WMAPRO, 0x041f),
+
+    /** CUSTOMER Codec*/
+    HA_AUDIO_ID_CUSTOM_0        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0400),
+    HA_AUDIO_ID_CUSTOM_1        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0401),
+/*ZHTQ ADD*/	
+	HA_AUDIO_ID_CUSTOM_2        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0402),
+	HA_AUDIO_ID_CUSTOM_3        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_TRUEHD, 0x0403),
+	HA_AUDIO_ID_CUSTOM_4        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_LPCM, 0x0404),
+	HA_AUDIO_ID_CUSTOM_5	  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_WMA, 0x0405),
+	HA_AUDIO_ID_CUSTOM_6	  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_WMAPRO, 0x0406),
+} HA_CODEC_ID_E;
+
+/**HA Channel Mode definition*/
+/**CNcomment:*/
+typedef enum
+{
+    HA_AUDIO_CH_MODE_DUAL_MONO = 0x0,
+    HA_AUDIO_CH_MODE_MONO      = 0x1,
+    HA_AUDIO_CH_MODE_STEREO    = 0x2,
+    HA_AUDIO_CH_MODE_3_0_MODE  = 0x3,
+    HA_AUDIO_CH_MODE_2_1_MODE  = 0x4,
+    HA_AUDIO_CH_MODE_3_1_MODE  = 0x5,
+    HA_AUDIO_CH_MODE_2_2_MODE  = 0x6,
+    HA_AUDIO_CH_MODE_3_2_MODE  = 0x7,
+    HA_AUDIO_CH_MODE_JOINT_STEREO = 0x8,   /**<only in mp3 format.*/ /**<CNcomment:mp3joint stereo*/
+    HA_AUDIO_CH_MODE_BUTT      = 0x1ff
+} HA_AUDIO_CHANNELMODE_E;
+
+/**HA Audio Output AD Mode definition*/
+/**CNcomment:HA OUTPUT AD MODE */
+typedef enum
+{
+    HA_OUTPUT_AD_OFF = 0,
+    HA_OUTPUT_AD_ON,
+    HA_OUTPUT_AD_OFF_WITHASSOC,
+    HA_OUTPUT_AD_BUTT
+} HA_CODEC_OUTPUT_AD_MODE_E;
+
+/**Define query parameter of an HA codec.*/
+/**CNcomment:HA codec */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_VOID *pPara;
+} HA_CODEC_PARAMETER_QUERY_S;
+
+/**Define format query parameter of an HA codec.*/
+/**CNcomment:HA codec */
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_FORMAT_E enFormat;
+} HA_CODEC_FORMAT_QUERY_PARAM_S;
+
+/**Define packet query parameter of an HA codec.*/
+/**CNcomment:HA codec packet*/
+typedef struct
+{
+    HI_U32  enCmd;              /**<packet query command.*/ /**<CNcomment:packet*/
+    HI_BOOL bPacketDecoder;     /**<Packet mode.In this mode, the decoder can decode the next packet only after processing an entire packet. */
+                                /**<CNcomment:packet.packetpacket*/
+} HA_CODEC_PACKETDECODER_QUERY_PARAM_S;
+
+/**Define hardware decode query parameter of an HA codec.*/
+/**CNcomment:HA codec hardware*/
+typedef struct
+{
+    HI_U32  enCmd;      /**<hwdecode query command.*/ /**<CNcomment: hwdecode*/
+    HI_BOOL bHwCodec;   /**<HI_TRUE: hwdecode mode else swdecode mode. */ /**<CNcomment:hwdecode*/
+} HA_CODEC_HARDWARECODER_QUERY_PARAM_S;
+
+/**Define query parameter of dual decode capability.*/
+/**CNcomment:*/
+typedef struct
+{
+    HI_U32  enCmd;                  /**<query dual decode capability command.*/ /**<CNcomment: */
+    HI_BOOL bDualDecSupport;        /**<support dual decode or not. */  /**<CNcomment:*/
+} HA_CODEC_DUALDECODE_QUERY_PARAM_S;
+
+/**Define setting parameter of dual decode ad output mode.*/
+/**CNcomment:AD**/
+typedef struct
+{
+    HI_U32               enCmd;             /**<set AD Output Mode command.*/ /**<CNcomment: AD*/
+    HA_CODEC_OUTPUT_AD_MODE_E  enAdMode;    /**<AD Output Mode. */  /**<CNcomment:AD*/
+} HA_CODEC_ADMODE_SET_PARAM_S;
+
+/**Define setting parameter of AD Balance.*/
+/**CNcomment:AD **/
+typedef struct
+{
+    HI_U32  enCmd;                      /**<set AD Balance command.*/ /**<CNcomment: AD*/
+    HI_S16  s16ADBalance;               /**<set the value of AD Balance */  /**<CNcomment:AD*/
+} HA_CODEC_ADBALANCE_SET_PARAM_S;
+
+/**Define set parameter of whether work in compress mode.*/
+/**CNcomment:*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<set the compress mode command. */ /**<CNcomment:*/
+    HI_BOOL bCompressMode;  /**<whether work in compress mode. */ /**<CNcomment:*/
+} HA_CODEC_COMPRESSMODE_SET_PARAM_S;
+
+/**Define get parameter of decoder output delay.*/
+/**CNcomment:*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<get the output delay command. */ /**<CNcomment:*/
+    HI_U32  u32OutputDelay; /**<decoder output delay ms. */ /**<CNcomment:()*/
+} HA_CODEC_OUTOUTDELAY_GET_PARAM_S;
+
+/**Define the error codes of an HA codec.*/
+/**CNcomment:HA codec */
+typedef enum hiHA_ERRORTYPE_E
+{
+    HA_ErrorNone = 0, /**<None error.*/ /**<CNcomment: */
+
+    HA_ErrorInsufficientResources = (HI_S32) 0x80001000,/**<The device fails to be created due to insufficient resources.*/ /**<CNcomment: */
+
+    HA_ErrorInvalidParameter = (HI_S32) 0x80001001, /**<The input parameter is invalid.*/ /**<CNcomment: */
+
+    HA_ErrorStreamCorrupt = (HI_S32) 0x80001002, /**<The decoding fails due to incorrect input streams.*/ /**<CNcomment: */
+
+    HA_ErrorNotEnoughData = (HI_S32) 0x80001003,/**<The decoding ends due to insufficient streams.*/ /**<CNcomment: */
+
+    HA_ErrorDecodeMode = (HI_S32) 0x80001004,/**<The decoding mode is not supported.*/ /**<CNcomment: */
+
+    HA_ErrorNotSupportCodec = (HI_S32) 0x80001005,/**<The codec is not supported.*/ /**<CNcomment: */
+
+    HA_ErrorInBufFull = (HI_S32) 0x80001006,/**<Input buffer is full.*/ /**<CNcomment: */
+
+    HA_ErrorOutBufEmpty = (HI_S32) 0x80001007,/**<Output buffer is empty.*/ /**<CNcomment: */
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    HA_ErrorNotEnoughADData = (HI_S32) 0x80001008,/**<The decoding ends due to insufficient ad streams.*/ /**<CNcomment:ad */
+
+    HA_ErrorADDecFailed = (HI_S32) 0x80001009,
+#endif
+
+    HA_ErrorMax = 0x9FFFFFFF
+} HI_HA_ERRORTYPE_E;
+
+/**Definition of the distribution mode of the channels of an HA codec.*/
+/**CNcomment:HA codec */
+typedef enum hiHA_CHANNELTYPE_E
+{
+    HA_AUDIO_ChannelNone = 0x0,    /**< Unused or empty.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLF  = 0x1,     /**< Left front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRF  = 0x2,     /**< Right front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelCF  = 0x3,     /**< Center front.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLS  = 0x4,     /**< Left surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRS  = 0x5,     /**< Right surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLFE = 0x6,     /**< Low frequency effects.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelCS  = 0x7,     /**< Back surround.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelLR  = 0x8,     /**< Left rear.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelRR  = 0x9,     /**< Right rear.*/ /**<CNcomment:*/
+    HA_AUDIO_ChannelMax = 0x7FFFFFFF
+} HI_HA_CHANNELTYPE_E;
+
+/**Definition of the decoding mode of an HA decoder.*/
+/**CNcomment:HA */
+typedef enum hiHA_DECODEMODE_E
+{
+    HD_DEC_MODE_RAWPCM = 0,        /**<PCM decoding mode.*/ /**<CNcomment:PCM */
+    HD_DEC_MODE_THRU,              /**<SPIDF61937 passthrough decoding mode only, such as AC3/DTS.*/ /**<CNcomment:*/
+    HD_DEC_MODE_SIMUL,             /**<PCM and passthrough decoding mode.*/ /**<CNcomment:PCM + */
+    HD_DEC_MODE_BUTT = 0x7FFFFFFF
+} HI_HA_DECODEMODE_E;
+
+/**Definition of the HA codec version.*/
+/**CNcomment:HA codec */
+typedef union hiHI_HAAUDIO_VERSIONTYPE_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;      /**< Major version.*/ /**<CNcomment: */
+        HI_U8 u8VersionMinor;      /**< Minor version.*/ /**<CNcomment: */
+        HI_U8 u8Revision;          /**< Revision version.*/ /**<CNcomment: */
+        HI_U8 u8Step;              /**< Step version.*/ /**<CNcomment: */
+    } s;
+    HI_U32 u32Version;
+} HI_HAAUDIO_VERSIONTYPE_U;
+
+/**Definition of the data types of the PCM module in an HA codec HA codec.*/
+/**CNcomment:pcm */
+typedef struct hiHA_PCMMODETYPE_S
+{
+    HI_U32              u32DesiredOutChannels;/**<Input,number of expected output channels.If the number of original channels is not equal to the number of expected output channels,
+                                                  the decoded automatically performs down-mixing or up-mixing,In this way,
+                                                  the number of output channels is equal to the value of u32DesiredOutChannels,1: mono; 2 stereo. \n*/
+                                              /**<CNcomment:IN . 
+                                                  down-mix up-mix 
+                                                  u32DesiredOutChannels.  1: mono, 2 for stereo*/
+    HI_BOOL             bInterleaved;/**<Whether the PCM data is interleaved.
+                                         HI_TRUE: interleaved mode (L/R/L/R.. .L/R/L/R).
+                                         HI_FALSE: non-interleaved mode (L/L/L.../R/R/R...). \n*/
+                                     /**<CNcomment:IN PCM 
+                                         HI_TRUE:  : L/R/L/R...L/R/L/R.
+                                         HI_FALSE: : L/L/L......../R/R/R....... */
+    HI_U32              u32BitPerSample;/**<Input Bit width of the PCM data.Only 16-bit or 24-bit width is supported.For the data of 16-bit width, 16-bit memory is used,
+                                            For the data of 24-bit width, 32-bit memory is used,The active bits of the 24-bit PCM data are upper bits, and the lower eight bits are padded with 0s. \n*/
+                                        /**<CNcomment:IN PCM ,16 24  16bit 16bit ,
+                                            24bit 32.24bit PCM8 0*/
+    HI_U32              u32DesiredSampleRate; /**<Input, expected output sampling rate.*/ /**<CNcomment:IN */
+    HI_HA_CHANNELTYPE_E enChannelMapping[HA_AUDIO_MAXCHANNELS]; /**<Input, distribution mode of output channels.*/ /**<CNcomment:IN */
+} HI_HA_PCMMODETYPE_S;
+
+/**Configuration parameters required by an HA codec for creating devices.*/
+/**CNcomment:HA */
+typedef struct hiHADECODE_OPENPARAM_S
+{
+    HI_HA_DECODEMODE_E  enDecMode;  /**<IN Decode Mode.*/ /**<CNcomment:*/
+    HI_HA_PCMMODETYPE_S sPcmformat; /**<IN data types of pcm module.*/ /**<CNcomment:PCM*/
+    HI_VOID *           pCodecPrivateData;/**<Input, pointer to private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                          /**<CNcomment:IN  0*/
+    HI_U32              u32CodecPrivateDataSize;/**<Input, size of the private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                                /**<CNcomment:IN , 0*/
+} HI_HADECODE_OPENPARAM_S;
+
+/**Input streams of an HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHADECODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;  /**<Input, presentation time stamp (PTS) (in ms).Note: The HA decoder must discard this information. */ /**<CNcomment:*/
+    HI_U8  *pu8Data;   /**<Input/output, pointer to input streams.The decoder update this pointer after decoding. */ /**<CNcomment:IN/OUT */
+    HI_S32  s32Size;   /**<Input, size (in byte) of input streams.*/ /**<CNcomment:IN . unit: Byte*/
+    HI_BOOL bEndOfFrm; /**<Input, the last frame or not.*/ /**<CNcomment:IN */
+} HI_HADECODE_INPACKET_S;
+
+/**Get Open parameter of an HA decoder.*/
+/**CNcomment:HA */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_HADECODE_OPENPARAM_S *pstDecodeParams;
+} HA_CODEC_GET_DECOPENPARAM_PARAM_S;
+
+/**Definition of the decoder output pts infomations.*/
+/**CNcomment:pts*/
+typedef struct hiHI_HA_OUTPTSINFO_S
+{
+    union
+    {
+        HI_U32 u32SwDecoderBytesLeft;   /**<left bytes of software decoder.*/ /**<CNcomment: */
+        HI_U32 u32HwDecoderPtsReadPos;  /**<pts read position of software decoder.*/ /**<CNcomment:pts */
+    } unPts;
+
+    union
+    {
+        HI_U32 u32SwAdDecoderBytesLeft;     /**<ad left bytes of software decoder.*/ /**<CNcomment:ad */
+        HI_U32 u32HwAdDecoderPtsReadPos;    /**<ad pts read position of software decoder.*/ /**<CNcomment:ad pts */
+    } unAdPts;
+} HI_HA_OUTPTSINFO_S;
+
+/**Output structure of the HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHI_HADECODE_OUTPUT_S
+{
+    HI_S32 *ps32PcmOutBuf;       /**<Input, pointer to the decoded PCM data.
+                                     Note: 1) ps32PcmOutBuf must be 32-word aligned.
+                                           2) ps32PcmOutBuf is NULL when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN PCM . */
+
+    HI_U32  u32PcmOutBufSize;    /**<Input, size (in byte) of the buffer for storing the decoded PCM data
+                                     Note: u32PcmOutBufSize is 0 when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN  PCM . unit:Byte */
+
+    HI_S32 *ps32BitsOutBuf;      /**<Input, pointer to the decoded passthrough data.
+                                     Note: 1) ps32BitsOutBuf must be 32-word aligned.
+                                           2) ps32BitsOutBuf is NULL when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN . */
+
+    HI_U32  u32BitsOutBufSize;   /**<Input, size (in byte) of the buffer for storing the decoded passthrough data (IEC61937)
+                                     Note: u32BitsOutBufSize is 0 when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN (IEC61937) . unit:Byte */
+
+    HI_U32  u32PcmOutSamplesPerFrame; /**<Output, number of output sampling points after the PCM data is decoded.*/ /**<CNcomment:OUT. Pcm  */
+    HI_BOOL bInterleaved;             /**<Output, interleaved mode for PCM decoding.*/ /**<CNcomment:OUT PCM  */
+    HI_U32  u32BitPerSample;          /**<Output, bit per sampling.*/ /**<CNcomment:OUT */
+    HI_U32  u32BitsOutBytesPerFrame;  /**<Output, size (in byte) of the passthrough frame.*/ /**<CNcomment:OUT . unit: Byte*/
+    HI_U32  u32OutChannels;           /**<Output, number of output channels.*/ /**<CNcomment:OUT */
+    HI_U32  u32OutSampleRate;         /**<Output, output sampling rate.*/ /**<CNcomment:OUT. */
+    HI_U32  u32OrgChannels;           /**<Output, number of original channels.*/ /**<CNcomment:OUT */
+    HI_U32  u32OrgSampleRate;         /**<Output, original sampling rate.*/ /**<CNcomment:OUT */
+    HI_U32  u32BitRate;               /**<Output, bit rate (in bit/s) of the compressed streams.*/ /**<CNcomment:OUT unit: bit/S*/
+    HI_HA_OUTPTSINFO_S stPtsInfo;     /**<Output, pts information.*/ /**<CNcomment:OUT. pts*/
+    HI_U32  u32FrameIndex;   /**<Output, output frame index.*/ /**<CNcomment:OUT. */
+} HI_HADECODE_OUTPUT_S;
+
+/**Definition of the HA decoder.*/
+/**CNcomment:HA */
+typedef struct hiHA_DECODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about a decoder, such as MP3 or AAC. */
+                          /**<CNcomment:IN MP3,AAC*/
+
+    const HI_U32 enCodecID;/**<Input, decoder ID.Note: This ID is the identifier of a decoder, and must be unique. */
+                           /**<CNcomment:IN : */
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, decoder version.*/ /**<CNcomment:IN */
+
+    const HI_PCHAR pszDescription;/**<Input, detailed information about a decoder.*/ /**<CNcomment:IN */
+
+
+
+    struct hiHA_DECODE_S *pstNext;/**<Output, pointer to the next decoder.This member variable is maintained by the client that calls the HA codec,
+                                      Therefore, the developers of the HA decoder can ignore this member variable. \n*/
+                                  /**<CNcomment:OUT  .  HA Codec , HA */
+
+    HI_VOID  * pDllModule;/**<Output, pointer to the dll symbol of an HA decoder,This member variable is maintained by the client that calls the HA codec,
+                              Therefore, the developers of the HA decoder can ignore this member variable.\n*/
+                          /**<CNcomment:OUT HA Codec , HA */
+
+    /**
+    \brief Initializes a decoder. CNcomment: CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open CNend
+    \param[out] phDecoder   pointer of the decoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecInit)(HI_VOID * *phDecoder,
+                                 const HI_HADECODE_OPENPARAM_S * pstOpenParam);
+
+    /**
+    \brief DeInitializes a decoder. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   pointer of the decoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDeInit)(HI_VOID* hDecoder);
+
+    /**
+    \brief Configure a decoder dynamically. You can call this API when a decoder works.
+    CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the decoder CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID* hDecoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum size of the buffer required for storing the PCM data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:PCMsize.  CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the pcm audio frame. unit:Byte CNcomment:PCM CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxPcmOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief Maximum size of the buffer required for storing the passthrough data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:size. CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the iec61937 audio frame. unit:Byte CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxBitsOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to decode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDecodeFrame)(HI_VOID* hDecoder,
+                                        HI_HADECODE_INPACKET_S* pstApkt,
+                                        HI_HADECODE_OUTPUT_S* pstAOut);
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    /**
+    \brief This method is used to dual decode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[in] pstADApkt pointer to AD audio stream packet CNcomment:AD CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDualDecodeFrame)(HI_VOID* hDecoder,
+                                            HI_HADECODE_INPACKET_S* pstApkt,
+                                            HI_HADECODE_INPACKET_S* pstADApkt,
+                                            HI_HADECODE_OUTPUT_S* pstAOut);
+#endif
+
+} HI_HA_DECODE_S;
+
+/**Parameters for creating an HA encoder.*/
+/**CNcomment:HA */
+typedef struct hiHAENCODE_OPENPARAM_S
+{
+    HI_U32      u32DesiredOutChannels; /**<IN Number of channels (e.g 2 for stereo).*/ /**<CNcomment:*/
+    HI_BOOL     bInterleaved;       /**<IN interleave or not.*/ /**<CNcomment:*/
+    HI_S32      s32BitPerSample;    /**<IN bitwidth per sample.*/ /**<CNcomment:*/
+    HI_U32      u32DesiredSampleRate; /**<IN desired samplerate.*/ /**<CNcomment:*/
+    HI_U32      u32SamplePerFrame;  /**<IN Pcm samples per frame for encoder.*/ /**<CNcomment:*/
+    HI_VOID*    pCodecPrivateData;  /**<IN Pointer of decoder private open parameters note: if there is none private parameters, pCodecPrivateData=0.*/
+                                    /**<CNcomment:*/
+    HI_U32      u32CodecPrivateDataSize;/**<IN Size of decoder private open parameters note: if there is none private parameters, u32CodecPrivateDataSize=0.*/
+                                        /**<CNcomment:*/
+} HI_HAENCODE_OPENPARAM_S;
+
+/**HA input pcm  packet struct.*/
+/**CNcomment:packet*/
+typedef struct hiHAENCODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;       /**<IN  PTS (unit:MS) Note: HA encoder should discard this infomation.*/
+                            /**<CNcomment:PTS:*/
+    HI_U8*  pu8Data;        /**<IN/OUT pointer to input auduo pcm data note: HA encoder would update pu8Data after encode.*/
+                            /**<CNcomment:*/
+    HI_U32  u32Size;        /**<IN/OUT size of the input auduo data. unit: Byte.*/ /**<CNcomment:*/
+} HI_HAENCODE_INPACKET_S;
+
+/**HA encoder output struct.*/
+/**CNcomment:*/
+typedef struct hiHAENCODE_OUTPUT_S
+{
+    HI_S32* ps32BitsOutBuf;         /**<IN the pointer to encoded bitstream output buffer note: ps32BitsOutBuf must  be word32-aligned.*/
+                                    /**<CNcomment:buffer*/
+    HI_U32  u32BitsOutBufSize;      /**<IN the buffer size of bitstream output buffer. unit:Byte.*/ /**<CNcomment:buffer*/
+    HI_U32  u32BitsOutBytesPerFrame;/**<IN size of the encoded audio data frame ,unit: Byte.*/ /**<CNcomment::Byte*/
+    HI_U32  u32BitRate;             /**<IN compress bit rate of the audio stream.*/ /**<CNcomment:*/
+} HI_HAENCODE_OUTPUT_S;
+
+/**HA encoder struct define.*/
+/**CNcomment:*/
+typedef struct hiHA_ENCODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about audio encoder. */
+    /**<CNcomment:IN */
+
+    const HI_U32 enCodecID;/**<Input, encoder ID.Note: This ID is the identifier of a encoder, and must be unique. */
+    /**<CNcomment:IN : */
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, encoder version.*/ /**<CNcomment:IN */
+
+    const HI_PCHAR pszDescription;/**<Input, Description infomation of the audio encoder. */ /**<CNcomment:IN */
+
+    struct hiHA_ENCODE_S* pstNext;/**<OUT pointer to next HA enocder.manager by client.client:The layer of software that invokes the methods of the HA encoder. */
+    /**<CNcomment:OUT  */
+
+    HI_VOID*   pDllModule;/**<Output, pointer to the dll symbol of an HA encoder.This member variable is maintained by the client that calls the HA codec
+                              Therefore, the developers of the HA encoder can ignore this member variable. \n*/
+    /**<CNcomment:OUT HA Codec , HA */
+
+    /**
+    \brief Initializes a encoder. CNcomment: CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open CNend
+    \param[out] phEncoder   pointer of the encoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeInit)(HI_VOID * *phEncoder,
+                                    const HI_HAENCODE_OPENPARAM_S* pstOpenParam);
+
+    /**
+    \brief DeInitializes a encoder. CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   pointer of the encoder handle CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeDeInit)(HI_VOID* hEncoder);
+
+    /**
+    \brief Configure a encoder dynamically. It can be invoked anytime after the Encoder has been loaded.
+    CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   the encoder handle CNcomment: CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the encoder CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID* hEncoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum output size of an encoded bitstream CNcomment:size CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment: CNend
+    \param[out] pu32OutSizes pointer to the max size of the encoded audio frame. unit:Byte CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeGetMaxBitsOutSize)(HI_VOID* hEncoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to encode a frame. CNcomment: CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment: CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment: CNend
+    \param[out] pstAOut pointer to audio output CNcomment: CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment: CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeFrame)(HI_VOID* hEncoder,
+                                     HI_HAENCODE_INPACKET_S* pstApkt,
+                                     HI_HAENCODE_OUTPUT_S* pstAOut);
+} HI_HA_ENCODE_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* #ifndef __HI_AUDIO_CODEC_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_common.h b/xbmc/platform/linux/hisi/hi_common.h
new file mode 100644
index 0000000000..1c01b2c634
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_common.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_COMMON_H__
+#define __HI_COMMON_H__
+
+#include "hi_system.h"
+#include "hi_memory.h"
+#include "hi_user_proc.h"
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     COMMON */
+/** @{ */ /** <!--  [COMMON] */
+
+typedef struct hiRECT_S
+{
+    HI_S32 s32X;
+    HI_S32 s32Y;
+    HI_S32 s32Width;
+    HI_S32 s32Height;
+} HI_RECT_S;
+
+typedef enum hiLAYER_ZORDER_E
+{
+    HI_LAYER_ZORDER_MOVETOP = 0,  /**<Move to the top*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEUP,       /**<Move up*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEBOTTOM,   /**<Move to the bottom*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_MOVEDOWN,     /**<Move down*/ /**<CNcomment:   */
+    HI_LAYER_ZORDER_BUTT
+} HI_LAYER_ZORDER_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#endif /* __HI_COMMON_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_debug.h b/xbmc/platform/linux/hisi/hi_debug.h
new file mode 100644
index 0000000000..5818761387
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_debug.h
@@ -0,0 +1,239 @@
+/******************************************************************************
+Copyright (C), 2005-2018, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_debug.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2005/4/23
+Description   : Common debugging macro definition
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_DEBUG_H__
+#define __HI_DEBUG_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#include "hi_type.h"
+#include "hi_module.h"
+
+#ifdef HI_LOG_SUPPORT
+#define HI_DEBUG
+
+#ifdef __KERNEL__
+    #define HI_PRINT printk
+    #define HI_PANIC printk
+#else
+#include <stdio.h>
+    #define HI_PRINT printf
+    #define HI_PANIC printf
+#endif
+#else
+#undef HI_DEBUG
+
+#define HI_PANIC(fmt...)    \
+    do { \
+    } while (0)
+
+#define HI_PRINT(fmt...)    \
+    do { \
+    } while (0)
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup     HI_DEBUG */
+/** @{ */  /** <!-- [HI_DEBUG] */
+
+
+/**Default level of the output debugging information*/
+/**CNcomment: */
+#define HI_LOG_LEVEL_DEFAULT HI_LOG_LEVEL_ERROR
+
+/**Level of the output debugging information*/
+/**CNcomment: */
+typedef enum hiLOG_LEVEL_E
+{
+    HI_LOG_LEVEL_FATAL   = 0,     /**<Fatal error. It indicates that a critical problem occurs in the system. Therefore, you must pay attention to it.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_ERROR   = 1,     /**<Major error. It indicates that a major problem occurs in the system and the system cannot run.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_WARNING = 2,     /**<Warning. It indicates that a minor problem occurs in the system, but the system still can run properly.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_INFO    = 3,     /**<Message. It is used to prompt users. Users can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_DBG     = 4,     /**<Debug. It is used to prompt developers. Developers can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: ,  */
+    HI_LOG_LEVEL_TRACE   = 5,     /**<Trace. It is used to track the entry and exit of function when the interface is called.*/
+                                  /**<CNcomment:  */
+    HI_LOG_LEVEL_BUTT
+} HI_LOG_LEVEL_E;
+
+/** @} */
+
+/**Just only for fatal level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_FATAL    (0)
+/**Just only for error level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_ERROR    (1)
+/**Just only for warning level print. */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_WARN     (2)
+/**Just only for info level print.    */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_INFO     (3)
+/**Just only for debug level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_DBG      (4)
+/**Just only for trace level print.   */   /**CNcomment:  */
+#define HI_TRACE_LEVEL_TRACE    (5)
+
+#ifndef HI_LOG_LEVEL
+#define HI_LOG_LEVEL         (HI_TRACE_LEVEL_INFO)
+#endif
+
+
+/**Just only debug output,MUST BE NOT calling it. */
+/**CNcomment:  */
+extern HI_VOID HI_LogOut(HI_U32 u32Level, HI_MOD_ID_E enModId,
+            HI_U8 *pFuncName, HI_U32 u32LineNum, const char *format, ...);
+
+#ifdef HI_DEBUG
+
+#define HI_TRACE(level, module_id, fmt...)                      \
+    do{                                                         \
+        HI_LogOut(level, module_id, (HI_U8*)__FUNCTION__,__LINE__,fmt);  \
+    }while(0)
+
+#define HI_ASSERT(expr)                                     \
+    do{                                                     \
+        if (!(expr)) {                                      \
+            HI_PANIC("\nASSERT failed at:\n  >File name: %s\n  >Function : %s\n  >Line No. : %d\n  >Condition: %s\n", \
+                __FILE__,__FUNCTION__, __LINE__, #expr);    \
+        }                                                   \
+    }while(0)
+
+
+#define HI_ASSERT_RET(expr)                                     \
+    do{                                                         \
+        if (!(expr)) {                                          \
+            HI_PRINT("\n<%s %d>: ASSERT Failure{" #expr "}\n",  \
+                          __FUNCTION__, __LINE__);              \
+            return HI_FAILURE;                                  \
+        }                                                       \
+    }while(0)
+
+#define HI_DEBUG_LOG(fmt...) \
+            HI_TRACE(HI_LOG_LEVEL_INFO, HI_ID_SYS, fmt)
+
+
+/**Supported for debug output to serial/network/u-disk. */
+/**CNcomment: U */
+/**Just only reserve the fatal level output. */
+/**CNcomment:  */
+#if (HI_LOG_LEVEL == HI_TRACE_LEVEL_FATAL)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_ERROR)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error/warning level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_WARN)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error/warning/info level output. */
+/**CNcomment:  */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_INFO)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+#else
+/**Reserve all the levels output. */
+/**CNcomment:  */
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_DBG,      module_id, fmt)
+#define HI_TRACE_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_TRACE,    module_id, fmt)
+#endif
+
+#else
+#define HI_FATAL_PRINT(module_id, fmt...)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+
+#define HI_TRACE(level, module_id, fmt...)
+#define HI_ASSERT(expr)
+#define HI_ASSERT_RET(expr)
+#define HI_DEBUG_LOG(fmt...)
+#endif /* endif HI_DEBUG */
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define MKSTR(exp) # exp
+#define MKMARCOTOSTR(exp) MKSTR(exp)
+#define VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "] Build Time: [" __DATE__ ", " __TIME__ "]")
+#define USER_VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "]")
+
+/**Initialize a user module.*/
+/**CNcomment:  */
+#define HI_MODULE_DECLARE(MODULE_NAME)	\
+	static HI_U32 g_u32ModuleId = HI_INVALID_MODULE_ID;	\
+	static HI_S32 __attribute__((constructor(200))) init_module_id() \
+	{	 \
+		return HI_MODULE_RegisterByName(MODULE_NAME, &g_u32ModuleId); \
+	} \
+    static HI_S32 __attribute__((destructor(200))) deinit_module_id() \
+    { \
+        return HI_MODULE_UnRegister(g_u32ModuleId); \
+    }
+
+/**Defines a user module ID.*/
+/**CNcomment: ID */
+#define MODULE_ID (g_u32ModuleId)
+
+/**Defines the command of the user module different level log print.*/
+/**CNcomment:  */
+#define HI_MODULE_FATAL(pszFormat...)  HI_FATAL_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_ERROR(pszFormat...)  HI_ERR_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_WARN(pszFormat...)   HI_WARN_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_DEBUG(pszFormat...)  HI_DBG_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_INFO(pszFormat...)   HI_INFO_PRINT(MODULE_ID,pszFormat)
+
+/**Defines the memory allocate and free command used by user module.*/
+/**CNcomment:  */
+#define HI_MODULE_MALLOC(u32Size)               HI_MEM_Malloc(MODULE_ID, u32Size)
+#define HI_MODULE_FREE(pMemAddr)                HI_MEM_Free(MODULE_ID, pMemAddr)
+#define HI_MODULE_CALLOC(u32MemBlock, u32Size)  HI_MEM_Calloc(MODULE_ID, u32MemBlock, u32Size)
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_DEBUG_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_error_mpi.h b/xbmc/platform/linux/hisi/hi_error_mpi.h
new file mode 100644
index 0000000000..ec1c4e7e66
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_error_mpi.h
@@ -0,0 +1,936 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_error_mpi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2008/04/24
+  Description   : error code of MPI
+  History       :
+  1.Date        : 2008/04/24
+    Author      :
+    Modification: Created file
+
+******************************************************************************/
+/**
+\file
+\brief Describes the information about common error codes. CNcomment: 
+*/
+/* add include here */
+#ifndef __HI_UNF_MPI_ERRORCODE_H__
+#define __HI_UNF_MPI_ERRORCODE_H__
+
+#include "hi_module.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"
+{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      MSP_ERRCODE */
+/** @{ */  /** <!-- MSP_ERRCODE */
+
+#define HI_ERRCODE_DEF(moduleid, errid) (HI_U32)(0x80000000 | ((moduleid) << 16)  | (errid))
+
+#define HI_ERR_DISP_DEV_NOT_EXIST           (HI_S32)(0x80100001)
+#define HI_ERR_DISP_NOT_DEV_FILE            (HI_S32)(0x80100002)
+#define HI_ERR_DISP_DEV_OPEN_ERR            (HI_S32)(0x80100003)
+#define HI_ERR_DISP_DEV_CLOSE_ERR           (HI_S32)(0x80100004)
+#define HI_ERR_DISP_NULL_PTR                (HI_S32)(0x80100005)
+#define HI_ERR_DISP_NO_INIT                 (HI_S32)(0x80100006)
+#define HI_ERR_DISP_INVALID_PARA            (HI_S32)(0x80100007)
+#define HI_ERR_DISP_CREATE_ERR              (HI_S32)(0x80100008)
+#define HI_ERR_DISP_DESTROY_ERR             (HI_S32)(0x80100009)
+#define HI_ERR_DISP_NOT_EXIST               (HI_S32)(0x8010000A)
+#define HI_ERR_DISP_INVALID_OPT             (HI_S32)(0x8010000B)
+#define HI_ERR_DISP_NOT_SUPPORT_FMT         (HI_S32)(0x8010000C)
+#define HI_ERR_DISP_NOT_OPEN                (HI_S32)(0x8010000D)
+#define HI_ERR_DISP_SRC_UNAVAILABLE         (HI_S32)(0x8010000E)
+#define HI_ERR_DISP_NOT_SUPPORT             (HI_S32)(0x8010000F)
+#define HI_ERR_DISP_MALLOC_FAILED           (HI_S32)(0x80100010)
+#define HI_ERR_DISP_UNKNOWN                 (HI_S32)(0x801000FF)
+#define HI_ERR_DISP_TIMEOUT                 (HI_S32)(0x801000F1)
+#define HI_ERR_DISP_MALLOC_MAP_ERR          (HI_S32)(0x801000F2)
+
+
+
+#define HI_ERR_VO_DEV_NOT_EXIST             (HI_S32)(0x80110001)
+#define HI_ERR_VO_NOT_DEV_FILE              (HI_S32)(0x80110002)
+#define HI_ERR_VO_DEV_OPEN_ERR              (HI_S32)(0x80110003)
+#define HI_ERR_VO_DEV_CLOSE_ERR             (HI_S32)(0x80110004)
+#define HI_ERR_VO_NULL_PTR                  (HI_S32)(0x80110005)
+#define HI_ERR_VO_NO_INIT                   (HI_S32)(0x80110006)
+#define HI_ERR_VO_INVALID_PARA              (HI_S32)(0x80110007)
+#define HI_ERR_VO_CREATE_ERR                (HI_S32)(0x80110008)
+#define HI_ERR_VO_DESTROY_ERR               (HI_S32)(0x80110009)
+#define HI_ERR_VO_NOT_EXIST                 (HI_S32)(0x80110010)
+#define HI_ERR_VO_INVALID_OPT               (HI_S32)(0x80110030)
+#define HI_ERR_VO_WIN_NOT_EXIST             (HI_S32)(0x80110040)
+#define HI_ERR_VO_WIN_NOT_ENABLE            (HI_S32)(0x80110041)
+#define HI_ERR_VO_WIN_UNSUPPORT             (HI_S32)(0x80110042)
+#define HI_ERR_VO_TIMEOUT                   (HI_S32)(0x80110043)
+#define HI_ERR_VO_OPERATION_DENIED          (HI_S32)(0x80110044)
+#define HI_ERR_VO_SLAVE_WIN_LOST            (HI_S32)(0x80110045)
+#define HI_ERR_VO_FRAME_INFO_ERROR          (HI_S32)(0x80110046)
+#define HI_ERR_VO_FRAME_RELEASE_FAILED      (HI_S32)(0x80110047)
+#define HI_ERR_VO_NO_FRAME_TO_RELEASE       (HI_S32)(0x80110048)
+#define HI_ERR_VO_ADD_PROC_ERR              (HI_S32)(0x80110049)
+#define HI_ERR_VO_MALLOC_FAILED             (HI_S32)(0x80110050)
+#define HI_ERR_VO_DEPEND_DEVICE_NOT_READY   (HI_S32)(0x80110051)
+#define HI_ERR_VO_BUFQUE_FULL               (HI_S32)(0x80110052)
+#define HI_ERR_VO_BUFQUE_EMPTY              (HI_S32)(0x80110053)
+#define HI_ERR_VO_NO_SOURCE                 (HI_S32)(0x80110054)
+
+
+#define HI_ERR_VDEC_NOT_OPEN                (HI_S32)(0x80120001)
+#define HI_ERR_VDEC_INVALID_PARA            (HI_S32)(0x80120002)
+#define HI_ERR_VDEC_NULL_PTR                (HI_S32)(0x80120003)
+#define HI_ERR_VDEC_NOT_SUPPORT             (HI_S32)(0x80120004)
+#define HI_ERR_VDEC_TIMEOUT                 (HI_S32)(0x80120005)
+#define HI_ERR_VDEC_INPUT_CORRUPT           (HI_S32)(0x80120006)
+#define HI_ERR_VDEC_NO_ENOUGH_DATA          (HI_S32)(0x80120007)
+#define HI_ERR_VDEC_UNKNOWN                 (HI_S32)(0x80120008)
+#define HI_ERR_VDEC_MALLOC_FAILED           (HI_S32)(0x80120044)
+#define HI_ERR_VDEC_CREATECH_FAILED         (HI_S32)(0x80120047)
+#define HI_ERR_VDEC_DESTROYCH_FAILED        (HI_S32)(0x80120048)
+#define HI_ERR_VDEC_INVALID_CHANID          (HI_S32)(0x80120049)
+#define HI_ERR_VDEC_RESETCH_FAILED          (HI_S32)(0x80120050)
+#define HI_ERR_VDEC_SETATTR_FAILED          (HI_S32)(0x80120051)
+#define HI_ERR_VDEC_GETATTR_FAILED          (HI_S32)(0x80120052)
+#define HI_ERR_VDEC_SENDSTREAM_FAILED       (HI_S32)(0x80120053)
+#define HI_ERR_VDEC_RECEIVE_FAILED          (HI_S32)(0x80120054)
+#define HI_ERR_VDEC_DISCARD_PRIDATA         (HI_S32)(0x80120055)
+#define HI_ERR_VDEC_RELEASEFRAME_FAILED     (HI_S32)(0x80120056)
+#define HI_ERR_VDEC_RELEASEPRI_FAILED       (HI_S32)(0x80120057)
+#define HI_ERR_VDEC_NOT_INIT                (HI_S32)(0x80120059)
+#define HI_ERR_VDEC_USERCOPY_ERR            (HI_S32)(0x8012005A)
+#define HI_ERR_VDEC_LIST_EMPTY              (HI_S32)(0x8012005B)
+#define HI_ERR_VDEC_INVALID_STATE           (HI_S32)(0x8012005C)
+#define HI_ERR_VDEC_NOT_ENABLE              (HI_S32)(0x80120060)
+#define HI_ERR_VDEC_BUFFER_NOT_ATTACH       (HI_S32)(0x80120061)
+#define HI_ERR_VDEC_BUFFER_REQUIRE_INVALID  (HI_S32)(0x80120062)
+#define HI_ERR_VDEC_BUFFER_ATTACHED         (HI_S32)(0x80120063)
+#define HI_ERR_VDEC_BUFFER_FULL             (HI_S32)(0x80120064)
+
+#define HI_ERR_AO_NOT_INIT                  (HI_S32)(0x80130001)
+#define HI_ERR_AO_INVALID_PARA              (HI_S32)(0x80130002)
+#define HI_ERR_AO_NULL_PTR                  (HI_S32)(0x80130003)
+#define HI_ERR_AO_INVALID_ID                (HI_S32)(0x80130004)
+#define HI_ERR_AO_USED                      (HI_S32)(0x80130005)
+#define HI_ERR_AO_NOTSUPPORT                (HI_S32)(0x80130006)
+#define HI_ERR_AO_USERCOPY_ERR              (HI_S32)(0x80130007)
+#define HI_ERR_AO_SOUND_NOT_OPEN            (HI_S32)(0x80130008)
+#define HI_ERR_AO_INTR                      (HI_S32)(0x80130009)
+#define HI_ERR_AO_DEV_NOT_OPEN              (HI_S32)(0x80130041)
+#define HI_ERR_AO_CREATE_FAIL               (HI_S32)(0x80130042)
+#define HI_ERR_AO_OUT_BUF_FULL              (HI_S32)(0x80130046)
+#define HI_ERR_AO_INVALID_OUTFRAME          (HI_S32)(0x80130047)
+#define HI_ERR_AO_DATASIZE_EXCEED           (HI_S32)(0x80130048)
+#define HI_ERR_AO_INVALID_INFRAME           (HI_S32)(0x80130049)
+#define HI_ERR_AO_INBUF_EMPTY               (HI_S32)(0x8013004a)
+#define HI_ERR_AO_INVALID_PORT              (HI_S32)(0x8013004c)
+#define HI_ERR_AO_SENDMUTE                  (HI_S32)(0x8013004d)
+#define HI_ERR_AO_VIRTUALBUF_EMPTY          (HI_S32)(0x8013004e)
+#define HI_ERR_AO_PAUSE_STATE               (HI_S32)(0x8013004f)
+#define HI_ERR_AO_OUTPORT_NOT_ATTATCH       (HI_S32)(0x80130050)
+#define HI_ERR_AO_CAST_TIMEOUT              (HI_S32)(0x80130051)
+#define HI_ERR_AO_MALLOC_FAILED             (HI_S32)(0x80130052)
+#define HI_ERR_AO_DEVICE_BUSY               (HI_S32)(0x80130053)
+#define HI_ERR_AO_NOT_ACTIVED               (HI_S32)(0x80130054)
+
+#define HI_ERR_ADEC_DEV_NOT_OPEN            (HI_S32)(0x80140001)
+#define HI_ERR_ADEC_INVALID_PARA            (HI_S32)(0x80140002)
+#define HI_ERR_ADEC_NULL_PTR                (HI_S32)(0x80140003)
+#define HI_ERR_ADEC_IN_BUF_FULL             (HI_S32)(0x80140004)
+#define HI_ERR_ADEC_OUT_BUF_EMPTY           (HI_S32)(0x80140005)
+#define HI_ERR_ADEC_OUT_VOLUME              (HI_S32)(0x80140006)
+#define HI_ERR_ADEC_IN_PTSBUF_FULL          (HI_S32)(0x80140007)
+
+#define HI_ERR_DMX_NOT_INIT                 (HI_S32)(0x80150001)
+#define HI_ERR_DMX_INVALID_PARA             (HI_S32)(0x80150002)
+#define HI_ERR_DMX_NULL_PTR                 (HI_S32)(0x80150003)
+#define HI_ERR_DMX_NOT_SUPPORT              (HI_S32)(0x80150004)
+#define HI_ERR_DMX_TIMEOUT                  (HI_S32)(0x80150005)
+#define HI_ERR_DMX_ALLOC_MEM_FAILED         (HI_S32)(0x80150006)
+#define HI_ERR_DMX_BUSY                     (HI_S32)(0x80150007)
+#define HI_ERR_DMX_NOATTACH_PORT            (HI_S32)(0x80150008)
+#define HI_ERR_DMX_ATTACHED_PORT            (HI_S32)(0x80150009)
+#define HI_ERR_DMX_RECREAT_TSBUFFER         (HI_S32)(0x8015000a)
+#define HI_ERR_DMX_UNMATCH_CHAN             (HI_S32)(0x8015000b)
+#define HI_ERR_DMX_NOFREE_CHAN              (HI_S32)(0x8015000c)
+#define HI_ERR_DMX_OPENING_CHAN             (HI_S32)(0x8015000d)
+#define HI_ERR_DMX_NOT_OPEN_CHAN            (HI_S32)(0x8015000e)
+#define HI_ERR_DMX_ATTACHED_FILTER          (HI_S32)(0x8015000f)
+#define HI_ERR_DMX_NOATTACH_FILTER          (HI_S32)(0x80150010)
+#define HI_ERR_DMX_UNMATCH_FILTER           (HI_S32)(0x80150011)
+#define HI_ERR_DMX_NOFREE_FILTER            (HI_S32)(0x80150012)
+#define HI_ERR_DMX_NOATTACH_KEY             (HI_S32)(0x80150013)
+#define HI_ERR_DMX_UNMATCH_KEY              (HI_S32)(0x80150014)
+#define HI_ERR_DMX_NOFREE_KEY               (HI_S32)(0x80150015)
+#define HI_ERR_DMX_ATTACHED_KEY             (HI_S32)(0x80150016)
+#define HI_ERR_DMX_NOAVAILABLE_BUF          (HI_S32)(0x80150017)
+#define HI_ERR_DMX_NOAVAILABLE_DATA         (HI_S32)(0x80150018)
+#define HI_ERR_DMX_REACQUIRE_BUF            (HI_S32)(0x80150019)
+#define HI_ERR_DMX_OCCUPIED_PID             (HI_S32)(0x80150020)
+#define HI_ERR_DMX_MMAP_FAILED              (HI_S32)(0x80150021)
+#define HI_ERR_DMX_MUNMAP_FAILED            (HI_S32)(0x80150022)
+#define HI_ERR_DMX_EMPTY_BUFFER             (HI_S32)(0x80150023)
+#define HI_ERR_DMX_OVERFLOW_BUFFER          (HI_S32)(0x80150024)
+#define HI_ERR_DMX_NOT_START_REC_CHAN       (HI_S32)(0x80150030)
+#define HI_ERR_DMX_STARTING_REC_CHAN        (HI_S32)(0x80150031)
+#define HI_ERR_DMX_NOAVAILABLE_EXCLUDEPID   (HI_S32)(0x80150032)
+#define HI_ERR_DMX_NOAVAILABLE_TAG_PORT     (HI_S32)(0x80150033)
+#define HI_ERR_DMX_NOT_SUPPORT_TAGDEAL      (HI_S32)(0x80150034)
+#define HI_ERR_DMX_REC_BUFNOTMATCH          (HI_S32)(0x80150035)
+#define HI_ERR_DMX_INVALID_REC_CHAN         (HI_S32)(0x80150036)
+#define HI_ERR_DMX_BUSY_CHAN                (HI_S32)(0x80150037)
+#define HI_ERR_DMX_BUSY_FILTER              (HI_S32)(0x80150038)
+#define HI_ERR_DMX_BUSY_KEY                 (HI_S32)(0x80150039)
+#define HI_ERR_DMX_BUSY_REC                 (HI_S32)(0x8015003A)
+
+#define HI_ERR_TSIO_NOT_INIT                (HI_S32)(0x80160001)
+#define HI_ERR_TSIO_INVALID_PARA            (HI_S32)(0x80160002)
+#define HI_ERR_TSIO_NULL_PTR                (HI_S32)(0x80160003)
+#define HI_ERR_TSIO_NO_MEMORY               (HI_S32)(0x80160004)
+#define HI_ERR_TSIO_NO_RESOURCE             (HI_S32)(0x80160005)
+#define HI_ERR_TSIO_BUSY                    (HI_S32)(0x80160006)
+#define HI_ERR_TSIO_NOT_READY               (HI_S32)(0x80160007)
+#define HI_ERR_TSIO_NOAVAILABLE_BUF         (HI_S32)(0x80160008)
+#define HI_ERR_TSIO_NOAVAILABLE_DATA        (HI_S32)(0x80160009)
+#define HI_ERR_TSIO_INTR                    (HI_S32)(0x8016000a)
+#define HI_ERR_TSIO_TIMEOUT                 (HI_S32)(0x8016000b)
+#define HI_ERR_TSIO_NOT_SUPPORT             (HI_S32)(0x8016000c)
+#define HI_ERR_TSIO_CC_ERROR                (HI_S32)(0x8016000d)
+#define HI_ERR_TSIO_DEMUX_NOT_READY         (HI_S32)(0x8016000e)
+#define HI_ERR_TSIO_STALED                  (HI_S32)(0x8016000f)
+
+#define HI_ERR_VI_NO_INIT                   (HI_S32)(0x801A0001)
+#define HI_ERR_VI_INVALID_PARA              (HI_S32)(0x801A0002)
+#define HI_ERR_VI_NULL_PTR                  (HI_S32)(0x801A0003)
+#define HI_ERR_VI_INVALID_CHNID             (HI_S32)(0x801A0004)
+#define HI_ERR_VI_DEV_OPENED                (HI_S32)(0x801A0005)
+#define HI_ERR_VI_DEV_NOT_EXIST             (HI_S32)(0x801A0006)
+#define HI_ERR_VI_NOT_DEV_FILE              (HI_S32)(0x801A0007)
+#define HI_ERR_VI_NO_CHN_LEFT               (HI_S32)(0x801A0008)
+#define HI_ERR_VI_BUSY                      (HI_S32)(0x801A0009)
+#define HI_ERR_VI_CHN_NOT_EXIST             (HI_S32)(0x801A000A)
+#define HI_ERR_VI_CHN_INVALID_OPT           (HI_S32)(0x801A000B)
+#define HI_ERR_VI_CHN_INVALID_STAT          (HI_S32)(0x801A000C)
+#define HI_ERR_VI_CHN_INIT_BUF_ERR          (HI_S32)(0x801A000D)
+#define HI_ERR_VI_BUF_EMPTY                 (HI_S32)(0x801A000E)
+#define HI_ERR_VI_BUF_FULL                  (HI_S32)(0x801A000F)
+#define HI_ERR_VI_NOT_SUPPORT               (HI_S32)(0x801A0010)
+
+#define HI_ERR_AI_NOT_INIT                  (HI_S32)(0x801B0001)
+#define HI_ERR_AI_INVALID_PARA              (HI_S32)(0x801B0002)
+#define HI_ERR_AI_NULL_PTR                  (HI_S32)(0x801B0003)
+#define HI_ERR_AI_INVALID_ID                (HI_S32)(0x801B0004)
+#define HI_ERR_AI_DEV_OPENED                (HI_S32)(0x801B0005)
+#define HI_ERR_AI_NOTSUPPORT                (HI_S32)(0x801B0006)
+#define HI_ERR_AI_USERCOPY                  (HI_S32)(0x801B0007)
+#define HI_ERR_AI_BUFEMPTY                  (HI_S32)(0x801B0008)
+
+
+#define HI_ERR_AENC_DEV_NOT_OPEN            (HI_S32)(0x801C0001)
+#define HI_ERR_AENC_INVALID_PARA            (HI_S32)(0x801C0002)
+#define HI_ERR_AENC_NULL_PTR                (HI_S32)(0x801C0003)
+#define HI_ERR_AENC_OUT_BUF_FULL            (HI_S32)(0x801C0006)
+#define HI_ERR_AENC_INVALID_OUTFRAME        (HI_S32)(0x801C0007)
+#define HI_ERR_AENC_DATASIZE_EXCEED         (HI_S32)(0x801C0008)
+#define HI_ERR_AENC_CREATECH_FAIL           (HI_S32)(0x801C0009)
+#define HI_ERR_AENC_IN_BUF_FULL             (HI_S32)(0x801C000a)
+#define HI_ERR_AENC_CH_NOT_OPEN             (HI_S32)(0x801C000b)
+#define HI_ERR_AENC_OUT_BUF_EMPTY           (HI_S32)(0x801C000c)
+#define HI_ERR_AENC_OUT_BUF_BAD             (HI_S32)(0x801C000d)
+#define HI_ERR_AENC_IN_BUF_UNEMPTY          (HI_S32)(0x801C000e)
+#define HI_ERR_AENC_CH_NOT_SUPPORT          (HI_S32)(0x801C000f)
+
+
+#define HI_ERR_VENC_NO_INIT                 (HI_S32)(0x801D0001)
+#define HI_ERR_VENC_INVALID_PARA            (HI_S32)(0x801D0002)
+#define HI_ERR_VENC_NULL_PTR                (HI_S32)(0x801D0003)
+#define HI_ERR_VENC_INVALID_CHNID           (HI_S32)(0x801D0004)
+#define HI_ERR_VENC_DEV_OPENED              (HI_S32)(0x801D0005)
+#define HI_ERR_VENC_DEV_NOT_EXIST           (HI_S32)(0x801D0006)
+#define HI_ERR_VENC_NOT_DEV_FILE            (HI_S32)(0x801D0007)
+#define HI_ERR_VENC_CREATE_ERR              (HI_S32)(0x801D0008)
+#define HI_ERR_VENC_DESTROY_ERR             (HI_S32)(0x801D0009)
+#define HI_ERR_VENC_CHN_NOT_EXIST           (HI_S32)(0x801D000A)
+#define HI_ERR_VENC_CHN_INVALID_STAT        (HI_S32)(0x801D000B)
+#define HI_ERR_VENC_CHN_NO_ATTACH           (HI_S32)(0x801D000C)
+#define HI_ERR_VENC_BUF_EMPTY               (HI_S32)(0x801D000D)
+#define HI_ERR_VENC_CHN_RELEASE_ERR         (HI_S32)(0x801D000E)
+#define HI_ERR_VENC_NOT_SUPPORT             (HI_S32)(0x801D000F)
+
+#define HI_ERR_SIO_AI_INVALID_DEVID         (HI_S32)(0x801E0001)
+#define HI_ERR_SIO_AI_INVALID_CHNID         (HI_S32)(0x801E0002)
+#define HI_ERR_SIO_AI_ILLEGAL_PARAM         (HI_S32)(0x801E0003)
+#define HI_ERR_SIO_AI_NULL_PTR              (HI_S32)(0x801E0004)
+#define HI_ERR_SIO_AI_NOT_CONFIG            (HI_S32)(0x801E0005)
+#define HI_ERR_SIO_AI_NOT_SURPPORT          (HI_S32)(0x801E0006)
+#define HI_ERR_SIO_AI_NOT_PERM              (HI_S32)(0x801E0007)
+#define HI_ERR_SIO_AI_NOT_ENABLED           (HI_S32)(0x801E0008)
+#define HI_ERR_SIO_AI_NOMEM                 (HI_S32)(0x801E0009)
+#define HI_ERR_SIO_AI_NOBUF                 (HI_S32)(0x801E000A)
+#define HI_ERR_SIO_AI_BUF_EMPTY             (HI_S32)(0x801E000B)
+#define HI_ERR_SIO_AI_BUF_FULL              (HI_S32)(0x801E000C)
+#define HI_ERR_SIO_AI_SYS_NOTREADY          (HI_S32)(0x801E000D)
+#define HI_ERR_SIO_AI_BUSY                  (HI_S32)(0x801E000E)
+
+#define HI_ERR_SIO_AO_INVALID_DEVID         (HI_S32)(0x801F0001)
+#define HI_ERR_SIO_AO_INVALID_CHNID         (HI_S32)(0x801F0002)
+#define HI_ERR_SIO_AO_ILLEGAL_PARAM         (HI_S32)(0x801F0003)
+#define HI_ERR_SIO_AO_NULL_PTR              (HI_S32)(0x801F0004)
+#define HI_ERR_SIO_AO_NOT_CONFIG            (HI_S32)(0x801F0005)
+#define HI_ERR_SIO_AO_NOT_SURPPORT          (HI_S32)(0x801F0006)
+#define HI_ERR_SIO_AO_NOT_PERM              (HI_S32)(0x801F0007)
+#define HI_ERR_SIO_AO_NOT_ENABLED           (HI_S32)(0x801F0008)
+#define HI_ERR_SIO_AO_NOMEM                 (HI_S32)(0x801F0009)
+#define HI_ERR_SIO_AO_NOBUF                 (HI_S32)(0x801F000A)
+#define HI_ERR_SIO_AO_BUF_EMPTY             (HI_S32)(0x801F000B)
+#define HI_ERR_SIO_AO_BUF_FULL              (HI_S32)(0x801F000C)
+#define HI_ERR_SIO_AO_SYS_NOTREADY          (HI_S32)(0x801F000D)
+#define HI_ERR_SIO_AO_BUSY                  (HI_S32)(0x801F000E)
+
+#define HI_ERR_AFLT_NOT_INIT                (HI_S32)(0x80200001)
+#define HI_ERR_AFLT_INVALID_PARA            (HI_S32)(0x80200002)
+#define HI_ERR_AFLT_NULL_PTR                (HI_S32)(0x80200003)
+#define HI_ERR_AFLT_INVALID_HANDLE          (HI_S32)(0x80200004)
+#define HI_ERR_AFLT_CHN_NOT_OPEN            (HI_S32)(0x80200005)
+#define HI_ERR_AFLT_INBUF_FULL              (HI_S32)(0x80200006)
+#define HI_ERR_AFLT_OUTBUF_EMPTY            (HI_S32)(0x80200007)
+#define HI_ERR_AFLT_BUFEMPTY                (HI_S32)(0x80200008)
+
+#define HI_ERR_HDMI_NOT_INIT                (HI_S32)(0x80210001)
+#define HI_ERR_HDMI_INVALID_PARA            (HI_S32)(0x80210002)
+#define HI_ERR_HDMI_NUL_PTR                 (HI_S32)(0x80210003)
+#define HI_ERR_HDMI_DEV_NOT_OPEN            (HI_S32)(0x80210004)
+#define HI_ERR_HDMI_DEV_NOT_CONNECT         (HI_S32)(0x80210005)
+#define HI_ERR_HDMI_READ_SINK_FAILED        (HI_S32)(0x80210006)
+#define HI_ERR_HDMI_INIT_ALREADY            (HI_S32)(0x80210007)
+#define HI_ERR_HDMI_CALLBACK_ALREADY        (HI_S32)(0x80210008)
+#define HI_ERR_HDMI_INVALID_CALLBACK        (HI_S32)(0x80210009)
+#define HI_ERR_HDMI_FEATURE_NO_SUPPORT      (HI_S32)(0x8021000a)
+#define HI_ERR_HDMI_BUS_BUSY                (HI_S32)(0x8021000b)
+
+#define HI_ERR_PVR_NOT_INIT                 (HI_S32)(0x80300001)
+#define HI_ERR_PVR_INVALID_PARA             (HI_S32)(0x80300002)
+#define HI_ERR_PVR_NUL_PTR                  (HI_S32)(0x80300003)
+#define HI_ERR_PVR_CHN_NOT_INIT             (HI_S32)(0x80300004)
+#define HI_ERR_PVR_INVALID_CHNID            (HI_S32)(0x80300005)
+#define HI_ERR_PVR_NO_CHN_LEFT              (HI_S32)(0x80300006)
+#define HI_ERR_PVR_ALREADY                  (HI_S32)(0x80300007)
+#define HI_ERR_PVR_BUSY                     (HI_S32)(0x80300008)
+#define HI_ERR_PVR_NO_MEM                   (HI_S32)(0x80300009)
+#define HI_ERR_PVR_NOT_SUPPORT              (HI_S32)(0x8030000A)
+#define HI_ERR_PVR_RETRY                    (HI_S32)(0x8030000B)
+#define HI_ERR_PVR_FILE_EXIST               (HI_S32)(0x80300011)
+#define HI_ERR_PVR_FILE_NOT_EXIST           (HI_S32)(0x80300012)
+#define HI_ERR_PVR_FILE_CANT_OPEN           (HI_S32)(0x80300013)
+#define HI_ERR_PVR_FILE_CANT_CLOSE          (HI_S32)(0x80300014)
+#define HI_ERR_PVR_FILE_CANT_SEEK           (HI_S32)(0x80300015)
+#define HI_ERR_PVR_FILE_CANT_WRITE          (HI_S32)(0x80300016)
+#define HI_ERR_PVR_FILE_CANT_READ           (HI_S32)(0x80300017)
+#define HI_ERR_PVR_FILE_INVALID_FNAME       (HI_S32)(0x80300018)
+#define HI_ERR_PVR_FILE_TILL_START          (HI_S32)(0x80300019)
+#define HI_ERR_PVR_FILE_TILL_END            (HI_S32)(0x8030001A)
+#define HI_ERR_PVR_FILE_DISC_FULL           (HI_S32)(0x8030001B)
+#define HI_ERR_PVR_REC_INVALID_STATE        (HI_S32)(0x80300021)
+#define HI_ERR_PVR_REC_INVALID_DMXID        (HI_S32)(0x80300022)
+#define HI_ERR_PVR_REC_INVALID_FSIZE        (HI_S32)(0x80300023)
+#define HI_ERR_PVR_REC_INVALID_UDSIZE       (HI_S32)(0x80300024)
+#define HI_ERR_PVR_PLAY_INVALID_STATE       (HI_S32)(0x80300031)
+#define HI_ERR_PVR_PLAY_INVALID_DMXID       (HI_S32)(0x80300032)
+#define HI_ERR_PVR_PLAY_INVALID_TSBUFFER    (HI_S32)(0x80300033)
+#define HI_ERR_PVR_PLAY_INVALID_PACKETBUFFER (HI_S32)(0x80300034)
+#define HI_ERR_PVR_PLAY_INDEX_BEYOND_TS     (HI_S32)(0x80300035)
+#define HI_ERR_PVR_SEC_INIT_FAILED          (HI_S32)(0x80300036)
+#define HI_ERR_PVR_SEC_RUNTIME_ERROR        (HI_S32)(0x80300037)
+
+#define HI_ERR_PVR_INDEX_CANT_MKIDX         (HI_S32)(0x80300041)
+#define HI_ERR_PVR_INDEX_FORMAT_ERR         (HI_S32)(0x80300042)
+#define HI_ERR_PVR_INDEX_DATA_ERR           (HI_S32)(0x80300043)
+#define HI_ERR_PVR_INDEX_INVALID_ENTRY      (HI_S32)(0x80300044)
+#define HI_ERR_PVR_INTF_EVENT_INVAL         (HI_S32)(0x80300051)
+#define HI_ERR_PVR_INTF_EVENT_NOREG         (HI_S32)(0x80300052)
+#define HI_ERR_ADVCA_PVR_KEY_CHECK_FAILED   (HI_S32)(0x80300053)
+#define HI_ERR_ADVCA_PVR_CMAC_CHECK_FAILED  (HI_S32)(0x80300054)
+
+#define HI_ERR_AVPLAY_DEV_NOT_EXIST         (HI_S32)(0x80310001)
+#define HI_ERR_AVPLAY_NOT_DEV_FILE          (HI_S32)(0x80310002)
+#define HI_ERR_AVPLAY_DEV_OPEN_ERR          (HI_S32)(0x80310003)
+#define HI_ERR_AVPLAY_DEV_CLOSE_ERR         (HI_S32)(0x80310004)
+#define HI_ERR_AVPLAY_NULL_PTR              (HI_S32)(0x80310005)
+#define HI_ERR_AVPLAY_DEV_NO_INIT           (HI_S32)(0x80310006)
+#define HI_ERR_AVPLAY_INVALID_PARA          (HI_S32)(0x80310007)
+#define HI_ERR_AVPLAY_CREATE_ERR            (HI_S32)(0x80310008)
+#define HI_ERR_AVPLAY_DESTROY_ERR           (HI_S32)(0x80310009)
+#define HI_ERR_AVPLAY_INVALID_OPT           (HI_S32)(0x8031000A)
+#define HI_ERR_AVPLAY_NOT_SUPPORT           (HI_S32)(0x8031000B)
+
+#define HI_ERR_SYNC_DEV_NOT_EXIST           (HI_S32)(0x80320001)
+#define HI_ERR_SYNC_NOT_DEV_FILE            (HI_S32)(0x80320002)
+#define HI_ERR_SYNC_DEV_OPEN_ERR            (HI_S32)(0x80320003)
+#define HI_ERR_SYNC_DEV_CLOSE_ERR           (HI_S32)(0x80320004)
+#define HI_ERR_SYNC_NULL_PTR                (HI_S32)(0x80320005)
+#define HI_ERR_SYNC_DEV_NO_INIT             (HI_S32)(0x80320006)
+#define HI_ERR_SYNC_INVALID_PARA            (HI_S32)(0x80320007)
+#define HI_ERR_SYNC_CREATE_ERR              (HI_S32)(0x80320008)
+#define HI_ERR_SYNC_DESTROY_ERR             (HI_S32)(0x80320009)
+#define HI_ERR_SYNC_INVALID_OPT             (HI_S32)(0x8032000A)
+
+#define HI_ERR_MCE_DEV_NOT_EXIST            (HI_S32)(0x80330001)
+#define HI_ERR_MCE_NOT_DEVICE               (HI_S32)(0x80330002)
+#define HI_ERR_MCE_DEV_OPEN_ERR             (HI_S32)(0x80330003)
+#define HI_ERR_MCE_DEV_NOT_INIT             (HI_S32)(0x80330004)
+#define HI_ERR_MCE_PTR_NULL                 (HI_S32)(0x80330005)
+#define HI_ERR_MCE_PARAM_INVALID            (HI_S32)(0x80330006)
+#define HI_ERR_MCE_GET_MTDINFO_ERR          (HI_S32)(0x80330007)
+#define HI_ERR_MCE_MTD_OPEN                 (HI_S32)(0x80330008)
+#define HI_ERR_MCE_MTD_CLOSE                (HI_S32)(0x80330009)
+#define HI_ERR_MCE_MTD_READ                 (HI_S32)(0x80330010)
+#define HI_ERR_MCE_MTD_WRITE                (HI_S32)(0x80330011)
+#define HI_ERR_MCE_MTD_GETINFO              (HI_S32)(0x80330012)
+#define HI_ERR_MCE_MTD_ERASE                (HI_S32)(0x80330013)
+#define HI_ERR_MCE_MEM_ALLC                 (HI_S32)(0x80330014)
+#define HI_ERR_MCE_INVALID_OPT              (HI_S32)(0x80330015)
+
+#define HI_ERR_VP_PTR_NULL                  (HI_S32)(0x80340001)
+#define HI_ERR_VP_NOT_INIT                  (HI_S32)(0x80340002)
+#define HI_ERR_VP_DEV_NOT_EXIST             (HI_S32)(0x80340003)
+#define HI_ERR_VP_NOT_DEV_FILE              (HI_S32)(0x80340004)
+#define HI_ERR_VP_DEV_OPEN_ERR              (HI_S32)(0x80340005)
+#define HI_ERR_VP_INVALID_PARA              (HI_S32)(0x80340006)
+#define HI_ERR_VP_NOT_SUPPORT               (HI_S32)(0x80340007)
+#define HI_ERR_VP_INVALID_HANDLE            (HI_S32)(0x80340008)
+#define HI_ERR_VP_HANDLE_NOTEXIST           (HI_S32)(0x80340009)
+#define HI_ERR_VP_NOT_READY                 (HI_S32)(0x8034000a)
+#define HI_ERR_VP_ILLEGAL_STATE             (HI_S32)(0x8034000b)
+
+#define HI_ERR_IR_OPEN_ERR                          (HI_S32)(0x80410001)
+#define HI_ERR_IR_CLOSE_ERR                         (HI_S32)(0x80410002)
+#define HI_ERR_IR_NOT_INIT                          (HI_S32)(0x80410003)
+#define HI_ERR_IR_INVALID_PARA                      (HI_S32)(0x80410004)
+#define HI_ERR_IR_NULL_PTR                          (HI_S32)(0x80410005)
+#define HI_ERR_IR_READ_FAILED                       (HI_S32)(0x80410006)
+#define HI_ERR_IR_ENABLE_FAILED                     (HI_S32)(0x80410007)
+#define HI_ERR_IR_SET_BLOCKTIME_FAILED              (HI_S32)(0x80410008)
+#define HI_ERR_IR_SET_FETCHMETHOD_FAILED            (HI_S32)(0x80410009)
+#define HI_ERR_IR_SET_KEYUP_FAILED                  (HI_S32)(0x8041000A)
+#define HI_ERR_IR_SET_REPEAT_FAILED                 (HI_S32)(0x8041000B)
+#define HI_ERR_IR_SET_REPKEYTIMEOUT_FAILED          (HI_S32)(0x8041000C)
+#define HI_ERR_IR_RESET_FAILED                      (HI_S32)(0x8041000D)
+#define HI_ERR_IR_ENABLE_PROT_FAILED                (HI_S32)(0x8041000E)
+#define HI_ERR_IR_DISABLE_PROT_FAILED               (HI_S32)(0x8041000F)
+#define HI_ERR_IR_GET_PROTENABLE_FAILED             (HI_S32)(0x80410010)
+#define HI_ERR_IR_SETFORMAT_FAILED                  (HI_S32)(0x80410011)
+#define HI_ERR_IR_UNSUPPORT                         (HI_S32)(0x80410012)
+
+#define HI_ERR_RTC_NOT_INIT                         (HI_S32)(0x80420001)
+#define HI_ERR_RTC_REPEAT_INIT                      (HI_S32)(0x80420002)
+#define HI_ERR_RTC_INVALID_POINT                    (HI_S32)(0x80420003)
+#define HI_ERR_RTC_INVALID_PARA                     (HI_S32)(0x80420004)
+#define HI_ERR_RTC_FAILED_INIT                      (HI_S32)(0x80420005)
+#define HI_ERR_RTC_FAILED_SETTIME                   (HI_S32)(0x80420006)
+#define HI_ERR_RTC_FAILED_GETTIME                   (HI_S32)(0x80420007)
+#define HI_ERR_RTC_FAILED_ALARMENABLE               (HI_S32)(0x80420008)
+#define HI_ERR_RTC_FAILED_ALARMDISABLE              (HI_S32)(0x80420009)
+#define HI_ERR_RTC_FAILED_SETALARM                  (HI_S32)(0x8042000A)
+#define HI_ERR_RTC_FAILED_GETALARM                  (HI_S32)(0x8042000B)
+
+#define HI_ERR_WDG_NOT_INIT                         (HI_S32)(0x80430001)
+#define HI_ERR_WDG_REPEAT_INIT                      (HI_S32)(0x80430002)
+#define HI_ERR_WDG_INVALID_POINT                    (HI_S32)(0x80430003)
+#define HI_ERR_WDG_INVALID_PARA                     (HI_S32)(0x80430004)
+#define HI_ERR_WDG_FAILED_INIT                      (HI_S32)(0x80430005)
+#define HI_ERR_WDG_FAILED_SETTIMEOUT                (HI_S32)(0x80430006)
+#define HI_ERR_WDG_FAILED_ENABLE                    (HI_S32)(0x80430007)
+#define HI_ERR_WDG_FAILED_DISABLE                   (HI_S32)(0x80430008)
+#define HI_ERR_WDG_FAILED_CLEARWDG                  (HI_S32)(0x80430009)
+#define HI_ERR_WDG_FAILED_RESET                     (HI_S32)(0x8043000A)
+#define HI_ERR_WDG_FAILED_RESMODE                   (HI_S32)(0x8043000B)
+#define HI_ERR_WDG_NOT_SUPPORT                      (HI_S32)(0x8043000C)
+#define HI_ERR_WDG_FAILED_GETTIMEOUT                (HI_S32)(0x8043000D)
+#define HI_ERR_WDG_FAILED_DEINIT                    (HI_S32)(0x8043000E)
+
+#define HI_ERR_I2C_OPEN_ERR                         (HI_S32)(0x80440001)
+#define HI_ERR_I2C_CLOSE_ERR                        (HI_S32)(0x80440002)
+#define HI_ERR_I2C_NOT_INIT                         (HI_S32)(0x80440003)
+#define HI_ERR_I2C_INVALID_PARA                     (HI_S32)(0x80440004)
+#define HI_ERR_I2C_NULL_PTR                         (HI_S32)(0x80440005)
+#define HI_ERR_I2C_COPY_DATA_ERR                    (HI_S32)(0x80440006)
+#define HI_ERR_I2C_MALLOC_ERR                       (HI_S32)(0x80440007)
+#define HI_ERR_I2C_WRITE_TIMEOUT                    (HI_S32)(0x80440008)
+#define HI_ERR_I2C_READ_TIMEOUT                     (HI_S32)(0x80440009)
+
+#define HI_ERR_SCI_OPEN_ERR                         (HI_S32)(0x80450001)
+#define HI_ERR_SCI_CLOSE_ERR                        (HI_S32)(0x80450002)
+#define HI_ERR_SCI_NOT_INIT                         (HI_S32)(0x80450003)
+#define HI_ERR_SCI_INVALID_PARA                     (HI_S32)(0x80450004)
+#define HI_ERR_SCI_NULL_PTR                         (HI_S32)(0x80450005)
+#define HI_ERR_SCI_INVALID_OPT                      (HI_S32)(0x80450006)
+#define HI_ERR_SCI_SEND_ERR                         (HI_S32)(0x80450007)
+#define HI_ERR_SCI_RECEIVE_ERR                      (HI_S32)(0x80450008)
+#define HI_ERR_SCI_NO_ATR                           (HI_S32)(0x80450009)
+#define HI_ERR_SCI_PPS_PTYPE_ERR                    (HI_S32)(0x8045000A)
+#define HI_ERR_SCI_PPS_FACTOR_ERR                   (HI_S32)(0x8045000B)
+#define HI_ERR_SCI_PPS_NOTSUPPORT_ERR               (HI_S32)(0x8045000C)
+#define HI_ERR_SCI_NOTSUPPORT                       (HI_S32)(0x8045000D)
+
+#define HI_ERR_ETH_NOT_INIT                         (HI_S32)(0x80460001)
+#define HI_ERR_ETH_REPEAT_INIT                      (HI_S32)(0x80460002)
+#define HI_ERR_ETH_INVALID_POINT                    (HI_S32)(0x80460003)
+#define HI_ERR_ETH_INVALID_PARA                     (HI_S32)(0x80460004)
+#define HI_ERR_ETH_FAILED_INIT                      (HI_S32)(0x80460005)
+
+#define HI_ERR_GPIO_OPEN_ERR                        (HI_S32)(0x80470001)
+#define HI_ERR_GPIO_CLOSE_ERR                       (HI_S32)(0x80470002)
+#define HI_ERR_GPIO_NOT_INIT                        (HI_S32)(0x80470003)
+#define HI_ERR_GPIO_INVALID_PARA                    (HI_S32)(0x80470004)
+#define HI_ERR_GPIO_NULL_PTR                        (HI_S32)(0x80470005)
+#define HI_ERR_GPIO_INVALID_OPT                     (HI_S32)(0x80470006)
+#define HI_ERR_GPIO_FAILED_SETINT                   (HI_S32)(0x80470007)
+#define HI_ERR_GPIO_FAILED_SETENABLE                (HI_S32)(0x80470008)
+#define HI_ERR_GPIO_FAILED_GETINT                   (HI_S32)(0x80470009)
+#define HI_ERR_GPIO_GETINT_TIMEOUT                  (HI_S32)(0x8047000A)
+#define HI_ERR_GPIO_INTTYPE_NOT_SUPPORT             (HI_S32)(0x8047000B)
+#define HI_ERR_GPIO_NOT_SUPPORT                     (HI_S32)(0x8047000C)
+#define HI_ERR_GPIO_FAILED_SETOUTPUTTYPE            (HI_S32)(0x8047000D)
+#define HI_ERR_GPIO_FAILED_GETOUTPUTTYPE            (HI_S32)(0x8047000E)
+#define HI_ERR_GPIO_FAILED_SETDIRECT                (HI_S32)(0x8047000F)
+#define HI_ERR_GPIO_FAILED_GETDIRECT                (HI_S32)(0x80470010)
+#define HI_ERR_GPIO_FAILED_SETVALUE                 (HI_S32)(0x80470011)
+#define HI_ERR_GPIO_FAILED_GETVALUE                 (HI_S32)(0x80470012)
+
+#define HI_ERR_DMAC_NOT_INIT                        (HI_S32)(0x80480001)
+#define HI_ERR_DMAC_REPEAT_INIT                     (HI_S32)(0x80480002)
+#define HI_ERR_DMAC_INVALID_POINT                   (HI_S32)(0x80480003)
+#define HI_ERR_DMAC_INVALID_PARA                    (HI_S32)(0x80480004)
+#define HI_ERR_DMAC_FAILED_INIT                     (HI_S32)(0x80480005)
+#define HI_ERR_DMAC_FAILED_GETCHANNEL               (HI_S32)(0x80480006)
+#define HI_ERR_DMAC_FAILED_MEMTRANS                 (HI_S32)(0x80480007)
+#define HI_ERR_DMAC_FAILED_PERTRANS                 (HI_S32)(0x80480008)
+#define HI_ERR_DMAC_FAILED_GETSTAT                  (HI_S32)(0x80480009)
+#define HI_ERR_DMAC_FAILED_LISTRESET                (HI_S32)(0x8048000A)
+#define HI_ERR_DMAC_FAILED_ADDLIST                  (HI_S32)(0x8048000B)
+#define HI_ERR_DMAC_FAILED_LISTTRANS                (HI_S32)(0x8048000C)
+
+#define  HI_ERR_PMOC_NOT_INIT                       (HI_S32)(0x80490001)
+#define  HI_ERR_PMOC_REPEAT_INIT                    (HI_S32)(0x80490002)
+#define  HI_ERR_PMOC_INVALID_POINT                  (HI_S32)(0x80490003)
+#define  HI_ERR_PMOC_INVALID_PARA                   (HI_S32)(0x80490004)
+#define  HI_ERR_PMOC_FAILED_INIT                    (HI_S32)(0x80490005)
+#define  HI_ERR_PMOC_FAILED_MODE                    (HI_S32)(0x80490006)
+#define  HI_ERR_PMOC_FAILED_READMODE                (HI_S32)(0x80490007)
+#define  HI_ERR_PMOC_FAILED_SETWAKEUPVAL            (HI_S32)(0x80490008)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPVAL            (HI_S32)(0x80490009)
+#define  HI_ERR_PMOC_INVALID_MODE                   (HI_S32)(0x8049000A)
+#define  HI_ERR_PMOC_FAILED_STANDBY                 (HI_S32)(0x8049000B)
+#define  HI_ERR_PMOC_FAILED_SETDEV                  (HI_S32)(0x8049000C)
+#define  HI_ERR_PMOC_FAILED_GETPERIOD               (HI_S32)(0x8049000D)
+#define  HI_ERR_PMOC_FAILED_IRPOWERVAL              (HI_S32)(0x8049000E)
+#define  HI_ERR_PMOC_FAILED_KEYLEDPOWERVAL          (HI_S32)(0x8049000F)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPMODE           (HI_S32)(0x80490010)
+#define  HI_ERR_PMOC_FAILED_GETTEMPERATURE          (HI_S32)(0x80490011)
+
+#define HI_ERR_TUNER_NOT_INIT                       (HI_S32)(0x804A0001)
+#define HI_ERR_TUNER_NOT_OPEN                       (HI_S32)(0x804A0002)
+#define HI_ERR_TUNER_INVALID_POINT                  (HI_S32)(0x804A0003)
+#define HI_ERR_TUNER_INVALID_PARA                   (HI_S32)(0x804A0004)
+#define HI_ERR_TUNER_FAILED_INIT                    (HI_S32)(0x804A0005)
+#define HI_ERR_TUNER_FAILED_CONNECT                 (HI_S32)(0x804A0006)
+#define HI_ERR_TUNER_FAILED_GETSTATUS               (HI_S32)(0x804A0007)
+#define HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH       (HI_S32)(0x804A0008)
+#define HI_ERR_TUNER_FAILED_GETBER                  (HI_S32)(0x804A0009)
+#define HI_ERR_TUNER_FAILED_GETSNR                  (HI_S32)(0x804A000A)
+#define HI_ERR_TUNER_FAILED_SETTSTYPE               (HI_S32)(0x804A000B)
+#define HI_ERR_TUNER_FAILED_SELECTTUNER             (HI_S32)(0x804A000C)
+#define HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL        (HI_S32)(0x804A000D)
+#define HI_ERR_TUNER_FAILED_LOWCONS                 (HI_S32)(0x804A000E)
+#define HI_ERR_TUNER_FAILED_NORMALMODE              (HI_S32)(0x804A000F)
+#define HI_ERR_TUNER_FAILED_REGRW                   (HI_S32)(0x804A0010)
+#define HI_ERR_TUNER_FAILED_SETTUNER                (HI_S32)(0x804A0011)
+#define HI_ERR_TUNER_NOT_CONNECT                    (HI_S32)(0x804A0012)
+#define HI_ERR_TUNER_INVALID_PORT                   (HI_S32)(0x804A0013)
+#define HI_ERR_TUNER_FAILED_SETQAMINSIDE            (HI_S32)(0x804A0014)
+#define HI_ERR_TUNER_FAILED_SELECTSYMBOLRATE        (HI_S32)(0x804A0015)
+#define HI_ERR_TUNER_FAILED_GETSIGNALQUALITY        (HI_S32)(0x804A0016)
+#define HI_ERR_TUNER_FAILED_GETSIGNALINFO           (HI_S32)(0x804A0017)
+#define HI_ERR_TUNER_FAILED_BLINDSCAN               (HI_S32)(0x804A0018)
+#define HI_ERR_TUNER_FAILED_LNBCTRL                 (HI_S32)(0x804A0019)
+#define HI_ERR_TUNER_FAILED_SWITCH                  (HI_S32)(0x804A001A)
+#define HI_ERR_TUNER_FAILED_DISEQC                  (HI_S32)(0x804A001B)
+#define HI_ERR_TUNER_FAILED_STANDBY                 (HI_S32)(0x804A001C)
+#define HI_ERR_TUNER_FAILED_WAKEUP                  (HI_S32)(0x804A001D)
+#define HI_ERR_TUNER_FAILED_DISABLE                 (HI_S32)(0x804A001E)
+#define HI_ERR_TUNER_FAILED_ENABLE                  (HI_S32)(0x804A001F)
+#define HI_ERR_TUNER_FAILED_SETPLPID                (HI_S32)(0x804A0020)
+#define HI_ERR_TUNER_FAILED_GETPLPNUM               (HI_S32)(0x804A0021)
+#define HI_ERR_TUNER_FAILED_GETPLPTYPE              (HI_S32)(0x804A0022)
+#define HI_ERR_TUNER_FAILED_SETTSOUT                (HI_S32)(0x804A0023)
+#define HI_ERR_TUNER_FAILED_SETSATATTR              (HI_S32)(0x804A0024)
+#define HI_ERR_TUNER_FAILED_SAMPLEDATA              (HI_S32)(0x804A0025)
+#define HI_ERR_TUNER_FAILED_SETTERATTR              (HI_S32)(0x804A0026)
+#define HI_ERR_TUNER_FAILED_SETSTEP                 (HI_S32)(0x804A0027)
+#define HI_ERR_TUNER_FAILED_GETBANDRANGE            (HI_S32)(0x804A0028)
+#define HI_ERR_TUNER_FAILED_SETTOPADJUST            (HI_S32)(0x804A0029)
+#define HI_ERR_TUNER_FAILED_GETBAND                 (HI_S32)(0x804A002A)
+#define HI_ERR_TUNER_FAILED_GETTONE                 (HI_S32)(0x804A002B)
+#define HI_ERR_TUNER_FAILED_GETAGC                  (HI_S32)(0x804A002C)
+#define HI_ERR_TUNER_FAILED_TERSCANTIMEOUT          (HI_S32)(0x804A002D)
+#define HI_ERR_TUNER_FAILED_ALLOC_MEM               (HI_S32)(0x804A002E)
+#define HI_ERR_TUNER_FAILED_SETISIID                (HI_S32)(0x804A002F)
+#define HI_ERR_TUNER_FAILED_GETISIID                (HI_S32)(0x804A0030)
+#define HI_ERR_TUNER_FAILED_GETTOTALISI             (HI_S32)(0x804A0031)
+#define HI_ERR_TUNER_FAILED_MONITORISDBTLAYER       (HI_S32)(0x804A0032)
+#define HI_ERR_TUNER_INVALID_SIGTYPE                (HI_S32)(0x804A0033)
+#define HI_ERR_TUNER_INVALID_DEMODTYPE              (HI_S32)(0x804A0034)
+#define HI_ERR_TUNER_INVALID_TUNERTYPE              (HI_S32)(0x804A0035)
+#define HI_ERR_TUNER_INVALID_FREQUENCY              (HI_S32)(0x804A0036)
+#define HI_ERR_TUNER_INVALID_SYMBOLRATE             (HI_S32)(0x804A0037)
+#define HI_ERR_TUNER_INVALID_FUNCTION               (HI_S32)(0x804A0038)
+#define HI_ERR_TUNER_DISEQC_BUSY                    (HI_S32)(0x804A0039)
+#define HI_ERR_TUNER_DISEQC_POST_LISTEN             (HI_S32)(0x804A003A)
+#define HI_ERR_TUNER_DISEQC_RECV_LENGTH             (HI_S32)(0x804A003B)
+#define HI_ERR_TUNER_DISEQC_RECV_TIMEOUT            (HI_S32)(0x804A003C)
+#define HI_ERR_TUNER_DISEQC_RECV_STATE              (HI_S32)(0x804A003D)
+#define HI_ERR_TUNER_BLINDSAN_TPVERIFY              (HI_S32)(0x804A003E)
+#define HI_ERR_TUNER_MCU_DOWNLOAD                   (HI_S32)(0x804A003F)
+#define HI_ERR_TUNER_CATCH_TIMEOUT                  (HI_S32)(0x804A0040)
+#define HI_ERR_TUNER_SECURE_CHECK                   (HI_S32)(0x804A0041)
+
+#define HI_ERR_KEYLED_NOT_INIT                      (HI_S32)(0x804B0001)
+#define HI_ERR_KEYLED_INVALID_PARA                  (HI_S32)(0x804B0002)
+#define HI_ERR_KEYLED_NULL_PTR                      (HI_S32)(0x804B0003)
+#define HI_ERR_KEYLED_NO_NEW_KEY                    (HI_S32)(0x804B0004)
+#define HI_ERR_KEYLED_TIMEOUT                       (HI_S32)(0x804B0005)
+#define HI_ERR_KEYLED_FAILED_SETMODE                (HI_S32)(0x804B0006)
+#define HI_ERR_KEYLED_FAILED_DISPLAY                (HI_S32)(0x804B0007)
+
+
+#define HI_ERR_E2PROM_OPEN_ERR                      (HI_S32)(0x804C0001)
+#define HI_ERR_E2PROM_CLOSE_ERR                     (HI_S32)(0x804C0002)
+#define HI_ERR_E2PROM_NOT_INIT                      (HI_S32)(0x804C0003)
+#define HI_ERR_E2PROM_INVALID_PARA                  (HI_S32)(0x804C0004)
+#define HI_ERR_E2PROM_NULL_PTR                      (HI_S32)(0x804C0005)
+#define HI_ERR_E2PROM_COPY_DATA_ERR                 (HI_S32)(0x804C0006)
+#define HI_ERR_E2PROM_MALLOC_ERR                    (HI_S32)(0x804C0007)
+
+
+#define  HI_ERR_CIPHER_NOT_INIT                     (HI_S32)(0x804D0001)
+#define  HI_ERR_CIPHER_INVALID_HANDLE               (HI_S32)(0x804D0002)
+#define  HI_ERR_CIPHER_INVALID_POINT                (HI_S32)(0x804D0003)
+#define  HI_ERR_CIPHER_INVALID_PARA                 (HI_S32)(0x804D0004)
+#define  HI_ERR_CIPHER_FAILED_INIT                  (HI_S32)(0x804D0005)
+#define  HI_ERR_CIPHER_FAILED_GETHANDLE             (HI_S32)(0x804D0006)
+#define  HI_ERR_CIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x804D0007)
+#define  HI_ERR_CIPHER_FAILED_CONFIGAES             (HI_S32)(0x804D0008)
+#define  HI_ERR_CIPHER_FAILED_CONFIGDES             (HI_S32)(0x804D0009)
+#define  HI_ERR_CIPHER_FAILED_ENCRYPT               (HI_S32)(0x804D000A)
+#define  HI_ERR_CIPHER_FAILED_DECRYPT               (HI_S32)(0x804D000B)
+#define  HI_ERR_CIPHER_BUSY                         (HI_S32)(0x804D000C)
+#define  HI_ERR_CIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x804D000D)
+#define  HI_ERR_CIPHER_FAILED_MEM                   (HI_S32)(0x804D000E)
+#define  HI_ERR_CIPHER_UNAVAILABLE                  (HI_S32)(0x804D000F)
+#define  HI_ERR_CIPHER_OVERFLOW                     (HI_S32)(0x804D0010)
+#define  HI_ERR_CIPHER_HARD_STATUS                  (HI_S32)(0x804D0011)
+#define  HI_ERR_CIPHER_TIMEOUT                      (HI_S32)(0x804D0012)
+#define  HI_ERR_CIPHER_UNSUPPORTED                  (HI_S32)(0x804D0013)
+#define  HI_ERR_CIPHER_REGISTER_IRQ                 (HI_S32)(0x804D0014)
+#define  HI_ERR_CIPHER_ILLEGAL_UUID                 (HI_S32)(0x804D0015)
+#define  HI_ERR_CIPHER_ILLEGAL_KEY                  (HI_S32)(0x804D0016)
+#define  HI_ERR_CIPHER_INVALID_ADDR                 (HI_S32)(0x804D0017)
+#define  HI_ERR_CIPHER_INVALID_LENGTH               (HI_S32)(0x804D0018)
+#define  HI_ERR_CIPHER_ILLEGAL_DATA                 (HI_S32)(0x804D0019)
+#define  HI_ERR_CIPHER_RSA_SIGN                     (HI_S32)(0x804D001A)
+#define  HI_ERR_CIPHER_RSA_VERIFY                   (HI_S32)(0x804D001B)
+
+#define  HI_ERR_CA_OPEN_ERR                         (HI_S32)(0x804E0001)
+#define  HI_ERR_CA_CLOSE_ERR                        (HI_S32)(0x804E0002)
+#define  HI_ERR_CA_NOT_INIT                         (HI_S32)(0x804E0003)
+#define  HI_ERR_CA_COPY_DATA_ERR                    (HI_S32)(0x804E0004)
+#define  HI_ERR_CA_INVALID_PARA                     (HI_S32)(0x804E0005)
+#define  HI_ERR_CA_WAIT_TIMEOUT                     (HI_S32)(0x804E0006)
+#define  HI_ERR_CA_CW_DECRYPT                       (HI_S32)(0x804E0007)
+#define  HI_ERR_CA_R2R_DECRYPT                      (HI_S32)(0x804E0008)
+#define  HI_ERR_CA_R2R_ENCRYPT                      (HI_S32)(0x804E0009)
+#define  HI_ERR_CA_SETPARAM_AGAIN                   (HI_S32)(0x804E000A)
+#define  HI_ERR_CA_DBG_INERR                        (HI_S32)(0x804E000B)
+#define  HI_ERR_CA_NOT_CONFIG                       (HI_S32)(0x804E000C)
+#define  HI_ERR_CA_LPK_DECRYPT                      (HI_S32)(0x804E000D)
+#define  HI_ERR_CA_NOT_SUPPORT                      (HI_S32)(0x804E000E)
+#define  HI_ERR_CA_SWPK_ENCRYPT                     (HI_S32)(0x804E000F)
+#define  HI_ERR_CA_NO_MEMORY                        (HI_S32)(0x804E0011)
+#define  HI_ERR_CA_PTR_NULL                         (HI_S32)(0x804E0012)
+#define  HI_ERR_CA_GETSEMA_ERR                      (HI_S32)(0x804E0013)
+#define  HI_ERR_CA_NO_RESOURCE                      (HI_S32)(0x804E0014)
+#define  HI_ERR_CA_NOT_FIND_CA                      (HI_S32)(0x804E0016)
+#define  HI_ERR_CA_NOT_FIND_KLAD                    (HI_S32)(0x804E0017)
+#define  HI_ERR_CA_NOT_FIND_SESSION                 (HI_S32)(0x804E0018)
+#define  HI_ERR_CA_NOT_SET                          (HI_S32)(0x804E0019)
+#define  HI_ERR_CA_ALREADY_SET                      (HI_S32)(0x804E001A)
+#define  HI_ERR_CA_NOT_FIND_CALLBACK                (HI_S32)(0x804E001B)
+#define  HI_ERR_CA_KEY_NOT_READDY                   (HI_S32)(0x804E001C)
+
+
+#define  HI_ERR_PM_COPY_DATA_ERR                    (HI_S32)(0x804F0001)
+#define  HI_ERR_PM_INVALID_PARAM                    (HI_S32)(0x804F0002)
+
+#define  HI_ERR_CI_NOT_INIT                         (HI_S32)(0x80500001)
+#define  HI_ERR_CI_OPEN_ERR                         (HI_S32)(0x80500002)
+#define  HI_ERR_CI_CLOSE_ERR                        (HI_S32)(0x80500003)
+#define  HI_ERR_CI_INVALID_PARA                     (HI_S32)(0x80500004)
+#define  HI_ERR_CI_NO_MEMORY                        (HI_S32)(0x80500005)
+#define  HI_ERR_CI_TIMEOUT                          (HI_S32)(0x80500006)
+#define  HI_ERR_CI_REG_READ_ERR                     (HI_S32)(0x80500007)
+#define  HI_ERR_CI_REG_WRITE_ERR                    (HI_S32)(0x80500008)
+#define  HI_ERR_CI_IO_READ_ERR                      (HI_S32)(0x80500009)
+#define  HI_ERR_CI_IO_WRITE_ERR                     (HI_S32)(0x8050000A)
+#define  HI_ERR_CI_ATTR_READ_ERR                    (HI_S32)(0x8050000B)
+#define  HI_ERR_CI_ATTR_WRITE_ERR                   (HI_S32)(0x8050000C)
+#define  HI_ERR_CI_CANNOT_POWEROFF                  (HI_S32)(0x8050000D)
+#define  HI_ERR_CI_PCCD_DEVICE_BUSY                 (HI_S32)(0x8050000E)
+#define  HI_ERR_CI_PCCD_CIS_READ                    (HI_S32)(0x8050000F)
+#define  HI_ERR_CI_UNSUPPORT                        (HI_S32)(0x80500010)
+#define  HI_ERR_CI_UNKONWN                          (HI_S32)(0x80500011)
+#define  HI_ERR_CI_DETECT_ERR                       (HI_S32)(0x80500012)
+
+#define HI_ERR_PWM_DEV_NOT_EXIST                    (HI_S32)(0x80510001)
+#define HI_ERR_PWM_NOT_INIT                         (HI_S32)(0x80510002)
+#define HI_ERR_PWM_OPEN_ERR                         (HI_S32)(0x80510003)
+#define HI_ERR_PWM_CLOSE_ERR                        (HI_S32)(0x80510004)
+#define HI_ERR_PWM_INVALID_PARA                     (HI_S32)(0x80510005)
+#define HI_ERR_PWM_INVALID_OPT                      (HI_S32)(0x80510006)
+#define HI_ERR_PWM_UNSUPPORT                        (HI_S32)(0x80510007)
+
+#define HI_ERR_PDM_DEV_NOT_EXIST                    (HI_S32)(0x80520001)
+#define HI_ERR_PDM_NOT_DEVICE                       (HI_S32)(0x80520002)
+#define HI_ERR_PDM_DEV_OPEN_ERR                     (HI_S32)(0x80520003)
+#define HI_ERR_PDM_DEV_NOT_INIT                     (HI_S32)(0x80520004)
+#define HI_ERR_PDM_PTR_NULL                         (HI_S32)(0x80520005)
+#define HI_ERR_PDM_PARAM_INVALID                    (HI_S32)(0x80520006)
+#define HI_ERR_PDM_GET_MTDINFO_ERR                  (HI_S32)(0x80520007)
+#define HI_ERR_PDM_MTD_OPEN                         (HI_S32)(0x80520008)
+#define HI_ERR_PDM_MTD_CLOSE                        (HI_S32)(0x80520009)
+#define HI_ERR_PDM_MTD_READ                         (HI_S32)(0x80520010)
+#define HI_ERR_PDM_MTD_WRITE                        (HI_S32)(0x80520011)
+#define HI_ERR_PDM_MTD_GETINFO                      (HI_S32)(0x80520012)
+#define HI_ERR_PDM_MTD_ERASE                        (HI_S32)(0x80520013)
+#define HI_ERR_PDM_MEM_ALLC                         (HI_S32)(0x80520014)
+#define HI_ERR_PDM_INVALID_OPT                      (HI_S32)(0x80520015)
+#define HI_ERR_PDM_GET_DEVINFO_ERR                  (HI_S32)(0x80520016)
+
+#define  HI_ERR_LSADC_INVALID_PARA                   (HI_S32)(0x80520004)
+#define  HI_ERR_LSADC_FAILED_INIT                    (HI_S32)(0x80520005)
+
+#define HI_ERR_UART_OPENED                           (HI_S32)(0x80530000)
+#define HI_ERR_UART_NOT_OPEN                         (HI_S32)(0x80530001)
+#define HI_ERR_UART_BUFF                             (HI_S32)(0x80530002)
+#define HI_ERR_UART_OPEN                             (HI_S32)(0x80530003)
+#define HI_ERR_UART_MAP                              (HI_S32)(0x80530004)
+#define HI_ERR_UART_UNMAP                            (HI_S32)(0x80530005)
+#define HI_ERR_UART_CLOSE                            (HI_S32)(0x80530006)
+#define HI_ERR_UART_DEVICE                           (HI_S32)(0x80530007)
+#define HI_ERR_UART_CREATE_THREAD                    (HI_S32)(0x80530008)
+#define HI_ERR_UART_THREAD_JOIN                      (HI_S32)(0x80530009)
+#define HI_ERR_UART_SET_ATTR                         (HI_S32)(0x8053000a)
+#define HI_ERR_UART_GET_ATTR                         (HI_S32)(0x8053000b)
+#define HI_ERR_UART_SPEED                            (HI_S32)(0x8053000c)
+#define HI_ERR_UART_IOSPEED                          (HI_S32)(0x8053000d)
+#define HI_ERR_UART_DATABITS                         (HI_S32)(0x8053000e)
+#define HI_ERR_UART_PARITY                           (HI_S32)(0x8053000f)
+#define HI_ERR_UART_STOPBITS                         (HI_S32)(0x80530010)
+#define HI_ERR_UART_WRITE                            (HI_S32)(0x80530011)
+#define HI_ERR_UART_GEN                              (HI_S32)(0x80530012)
+
+#define HI_ERR_PQ_DEV_NOT_EXIST                     (HI_S32)(0x80600001)
+#define HI_ERR_PQ_NOT_DEV_FILE                      (HI_S32)(0x80600002)
+#define HI_ERR_PQ_DEV_OPEN_ERR                      (HI_S32)(0x80600003)
+#define HI_ERR_PQ_DEV_CLOSE_ERR                     (HI_S32)(0x80600004)
+#define HI_ERR_PQ_NULL_PTR                          (HI_S32)(0x80600005)
+#define HI_ERR_PQ_NO_INIT                           (HI_S32)(0x80600006)
+#define HI_ERR_PQ_INVALID_PARA                      (HI_S32)(0x80600007)
+#define HI_ERR_PQ_PARAM_NOT_BURN                    (HI_S32)(0x80600008)
+
+#define HI_ERR_SPI_OPEN_ERR                         (HI_S32)(0x80700001)
+#define HI_ERR_SPI_CLOSE_ERR                        (HI_S32)(0x80700002)
+#define HI_ERR_SPI_NOT_INIT                         (HI_S32)(0x80700003)
+#define HI_ERR_SPI_INVALID_PARA                     (HI_S32)(0x80700004)
+#define HI_ERR_SPI_NULL_PTR                         (HI_S32)(0x80700005)
+#define HI_ERR_SPI_COPY_DATA_ERR                    (HI_S32)(0x80700006)
+#define HI_ERR_SPI_MALLOC_ERR                       (HI_S32)(0x80700007)
+#define HI_ERR_SPI_WRITE_TIMEOUT                    (HI_S32)(0x80700008)
+#define HI_ERR_SPI_READ_TIMEOUT                     (HI_S32)(0x80700009)
+
+#define  HI_ERR_PLCIPHER_NOT_INIT                     (HI_S32)(0x808D0001)
+#define  HI_ERR_PLCIPHER_INVALID_HANDLE               (HI_S32)(0x808D0002)
+#define  HI_ERR_PLCIPHER_INVALID_PTR                (HI_S32)(0x808D0003)
+#define  HI_ERR_PLCIPHER_INVALID_PARA                 (HI_S32)(0x808D0004)
+#define  HI_ERR_PLCIPHER_FAILED_INIT                  (HI_S32)(0x808D0005)
+#define  HI_ERR_PLCIPHER_FAILED_GETHANDLE             (HI_S32)(0x808D0006)
+#define  HI_ERR_PLCIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x808D0007)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGAES             (HI_S32)(0x808D0008)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGDES             (HI_S32)(0x808D0009)
+#define  HI_ERR_PLCIPHER_FAILED_ENCRYPT               (HI_S32)(0x808D000A)
+#define  HI_ERR_PLCIPHER_FAILED_DECRYPT               (HI_S32)(0x808D000B)
+#define  HI_ERR_PLCIPHER_BUSY                         (HI_S32)(0x808D000C)
+#define  HI_ERR_PLCIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x808D000D)
+
+#define  HI_ERR_OTP_NOT_INIT                      (HI_S32)(0x808F0001)
+#define  HI_ERR_OTP_NOT_SUPPORT_INTERFACE         (HI_S32)(0x808F0002)
+#define  HI_ERR_OTP_INVALID_PARA                  (HI_S32)(0x808F0003)
+#define  HI_ERR_OTP_PTR_NULL                      (HI_S32)(0x808F0004)
+#define  HI_ERR_OTP_CHECK_FAILED                  (HI_S32)(0x808F0005)
+#define  HI_ERR_OTP_SYSCALL_FAILED                (HI_S32)(0x808F0006)
+#define  HI_ERR_OTP_MALLOC_ERR                    (HI_S32)(0x808F0007)
+#define  HI_ERR_OTP_NOT_FOUND                     (HI_S32)(0x808F0008)
+#define  HI_ERR_OTP_NOT_SUPPORT                   (HI_S32)(0x808F0009)
+#define  HI_ERR_OTP_MEM_MAP                       (HI_U32)(0x808F0010)
+#define  HI_ERR_OTP_NOT_INITRDY                   (HI_U32)(0x808F0011)
+#define  HI_ERR_OTP_READABLE_FUSE_VERIFY          (HI_U32)(0x808F0012)
+#define  HI_ERR_OTP_TIMEOUT                       (HI_U32)(0x808F0013)
+#define  HI_ERR_OTP_PROG_PERM                     (HI_U32)(0x808F0017)
+#define  HI_ERR_OTP_FAIL_PRMRD                    (HI_U32)(0x808F0018)
+#define  HI_ERR_OTP_FAIL_RD                       (HI_U32)(0x808F0019)
+#define  HI_ERR_OTP_DISABLE_PROG                  (HI_U32)(0x808F001a)
+#define  HI_ERR_OTP_FULL_VERSION                  (HI_U32)(0x808F001b)
+#define  HI_ERR_OTP_FAILED_CHECKVERSION           (HI_U32)(0x808F001c)
+#define  HI_ERR_OTP_FAILED_AUTH                   (HI_U32)(0x808F001d)
+#define  HI_ERR_OTP_TAID_SETED                    (HI_U32)(0x808F001f)
+#define  HI_ERR_OTP_INVALID_TAID                  (HI_U32)(0x808F0020)
+#define  HI_ERR_OTP_DUPLICATE_TAID                (HI_U32)(0x808F0021)
+#define  HI_ERR_OTP_NO_AVAILABLE_INDEX            (HI_U32)(0x808F0022)
+#define  HI_ERR_OTP_FUSE_LOCKED                   (HI_U32)(0x808F0023)
+#define  HI_ERR_OTP_DATA_BUILD_FAILED             (HI_U32)(0x808F0024)
+#define  HI_ERR_OTP_DATA_VERIFY_FAILED            (HI_U32)(0x808F0025)
+#define  HI_ERR_OTP_DATA_VERIFY_NULL              (HI_U32)(0x808F0026)
+#define  HI_ERR_OTP_SEC_FAILED                    (HI_U32)(0x808F0027)
+
+#define HI_ERR_SM_NULL_PTR                        (HI_S32)(0x80900001)
+#define HI_ERR_SM_NO_SESSION_FOUND                (HI_S32)(0x80900002)
+#define HI_ERR_SM_INVALID_HANDLE                  (HI_S32)(0x80900003)
+#define HI_ERR_SM_INVALID_INTENT                  (HI_S32)(0x80900004)
+#define HI_ERR_SM_INVALID_MODULEID                (HI_S32)(0x80900006)
+#define HI_ERR_SM_NO_MEMORY                       (HI_S32)(0x80900007)
+#define HI_ERR_SM_INVALID_LINKRULES               (HI_S32)(0x80900008)
+#define HI_ERR_SM_INVALID_INTENTRULES             (HI_S32)(0x80900009)
+#define HI_ERR_SM_NO_HANDLE_ADD                   (HI_S32)(0x8090000a)
+#define HI_ERR_SM_CONFLICT_SET                    (HI_S32)(0x8090000b)
+#define HI_ERR_SM_NOT_SUPPORT                     (HI_S32)(0x8090000c)
+#define HI_ERR_SM_INVALID_CMD                     (HI_S32)(0x8090000d)
+#define HI_ERR_SM_INVALID_SIZE                    (HI_S32)(0x8090000e)
+#define HI_ERR_SM_INVALID_ACCESS                  (HI_S32)(0x8090000f)
+#define HI_ERR_SM_INVALID_RESOURCE_NUM            (HI_S32)(0x80900010)
+
+#define HI_ERR_KLAD_NOT_INIT                      HI_ERRCODE_DEF(HI_ID_CA, 0x0001)
+#define HI_ERR_KLAD_NULL_PTR                      HI_ERRCODE_DEF(HI_ID_CA, 0x0002)
+#define HI_ERR_KLAD_INVALID_HANDLE                HI_ERRCODE_DEF(HI_ID_CA, 0x0003)
+#define HI_ERR_KLAD_INVALID_ALG                   HI_ERRCODE_DEF(HI_ID_CA, 0x0004)
+#define HI_ERR_KLAD_INVALID_TARGET                HI_ERRCODE_DEF(HI_ID_CA, 0x0005)
+#define HI_ERR_KLAD_INVALID_TARGETADDR            HI_ERRCODE_DEF(HI_ID_CA, 0x0006)
+#define HI_ERR_KLAD_NO_MEMORY                     HI_ERRCODE_DEF(HI_ID_CA, 0x0007)
+#define HI_ERR_KLAD_WAIT_TIMEOUT                  HI_ERRCODE_DEF(HI_ID_CA, 0x0008)
+#define HI_ERR_KLAD_NOT_FIND_KLAD                 HI_ERRCODE_DEF(HI_ID_CA, 0x0009)
+#define HI_ERR_KLAD_NOT_FIND_SESSION              HI_ERRCODE_DEF(HI_ID_CA, 0x000a)
+#define HI_ERR_KLAD_NOT_SET_ATTR                  HI_ERRCODE_DEF(HI_ID_CA, 0x000b)
+#define HI_ERR_KLAD_NOT_FIND_CALLBACK             HI_ERRCODE_DEF(HI_ID_CA, 0x000c)
+#define HI_ERR_KLAD_KEY_NOT_READY                 HI_ERRCODE_DEF(HI_ID_CA, 0x000d)
+#define HI_ERR_KLAD_ALREADY_SETATTR               HI_ERRCODE_DEF(HI_ID_CA, 0x000e)
+#define HI_ERR_KLAD_NOT_SET_SESSIONKEY            HI_ERRCODE_DEF(HI_ID_CA, 0x000f)
+#define HI_ERR_KLAD_NOT_SET_CONTENTKEY            HI_ERRCODE_DEF(HI_ID_CA, 0x0010)
+#define HI_ERR_KLAD_ALREADY_SETTARGET             HI_ERRCODE_DEF(HI_ID_CA, 0x0011)
+#define HI_ERR_KLAD_NOT_SETTARGET                 HI_ERRCODE_DEF(HI_ID_CA, 0x0012)
+#define HI_ERR_KLAD_DETACH_ERRTARGET              HI_ERRCODE_DEF(HI_ID_CA, 0x0013)
+#define HI_ERR_KLAD_INVALID_LEVEL                 HI_ERRCODE_DEF(HI_ID_CA, 0x0014)
+#define HI_ERR_KLAD_UNAVAILABLE_TARGET            HI_ERRCODE_DEF(HI_ID_CA, 0x0015)
+#define HI_ERR_KLAD_FAILED_SETIV                  HI_ERRCODE_DEF(HI_ID_CA, 0x0016)
+#define HI_ERR_KLAD_INVALID_ENGINE                HI_ERRCODE_DEF(HI_ID_CA, 0x0017)
+#define HI_ERR_KLAD_INVALID_EVENORODD             HI_ERRCODE_DEF(HI_ID_CA, 0x0018)
+#define HI_ERR_KLAD_NOT_SUPPORT                   HI_ERRCODE_DEF(HI_ID_CA, 0x0019)
+#define HI_ERR_KLAD_INVALID_IVLENGTH              HI_ERRCODE_DEF(HI_ID_CA, 0x001a)
+#define HI_ERR_KLAD_NO_RESOURCE                   HI_ERRCODE_DEF(HI_ID_CA, 0x001b)
+#define HI_ERR_KLAD_UNKNOWN_CMD                   HI_ERRCODE_DEF(HI_ID_CA, 0x001c)
+#define HI_ERR_KLAD_OPEN_ERR                      HI_ERRCODE_DEF(HI_ID_CA, 0x001d)
+#define HI_ERR_KLAD_INVALID_PARAM                 HI_ERRCODE_DEF(HI_ID_CA, 0x001e)
+#define HI_ERR_KLAD_TASK_ID_MISMATCH              HI_ERRCODE_DEF(HI_ID_CA, 0x001f)
+#define HI_ERR_KLAD_MUTEX                         HI_ERRCODE_DEF(HI_ID_CA, 0x0020)
+
+#define HI_ERR_KLAD_CHECK_BASE                    HI_ERRCODE_DEF(HI_ID_CA, 0x0020)
+#define HI_ERR_KLAD_CHECK_OTP_CONFIG_DISABLE      HI_ERRCODE_DEF(HI_ID_CA, 0x0021)
+#define HI_ERR_KLAD_CHECK_LEVEL                   HI_ERRCODE_DEF(HI_ID_CA, 0x0022)
+#define HI_ERR_KLAD_CHECK_DSC_MODE                HI_ERRCODE_DEF(HI_ID_CA, 0x0023)
+#define HI_ERR_KLAD_CHECK_PORT                    HI_ERRCODE_DEF(HI_ID_CA, 0x0024)
+#define HI_ERR_KLAD_CHECK_ROOTKEY_NOT_READY       HI_ERRCODE_DEF(HI_ID_CA, 0x0025)
+#define HI_ERR_KLAD_CHECK_LEVEL1_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0026)
+#define HI_ERR_KLAD_CHECK_LEVEL2_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0027)
+#define HI_ERR_KLAD_CHECK_LEVEL3_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0028)
+#define HI_ERR_KLAD_CHECK_LEVEL4_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0029)
+#define HI_ERR_KLAD_CHECK_LEVEL5_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x002a)
+#define HI_ERR_KLAD_CHECK_DCAS_PROFILE            HI_ERRCODE_DEF(HI_ID_CA, 0x002b)
+#define HI_ERR_KLAD_CHECK_TDES_KEY                HI_ERRCODE_DEF(HI_ID_CA, 0x002c)
+#define HI_ERR_KLAD_CHECK_C2_TA_HASH              HI_ERRCODE_DEF(HI_ID_CA, 0x002d)
+#define HI_ERR_KLAD_CHECK_CLEAR_CW_CONFIG         HI_ERRCODE_DEF(HI_ID_CA, 0x002e)
+#define HI_ERR_KLAD_CHECK_CW                      HI_ERRCODE_DEF(HI_ID_CA, 0x0032)
+#define HI_ERR_KLAD_CHECK_TEE_ENABLE              HI_ERRCODE_DEF(HI_ID_CA, 0x0034)
+#define HI_ERR_KLAD_SECURE_ATTR_UINIT             HI_ERRCODE_DEF(HI_ID_CA, 0x0035)
+#define HI_ERR_KLAD_REQUIRE_IRQ_FAILED            HI_ERRCODE_DEF(HI_ID_CA, 0x0036)
+#define HI_ERR_KLAD_SEC_FAILED                    HI_ERRCODE_DEF(HI_ID_CA, 0x0037)
+
+#define HI_ERR_CERT_NOT_INIT                      HI_ERRCODE_DEF(HI_ID_CERT, 0x0101)
+#define HI_ERR_CERT_INVALID_HANDLE                HI_ERRCODE_DEF(HI_ID_CERT, 0x0102)
+#define HI_ERR_CERT_INVALID_PTR                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0103)
+#define HI_ERR_CERT_INVALID_PARA                  HI_ERRCODE_DEF(HI_ID_CERT, 0x0104)
+#define HI_ERR_CERT_FAILED_INIT                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0105)
+#define HI_ERR_CERT_UNEXPECTED_STA                HI_ERRCODE_DEF(HI_ID_CERT, 0x0106)
+#define HI_ERR_CERT_UNEXPECTED_EMI                HI_ERRCODE_DEF(HI_ID_CERT, 0x0107)
+#define HI_ERR_CERT_KEY_INVALID                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0108)
+#define HI_ERR_CERT_TIMEOUT                       HI_ERRCODE_DEF(HI_ID_CERT, 0x0109)
+#define HI_ERR_CERT_LOCKED                        HI_ERRCODE_DEF(HI_ID_CERT, 0x010A)
+#define HI_ERR_CERT_UNLOCKED                      HI_ERRCODE_DEF(HI_ID_CERT, 0x010B)
+#define HI_ERR_CERT_UNEXPECTED_CW                 HI_ERRCODE_DEF(HI_ID_CERT, 0x010C)
+#define HI_ERR_CERT_MUTEX_ERR                     HI_ERRCODE_DEF(HI_ID_CERT, 0x010D)
+#define HI_ERR_CERT_LOCK_STA_ERR                  HI_ERRCODE_DEF(HI_ID_CERT, 0x010E)
+#define HI_ERR_CERT_DBG_ALG_ERR                   HI_ERRCODE_DEF(HI_ID_CERT, 0x010F)
+#define HI_ERR_CERT_DBG_PRT_SEL_ERR               HI_ERRCODE_DEF(HI_ID_CERT, 0x0110)
+#define HI_ERR_CERT_DBG_USAGE_ERR                 HI_ERRCODE_DEF(HI_ID_CERT, 0x0111)
+#define HI_ERR_CERT_DBG_OTHER_ERR                 HI_ERRCODE_DEF(HI_ID_CERT, 0x0112)
+#define HI_ERR_CERT_UNKNOWN_CMD                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0113)
+#define HI_ERR_CERT_UNEXPECTED_PORT               HI_ERRCODE_DEF(HI_ID_CERT, 0x0114)
+#define HI_ERR_CERT_REQUIRE_IRQ_FAILED            HI_ERRCODE_DEF(HI_ID_CERT, 0x0115)
+#define HI_ERR_CERT_PV_ACTIVATE                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0116)
+
+#define HI_ERR_MAILBOX_NOT_INIT                   HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0001)
+#define HI_ERR_MAILBOX_INVALID_HANDLE             HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0002)
+#define HI_ERR_MAILBOX_INVALID_PTR                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0003)
+#define HI_ERR_MAILBOX_INVALID_PARA               HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0004)
+#define HI_ERR_MAILBOX_INVALID_FLAG               HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0005)
+#define HI_ERR_MAILBOX_INVALID_RECEIVER           HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0006)
+#define HI_ERR_MAILBOX_NO_MEMORY                  HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0007)
+#define HI_ERR_MAILBOX_NOT_SUPPORT                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0008)
+#define HI_ERR_MAILBOX_ERR_RECEIVE                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0009)
+#define HI_ERR_MAILBOX_UNEXPECTED_RECEIVE_LEN     HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000A)
+#define HI_ERR_MAILBOX_CRC_CHECK_ERROR            HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000B)
+#define HI_ERR_MAILBOX_UNKNOWN_CMD                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000C)
+#define HI_ERR_MAILBOX_NO_SESSION                 HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000D)
+#define HI_ERR_MAILBOX_TIMEOUT                    HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000E)
+#define HI_ERR_MAILBOX_UNKNOWN                    HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000F)
+
+#define HI_ERR_IFCP_NOT_SUPPORT                   HI_ERRCODE_DEF(HI_ID_IFCP, 0x0001)
+/** @} */  /*! <!-- Macro Definition end */
+
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+
+#endif /* End of #ifndef __HI_UNF_MPI_ERRORCODE_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_go.h b/xbmc/platform/linux/hisi/hi_go.h
new file mode 100644
index 0000000000..4535af8364
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go.h
@@ -0,0 +1,36 @@
+#ifndef __HI_GO_H__
+#define __HI_GO_H__
+
+#include "hi_type.h"
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+#include "hi_go_encoder.h"
+#include "hi_go_decoder.h"
+#include "hi_go_bliter.h"
+#include "hi_go_gdev.h"
+#include "hi_go_text.h"
+#include "hi_go_winc.h"
+#include "hi_go_cursor.h"
+#include "hi_go_errno.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+/*************************** Structure Definition ****************************/
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_bliter.h b/xbmc/platform/linux/hisi/hi_go_bliter.h
new file mode 100644
index 0000000000..2b88179515
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_bliter.h
@@ -0,0 +1,636 @@
+#ifndef __HI_GO_BLITER_H__
+#define __HI_GO_BLITER_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+
+/****************************** Error Number ********************************/
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_BLIT */
+/** @{ */  /** <!-- [HIGO_BLIT] */
+
+/** Pixel-level alpha blending operation*/
+/** CNcomment: alpha */
+typedef enum
+{
+    HIGO_COMPOPT_NONE = 0, /**<Porter/Duff None-blending operation*//**<CNcomment:Porter/Duff None */
+    HIGO_COMPOPT_CLEAR,    /**<Porter/Duff clear blending operation*//**<CNcomment:Porter/Duff clear */
+    HIGO_COMPOPT_SRC     , /**<Porter/Duff SRC blending operation*//**<CNcomment:Porter/Duff Src */
+    HIGO_COMPOPT_SRCOVER , /**<Porter/Duff Srcover blending operation*//**<CNcomment:Porter/Duff Srcover */
+    HIGO_COMPOPT_DSTOVER , /**<Porter/Duff DstOver blending operation*/ /**<CNcomment:Porter/Duff DstOver */
+    HIGO_COMPOPT_SRCIN   , /**<Porter/Duff SrcIn blending operation*//**<CNcomment:Porter/Duff SrcIn */
+    HIGO_COMPOPT_DSTIN   , /**<Porter/Duff DstIn blending operation*/ /**<CNcomment:Porter/Duff DstIn */
+    HIGO_COMPOPT_SRCOUT  , /**<Porter/Duff SrcOut blending operation*//**<CNcomment:Porter/Duff SrcOut */
+    HIGO_COMPOPT_DSTOUT  , /**<Porter/Duff DstOut blending operation*/ /** CNcomment:Porter/Duff DstOut */
+    HIGO_COMPOPT_SRCATOP , /**<Porter/Duff SrcAtop blending operation*/ /**<CNcomment:Porter/Duff SrcAtop */
+    HIGO_COMPOPT_DSTATOP , /**<Porter/Duff DstAtop blending operation*//**<CNcomment: Porter/Duff DstAtop */
+    HIGO_COMPOPT_ADD     ,  /**<Porter/Duff DstAtop blending operation*/ /**<CNcomment: Porter/Duff DstAtop */
+    HIGO_COMPOPT_XOR     , /**<Porter/Duff Xor blending operation*/ /**<CNcomment: Porter/Duff Xor */
+    HIGO_COMPOPT_DST     , /**<Porter/Duff DstAtop blending operation*/ /**<CNcomment: Porter/Duff DstAtop */
+    HIGO_COMPOPT_AKS,      /**<Assume that the destination surface is not transparent. After the alpha blending is performed, the source alpha is retained.*//**<CNcomment: surfacealphaalpha */
+    HIGO_COMPOPT_AKD,      /**<Assume that the destination surface is not transparent. After the alpha blending is performed, the destination alpha is retained.*//**<CNcomment: surfacealphaalpha */
+
+    HIGO_COMPOPT_BUTT
+} HIGO_COMPOPT_E;
+
+/** Operation mode corresponding to colorkey*//** CNcomment: Colorkey */
+typedef enum
+{
+    HIGO_CKEY_NONE = 0, /**<Do not use the colorkey.*//**<CNcomment: colorkey */
+    HIGO_CKEY_SRC,      /**<Use the source colorkey.*//**<CNcomment: colorkey */
+    HIGO_CKEY_DST,     /**<Use the destination colorkey.*//**<CNcomment: colorkey */
+
+    HIGO_CKEY_BUTT
+} HIGO_CKEY_E;
+
+/** Two raster of operations (ROPs)*//** CNcomment: 2ROP */
+typedef enum
+{
+    HIGO_ROP_BLACK = 0, /**< Blackness */
+    HIGO_ROP_PSDon,     /**< ~(PS+D) */
+    HIGO_ROP_PSDna,     /**< ~PS & D */
+    HIGO_ROP_PSn,       /**< ~PS */
+    HIGO_ROP_DPSna,     /**< PS & ~D */
+    HIGO_ROP_Dn,        /**< ~D */
+    HIGO_ROP_PSDx,      /**< PS^D */
+    HIGO_ROP_PSDan,     /**< ~(PS&D) */
+    HIGO_ROP_PSDa,      /**< PS & D */
+    HIGO_ROP_PSDxn,     /**< ~(PS^D) */
+    HIGO_ROP_D,         /**< D */
+    HIGO_ROP_PSDno,     /**< ~PS + D */
+    HIGO_ROP_PS,        /**< PS */
+    HIGO_ROP_DPSno,     /**< PS + ~D */
+    HIGO_ROP_PSDo,      /**< PS+D */
+    HIGO_ROP_WHITE,     /**< Whiteness */
+
+    HIGO_ROP_BUTT
+} HIGO_ROP_E;
+
+typedef enum
+{
+    HIGO_ROTATE_NONE = 0,
+    HIGO_ROTATE_90,     /**<Rotate 90 degrees clockwise*//**<CNcomment: 90 */
+    HIGO_ROTATE_180,    /**<Rotate 180 degrees clockwise*//**<CNcomment: 180 */
+    HIGO_ROTATE_270,    /**<Rotate 270 degrees clockwise*//**<CNcomment: 270 */
+
+    HIGO_ROTATE_BUTT
+} HIGO_ROTATE_E;
+
+typedef enum
+{
+    HIGO_MIRROR_NONE = 0,
+
+    HIGO_MIRROR_LR,     /**<Mirror the left and the right*//**<CNcomment:  */
+    HIGO_MIRROR_TB,     /**<Mirror the top and the bottom*//**<CNcomment:  */
+
+    HIGO_MIRROR_BUTT
+} HIGO_MIRROR_E;
+
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag*//**<CNcomment: alpha */
+    HI_BOOL EnablePixelAlpha;       /**<Pixel alpha enable flag*//**<CNcomment: alpha */
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: alpha */
+    HIGO_CKEY_E    ColorKeyFrom;    /**<Colorkey operation*//**<CNcomment:ColorKey */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: ROP2 */
+    HIGO_ROP_E     Rop;              /**<ROP2 operation type*//**<CNcomment: ROP2 */
+    HIGO_ROP_E     RopAlpha;         /**<Type of the ROP alpha operation*//**<CNcomment: ROP alpha*/
+ }HIGO_BLTOPT2_S;
+
+/** CNcomment: blit */
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag. If this flag is enabled, the PixelAlphaComp blending mode must be specified.*//**<CNcomment: alpha,PixelAlphaComp*/
+    HI_BOOL EnablePixelAlpha;       /**<Pixel alpha enable flag*//**<CNcomment: alpha */
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: alpha */
+    HIGO_CKEY_E    ColorKeyFrom;    /**<colorkey operation*//**<CNcomment: ColorKey */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: ROP2 */
+    HIGO_ROP_E     Rop;             /**<ROP2 operation type*//**<CNcomment: ROP2 */
+    HIGO_ROP_E     RopAlpha;        /**<Type of the ROP alpha operation*/    /**<CNcomment: ROP alpha*/
+    HI_BOOL        EnableScale;      /**<Enable the scaling function*//**<CNcomment:  */
+    HIGO_ROTATE_E  RotateType;      /**<Rotation type*//**<CNcomment:  */
+    HIGO_MIRROR_E  MirrorType;      /**<Mirror type*//**<CNcomment:  */
+} HIGO_BLTOPT_S;
+
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag*//**<CNcomment: alpha */
+
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: alpha */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: ROP2 */
+    HIGO_ROP_E     RopColor;        /**<ROP2 operation type*//**<CNcomment: ROP2 */
+	HIGO_ROP_E     RopAlpha;
+
+} HIGO_MASKOPT_S;
+
+/**Anti-flicker level*//** CNcomment:  */
+typedef enum
+{
+    HIGO_DEFLICKER_AUTO = 0, /*Anti-flicker level, ranging from low to high. The higher the level, the better the anti-flicker effect, but the more blurred the picture.*//** CNcomment:LOW~HIGH,*/
+    HIGO_DEFLICKER_LOW,
+    HIGO_DEFLICKER_MIDDLE,
+    HIGO_DEFLICKER_HIGH,
+    HIGO_DEFLICKER_BUTT
+}HIGO_DEFLICKEROPT_E;
+
+/**Anti-flicker level*//** CNcomment:  */
+typedef struct
+{
+    HIGO_DEFLICKEROPT_E DefLevel;
+}HIGO_DEFLICKEROPT_S;
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_BLIT */
+/** @{ */  /** <!-- HIGO_BLIT */
+
+/**
+\brief Initializes the Bliter module.CNcomment: Bliter CNend
+\attention \n
+When ::HI_GO_Init is called, this application programming interface (API) is also called.CNcomment: ::HI_GO_Init CNend
+\param  N/A.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitBliter
+*/
+HI_S32 HI_GO_InitBliter(HI_VOID);
+
+/**
+\brief Deinitializes the Bliter module.CNcomment:Bliter CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.CNcomment:::HI_GO_Deinit CNend
+\param N/A. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitBliter
+*/
+
+HI_S32 HI_GO_DeinitBliter(HI_VOID);
+
+/**
+\brief Fills in a rectangle.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] Surface Surface handle.CNcomment:Surface CNend
+\param[in] pRect Size of the rectangle to be filled in. If the parameter is not set, it indicates that the entire
+surface is filled in.CNcomment: surface CNend
+\param[in] Color Color Fill color. For the RGB format, 32-bit color is filled in; for the palette, the color index (0-255)
+is filled in.CNcomment:,RGB32(0 ~ 255)CNend
+\param[in] CompositeOpt Blending mode.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_OUTOFPAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_FillRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR Color, HIGO_COMPOPT_E CompositeOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, color space conversion (CSC), scaling, and rotation are supported.CNcomment: CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+Scaling, rotation, and mirror cannot be combined. \n
+For scaling, rotation, and mirror, the source and destination pixel formats must be the same, but the format cannot
+be YUV or CLUT.\n
+CNcomment:YUVRGB \n
+colorkeyalphaROPcolorkey+ROP\
+ \n
+YUVCLUT \n CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:surface CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:surface CNend
+\param[in] DstSurface Destination surface handle.CNcomment:surface CNend
+\param[in] pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:surface CNend
+\param[in] pBlitOpt Blending mode.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_Blit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                   HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                   const HIGO_BLTOPT_S* pBlitOpt);
+
+/**
+\brief Draws a line segment. Cropping is not supported.CNcomment: CNend
+\attention \n
+Cropping is not supported. Users must keep the entire line within the surface region.
+CNcomment:surface CNend
+
+\param[in] Surface Destination surface handle.CNcomment:surface CNend
+\param[in] x0 Horizontal coordinate of the start point.CNcomment:x CNend
+\param[in] y0 Vertical coordinate of the start point.CNcomment:y CNend
+\param[in] x1 Horizontal coordinate of the end point.CNcomment:x CNend
+\param[in] y1 Vertical coordinate of the end point .CNcomment:y CNend
+\param[in] color Line segment color.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_DrawLine(HI_HANDLE Surface, HI_S32 x0, HI_S32 y0, HI_S32 x1, HI_S32 y1, HI_COLOR color);
+
+/**
+\brief Draws an ellipse.CNcomment: CNend
+\attention \n
+Cropping is not supported. Users must keep the entire ellipse within the surface region.
+CNcomment:surface CNend
+
+\param[in] Surface Destination surface handle.CNcomment:surface CNend
+\param[in] sx Horizontal coordinate of the ellipse center.CNcomment:x CNend
+\param[in] sy Vertical coordinate of the ellipse center.CNcomment:y CNend
+\param[in] rx X axis radius .CNcomment:x CNend
+\param[in] ry Y axis radius.CNcomment:y CNend
+\param[in] color Ellipse color.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_DrawEllipse(HI_HANDLE Surface, HI_S32 sx, HI_S32 sy, HI_S32 rx, HI_S32 ry, HI_COLOR color);
+
+/**
+\brief Draws a circle. Cropping is not supported.CNcomment: CNend
+\attention \n
+Cropping is not supported. Users must keep the entire circle within the surface region.
+CNcomment:surface CNend
+
+\param[in] Surface Destination surface handle.CNcomment:surface CNend
+\param[in] x Horizontal coordinate of the circle center.CNcomment:x CNend
+\param[in] y Vertical coordinate of the circle center.CNcomment:y CNend
+\param[in] r Radius.CNcomment: CNend
+\param[in] color Circle color. The circle is filled in with 32-bit colors.CNcomment:, 32 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_DrawCircle(HI_HANDLE Surface, HI_S32 x, HI_S32 y, HI_S32 r, HI_COLOR color);
+
+/**
+\brief Draws a rectangle.CNcomment: CNend
+\attention \n
+If the rectangle is empty, it indicates that the rectangle size is the same as surface.
+Cropping is not supported; therefore, you must ensure that the entire rectangle is within the surface.
+CNcomment:surface
+surface CNend
+
+\param[in] Surface Destination surface handle.CNcomment:surface CNend
+\param[in] pRect Rectangle region.CNcomment: CNend
+\param[in] color Rectangle color.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_DrawRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR color);
+
+/**
+\brief Performs the mask ROP or mask blend transfer on the raster bitmap.CNcomment:Mask RopMask Blend CNend
+\attention \n
+The mask bitmap is in A1 or A8 format.
+You need to overlay the mask bitmap with the source bitmap, overlay the result with the destination bitmap, and then
+output the final result to the destination bitmap.
+If the ROP and blending operation are perform at the same time, only the ROP takes effect.
+CNcomment:MaskA1A8Surface
+Mask
+RopBlendRop CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:surface CNend
+\param[in] pSrcRect Source rectangle.CNcomment: CNend
+\param[in] DstSurface Destination surface handle.CNcomment:surface CNend
+\param[in] pDstRect Destination rectangle.CNcomment: CNend
+\param[in] MaskSurface Mask surface handle.CNcomment:MASK surface CNend
+\param[in] pMaskRect Mask rectangle.CNcomment:MASK CNend
+\param[in] pOpt Operation option.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVRECT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment: CNend
+*/
+
+HI_S32 HI_GO_MaskBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                      HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                      HI_HANDLE MaskSurface, const HI_RECT* pMaskRect,
+                      const HIGO_MASKOPT_S* pOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, CSC is supported.CNcomment: CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+CNcomment: YUVRGB \n
+colorkeyalphaROPcolorkey+ROP\ CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:surface CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:surface CNend
+\param[in] DstSurface Destination surface handle.CNcomment:surface CNend
+\param[in] pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:surface CNend
+\param[in] pBlitOpt Blending mode. If the parameter is not set, default settings are used. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_BitBlit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                       HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                       const HIGO_BLTOPT2_S* pBlitOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, CSC and scaling are supported. CNcomment:,  CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+CNcomment:YUVRGB \n
+colorkeyalphaROPcolorkey+ROP\ CNend
+
+\param[in] SrcSurface  Source surface handle. CNcomment:surface CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:surface CNend
+\param[in] DstSurface Destination surface handle. CNcomment:surface CNend
+\param[in] pDstRect pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface. CNcomment:surface CNend
+\param[in] pBlitOpt Blending mode. If the parameter is not set, default settings are used. CNcomment:, CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_StretchBlit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                       HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                       const HIGO_BLTOPT2_S* pBlitOpt);
+
+/**
+\brief  Fills in the pattern.CNcomment: CNend
+\attention \n
+\param[in] SrcSurface  Source surface handle. CNcomment:surface CNend
+\param[in] pSrcRect  Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:surface CNend
+\param[in] DstSurface  Destination surface handle. CNcomment:surface CNend
+\param[in] pDstRect  Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:surface CNend
+\param[in] pParOpt  Blending mode. If the parameter is not set, default settings are used. CNcomment:, CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_PatternBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                              HI_HANDLE DstSurface, const HI_RECT * pDstRect,
+                              const HIGO_BLTOPT2_S* pParOpt);
+
+/**
+\brief Performs anti-flicker and transfer. This API is used for the second anti-flicker.CNcomment:CNend
+\attention \n
+This API is used in the following two application scenarios:
+1. The automatic anti-flicker effect of a graphics layer is poor.
+2. The buffer mode of a graphics layer is single-buffer mode (HIGO_LAYER_BUFFER_SINGLE). In this case, users need to
+perform anti-flicker by themselves.
+When the sizes of the source bitmap and destination bitmap are different, scaling is performed automatically.
+CNcomment:
+1 
+2 bufferbuffer(HIGO_LAYER_BUFFER_SINGLE)
+CNend
+
+\param[in] SrcSurface  SrcSurface Source surface handle.CNcomment: surface CNend
+\param[in] pSrcRect  pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:surface CNend
+\param[in] DstSurface  DstSurface Destination surface handle. CNcomment:surface CNend
+\param[in] pDstRect  pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface. CNcomment:surface CNend
+\param[in] pDefOpt  pDefOpt Anti-flicker level. If this parameter is not set, it indicates the automatic level. CNcomment:AUTO  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_DeflickerBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                                 HI_HANDLE DstSurface, const HI_RECT * pDstRect,
+                                 const HIGO_DEFLICKEROPT_S* pDefOpt);
+
+/**
+\brief Do the alpha blending between the forground surface and the backgroud surface, transfers the result to the destination surface. The background surface and the destination surface must be in the RGB color space.
+You can performs color space coversion, scale, or mirror, colorkey with alpha blending.CNcomment:surfaceRGBCNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported, rotation is not supported.\
+Scaling, and mirror cannot be combined. \n
+For scaling, and mirror, the source and destination pixel formats must be the same, but the format cannot
+be YUV or CLUT.\n
+CNcomment:YUVRGB \n
+colorkeyalphaROPcolorkey+ROP\
+ \n
+YUVCLUT \n CNend
+
+\param[in] BckSurface background surface handle.CNcomment:surface CNend
+\param[in] pBckRect backgound region for transfer. If the parameter is not set, it indicates the entire background surface.CNcomment:surfacesurface CNend
+\param[in] ForSurface forground surface handle.CNcomment:surface CNend
+\param[in] pForRect forground region for transfer. If the parameter is not set, it indicates the entire forground surface.
+surface.CNcomment:surfacesurface CNend
+\param[in] DstSurface destination surface handle.CNcomment:surface CNend
+\param[in] pDstRect destination region for transfer. If the parameter is not set, it indicates the entire destination surface.
+surface.CNcomment:surface CNend
+\param[in] pBlitOpt Blending mode.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_Blit3Source(HI_HANDLE BckSurface, const HI_RECT* pBckRect,
+                   HI_HANDLE ForSurface, const HI_RECT* pForRect,
+                   HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                   const HIGO_BLTOPT_S* pBlitOpt);
+/**
+\brief Fills in a rounded rectangle.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] Surface Surface handle.CNcomment:Surface CNend
+\param[in] pRect Size of the rectangle to be filled in. If the parameter is not set, it indicates that the entire
+surface is filled in.CNcomment: surface CNend
+\param[in] Color Color Fill color. For the RGB format, 32-bit color is filled in; for the palette, the color index (0-255)
+is filled in.CNcomment:,RGB32(0 ~ 255)CNend
+\param[in] s32Radius radius.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_OUTOFPAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\see \n
+N/A. CNcomment: CNend
+*/
+
+HI_S32 HI_GO_FillRoundRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR Color, HI_S32 s32Radius);
+
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_BLITER_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_comm.h b/xbmc/platform/linux/hisi/hi_go_comm.h
new file mode 100644
index 0000000000..4dde8e5050
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_comm.h
@@ -0,0 +1,242 @@
+#ifndef __HI_GO_COMM_H__
+#define __HI_GO_COMM_H__
+
+#include "hi_type.h"
+#include "hi_go_errno.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_COMMON */
+/** @{ */  /**<![HIGO_COMMON] */
+
+/**Maximum number of colors in the palette*//** CNcomment:  */
+#define MAX_PALETTE_COLOR_SIZE 256
+
+/**Color value*//** CNcomment:  */
+typedef HI_U32 HI_COLOR;
+
+/**Palette*//** CNcomment:  */
+typedef HI_COLOR HI_PALETTE[MAX_PALETTE_COLOR_SIZE];
+
+typedef enum
+{
+    HIGO_IMGTYPE_JPEG = 0, /**<.jpeg picture*//**<CNcomment: JPEG*/
+    HIGO_IMGTYPE_GIF,      /**<.gif picture*//**<CNcomment: GIF*/
+    HIGO_IMGTYPE_BMP,      /**<.bmp picture*//**<CNcomment: BMP */
+    HIGO_IMGTYPE_PNG,      /**<.png picture*//**<CNcomment: PNG */
+    HIGO_IMGTYPE_RLE,      /**<.rle picture*//**<CNcomment: RLE */
+    HIGO_IMGTPYE_BUTT
+} HIGO_IMGTYPE_E;
+
+
+/**Rectangle*//** CNcomment:  */
+typedef struct
+{
+    HI_S32 x, y;
+
+    HI_S32 w, h;
+} HI_RECT;
+
+typedef HI_RECT HI_POINT;
+
+/**Region*//** CNcomment:  */
+typedef struct
+{
+    HI_S32 l;
+    HI_S32 t;
+    HI_S32 r;
+    HI_S32 b;
+} HI_REGION;
+
+/**Mode of adjusting the window z-order*//**CNcomment:Z*/
+typedef enum
+{
+    HIGO_ZORDER_MOVETOP = 0,  /**<Move to the top*//**<CNcomment:*/
+    HIGO_ZORDER_MOVEUP,       /**<Move upwards*//**<CNcomment:*/
+    HIGO_ZORDER_MOVEBOTTOM,   /**<Move to the bottom*//**<CNcomment:*/
+    HIGO_ZORDER_MOVEDOWN,     /**<Move downwards*//**<CNcomment:*/
+    HIGO_ZORDER_BUTT
+} HIGO_ZORDER_E;
+
+#define HIGO_INVALID_HANDLE 0x0
+
+/**Stream position*//** CNcomment: */
+
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_COMMON */
+/** @{ */  /** <![HIGO_COMMON] */
+
+
+/**
+\brief Initializes the HiGo.CNcomment:HiGo CNend
+\attention \n
+Before using the HiGo, you must call this application programming interface (API) to initialize the HiGo. The HiGo
+includes the graphic device (Gdev) module, decoder, Winc module, bit block transfer (Bliter) module, and surface
+module.
+CNcomment:HiGoHiGogdev, decoder, winc, blit, surface CNend
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INITFAILED
+
+\see \n
+::HI_GO_Deinit
+*/
+HI_S32	HI_GO_Init(HI_VOID);
+
+/**
+\brief Deinitializes the HiGo.CNcomment: HiGo CNend
+\attention \n
+If the HiGo is not used, you need to call this API to release resources.CNcomment: HiGo CNend
+\param N/A.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_Init
+*/
+HI_S32	HI_GO_Deinit(HI_VOID);
+
+/**
+\brief Initializes the extended library of the HiGo.CNcomment:HiGo  CNend
+\attention \n
+If the extended library of the HiGo is not used, you need to call this API to release resources, especially the
+resources of the cursor and text modules.
+CNcomment:CURSORTEXTCNend
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_DeInitExt
+*/
+HI_S32 HI_GO_InitExt(HI_VOID);
+
+/**
+\brief Deinitializes the extended library of the HiGo.CNcomment: HiGo CNend
+\attention \n
+If the HiGo is not used, you need to call this API to release resources.CNcomment: HiGoCURSORTEXTCNend
+\param N/A.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_InitExt
+*/
+HI_S32 HI_GO_DeInitExt(HI_VOID);
+
+/**
+\brief Obtains the version information.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[out] ppVersion Output address of the version information string. The value cannot be empty.CNcomment:  CNend
+\param[out] ppBuildTime Build Output address of the time string. The value cannot be empty.CNcomment:Build CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_GetVersion(HI_CHAR ** ppVersion, HI_CHAR **ppBuildTime);
+
+/**
+\brief Converts the data on a surface into a .bmp picture for output.CNcomment: SurfaceBMPCNend
+\attention \n
+The output file is [year]-[date]-[hour]-[min]-[second]-[ms].bmp.CNcomment: [year]-[date]-[hour]-[min]-[second]-[ms].bmp CNend
+The output picture must be a 16-bit bitmap.CNcomment: 16CNend
+It is recommended that you call HI_GO_EncodeToFile rather than HI_GO_Surface2Bmp.CNcomment: HI_GO_EncodeToFile CNend
+
+\param[in] Surface Data to be captured.CNcomment: CNend
+\param[in] pRect Pointer to a rectangle. If this parameter is not set, it indicates the entire surface.CNcomment: ,surfaceCNend
+
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOMEM
+
+*/
+HI_S32	HI_GO_Surface2Bmp(HI_HANDLE Surface, const HI_RECT *pRect);
+
+/**
+\brief Enables the memory management module.CNcomment: CNend
+\attention \n
+The memory management module is disabled by default. Before using the memory statistics function, you must call this
+API to enable the memory management module.
+CNcomment: CNend
+
+\param[in] bEnable Whether to enable the memory statistics function.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+
+*/
+HI_S32 HI_GO_EnableMemMng(HI_BOOL bEnable);
+
+
+
+/**
+\brief Obtains the enable status of the memory management module.CNcomment: CNend
+\attention \n
+\param[out] pbEnable Whether to obtain the enable status of the memory statistics function.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+
+*/
+HI_S32 HI_GO_GetMemMngStatus(HI_BOOL *pbEnable);
+
+/**
+\brief Outputs the general information about the system memory.CNcomment: CNend
+\attention \n
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+*/
+HI_S32 HI_GO_SysMemQuene(HI_VOID);
+
+/**
+\brief Outputs the general information about the media memory zone (MMZ).CNcomment: MMZCNend
+\attention \n
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+
+*/
+HI_S32 HI_GO_MMZMemQuene(HI_VOID);
+
+/** @} */  /*! <!-- API declaration end */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_COMM_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_cursor.h b/xbmc/platform/linux/hisi/hi_go_cursor.h
new file mode 100644
index 0000000000..4c76869655
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_cursor.h
@@ -0,0 +1,217 @@
+#ifndef _HI_GO_CURSOR_H
+#define _HI_GO_CURSOR_H
+
+#include "hi_go_comm.h"
+#include "hi_go_gdev.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_CURSOR */
+/** @{ */  /** <!-- [HIGO_CURSOR] */
+
+typedef struct
+{
+    HI_HANDLE hCursor;    /**<The maximum resolution is 128x128, and the minimum resolution is 16x16 for the cursor picture. Both pixel alpha and colorkey are supported.*/
+    				      /**<CNcomment: 128*128,16*16, alphacolorkey */
+    HI_U32    HotspotX;   /**<Horizontal coordinate of the cursor hot spot relative to the cursor picture*//**<CNcomment: X */
+    HI_U32    HotspotY;   /**<Vertical coordinate of the cursor+ hot spot relative to the cursor picture*//**<CNcomment: Y */
+} HIGO_CURSOR_INFO_S;
+
+/**Status of the cursor layer*//** CNcomment:  */
+typedef struct
+{
+    HI_BOOL bShow;             /**<Whether to display the cursor layer.*//**<CNcomment:  */
+} HIGO_CURSOR_STATUS_S;
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_CURSOR */
+/** @{ */  /** <!-- [HIGO_CURSOR] */
+
+/**
+\brief Initializes the cursor module.CNcomment: CNend
+\attention \n
+
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment:  CNend
+\retval ::HIGO_ERR_INITFAILED
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_DeinitCursor
+*/
+
+HI_S32 HI_GO_InitCursor();
+
+/**
+\brief Deinitializes the cursor module.CNcomment: CNend
+\attention \n
+
+\param N/A.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_InitCursor
+*/
+
+HI_S32 HI_GO_DeinitCursor();
+
+/**
+\brief  Displays the cursor layer.CNcomment: CNend
+\attention \n
+1. The cursor of the output layer is located in the middle of the screen by default.CNcomment:1  CNend
+2. You need set the cursor information before the cursor layer is displayed.CNcomment:2.showCNend
+\param[in] bVisible Visible status of the cursor layer. HI_TRUE: visible; HI_FASLE: invisible.CNcomment: HI_TRUE: HI_FASLE:CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOCURSORINF
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_GetCursorStatus
+::HI_GO_SetCursorInfo
+*/
+HI_S32 HI_GO_ShowCursor(HI_BOOL bVisible);
+
+/**
+\brief Obtains the current status of the cursor layer.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+
+\param[out] pCursorStatus Pointer to the current status of the cursor layer. The value cannot be empty.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_ShowLayer
+*/
+HI_S32 HI_GO_GetCursorStatus( HIGO_CURSOR_STATUS_S* pCursorStatus);
+
+/**
+\brief Moves the cursor to a specified position on a specified screen.CNcomment: CNend
+\attention \n
+The cursor position can be changed only when the cursor status is show.CNcomment:cursorshow CNend
+
+\param[in] x Horizontal coordinate (in pixel) of the cursor on the screen relative to the canvas surface of a
+graphics layer.CNcomment: X,, canvas surface CNend
+\param[in] y Vertical coordinate (in pixel) of the cursor on the screen relative to the canvas surface of a graphics
+layer.CNcomment:Y,, canvas surface CNend
+
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_SetCursorPos(HI_S32 x, HI_S32 y);
+
+/**
+\brief Obtains the coordinates of the cursor on the screen.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[out] pX Horizontal coordinate (in pixel) of the cursor on the screen.CNcomment:X, CNend
+\param[out] pY Vertical coordinate (in pixel) of the cursor on the screen.CNcomment:Y, CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_GetCursorPos(HI_S32* pX, HI_S32* pY);
+
+/**
+\brief Sets the hot spot of the displayed cursor picture.CNcomment: CNend
+\attention \n
+The minimum resolution is 16x16, and the maximum resolution is 128x128 for the cursor picture. Both colorkey and
+alpha are supported. CNcomment:16x16,128x128colorkey, alpha CNend
+\param[in] pCursorInfo Information about the cursor picture and coordinates of the hot spot.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVHOTSPOT
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_SetCursorInfo(const HIGO_CURSOR_INFO_S* pCursorInfo);
+
+/**
+\brief Obtains the information about the displayed cursor picture.CNcomment: CNend
+\attention \n
+\param[in] pCursorInfo Information about the cursor picture and coordinates of the hot spot.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_GetCursorInfo(HIGO_CURSOR_INFO_S* pCursorInfo);
+
+/**
+\brief Attaches the cursor to one or more graphics layers.CNcomment: CNend
+\attention \n
+The graphics layers to which the cursor is attached must be opened.CNcomment:openCNend
+\param[in] hLayer CNcomment:ID CNend
+
+\retval ::HI_SUCCESS Layer ID.CNcomment: CNend
+\retval ::HI_FAILURE Success.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_NOTOPEN
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32  HI_GO_AttchCursorToLayer(HI_HANDLE hLayer);
+
+/**
+\brief Detaches the cursor from graphics layers.CNcomment: CNend
+\attention \n
+\param[in] hLayer Layer ID.CNcomment:ID CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HI_FAILURE The display fails.CNcomment: CNend
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32  HI_GO_DetachCursorFromLayer(HI_HANDLE hLayer);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_go_decoder.h b/xbmc/platform/linux/hisi/hi_go_decoder.h
new file mode 100644
index 0000000000..4e8fe1ffca
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_decoder.h
@@ -0,0 +1,439 @@
+#ifndef __HI_GO_DECODE_H__
+#define __HI_GO_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_DEC */
+/** @{ */  /** <!-- [HIGO_DEC] */
+
+/** Decoding type of the decoding instance*//** CNcomment:  */
+typedef enum
+{
+    HIGO_DEC_IMGTYPE_JPEG = HIGO_IMGTYPE_JPEG, /**<.jpeg picture*//**<CNcomment: JPEG*/
+    HIGO_DEC_IMGTYPE_GIF  = HIGO_IMGTYPE_GIF,  /**<.gif picture*//**<CNcomment: GIF*/
+    HIGO_DEC_IMGTYPE_BMP  = HIGO_IMGTYPE_BMP, /**<.bmp picture*//**<CNcomment: BMP */
+    HIGO_DEC_IMGTYPE_PNG  = HIGO_IMGTYPE_PNG,  /**<.png picture*//**<CNcomment: PNG */
+    HIGO_DEC_IMGTYPE_RLE  = HIGO_IMGTYPE_RLE,  /**<.rle picture*//**<CNcomment: RLE */
+    HIGO_DEC_IMGTPYE_BUTT
+} HIGO_DEC_IMGTYPE_E;
+
+/**Stream source*//** CNcomment:  */
+typedef enum
+{
+    HIGO_DEC_SRCTYPE_FILE = 0, /**<Streams are derived from files.*//**<CNcomment: */
+    HIGO_DEC_SRCTYPE_MEM,      /**<Streams are derived from the memory.*//**<CNcomment: */
+    HIGO_DEC_SRCTYPE_STREAM,   /**<Streams are derived from stream data.*/  /**<CNcomment: */
+    HIGO_DEC_SRCTYPE_BUTT
+} HIGO_DEC_SRCTYPE_E;
+
+typedef struct
+{
+    HIGO_MEMTYPE_E MemType;
+    HI_BOOL IsPubPalette;  /*Decoder uses common Palette or not*//** CNcomment:,*/
+}HIGO_DEC_SURINFO_S;
+
+typedef HI_S32 (*PTR_Dec_WriteStreamCB_FN)(HI_ULONG ClientData, HI_ULONG Offset);
+
+/**Detailed information about the stream source*//** CNcomment:*/
+typedef union
+{
+    /*The following information is required if the input source is the memory.*//** CNcomment:*/
+    struct
+    {
+        HI_CHAR* pAddr;      /**<Memory pointer address*//**<CNcomment: */
+        HI_U32 Length;       /**<Length*//**<CNcomment: */
+    } MemInfo;
+
+    /*Picture name*//** CNcomment:*/
+    const HI_CHAR *pFileName;
+    struct
+    {
+        PTR_Dec_WriteStreamCB_FN pWriteCB;
+        HI_ULONG ClientData; /**<Save client data.*//**<CNcomment:  */
+    } Stream;
+} HIGO_DEC_SRCINFO_U;
+
+/**Parameters for creating a decoding instance.*//** CNcomment:  */
+typedef struct
+{
+    HIGO_DEC_SRCTYPE_E SrcType; /**<Type of the input stream.*//**<CNcomment: */
+    HIGO_DEC_SRCINFO_U SrcInfo; /**<Information about the input source.*//**<CNcomment: */
+} HIGO_DEC_ATTR_S;
+
+/** Major information after decoding*//** CNcomment:  */
+typedef struct
+{
+    HI_U32             Count;           /**<Number of pictures*//**<CNcomment:  */
+    HIGO_DEC_IMGTYPE_E ImgType;         /**<Type of the input source.*//**<CNcomment:  */
+    HI_U32             ScrWidth;        /**<Screen width. The screen refers to that of the picture. The value 0 indicates "invalid".*//**<CNcomment: 0 */
+    HI_U32             ScrHeight;       /**<Screen height. The screen refers to that of the picture. The value 0 indicates "invalid".*//**<CNcomment: 0 */
+    HI_BOOL            IsHaveBGColor;   /**<Whether there is any background color.*//**<CNcomment:  */
+    HI_COLOR           BGColor;         /**<Background color*//**<CNcomment:  */
+} HIGO_DEC_PRIMARYINFO_S;
+
+/** Index picture format*//** CNcomment:  */
+typedef struct
+{
+    HI_U32    OffSetX;                /**<X offset value on the screen. The screen mentioned in this document refers to that of the picture.*//**<CNcomment: X */
+    HI_U32    OffSetY;                /**<Y offset value on the screen.*//**<CNcomment: Y*/
+    HI_U32    Width;                  /**<Width of the original picture*//**<CNcomment:  */
+    HI_U32    Height;                  /**<Height of the original picture*//**<CNcomment:  */
+    HI_U8     Alpha;                  /**<Information about channel alpha used for overlaying pictures. The alpha value ranges from 0 to 255.*//**<CNcomment: alpha0-255 */
+    HI_BOOL   IsHaveKey;              /**<Key enable. HI_FALSE: disabled; HI_TRUE: enabled*//**<CNcomment: KEY HI_FALSE: KEYHI_TRUE: KEY */
+    HI_COLOR  Key;                    /**<Information about colorkey used for overlaying pictures*//**<CNcomment: colorkey */
+    HIGO_PF_E Format;                 /**<Pixel format of the picture source*//**<CNcomment:  */
+    HI_U32    DelayTime;              /**<Time interval between this picture and the previous one (10 ms). The value 0 indicates that the parameter is invalid.*//**<CNcomment: (10ms)0 */
+    HI_U32    DisposalMethod;         /**<Processing method of the current frame. This application programming interface (API) is valid for only GIF pictures. 0: customized processing method; 1: no processing method; 2: use the background color.*/    /**<CNcomment: GIF0:1:2:*/
+} HIGO_DEC_IMGINFO_S;
+
+/* Picture attributes after decoding*//** CNcomment:  */
+typedef struct
+{
+    HI_U32    Width;                  /**<Expected width after decoding*//**<CNcomment:  */
+    HI_U32    Height;                 /**<Expected height after decoding*//**<CNcomment: */
+    HIGO_PF_E Format;                 /**<Expected pixel format after decoding*//**<CNcomment: */
+} HIGO_DEC_IMGATTR_S;
+
+/** Extended data format type*//** CNcomment:  */
+typedef enum
+{
+    HIGO_DEC_EXTEND_EXIF = 0,          /**<Extended-data in EXIF format*//**<CNcomment: EXIF */
+    HIGO_DEC_EXTEND_EXIF_BUTT
+} HIGO_DEC_EXTENDTYPE_E;
+
+/** Basic picture information*//** CNcomment:  */
+typedef struct
+{
+    HI_U32    Width;                /**<Picture width*//**<CNcomment:  */
+    HI_U32    Height;               /**<Picture height*//**<CNcomment:  */
+    HIGO_PF_E PixelFormat;          /**<Pixel format*//**<CNcomment:  */
+    HI_U32    VirAddr[3];           /**<Virtual address. If the address is in RGB format, only the first VirAddr[0] is the start address,
+                                                and VirAddr[1] and VirAddr[2] are invalid. If the address is in YC format,
+                                                VirAddr[0] indicates the start address of the Y component, VirAddr[1] indicates the start address of the C component,
+                                                and VirAddr[2] is invalid.*/
+                                                /**<CNcomment: RGBVirAddr[0]
+                                                VirAddr[1]VirAddr[2]YC
+                                                VirAddr[0]YVirAddr[1]C
+                                                VirAddr[2] */
+    HI_U32    PhyAddr[3];           /**<Physical address. The usage principles are the same as previous ones.*//**<CNcomment:  */
+    HI_U32    Pitch[3];             /**<Pitch. The usage principles are the same as previous ones.*//**<CNcomment:  */
+    HI_U32    Palate[256];         /**<Palette*//**<CNcomment:  */
+} HIGO_DEC_IMGDATA_S;
+
+typedef struct {
+    HI_VOID *StreamBuf;     /**<Virtual start address of streams *//**<CNcomment:  */
+    HI_U32 StreamLen;       /**<Actual read stream length *//**<CNcomment:  */
+    HI_U32 ExpectStreamLen; /**<Expect read stream length *//**<CNcomment:  */
+} HIGO_DEC_WRITESTREAM_S;
+
+/** @} */  /*! <!-- Structure Definition end */
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_DEC */
+/** @{ */  /** <!-- [HIGO_DEC] */
+
+
+ /**
+\brief Initializes the decoder.CNcomment:  CNend
+\attention \n
+::HI_GO_Init already calls the interfaceCNcomment: ::HI_GO_Init CNend
+\param  N/ACNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDecoder
+*/
+
+HI_S32 HI_GO_InitDecoder(HI_VOID);
+
+/**
+\brief Deinitializes the decoder.CNcomment:  CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.CNcomment: ::HI_GO_Deinit CNend
+\param  N/A.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDecoder
+*/
+
+HI_S32 HI_GO_DeinitDecoder(HI_VOID);
+
+ /**
+ \brief Creates a decoding handle.CNcomment:  CNend
+ \attention \n
+ Currently, the formats of .bmp, .png, .jpeg, and .gif are supported. The picture input source can be the memory, files
+, and streams. The picture input source of streams is only applicable to the .jpeg format.
+CNcomment: BMPPNGJPEGGIFJPEGCNend
+
+ \param[in] pSrcDesc Information about the input source. This parameter cannot be empty.
+                The type of the input stream must match the information about the input source. For example,
+corresponding file names must be entered for the file stream, and the memory address and memory size must be entered
+for the memory stream.CNcomment: \n
+                FILE\n
+                Memorymemory CNend
+ \param[out] pDecoder Pointer of the decoding instance handle. This parameter cannot be empty.CNcomment:  CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_NOTINIT
+ \retval ::HIGO_ERR_NOMEM
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_INVFILE
+ \retval ::HIGO_ERR_INVSRCTYPE
+ \retval ::HIGO_ERR_INVIMAGETYPE
+ \retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DestroyDecoder
+*/
+HI_S32 HI_GO_CreateDecoder(const HIGO_DEC_ATTR_S* pSrcDesc, HI_HANDLE* pDecoder);
+
+ /**
+ \brief Destroys a decoding handle.CNcomment: CNend
+ \attention \n
+ N/A.CNcomment: CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment: CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_CreateDecoder
+*/
+HI_S32 HI_GO_DestroyDecoder(HI_HANDLE Decoder);
+
+/**
+ \brief Stream APICNcomment:  CNend
+ \attention \n
+ N/A.CNcomment: CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment:  CNend
+ \param[in] pStream Pointer to the stream information. This parameter cannot be empty.CNcomment:   CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HI_FAILURE
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_CreateDecoder
+*/
+HI_S32 HI_GO_DecWriteStream(HI_HANDLE Decoder, HIGO_DEC_WRITESTREAM_S *pStream);
+
+/**
+\brief Reset decoding.CNcomment: CNend
+\attention only support jpeg decode\n
+N/A.CNcomment: jpeg CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVIMAGETYPE
+
+\see sample_dec_stream.c\n
+::HI_GO_ResetDecoder
+*/
+HI_S32 HI_GO_ResetDecoder(HI_HANDLE Decoder);
+
+ /**
+ \brief Obtains the major information about pictures.CNcomment: CNend
+ \attention
+ N/A.CNcomment: CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment: CNend
+\param[out] pPrimaryInfo  Pointer to the major information about the decoded picture. This parameter cannot be empty.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DecImgInfo
+*/
+HI_S32 HI_GO_DecCommInfo(HI_HANDLE Decoder, HIGO_DEC_PRIMARYINFO_S *pPrimaryInfo);
+
+/**
+ \brief Obtains the information about the specified picture. You can customize the picture format.CNcomment:  CNend
+ \attention \n
+  N/A.CNcomment:  CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment:  CNend
+ \param[in] Index
+ Picture index number. For .jpeg pictures, the index number of the main picture is 0, and index
+numbers of thumbnails start from 1.
+                   The index numbers of GIF pictures start from 0 and increase by 1 according to the sequence of the
+pictures stored in a file.
+CNcomment: JPEG01\n
+                   GIF0 CNend
+ \param[out] pImgInfo Picture information. This parameter cannot be empty.CNcomment:  CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_INVINDEX
+ \retval ::HI_FAILURE
+ \retval ::HI_NULL_PTR
+ \retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DecCommInfo
+*/
+HI_S32 HI_GO_DecImgInfo(HI_HANDLE Decoder, HI_U32 Index, HIGO_DEC_IMGINFO_S *pImgInfo);
+
+ /**
+ \brief Obtains the data of a picture.CNcomment: CNend
+ \attention \n
+ The format in the destination picture attributes does not support the macro block format.CNcomment: CNend
+
+\param[in] Decoder Handle of the decoding instance.CNcomment: CNend
+\param[in] Index Index number of a picture, starting from 0.CNcomment:0 CNend
+\param[in] pImgAttr Attribute of the destination picture. If the value is empty, it indicates that the original
+picture attributes are retained.CNcomment: CNend
+\param[out] pSurface Handle of the surface where the decoded data is stored.CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HI_FAILURE
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_DecCommInfo
+*/
+HI_S32 HI_GO_DecImgData(HI_HANDLE Decoder, HI_U32 Index, const HIGO_DEC_IMGATTR_S *pImgAttr, HI_HANDLE *pSurface);
+
+/**
+ \brief Obtains the extended data.CNcomment:  CNend
+ \attention \n
+ Hi3110E does not support the API.CNcomment: Hi3110E CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment:  CNend
+ \param[in] DecExtendType
+ Type of the obtained extended data. Currently, only the EXIF information in .jpeg format is available.
+ CNcomment: JPEGEXIF CNend
+ \param[out] ppData Pointer to the extended data pointer.CNcomment:  CNend
+ \param[out] pLength ppData Length.CNcomment: ppData CNend
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_ReleaseDecExtendData
+*/
+HI_S32 HI_GO_DecExtendData(HI_HANDLE Decoder, HIGO_DEC_EXTENDTYPE_E DecExtendType, HI_VOID **ppData, HI_U32 *pLength);
+
+ /**
+ \brief Releases extended data.CNcomment: CNend
+ \attention \n
+ Hi3110E does not support the API.CNcomment:Hi3110ECNend
+ \param[in] Decoder Decoder handle.CNcomment:Decoder CNend
+ \param[in] DecExtendType Type of the obtained extended data. Currently, only the EXIF information in .jpeg format is
+available.CNcomment:JPEGEXIF CNend
+ \param[in] pData Pointer to the extended data.CNcomment: CNend
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_DecExtendData
+*/
+HI_S32 HI_GO_ReleaseDecExtendData(HI_HANDLE Decoder, HIGO_DEC_EXTENDTYPE_E DecExtendType, HI_VOID *pData);
+
+/**
+\brief Decodes a picture to a specified surface.CNcomment:surface CNend
+\attention \n
+The decoded surface is scaled automatically based on the size of the target surface. In addition, the decoded surface
+modifies the attributes of the target surface, such as colorkey, alpha value, and palette.
+CNcomment:SurfacesurfacesurfaceCOLORKEYALPHA CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment:  CNend
+\param[in] Index   Index number of a decoded picture.CNcomment: CNend
+\param[out] Surface Decoded target surface.CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_FAILURE
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_DecImgToSurface(HI_HANDLE Decoder, HI_U32 Index, HI_HANDLE Surface);
+
+/**
+\brief Decodes a specified file, and generates a new surface.CNcomment:surface CNend
+\attention \n
+    If there are multiple pictures in the file (such as .gif animation, .jpeg main picture, and .jpeg thumbnail),
+    only the .jpeg main picture and the first picture of the .gif animation are decoded.
+    In addition, the surface size is the same as the picture size.
+    CNcomment::gifJPEG
+    JPEGGIFsurface CNend
+\param[in] pszFile Picture name. The picture can be in the format of .gif, .png, .jpg, or .bmp.CNcomment:GIF, PNG, JPG, BMP CNend
+\param[out] pSurface, Surface for storing decoded pictures.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVIMAGETYPE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_DecodeFile(const HI_CHAR* pszFile, HI_HANDLE* pSurface);
+
+/**
+\brief Set the attribute of Decoder out Surface memrory.  CNcomment:Surface CNend
+\attention \n
+N/A.CNcomment:  CNend
+\param[in] Decoder handle. CNcomment: CNend
+\param[in] pSurfInfo.  CNcomment:Surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_SetDecSurfInfo(HI_HANDLE Decoder, HIGO_DEC_SURINFO_S  *pSurfInfo);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_DECODE_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_encoder.h b/xbmc/platform/linux/hisi/hi_go_encoder.h
new file mode 100644
index 0000000000..6e6926b496
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_encoder.h
@@ -0,0 +1,164 @@
+#ifndef __HI_GO_ENCODER_H__
+#define __HI_GO_ENCODER_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_ENC */
+/** @{ */  /** <!-- [HIGO_ENC] */
+
+/**Encoder attributes*/
+/** CNcomment:*/
+typedef struct
+{
+   HIGO_IMGTYPE_E ExpectType;   /**<Type of the encoded picture*//**<CNcomment:*/
+   HI_U32 QualityLevel;        /**<The quality level ranges from 1 to 99. The higher the level, the better the quality, and the greater the encoded picture or occupied memory. The QualityLevel parameter is valid for .jpeg pictures only.*//**<CNcomment:1-99, JPEG*/
+}HIGO_ENC_ATTR_S;
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_ENC */
+/** @{ */  /** <!-- [HIGO_ENC] */
+ /**
+\brief Initializes the encoder. CNcomment: CNend
+\attention \n
+When ::HI_GO_Init is called, this application programming interface (API) is also called.
+CNcomment: ::HI_GO_Init CNend
+\param  N/A
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDecoder
+*/
+
+HI_S32 HI_GO_InitEncoder(HI_VOID);
+
+
+/**
+\brief Deinitializes the encoder. CNcomment: CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit CNend
+\param  N/A
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDecoder
+*/
+
+HI_S32 HI_GO_DeinitEncoder(HI_VOID);
+
+/**
+\brief Encodes a surface in a specified format, and saves the encoded surface in a file.
+CNcomment:surface CNend
+\attention \n
+The .bmp encoding format is supported.
+The hardware platform determines whether the .jpeg encoding foramt is supported.
+CNcomment:bmp \n
+(JPEG,) CNend
+
+\param[in] hSurface  Surface to be encoded. CNcomment:surface, CNend
+\param[in] pFile    Name of the encoded file. This parameter can be empty. If this parameter is not set, the encoded file is named [year]-[month]-[date]-[hour]-[minute]-[second].
+                        CNcomment:[]-[]-[]-[]-[]-[] CNend
+\param[in] pAttr    Encoding attributes. This parameter cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVIMAGETYPE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_DEPEND_JPGE
+
+\see \n
+*/
+HI_S32 HI_GO_EncodeToFile(HI_HANDLE hSurface, const HI_CHAR* pFile, const HIGO_ENC_ATTR_S* pAttr);
+
+/**
+\brief Encodes a surface in a specified picture format and saves it in a memory. Ensure that the memory is sufficient.
+CNcomment:surface CNend
+\attention \n
+The data can be encoded as .bmp data, and saved in a specified memory.
+The hardware platform determines whether the .jpeg encoding format is supported.
+CNcomment:bmp
+(JPEG,) CNend
+
+\param[in] hSurface     Surface to be encoded. CNcomment:surface, CNend
+\param[in] pMem         Start address of the memory for storing the encoded pictures. CNcomment: CNend
+\param[in] MemLen       Size of a specified memory. CNcomment: CNend
+\param[out] pOutLen     Actual size of the used memory, indicating the length of encoded data. Ensure that the value of pOutLen is smaller than or equal to the value of MemLen.
+                                CNcomment:(pOutLen <= MemLen) CNend
+\param[in] pAttr        Encoding attributes. This parameter cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVIMAGETY
+\retval ::HIGO_ERR_INVIMAGETYPE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_DEPEND_JPGE
+
+\see \n
+*/
+
+HI_S32 HI_GO_EncodeToMem(HI_HANDLE hSurface, HI_U8* pMem, HI_U32 MemLen, HI_U32* pOutLen, const HIGO_ENC_ATTR_S* pAttr);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_TYPE_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_errno.h b/xbmc/platform/linux/hisi/hi_go_errno.h
new file mode 100644
index 0000000000..877323611c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_errno.h
@@ -0,0 +1,554 @@
+#ifndef __HI_GO_ERRNO_H__
+#define __HI_GO_ERRNO_H__
+
+/* add include here */
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      HIGO_ERRCODE */
+/** @{ */  /** <!-- [HIGO_ERRCODE] */
+
+/**Error IDs of HiGo projects*/
+/** CNcomment:HiGo ID */
+#define HIGO_ERR_APPID (0x80000000L + 0x30000000L)
+
+typedef enum hiGOLOG_ERRLEVEL_E
+{
+    HIGO_LOG_LEVEL_DEBUG = 0,  /* debug-level                                  */
+    HIGO_LOG_LEVEL_INFO,       /* informational                                */
+    HIGO_LOG_LEVEL_NOTICE,     /* normal but significant condition             */
+    HIGO_LOG_LEVEL_WARNING,    /* warning conditions                           */
+    HIGO_LOG_LEVEL_ERROR,      /* error conditions                             */
+    HIGO_LOG_LEVEL_CRIT,       /* critical conditions                          */
+    HIGO_LOG_LEVEL_ALERT,      /* action must be taken immediately             */
+    HIGO_LOG_LEVEL_FATAL,      /* just for compatibility with previous version */
+    HIGO_LOG_LEVEL_BUTT
+} HIGO_LOG_ERRLEVEL_E;
+
+/**Macros for defining the error codes of the HiGo*/
+/** CNcomment:HiGo  */
+#define HIGO_DEF_ERR( module, errid) \
+    ((HI_S32)((HIGO_ERR_APPID) | (((HI_U32)module) << 16) | (((HI_U32)HIGO_LOG_LEVEL_ERROR) << 13) | ((HI_U32)errid)))
+
+/**HiGo Module encoding*/
+/** CNcomment:HiGo  */
+typedef enum
+{
+    HIGO_MOD_COMM = 0,
+    HIGO_MOD_SURFACE,
+    HIGO_MOD_MEMSURFACE,
+    HIGO_MOD_LAYER,
+    HIGO_MOD_BLITER,
+    HIGO_MOD_DEC,
+    HIGO_MOD_TEXTOUT,
+    HIGO_MOD_WINC,
+    HIGO_MOD_CURSOR,
+    HIGO_MOD_TEXT_LAYOUT,
+    HIGO_MOD_BUTT
+} HIGO_MOD_E;
+
+/**Common error codes of the HiGo*/
+/** CNcomment:HiGo  */
+typedef enum
+{
+    ERR_COMM_NOTINIT = 0,
+    ERR_COMM_INITFAILED,
+    ERR_COMM_DEINITFAILED,
+    ERR_COMM_NULLPTR,
+    ERR_COMM_INVHANDLE,
+    ERR_COMM_NOMEM,
+    ERR_COMM_INTERNAL,
+    ERR_COMM_INVSRCTYPE,
+    ERR_COMM_INVFILE,
+    ERR_COMM_INVPARAM,
+    ERR_COMM_INUSE,
+    ERR_COMM_UNSUPPORTED,
+    ERR_COMM_DEPENDTDE,
+    ERR_COMM_DEPENDFB ,
+    ERR_COMM_DEPENDMMZ,
+    ERR_COMM_DEPENDJPEG,
+    ERR_COMM_DEPENDPNG,
+    ERR_COMM_DEPENDBMP,
+    ERR_COMM_DEPENDGIF,
+    ERR_COMM_DEPENDCURSOR,
+    ERR_COMM_DEPENDJPGENC,
+    ERR_COMM_BUTT
+} HIGO_ERR_E;
+
+/**The dependent module is not initialized (0xB0008000).*/
+/** CNcomment: 0xB0008000 */
+#define HIGO_ERR_NOTINIT HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NOTINIT)
+
+/*The module fails to be initialized (0xB0008001).*/
+/** CNcomment: 0xB0008001 */
+#define HIGO_ERR_DEINITFAILED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INITFAILED)
+
+/**The module fails to be deinitialized (0xB0008002).*/
+/** CNcomment: 0xB0008002 */
+#define HIGO_ERR_INITFAILED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEINITFAILED)
+
+/**The input pointer is null (0xB0008003).*/
+/** CNcomment: 0xB0008003 */
+#define HIGO_ERR_NULLPTR HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NULLPTR)
+
+/**The input handle is invalid (0xB0008004).*/
+/** CNcomment: 0xB0008004 */
+#define HIGO_ERR_INVHANDLE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVHANDLE)
+
+/**The memory is insufficient (0xB0008005).*/
+/** CNcomment: 0xB0008005 */
+#define HIGO_ERR_NOMEM HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NOMEM)
+
+/**An internal error occurs (0xB0008006).*/
+/** CNcomment: 0xB0008006 */
+#define HIGO_ERR_INTERNAL HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INTERNAL)
+
+/**The I/O source is invalid (0xB0008007).*/
+/** CNcomment:IO 0xB0008007 */
+#define HIGO_ERR_INVSRCTYPE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVSRCTYPE)
+
+/**The file operation fails because the file is invalid (0xB0008008).*/
+/** CNcomment: 0xB0008008 */
+#define HIGO_ERR_INVFILE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVFILE)
+
+/**The parameter is invalid (0xB0008009).*/
+/** CNcomment: 0xB0008009*/
+#define HIGO_ERR_INVPARAM HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVPARAM)
+
+/**The handle is being used (0xB000800A).*/
+/** CNcomment: 0xB000800A */
+#define HIGO_ERR_INUSE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INUSE)
+
+/**The operation is invalid (0xB000800B).*/
+/** CNcomment: 0xB000800B */
+#define HIGO_ERR_UNSUPPORTED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_UNSUPPORTED)
+
+/**An error occurs when the APIs related to the TDE are called (0xB000800C).*/
+/** CNcomment:TDE 0xB000800C*/
+#define HIGO_ERR_DEPEND_TDE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDTDE)
+
+/**An error occurs when the APIs related to the FB are called (0xB000800D).*/
+/** CNcomment:FB  0xB000800D*/
+#define HIGO_ERR_DEPEND_FB HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDFB)
+
+/**An error occurs when the APIs related to the MMZ are called (0xB000800E).*/
+/** CNcomment:MMZ 0xB000800E*/
+#define HIGO_ERR_DEPEND_MMZ HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDMMZ)
+
+/**An error occurs when the APIs related to .jpeg decoding are called (0xB000800F).*/
+/** CNcomment:JPEG    0xB000800F*/
+#define HIGO_ERR_DEPEND_JPEG HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDJPEG)
+
+/**An error occurs when the APIs related to .png decoding are called (0xB0008010).*/
+/** CNcomment:PNG 0xB0008010*/
+#define HIGO_ERR_DEPEND_PNG HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDPNG)
+
+/**An error occurs when the APIs related to .bmp decoding are called (0xB0008011).*/
+/** CNcomment:BMP 0xB0008011*/
+#define HIGO_ERR_DEPEND_BMP HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDBMP)
+
+/**An error occurs when the APIs related to .gif decoding are called (0xB0008012).*/
+/** CNcomment:GIF 0xB0008012*/
+#define HIGO_ERR_DEPEND_GIF HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDGIF)
+
+/**An error occurs when the APIs related to the cursor are called (0xB0008013).*/
+/** CNcomment:CURSOR  0xB0008013*/
+#define HIGO_ERR_DEPEND_CURSOR HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDCURSOR)
+
+/**An error occurs when the APIs related to .jpeg encoding are called (0xB0008014).*/
+/** CNcomment:jpeg 0xB0008014*/
+#define HIGO_ERR_DEPEND_JPGE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDJPGENC)
+
+
+/**Error codes of the HiGo surface module*/
+/** CNcomment:HiGo surface */
+typedef enum
+{
+    ERR_SURFACE_INVSURFACESIZE = 0,
+    ERR_SURFACE_INVSURFACEPF,
+    ERR_SURFACE_NOTLOCKED,
+    ERR_SURFACE_LOCKED,
+    ERR_SURFACE_NOCOLORKEY,
+    ERR_SURFACE_BUTT
+} HIGO_SURFACE_ERR_E;
+
+#define SURFACE_DEF_ERR(err) HIGO_DEF_ERR(HIGO_MOD_SURFACE, err)
+
+/**The surface size is incorrect (0xB0018000).*/
+/** CNcomment:surface 0xB0018000 */
+#define HIGO_ERR_INVSURFACESIZE SURFACE_DEF_ERR(ERR_SURFACE_INVSURFACESIZE)
+
+/**The pixel format of the surface is incorrect (0xB0018001).*/
+/** CNcomment:surface 0xB0018001 */
+#define HIGO_ERR_INVSURFACEPF SURFACE_DEF_ERR(ERR_SURFACE_INVSURFACEPF)
+
+/**The surface cannot be unlocked because it is not locked (0xB0018002).*/
+/** CNcomment:surfacesurface 0xB0018002 */
+#define HIGO_ERR_NOTLOCKED SURFACE_DEF_ERR(ERR_SURFACE_NOTLOCKED)
+
+/**The surface cannot be written because it is locked (0xB0018003).*/
+/** CNcomment:surfacesurface 0xB0018003 */
+#define HIGO_ERR_LOCKED SURFACE_DEF_ERR(ERR_SURFACE_LOCKED)
+
+/**The surface does not contain the colorkey value (0xB0018004).*/
+/** CNcomment:surfacecolorKey 0xB0018004 */
+#define HIGO_ERR_NOCOLORKEY SURFACE_DEF_ERR(ERR_SURFACE_NOCOLORKEY)
+
+/**Error codes of the HiGo Gdev module*/
+/** CNcomment:HiGo gdev*/
+typedef enum
+{
+    ERR_LAYER_INVSIZE = 0,
+    ERR_LAYER_INVLAYERID,
+    ERR_LAYER_INVPIXELFMT,
+    ERR_LAYER_FLUSHTYPE,
+    ERR_LAYER_FREEMEM,
+    ERR_LAYER_CLOSELAYER,
+    ERR_LAYER_CANNOTCHANGE,
+    ERR_LAYER_INVORDERFLAG,
+    ERR_LAYER_SETALPHA,
+    ERR_LAYER_ALREADYSHOW,
+    ERR_LAYER_ALREADYHIDE,
+    ERR_LAYER_INVLAYERPOS,
+    ERR_LAYER_INVSURFACE,
+    ERR_LAYER_INVLAYERSIZE,
+    ERR_LAYER_INVFLUSHTYPE,
+    ERR_LAYER_INVANILEVEL,
+    ERR_LAYER_NOTOPEN,
+    ERR_LAYER_FB_OPENFAILURE,
+    ERR_LAYER_FB_GETVSCREENINFOFAILURE,
+    ERR_LAYER_FB_PUTVSCREENINFOFAILURE,
+    ERR_LAYER_FB_GETLAYERINFO,
+    ERR_LAYER_FB_PUTLAYERINFO,
+    ERR_LAYER_FB_GETLAYERALPHA,
+    ERR_LAYER_FB_PUTLAYERALPHA,
+    ERR_LAYER_FB_WRONG_LAYERID,
+    ERR_LAYER_FB_REFRESHFAILURE,
+    ERR_LAYER_FB_GETCANVASBUFFER,
+    ERR_LAYER_FB_PUTCANVASBUFFER,
+    ERR_LAYER_FB_GETZORDER,
+    ERR_LAYER_FB_PUTZORDER,
+    ERR_LAYER_BUTT
+} HIGO_LAYER_ERR_E;
+
+#define LAYER_DEF_ERR(err) HIGO_DEF_ERR(HIGO_MOD_LAYER, err)
+
+/**The layer size is invalid (0xB0038000).*/
+/** CNcomment: 0xB0038000 */
+#define HIGO_ERR_INVSIZE LAYER_DEF_ERR(ERR_LAYER_INVSIZE)
+
+/**The hardware layer ID is invalid (0xB0038001).*/
+/** CNcomment:ID 0xB0038001 */
+#define HIGO_ERR_INVLAYERID LAYER_DEF_ERR(ERR_LAYER_INVLAYERID)
+
+/**The pixel format is invalid (0xB0038002).*/
+/** CNcomment: 0xB0038002 */
+#define HIGO_ERR_INVPIXELFMT LAYER_DEF_ERR(ERR_LAYER_INVPIXELFMT)
+
+/**The layer refresh mode is incorrect (0xB0038003).*/
+/** CNcomment: 0xB0038003 */
+#define HIGO_ERR_INVFLUSHTYPE LAYER_DEF_ERR(ERR_LAYER_FLUSHTYPE)
+
+/**The display buffer fails to be released (0xB0038004).*/
+/** CNcomment: 0xB0038004 */
+#define HIGO_ERR_FREEMEM LAYER_DEF_ERR(ERR_LAYER_FREEMEM)
+
+/**The layer device fails to be stopped (0xB0038005).*/
+/** CNcomment: 0xB0038005 */
+#define HIGO_ERR_CLOSELAYERFAILED LAYER_DEF_ERR(ERR_LAYER_CLOSELAYER)
+
+/**The z-order of the graphics layer cannot be changed (0xB0038006).*/
+/** CNcomment:Z 0xB0038006 */
+#define HIGO_ERR_CANNOTCHANGE LAYER_DEF_ERR(ERR_LAYER_CANNOTCHANGE)
+
+/**The z-order change flag is invalid (0xB0038007).*/
+/** CNcomment:Z 0xB0038007 */
+#define HIGO_ERR_INVORDERFLAG LAYER_DEF_ERR(ERR_LAYER_INVORDERFLAG)
+
+/**The surface alpha value fails to be set (0xB0038008).*/
+/** CNcomment:surface alpha 0xB0038008 */
+#define HIGO_ERR_SETALPHAFAILED LAYER_DEF_ERR(ERR_LAYER_SETALPHA)
+
+/**The graphics layer has been displayed (0xB0038009).*/
+/** CNcomment: 0xB0038009 */
+#define HIGO_ERR_ALREADYSHOW LAYER_DEF_ERR(ERR_LAYER_ALREADYSHOW)
+
+/**The graphics layer has been hidden (0xB003800A).*/
+/** CNcomment: 0xB003800A */
+#define HIGO_ERR_ALREADYHIDE LAYER_DEF_ERR(ERR_LAYER_ALREADYHIDE)
+
+/**The start position of the graphics layer is invalid (0xB003800B).*/
+/** CNcomment: 0xB003800B*/
+#define HIGO_ERR_INVLAYERPOS LAYER_DEF_ERR(ERR_LAYER_INVLAYERPOS)
+
+/**Alignment fails because the surface is invalid (0xB003800C).*/
+/** CNcomment:surface 0xB003800C*/
+#define HIGO_ERR_INVLAYERSURFACE LAYER_DEF_ERR(ERR_LAYER_INVSURFACE)
+
+/**The anti-flicker level of the graphics layer is invalid (0xB003800F).*/
+/** CNcomment: 0xB003800F*/
+#define HIGO_ERR_INVANILEVEL LAYER_DEF_ERR(ERR_LAYER_INVANILEVEL)
+
+/**The graphics layer is not started (0xB0038010).*/
+/** CNcomment: 0xB0038010*/
+#define HIGO_ERR_NOTOPEN LAYER_DEF_ERR(ERR_LAYER_NOTOPEN)
+
+/** frame buffer: open fb device failure (0xB0038011).*/
+/** CNcomment: frame buffer, fb 0xB0038011*/
+#define HIGO_ERR_FB_OPEN_FAILURE                    LAYER_DEF_ERR(ERR_LAYER_FB_OPENFAILURE)
+
+/** frame buffer: get vscreeninfo failure (0xB0038012). */
+/** CNcomment: frame buffer,  0xB0038012 */
+#define HIGO_ERR_FB_GET_VSCREENINFO_FAILURE         LAYER_DEF_ERR(ERR_LAYER_FB_GETVSCREENINFOFAILURE)
+
+/** frame buffer: put vscreeninfo failure (0xB0038013). */
+/** CNcomment: frame buffer,  0xB0038013 */
+#define HIGO_ERR_FB_PUT_VSCREENINFO_FAILURE         LAYER_DEF_ERR(ERR_LAYER_FB_PUTVSCREENINFOFAILURE)
+
+/** frame buffer: get layer info failure (0xB0038014). */
+/** CNcomment: frame buffer,  0xB0038014 */
+#define HIGO_ERR_FB_GET_LAYERINFO_FAILURE           LAYER_DEF_ERR(ERR_LAYER_FB_GETLAYERINFO)
+
+/** frame buffer: put layer info failure (0xB0038015). */
+/** CNcomment: frame buffer,  0xB0038015 */
+#define HIGO_ERR_FB_PUT_LAYERINFO_FAILURE           LAYER_DEF_ERR(ERR_LAYER_FB_PUTLAYERINFO)
+
+/** frame buffer: get layer alpha failure (0xB0038016). */
+/** CNcomment: frame buffer, alpha 0xB0038016 */
+#define HIGO_ERR_FB_GET_LAYERALPHA_FAILURE          LAYER_DEF_ERR(ERR_LAYER_FB_GETLAYERALPHA)
+
+/** frame buffer: put layer alpha failure (0xB0038017). */
+/** CNcomment: frame buffer, alpha 0xB0038017 */
+#define HIGO_ERR_FB_PUT_LAYERALPHA_FAILURE          LAYER_DEF_ERR(ERR_LAYER_FB_PUTLAYERALPHA)
+
+/** frame buffer: wrong layre id (0xB0038018). */
+/** CNcomment: frame buffer, ID 0xB0038018 */
+#define HIGO_ERR_FB_WRONG_LAYER_ID                  LAYER_DEF_ERR(ERR_LAYER_FB_WRONG_LAYERID)
+
+/** frame buffer: refresh failure (0xB0038019). */
+/** CNcomment: frame buffer,  0xB0038019 */
+#define HIGO_ERR_FB_REFRESH_FAILURE                 LAYER_DEF_ERR(ERR_LAYER_FB_REFRESHFAILURE)
+
+/** frame buffer: get canvas buffer failure (0xB003801A). */
+/** CNcomment: frame buffer, CANVAS BUFFER 0xB003801A */
+#define HIGO_ERR_FB_GET_CANVAS_BUFFER_FAILURE       LAYER_DEF_ERR(ERR_LAYER_FB_GETCANVASBUFFER)
+
+/** frame buffer: put canvas buffer failure (0xB003801B). */
+/** CNcomment: frame buffer, CANVAS BUFFER 0xB003801B */
+#define HIGO_ERR_FB_PUT_CANVAS_BUFFER_FAILURE       LAYER_DEF_ERR(ERR_LAYER_FB_PUTCANVASBUFFER)
+
+/** frame buffer: get zorder failure (0xB003801C). */
+/** CNcomment: frame buffer, zorder 0xB003801C */
+#define HIGO_ERR_FB_GET_ZORDER_FAILURE              LAYER_DEF_ERR(ERR_LAYER_FB_GETZORDER)
+
+/** frame buffer: put zorder failure (0xB003801D). */
+/** CNcomment: frame buffer, zorder 0xB003801D */
+#define HIGO_ERR_FB_PUT_ZORDER_FAILURE              LAYER_DEF_ERR(ERR_LAYER_FB_PUTZORDER)
+
+
+/**Error codes of the HiGo Bliter module*/
+/** CNcomment:HiGo bliter */
+typedef enum
+{
+    ERR_BLITER_INVCOMPTYPE = 0,
+    ERR_BLITER_INVCKEYTYPE,
+    ERR_BLITER_INVMIRRORTYPE,
+    ERR_BLITER_INVROTATETYPE,
+    ERR_BLITER_INVROPTYPE,
+    ERR_BLITER_INVSCALING,
+    ERR_BLITER_OUTOFBOUNDS,
+    ERR_BLITER_EMPTYRECT,
+    ERR_BLITER_OUTOFPAL,
+    ERR_BLITER_NOP,
+    ERR_BLITER_BUTT
+} HIGO_BLITER_ERR_S;
+
+/**The blending mode is incorrect (0xB0048000).*/
+/** CNcomment:  0xB0048000 */
+#define HIGO_ERR_INVCOMPTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVCOMPTYPE)
+
+/**The colorkey operation is invalid (0xB0048001).*/
+/** CNcomment:colorKey 0xB0048001 */
+#define HIGO_ERR_INVCKEYTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVCKEYTYPE)
+
+/**The mirror operation is invalid (0xB0048002).*/
+/** CNcomment: 0xB0048002 */
+#define HIGO_ERR_INVMIRRORTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVMIRRORTYPE)
+
+/**The rotation operation is invalid (0xB0048003).*/
+/** CNcomment: 0xB0048003 */
+#define HIGO_ERR_INVROTATETYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVROTATETYPE)
+
+/**The ROP operation is invalid (0xB0048004).*/
+/** CNcomment:ROP 0xB0048004 */
+#define HIGO_ERR_INVROPTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVROPTYPE)
+
+/**The scaling is abnormal (0xB0048005).*/
+/** CNcomment: 0xB0048005 */
+#define HIGO_ERR_INVSCALING HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVSCALING)
+
+/**The rectangle exceeds the boundary (0xB0048006).*/
+/** CNcomment: 0xB0048006*/
+#define HIGO_ERR_OUTOFBOUNDS HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_OUTOFBOUNDS)
+
+/**The rectangle is empty (0xB0048007).*/
+/** CNcomment: 0xB0048007*/
+#define HIGO_ERR_EMPTYRECT HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_EMPTYRECT)
+
+/**The palette does not contain this color (0xB0048008).*/
+/** CNcomment: 0xB0048008*/
+#define HIGO_ERR_OUTOFPAL HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_OUTOFPAL)
+
+/**Error codes of the HiGo decoder*/
+/** CNcomment:HiGo decode*/
+typedef enum
+{
+    ERR_DEC_INVIMAGETYPE = 0,
+    ERR_DEC_INVINDEX,
+    ERR_DEC_INVIMGDATA,
+    ERR_DEC_BUTT
+} HIGO_ERR_DEC_E;
+
+/**<The picture format is invalid (0xB0058000).*/
+/**<CNcomment: 0xB0058000 */
+#define HIGO_ERR_INVIMAGETYPE HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVIMAGETYPE)
+
+/**<The picture index number is invalid (0xB0058001).*/
+/**<CNcomment: 0xB0058001 */
+#define HIGO_ERR_INVINDEX HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVINDEX)
+
+/**<The picture data is invalid (0xB0058002).*/
+/**<CNcomment: 0xB0058002 */
+#define HIGO_ERR_INVIMGDATA HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVIMGDATA)
+
+/**Error codes of the HiGo textout module*/
+/** CNcomment:HiGo textout */
+typedef enum
+{
+    ERR_TEXTOUT_INVRECT = 0,
+    ERR_TEXTOUT_UNSUPPORT_CHARSET,
+    ERR_TEXTOUT_ISUSING,
+    ERR_TEXTOUT_NOIMPLEMENT,
+    ERR_TEXTOUT_SHAPE,
+    ERR_TEXTOUT_MAX_CHAR,
+    ERR_TEXTOUT_CHAR_SET,
+    ERR_TEXTOUT_BIDI,
+    ERR_TEXTOUT_ERRCODE_MAX = 0x1F,
+    ERR_TEXTOUT_INTERNAL = 0,
+    ERR_TEXTOUT_BUTT
+} HIGO_TEXTOUT_ERR_S;
+
+/**The rectangle region is invalid (0xB0068000).*/
+/** CNcomment: 0xB0068000 */
+#define HIGO_ERR_INVRECT HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_INVRECT)
+
+/**The character set is not supported (0xB0068001).*/
+/** CNcomment: 0xB0068001*/
+#define HIGO_ERR_UNSUPPORT_CHARSET HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_UNSUPPORT_CHARSET)
+
+/**The character set is not supported (0xB0068002).*/
+/** CNcomment: 0xB0068002*/
+#define HIGO_ERR_ISUSING HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_ISUSING)
+/**The function not implement yet (0xB0068003) */
+/** CNcomment: 0xB0068003 */
+#define HIGO_ERR_NOIMPLEMENT  HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_NOIMPLEMENT);
+/**Shape Failed (0xB0068004) */
+/** CNcomment: 0xB0068004 */
+#define HIGO_ERR_SHAPEFAILED HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_SHAPE);
+
+/**Number of characters greater than limit (0xB0068005) */
+/** CNcomment: 0xB0068005 */
+#define HIGO_ERR_MAX_CHAR HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_MAX_CHAR);
+
+/**Char set error (0xB0068006) */
+/** CNcomment: 0xB0068006 */
+#define HIGO_ERR_CHAR_SET HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_CHAR_SET);
+
+/**bi-directional process erro(0xB)068007) */
+/** CNcomment: 0xB0068006 */
+#define HIGO_ERROR_BIDI HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_BIDI);
+
+/**Internal error (0xB006801F) */
+/** CNcomment: 0xB006801F */
+#define HIGO_ERR_TEXTINTERNAL HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_INTERNAL)
+
+/**Error codes of the HiGo Winc module*/
+/** CNcomment:HiGo Winc */
+typedef enum
+{
+    ERR_WINC_ALREADYBIND = 0, /**<The Winc module has been attached.*//**<CNcomment: */
+    ERR_WINC_INVZORDERTYPE,   /**<The z-order adjustment mode is invalid.*//**<CNcomment:Z */
+    ERR_WINC_NOUPDATE,        /**<The desktop is not refreshed.*//**<CNcomment: */
+    ERR_WINC_INVPF,           /**<The pixel format is invalid.*//**<CNcomment: */
+    ERR_WINC_INVTREE,           /**<The window tree is invalid.*//**<CNcomment: */
+    ERR_WINC_ALREADYSETMODE,    /**<The window already be set mode.*//**<CNcomment:*/
+    ERR_WINC_BUTT
+} HIGO_ERR_WINC_E;
+
+/**The desktop has been attached to a graphics layer (0xB0078000).*/
+/** CNcomment: 0xB0078000 */
+#define HIGO_ERR_ALREADYBIND HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_ALREADYBIND)
+
+/**The z-order adjustment mode is invalid (0xB0078001).*/
+/** CNcomment:Z 0xB0078001 */
+#define HIGO_ERR_INVZORDERTYPE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVZORDERTYPE)
+
+/**The desktop is not refreshed (0xB0078002).*/
+/** CNcomment: 0xB0078002 */
+#define HIGO_ERR_NOUPDATE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_NOUPDATE)
+
+/**The desktop is not refreshed (0xB0078003).*/
+/** CNcomment: 0xB0078003 */
+#define HIGO_ERR_INVPF HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVPF)
+
+/**The desktop is not refreshed (0xB0078004).*/
+/** CNcomment: 0xB0078004 */
+#define HIGO_ERR_INVTREE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVTREE)
+
+/**The window already be set mode (0xB0078005).*/
+/** CNcomment: 0xB0078005 */
+#define HIGO_ERR_ALREADYSETMODE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_ALREADYSETMODE)
+
+/**Error codes of the HiGo surface module*/
+/** CNcomment:HiGo Cursor */
+typedef enum
+{
+    ERR_CURSOR_INVHOTSPOT = 0,
+    ERR_CURSOR_NOCURSORINFO,
+    ERR_CURSOR_BUTT
+} HIGO_CURSOR_ERR_E;
+
+/**The hot spot coordinate of the cursor is invalid (0xB0088000).*/
+/** CNcomment:cursor 0xB0088000 */
+#define HIGO_ERR_INVHOTSPOT  HIGO_DEF_ERR(HIGO_MOD_CURSOR, ERR_CURSOR_INVHOTSPOT)
+
+/**The cursor information is not set (0xB0088001).*/
+/** CNcomment:cursor 0xB0088001 */
+#define HIGO_ERR_NOCURSORINF HIGO_DEF_ERR(HIGO_MOD_CURSOR, ERR_CURSOR_NOCURSORINFO)
+
+/** @} */  /*! <!-- Macro Definition end */
+
+
+
+/*************************** Structure Definition ****************************/
+
+
+/********************** Global Variable declaration **************************/
+
+
+/******************************* API declaration *****************************/
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_ERRNO_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_gdev.h b/xbmc/platform/linux/hisi/hi_go_gdev.h
new file mode 100644
index 0000000000..f25cab1687
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_gdev.h
@@ -0,0 +1,1022 @@
+#ifndef __HI_GO_GDEV_H__
+#define __HI_GO_GDEV_H__
+
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_GDEV */
+/** @{ */  /** <!-- [HIGO_GDEV] */
+
+/** Definition of the graphics layer ID*/
+/** CNcomment:ID*/
+typedef enum
+{
+    HIGO_LAYER_SD_0 = 0,
+    HIGO_LAYER_SD_1,
+    HIGO_LAYER_HD_0,
+    HIGO_LAYER_HD_1,
+    HIGO_LAYER_HD_2,
+    HIGO_LAYER_HD_3,
+    HIGO_LAYER_AD_0,
+    HIGO_LAYER_AD_1,
+    HIGO_LAYER_BUTT,
+}HIGO_LAYER_E;
+
+/**Standard-definition (SD) graphics layer 0*/
+/** CNcomment:0 */
+#define HIGO_LAYER_RGB0 HIGO_LAYER_SD_0
+
+/**SD graphics layer 1*/
+/** CNcomment:1 */
+#define HIGO_LAYER_RGB1 HIGO_LAYER_SD_1
+
+#define GRAPHICS_LAYER_MAX_NUM 4
+/** The following macro defines the buffer mode of each graphics layer of the HiGo. The canvas buffer is used for drawing,
+and the display buffer is used for display output.*/
+/** CNcomment:higobuffercanvas bufferbuffer, display bufferbuffer.*/
+#define HIGO_LAYER_BUFFER_SINGLE      0x02 /**<One canvas buffer, and no display buffer*//**<CNcomment:1canvas buffer, display buffer */
+#define HIGO_LAYER_BUFFER_DOUBLE      0x04 /**<One canvas buffer, and one display buffer. Dual buffers are supported.*//**<CNcomment:1canvas buffer, 1display buffer  */
+#define HIGO_LAYER_BUFFER_TRIPLE      0x08 /**<One canvas buffer, and two display buffers. The flip function is supported.*//**<CNcomment:1canvas buffer, 2display buffer flip, */
+#define HIGO_LAYER_BUFFER_OVER        0x10 /**<One canvas buffer, and two display buffers. The flip function is supported. If tasks are being performed during refresh, the current frame is discarded.*//**<CNcomment:1canvas buffer, 2display buffer flip, */
+
+/**Refresh mode of graphics layers for complying with old definitions. The mode is not recommended.*/
+/** CNcomment:*/
+typedef enum
+{
+    HIGO_LAYER_FLUSH_FLIP        = HIGO_LAYER_BUFFER_TRIPLE,
+    HIGO_LAYER_FLUSH_DOUBBUFER   = HIGO_LAYER_BUFFER_DOUBLE,
+    HIGO_LAYER_FLUSH_NORMAL      = HIGO_LAYER_BUFFER_SINGLE,
+    HIGO_LAYER_FLUSH_OVER        = HIGO_LAYER_BUFFER_OVER,
+    HIGO_LAYER_FLUSH_BUTT
+} HIGO_LAYER_FLUSHTYPE_E;
+
+/**Anti-flicker level, ranging from low to high. The higher the level, the better the anti-flicker effect, but the more blurred the picture.*/
+/** CNcomment:LOW~HIGH,*/
+typedef enum
+{
+    HIGO_LAYER_DEFLICKER_NONE = 0,
+    HIGO_LAYER_DEFLICKER_LOW,
+    HIGO_LAYER_DEFLICKER_MIDDLE,
+    HIGO_LAYER_DEFLICKER_HIGH,
+    HIGO_LAYER_DEFLICKER_AUTO,
+    HIGO_LAYER_DEFLICKER_BUTT
+}HIGO_LAYER_DEFLICKER_E;
+
+/**Frame encode format*/
+/** CNcomment:*/
+typedef enum
+{
+    HIGO_ENCPICFRM_MONO   = 0x0,            /**<Normal display, no 3D TV*//**<CNcomment:3D */
+    HIGO_ENCPICFRM_STEREO_SIDEBYSIDE_HALF,  /**< L/R frames are downscaled horizontally by 2 andpacked side-by-side into a single frame, left on lefthalf of frame*//**<CNcomment:L/R*/
+    HIGO_ENCPICFRM_STEREO_TOPANDBOTTOM,     /**< L/R frames are downscaled vertically by 2 andpacked into a single frame, left on top*//**<CNcomment:L/R*/
+    HIGO_ENCPICFRM_BUTT
+}HIGO_ENCPICFRM_E;
+
+/**3D STEREO mode*/
+/** CNcomment:3D STEREO*/
+typedef enum
+{
+    HIGO_STEREO_MODE_HW_FULL = 0x0,  /**< 3d stereo function use hardware and transfer full frame to vo, note: hardware doesn't support the mode if encoder picture delivery method is top and bottom */
+    HIGO_STEREO_MODE_HW_HALF ,       /**< 3d stereo function use hardware and transfer half frame to vo*/
+    HIGO_STEREO_MODE_SW_EMUL,        /**<3d stereo function use software emulation */
+    HIGO_STEREO_MODE_BUTT
+}HIGO_STEREO_MODE_E;
+
+/**Layer attribute parameters*/
+/** CNcomment:*/
+typedef struct
+{
+    HI_S32                 ScreenWidth;    /**<Height of a graphics layer on the screen. The value must be greater than 0.*//**<CNcomment:0 */
+    HI_S32                 ScreenHeight;   /**<Width of a graphics layer on the screen. The value must be greater than 0.*//**<CNcomment:0 */
+    HI_S32                 CanvasWidth;    /**<Width of the canvas buffer of a graphics layer. If the value is 0, no canvas buffer is created.*//**<CNcomment:buffer0buffer */
+    HI_S32                 CanvasHeight;   /**<Height of the canvas buffer of a graphics layer. If the value is 0, no canvas buffer is created.*//**<CNcomment:buffer0buffer */
+    HI_S32                 DisplayWidth;   /**<Width of the display buffer of a graphics layer. If the value is 0, the value of ScreenWidth is used.*//**<CNcomment:buffer0ScreenWidth*/
+    HI_S32                 DisplayHeight;  /**<Height of the display buffer of a graphics layer. If the value is 0, the value of ScreenHeight is used.*//**<CNcomment:buffer0ScreenHeight*/
+    HIGO_LAYER_FLUSHTYPE_E LayerFlushType; /**< Refresh mode of the layer. You can choose the refresh mode based on the actual scenario to improve the refresh efficiency. If the value is 0, the dual-buffer+flip refresh mode is used by default. *//**<CNcomment:,0+Flip */
+    HIGO_LAYER_DEFLICKER_E AntiLevel;      /**<Anti-flicker level of a graphics layer*//**<CNcomment: */
+    HIGO_PF_E              PixelFormat;    /**<Pixel format of a graphics layer. The format must be supported by the hardware layer. You need to choose the pixel format parameters of the layer based on hardware devices.*//**<CNcomment: */
+    HIGO_LAYER_E           LayerID;        /**<Hardware ID of a graphics layer. The supported graphics layer depends on the chip platform. For example, the Hi3720 supports an HD graphics layer and an SD graphics layer.*//**<CNcomment:ID */
+} HIGO_LAYER_INFO_S;
+
+/**Status of a graphics layer*/
+/** CNcomment: */
+typedef struct
+{
+    HI_BOOL bShow;             /**<Whether to display a graphics layer.*//**<CNcomment: */
+} HIGO_LAYER_STATUS_S;
+
+typedef struct
+{
+    HI_COLOR ColorKey;         /**<Transparency of a graphics layer*//**<CNcomment:*/
+    HI_BOOL bEnableCK;         /**<Whether the colorkey of a graphics layer is enabled.*//**<CNcomment:colorkey */
+}HIGO_LAYER_KEY_S;
+
+typedef struct
+{
+    HI_BOOL bAlphaEnable;   /**<Alpha pixel enable flag*//**<CNcomment:alpha */
+    HI_BOOL bAlphaChannel;  /**<Alpha channel enable flag*//**<CNcomment:alpha  */
+    HI_U8   Alpha0;         /**<Alpha0 value. It is valid in ARGB1555 format.*//**<CNcomment:alpha0,ARGB1555 */
+    HI_U8   Alpha1;         /**<Alpha1 value. It is valid in ARGB1555 format.*//**<CNcomment:alpha1,ARGB1555 */
+    HI_U8   GlobalAlpha;    /**<Global alpha. This value is valid only when the alpha channel is valid.*//**<CNcomment:alphaalpha */
+}HIGO_LAYER_ALPHA_S;
+
+typedef struct
+{
+    HI_HANDLE   Layer;          /** The layer the scrolltext want to show */
+    HI_RECT       stScrollRect;   /** the position you wanted to show on the layer */
+    HIGO_PF_E   ePixelFormat;    /** the color format of scrolltext content */
+    HI_U16        u16CacheNum;       /** The cached buffer number for store scrolltext content */
+    HI_U16        u16RefreshFreq;    /** The refresh frequency you wanted */
+    HI_BOOL     bDeflicker;        /** Whether enable antificker */
+} HIGO_SCROLLTEXT_ATTR_S;
+
+typedef struct
+{
+    HI_U32 u32PhyAddr;   /** The physical address of the scrolltext content buffer */
+    HI_U8  *pu8VirAddr;  /** The virtual address of the scrolltext content buffer */
+    HI_U32 u32BufferLen; /** The virtual or physical address Length of the scrolltext content buffer */
+    HI_U32 u32Stride;    /** The stride of the scrolltext content buffer */
+} HIGO_SCROLLTEXT_DATA_S;
+
+
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_GDEV */
+/** @{ */  /** <!--[HIGO_GDEV] */
+
+/**
+\brief Initializes a display device. CNcomment: CNend
+\attention \n
+When ::HI_GO_Init is called, this API is also called.
+CNcomment: ::HI_GO_Init CNend
+\param N/A. CNcomment: CNend
+
+\retval ::HI_FAILURE
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INITFAILED
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDisplay
+*/
+HI_S32 HI_GO_InitDisplay(HI_VOID);
+
+/**
+\brief Deinitializes a display device. CNcomment: CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit CNend
+\param N/A. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDisplay
+*/
+HI_S32 HI_GO_DeinitDisplay(HI_VOID);
+
+/**
+\brief Obtains the default parameters of an SD or HD graphics layer based on its ID.
+If you do not want to use default values, you can set the members of pLayerInfo.
+CNcomment:ID(SD,HD)
+pLayerInfo CNend
+\attention \n
+
+\param[in] LayerID Layer ID. CNcomment:ID CNend
+\param[in]  pLayerInfo Obtained parameters of a graphics layer when it is created. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVPARAM
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_GetLayerDefaultParam (HIGO_LAYER_E LayerID, HIGO_LAYER_INFO_S *pLayerInfo);
+
+
+/**
+\brief Creates a graphics layer. CNcomment: CNend
+\attention \n
+The platform determines whether VO hardware scaling is supported.
+If VO hardware scaling is supported, the display size is scaled to fit the screen when the display size is inconsistent with the screen size.
+If VO hardware scaling is not supported, the display size and screen size must be the same.
+CNcomment:VO
+VO displaysizescreensizescreensize
+VO displaysizescreensizedisplaysizescreensize CNend
+
+\param[in]  pLayerInfo Basic attributes of a graphics layer. The value cannot be empty. CNcomment: CNend
+\param[out] pLayer Pointer to the handle of a graphics layer. The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVFLUSHTYPE
+\retval ::HIGO_ERR_INVANILEVEL
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_ALREADYBIND
+\retval ::HIGO_ERR_INVLAYERSURFACE
+
+\see \n
+::HI_GO_DestroyLayer
+*/
+HI_S32 HI_GO_CreateLayer (const HIGO_LAYER_INFO_S *pLayerInfo, HI_HANDLE* pLayer);
+
+/**
+\brief Destroys a graphics layer. CNcomment: CNend
+\attention \n
+If a graphics layer is in use (for example, the desktop based on the layer is not destroyed), the layer cannot be destroyed.
+CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+
+
+\see \n
+::HI_GO_CreateLayer
+*/
+HI_S32 HI_GO_DestroyLayer(HI_HANDLE Layer);
+
+
+/**
+\brief Sets the position of a graphics layer on the screen. CNcomment: CNend
+\attention \n
+The value takes effect at once and you do not need to refresh it. If the start position of a layer exceeds the screen, it is automatically adjusted to the boundary of the screen.
+CNcomment: CNend
+\param[in] Layer  Layer handle. CNcomment: CNend
+\param[in] u32StartX Horizontal coordinate of the position where a layer appears on the screen. CNcomment:X CNend
+\param[in] u32StartY Vertical coordinate of the position where a layer appears on the screen. CNcomment:Y CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERPOS
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerPos
+*/
+HI_S32 HI_GO_SetLayerPos(HI_HANDLE Layer, HI_U32 u32StartX, HI_U32 u32StartY);
+
+/**
+\brief Obtains the position where a layer appears on the screen. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[out] pStartX Pointer of the horizontal coordinate of the position where a layer appears on the screen. The value cannot be empty. CNcomment:X CNend
+\param[out] pStartY Pointer of the vertical coordinate of the position where a layer appears on the screen. The value cannot be empty. CNcomment:Y CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetLayerPos
+*/
+HI_S32 HI_GO_GetLayerPos(HI_HANDLE Layer, HI_U32 *pStartX, HI_U32 *pStartY);
+
+
+/**
+\brief Sets the output height and width of a graphics layer on the display device. CNcomment: CNend
+\attention \n
+This API supports zoom in operations. The maximum range is specified when a graphics layer is created.\n
+CNcomment: CNend
+
+\param[in]  Layer Layer handle. CNcomment: CNend
+\param[in] u32SWidth  Actual output width. CNcomment: CNend
+\param[in] u32SHeight Actual output height. CNcomment: CNend
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetScreenSize
+*/
+HI_S32 HI_GO_SetScreenSize(HI_HANDLE Layer, HI_U32 u32SWidth, HI_U32 u32SHeight);
+
+
+/**
+\brief Obtains the output height and width of a graphics layer on the display device. CNcomment:CNend
+\attention \n
+N/A. CNcomment: CNend
+\param[in]  Layer Layer handle. CNcomment: CNend
+\param[out] pSWidth  Pointer to the actual output width. CNcomment: CNend
+\param[out] pSHeight Pointer to the actual output height. CNcomment: CNend
+\retval none
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetScreenSize
+*/
+HI_S32 HI_GO_GetScreenSize(HI_HANDLE Layer, HI_U32 *pSWidth, HI_U32 *pSHeight);
+
+/**
+\brief Sets the global alpha value of a layer surface. CNcomment:surfacealpha CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in] Alpha Global alpha value. The value cannot be empty and ranges from 0 to 255. CNcomment:Alpha alpha0-255 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_SETALPHAFAILED
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerAlpha
+*/
+
+HI_S32 HI_GO_SetLayerAlpha(HI_HANDLE Layer, HI_U8 Alpha);
+
+/**
+\brief Sets layer premul state. CNcomment: CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in] enable or disable layer premu. CNcomment:CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+
+\see \n
+::HI_GO_SetLayerPreMul
+*/
+HI_S32 HI_GO_SetLayerPreMul(HI_HANDLE Layer, HI_BOOL bPreMul);
+
+
+/**
+\brief Obtains the global alpha value of a layer surface. CNcomment:surfacealpha CNend
+\attention \n
+N/A. CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[out] pAlpha Pointer to the global alpha value. CNcomment:alpha CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetLayerAlpha
+*/
+HI_S32 HI_GO_GetLayerAlpha(HI_HANDLE Layer, HI_U8* pAlpha);
+
+
+/**
+\brief Obtains the surface of a graphics layer. CNcomment:surface CNend
+\attention \n
+Surface of a graphics layer. It cannot be released by calling HI_GO_FreeSurface. The surface can be released only when the corresponding layer is destroyed.
+After a process is switched, you must obtain the layer surface again by calling HI_S32 HI_GO_GetLayerSurface.
+CNcomment:surfaceHI_GO_FreeSurface
+surface; CNend
+\param[in] Layer handle. CNcomment:Layer  CNend
+\param[out] pSurface Pointer to the surface handle. The value cannot be empty. CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_GetLayerSurface(HI_HANDLE Layer, HI_HANDLE *pSurface);
+
+/**
+\brief Shows or hides a graphics layer. CNcomment: CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in] bVisbile Show/hide flag. HI_TRUE: show; HI_FALSE: hide. CNcomment:HI_TRUEHI_FALSE CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerStatus
+*/
+HI_S32 HI_GO_ShowLayer(HI_HANDLE Layer, HI_BOOL bVisbile);
+
+/**
+\brief Obtains the current status of a graphics layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[out] pLayerStatus Pointer to the current status of a graphics layer. The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_ShowLayer
+*/
+HI_S32 HI_GO_GetLayerStatus(HI_HANDLE Layer, HIGO_LAYER_STATUS_S* pLayerStatus);
+
+/**
+\brief Refreshes a graphics layer. CNcomment: CNend
+\attention \n
+1. After drawing, you need to refresh the layer to display the drawing result.
+2. There are two display modes after a graphics layer is refreshed. If there is no window, the contents of the layer surface are displayed; if there is a window, its contents are displayed.
+CNcomment:1.
+2.layersurfaceCNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in]  pRect Rectangle to be refreshed. If the value is NULL, the entire screen is refreshed. CNcomment:NULL,  CNend
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_EMPTYRECT
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_RefreshLayer(HI_HANDLE Layer, const HI_RECT* pRect);
+
+
+/**
+\brief Sets the canvas buffer of a graphics layer. CNcomment:canvas surface. CNend
+\attention \n
+If the stream sources of the HD and SD graphics layer are the same, the canvas buffer of the SD graphics layer can be shared with the HD graphics layer.
+CNcomment:canvas buffer
+     SurrfaceMMZ. CNend
+\param[in] Layer     Layer handle. CNcomment: CNend
+\param[in] hSurface  Surface of a graphics layer. If the value is INVALID_HANDLE, there is no user handle. CNcomment:surfaceINVALID_HANDLE CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVPARAM
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_SetLayerSurface(HI_HANDLE Layer, HI_HANDLE hSurface);
+
+
+
+/**
+\brief Sets the background color of a graphics layer. CNcomment: CNend
+\attention \n
+The background color of a graphics layer takes effect only when widows are overlaid with each other.
+CNcomment: CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in] Color Background color of a graphics layer. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_SetLayerBGColor(HI_HANDLE Layer, HI_COLOR Color);
+
+/**
+\brief Obtains the background color of a graphics layer. CNcomment: CNend
+\attention \n
+This API is available only when there are windows on graphics layers. Otherwise, the configured background color does not take effect.
+CNcomment:CNend
+\param[in] Layer Layer handle. CNcomment: CNend
+\param[in] pColor Used for storing the background color of a graphics layer. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A. CNcomment: CNend
+*/
+HI_S32 HI_GO_GetLayerBGColor(HI_HANDLE Layer, HI_COLOR* pColor);
+
+/**
+\brief Sets the size of a display buffer. CNcomment:buffer size CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer      Layer handle. CNcomment: CNend
+\param[in] u32DWidth     Pointer to the width. CNcomment: CNend
+\param[in] u32DHeight    Pointer to the height. CNcomment: CNend
+\param[out] N/A . CNcomment:  CNend
+
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_GetDisplaySize
+*/
+HI_S32 HI_GO_SetDisplaySize(HI_HANDLE Layer, HI_U32 u32DWidth, HI_U32 u32DHeight);
+
+/**
+\brief Obtains the size of a display buffer. CNcomment:buffersize CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer      Layer handle. CNcomment: CNend
+\param[in] pDWidth    Pointer to the width. The value cannot be empty. CNcomment:  CNend
+\param[in] pDHeight   Pointer to the height. The value cannot be empty. CNcomment: CNend
+\param[out] N/A. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_SetDisplaySize
+*/
+HI_S32 HI_GO_GetDisplaySize(HI_HANDLE Layer, HI_U32 *pDWidth, HI_U32 *pDHeight);
+
+/**
+\brief Sets the refresh mode. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer         Layer handle. CNcomment: CNend
+\param[in] FlushType     Refresh mode of a graphics layer. CNcomment: CNend
+\param[out] N/A. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVFLUSHTYPE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetFlushType
+*/
+HI_S32 HI_GO_SetFlushType(HI_HANDLE Layer, HIGO_LAYER_FLUSHTYPE_E FlushType);
+
+/**
+\brief Obtains the refresh mode. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment:  CNend
+\param[in] *pFlushType Refresh mode of a graphics layer. The value cannot be empty. CNcomment:  CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetFlushType
+*/
+HI_S32 HI_GO_GetFlushType(HI_HANDLE Layer, HIGO_LAYER_FLUSHTYPE_E *pFlushType);
+
+/**
+\brief Sets the transparency of a graphics layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment:  CNend
+\param[in] pKey        Pointer to the transparency information. The value cannot be empty. CNcomment: CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetLayerColorkey
+*/
+HI_S32 HI_GO_SetLayerColorkey(HI_HANDLE Layer, const HIGO_LAYER_KEY_S *pKey);
+
+/**
+\brief Obtains the transparency information about a graphics layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] pKey        Pointer to the transparency information. CNcomment: CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerColorkey
+*/
+HI_S32 HI_GO_GetLayerColorkey(HI_HANDLE Layer, HIGO_LAYER_KEY_S *pKey);
+
+/**
+\brief Sets the palette of a graphics layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] Palette     Palette of a graphics layer. CNcomment: CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetLayerPalette
+*/
+HI_S32 HI_GO_SetLayerPalette(HI_HANDLE Layer, const HI_PALETTE Palette);
+
+/**
+\brief Obtains the palette of a graphics layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] Palette     Palette of a graphics layer. CNcomment: CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerPalette
+*/
+HI_S32 HI_GO_GetLayerPalette(HI_HANDLE Layer, HI_PALETTE Palette);
+
+/**
+\brief Waits for the blanking area. CNcomment: CNend
+\attention \n
+N/A
+CNcomment:  CNend
+\param[in] Layer       Layer handle. CNcomment:  CNend
+\param[out] N/A. CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerPalette
+*/
+HI_S32 HI_GO_WaitForBlank(HI_HANDLE Layer);
+
+
+/**
+\brief Configures the alpha information about a graphics layer. This API is an extended API. CNcomment:alpha CNend
+\attention \n
+The alpha0 and alpha1 of the data structure HIGO_LAYER_ALPHA_S are valid only in ARGB1555 format.
+This API is used to implement the translucent effect in ARGB1555 format.
+CNcomment:HIGO_LAYER_ALPHA_Salpha0,alpha1ARGB1555
+ARGB1555 CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] pAlphaInfo   Alpha information about a graphics layer. The value cannot be empty. CNcomment:alpha CNend
+\param[out] N/A.
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerAlphaEx
+*/
+HI_S32 HI_GO_SetLayerAlphaEx(HI_HANDLE Layer,  HIGO_LAYER_ALPHA_S *pAlphaInfo);
+
+
+/**
+\brief Obtains the alpha information about a graphics layer. This API is an extended API. CNcomment:alpha CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[out] pAlphaInfo  Alpha information about a graphics layer. The value cannot be empty. CNcomment:alpha CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerAlphaEx
+*/
+HI_S32 HI_GO_GetLayerAlphaEx(HI_HANDLE Layer,  HIGO_LAYER_ALPHA_S *pAlphaInfo);
+
+/**
+\brief set the Z order of graphics layer in the sample display. CNcomment:ZCNend
+\attention \n
+this function make effect imediately. CNcomment:Z CNend
+\param[in] Layer Layer handle. CNcomment:  CNend
+\param[in] ZFlag zorder flag. CNcomment:Z CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVORDERFLAG
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_CANNOTCHANGE
+
+\see \n
+::HI_GO_GetLayerZorder
+*/
+HI_S32 HI_GO_SetLayerZorder(HI_HANDLE Layer, HIGO_ZORDER_E enZOrder);
+
+/**
+\brief get the Z order of graphics layer in the sample display. CNcomment:ZCNend
+\attention \n
+CNcomment:Z CNend
+\param[in] Layer    Layer handle. CNcomment:  CNend
+\param[out] pZOrder Z Order Information. CNcomment:ZCNend
+
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_ChangeLayerZorder
+*/
+HI_S32 HI_GO_GetLayerZorder(HI_HANDLE Layer, HI_U32* pu32ZOrder);
+
+/**
+\brief Sets frame input encode mode of a graphic layer. CNcomment:3DVOCNend
+\attention \n
+MONO is the default mode.
+CNcomment:MONO3D Stereo. CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] EncPicFrm  Frame encode mode.The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoMode
+*/
+HI_S32 HI_GO_SetStereoMode(HI_HANDLE Layer,  HIGO_STEREO_MODE_E InputEnc);
+
+
+
+/**
+\brief Obtains frame encode mode of a graphic layer. CNcomment:3DCNend
+\attention \n
+CNcomment: CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[out] pInputEnc  Frame encode mode.The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetStereoMode
+*/
+HI_S32 HI_GO_GetStereoMode(HI_HANDLE Layer,  HIGO_STEREO_MODE_E *pInputEnc);
+
+
+/**
+\brief set the 3d depth, only support depth in Horizontal . CNcomment:, CNend
+\attention \n
+CNcomment: CNend
+
+\param[in]  Layer       Layer handle. CNcomment: CNend
+\param[out] StereoDepth  3D depth. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoDepth
+*/
+HI_S32 HI_GO_SetStereoDepth(HI_HANDLE Layer,  HI_S32  s32StereoDepth);
+
+
+/**
+\brief get the 3d depth, only support depth in Horizontal . CNcomment:, CNend
+\attention \n
+CNcomment: CNend
+
+\param[in]  Layer       Layer handle. CNcomment: CNend
+\param[out] pStereoDepth  3D depth. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoDepth
+*/
+HI_S32 HI_GO_GetStereoDepth(HI_HANDLE Layer,  HI_S32  *ps32StereoDepth);
+
+/**
+\brief Sets compress mode of a graphic layer. CNcomment: CNend
+\attention \n
+When compress is enable, only HIGO_PF_8888 is supported;SD layer and  STEREO TOPANDBOTTOM
+are also not supported.
+CNcomment:HIGO_PF_88883D STEREO TOPANDBOTTOM CNend
+
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[in] StereoMode  Stereo mode, the value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoMode
+*/
+HI_S32 HI_GO_SetCompression(HI_HANDLE Layer,  HI_BOOL bEnable);
+
+
+/**
+\brief Sets compress mode of a graphic layer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+\param[in] Layer       Layer handle. CNcomment: CNend
+\param[out] pbEnable  Stereo mode, the value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetStereoMode
+*/
+HI_S32 HI_GO_GetCompression(HI_HANDLE Layer,  HI_BOOL* pbEnable);
+
+/**
+\brief Create ScrollText. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] pstScrollAttr  ScrollText attribute,the value cannot be empty. CNcomment: CNend
+\param[out] phScrollText  ScrollText handle. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_INUSE
+
+\see \n
+    ::HI_GO_CreateScrollText
+*/
+HI_S32 HI_GO_CreateScrollText(HIGO_SCROLLTEXT_ATTR_S * pstScrollAttr, HI_HANDLE * phScrollText);
+
+
+/**
+\brief Fill data to ScrollText cache buffer. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] hScrollText  ScrollText handle.     CNcomment: CNend
+\param[out] pstScrollData ScrollText data information. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_FillScrollText
+*/
+HI_S32 HI_GO_FillScrollText(HI_HANDLE hScrollText, HIGO_SCROLLTEXT_DATA_S * pstScrollData);
+
+
+/**
+\brief Pause the ScrollText. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] hScrollText  ScrollText handle.   CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_PauseScrollText
+*/
+HI_S32  HI_GO_PauseScrollText(HI_HANDLE hScrollText);
+
+
+/**
+\brief Resume the ScrollText,the ScrollText has Paused. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] hScrollText  ScrollText handle.  CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_ResumeScrollText
+*/
+HI_S32  HI_GO_ResumeScrollText(HI_HANDLE hScrollText);
+
+
+/**
+\brief Destroy ScrollText. CNcomment: CNend
+\attention \n
+N/A. CNcomment: CNend
+
+\param[in] hScrollText ScrollText handle.  CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_DestoryScrollText
+*/
+HI_S32  HI_GO_DestoryScrollText(HI_HANDLE hScrollText);
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_GDEV_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_surface.h b/xbmc/platform/linux/hisi/hi_go_surface.h
new file mode 100644
index 0000000000..7f90c436a1
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_surface.h
@@ -0,0 +1,808 @@
+#ifndef __HI_GO_SURFACE_H__
+#define __HI_GO_SURFACE_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+typedef enum
+{
+    HIGO_PF_CLUT8 = 0,  /**<Palette*//**<CNcomment: */
+    HIGO_PF_CLUT1,
+    HIGO_PF_CLUT4,
+    HIGO_PF_4444,       /**<Each pixel occupies 16 bits, and the A/R/G/B components each occupies 4 bits. They are sorted by address in descending order.*//**<CNcomment:16bitARGB4bit */
+    HIGO_PF_0444,       /**<Each pixel occupies 16 bits, and the A/R/G/B components each occupies 4 bits. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:16bitARGB4bit, A */
+
+    HIGO_PF_1555,       /**<Each pixel occupies 16 bits, the R/G/B components each occupies 5 bits, and the A component occupies 1 bit. They are sorted by address in descending order.*//**<CNcomment:16bitRGB5bitA1bit */
+    HIGO_PF_0555,       /**<Each pixel occupies 16 bits, the R/G/B components each occupies 5 bits, and the A component occupies 1 bit. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:16bitRGB5bitA1bit, A */
+    HIGO_PF_565,        /**<Each pixel occupies 16 bits, and the R/G/B components each occupies 5 bits, 6 bits, and 5 bits respectively. They are sorted by address in descending order.*//**<CNcomment:16bitRGB5bit6bit5bit */
+    HIGO_PF_8565,       /**<Each pixel occupies 24 bits, and the A/R/G/B components each occupies 8 bits, 5 bits, 6 bits, and 5 bits respectively. They are sorted by address in descending order.*//**<CNcomment:24bitARGB8bit, 5bit6bit5bit */
+    HIGO_PF_8888,       /**<Each pixel occupies 32 bits, and the A/R/G/B components each occupies 8 bits. They are sorted by address in descending order.*//**<CNcomment:32bitARGB8bit */
+    HIGO_PF_0888,       /**<Each pixel occupies 24 bits, and the A/R/G/B components each occupies 8 bits. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:24bitARGB8bitA */
+
+    HIGO_PF_YUV400,     /**<Semi-planar YUV 400 format defined by HiSilicon*//**<CNcomment:semi-planar YUV 400 */
+    HIGO_PF_YUV420,     /**<Semi-planar YUV 420 format defined by HiSilicon*//**<CNcomment:semi-planar YUV 420 */
+    HIGO_PF_YUV422,     /**<Semi-planar YUV 422 format and horizontal sampling format defined by HiSilicon*//**<CNcomment:semi-planar YUV 422  */
+    HIGO_PF_YUV422_V,   /**<Semi-planar YUV 422 format and vertical sampling format defined by HiSilicon*//**<CNcomment:semi-planar YUV 422  */
+    HIGO_PF_YUV444,     /**<Semi-planar YUV 444 format defined by HiSilicon*//**<CNcomment:semi-planar YUV 444 */
+
+	HIGO_PF_A1,
+	HIGO_PF_A8,
+
+    HIGO_PF_YUV888,
+    HIGO_PF_YUV8888,
+	HIGO_PF_RLE8,
+    HIGO_PF_BUTT
+} HIGO_PF_E;
+/** @} */  /*! <!-- Macro Definition end */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+/**Component type*/
+/** CNcomment: */
+typedef enum
+{
+    HIGO_PDFORMAT_RGB = 0,
+    HIGO_PDFORMAT_RGB_PM,   /**< pre-multiplied */
+    HIGO_PDFORMAT_Y,
+    HIGO_PDFORMAT_UV,
+    HIGO_PDFORMAT_UV_LE,
+
+    HIGO_PDFORMAT_BUTT
+} HIGO_PDFORMAT_E;
+
+typedef struct
+{
+    HIGO_PDFORMAT_E Format;     /**<Component type*//**<CNcomment: */
+    HI_VOID*        pData;      /**<Pointer to the virtual address of a component*//**<CNcomment: */
+    HI_VOID*        pPhyData;   /**<Pointer to the physical address of a component*//**<CNcomment: */
+    HI_U32          Pitch;      /**<Component pitch*//**<CNcomment: */
+    HI_U32          Bpp;        /**<Bytes per pixel*//**<CNcomment:bytes per pixel */
+    HI_U32          Offset;
+} HIGO_PIXELDATA_S;
+
+/**Maximum number of data components*/
+/** CNcomment: */
+#define MAX_PARTPIXELDATA 3
+
+/**The following sync modes can be used together. The non-automatic sync mode is also available.*/
+/** CNcomment: */
+typedef enum
+{
+    HIGO_SYNC_MODE_CPU = 0x01, /*Sync mode. In this mode, CPU operations are required.*//**<CNcomment:CPU*/
+    HIGO_SYNC_MODE_TDE = 0x02, /*Sync mode. In this mode, the 2D acceleration operation is required.*//**<CNcomment:2D*/
+    HIGO_SYNC_MODE_BUTT,
+} HIGO_SYNC_MODE_E;
+
+
+typedef enum
+{
+    HIGO_MEMTYPE_MMZ = 0,       /**<The memory is an media memory zone (MMZ) memory.*//**<CNcomment:MMZ */
+    HIGO_MEMTYPE_OS,            /**<The memory is an operating system (OS) memory.*//**<CNcomment: */
+    HIGO_MEMTYPE_BUTT
+}HIGO_MEMTYPE_E;
+
+typedef enum
+{
+	HIGO_OWNER_USER = 0,        /**<The memory is managed by users. That is, the memory is allocated and destroyed by users.*//**<CNcomment: */
+	HIGO_OWNER_HIGO,            /**<The memory is managed by the HiGo module rather than users.*//**<CNcomment:HIGO */
+	HIGO_OWNER_BUTT
+}HIGO_OWNER_E;
+
+typedef struct
+{
+    HI_S32 Width;                               /**<Surface width*//**<CNcomment:surface */
+    HI_S32 Height;                              /**<Surface height*//**<CNcomment:surface */
+    HIGO_PF_E PixelFormat;                      /**<Pixel format of a surface*//**<CNcomment:surface*/
+    HI_U32   Pitch[MAX_PARTPIXELDATA];          /**<Pitch of a surface*//**<CNcomment:surface*/
+    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];       /**<Physical address of a surface*//**<CNcomment:surface*/
+    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**<Virtual address of a surface*//**<CNcomment:surface*/
+    HIGO_MEMTYPE_E MemType;                     /**<Type of the surface memory*//**<CNcomment:surface*/
+    HI_BOOL bPubPalette;                        /**<Use common Palette or not*//**<CNcomment:;Clut.
+                                                    ,*/
+}HIGO_SURINFO_S;
+
+typedef struct
+{
+    HI_S32 Width;                               /**<Surface width*//**<CNcomment:surface */
+    HI_S32 Height;                              /**<Surface height*//**<CNcomment:surface */
+    HIGO_PF_E PixelFormat;                      /**<Pixel format of a surface*//**<CNcomment:surface*/
+
+    /**<Pitch of a surface
+    Pitch[0] indicates the pitch in RGB format or the pitch of the Y component in semi-planar format.
+     Pitch[1] indicates the pitch of the C component in semi-planar format.
+     Pitch[2] is reserved.*/
+    /**<CNcomment:surface
+     Pitch[0]RGB Semi-plannerY
+     Pitch[1]Semi-plannerC
+     Pitch[2]*/
+    HI_U32   Pitch[MAX_PARTPIXELDATA];
+
+    /**<Physical address of a surface
+    pPhyAddr[0] indicates the physical address in RGB format or the physical address of the Y component in semi-planar format.
+    pPhyAddr[1] indicates the physical address of the C component in semi-planar format.*/
+    /**<CNcomment:surface
+    pPhyAddr[0]RGB Semi-plannerY
+    pPhyAddr[1]Semi-plannerC*/
+    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];
+
+    /**<Virtual address of a surface
+    pVirAddr[0] indicates the virtual address in RGB format or the virtual address of the Y component in semi-planar format.
+    pVirAddr[1] indicates the virtual address of the C component in semi-planar format.*/
+    /**<CNcomment:surface
+    pVirAddr[0]RGB Semi-plannerY
+    pVirAddr[1]Semi-plannerC*/
+    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**<CNcomment: surface
+                                                     pVirAddr[0]RGB Semi-plannerY
+                                                     pVirAddr[1]Semi-plannerC
+                                                */
+    HIGO_MEMTYPE_E MemType;                     /**<Type of the surface memory*//**<CNcomment:surface*/
+    HI_BOOL bPubPalette;        /**<Use common Palette or not*//**<CNcomment:;Clut*/
+    HIGO_OWNER_E   MemOwner;                    /**<Memory source. For example, the memory is allocated by users or the HiGo module.*//**<CNcomment:,,HIGO*/
+}HIGO_SURINFOEX_S;
+
+/**Data component structure*/
+/** CNcomment: */
+typedef HIGO_PIXELDATA_S HI_PIXELDATA[MAX_PARTPIXELDATA];
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+/**
+\brief Initializes the surface module. CNcomment:Surface CNend
+\attention \n
+When ::HI_GO_Init is called, this API is also called.
+CNcomment: ::HI_GO_Init CNend
+\param N/A
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+
+\see \n
+::HI_GO_DeinitSurface
+*/
+HI_S32 HI_GO_InitSurface(HI_VOID);
+
+/**
+\brief Deinitializes the surface module. CNcomment:Surface CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit CNend
+\param N/A
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_InitSurface
+*/
+HI_S32 HI_GO_DeinitSurface(HI_VOID);
+
+/**
+\brief Sets the alpha value of a surface. CNcomment:surfacealpha CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[in]  Alpha Alpha value, ranging from 0 to 255. The value 0 indicates transparent, and the value 255 indicates opaque. CNcomment:Alpha0-2550255 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_GetSurfaceAlpha
+*/
+HI_S32 HI_GO_SetSurfaceAlpha(HI_HANDLE Surface, HI_U8 Alpha);
+
+/**
+\brief Obtains the alpha value of a surface. CNcomment:surfacealpha CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[out] pAlpha Pointer to the received alpha value. The pointer cannot be null. CNcomment:alhpa CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+::HI_GO_SetSurfaceAlpha
+*/
+HI_S32 HI_GO_GetSurfaceAlpha(HI_HANDLE Surface, HI_U8* pAlpha);
+
+/**
+\brief Enables or disables the colorkey of a surface. CNcomment:surfacecolorkey CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+\param[in] Enable Colorkey enable. HI_TRUE: enabled; HI_FALSE: disabled. CNcomment:colorKeyHI_TRUEHI_FALSE CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_EnableSurfaceColorKey(HI_HANDLE Surface, HI_BOOL Enable);
+
+/**
+\brief Sets the colorkey value of a surface. CNcomment:surfacecolorKey CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+\param[in] ColorKey Colorkey value. For the RGB format, the colorkey is padded with 32-bit colors. For the CLUT format, the colorkey is padded with color index. CNcomment:Colorkey, RGB32bitCLUTCNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_GetSurfaceColorKey
+*/
+HI_S32 HI_GO_SetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR ColorKey);
+
+/**
+\brief Obtains the colorkey value of a surface. CNcomment:surfacecolorkey CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[out] pColorKey Pointer to the received colorkey value. The value cannot be empty. CNcomment:colorkey CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOCOLORKEY
+
+\see \n
+::HI_GO_SetSurfaceColorKey
+*/
+HI_S32 HI_GO_GetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR* pColorKey);
+
+/**
+\brief Sets the palette of a surface. CNcomment:Surface CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+\param[in] Palette Palette. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACEPF
+
+\see \n
+::HI_GO_GetSurfaceColorKey
+*/
+HI_S32 HI_GO_SetSurfacePalette(HI_HANDLE Surface, const HI_PALETTE Palette);
+
+/**
+\brief Obtains the palette of a surface. CNcomment:surface CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[out] Palette Pointer to the received palette. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACEPF
+
+\see \n
+::HI_GO_SetSurfacePalette
+*/
+HI_S32 HI_GO_GetSurfacePalette(HI_HANDLE Surface, HI_PALETTE Palette);
+
+/**
+\brief Locks a surface and obtains its memory pointer. CNcomment:surface CNend
+\attention \n
+Before accessing a surface, you need to call the API to lock the surface.\n
+You cannot lock the same surface repeatedly.
+CNcomment:surfacesurface \n
+surface CNend
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+\param[out] pData Pixel format information related to memory accessing. CNcomment: CNend
+\param[in] bSync  Synchronization. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_LOCKED
+
+\see \n
+::HI_GO_UnlockSurface
+*/
+HI_S32 HI_GO_LockSurface(HI_HANDLE Surface, HI_PIXELDATA pData, HI_BOOL bSync);
+
+
+/**
+\brief Unlocks a surface. CNcomment:surface CNend
+\attention \n
+After accessing a surface, you need to call the API to unlock it.
+CNcomment:surfacesurface CNend
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOTLOCKED
+
+\see \n
+::HI_GO_LockSurface
+*/
+HI_S32 HI_GO_UnlockSurface(HI_HANDLE Surface);
+
+/**
+\brief Obtains the dimensions of a surface. CNcomment:surface CNend
+\attention \n
+pWidth and pHeight cannot be empty concurrently.
+CNcomment:pWidthpHeight CNend
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[out]  pWidth Width output address of a surface. The value cannot be empty. CNcomment:Surface CNend
+\param[out]  pHeight Height output address of a surface. The value cannot be empty. CNcomment:Surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceSize(HI_HANDLE Surface, HI_S32* pWidth, HI_S32* pHeight);
+
+/**
+\brief Obtains the pixel format of a surface. CNcomment:surface CNend
+\attention \n
+N/A
+\param[in]  Surface Surface Surface handle. CNcomment:Surface CNend
+\param[out] pPixelFormat Output address of the pixel format. The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfacePixelFormat(HI_HANDLE Surface, HIGO_PF_E* pPixelFormat);
+
+/**
+\brief Encapsulates the user memory into a surface. CNcomment:surface CNend
+\attention \n
+All the attributes of pSurInfo must be correct. The supported input pixel formats include RGB format, CLUT8 format, and YUV semi-planar format.
+CNcomment:pSurInfo,RGBclut8YUV semi-plannerCNend
+
+\param[in]  pSurInfo User memory information. The value cannot be empty. CNcomment: CNend
+\param[out] pSurface Handle information. The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_CreateSurfaceFromMem(const HIGO_SURINFO_S *pSurInfo, HI_HANDLE * pSurface);
+
+/**
+\brief Creates a memory surface. CNcomment:surface CNend
+\attention \n
+The surface in the format of ::HIGO_PF_CLUT1, ::HIGO_PF_CLUT4, ::HIGO_PF_YUV420, or ::HIGO_PF_YUV422 cannot be created.
+CNcomment:::HIGO_PF_CLUT1::HIGO_PF_CLUT4::HIGO_PF_YUV420::HIGO_PF_YUV422surface CNend
+
+\param[in] Width Surface width. CNcomment:Surface CNend
+\param[in] Height Surface height. CNcomment:Surface CNend
+\param[in] PixelFormat Surface pixel format. CNcomment:Surface CNend
+\param[out] pSurface Surface handle. CNcomment:Surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_FreeSurface
+*/
+HI_S32 HI_GO_CreateSurface(HI_S32 Width, HI_S32 Height, HIGO_PF_E PixelFormat, HI_HANDLE* pSurface);
+
+/**
+\brief Creates a child surface that shares the same memory with its parent surface. CNcomment:surfacesurfacesurface CNend
+\attention \n
+N/A
+
+\param[in] Surface Parent surface handle. CNcomment:surface CNend
+\param[in] pRect Region of the child surface in the parent surface. The value cannot be empty. CNcomment:surfacesurface CNend
+\param[out] pSubSurface Child surface handle. The value cannot be empty. CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_FreeSurface
+*/
+HI_S32 HI_GO_CreateSubSurface(HI_HANDLE Surface, const HI_RECT *pRect, HI_HANDLE* pSubSurface);
+
+
+/**
+\brief Destroys a surface. CNcomment:surface CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INUSE
+
+\see \n
+::HI_GO_CreateSurface \n
+::HI_GO_DecImgData
+*/
+HI_S32 HI_GO_FreeSurface(HI_HANDLE Surface);
+
+
+/**
+\brief Controls whether to synchronize the drawing operations based on a surface. CNcomment: surfaceCNend
+\attention \n
+When a surface is created, the operations based on the surface are synchronized by default. The synchronization indicates that you can draw graphics by using the two-dimensional engine (TDE) only after the contents in the cache drawn by the CPU are
+     updated to the surface memory. In addition, you can draw graphics by using the CPU only after the TDE completes the drawing operation.
+     This API is applicable to all the operations related to the surface.
+CNcomment:surface: TDECPUcache\n
+     surfaceCPUTDE
+     surface CNend
+
+\param[in] hSurface Surface handle, not used. CNcomment:Surface CNend
+\param[in] bAutoSync Automatic sync enable. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_EnableSurfaceAutoSync(HI_HANDLE hSurface, HI_BOOL bAutoSync);
+
+
+
+/**
+\brief Synchronizes the operations performed on a surface. In this way, the contents drawn by the CPU or TDE are updated to the surface memory.
+CNcomment:surface,CPU2Dsurface CNend
+\attention \n
+If you disable the automatic sync function by calling ::HI_GO_EnableSurfaceAutoSync, you need to synchronize the operations by calling HI_S32 HI_GO_SyncSurface when drawing graphics using the TDE or CPU.
+Otherwise, an error occurs during drawing.
+CNcomment:::HI_GO_EnableSurfaceAutoSyncTDECPU\n
+CNend
+\param[in] hSurface Surface handle, not used. CNcomment:Surface CNend
+\param[in] mode Sync mode. For details, see the description of ::HIGO_SYNC_MODE_E. CNcomment:::HIGO_SYNC_MODE_E CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SyncSurface(HI_HANDLE hSurface, HIGO_SYNC_MODE_E mode);
+
+
+/**
+\brief Sets the name of a surface. After setting the surface name, you can view the internal information about the surface (such as memory usage, width, height, and pixel format) by running cat /proc/higo in the command line window.
+CNcomment:surfacesurface cat /proc/higo surface
+ CNend
+\attention \n
+The name contains a maximum of 16 characters including the end character '/0'.
+CNcomment:16'\0'CNend
+
+\param[in] hSurface Surface handle. CNcomment:surface CNend
+\param[in] pName String of a surface name. CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceName(HI_HANDLE hSurface, const HI_CHAR* pName);
+
+
+/**
+\brief Obtains the name of a surface. CNcomment:surface CNend
+\attention \n
+The name contains a maximum of 16 characters including the end character '/0'.
+CNcomment:16'\0'CNend
+
+\param[in] hSurface Surface handle. CNcomment:surface CNend
+\param[in] pNameBuf Buffer for storing names. CNcomment:buffer CNend
+\param[in] BufLen Buffer size. CNcomment:buffer  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVPARAM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceName(HI_HANDLE hSurface,  HI_CHAR* pNameBuf, HI_U32 BufLen);
+
+
+
+/**
+\brief Obtains the memory type. CNcomment: CNend
+\attention \n
+
+\param[in]  Surface Surface handle. CNcomment:Surface CNend
+\param[out]  pMemType Pointer to the memory type. The value cannot be empty. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceMemType(HI_HANDLE Surface, HIGO_MEMTYPE_E *pMemType);
+
+
+/**
+\brief Queries the memory type. CNcomment: CNend
+\attention \n
+
+\param[in]   Surface  surface
+\param[out]  pOwner   Pointer to the owner type. The value cannot be empty. CNcomment:Owner CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceOwner(HI_HANDLE Surface, HIGO_OWNER_E *pOwner);
+
+/**
+\brief Creates an OS surface.
+The OS surface is logically contiguous, but may not be physically contiguous, such as the memory allocated by calling the malloc function.
+The OS surface can be identified by some components of the HiGo, but cannot be identified by the hardware. When the MMZ is insufficient, the OS surface can be used.
+CNcomment:OS \n
+malloc\n
+HIGOMMZ CNend
+
+\attention \n
+Note the following points when using the OS surface:
+1) The OS surface can be used during the BMP, GIF, or PNG software decoding when the picture is not scaled and the picture format is not converted.
+2) The RGB data stored in the surface can be encoded as a BMP file.
+3) Texts can be output to the OS surface.
+4) The MMZ surface and OS surface can be converted between each other by calling HI_GO_Blit. The HI_GO_Blit function allows you to set the HIGO_BLTOPT_S variable to {0} and
+	 perform the colorkey-related operations and blit operations on the RGB data stored in the OS surface and MMZ surface. Other operations are not supported.
+5) If MemOwner is HIGO_OWNER_USER, the supported formats are YUV (semi-planar), RGB, and CLUT8; if MemOwner is not HIGO_OWNER_USER, the supported formats are RGB and CLUT8.
+The following describes how to create the surfaces that store the data in common YUV formats:
+	HI_U32 u32AlignWidth_Y,u32AlignHeight_Y; //Pitch of the Y component after byte alignment
+	HI_U32 u32AlignWidth_C,u32AlignHeight_C; //Pitch of the UV component after byte alignment
+	HI_U32 uExpectWidth,uExpectHeight;       //Size of the source picture or the expected size of the picture
+	HIGO_PF_E szPixelFormat;                 //Pixel format of the source picture or the expected pixel format of the picture, such as HIGO_PF_YUV400, HIGO_PF_YUV420, HIGO_PF_YUV422, HIGO_PF_YUV422_V, or HIGO_PF_YUV444
+	HIGO_SURINFOEX_S SurfaceInfoEx = {0};
+
+	SurfaceInfoEx.Width = uExpectWidth;
+	SurfaceInfoEx.Height = uExpectHeight;
+	SurfaceInfoEx.PixelFormat = szPixelFormat;
+	SurfaceInfoEx.MemType = HIGO_MEMTYPE_MMZ;
+  	SurfaceInfoEx.MemOwner = HIGO_OWNER_USER;
+
+	SurfaceInfoEx.Pitch[0] = u32AlignWidth_Y;
+	SurfaceInfoEx.pPhyAddr[0] = HI_MMZ_New(SurfaceInfoEx.Pitch[0]*u32AlignHeight_Y, 4, NULL, "higoSurface");
+	SurfaceInfoEx.pVirAddr[0] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[0], 0);
+
+	SurfaceInfoEx.Pitch[1] = u32AlignWidth_C;
+	SurfaceInfoEx.pPhyAddr[1] = HI_MMZ_New(SurfaceInfoEx.Pitch[1]*u32AlignHeight_C, 4, NULL, "higoSurfaceCbCr");
+	SurfaceInfoEx.pVirAddr[1] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[1], 0);
+
+	ret = HI_GO_CreateSurfaceEx(&SurfaceInfoEx, &picSurface);
+
+---------------------------------------------------------------------------------------
+The following describes the values of u32AlignWidth_Y, u32AlignHeight_Y, u32AlignWidth_C, and u32AlignHeight_C based on the value of szPixelFormat:
+1) If szPixelFormat is YUV400:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = 0;
+	u32AlignHeight_C = 0;
+2) If szPixelFormat is YUV420:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 15) + (~(15));	      //16-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y;
+	u32AlignHeight_C = u32AlignHeight_Y/2;
+3) If szPixelFormat is YUV422:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y;
+	u32AlignHeight_C = u32AlignHeight_Y;
+4) If szPixelFormat is YUV422_V:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 15) + (~(15));	      //16-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y*2;
+	u32AlignHeight_C = u32AlignHeight_Y/2;
+5) If szPixelFormat is YUV444:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y*2;
+	u32AlignHeight_C = u32AlignHeight_Y;
+CNcomment:os surface
+1).bmpgifpng
+2).RGBsurfacebmp
+3).textsurface
+4).MMZOSsurfaceHI_GO_BlitHI_GO_BlitHIGO_BLTOPT_S ={0}
+	 ColorkeysurfaceRGBblit
+5).MemOwnerHIGO_OWNER_USERYUV(semi-planner), RGBCLUT8RGBCLUT8
+YUVsurface
+	HI_U32 u32AlignWidth_Y,u32AlignHeight_Y; //Y
+	HI_U32 u32AlignWidth_C,u32AlignHeight_C; //UV
+	HI_U32 uExpectWidth,uExpectHeight;       //
+	HIGO_PF_E szPixelFormat;                 //HIGO_PF_YUV400,HIGO_PF_YUV420,HIGO_PF_YUV422,HIGO_PF_YUV422_V,HIGO_PF_YUV444
+	HIGO_SURINFOEX_S SurfaceInfoEx = {0};
+
+	SurfaceInfoEx.Width = uExpectWidth;
+	SurfaceInfoEx.Height = uExpectHeight;
+	SurfaceInfoEx.PixelFormat = szPixelFormat;
+	SurfaceInfoEx.MemType = HIGO_MEMTYPE_MMZ;
+  	SurfaceInfoEx.MemOwner = HIGO_OWNER_USER;
+
+	SurfaceInfoEx.Pitch[0] = u32AlignWidth_Y;
+	SurfaceInfoEx.pPhyAddr[0] = HI_MMZ_New(SurfaceInfoEx.Pitch[0]*u32AlignHeight_Y, 4, NULL, "higoSurface");
+	SurfaceInfoEx.pVirAddr[0] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[0], 0);
+
+	SurfaceInfoEx.Pitch[1] = u32AlignWidth_C;
+	SurfaceInfoEx.pPhyAddr[1] = HI_MMZ_New(SurfaceInfoEx.Pitch[1]*u32AlignHeight_C, 4, NULL, "higoSurfaceCbCr");
+	SurfaceInfoEx.pVirAddr[1] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[1], 0);
+
+	ret = HI_GO_CreateSurfaceEx(&SurfaceInfoEx, &picSurface);
+
+---------------------------------------------------------------------------------------
+szPixelFormatu32AlignWidth_Yu32AlignHeight_Yu32AlignWidth_Cu32AlignHeight_C
+1 ) YUV400
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //128 byte
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //8 byte
+	u32AlignWidth_C   = 0;
+	u32AlignHeight_C  = 0;
+2 ) YUV420
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //128 byte
+	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //16 byte
+	u32AlignWidth_C   = u32AlignWidth_Y;
+	u32AlignHeight_C  = u32AlignHeight_Y / 2;
+3 ) YUV422
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //128 byte
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //8 byte
+	u32AlignWidth_C   = u32AlignWidth_Y;
+	u32AlignHeight_C  = u32AlignHeight_Y;
+4 ) YUV422_V
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //128 byte
+	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //16 byte
+	u32AlignWidth_C   = u32AlignWidth_Y * 2;
+	u32AlignHeight_C  = u32AlignHeight_Y / 2;
+5 ) YUV444
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //128 byte
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //8 byte
+	u32AlignWidth_C   = u32AlignWidth_Y * 2;
+	u32AlignHeight_C  = u32AlignHeight_Y; CNend
+\param[in]   pSurInfo      Pointer to the surface information. The value cannot be empty. CNcomment:surface CNend
+\param[out]  pSurface      Pointer to a surface. The value cannot be empty. CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_CreateSurfaceEx(const HIGO_SURINFOEX_S  *pSurInfo, HI_HANDLE* pSurface);
+
+/**
+\brief Set common Palette. CNcomment: CNend
+\attention \n
+N/A
+\param[in]   Palette.  CNcomment: CNend
+\param[out]  none
+
+\retval ::HI_SUCCESS
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetPubPalette(HI_PALETTE Palette);
+
+/**
+\brief Get common Palette. CNcomment: CNend
+\attention \n
+N/A
+\param[in]   none
+\param[out]  Palette.  CNcomment: CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetPubPalette(HI_PALETTE Palette);
+
+/**
+\brief Set clip region of surface. CNcomment:surface. CNend
+\attention \n
+Blit just support single Clip.
+CNcomment:blitsurface,
+(HI_GO_SetSurfaceClipRect) CNend
+
+\param[in]   Surface handle. CNcomment:surface CNend
+\param[in]   Pointer of Region. CNcomment: CNend
+\param[in]   Number of clip region. CNcomment: CNend
+\param[out]  none
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceClipRgn(HI_HANDLE Surface, HI_REGION *pRegion, HI_U32 u32Num);
+
+/**
+\brief Get clip region of surface.CNcomment:surface. CNend
+\attention  \n
+N/A
+\param[in]   Surface handle. CNcomment:surface CNend
+\param[out]   Pointer of Region. CNcomment: CNend
+\param[out]   Number of clip region. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceClipRgn(HI_HANDLE Surface, HI_REGION **ppRegion, HI_U32 *pu32Num);
+
+/**
+\brief Set Clip Rect. CNcomment: CNend
+\attention  \n
+N/A
+\param[in]   Surface handle. CNcomment:surface CNend
+\param[in]   Clip Rect. CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceClipRect(HI_HANDLE hSurface, const HI_RECT *pRect);
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_SURFACE_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_go_text.h b/xbmc/platform/linux/hisi/hi_go_text.h
new file mode 100644
index 0000000000..0263383aca
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_go_text.h
@@ -0,0 +1,480 @@
+#ifndef __HI_GO_TEXT_H__
+#define __HI_GO_TEXT_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_TEXT */
+/** @{ */  /** <![HIGO_TEXT] */
+
+#define LAYOUT_LEFT          HIGO_LAYOUT_LEFT     /**<Horizontally left*//**<CNcomment:*/
+#define LAYOUT_RIGHT         HIGO_LAYOUT_RIGHT    /**<Horizontally right*//**<CNcomment:*/
+#define LAYOUT_HCENTER       HIGO_LAYOUT_HCENTER  /**<Horizontally center*//**<CNcomment:*/
+#define LAYOUT_TOP           HIGO_LAYOUT_TOP      /**<Vertically top*//**<CNcomment:*/
+#define LAYOUT_BOTTOM        HIGO_LAYOUT_BOTTOM   /**<Vertically bottom*//**<CNcomment:*/
+#define LAYOUT_VCENTER       HIGO_LAYOUT_VCENTER  /**<Vertically center*//**<CNcomment:*/
+#define LAYOUT_WRAP          HIGO_LAYOUT_WRAP     /**<Wrap*//**<CNcomment:*/
+#define LAYOUT_WORDELLIPSIS  HIGO_LAYOUT_WORDELLIPSIS /**<Ellipsis format*//**<CNcomment:*/
+#define LAYOUT_FORCE_LEFT    HIGO_LAYOUT_FORCE_LEFT     /**<Force Horizontally left*//**<CNcomment:*/
+#define LAYOUT_FORCE_RIGHT   HIGO_LAYOUT_FORCE_RIGHT    /**<Force Horizontally right*//**<CNcomment:*/
+
+/** */
+typedef enum
+{
+    HIGO_LAYOUT_LEFT             = 0x0001,
+    HIGO_LAYOUT_RIGHT            = 0x0002,
+    HIGO_LAYOUT_HCENTER          = 0x0004,
+    HIGO_LAYOUT_WRAP             = 0x0008,
+    HIGO_LAYOUT_WORDELLIPSIS     = 0x0010,
+    HIGO_LAYOUT_TOP              = 0x0100,
+    HIGO_LAYOUT_BOTTOM           = 0x0200,
+    HIGO_LAYOUT_VCENTER          = 0x0400,
+    HIGO_LAYOUT_FORCE_LEFT       = 0x8000,
+    HIGO_LAYOUT_FORCE_RIGHT      = 0x10000,
+    HIGO_LAYOUT_VERTICAL         = 0x20000,
+    HIGO_LAYOUT_BUTT             = 0x40000,
+} HIGO_LAYOUT_E;
+
+/**<Definition of a character set*//** CNcomment:  */
+typedef enum
+{
+    HIGO_CHARSET_UNKOWN,
+    HIGO_CHARSET_ASCI,
+    HIGO_CHARSET_GB2312,
+    HIGO_CHARSET_UTF8,
+    HIGO_CHARSET_UTF16,
+    HIGO_CHARSET_UCS2 = HIGO_CHARSET_UTF16,
+    HIGO_CHARSET_UTF32,
+    HIGO_CHARSET_BUTT,
+} HIGO_CHARSET_E;
+
+/** Definition of a text base direction*//** CNcomment: */
+typedef enum
+{
+    HIGO_TEXT_DIR_NEUTRAL = 0,/**<neutral deirction*//**<CNcomment:*/
+    HIGO_TEXT_DIR_LTR,/**<Left to right*//**<CNcomment: */
+    HIGO_TEXT_DIR_RTL,/**<Right to left*//**<CNcomment: */
+    HIGO_TEXT_DIR_BUTT
+} HIGO_TEXT_DIR_E;
+
+
+typedef struct
+{
+    HIGO_CHARSET_E Charset; /**<Character set name*//**<CNcomment: */
+    HI_U8 Height;         /**<Font height*//**<CNcomment: */
+    HI_U8 MaxWidth;      /**<Maximum font width*//**<CNcomment: */
+}HIGO_FONTATTR_S;
+
+/** Attributes of a text output object*//** CNcomment:  */
+typedef struct
+{
+    HI_COLOR        BgColor;     /**<Background color*//**<CNcomment: */
+    HI_COLOR        FgColor;     /**<Foreground color*/ /**<CNcomment: */
+    HIGO_FONTATTR_S SbFontAttr;  /**<Font attributes of the single-byte character set*/ /**<CNcomment: */
+    HIGO_FONTATTR_S MbFontAttr;  /**<Font attributes of the multi-byte character set*//**<CNcomment: */
+} HIGO_TEXTOUTATTR_S;
+
+typedef enum
+{
+    HIGO_TEXT_STYLE_NORMAL = 0x00, /**<Normal font*//**<CNcomment:*/
+    HIGO_TEXT_STYLE_ITALIC = 0x01, /**<Italic font*//**<CNcomment:*/
+    HIGO_TEXT_STYLE_BOLD   = 0x02, /**<Bold font*//**<CNcomment:*/
+    HIGO_TEXT_STYLE_HALF_HEIGHT   = 0x04, /**<Half-height font *//**<CNcomment: */
+    HIGO_TEXT_STYLE_HALF_WIDTH    = 0x08, /**<Half-width font *//**<CNcomment: */
+    HIGO_TEXT_STYLE_DOUBLE_HEIGHT = 0x10, /**<Double-height font *//**<CNcomment:*/
+    HIGO_TEXT_STYLE_DOUBLE_WIDTH  = 0x20, /**<Double-widht font *//**<CNcomment:*/
+    HIGO_TEXT_STYLE_BUTT          = 0x40
+} HIGO_TEXT_STYLE_E;
+
+typedef struct{
+    HI_HANDLE     hFont;           	 /**<Handle of font file*//**<CNcomment:*/
+    HI_U32        Style;             /**<Layout style*//**<CNcomment:*/
+    HI_S32        s32Width;    	     /**<Width of display arear*//**<CNcomment:*/
+    HI_S32        s32Height;         /**<Height of display arear*//**<CNcomment:*/
+    HI_S32  	  horz_dist;         /**<Character horizontal spacing*//**<CNcomment: */
+    HI_S32  	  vert_dist;         /**<Raw vertical spacing*//**<CNcomment:,*/
+    HI_BOOL       single_para_flg;   /**<Whether it is a single paragraph *//**<CNcomment: */
+    HI_BOOL    	  auto_dir;          /**<Whether it is automatic direction*//**<CNcomment: */
+    HIGO_TEXT_DIR_E base_dir;        /**<Base direction*//**<CNcomment:  */
+    HI_U32        max_char;          /**<Max character*//**<CNcomment: */
+    HI_COLOR      select_bg;         /**<Selected background color*//**<CNcomment:*/
+    HI_COLOR      select_fg;         /**<Selected frontground color*//**<CNcomment:*/
+}HIGO_LAYOUT_INFO_S;
+
+typedef struct
+{
+    const HI_CHAR* pSbcFontFile;/**<Single-byte character font file.*//**<CNcomment:*/
+    const HI_CHAR* pMbcFontFile;/**<Multi-byte character font file.*//**<CNcomment:*/
+    HI_U32   u32Size; /**<This value is ignored for the dot-matrix font.*//**<CNcomment:*/
+} HIGO_TEXT_INFO_S;
+
+typedef enum{
+	HIGO_LAYOUT_MOVECURSOR_UP,    /**< move cursor to up position*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_DOWN,  /**< move cursor to down position*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_PREV,  /**< move cursor to previous postion*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_NEXT,  /**< move cursor to next position*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_LEFT,  /**< move cursor to left position*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_RIGHT, /**< move cursor to right positon*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_SOT,   /**< move cursor to start position of text*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_EOT,   /**< move curosr to end position of text*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_SOL,   /**< move cursor to start of current line*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_EOL,   /**< move cursor to end of current line*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_SOP,   /**< move cursor to start of current paragraph*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_EOP,   /**< move cursor to end of current paragraph*//**<CNcomment:*/
+	HIGO_LAYOUT_MOVECURSOR_BUTT,
+}HIGO_TEXT_CURSOR_DIR_E;
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_TEXT */
+/** @{ */  /** <![HIGO_TEXT] */
+
+/**
+\brief Creates a text output object.CNcomment:  CNend
+\attention \n
+The values of pSbFontFile and pMbFontFile cannot be empty at the same time. If the received file name is in vector
+font, the font height is set based on the 22-dot array.
+CNcomment: pSbFontFilepMbFontFile,,
+22 CNend
+\param[in] pSbFontFile Font file of the single-byte character set. If the value is empty, it indicates that the single
+-byte character set library is not used.CNcomment:  CNend
+\param[in] pMbFontFile  Font file of the multi-byte character set. If the value is empty, it indicates that the multi-
+byte character set library is not used. Ensure that the font files of the single-byte and multi-byte character sets
+cannot be empty concurrently.CNcomment:  CNend
+\param[out]  pTextOut Handle of a text output object.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_DestroyText
+*/
+HI_S32 HI_GO_CreateText(const HI_CHAR* pSbFontFile, const HI_CHAR* pMbFontFile, HI_HANDLE* pTextOut);
+
+/**
+\brief Destroys a text output object.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_CreateText
+*/
+HI_S32 HI_GO_DestroyText(HI_HANDLE TextOut);
+
+/**
+\brief set the input charset. CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[out] CharSet  charset of input text.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+::HI_GO_CreateText
+*/
+HI_S32 HI_GO_SetInputCharSet(HI_HANDLE TextOut, HIGO_CHARSET_E CharSet);
+
+/**
+\brief Obtains the attributes of a text output object.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[out] pTextOutAttr  Attributes of a text output object.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_GetTextAttr(HI_HANDLE TextOut,HIGO_TEXTOUTATTR_S *pTextOutAttr);
+
+/**
+\brief Obtains the width and height of text contents.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[in] pText Text contents.CNcomment: CNend
+\param[out] pWidth Width of text contents. It cannot be empty.CNcomment: CNend
+\param[out] pHeight Height of text contents. It cannot be empty.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_GetTextExtent(HI_HANDLE TextOut, const HI_CHAR *pText, HI_S32 *pWidth, HI_S32 *pHeight);
+
+/**
+\brief Obtains the width and height of vertical text contents.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[in] pText Text contents.CNcomment: CNend
+\param[out] pTextWidth Actual width of text contents. It cannot be empty.CNcomment: CNend
+\param[out] pHeight Height of text contents. It cannot be empty.CNcomment: CNend
+\param[out] pLayoutAreaWidth Minmal width of layout area. It cannot be empty.CNcomment: CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_GetVerticalTextExtent(HI_HANDLE hFont, const HI_CHAR *pText,
+                                   HI_S32 *pTextWidth, HI_S32 *pHeight, HI_S32 *pLayoutAreaWidth);
+
+/**
+\brief Sets to display the background color of a text output object.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[in] bTransparent  Whether to display the background color of a text output object. If the value is set to
+HI_TRUE, the background color is not displayed. The default value is HI_TRUE.CNcomment:HI_TRUE, HI_TRUE CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/ACNcomment: CNend
+*/
+HI_S32 HI_GO_SetTextBGTransparent(HI_HANDLE TextOut, HI_BOOL bTransparent);
+
+/**
+\brief Sets the background color of a text output object.CNcomment: CNend
+\attention \n
+If the target surface is a palette, the color is the palette index.CNcomment:surfaceColor CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[in] Color  Background color of a text output object.CNcomment:CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_SetTextBGColor(HI_HANDLE TextOut, HI_COLOR Color);
+
+/**
+\brief Sets the font color of a text output object.CNcomment:  CNend
+\attention \n
+If the target surface is a palette, the color is the palette index.CNcomment: surfaceColor CNend
+\param[in] TextOut Handle of a text output object.CNcomment:  CNend
+\param[in] Color  Font color of a text output object.CNcomment:  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:  CNend
+*/
+HI_S32 HI_GO_SetTextColor(HI_HANDLE TextOut, HI_COLOR Color);
+
+/**
+\brief Outputs text contents to a specified surface.CNcomment:surface CNend
+\attention
+N/A.CNcomment: CNend
+\param[in] TextOut Handle of a text output object.CNcomment: CNend
+\param[in] Surface Surface handle.CNcomment:Surface CNend
+\param[in] pText  Text contents.CNcomment: CNend
+\param[in] pRect Text output region. If the value is empty, it indicates that text contents are output from the
+surface origin.CNcomment:surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_TextOut(HI_HANDLE TextOut,HI_HANDLE Surface, const HI_CHAR *pText,
+                           const HI_RECT *pRect);
+
+/**
+\brief Outputs texts. This API is an extended API. You can call this API to output contents based on customized
+styles and formatting.CNcomment:,CNend
+\param[in] hTextOut Text output handle.CNcomment: CNend
+\param[in] hSurface Surface handle.CNcomment:Surface CNend
+\param[in] pText    Text contents ending with /0.CNcomment:/0 CNend
+\param[in] pRect    Text output region.CNcomment: CNend
+\param[in] Style    Styles and formatting including LAYOUT_LEFT, LAYOUT_RIGHT, and LAYOUT_HCENTER.CNcomment:LAYOUT_LEFTLAYOUT_RIGHTLAYOUT_HCENTER CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_TextOutEx(HI_HANDLE hTextOut, HI_HANDLE hSurface,
+                               const HI_CHAR *pText,  const HI_RECT *pRect,
+                               HIGO_LAYOUT_E Style);
+
+/**
+\brief Calculates the number of characters in a specified text output region.CNcomment:  CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] hTextOut Text output handle.CNcomment:  CNend
+\param[in] pText    Text contents ending with /0.CNcomment: /0 CNend
+\param[in] pRect    Text output region. The value cannot be empty.CNcomment: , CNend
+\param[in] pLen      Pointer to the string length.CNcomment:  CNend
+
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HI_SUCCESS
+
+\see \n
+N/A.CNcomment:  CNend
+*/
+HI_S32 HI_GO_GetTextExtentEx(HI_HANDLE TextOut, const HI_CHAR *pText,
+                                       const HI_RECT *pRect, HI_U32 *pLen);
+
+/**
+\brief Creates a font.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] phText Text output handle.CNcomment: CNend
+\param[in] pInfo  Text information.CNcomment: CNend
+
+\retval ::HI_SUCCESS A font is created successfully.CNcomment: CNend
+\retval ::HI_FAILURE A font fails to be created.CNcomment: CNend
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_CreateTextEx(const HIGO_TEXT_INFO_S* pInfo, HI_HANDLE* phText);
+
+/**
+\brief Sets the style of a font, such as bold, italic, or normal.CNcomment:: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param[in] hTextOut Text output handle.CNcomment: CNend
+\param[in] eStyle   Font style.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_SetTextStyle(HI_HANDLE hTextOut, HIGO_TEXT_STYLE_E eStyle);
+
+
+
+/**
+\brief Sets the the text base direction
+lines.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+
+\param[in] hTextOut Text output handle. CNcomment: CNend
+\param[in] BaseDir the base direction of the text. CNcomment:  CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:  CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment: CNend
+
+\see \n
+N/A.CNcomment: CNend
+*/
+
+HI_S32 HI_GO_SetBaseDir(HI_HANDLE TextOut, HIGO_TEXT_DIR_E eBaseDir);
+/**
+\brief Sets the horizontal spacing between displayed characters, that is, the horizontal spacing between character
+lines.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+
+\param[in] hTextOut Text output handle.CNcomment: CNend
+\param[in] u32Distance Horizontal spacing.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:  CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment: CNend
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_SetCharExtra(HI_HANDLE hTextOut, HI_U32 u32Distance);
+
+/**
+\brief Sets the vertical and horizontal spacing.CNcomment: CNend
+\attention \n
+This API is available only when the font style is changed.CNcomment: CNend
+
+\param[in] hTextOut Text output handle.CNcomment: CNend
+\param[in] u32Distance Vertical spacing.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment: CNend
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_SetLineExtra(HI_HANDLE hText, HI_U32 u32Distance);
+
+/**
+\brief Initializes the character module.CNcomment:  CNend
+\attention \n
+N/A.CNcomment:  CNend
+\param N/A.CNcomment:  CNend
+\retval ::HI_SUCCESS Success.CNcomment:  CNend
+\retval ::HI_FAILURE Failure.CNcomment:  CNend
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+N/A.CNcomment:  CNend
+*/
+HI_S32 HI_GO_InitText();
+
+/**
+\brief Deinitializes the character module.CNcomment: CNend
+\attention \n
+N/A.CNcomment: CNend
+\param N/A.CNcomment: CNend
+\retval ::HI_SUCCESS Success.CNcomment: CNend
+\retval ::HIGO_ERR_NOTINIT Failure.CNcomment: CNend
+
+\see \n
+N/A.CNcomment: CNend
+*/
+HI_S32 HI_GO_DeinitText();
+
+
+/** @} */  /*! <!-- API declaration end */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_TEXT_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_memory.h b/xbmc/platform/linux/hisi/hi_memory.h
new file mode 100644
index 0000000000..b0c7ecd585
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_memory.h
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_MEMORY_H__
+#define __HI_MEMORY_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     MEMOYR */
+/** @{ */ /** <!--  [MEMOYR] */
+
+/** Maximum bytes of a buffer name */
+#define MAX_BUFFER_NAME_SIZE 16
+
+/**Structure of an MMZ buffer*/
+typedef struct hiMMZ_BUF_S
+{
+    HI_CHAR bufname[MAX_BUFFER_NAME_SIZE];  /**<Strings of an MMZ buffer name*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  phyaddr;                /**<Physical address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U8  *kernel_viraddr;         /**<Kernel-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U8  *user_viraddr;           /**<User-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  bufsize;                /**<Size of an MMZ buffer*/ /**<CNcomment:  MMZ buffer */
+    HI_U32  overflow_threshold;     /**<Overflow threshold of an MMZ buffer, in percentage. For example, the value 100 indicates 100%.*/ /**<CNcomment:  MMZ buffer: 100 indicates 100%.*/
+    HI_U32  underflow_threshold;    /**<Underflow threshold of an MMZ buffer, in percentage. For example, the value 0 indicates 0%.*/ /**<CNcomment:  MMZ buffer: 0 indicates 0%.*/
+} HI_MMZ_BUF_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      MEMOYR */
+/** @{ */  /** <!-- [MEMOYR] */
+
+/**
+@brief Applies for a media memory zone (MMZ) and maps the user-state address.
+CNcomment:  mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in/out] pstBuf Structure of the buffer information. Bufname and bufsize are inputs, and the physical address and user-state virtual address are outputs.
+                    CNcomment: bufferbufnamebufsize, CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Malloc(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief Unmaps the user-state address and releases the MMZ. CNcomment: mmz CNend
+@attention \n
+Ensure that the lengths of the transferred physical address and user-state virtual address are correct.
+CNcomment:  CNend
+@param[in] pstBuf Structure of the buffer information CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Free(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief pplies for an MMZ with a specified name and obtains its physical address. CNcomment: mmzmmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32Size Buffer size CNcomment: buffer CNend
+@param[in] u32Align Alignment mode CNcomment:  CNend
+@param[in] ps8MMZName Name of an MMZ in the buffer. If the MMZ name is set to NULL, an MMZ is anonymously applied for. CNcomment: bufferNULL CNend
+@param[in] ps8BufName Buffer name CNcomment: buffer CNend
+@retval ::NULL The application fails. CNcomment:  CNend
+@retval Physical address CNcomment:  CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID *HI_MMZ_New(HI_U32 u32Size , HI_U32 u32Align, HI_CHAR *ps8MMZName, HI_CHAR *ps8BufName);
+
+
+/**
+@brief Releases an MMZ based on its physical address. CNcomment: mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Delete(HI_U32 u32PhysAddr);
+
+/**
+@brief Maps the physical address of an MMZ applied for to a user-state virtual address. You can determine whether to cache the address.
+CNcomment: mmzcached CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@param[in] u32Cached Whether to cache the address. 0: no; 1: yes CNcomment: cache01 CNend
+@retval ::NULL The application fails. CNcomment:  CNend
+@retval User-state virtual address CNcomment:  CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID *HI_MMZ_Map(HI_U32 u32PhysAddr, HI_U32 u32Cached);
+
+/**
+@brief Unmaps the user-state address of an MMZ. CNcomment: mmz CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Unmap(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Flushes D-cache to the cached MMZ. CNcomment: cachedMMZDcache CNend
+@attention \n
+refreshed transferred u32PhysAddr memory, the value 0 of u32PhysAddr is invalid.
+CNcomment: u32PhysAddr u32PhysAddr0 CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_Flush(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Obtains the physical address and size based on the virtual address. CNcomment:  CNend
+@attention \n
+N/A CNcomment:  CNend
+@param[in] pVir User-state virtual address CNcomment:  CNend
+@param[out] pu32Phyaddr Physical address  CNcomment:  CNend
+@param[out] pu32Size Size CNcomment:  CNend
+@retval ::HI_SUCCESS Success CNcomment:  CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_MMZ_GetPhyaddr(HI_VOID * pVir, HI_U32 *pu32Phyaddr, HI_U32 *pu32Size);
+
+/**
+@brief malloc the pointed size from system heap. CNcomment: CNend
+@attention None CNcomment: CNend
+@param[in] u32ModuleID The module ID, who need to request memory. CNcomment:ID CNend
+@param[in] u32Size The size of requesting. CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::Valid memory address Success CNcomment: CNend
+@retval ::NULL Failure CNcomment:NULL CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_VOID* HI_MEM_Malloc(HI_U32 u32ModuleID, HI_U32 u32Size);
+
+
+/**
+@brief Free the requsted memory by hi_malloc. CNcomment: CNend
+@attention when stopping to use the memory, calling this interface. CNcomment: CNend
+@param[in] u32ModuleID The module ID, who need to free memory. CNcomment:ID CNend
+@param[in] pMemAddr The memory address to free CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::None CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_VOID HI_MEM_Free(HI_U32 u32ModuleID, HI_VOID* pMemAddr);
+
+/**
+@brief Calloc memory, with u32MemBlock blocks and u32Size size per. CNcomment: CNend
+@attention None CNcomment: CNend
+@param[in] u32ModuleID The module id, who need to calloc memory. CNcomment:ID CNend
+@param[in] u32MemBlock The requesting block number. CNcomment: CNend
+@param[in] u32Size The requesting size per block. CNcomment: CNend
+@param[out] None CNcomment: CNend
+@retval ::Valid memory address Success CNcomment: CNend
+@retval ::NULL Failure CNcomment:NULL CNend
+@see \n
+N/A CNcomment:  CNend
+*/
+HI_VOID* HI_MEM_Calloc(HI_U32 u32ModuleID, HI_U32 u32MemBlock, HI_U32 u32Size);
+
+
+/** @} */ /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_MEMORY_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_module.h b/xbmc/platform/linux/hisi/hi_module.h
new file mode 100644
index 0000000000..ed0640b4ed
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_module.h
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_MODULE_H__
+#define __HI_MODULE_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     MODULE */
+/** @{ */ /** <!--  [MODULE] */
+
+#define HI_INVALID_MODULE_ID        (0xffffffff)
+#define HI_MAX_USER_MODULE_NUMBER   (256)
+
+/** Module ID flags */
+typedef enum hiMOD_ID_E
+{
+    HI_ID_STB         = 0,
+
+    /**< common. */ /**< CNcomment:  */
+    HI_ID_SYS         = 1,
+    HI_ID_MODULE      ,
+    HI_ID_LOG         ,
+    HI_ID_PROC        ,
+    HI_ID_MEM         ,
+    HI_ID_STAT        ,
+    HI_ID_PDM         ,
+    HI_ID_MEMDEV      ,
+
+    HI_ID_DEMUX       = 0x0A,
+    HI_ID_TSIO,
+    HI_ID_IFCP,
+
+    /**< audio. */ /**< CNcomment:  */
+    HI_ID_ADEC        = 0x10,
+    HI_ID_AO          ,
+    HI_ID_SIO_AI      ,
+    HI_ID_SIO_AO      ,
+    HI_ID_SIO         ,
+    HI_ID_AI          ,
+    HI_ID_AENC        ,
+    HI_ID_SRC         ,
+    HI_ID_AIAO        ,
+    HI_ID_AFLT        ,
+    HI_ID_ADSP        ,
+    HI_ID_AMP         ,
+    HI_ID_SIF         ,
+
+    /**< video. */ /**< CNcomment:  */
+    HI_ID_VFMW        = 0x20,
+    HI_ID_SVDEC       ,
+    HI_ID_DISP        ,
+    HI_ID_HDMI        ,
+    HI_ID_VO          ,
+    HI_ID_VPSS        ,
+    HI_ID_VDEC        ,
+    HI_ID_VI          ,
+    HI_ID_VENC        ,
+    HI_ID_PQ         ,
+    HI_ID_EDID,
+    HI_ID_VICAP       ,
+    HI_ID_HDMIRX      ,
+    /**< graphics. */ /**< CNcomment:  */
+    HI_ID_TDE         = 0x30,
+    HI_ID_JPGDEC      ,
+    HI_ID_JPGENC      ,
+    HI_ID_FB          ,
+    HI_ID_PNG         ,
+    HI_ID_HIGO        ,
+    HI_ID_GFX2D       ,
+
+    /**< player. */ /**< CNcomment:  */
+    HI_ID_PVR         = 0x40,
+    HI_ID_AVPLAY      ,
+    HI_ID_SYNC        ,
+    HI_ID_VSYNC       ,
+    HI_ID_ASYNC       ,
+    HI_ID_FASTPLAY ,
+
+    /**< ecs. */ /**< CNcomment:  */
+    HI_ID_FLASH       = 0x50,
+    HI_ID_IR          ,
+    HI_ID_RTC         ,
+    HI_ID_I2C         ,
+    HI_ID_SCI         ,
+    HI_ID_ETH         ,
+    HI_ID_USB_PROTECT ,
+    HI_ID_WDG         = 0x57,   /* watch dog used 'W' */
+    HI_ID_GPIO        ,
+    HI_ID_GPIO_I2C    ,
+    HI_ID_DMAC        ,
+    HI_ID_PMOC        ,
+    HI_ID_TUNER       ,
+    HI_ID_KEYLED      ,
+    HI_ID_E2PROM      ,
+    HI_ID_CIPHER      ,
+    HI_ID_OTP         = 0x60,
+    HI_ID_CA          ,
+    HI_ID_PM          ,
+    HI_ID_CI          ,
+    HI_ID_CIMAXPLUS   ,
+    HI_ID_TVP5150     ,
+    HI_ID_SIL9293     ,
+    HI_ID_PWM         ,
+    HI_ID_SPI         ,
+    HI_ID_PLCIPHER    ,//0x69
+    HI_ID_CERT        ,//0x6A
+    HI_ID_SM          ,//0x6B
+    HI_ID_RUNTIME     ,//0x6C
+    HI_ID_MAILBOX     ,//0x6D
+    HI_ID_CASIMAGE    ,//0x6E
+
+    /**< voip, bluetooth,alsa. */ /**<  CNcomment: VOIP*/
+    HI_ID_VOIP_HME    = 0x80,
+    HI_ID_NDPT        ,
+    HI_ID_AUDADP      ,
+    HI_ID_BT          ,
+    HI_ID_ALSA        ,
+    HI_ID_3G          ,
+    HI_ID_KARAOKE     ,
+
+    /**< vp. */ /**<  CNcomment: VP*/
+    HI_ID_VP          = 0x90,
+    HI_ID_HDCP        ,
+
+    /**< subtitle. */ /**<  CNcomment: */
+    HI_ID_SUBT        = 0x98,
+    HI_ID_TTX         ,
+    HI_ID_CC          ,
+
+    /**< loader. */ /**< CNcomment: loader */
+    HI_ID_LOADER      = 0xA0,
+
+    /**< Reserve fro middleware: 0xA1-0XB7. */ /**<  CNcomment:  0xA1-0XB7.*/
+
+    /**<GPU. */ /**< CNcomment:GPU*/
+    HI_ID_GPU        = 0xB8,
+
+    /**< user definition. */ /**< CNcomment:  */
+    HI_ID_USR_START   = 0xC0,
+    HI_ID_USR_END     = 0xFE,
+
+    HI_ID_BUTT        = 0xFF
+} HI_MOD_ID_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      MODULE */
+/** @{ */  /** <!-- [MODULE] */
+
+/**
+@brief Register one module to manager. CNcomment: CNend
+@attention Before manager someone module, calling this interface. CNcomment: CNend
+@param[in] pszModuleName The module name CNcomment: CNend
+@param[in] u32ModuleID   The module ID. CNcomment:ID CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_Register(HI_U32 u32ModuleID, const HI_CHAR * pszModuleName);
+
+/**
+@brief Register one moudle by name. CNcomment:ID CNend
+@attention Before manager someone module, calling this interface. CNcomment: CNend
+@param[in] pszModuleName The module name CNcomment: CNend
+@param[out] pu32ModuleID The module id allocated by system. CNcomment:ID CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_RegisterByName(const HI_CHAR * pszModuleName, HI_U32* pu32ModuleID);
+
+/**
+@brief UnRegister one module to trace. CNcomment: CNend
+@attention Before stopping to manage someone module, calling this interface. CNcomment: CNend
+@param[in] u32ModuleID The module ID. CNcomment:ID CNend
+@param[out] None CNcomment: CNend
+@retval ::HI_SUCCESS Success CNcomment: CNend
+@retval ::HI_FAILURE Failure CNcomment: CNend
+@see \n
+N/A CNcomment: CNend
+*/
+HI_S32 HI_MODULE_UnRegister(HI_U32 u32ModuleID);
+
+/** @} */ /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_MODULE_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_system.h b/xbmc/platform/linux/hisi/hi_system.h
new file mode 100644
index 0000000000..d7613f6a0f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_system.h
@@ -0,0 +1,435 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_SYSTEM_H__
+#define __HI_SYSTEM_H__
+
+#include "hi_type.h"
+#include "hi_debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct hiSYS_CONF_S
+{
+    HI_U32 u32Reverse; /* Not used, reserved for extension */ /* CNcomment:  */
+} HI_SYS_CONF_S;
+
+/* Define the chip type. */
+typedef enum hiCHIP_TYPE_E
+{
+    HI_CHIP_TYPE_HI3716M,
+    HI_CHIP_TYPE_HI3716H,
+    HI_CHIP_TYPE_HI3716C,
+    HI_CHIP_TYPE_HI3716D,
+
+    HI_CHIP_TYPE_HI3720,
+    HI_CHIP_TYPE_HI3712,
+    HI_CHIP_TYPE_HI3715,
+
+    HI_CHIP_TYPE_HI3718M,
+    HI_CHIP_TYPE_HI3718C,
+    HI_CHIP_TYPE_HI3719M,
+    HI_CHIP_TYPE_HI3719C,
+    HI_CHIP_TYPE_HI3719M_A,
+
+    HI_CHIP_TYPE_HI3796C   = 0x20,
+    HI_CHIP_TYPE_HI3798C,
+    HI_CHIP_TYPE_HI3796M,
+    HI_CHIP_TYPE_HI3798M,
+
+    HI_CHIP_TYPE_HI3796C_A = 0x40,
+    HI_CHIP_TYPE_HI3798C_A,
+    HI_CHIP_TYPE_HI3798C_B,
+
+    HI_CHIP_TYPE_HI3798M_A,
+    HI_CHIP_TYPE_HI3798M_H,
+
+    HI_CHIP_TYPE_BUTT
+} HI_CHIP_TYPE_E;
+
+/* Define the chip version. */
+typedef enum hiCHIP_VERSION_E
+{
+    HI_CHIP_VERSION_V100 = 0x100,
+    HI_CHIP_VERSION_V101 = 0x101,
+    HI_CHIP_VERSION_V110 = 0x110,
+    HI_CHIP_VERSION_V200 = 0x200,
+    HI_CHIP_VERSION_V210 = 0x210,
+    HI_CHIP_VERSION_V300 = 0x300,
+    HI_CHIP_VERSION_V310 = 0x310,
+    HI_CHIP_VERSION_V400 = 0x400,
+    HI_CHIP_VERSION_V410 = 0x410,
+    HI_CHIP_VERSION_V420 = 0x420,
+    HI_CHIP_VERSION_V430 = 0x430,
+    HI_CHIP_VERSION_V450 = 0x450,
+    HI_CHIP_VERSION_BUTT
+} HI_CHIP_VERSION_E;
+
+typedef enum
+{
+    HI_CHIP_PACKAGE_TYPE_BGA_15_15 = 0,
+    HI_CHIP_PACKAGE_TYPE_BGA_16_16,
+    HI_CHIP_PACKAGE_TYPE_BGA_19_19,
+    HI_CHIP_PACKAGE_TYPE_BGA_23_23,
+    HI_CHIP_PACKAGE_TYPE_BGA_31_31,
+    HI_CHIP_PACKAGE_TYPE_QFP_216,
+    HI_CHIP_PACKAGE_TYPE_BGA_21_21,
+    HI_CHIP_PACKAGE_TYPE_BGA_14_14,
+    HI_CHIP_PACKAGE_TYPE_BUTT
+} HI_CHIP_PACKAGE_TYPE_E;
+
+/* Define the chip support attrs */
+typedef enum hiCHIP_CAP_E
+{
+    HI_CHIP_CAP_DOLBY,
+    HI_CHIP_CAP_DTS,
+    HI_CHIP_CAP_ADVCA,
+    HI_CHIP_CAP_MACROVISION,
+    HI_CHIP_CAP_HDR10,
+    HI_CHIP_CAP_DOLBYVISION,
+    HI_CHIP_CAP_BUTT
+} HI_CHIP_CAP_E;
+
+/* Define the video codec lisence contrl enum. */
+typedef enum hiSYS_VIDEO_CODEC_E
+{
+    HI_SYS_VIDEO_MPEG2 = 0x1,
+    HI_SYS_VIDEO_MPEG4 = 0x2,
+    HI_SYS_VIDEO_VC1   = 0x4,
+    HI_SYS_VIDEO_H264  = 0x8,
+    HI_SYS_VIDEO_MVC   = 0x10,
+    HI_SYS_VIDEO_H265  = 0x20,
+    HI_SYS_VIDEO_AVS   = 0x40,
+    HI_SYS_VIDEO_DIVX  = 0x80,
+    HI_SYS_VIDEO_REAL8 = 0x100,
+    HI_SYS_VIDEO_REAL9 = 0x200,
+    HI_SYS_VIDEO_AVS2  = 0x400,
+    HI_SYS_VIDEO_MASK  = 0x7FF,
+} HI_SYS_VIDEO_CODEC_E;
+
+/* System version, that is, the version of the software developer's kit (SDK) */
+typedef struct hiSYS_VERSION_S
+{
+    HI_CHIP_TYPE_E  enChipTypeSoft;     /* Chip type corresponding to the SDK */ /* CNcomment: SDK */
+    HI_CHIP_TYPE_E  enChipTypeHardWare; /* Chip type that is detected when the SDK is running */ /* CNcomment: SDK */
+    HI_CHIP_VERSION_E enChipVersion;    /* Chip version that is detected when the SDK is running */ /* CNcomment: SDK */
+    HI_CHAR         aVersion[80];       /* Version string of the SDK */ /* CNcomment: SDK */
+    HI_CHAR         BootVersion[80];    /* Version string of the Boot */ /* CNcomment: Boot */
+    HI_CHAR         SecureOSImageVersion[96]; /* Version string of the secure os image */ /* CNcomment: OS */
+} HI_SYS_VERSION_S;
+
+/* Define the chip attributes */
+typedef struct hiSYS_CHIP_ATTR_S
+{
+    HI_BOOL bDolbySupport;       /* Whether support dolby or not */ /* CNcomment: */
+    HI_BOOL bDTSSupport;         /* Whether support DTS or not */ /* CNcomment:DTS */
+    HI_BOOL bADVCASupport;       /* Whether support ADVCA or not */ /* CNcomment: */
+    HI_BOOL bMacrovisionSupport; /* Whether support Macrovision or not */ /* CNcomment:Macrovision */
+    HI_BOOL bHDR10Support;       /* Whether support HDR10 or not */ /* CNcomment:HDR10 */
+    HI_BOOL bDolbyvisionSupport; /* Whether support DolbyVision or not */ /* CNcomment:Dolbyvision */
+    HI_U64  u64ChipID;           /* the unique 64 bits chipid */ /* CNcomment:64ID */
+    HI_U32  u32ChipID;           /* the unique 32 bits chipid since 98mv200 */ /* CNcomment:32ID98mv200 */
+} HI_SYS_CHIP_ATTR_S;
+
+/* Define the Sys attributes */
+typedef struct hiSYS_ATTR_S
+{
+    HI_BOOL bSMPSupport; /* Whether support SMP or not */ /* CNcomment: */
+} HI_SYS_ATTR_S;
+
+/* Defines DDR configuration type struct */
+/* CNcomment: DDR  */
+typedef struct hiSYS_MEM_CONFIG_S
+{
+    HI_U32 u32TotalSize; /* Total memory size(MB) */ /* CNcomment: (MB) */
+    HI_U32 u32MMZSize;   /* MMZ memory size(MB) */ /* CNcomment: MMZ(MB) */
+} HI_SYS_MEM_CONFIG_S;
+
+#ifndef __KERNEL__
+#include <time.h>
+
+/*
+ * brief Initializes the system. CNcomment:  CNend
+ * attention \n
+ * You must call this API to initialize the system before using the APIs of all modules.
+ * Though you can call other APIs successfully before calling this API, the subsequent operations may fail.\n
+ * CNcomment: \n
+ *  CNend
+ * param N/A CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_Init(HI_VOID);
+
+/*
+ * brief Deinitializes the system. CNcomment:  CNend
+ * attention \n
+ * If all modules are not used, you need to call this API to deinitialize the system.\n
+ * CNcomment:  CNend
+ * param N/A CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_DeInit(HI_VOID);
+
+/*
+ * brief Obtains the compiled time of a version. CNcomment:  CNend
+ * attention \n
+ * The compiled time is the time during which the common module is made again.
+ * CNcomment: commonmake CNend
+ * param[out] pstTime Pointer to the compiled time of a version (output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetBuildTime(struct tm * pstTime);
+
+/*
+ * brief Obtains the version number. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pstVersion Pointer to the version number (output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetVersion(HI_SYS_VERSION_S *pstVersion);
+
+/*
+ * brief Obtains the package type. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] penPackageType Pointer to the package type (output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetChipPackageType(HI_CHIP_PACKAGE_TYPE_E *penPackageType);
+
+/*
+ * brief Obtains the chip support attributes. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] enChipCap Indicate which chip capability. CNcomment:  CNend
+ * param[out] pbSupport Pointer to the chip whether support the attributes(output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetChipCapability(HI_CHIP_CAP_E enChipCap, HI_BOOL *pbSupport);
+
+/*
+ * brief Obtains the chip attributes. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pstChipAttr Pointer to the chip attributes(output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetChipAttr(HI_SYS_CHIP_ATTR_S *pstChipAttr);
+
+/*
+ * brief Obtains the Sys attributes. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pstSysAttr Pointer to the chip attributes(output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetAttr(HI_SYS_ATTR_S *pstSysAttr);
+
+/*
+ * brief CRC32 function. CNcomment: CRC32 CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] pu8Src Pointer to the source buffer. CNcomment: buffer CNend
+ * param[in] u32SrcLen length of the source buffer. CNcomment: buffer CNend
+ * param[out] pu32Dst Pointer to the out value. CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_CRC32(HI_U8 *pu8Src, HI_U32 u32SrcLen, HI_U32 *pu32Dst);
+
+/*
+ * brief Obtains the chip attributes. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pstConfig Pointer to address for memory configuration(output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetMemConfig(HI_SYS_MEM_CONFIG_S *pstConfig);
+
+/*
+ * brief Performs global system configuration. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] pstSysConf Pointer to the address for system configuration CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_SetConf(const HI_SYS_CONF_S *pstSysConf);
+
+/*
+ * brief Obtains global system configuration. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pstSysConf Pointer to the system configuration (output). CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetConf(HI_SYS_CONF_S *pstSysConf);
+
+/*
+ * brief Sets the debugging information level of a module. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] enModId Debugging ID of a module CNcomment: ID CNend
+ * param[in] enLogLevel Debugging information level of a module CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogLevel(HI_MOD_ID_E enModId,  HI_LOG_LEVEL_E enLogLevel);
+
+/*
+ * brief Sets the debugging information file path for U-disk. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in]  pszLogPath Debugging information file path. CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogPath(const HI_CHAR* pszLogPath);
+
+/*
+ * brief Sets the debugging files(may be stream, YUV data, image...) save path. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in]  pszPath Debugging files path. CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetStorePath(const HI_CHAR* pszPath);
+
+/*
+ * brief Sets the debugging information file size(MB), range from 1 to 120. CNcomment: (MB)1120 CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in]  u32LogSize Debugging information file size(MB). CNcomment: (MB) CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogSize(HI_U32 u32LogSize);
+
+/*
+ * brief Writes to a register or a memory. CNcomment:  CNend
+ * attention:\n
+ * support register range: \n
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * CNcomment:\n
+ * :
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * CNend
+ * param[in] u32RegAddr Physical address of a register CNcomment:  CNend
+ * param[in] u32Value Value of a register CNcomment:   CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_WriteRegister(HI_U32 u32RegAddr, HI_U32 u32Value);
+
+/*
+ * brief Reads a register. CNcomment: CNend
+ * attention \n
+ * support register range: \n
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * {0xF8AB0000, 0xF8ABFFFF} \n
+ * CNcomment:\n
+ * :
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * {0xF8AB0000, 0xF8ABFFFF} \n
+ * CNend
+ * param[in] u32RegAddr Physical address of a register CNcomment:  CNend
+ * param[out] pu32Value Pointer to the register value (output) CNcomment:   CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_ReadRegister(HI_U32 u32RegAddr, HI_U32 *pu32Value);
+
+/*
+ * brief Get timestamp. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[out] pu32TimeMs Pointer to the timestamp value (output) CNcomment:  CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_GetTimeStampMs(HI_U32 *pu32TimeMs);
+
+/*
+ * brief Disable some video codec. CNcomment:  CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] enVideoCodec  The type of video codec:    CNend
+ * retval ::HI_SUCCESS Success CNcomment:  CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API CNend
+ * see \n
+ * N/A CNcomment:  CNend
+ */
+HI_S32 HI_SYS_DisableVideoCodec(HI_SYS_VIDEO_CODEC_E enVideoCodec);
+
+#endif /* endif __KERNEL__ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_SYSTEM_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_type.h b/xbmc/platform/linux/hisi/hi_type.h
new file mode 100644
index 0000000000..f2be4c00e5
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_type.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2005-2018. All rights reserved.
+ * Description: Common data types of the system.
+ *              CNcomment:  CNend
+ * Author: Hisilicon multimedia software group
+ * Create: 2005-4-23
+ */
+
+#ifndef __HI_TYPE_H__
+#define __HI_TYPE_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of basic data types. The data types are applicable to both the application layer and kernel codes. *
+ * CNcomment:   CNend                                                   *
+ *--------------------------------------------------------------------------------------------------------------*/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Common_TYPE */
+/** @{ */  /** <!-- [Common_TYPE] */
+
+typedef unsigned char           HI_UCHAR;
+typedef unsigned char           HI_U8;
+typedef unsigned short          HI_U16;
+typedef unsigned int            HI_U32;
+typedef unsigned long long      HI_U64;
+typedef unsigned long           HI_ULONG;
+
+typedef char*                   HI_PCHAR;
+typedef char                    HI_CHAR;
+typedef signed char             HI_S8;
+typedef short                   HI_S16;
+typedef int                     HI_S32;
+typedef long long               HI_S64;
+typedef long                    HI_SLONG;
+
+typedef float                   HI_FLOAT;
+typedef double                  HI_DOUBLE;
+
+/* typedef void                    HI_VOID; */
+#define HI_VOID         void
+
+typedef unsigned long           HI_SIZE_T;
+typedef unsigned long           HI_LENGTH_T;
+
+typedef HI_U32                  HI_HANDLE;
+
+typedef unsigned int            HI_PHYS_ADDR_T;
+
+#ifdef CONFIG_ARCH_LP64_MODE
+typedef unsigned long long      HI_VIRT_ADDR_T;
+#else
+typedef unsigned int            HI_VIRT_ADDR_T;
+#endif
+
+/** Constant Definition */
+/** CNcomment:  */
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1,
+} HI_BOOL;
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define HI_NULL             0L
+#define HI_NULL_PTR         0L
+
+#define HI_SUCCESS          0
+#define HI_FAILURE          (-1)
+
+#define HI_INVALID_HANDLE   (0xffffffff)
+
+#define HI_INVALID_PTS      (0xffffffff)
+#define HI_INVALID_TIME     (0xffffffff)
+
+#define HI_OS_LINUX     0xabcd
+#define HI_OS_WIN32     0xcdef
+
+#ifdef _WIN32
+#define HI_OS_TYPE      HI_OS_WIN32
+#else
+#define __OS_LINUX__
+#define HI_OS_TYPE      HI_OS_LINUX
+#endif
+
+#ifdef HI_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+
+define of HI_HANDLE :
+bit31                                                           bit0
+  |<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+  |--------------------------------------------------------------|
+  |      HI_MOD_ID_E       |  mod defined data |     chnID       |
+  |--------------------------------------------------------------|
+
+mod defined data: private data define by each module(for example: sub-mod id), usually, set to 0.
+*/
+
+#define HI_HANDLE_MAKEHANDLE(mod, privatedata, chnid)  (HI_HANDLE)( (((mod)& 0xffff) << 16) | ((((privatedata)& 0xff) << 8) ) | (((chnid) & 0xff)) )
+
+#define HI_HANDLE_GET_MODID(handle)     (((handle) >> 16) & 0xffff)
+#define HI_HANDLE_GET_PriDATA(handle)   (((handle) >> 8) & 0xff)
+#define HI_HANDLE_GET_CHNID(handle)     (((handle)) & 0xff)
+
+#define HI_UNUSED(x) ((x)=(x))
+
+typedef unsigned char           hi_uchar;
+typedef unsigned char           hi_u8;
+typedef unsigned short          hi_u16;
+typedef unsigned int            hi_u32;
+typedef unsigned long long      hi_u64;
+typedef unsigned long           hi_ulong;
+
+typedef char                    hi_char;
+typedef signed char             hi_s8;
+typedef short                   hi_s16;
+typedef int                     hi_s32;
+typedef long long               hi_s64;
+typedef long                    hi_slong;
+
+typedef float                   hi_float;
+typedef double                  hi_double;
+
+typedef void                    hi_void;
+
+typedef unsigned long           hi_size_t;
+typedef unsigned long           hi_length_t;
+
+typedef hi_u32                  hi_handle;
+
+typedef HI_BOOL                 hi_bool;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_TYPE_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_advca.h b/xbmc/platform/linux/hisi/hi_unf_advca.h
new file mode 100644
index 0000000000..7038d14d63
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_advca.h
@@ -0,0 +1,1923 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_advca.h
+Version       : Initial
+Author        : Hisilicon hisecurity team
+Created       : 2013-08-28
+Last Modified :
+Description   : Hisilicon CA API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_ADVCA_H__
+#define __HI_UNF_ADVCA_H__
+
+#include "hi_type.h"
+#include "hi_unf_cipher.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/** advanced CA session serect key class*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV1     = 0,    /**<session serect key level 1*/
+    HI_UNF_ADVCA_KEYLADDER_LEV2 ,           /**<session serect key level 2*/
+    HI_UNF_ADVCA_KEYLADDER_LEV3 ,           /**<session serect key level 3*/
+    HI_UNF_ADVCA_KEYLADDER_LEV4,            /**<session serect key level 4*/
+    HI_UNF_ADVCA_KEYLADDER_LEV5,            /**<session serect key level 5*/
+    HI_UNF_ADVCA_KEYLADDER_LEV6,            /**<session serect key level 6*/
+    HI_UNF_ADVCA_KEYLADDER_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LEV_E;
+
+/** advanced CA session keyladder target */
+typedef enum hiUNF_ADVCA_CA_TARGET_E
+{
+    HI_UNF_ADVCA_CA_TARGET_DEMUX         = 0, /**<demux*/
+    HI_UNF_ADVCA_CA_TARGET_MULTICIPHER,       /**<multicipher*/
+    HI_UNF_ADVCA_CA_TARGET_BUTT
+}HI_UNF_ADVCA_CA_TARGET_E;
+
+/** advanced CA Encrypt arith*/
+typedef enum hiUNF_ADVCA_ALG_TYPE_E
+{
+    HI_UNF_ADVCA_ALG_TYPE_TDES      = 0,    /**<Encrypt arith :3 DES*/
+    HI_UNF_ADVCA_ALG_TYPE_AES,              /**<Encrypt arith : AES*/
+    HI_UNF_ADVCA_ALG_TYPE_SM4,              /**<Encrypt arith : SM4*/
+    HI_UNF_ADVCA_ALG_TYPE_BUTT
+}HI_UNF_ADVCA_ALG_TYPE_E;
+
+/** FLASH device types*/
+typedef enum hiUNF_ADVCA_FLASH_TYPE_E
+{
+    HI_UNF_ADVCA_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NAND ,          /**<nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NOR ,           /**<nor flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_EMMC ,          /**<eMMC*/
+    HI_UNF_ADVCA_FLASH_TYPE_SPI_NAND ,      /**<spi_nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_BUTT
+}HI_UNF_ADVCA_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum hiUNF_ADVCA_JTAG_MODE_E
+{
+    HI_UNF_ADVCA_JTAG_MODE_OPEN     = 0,
+    HI_UNF_ADVCA_JTAG_MODE_PROTECT,
+    HI_UNF_ADVCA_JTAG_MODE_CLOSED,
+    HI_UNF_ADVCA_JTAG_MODE_BUTT
+}HI_UNF_ADVCA_JTAG_MODE_E;
+
+typedef struct HiUNF_ADVCA_LOCK_TZ_OTP_PARAM
+{
+    HI_U32 u32Addr;
+    HI_U32 u32Len;
+}HI_UNF_ADVCA_LOCK_TZ_OTP_PARAM_S;
+
+typedef enum hiUNF_ADVCA_SP_DSC_MODE_E
+{
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA2              = 0x0000,   /**<Demux PAYLOAD CSA2 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA3              = 0x0010,   /**<Demux PAYLOAD CSA3 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_IDSA      = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_ECB           = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI        = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_IPTV          = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CIPLUS        = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CBC           = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_NOVEL         = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_NOVEL        = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_IPTV         = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_ECB          = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_CBC          = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC           = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_IPTV         = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_ECB          = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_CBC          = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC               = 0x4020,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_ECB               = 0x4021,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_PIFF          = 0x4022,   /**<MultiCipher AES CBC PIFF */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_APPLE         = 0x4023,   /**<MultiCipher AES CBC APPLE */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CTR               = 0x4024,   /**<MultiCipher AES CTR */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_CBC              = 0x4040,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_ECB              = 0x4041,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_BUTT
+}HI_UNF_ADVCA_SP_DSC_MODE_E;
+
+/** Advca CA VendorID */
+typedef enum hiUNF_ADVCA_VENDORID_E
+{
+    HI_UNF_ADVCA_NULL       = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_ADVCA_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_ADVCA_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_ADVCA_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_ADVCA_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_ADVCA_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_ADVCA_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_ADVCA_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_ADVCA_COMMONCA   = 0x0b,        /**<COMMONCA Chipset, Marked with H*/
+    HI_UNF_ADVCA_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_ADVCA_PANACCESS  = 0x0e,        /**<PANACCESS CA Chipset*/
+    HI_UNF_ADVCA_VENDORIDE_BUTT
+}HI_UNF_ADVCA_VENDORID_E;
+
+/** Advca CA lock type */
+typedef enum hiUNF_ADVCA_LOCK_TYPE
+{
+    HI_UNF_ADVCA_LOCK_RSA_KEY = 0,
+    HI_UNF_ADVCA_LOCK_TZ_OTP,
+    HI_UNF_ADVCA_LOCK_MISC_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_GG_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_TSKL_CSA3_DISABLE,
+    HI_UNF_ADVCA_LOCK_BUTT,
+}HI_UNF_ADVCA_LOCK_TYPE_E;
+
+
+/** DCAS KeyLadder use mode */
+typedef enum hiUNF_ADVCA_DCAS_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK2         = 0,    /**<session EK2*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK1         = 1,    /**<session EK1*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_VENDORSYSID = 8,    /**<session Vendor_SysID*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_NONCE       = 9,    /**<session nonce*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_BUTT
+}HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E;
+
+/** MISC KeyLadder ROOTKEY Selection */
+typedef enum hiUNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E
+{
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_CSA2    = 0,     /**<MISC ROOTKEY CSA2*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_CSA3,            /**<MISC ROOTKEY CSA3*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_AES,             /**<MISC ROOTKEY AES*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_SM4,             /**<MISC ROOTKEY SM4*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_MAX
+}HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E;
+
+/**Defines the attribute ID of the OTP fuse. Please be kindly noted that the OTP fuse is set permanently.
+After setting the OTP fuse, please power off and then power on the STB to make the OTP fuse function effective */
+/**CNcomment: OTPID. OTP.
+OTP.*/
+typedef enum hiUNF_ADVCA_OTP_FUSE_E
+{
+    HI_UNF_ADVCA_OTP_NULL = 0,
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION, /**<Whether to enable the secure boot authentication, set the boot flash type together, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*//**<CNcomment: flash, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_DECRYPTION_ACTIVATION, /**<Whether to enable the secure boot decryption, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SELF_BOOT_DEACTIVATION, /**<Whether to disable the self boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_DEACTIVATION, /**<Whether to disable the DDR wakeup, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment:  , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_LEVEL_SEL, /**<CSA2 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_KL_LEVEL_SEL, /**<R2R keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: R2R keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_LEVEL_SEL, /**<SP keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_LEVEL_SEL, /**<CSA3 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA3 keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_LP_DEACTIVATION, /**<Whether to disable the LP keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: LP keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA2 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2CW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_CW_HARDONLY_ACTIVATION, /**<Whether to enable the SP hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SPCW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA3 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3CW , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_DEACTIVATION, /**<Whether to disable the CSA2 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_DEACTIVATION, /**<Whether to disable the SP keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_DEACTIVATION, /**<Whether to disable the CSA3 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3 keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_DEACTIVATION, /**<Whether to disable the MISC keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GOOGLE_KL_DEACTIVATION, /**<Whether to disable the google keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Google keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DCAS_KL_DEACTIVATION, /**<Whether to disable the DCAS keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DCAS keyladder , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_SCRAMBLE_ACTIVATION, /**<Whether to enable the DDR scrambling, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GLOBAL_LOCK_ACTIVATION, /**<Whether to lock the whole OTP area, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: OTP , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_RUNTIME_CHECK_ACTIVATION, /**<Whether to enable the runtime check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Runtime check , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_CHECK_ACTIVATION, /**<Whether to enable the DDR check when wakeup from standby, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID_CHECK_ACTIVATION, /**<Whether to enable the version id check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Version ID , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_MSID_CHECK_ACTIVATION, /**<Whether to enable the boot MSID check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Boot MSID , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_MODE, /**<JTAG protected mode, HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*//**<CNcomment: JTAG , HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_READ_DEACTIVATION, /**<Whether to disable to read OTP via JTAG, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: JTAGOTP , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_ROOTKEY, /**<CSA2 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA2 keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY, /**<R2R keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: R2R keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_ROOTKEY, /**<SP keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: SP keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_ROOTKEY, /**<CSA3 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA3 keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_ROOTKEY, /**<MISC keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY, /**<OEM keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: OEM keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ESCK_ROOTKEY, /**<ESCK keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: ESCK keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY, /**<JTAG key, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*//**<CNcomment: JTAG , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CHIP_ID, /**<Chip ID, HI_UNF_ADVCA_CHIPID_ATTR_S*//**<CNcomment: Chip ID, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MARKET_SEGMENT_ID, /**<Market segment ID, HI_UNF_ADVCA_MARKET_ID_ATTR_S*//**<CNcomment: Market segment ID , HI_UNF_ADVCA_MARKET_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID, /**<Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*//**<CNcomment: Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_LEVEL_SEL, /**<MISC keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: MISC keyladder , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VMX_BL_FUSE, /**<Burn verimatrix bootloader fuse*//**<CNcomment: verimatrixbootloader fuse*/
+    HI_UNF_ADVCA_OTP_IRDETO_ITCSA3_ACTIVATION, /**<Whether to enbale the tweaked CSA3, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOTINFO_DEACTIVATION, /**<Whether to disable the bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ITCSA3_IMLB, /**<tweaked CSA3 IMLB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3IMLB,HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_USB_DEACTIVATION, /**<Whether to disable the usb host, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: USB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SERIAL_DEACTIVATION, /**<Whether to disable serial port, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ETHERNET_DEACTIVATION, /**<Whether to disable the ethernet, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SM4_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the SM4 crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SM4 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TDES_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the TDES crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: TDES , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION_ONLY,   /**<Enable secure boot authentication only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment:  HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE,   /**<Boot flash type, HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*//**<CNcomment: flash HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_RSA_KEY_LOCK_FLAG,   /**< Get the lock flag of RSA_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: RSA_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_STBSN_LOCK_FLAG,   /**< Get the lock flag of STBSN, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: STBSN lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MSID_LOCK_FLAG,   /**< Get the lock flag of MSID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: MSID lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSIONID_LOCK_FLAG,   /**< Get the lock flag of VersionID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: VersionID lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of OEM_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: OEM_Root_key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of R2R_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: R2R_Root_key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY_LOCK_FLAG,   /**< Get the lock flag of JTAG key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: JTAG key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TZ_AREA_LOCK_FLAG,   /**< Get the lock flag of OTP trust area, when otp_tz_area_enable is set, these lock flags can only be accessed by secure cpu , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: OTP trust area lockotp_tz_area_enableCPUHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ENCRYPTION_DEACTIVATION, /**< whether to diable boot loader key generation, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: bootloader keyHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY,        /**<Boot keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: boot keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY,   /**<Sec store keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Sec store keyladder , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of BOOT_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: BOOT_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of SEC_STORE_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: SEC_STORE_Root_Key lockHI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SOS_MSID, /**< Get the security OS MSID (market segment id)*/ /**<CNcomment: MSID */
+    HI_UNF_ADVCA_OTP_REE_MSID, /**< Get MSID(market segment id) of REE images, Currently, this fuse is used for SBL(second boot loader) of VMX ultra*/ /**<CNcomment: REEMSID VMX ultraOTPboot*/
+    HI_UNF_ADVCA_OTP_SMK_EXT_KEY, /**<Dcas keyladder rkd SMK_EXT_KEY, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Dcas keyladder rkd key , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_FUSE_BUTT
+}HI_UNF_ADVCA_OTP_FUSE_E;
+
+/**Defines the attribute of secure boot check.*/
+/**CNcomment: */
+typedef struct hiUNF_ADVCA_OTP_SECURE_BOOT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is secure boot check enable or not*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type*/
+}HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S;
+
+/**Defines the boot flash type.*/
+/**CNcomment: flash*/
+typedef struct hiUNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S
+{
+    HI_BOOL bBootSelCtrl;    /**<0--the boot flash type is defined by chipset pin, 1--the boot flash type is defined by OTP value*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type, only valid when bBootSelCtrl is 1*/
+}HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S;
+
+/**Defines the default attribute of OTP fuse. If one OTP fuse can ONLY be "Enable" or "Disable",
+then we will use this attribute.*/
+/**CNcomment: OTP. OTP
+*/
+typedef struct hiUNF_ADVCA_OTP_DEFAULT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is the feature enable or not*/
+}HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S;
+
+/**Defines the attribute of the keyladder level.*/
+/**CNcomment: keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enKeyladderLevel;   /**<Keyladder level*/
+}HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S;
+
+/**Defines the attribute of the JTAG protected mode.*/
+/**CNcomment: JTAG.*/
+typedef struct hiUNF_ADVCA_JTAG_PRT_MODE_ATTR_S
+{
+    HI_UNF_ADVCA_JTAG_MODE_E enJtagMode;    /**<JTAG protection mode*/
+}HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S;
+
+/**Defines the attribute of the keyladder root key.*/
+/**CNcomment: keyladder .*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S
+{
+    HI_U8 u8RootKey[16];    /**<Root key of the keyladder*/
+}HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S;
+
+/**Defines the attribute of the JTAG key.*/
+/**CNcomment: JTAG.*/
+typedef struct hiUNF_ADVCA_JTAG_KEY_ATTR_S
+{
+    HI_U8 u8JtagKey[8];     /**<JTAG protected key*/
+}HI_UNF_ADVCA_JTAG_KEY_ATTR_S;
+
+/**Defines the attribute of the chip id.*/
+/**CNcomment: chip id.*/
+typedef struct hiUNF_ADVCA_CHIPID_ATTR_S
+{
+    HI_U8 au8ChipId[8];       /**<ChipID of the chipset, it is unique every chipset*/
+}HI_UNF_ADVCA_CHIPID_ATTR_S;
+
+/**Defines the attribute of the market segment id.*/
+/**CNcomment: market segment id.*/
+typedef struct hiUNF_ADVCA_MARKET_ID_ATTR_S
+{
+    HI_U8 u8MSID[4];    /**<Market Segment ID*/
+}HI_UNF_ADVCA_MARKET_ID_ATTR_S;
+
+/**Defines the attribute of the version id.*/
+/**CNcomment: version id.*/
+typedef struct hiUNF_ADVCA_VERSION_ID_ATTR_S
+{
+    HI_U8 u8VersionId[4];   /**<Bootloader Version ID*/
+}HI_UNF_ADVCA_VERSION_ID_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_BL_FUSE_ATTR_S
+{
+    HI_U32 u32VMXBLFuse;
+}HI_UNF_ADVCA_VMX_BL_FUSE_S;
+
+/**Defines the attribute of the tweaked CSA3 IMLB.*/
+/**CNcomment: tweaked CSA3 IMLB.*/
+typedef struct hiUNF_ADVCA_ITCSA3_IMLB_ATTR_S
+{
+    HI_U8 au8ItCsa3IMLB[2];   /**<tweaked CSA3 IMLB*/
+}HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S;
+
+/**Defines the attribute of the OTP fuse.*/
+/**CNcomment: OTP fuse.*/
+typedef struct hiUNF_ADVCA_OTP_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S          stDefaultAttr; /**<Default attribute, if one fuse can ONLY be "Enable" or "Disable", then we can use this attribute*/
+        HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S      stEnableSecureBoot; /**<Secure boot attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S  stKeyladderLevSel;  /**<Keyladder level attribute*/
+        HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S        stJtagPrtMode; /**<JTAG protected mode attribute*/
+        HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S    stKeyladderRootKey; /**<Keyladder rootkey attribute*/
+        HI_UNF_ADVCA_JTAG_KEY_ATTR_S             stJtagKey;   /**<JTAG key attribute*/
+        HI_UNF_ADVCA_CHIPID_ATTR_S               stChipId;     /**<Chip ID attribute*/
+        HI_UNF_ADVCA_MARKET_ID_ATTR_S            stMarketId;    /**<Market segment ID attribute*/
+        HI_UNF_ADVCA_VERSION_ID_ATTR_S           stVersionId;  /**<Bootloadder version ID attribute*/
+        HI_UNF_ADVCA_VMX_BL_FUSE_S               stVMXBLFuse;  /**<Vmx Bootloadder specific fuse attribute*/
+        HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S          stItCsa3IMLB; /**<tweaked CSA3 IMLB attribute*/
+        HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S  stBootFlashType;   /**<Boot flash type attribute*/
+    }unOtpFuseAttr;
+}HI_UNF_ADVCA_OTP_ATTR_S;
+
+/**Defines the attribute of the keyladder type ID.*/
+/**CNcomment: keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TYPE_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2 = 0,        /**<CSA2 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3,            /**<CSA3 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_R2R,             /**<R2R keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_SP,              /**<SP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_MISC,            /**<MISC keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_LP,              /**<LP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_TA,              /**<TA keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM,            /**<Google DRM key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE,        /**<Secure Store key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC,         /**<SWPK DEC key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC,         /**<SWPK ENC key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_TYPE_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TYPE_E;
+
+/**Defines the attribute of the CSA2 keyladder type ID.*/
+/**CNcomment: CSA2 keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E;
+
+/**Defines the attribute of the CSA3 keyladder type ID.*/
+/**CNcomment: CSA3 keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E;
+
+/**Defines the attribute of the R2R keyladder type ID.*/
+/**CNcomment: R2R keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_R2R_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E;
+
+/**Defines the attribute of the LP keyladder type ID.*/
+/**CNcomment: LP keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_LOAD_LPK = 0,            /**<Load Link protection key*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_DECRYPT_PROTECTED_DATA,   /**<Decrypt Link protected data*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_ALG,                       /**<LP Keyladder algorithm*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LP_ATTR_E;
+
+/**Defines the attribute of the LP keyladder.*/
+/**CNcomment: LP keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_E  enLPKlAttr; /**<LP keyladder attribute ID*/
+    HI_U8 u8Lpk[16];                                /**<Link protection key to be loaded*/
+    HI_U8 *pu8ProtectedData;                /**<Input link protected data to be decrypted*/
+    HI_U32 u32ProtectedDataLen;          /**<Input link protected data length*/
+    HI_U8 *pu8OutputProtectedData;   /**<Output link protected data after decryption*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<LP Keyladder algorithm, only support TDES/AES*/
+}HI_UNF_ADVCA_KEYLADDER_LP_ATTR_S;
+
+/**Defines the attribute of the SP keyladder type ID.*/
+/**CNcomment: SP keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ENABLE = 0,       /**<Use SPE keyladder or not for specal CA system */
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ALG ,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E;
+
+/**Defines the attribute of the MISC keyladder type ID.*/
+/**CNcomment: MISC keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_MISC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ENABLE = 0, /**<Use MISC keyladder or not. Before using the MISC keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ROOTKEY_SEL,       /**<MISC Keyladder Root key Selection*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E;
+
+/**Defines the attribute of the TA keyladder type ID.*/
+/**CNcomment: TA keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TA_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ENABLE = 0, /**<Use TA keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_LOAD_TRANDATA,   /**<Transformation data protection and loading*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E;
+
+/**Defines the attribute of the SECSTORE keyladder type ID.*/
+/**CNcomment: SECSTORE keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_ENABLE = 0, /**<Use SECSTORE keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E;
+
+/**Defines the attribute of the SWPK DEC keyladder type ID.*/
+/**CNcomment: SWPK DEC keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/SM4*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E;
+
+/**Defines the attribute of the SWPK ENC keyladder type ID.*/
+/**CNcomment: SWPK ENC keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/SM4*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E;
+
+/**Defines the attribute of the CSA2 keyladder.*/
+/**CNcomment: CSA2 keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E  enCsa2KlAttr; /**<CSA2 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S;
+
+/**Defines the attribute of the CSA3 keyladder.*/
+/**CNcomment: CSA3 keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E  enCsa3KlAttr; /**<CSA3 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                    /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S;
+
+/**Defines the attribute of the R2R keyladder.*/
+/**CNcomment: R2R keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_R2R_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E  enR2RKlAttr; /**<R2R keyladder attribute  ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S;
+
+/**Defines the attribute of the SP keyladder.*/
+/**CNcomment: SP keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E  enSPKlAttr; /**<SP keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use SP keyladder or not. Before using the SP keyladder*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S;
+
+
+
+/**Defines the attribute of the MISC keyladder.*/
+/**CNcomment: MISC keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_MISC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E  enMiscKlAttr; /**<MISC keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use MISC keyladder or not. Before using the MISC keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E enRootKeySel;    /**<MISC ROOT Key Selection*/
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: TA keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_TA_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E  enTAKlAttr; /**<TA keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use TA keyladder or not. Before using the TA keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 au8SessionKey[16];                                   /**<Session key*/
+    HI_U8 *pu8TranData;                                         /**<Transformation data*/
+    HI_U32 u32TranDataLen;                                  /**<Transformation data length*/
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S;
+
+/**Defines the attribute of the Google DRM keyladder type ID.*/
+/**CNcomment: Google DRM keyladderID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENABLE = 0,    /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should set this attribute to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT,       /**<Encrypt clear device key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG,       /**<Get flag*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E;
+
+/**Defines the attribute of Google DRM keyladder.*/
+/**CNcomment: Google DRM keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E  enGDRMKlAttr;
+    HI_BOOL bEnable;                                  /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should be set to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;       /**<Keyladder stage of the session key to be set*/
+    HI_HANDLE hCipherHandle;                    /**<cipher handle, if enStage is HI_UNF_ADVCA_KEYLADDER_LEV3, hCipherHandle should be set*/
+    HI_U8 au8SessionKey[32];                     /**<if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT it is clear device key, if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY, it is session key*/
+    HI_U8 au8Output[16];                          /**<if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT is set, it is encrypted device key, if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG is set, it is flag*/
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: TA keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E  enSECSTREKlAttr; /**<Secure STORE keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use Secure STORE keyladder or not. Before using the Secure STORE keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+}HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S;
+
+/**Defines the attribute of the SWPK DEC keyladder.*/
+/**CNcomment: SWPK DEC keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E  enSWPKDECKlAttr;     /**<SWPK DEC keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;                          /**<Keyladder algorithm, TDES/SM4*/
+}HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S;
+
+/**Defines the attribute of the SWPK ENC keyladder.*/
+/**CNcomment: SWPK ENC keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E  enSWPKENCKlAttr;     /**<SWPK ENC keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;                          /**<Keyladder algorithm, TDES/SM4*/
+}HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S;
+
+/**Defines the attribute of all of the keyladder.*/
+/**CNcomment:  keyladder.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S      stCSA2KlAttr;       /**<CSA2 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S      stCSA3KlAttr;       /**<CSA3 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S       stR2RKlAttr;        /**<R2R keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S        stSPKlAttr;         /**<SP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LP_ATTR_S        stLpKlAttr;         /**<LP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S      stMiscKlAttr;       /**<MISC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S        stTAKlAttr;         /**<TA keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S      stGDRMAttr;         /**<Google DRM keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S  stSECSTOREAttr;     /**<Secure STORE keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S   stSWPKDECKlAttr;    /**<SWPKDEC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S   stSWPKENCKlAttr;    /**<SWPKENE keyladder attribute*/
+    }unKlAttr;
+}HI_UNF_ADVCA_KEYLADDER_ATTR_S;
+
+
+/**Defines the attribute of the CA vendor type ID.*/
+/**CNcomment: CA vendorID.*/
+typedef enum hiUNF_ADVCA_CA_VENDOR_OPT_E
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CHIP_CONF_CMAC = 0, /**<To generate a secure message authentication code (MAC) tag for the OTP configuration data*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_CALC,  /**<To calculate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_AUTH,  /**<To authenticate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_ACTIVATION_CODE, /**<To set the activation code for tweaked CSA3.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_VMX_GET_RNG, /**<To get the RNG number, ONLY used for verimatrix currently.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_BUTT
+}HI_UNF_ADVCA_CA_VENDOR_OPT_E;
+
+/**Defines the attribute of chip configuration CMAC.*/
+/**CNcomment: OTPCMAC.*/
+typedef struct hiUNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S
+{
+    HI_U8 au8ChipConfBitm[16]; /**<128bit Chip configuration bit map*/
+    HI_U8 au8ChipConfCmac[16];   /**<128bit Chip configuration CMAC*/
+}HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S;
+
+/**Defines the attribute of the tweak CSA3, Activation Code.*/
+/**CNcomment: CSA3ACTIVATION CODE.*/
+typedef struct hiUNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S
+{
+    HI_U8 au8CSA3ActCode[16];   /**<128bit tweak CSA3 Activation Code*/
+}HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S;
+
+/**Defines the attribute of the high level code CBC-MAC authentication.*/
+/**CNcomment: CBC-MAC.*/
+typedef struct hiUNF_ADVCA_IRDETO_CBCMAC_ATTR_S
+{
+    HI_U8 *pu8InputData;
+    HI_U32 u32InputDataLen;
+    HI_U8 au8OutputCBCMAC[16];
+    HI_U8 au8RefCBCMAC[16];  /**<Reference CBC-MAC*/
+    HI_U32 u32AppLen; /**<High level code length*/
+}HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_GetRNG_S
+{
+    HI_U32 u32RNG;
+}HI_UNF_ADVCA_VMX_GetRNG_S;
+
+/**Defines the attribute of the CA vendor private function.*/
+/**CNcomment: CA.*/
+typedef struct hiADVCA_CA_VENDOR_OPT_S
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_E enCaVendorOpt;
+    union
+    {
+        HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S     stIrdetoChipConfCmac;
+        HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S    stIrdetoCsa3ActCode;
+        HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S             stIrdetoCbcMac;
+        HI_UNF_ADVCA_VMX_GetRNG_S                     stVMXRng;
+    }unCaVendorOpt;
+}HI_UNF_ADVCA_CA_VENDOR_OPT_S;
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/**
+\brief Initializes the advanced CA module CNcomment:advance CA CNend
+\attention \n
+Call this application programming interface (API) before using the advanced CA module.
+The code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:advance CA\n
+ CNend
+\param N/A CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_OPEN_ERR The CA device fails to start CNcomment:HI_ERR_CA_OPEN_ERR CA CNend
+\see \n
+::HI_UNF_ADVCA_DeInit
+*/
+HI_S32 HI_UNF_ADVCA_Init(HI_VOID);
+
+/**
+\brief Deinitializes the advanced CA module CNcomment:advance CA CNend
+\attention \n
+None CNcomment: CNend
+\param N/A CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DeInit(HI_VOID);
+
+/**
+\brief Set the ChipId CNcomment:ChipId  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+CHIP_ID should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:\n  CNend
+CNcomment:\n
+CHIP_IDCA\n  CNend
+\param[in] Id chip id CNcomment:Id chip id\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\see \n
+::HI_UNF_ADVCA_SetChipId
+*/
+HI_S32 HI_UNF_ADVCA_SetChipId(HI_U32 Id);
+
+/**
+\brief Obtains the chip ID CNcomment:ID  CNend
+\attention \n
+The chip ID is read-only.
+CNcomment:ID CNend
+\param[out] pu32ChipId Chip ID CNcomment:pu32ChipId   ID  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetChipId(HI_U32 *pu32ChipId);
+
+
+/**
+\brief Obtains the market ID CNcomment:Market ID  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8MarketId market ID CNcomment:pu8MarketId    CNend
+\param[in] u32MarketIdLen market ID length, must be equal to 4 CNcomment:u32MarketIdLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetMarketId
+*/
+HI_S32 HI_UNF_ADVCA_GetMarketId(HI_U8 *pu8MarketId, HI_U32 u32MarketIdLen);
+
+/**
+\brief Sets the Market ID CNcomment:Market ID  CNend
+\attention \n
+The market ID of the set-top box (STB) is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] pu8MarketId market ID CNcomment:pu8MarketId    CNend
+\param[in] u32MarketIdLen market ID length, must be equal to 4 CNcomment:u32MarketIdLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetMarketId(HI_U8 *pu8MarketId, HI_U32 u32MarketIdLen);
+
+/**
+\brief Obtains the serial number of the STB CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8StbSn Serial number of the STB CNcomment:pu8StbSn    CNend
+\param[in] u32StbSnLen Serial number length, must be equal to 4 CNcomment:u32StbSnLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_SetStbSn
+*/
+HI_S32 HI_UNF_ADVCA_GetStbSn(HI_U8 *pu8StbSn, HI_U32 u32StbSnLen);
+
+/**
+\brief Sets the serial number of the STB CNcomment: CNend
+\attention \n
+The serial number of the STB is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] pu8StbSn serial number of the STB CNcomment:pu8StbSn    CNend
+\param[in] u32StbSnLen Serial number length, must be equal to 4 CNcomment:u32StbSnLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetStbSn(HI_U8 *pu8StbSn, HI_U32 u32StbSnLen);
+
+/**
+\brief Set the R2R RootKey and lock it. CNcomment:R2R RootKey  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+R2R RootKey should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:,\n
+R2RRootKeyCA\n  CNend
+\param[in] pkey R2R Root Key CNcomment:pkey  R2R\n  CNend
+\param[in] u32KeyLen R2R Root key length, must be equal to 16. CNcomment:u32KeyLen R2R16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RRootKey(HI_U8* pkey, HI_U32 u32KeyLen);
+
+/**
+\brief Obtains the security startup enable status CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable: Security startup enable. CNcomment:pbEnable    CNend
+HI_TRUE enabled CNcomment:HI_TRUE   CNend
+HI_FALSE disabled CNcomment:HI_FALSE  CNend
+\param[out] penFlashType the startup flash type, only valid when SCS is enable
+CNcomment:penFlashType Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSecBootStat(HI_BOOL *pbEnable,HI_UNF_ADVCA_FLASH_TYPE_E *penFlashType);
+
+/**
+\brief Obtains the mode of the JTAG interface CNcomment:JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Mode of the JTAG interface CNcomment:penJtagMode   JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E *penJtagMode);
+
+/**
+\brief Sets the mode of the JTAG interface CNcomment:JTAG   CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG interface CNcomment:enJtagMode   JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Obtains the R2R key ladder stage CNcomment:R2R key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the R2R key ladder stage CNcomment:R2R key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3
+CNcomment:enStage   key ladder\n HI_UNF_ADVCA_KEYLADDER_LEV2  HI_UNF_ADVCA_KEYLADDER_LEV3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the digital video broadcasting (DVB) key ladder stage CNcomment:DVB key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the DVB key ladder stage CNcomment:DVB key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the CSA3 key ladder stage CNcomment:CSA3 key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the CSA3 key ladder stage CNcomment:CSA3 key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Sets session keys for an R2R key ladder CNcomment:R2R key ladder    CNend
+\attention \n
+
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetR2RKeyLadderStage first.
+Session keys can be set during initialization or changed at any time.
+CNcomment:CIPHER\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetR2RKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The R2R decryption fails CNcomment:HI_ERR_CA_R2R_DECRYPT  R2R CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8* pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets session keys for a DVB key ladder CNcomment:DVB key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetDVBKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets session keys for a CSA3 key ladder CNcomment:CSA3 key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetDVBKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3SessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Set widevine keyladder session key CNcomment:widevine keyladder CNend
+\param[in]  enLevel keyladder level for input CNcomment:enLevel  CNend
+\param[in]  hCipherHandle cipher handle input when level 3 CNcomment:hCipherHandle Cipher CNend
+\param[in]  pu8Input input data for keyladder CNcomment:pu8Input  keyladder CNend
+\param[in]  u32InputLen input data length CNcomment:u32InputLen  CNend
+\param[out] pu32GdrmFlag the flag value when level 3 CNcomment:pu32GdrmFlag  GDRM  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA    CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT     CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK CNend
+\see
+\li ::
+*/
+HI_S32 HI_UNF_ADVCA_SetGDRMSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enLevel,
+                                    HI_HANDLE hCipherHandle,
+                                    HI_U8 *pu8Input,
+                                    HI_U32 u32InputLen,
+                                    HI_U32 *pu32GdrmFlag);
+
+
+/**
+\brief Encrypts software protect keys (SWPKs) CNcomment: CNend
+\attention
+Before the delivery of the STB, you need to read the SWPKs in plain text format from the flash memory, encrypt SWPKs by calling this API, and store the encrypted SWPKs in the flash memory for security startup.
+CNcomment: FlashSWPK(Software Protect Key),,SWPKFlash CNend
+The fist 8 bytes of the SWPK can't be equal to the last 8 bytes.
+CNcomment:SWPK88 CNend
+This API is only for special CA, please contact Hislicon before usage.
+CNcomment::CA CNend
+\param[in]  pPlainSwpk SWPKs in plain text format CNcomment:pPlainSwpk    SWPK  CNend
+\param[in] u32PlainSwpkLen SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen SWPK16 CNend
+\param[out] pEncryptedSwpk Encrypted SWPKs CNcomment:pEncryptedSwpk  SWPK  CNend
+\param[in] u32PlainSwpkLen Encrypted SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen SWPK16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA    CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT     CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EncryptSWPK(HI_U8 *pPlainSwpk, HI_U32 u32PlainSwpkLen, HI_U8 *pEncryptedSwpk, HI_U32 u32EncryptedSwpkLen);
+
+/**
+\brief Sets the algorithm of the DVB key ladder CNcomment:DVB key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the CSA2 key ladder CNcomment:CSA3 key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3Alg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the R2R key ladder CNcomment:R2R key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the DVB key ladder CNcomment:  DVB key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Obtains the algorithm of the R2R key ladder CNcomment: R2R key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+  \brief set RSA key CNcomment:RSA CNeng
+  \attention \n
+  If the mass-produced chipset have been set RSA Key by CA, there's no need to use this API to set RSA Key again.
+  This API can been called only once, please be careful, after setting RSA key, you should lock it by call API
+  HI_UNF_ADVCA_ConfigLockFlag.The length of RSA key must be 512 Bytes.
+  CNcomment:CARSAKey,RSAKey\n
+     ,,RSAKey\n
+     HI_UNF_ADVCA_ConfigLockFlag RSA key512 Bytes  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA\n  CNend
+  \param[in] u32KeyLen RSA key length, must be equal to 512. CNcomment:u32KeyLen RSA512 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetRSAKey(HI_U8 *pkey, HI_U32 u32KeyLen);
+
+/**
+  \brief set RSA key CNcomment:RSA CNend
+  \attention \n
+     RSA key can be read out when only the RSAKey is not locked,The length of RSA key is 512 Bytes.
+     RSA key should have been setting and lock before chipset is delivered to STB Manufacture.
+     Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:RSAkey, RSA key512 Bytes\n
+     RSA keyCA\n  CNend
+  \param[out] pkey RSA key CNcomment:pkey  RSA\n  CNend
+  \param[in] u32KeyLen RSA key length, must be equal to 512. CNcomment:u32KeyLen RSA512 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRSAKey(HI_U8 *pkey, HI_U32 u32KeyLen);
+
+/**
+  \brief set RSA key CNcomment:RSA CNend
+  \attention \n
+    This API is used to lock RSA KEY/Trustzone OTP\misc keyladder etc.Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:RSAkey\Trustzone OTP\misc keyladder\n  CNend
+  \param[enType] enType the type you want to lock.  CNcomment:enType  \n  CNend
+  \param[pu8ParamIn] pu8ParamIn reserved, default is null. CNcomment:pu8ParamIn  null\n  CNend
+  \param[u32ParamLen] u32ParamLen reserved, default is 0. CNcomment:u32ParamLen  0\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_ConfigLockFlag(HI_UNF_ADVCA_LOCK_TYPE_E enType, HI_U8 *pu8ParamIn, HI_U32 u32ParamLen);
+
+
+/**
+  \brief This function is used to check if the MarketID is already set
+  \attention \n
+  None
+  \param[in] pbIsMarketIdSet: the pointer point to the buffer to store the return value
+  \param[out] pbIsMarketIdSet: save the return value
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_IsMarketIdSet(HI_BOOL *pbIsMarketIdSet);
+
+/**
+  \brief This function is used to get the vendor type of the chipset
+  \attention \n
+  None
+  \param[out] pu32VendorID: The number indicates the vendor id
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVendorID(HI_U32 *pu32VendorID);
+
+/**
+\brief Enables the security startup function and sets the type of flash memory for security startup
+CNcomment:,Flash CNend
+\attention \n
+This function can be enabled only and cannot be disabled after being enabled.
+CNcomment: CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBoot(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief Enables the security startup function. This API should be used with the API HI_UNF_ADVCA_SetFlashTypeEx.
+CNcomment:HI_UNF_ADVCA_SetFlashTypeEx CNend
+\attention \n
+\param[in]  None
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBootEx(HI_VOID);
+
+/**
+\brief Sets the type of flash memory for security startup and disable the self boot, which mean that you cannot use the serial port to update the boot. This API should be used with the API HI_UNF_ADVCA_EnableSecBootEx
+CNcomment:FlashfastbootHI_UNF_ADVCA_EnableSecBootEx CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment: CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  Flash CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetFlashTypeEx(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief  Sets whether to use hardware CWs only CNcomment:CW CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the CW type (hardware CWs or software CWs) depends on the configuration of the DEMUX.
+CNcomment:
+DemuxCWCW CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockHardCwSel(HI_VOID);
+
+/**
+\brief Disables the self-boot function CNcomment:SelfBoot,boot/ CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:
+SelfBoot CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized.  CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Obtains the self-boot status CNcomment:SelfBoot CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable: self-boot status. CNcomment:pbEnable   SelfBoot CNend
+HI_TRUE enabled CNcomment:HI_TRUE   CNend
+HI_FALSE disabled CNcomment:HI_FALSE  CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSelfBootStat(HI_BOOL *pbDisable);
+
+/**
+\brief  Get whether to use hardware CWs only CNcomment:CW CNend
+\attention
+None CNcomment: CNend
+\param[out] pbLock indicates the state of hardware CWs  CNcomment:pbLock CW CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetHardCwSelStat(HI_BOOL *pbLock);
+
+/**
+\brief  Open the SWPK key ladder CNcomment:boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderOpen(HI_VOID);
+
+/**
+\brief  Close the SWPK key ladder CNcomment:boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderClose(HI_VOID);
+
+/**
+\brief Obtains the Version ID CNcomment:Version ID  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8VersionId Version ID CNcomment:pu8VersionId    CNend
+\param[in] u32VersionIdLen Version ID length, must be equal to 4 CNcomment:u32VersionIdLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetVersionId
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionId(HI_U8 *pu8VersionId, HI_U32 u32VersionIdLen);
+
+/**
+\brief Sets the Version ID CNcomment:Version ID  CNend
+\attention \n
+The version ID of the set-top box (STB) is set before delivery. The version ID can be set once only and takes effects after the STB restarts.
+CNcomment:  CNend
+\param[in] pu8VersionId version ID CNcomment:pu8VersionId    CNend
+\param[in] u32VersionIdLen Version ID length, must be equal to 4 CNcomment:u32VersionIdLen   4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetVersionId(HI_U8 *pu8VersionId, HI_U32 u32VersionIdLen);
+
+/**
+\brief  Sets whether to check the boot version CNcomment:Version  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the version check function is disabled
+CNcomment:
+version check  CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableVersionCheck(HI_VOID);
+
+/**
+\brief  Get the boot version check flag CNcomment:version CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat boot version check flag CNcomment:pu32Stat    version CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Sets whether to check the MSID in boot area CNcomment:boot areaMSID  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the boot MSID check function is disabled
+CNcomment:
+boot MSID check  CNend
+\param none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableBootMSIDCheck(HI_VOID);
+
+/**
+\brief  Get the boot MSID check flag CNcomment:MSID CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat boot MSID check flag CNcomment:pu32Stat    MSID CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootMSIDCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Get the software revision
+CNcomment:revision CNend
+\attention \n
+None CNcomment: CNend
+\param[out] revision string of Revision CNcomment:revision    Revision CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRevision(HI_U8 revision[25]);
+
+/**
+\brief  Set the DDR Scramble flag. Normally, this flag has been set as required by CA vendor
+CNcomment:DDRCA CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDDRScramble(HI_VOID);
+
+/**
+\brief  Get the DDR Scramble flag
+CNcomment:DDR CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat DDR Scramble flag CNcomment:pu32Stat    DDR CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDDRScrambleStat(HI_U32 *pu32Stat);
+
+/**
+\brief Sets whether to decrypt the BootLoader CNcomment:BootLoader CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+CNcomment:
+FlashBootLoader CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                   CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN     CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockBootDecEn(HI_VOID);
+
+/**
+\brief Get the BootLoader Decryption flag CNcomment:BootLoader CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu32Stat BootLoader Decryption flag CNcomment:pu32Stat    Bootloader CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootDecEnStat(HI_U32 *pu32Stat);
+
+
+
+/**
+\brief  Calculte the AES_CMAC value of data
+CNcomment: AES_CMAC  CNend
+\attention \n
+None CNcomment: CNend
+
+\param[in]  buffer  pointer of data buffer .        CNcomment:buffer  CNend
+\param[in]  Length  The length  of data .   CNcomment: CNend
+\param[in]  pKey   The key used in Calculte the AES_CMAC of data           CNcomment:pKey AES_CMAC key  CNend
+\param[in] u32KeyLen pKey length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+\param[out]  pCMAC   The AES_CMAC value          CNcomment:pCMAC AES_CMAC  CNend
+\param[in] u32CMACLen AES_CMAC length, must be equal to 16. CNcomment:u32CMACLen AES_CMAC16 CNend
+\retval ::HI_SUCCESS  Success                 CNcomment: CNend
+\retval ::HI_FAILURE    Failure                     CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_CalculteAES_CMAC(HI_U8 *buffer, HI_U32 Length, HI_U8 *pKey, HI_U32 u32KeyLen, HI_U8 *pCMAC, HI_U32 u32CMACLen);
+
+/**
+\brief Sets the algorithm of the SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_ALG_TYPE_TDES\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the SP key ladder CNcomment:  SP key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Sets the SP key ladder stage CNcomment:SP key ladder    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:  ,stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder\n HI_UNF_ADVCA_KEYLADDER_lev2  HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the SP key ladder stage CNcomment:SP key ladder CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+
+/**
+\brief Sets session keys for a SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetSPKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:Descrambler\n
+3key ladder12\n
+2key ladder1\n
+HI_UNF_ADVCA_SetSPKeyLadderStagekey ladder\n
+ CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    [HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetSPSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets the descramble mode of the SP key ladder CNcomment:SP key ladder    CNend
+\attention \n
+You must set a descramble mode before using a key ladder in a session. The default algorithm is HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI.
+It is recommended that you retain the descramble mode in a session.
+CNcomment:key ladder,  HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI\n
+ CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E enType);
+
+/**
+\brief Obtains the descramble mode of the SP key ladder CNcomment:  SP key ladder    CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E *pEnType);
+
+/**
+  \brief this function is used by the Novel CA for the encryption and decryption setting
+   CNcomment:Novelkey CNend
+  \attention \n
+  This function is used for the Novel encryption and decrption
+  CNcomment:   Novel keyladderkey CNend
+  \retval ::HI_SUCCESS Success  CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called  CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelCryptologyConfig(HI_VOID);
+
+/**
+  \brief Used for Novel CA to encrypt the data  CNcomment:Novel CNend
+  \attention \n
+  None  CNcomment:  CNend
+  \param[in]  pPlainText: the buffer to store the data to be encrypted CNcomment:pPlainText  CNend
+  \param[in]  TextLen: the length of the data to be encrypted CNcomment:TextLen     CNend
+  \param[in]  pCipherText: the buffer to store the encrypted data CNcomment:pCipherText  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataEncrypt(HI_U8 *pPlainText, HI_U32 TextLen, HI_U8 *pCipherText);
+
+/**
+  \brief This function is used for Novel to decrypt the data CNcomment:TextNovel CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  pPlainText: point to the data to be decrypted CNcomment:pPlainText  CNend
+  \param[in]  TextLen: the length of the data to be decrypted CNcomment:TextLen     CNend
+  \param[in]  pCipherText: the buffer store the decrypted data CNcomment:pCipherText  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataDecrypt(HI_U8 *pCipherText, HI_U32 TextLen, HI_U8 *pPlainText);
+
+/**
+\brief Sets oem root key it's mainly used for widevine keyladder CNcomment:OEM_root_key Widevine keyladder    CNend
+\attention \n
+This root key could only be written only once be careful, thanks    CNcomment: , CNend
+\param[in] pu8OEMRootKey buffer of the input key    CNcomment:pu8OEMRootKey    buffer  CNend
+\param[in] u32KeyLen key length of the input CNcomment:u32KeyLen     16  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW CNend
+
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOEMRootKey(HI_U8 *pu8OEMRootKey, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to open the DCAS CNcomment:DCAS CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enAlg: DCAS keyladder algorithm CNcomment:enAlg DCAS keyladder CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASOpen(HI_UNF_CIPHER_ALG_E enAlg);
+
+/**
+  \brief This function is used to get the DCAS CHIPID CNcomment:DCAS CHIPID
+  \attention \n
+  None  CNcomment: CNend
+  \param[out]  pu32MSBID: First 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID4 CNend
+  \param[out]  pu32LSBID: last 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID4 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDCASChipId(HI_U32 *pu32MSBID, HI_U32 *pu32LSBID);
+
+/**
+  \brief This function is used to set the session key CNcomment:DCAS session CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enDCASLevel: the DCAS keyladder level CNcomment:enAlg DCAS keyladder CNend
+  \param[in]  pu8Key: the DCAS keyladder session key CNcomment:enAlg DCAS keyladder CNend
+  \param[in] u32KeyLen DCAS keyladder session key length, must be equal to 16. CNcomment:u32KeyLen DCAS keyladder16 CNend
+  \param[out]  pu8Output: the output of the DCAS keyladder CNcomment:pu8Output DCAS keyladder CNend
+  \param[in] u32OutputLen Output length, must be equal to 16. CNcomment:u32OutputLen DCAS keyladder16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDCASSessionKey(HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E enDCASLevel,
+                            HI_U8 *pu8Key , HI_U32 u32KeyLen, HI_U8 *pu8Output,  HI_U32 u32OutputLen);
+
+/**
+  \brief This function is used to close the DCAS keyladder CNcomment:DCAS CNend
+  \attention \n
+  None  CNcomment: CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see  \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASClose(HI_VOID);
+
+/**
+  \brief This function is used to set the OTP fuse. CNcomment:OTP CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse OTPID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr OTP CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to get the OTP fuse. CNcomment:OTP CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse OTPID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr OTP CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to set the keyladder attribute. CNcomment:keyladder CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enKeyLadderType: The keyladder type ID CNcomment:enKeyLadderType KeyladderID CNend
+  \param[in]  pstKeyladderAttr: The keyladder attribute CNcomment:pstKeyladderAttr keyladderCNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetKeyLadderAttr(HI_UNF_ADVCA_KEYLADDER_TYPE_E enKeyLadderType, HI_UNF_ADVCA_KEYLADDER_ATTR_S *pstKeyladderAttr);
+
+/**
+  \brief This function is used to achieve the CA vendor privated function. CNcomment:CA CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  enCaVendor: The CA vendor type ID CNcomment:enCaVendor CA vendorID CNend
+  \param[in]  pstCavendorOpt: The parameter to achieve the CA vendor private function CNcomment:pstCavendorOpt CACNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS   CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_CaVendorOperation(HI_UNF_ADVCA_VENDORID_E enCaVendor, HI_UNF_ADVCA_CA_VENDOR_OPT_S *pstCaVendorOpt);
+
+/**
+  \brief This function is used to set the session key CNcomment:LP session CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  pu8Key: the LP keyladder session key CNcomment:enAlg LP keyladder CNend
+  \param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetLPSessionKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to generate the clear key CNcomment:LP  CNend
+  \attention \n
+  None  CNcomment: CNend
+  \param[in]  pEncryptedKey: the LP keyladder encrypted key CNcomment:key CNend
+  \param[in] u32EncryptedSwpkLen SWPK length, must be equal to 16. CNcomment:u32EncryptedSwpkLen  SWPK16 CNend
+  \param[out]  pPlainKey: the LP keyladder clear key CNcomment:key CNend
+  \param[in] u32PlainSwpkLen SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen SWPK16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+  \see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_ADVCA_DecryptLPKey(HI_U8 *pEncryptedSwpk, HI_U32 u32EncryptedSwpkLen, HI_U8 *pPlainSwpk, HI_U32 u32PlainSwpkLen);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ADVCA_H__ */
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_aenc.h b/xbmc/platform/linux/hisi/hi_unf_aenc.h
new file mode 100644
index 0000000000..fdb3ee77dd
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_aenc.h
@@ -0,0 +1,271 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_aenc.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       :
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        :
+  Modification  : Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief describle the information about AENC. CNcomment:AENC CNend
+ */
+
+#ifndef  __HI_UNF_AENC_H__
+#define  __HI_UNF_AENC_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_UNF_AENC_MAX_TYPE 1
+
+/* AENC Capability Description */
+/**CNcomment: */
+typedef struct
+{
+    HA_CODEC_ID_E  enCodecType; /* support aenc type */
+} HI_UNF_AENC_CAP_INFO_S;
+
+typedef struct
+{
+    HI_U32 u32SupportTypeNum;                               /* support aenc type num */
+    HI_U32 u32MaxAencInstance;                              /* maximum running aenc encoder */
+    HI_UNF_AENC_CAP_INFO_S stCapInfo[HI_UNF_AENC_MAX_TYPE]; /* capability information for each aenc type */
+} HI_UNF_AENC_CAP_S;
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      AENC */
+/** @{ */  /** <!-- [AENC] */
+
+/**
+\brief Initializes audio encoder. CNcomment: CNend
+\attention \n
+Call the interface before calling HI_UNF_AENC_Open. CNcomment:HI_UNF_AENC_Open CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Init(HI_VOID);
+
+/**
+\brief Deinitializes audio encoder. CNcomment: CNend
+\attention \n
+N/A
+\param N/A
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  Invalid operation CNcomment:HI_ERR_AENC_CH_NOT_SUPPORT  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_DeInit(HI_VOID);
+
+/**
+\brief Create audio encoder. CNcomment: CNend
+\attention \n
+Before calling the interface, you must configure the encoder. Now AENC only supports 16-bit and 2 channels, and support 16K, 22K, 24K, 32K, 44K, or 48Ksample rate.
+CNcomment:AENC16216K 22K 24K 32K 44K48K CNend
+\param[in] pstAencAttr               Attribute structure of the audio encoder. CNcomment: CNend
+\param[out] phAenc                   Obtain the handle of the audio encoder. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR        The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AENC_CREATECH_FAIL   The encoder fails to be created. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Create(const HI_UNF_AENC_ATTR_S* pstAencAttr, HI_HANDLE* phAenc);
+
+/**
+\brief Destroy the audio encoder. CNcomment: CNend
+\attention \n
+\param[in] phAenc the handle of the audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  The operation is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_OPEN     The audio encoder is not opened. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Destroy(HI_HANDLE hAenc);
+
+/**
+\brief Copy data to the encoder for encoding. CNcomment: CNend
+\attention \n
+\param[in] phAenc     The audio encoder handle CNcomment: CNend
+\param[in] pstAOFrame Send a frame of data to the encoder. CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AENC_IN_BUF_FULL      The input buffer of the encoder is full. CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT   The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_SendFrame(HI_HANDLE hAenc, const HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief Obtain data from a output buffer of the encoder and write the data into the file. CNcomment: CNend
+\attention \n
+\param[in] phAenc     The audio encoder handle CNcomment: CNend
+\param[in] pstStream  The data in a output buffer of the audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_OUT_BUF_EMPTY   The output buffer of the encoder is empty. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_AcquireStream(HI_HANDLE hAenc, HI_UNF_ES_BUF_S* pstStream, HI_U32 u32TimeoutMs);
+
+/**
+\brief Destroy the data in a output buffer of the encoder. CNcomment: CNend
+\attention \n
+Call the interface after calling HI_UNF_AENC_ReceiveStream. CNcomment:HI_UNF_AENC_ReceiveStream CNend
+\param[in] phAenc     The handle of audio encoder CNcomment: CNend
+\param[in] u32TimeoutMs   allowable timeout  CNcomment: CNend
+\param[out] pstStream  The data in a output buffer of the audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA   The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_OUT_BUF_BAD    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_IN_BUF_UNEMPTY The input buffer is empty. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_ReleaseStream(HI_HANDLE hAenc, const HI_UNF_ES_BUF_S* pstStream);
+
+/**
+\brief Register dynamic audio encoding libraries. CNcomment: CNend
+\attention \n
+\param[in] pEncoderDllName The file name of audio encoding  libraries CNcomment:pEncoderDllName  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_RegisterEncoder(const HI_CHAR* pEncoderDllName);
+
+/**
+\brief Attach audio encoder with audio track. CNcomment:Track  CNend
+\attention \n
+Before obtaining the streams and encoding, you must call the interface. CNcomment: CNend
+\param[in] hSrc   The handle of audio track CNcomment: CNend
+\param[in] hAenc     The handle of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT        The operation is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_AttachInput(HI_HANDLE hAenc, HI_HANDLE hSrc);
+
+/**
+\brief Detach audio encoder with audio track. CNcomment:Track  CNend
+\attention \n
+Before calling the interface, stop the encoding. CNcomment: CNend
+\param[in] hAenc     The handle of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT        The operation is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_DetachInput(HI_HANDLE hAenc);
+
+/**
+\brief Start to encode. CNcomment: CNend
+\attention \n
+Before calling the interface, you need to initialize the encoder, create an encoding channel and attach the player.
+CNcomment: CNend
+\param[in] hAenc The handle of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_Start(HI_HANDLE hAenc);
+
+/**
+\brief Stop to encode. CNcomment: CNend
+\attention \n
+Before calling the interface, you need to initialize the encoder, create an encoding channel, attach the player, and start the encoding.
+CNcomment: CNend
+\param[in] hAenc   The handle of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_Stop(HI_HANDLE hAenc);
+
+/**
+\brief Set the attribution of encode. CNcomment: CNend
+\attention \n
+Before calling the interface, you need to stop the encoder.
+CNcomment:CNend
+\param[in] hAenc   The handle of audio encoder CNcomment: CNend
+\param[in] pstAencAttr   The attribution of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_SetAttr(HI_HANDLE hAenc, const HI_UNF_AENC_ATTR_S* pstAencAttr);
+
+/**
+\brief Set the attribution of encode. CNcomment: CNend
+\attention \n
+\param[in] hAenc   The handle of audio encoder CNcomment: CNend
+\param[out] pstAencAttr   The attribution of audio encoder CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AENC_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AENC_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_GetAttr(HI_HANDLE hAenc, HI_UNF_AENC_ATTR_S* pstAencAttr);
+
+/**
+\brief get AENC capability. CNcomment: CNend
+\attention \n
+\param[in] pstCapability The returned capability of AENC CNcomment:pstCapability  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_GetCapability(HI_UNF_AENC_CAP_S* pstCapability);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_AENC_H__*/
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_ai.h b/xbmc/platform/linux/hisi/hi_unf_ai.h
new file mode 100644
index 0000000000..67aae65def
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_ai.h
@@ -0,0 +1,340 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_ai.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013/4/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : zgjie
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio input (AI) module. CNcomment:AI CNend
+ */
+
+#ifndef  __HI_UNF_AI_H__
+#define  __HI_UNF_AI_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/********************************Macro Definition********************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!-- AI */
+
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  AI */
+
+
+
+
+/**Audio inputport defination */
+/**CNcomment:*/
+typedef enum hiUNF_AI_E
+{
+    HI_UNF_AI_I2S0 = 0,
+
+    HI_UNF_AI_I2S1,
+
+    HI_UNF_AI_ADC0 = 0x10,
+
+    HI_UNF_AI_ADC1,
+
+    HI_UNF_AI_ADC2,
+
+    HI_UNF_AI_ADC3,
+
+    HI_UNF_AI_ADC4,
+
+    HI_UNF_AI_SIF0 = 0x20,
+
+    HI_UNF_AI_HDMI0 = 0x30,
+
+    HI_UNF_AI_HDMI1,
+
+    HI_UNF_AI_HDMI2,
+
+    HI_UNF_AI_HDMI3,
+
+    HI_UNF_AI_BUTT = 0xff,
+} HI_UNF_AI_E;
+
+/**Defines internal Audio ADC inputport attribute */
+/**CNcomment:ADC*/
+typedef struct hiUNF_AI_ADC_ATTR_S
+{
+    HI_BOOL   bByPass;
+} HI_UNF_AI_ADC_ATTR_S;
+
+
+/**Defines  Audio I2S inputport attribute */
+/**CNcomment:I2S*/
+typedef struct hiUNF_AI_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;  /**<I2S Attribute*/ /**<CNcomment:I2S*/
+}  HI_UNF_AI_I2S_ATTR_S;
+
+/**Defines the HDMI RX Audio data format .*/
+typedef enum hiHI_UNF_AI_HDMI_FORMAT_E
+{
+    HI_UNF_AI_HDMI_FORMAT_LPCM = 0,          /* LPCM 2/8 channels,  Audio Sample Packet layout0 or layout1 */ 
+    HI_UNF_AI_HDMI_FORMAT_LBR = 1,           /* IEC-61937 DD/DDP/DTS, Audio Sample Packet layout0 */ 
+    HI_UNF_AI_HDMI_FORMAT_HBR = 8,           /* IEC-61937 DTSHD/TrueHD, High-Bitrate (HBR) Audio Stream Packet*/ 
+    HI_UNF_AI_HDMI_FORMAT_BUTT
+} HI_UNF_AI_HDMI_FORMAT_E;
+
+
+/**Defines  HDMI Audio inputport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_AI_HDMI_ATTR_S
+{
+    HI_UNF_I2S_CHNUM_E    enChannel;    /**<Channel number*/ /**<CNcomment:*/
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;   /**<Bit Depth*/ /**<CNcomment:*/
+    HI_UNF_SAMPLE_RATE_E  enSampleRate; /**<Sample Rate*/ /**<CNcomment:*/
+    HI_UNF_AI_HDMI_FORMAT_E enHdmiAudioDataFormat;  /**<HDMI audio data format*/ /**<CNcomment:HDMI*/
+} HI_UNF_AI_HDMI_ATTR_S;
+
+/**Defines internal SIF(Audio Demodulator) inputport attribute */
+/**CNcomment:SIF*/
+typedef struct hiUNF_AI_SIF_ATTR_S
+{
+    HI_VOID* pPara;
+} HI_UNF_AI_SIF_ATTR_S;
+
+/**Defines  Audio inputport attribute */
+/**CNcomment:*/
+typedef struct hiHI_UNF_AI_ATTR_S
+{
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;          /**<samplerate, default 48000Hz*/ /**<CNcomment: 48000Hz*/
+    HI_U32                  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer, default 16*/ /**<CNcomment:  16*/
+    HI_U32                  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data, default 960*/ /**<CNcomment: PCM 960*/
+    union
+    {
+        HI_UNF_AI_ADC_ATTR_S  stAdcAttr;    /**<ADC Attribute*/ /**<CNcomment:ADC*/
+        HI_UNF_AI_I2S_ATTR_S  stI2sAttr;    /**<I2S Attribute*/ /**<CNcomment:I2S*/
+        HI_UNF_AI_HDMI_ATTR_S stHDMIAttr;   /**<HDMI Attribute*/ /**<CNcomment:HDMI*/
+    } unAttr;
+} HI_UNF_AI_ATTR_S;
+
+/**Defines AI Delay attribute */
+/**CNcomment:AI*/
+typedef struct hiHI_UNF_AI_DELAY_S
+{
+    HI_U32                  u32DelayMs;    /**<buffer delay compensation(ms), Min Value is 20, Max Value depends on u32PcmFrameMaxNum, u32PcmSamplesPerFrame and enSampleRate in HI_UNF_AI_ATTR_S.
+                                                    MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate. 
+                                                    MaxValue is equal to 320ms according to default HI_UNF_AI_ATTR_S*/ 
+                                                   /**<CNcomment:(ms), 20msHI_UNF_AI_ATTR_Su32PcmFrameMaxNumu32PcmSamplesPerFrameenSampleRate
+                                                    :MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate
+                                                    HI_UNF_AI_ATTR_S320ms */
+    HI_BOOL                 bDelayMsAutoHold;  /**<if hold buffer delay compensation time automatically*/ /**<CNcomment:AI_AOu32CompensationMs*/
+} HI_UNF_AI_DELAY_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  AI */
+
+/**
+\brief Initializes an AI device. CNcomment: CNend
+\attention \n
+Before calling the AI module, you must call this application programming interface (API). CNcomment:AI CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AI device. CNcomment: CNend
+\attention \n
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_DeInit(HI_VOID);
+
+/**
+ \brief Obtains the default attributes of a AI port. CNcomment: AI CNend
+ \attention \n
+ \param[in] pstAttr Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_GetDefaultAttr(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr);
+
+/**
+ \brief Enables a AI port to create a AI handle. CNcomment: AI PortAI CNend
+ \attention \n
+Before calling the AI, you must call this API.\n
+CNcomment: AI  CNend
+ \param[in] pstAttr CNcomment: Pointer to AI attributes AI CNend
+ \param[in] phandle CNcomment: hAi Pointer to the AI handle AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_Create(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr, HI_HANDLE *phAI);
+
+/**
+ \brief Disable a AI port to destroy the handle. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA  The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_Destroy(HI_HANDLE hAI);
+
+/**
+ \brief Set the attributes of a AI port. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \param[in] pstAttr  Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+ HI_S32 HI_UNF_AI_SetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+ \brief Obtains the attributes of a AI port. CNcomment: AI Port CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI CNend
+ \param[out] pstAttr Pointer to AI attributes CNcomment: AI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment:  CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_AI_GetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+\brief enable AI port. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] bEnable      enable  .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_SetEnable(HI_HANDLE hAI, HI_BOOL bEnable);
+
+/**
+\brief Obtains enable/disable status of AI port. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[out] pbEnable enable/disable status AI port. CNcomment:AI CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_GetEnable(HI_HANDLE hAI, HI_BOOL *pbEnable);
+
+/**
+\brief set AI delay compensation. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] pstDelay  delay compensation .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_SetDelay(HI_HANDLE hAI, const HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief Obtains AI delay compensation. CNcomment: AI CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[out] pstDelay delay compensation. CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_GetDelay(HI_HANDLE hAI, HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief get frame buffer from AI. CNcomment:  CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as AI).
+\param[in] AI handle CNcomment: AI CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment: CNend
+\param[out] pstFrame        frame info.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_AcquireFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Releases the frame buffer for AI . CNcomment:  CNend
+\attention \n
+\param[in] AI handle CNcomment: AI CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment: CNend
+\param[out] pstFrame        frame info.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment:  CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_AI_ReleaseFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_AI_H__*/
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_audio.h b/xbmc/platform/linux/hisi/hi_unf_audio.h
new file mode 100644
index 0000000000..a5e9dce50b
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_audio.h
@@ -0,0 +1,238 @@
+/******************************************************************************
+
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_audio.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_AUDIO_H__
+#define __HI_UNF_AUDIO_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_audio_codec.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Audio_Common */
+/** @{ */  /** <!-- [Audio_Common] */
+
+/**CNcomment: */
+typedef enum hiUNF_SAMPLE_RATE_E
+{
+    HI_UNF_SAMPLE_RATE_UNKNOWN=0,       /**<Unknown*/ /**<CNcomment:  */
+    HI_UNF_SAMPLE_RATE_8K    = 8000,    /**<8 kHz sampling rate*/ /**<CNcomment: 8K */
+    HI_UNF_SAMPLE_RATE_11K   = 11025,   /**<11.025 kHz sampling rate*/ /**<CNcomment: 11.025K */
+    HI_UNF_SAMPLE_RATE_12K   = 12000,   /**<12 kHz sampling rate*/ /**<CNcomment: 12K */
+    HI_UNF_SAMPLE_RATE_16K   = 16000,   /**<16 kHz sampling rate*/ /**<CNcomment: 16K */
+    HI_UNF_SAMPLE_RATE_22K   = 22050,   /**<22.050 kHz sampling rate*/ /**<CNcomment: 22.050K */
+    HI_UNF_SAMPLE_RATE_24K   = 24000,   /**<24 kHz sampling rate*/ /**<CNcomment: 24K */
+    HI_UNF_SAMPLE_RATE_32K   = 32000,   /**<32 kHz sampling rate*/ /**<CNcomment: 32K */
+    HI_UNF_SAMPLE_RATE_44K   = 44100,   /**<44.1 kHz sampling rate*/ /**<CNcomment: 44.1K */
+    HI_UNF_SAMPLE_RATE_48K   = 48000,   /**<48 kHz sampling rate*/ /**<CNcomment: 48K */
+    HI_UNF_SAMPLE_RATE_88K   = 88200,   /**<88.2 kHz sampling rate*/ /**<CNcomment: 88.2K */
+    HI_UNF_SAMPLE_RATE_96K   = 96000,   /**<96 kHz sampling rate*/ /**<CNcomment: 96K */
+    HI_UNF_SAMPLE_RATE_176K  = 176400,  /**<176 kHz sampling rate*/ /**<CNcomment: 176K */
+    HI_UNF_SAMPLE_RATE_192K  = 192000,  /**<192 kHz sampling rate*/ /**<CNcomment: 192K */
+
+    HI_UNF_SAMPLE_RATE_BUTT
+} HI_UNF_SAMPLE_RATE_E;
+
+/**Defines the bit depth during audio sampling.*/
+/**CNcomment: */
+typedef enum hiUNF_BIT_DEPTH_E
+{
+    HI_UNF_BIT_DEPTH_UNKNOWN =0,/**<Unknown*/ /**<CNcomment:   */
+    HI_UNF_BIT_DEPTH_8  = 8,    /**< 8-bit depth*/ /**<CNcomment: 8  */
+    HI_UNF_BIT_DEPTH_16 = 16,   /**<16-bit depth*/ /**<CNcomment: 16 */
+    HI_UNF_BIT_DEPTH_18 = 18,   /**<18-bit depth*/ /**<CNcomment: 18 */
+    HI_UNF_BIT_DEPTH_20 = 20,   /**<20-bit depth*/ /**<CNcomment: 20 */
+    HI_UNF_BIT_DEPTH_24 = 24,   /**<24-bit depth*/ /**<CNcomment: 24 */
+    HI_UNF_BIT_DEPTH_32 = 32,   /**<32-bit depth*/ /**<CNcomment: 32 */
+
+    HI_UNF_BIT_DEPTH_BUTT
+} HI_UNF_BIT_DEPTH_E;
+
+/**Defines the mode of audio channels.*/
+/**CNcomment: */
+typedef enum hiUNF_TRACK_MODE_E
+{
+    HI_UNF_TRACK_MODE_STEREO = 0,          /**<Stereo*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_MONO,         /**<Data is output after being mixed in the audio-left channel and audio-right channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_LEFT,         /**<The audio-left channel and audio-right channel output the data of the audio-left channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_DOUBLE_RIGHT,        /**<The audio-left channel and audio-right channel output the data of the audio-right channel.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_EXCHANGE,            /**<Data is output after being exchanged in the audio-left channel and audio-right channel.*/ /**<CNcomment:  */
+    HI_UNF_TRACK_MODE_ONLY_RIGHT,          /**<Only the data in the audio-right channel is output.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_ONLY_LEFT,           /**<Only the data in the audio-left channel is output.*/ /**<CNcomment: */
+    HI_UNF_TRACK_MODE_MUTED,               /**<Mute*/ /**<CNcomment: */
+
+    HI_UNF_TRACK_MODE_BUTT
+} HI_UNF_TRACK_MODE_E;
+
+/**Defines the attributes of the audio decoder.*/
+/**CNcomment: */
+typedef struct hiUNF_ACODEC_ATTR_S
+{
+    HA_CODEC_ID_E        enType;                    /**<Audio decoder type*/ /**<CNcomment: */
+    HI_HADECODE_OPENPARAM_S stDecodeParam;   /**<Audio decoder parameter*/ /**<CNcomment: */
+} HI_UNF_ACODEC_ATTR_S;
+
+/**Defines the attributes of audio encoder.*/
+/**CNcomment: */
+typedef struct hiUNF_AENC_ATTR_S
+{
+    HI_U32         enAencType;              /**<Audio encoder type*/ /**<CNcomment: */
+    HI_HAENCODE_OPENPARAM_S   sOpenParam;   /**<Audio encoder parameter*/ /**<CNcomment: */
+} HI_UNF_AENC_ATTR_S;
+
+/**Defines the information about audio streams.*/
+/**CNcomment: */
+typedef struct hiUNF_ACODEC_STREAMINFO_S
+{
+    HI_U32               enACodecType;     /**<Audio Codec type*/ /**<CNcomment: Codec HA_CODEC_ID_E*/
+    HI_U32               enSampleRate;     /**<Audio sampling rate*/ /**<CNcomment: */
+    HI_UNF_BIT_DEPTH_E   enBitDepth;       /**<Bit depth during audio sampling*/ /**<CNcomment: */
+    HI_U32               u32Channel;       /**<Audio output channel*//**<CNcomment: */
+    HI_U32               u32BitRate;       /**<Audio bitrate*/ /**<CNcomment: */
+    HA_FORMAT_E          enAudioFormat;    /**<Audio stream format*/ /**<CNcomment: */
+    HA_AUDIO_CHANNELMODE_E enChannelMode;  /**<Audio channel mode*/ /**<CNcomment: */
+    HI_BOOL              bLfePresent;      /**<Lfe present flag*/ /**<CNcomment: */
+    HI_BOOL              bAtmos;           /**<Atmos stream flag*/ /**<CNcomment: Atmos*/
+} HI_UNF_ACODEC_STREAMINFO_S;
+
+/**Defines the I2S(Inter-IC Sound) mode.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_MODE_E
+{
+    HI_UNF_I2S_STD_MODE = 0,     /**<I2S standard mode*/ /**<CNcomment: I2S*/
+    HI_UNF_I2S_PCM_MODE,         /**<pcm mode*/ /**<CNcomment: PCM*/
+    HI_UNF_I2S_TDM_MODE,         /**<TDM mode*/ /**<CNcomment: TDM*/
+
+    HI_UNF_I2S_MODE_BUTT
+} HI_UNF_I2S_MODE_E;
+
+/**Defines the I2S(Inter-IC Sound) master clock.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_MCLK_SEL_E
+{
+    HI_UNF_I2S_MCLK_128_FS = 0,      /* mclk 128*fs  */
+    HI_UNF_I2S_MCLK_256_FS,          /* mclk 256*fs */
+    HI_UNF_I2S_MCLK_384_FS,          /* mclk 384*fs */
+    HI_UNF_I2S_MCLK_512_FS,          /* mclk 512*fs */
+    HI_UNF_I2S_MCLK_768_FS,          /* mclk 768*fs */
+    HI_UNF_I2S_MCLK_1024_FS,         /* mclk 1024*fs */
+    HI_UNF_I2S_MCLK_BUTT
+} HI_UNF_I2S_MCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) bclk clock.*/
+typedef enum hiHI_UNF_I2S_BCLK_SEL_E
+{
+     HI_UNF_I2S_BCLK_1_DIV = 1,           /* bclk=mclk/1  */
+     HI_UNF_I2S_BCLK_2_DIV = 2,           /* bclk=mclk/2  */
+     HI_UNF_I2S_BCLK_3_DIV = 3,           /* bclk=mclk/3  */
+     HI_UNF_I2S_BCLK_4_DIV = 4,           /* bclk=mclk/4  */
+     HI_UNF_I2S_BCLK_6_DIV = 6,           /* bclk=mclk/6  */
+     HI_UNF_I2S_BCLK_8_DIV = 8 ,          /* bclk=mclk/8  */
+     HI_UNF_I2S_BCLK_12_DIV= 12,          /* bclk=mclk/12 */
+     HI_UNF_I2S_BCLK_24_DIV= 24,          /* bclk=mclk/24 */
+     HI_UNF_I2S_BCLK_32_DIV= 32,          /* bclk=mclk/32 */
+     HI_UNF_I2S_BCLK_48_DIV= 48,          /* bclk=mclk/48 */
+     HI_UNF_I2S_BCLK_64_DIV= 64,          /* bclk=mclk/64 */
+     HI_UNF_I2S_BCLK_BUTT
+} HI_UNF_I2S_BCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) channels.*/
+/**CNcomment: I2S*/
+typedef enum hiHI_UNF_I2S_CHNUM_E
+{
+    HI_UNF_I2S_CHNUM_1  = 1,
+    HI_UNF_I2S_CHNUM_2  = 2,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_8  = 8,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_16 = 16,             /* only work for TDM mode */
+
+    HI_UNF_I2S_BUTT,
+} HI_UNF_I2S_CHNUM_E;
+
+/**Defines the I2S(Inter-IC Sound) bit depth.*/
+typedef enum hiHI_UNF_I2S_BITDEPTH_E
+{
+    HI_UNF_I2S_BIT_DEPTH_16 = 16,
+    HI_UNF_I2S_BIT_DEPTH_24 = 24,         /* only work for I2S mode */
+} HI_UNF_I2S_BITDEPTH_E;
+
+/**Defines the I2S(Inter-IC Sound) data valid after frame sync clock at PCM mode .*/
+/**CNcomment: I2SPCM*/
+typedef enum hiHI_UNF_I2S_PCMDELAY_E
+{
+    HI_UNF_I2S_PCM_0_DELAY = 0,           /* 0  bclk cycles delay*/
+    HI_UNF_I2S_PCM_1_DELAY = 1,           /* 1  bclk cycles delay*/
+    HI_UNF_I2S_PCM_8_DELAY = 8,           /* 8  bclk cycles delay*/
+    HI_UNF_I2S_PCM_16_DELAY = 16,         /* 16 bclk cycles delay*/
+    HI_UNF_I2S_PCM_17_DELAY = 17,         /* 17 bclk cycles delay*/
+    HI_UNF_I2S_PCM_24_DELAY = 24,         /* 24 bclk cycles delay*/
+    HI_UNF_I2S_PCM_32_DELAY = 32,         /* 32 bclk cycles delay*/
+    HI_UNF_I2S_PCM_DELAY_BUTT
+} HI_UNF_I2S_PCMDELAY_E;
+
+/**Defines the I2S(Inter-IC Sound) attribute .*/
+/**CNcomment: I2S*/
+typedef struct hiHI_UNF_I2S_ATTR_S
+{
+    HI_BOOL               bMaster;           /* HI_TRUE:master, HI_FALSE: slave */
+    HI_UNF_I2S_MODE_E     enI2sMode;
+    HI_UNF_I2S_MCLK_SEL_E enMclkSel;
+    HI_UNF_I2S_BCLK_SEL_E enBclkSel;
+    HI_UNF_I2S_CHNUM_E    enChannel;
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;
+    HI_BOOL               bPcmSampleRiseEdge; /* only work for PCM mode. HI_TRUE:sample data at positive edge of bclk, HI_FALSE: sample data at  negative edge of bclk */
+    HI_UNF_I2S_PCMDELAY_E enPcmDelayCycle;    /* only work for PCM mode.  */
+} HI_UNF_I2S_ATTR_S;
+
+/**Defines the information about audio frames.*/
+/**CNcomment: */
+typedef struct hiUNF_AO_FRAMEINFO_S
+{
+    /** s32BitPerSample: (PCM) Data depth, and format of storing the output data
+          If the data depth is 16 bits, 16-bit word memory is used.
+          If the data depth is greater than 16 bits, 32-bit word memory is used, and data is stored as left-aligned data. That is, the valid data is at upper bits.
+     */
+    /**CNcomment: s32BitPerSample: (PCM) . 
+          16bit:   16bit word
+          16bit:   32bit word, ()
+     */
+    HI_S32  s32BitPerSample;       /**<Data depth*/ /**<CNcomment: */
+    HI_BOOL bInterleaved;          /**<Whether the data is interleaved*/ /**<CNcomment: */
+    HI_U32  u32SampleRate;         /**<Sampling rate*/ /**<CNcomment: */
+    HI_U32  u32Channels;           /**<Number of channels*/ /**<CNcomment: */
+    HI_U32  u32PtsMs;              /**<Presentation time stamp (PTS)*/ /**<CNcomment: */
+    HI_S32 *ps32PcmBuffer;         /**<Pointer to the buffer for storing the pulse code modulation (PCM) data*/ /**<CNcomment: PCM*/
+    HI_S32 *ps32BitsBuffer;        /**<Pointer to the buffer for storing the stream data*/ /**<CNcomment: */
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sampling points of the PCM data*/ /**<CNcomment: PCM*/
+    HI_U32  u32BitsBytesPerFrame;  /**<IEC61937 data size*/ /**<CNcomment: IEC61937*/
+    HI_U32  u32FrameIndex;         /**<Frame ID*/ /**<CNcomment:  */
+    HI_U32  u32IEC61937DataType;   /**<IEC61937 Data Type*/ /**<CNcomment: IEC619378bitIEC */
+} HI_UNF_AO_FRAMEINFO_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_AUDIO_ H*/
diff --git a/xbmc/platform/linux/hisi/hi_unf_avplay.h b/xbmc/platform/linux/hisi/hi_unf_avplay.h
new file mode 100644
index 0000000000..ad5bb94da0
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_avplay.h
@@ -0,0 +1,1639 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_avplay.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/21
+  Description   :
+  History       :
+  1.Date        : 2009/12/21
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio/video player (AVPLAY) module.
+          CNcomment:AVPLAY CNend
+ */
+#ifndef __HI_UNF_AVPLAY_H__
+#define __HI_UNF_AVPLAY_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*********************************error  macro******************************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**Highest priority of the video decoder*/
+/**CNcomment: */
+#define HI_UNF_VCODEC_MAX_PRIORITY  16
+
+
+/**Defines the buffer ID required in an AVPLAY.*/
+/**CNcomment:AVBufferID */
+typedef enum hiUNF_AVPLAY_BUFID_E
+{
+    HI_UNF_AVPLAY_BUF_ID_ES_VID  = 0,       /**<ID of the buffer for storing the video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVESBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD,            /**<ID of the buffer for storing the audio ESs played by an AVPLAY*//**<CNcommentAVESBuffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD_AD,         /**<ID of the buffer for storing the AD audio ESs played by an AVPLAY*//**<CNcommentAVAD ESBuffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_BL,     /**<ID of the buffer for storing the HDR BL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR BLBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_EL,     /**<ID of the buffer for storing the HDR EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR ELBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_DL,     /**<ID of the buffer for storing the HDR BL+EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AVHDR BL+ELBuffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_BUTT
+} HI_UNF_AVPLAY_BUFID_E;
+
+/**Defines the type of a media channel.*/
+/**CNcomment:. */
+typedef enum hiUNF_AVPLAY_MEDIA_CHAN
+{
+    HI_UNF_AVPLAY_MEDIA_CHAN_AUD  = 0x01,  /**<Audio channel*//**<CNcomment:  */
+    HI_UNF_AVPLAY_MEDIA_CHAN_VID  = 0x02,  /**<Video channel*//**<CNcomment:  */
+
+    HI_UNF_AVPLAY_MEDIA_CHAN_BUTT = 0x8
+} HI_UNF_AVPLAY_MEDIA_CHAN_E;
+
+/**Defines the type of an input stream interface.*/
+/**CNcomment: */
+typedef enum hiUNF_AVPLAY_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_TS = 0,   /**<Transport stream (TS)*//**<CNcomment:TS */
+    HI_UNF_AVPLAY_STREAM_TYPE_ES,       /**<ES stream*//**<CNcomment:ES */
+
+    HI_UNF_AVPLAY_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_STREAM_TYPE_E;
+
+/**Defines the stream attributes.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_STREAM_ATTR_S
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_E enStreamType;   /**<Stream type*//**<CNcomment: */
+
+    HI_U32                      u32VidBufSize;  /**<Video buffer size*//**<CNcomment:  */
+    HI_U32                      u32AudBufSize;  /**<Audio buffer size*//**<CNcomment:  */
+
+} HI_UNF_AVPLAY_STREAM_ATTR_S;
+
+/**Supported synchronization control mode*/
+/**CNcomment: */
+typedef enum hiUNF_SYNC_REF_E
+{
+    HI_UNF_SYNC_REF_NONE = 0, /**<Free playing without synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_AUDIO,    /**<Audio-based synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_VIDEO,    /**<Video-based synchronization*//**<CNcomment:  */
+    HI_UNF_SYNC_REF_PCR,      /**<Program Clock Reference (PCR)-based synchronization*//**<CNcomment: PCRProgram Clock Reference */
+    HI_UNF_SYNC_REF_SCR,      /**<System Clock Reference (SCR)-based synchronization*//**<CNcomment: SCR (System Clock Reference)  */
+
+    HI_UNF_AVPLAY_SYNC_REF_BUTT
+} HI_UNF_SYNC_REF_E;
+
+/**Defines the status of a buffer.*/
+/**CNcomment: */
+typedef enum hiUNF_AVPLAY_BUF_STATE_E
+{
+    HI_UNF_AVPLAY_BUF_STATE_EMPTY = 0,   /**<The buffer is idle.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_LOW,         /**<The buffer usage is too low.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_NORMAL,      /**<The buffer works normally.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_HIGH,        /**<The buffer usage is too high.*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATE_FULL,        /**<The buffer is full.*//**<CNcomment:  */
+
+    HI_UNF_AVPLAY_BUF_STATE_BUTT
+}HI_UNF_AVPLAY_BUF_STATE_E;
+
+/**Defines the type of pts channel.*/
+/** CNcomment:PTS */
+typedef enum hiUNF_SYNC_PTS_CHAN_E
+{
+    HI_UNF_SYNC_PTS_CHAN_VID,   /**<Video pts channel.*//**<CNcomment:PTS */
+    HI_UNF_SYNC_PTS_CHAN_AUD,   /**<Audio pts channel.*//**<CNcomment:PTS */
+    HI_UNF_SYNC_PTS_CHAN_PCR,   /**<Pcr channel.*//**<CNcomment:PCR */
+
+    HI_UNF_SYNC_PTS_CHAN_BUTT
+}HI_UNF_SYNC_PTS_CHAN_E;
+
+/**Defines the parameters of pts jump.*/
+/** CNcomment:PTS */
+typedef struct hiUNF_SYNC_PTSJUMP_PARAM_S
+{
+    HI_UNF_SYNC_PTS_CHAN_E  enPtsChan;  /**<Pts channel.*//**<CNcomment:PTS */
+    HI_BOOL                 bLoopback;  /**<Loopback or not.*//**<CNcomment: */
+    HI_U32                  u32FirstPts;/**<The first pts.*//**<CNcomment:PTS */
+    HI_U32                  u32FirstValidPts;/**<The first valid pts.*//**<CNcomment:PTS */
+    HI_U32                  u32CurSrcPts;   /**<The current src pts.*//**<CNcomment:PTS */
+    HI_U32                  u32CurPts;      /**<The current pts.*//**<CNcomment:PTS */
+    HI_U32                  u32LastSrcPts;  /**<The last src pts.*//**<CNcomment:PTS */
+    HI_U32                  u32LastPts;     /**<The last pts.*//**<CNcomment:PTS */
+}HI_UNF_SYNC_PTSJUMP_PARAM_S;
+
+typedef enum hiUNF_SYNC_PROC_E
+{
+    HI_UNF_SYNC_PROC_DISCARD,       /**<*Discard*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_REPEAT,        /**<*Repeat*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_PLAY,          /**<*Play*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_QUICKOUTPUT,   /**<*Quickoutput*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_TPLAY,         /**<*Tplay*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_CONTINUE,      /**<*Continue*//**<CNcomment:*/
+    HI_UNF_SYNC_PROC_BLOCK,         /**<*Block*//**<CNcomment:*/
+
+    HI_UNF_SYNC_PROC_BUTT
+}HI_UNF_SYNC_PROC_E;
+
+typedef struct hiUNF_SYNC_VID_TPLAYTIME_S
+{
+    HI_U32              u32PrivDispTime;    /**<This displaytime is for pvr smooth tplay*//**<CNcomment:pvr*/
+    HI_U32              u32Pts;             /**<The fram info PTS*//**<CNcomment:PTS*/
+    HI_UNF_SYNC_PROC_E  enSyncProc;         /**<*Sync results*//**<CNcomment:*/
+}HI_UNF_SYNC_VID_TPLAYTIME_S;
+
+/**Defines the parameters of synchronization status change*/
+/** CNcomment: */
+typedef struct hiUNF_SYNC_STAT_PARAM_S
+{
+     HI_S32          s32VidAudDiff;     /**<The diffrence between video and audio frames*//**<CNcomment:  */
+     HI_S32          s32VidPcrDiff;     /**<The diffrence between video frame and pcr*//**<CNcomment: PCR */
+     HI_S32          s32AudPcrDiff;     /**<The diffrence between audio frame and pcr*//**<CNcomment: PCR */
+     HI_U32          u32VidLocalTime;   /**<Local video synchronization reference time*//**<CNcomment:  */
+     HI_U32          u32AudLocalTime;   /**<Local audio synchronization reference time*//**<CNcomment:  */
+     HI_U32          u32PcrLocalTime;   /**<Local pcr synchronization reference time*//**<CNcomment: PCR */
+}HI_UNF_SYNC_STAT_PARAM_S;
+
+/**Defines the parameters of pcr and stc info*/
+/** CNcomment:PCR STC */
+typedef struct hiUNF_SYNC_PCR_STC_INFO_S
+{
+     HI_U64          u64PcrValue;     /**<the value of PCR*//**<CNcomment:PCR */
+     HI_U64          u64StcValue;     /**<The value of STC*//**<CNcomment:STC */
+}HI_UNF_SYNC_PCR_STC_INFO_S;
+
+/*Type of the event callback function*/
+/**CNcomment:  */
+typedef enum hiUNF_AVPLAY_EVENT_E
+{
+    HI_UNF_AVPLAY_EVENT_EOS,                   /**<The end of stream (EOS) operation is performed, NULL*//**<CNcomment: EOS, NULL.*/
+    HI_UNF_AVPLAY_EVENT_STOP,                  /**<The stop operation is performed, NULL*//**<CNcomment: STOP, NULL.*/
+    HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*//**<CNcomment: , HI_UNF_AVPLAY_BUF_STATE_E.*/
+    HI_UNF_AVPLAY_EVENT_NORM_SWITCH,           /**<Standard switch, HI_UNF_NORMCHANGE_PARAM_S*//**<CNcomment: , HI_UNF_NORMCHANGE_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE,   /**<3D Frame packing change, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E*//**<CNcomment: 3D, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E .*/
+    HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME,         /**<New video frame will be rendered, indicates the new video frame that can be sent to display, HI_UNF_VIDEO_FRAME_INFO_S*//**<CNcomment: , HI_UNF_VIDEO_FRAME_INFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME,         /**<New audio frame, HI_UNF_AO_FRAMEINFO_S*//**<CNcomment: , HI_UNF_AO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_USER_DATA,         /**<New video user data, HI_UNF_VIDEO_USERDATA_S*//**<CNcomment: , HI_UNF_VIDEO_USERDATA_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_AUD_ES,            /**<New audio ES data, HI_UNF_ES_BUF_S*//**<CNcomment: ES, HI_UNF_ES_BUF_S .*/
+    HI_UNF_AVPLAY_EVENT_IFRAME_ERR,            /**<I frame decode error*//**<CNcomment: I .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP,         /**<Pts Jump, HI_UNF_SYNC_PTSJUMP_PARAM_S * *//**<CNcomment: PTS, HI_UNF_SYNC_PTSJUMP_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE,      /**<Synchronization status change, HI_UNF_SYNC_STAT_PARAM_S * *//**<CNcomment: , HI_UNF_SYNC_STAT_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_VID_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE*//**<CNcomment: , HI_UNF_AVPLAY_EVENT_VID_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE*//**<CNcomment: , HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT,         /**<The video stream is unsupport*//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO,         /**<frame error ratio *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE,       /**<audio info change, HI_UNF_ACODEC_STREAMINFO_S *//**<CNcomment: HI_UNF_ACODEC_STREAMINFO_S*/
+    HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT,         /**<unsupported audio *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR,         /**<audio frame error *//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE,          /**<the setting vid codec type is error, HI_UNF_VCODEC_TYPE_E*//**<CNcomment: , HI_UNF_VCODEC_TYPE_E*/
+    HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED, /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME,         /**<vid frame decode error.*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_STATUS_REPORT,         /**<avplay status info, HI_UNF_AVPLAY_STATUS_INFO_S*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO,        /**<Video frame status info, HI_UNF_VIDEO_FRM_STATUS_INFO_S*/ /**<CNcomment: */
+    HI_UNF_AVPLAY_EVENT_VID_START_POS,         /**<the peek frame first pts, HI_U32*/ /**<CNcomment: peekpts, HI_U32*/
+    HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME,    /**<Estimated time of display, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/ /**<CNcomment: , HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/
+    HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE,   /**<HDCP strategy change, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S*//**<CNcomment:HDCP , HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_PCR_STC_VALUE,     /**<Pcr and Stc info,HI_UNF_SYNC_PCR_STC_INFO_S*//**<CNcomment:PcrStc,HI_UNF_SYNC_PCR_STC_INFO_S.*/
+    HI_UNF_AVPLAY_EVENT_VID_LASTFRMFLAG,       /**<Report vid last frame flag*//**<CNcomment: vdec*/
+    HI_UNF_AVPLAY_EVENT_VID_TPLAYTIME_SYNC,    /**<Trick play is to adjust the video frame,HI_UNF_SYNC_VID_TPLAYTIME_S*//**<CNcomment: ,HI_UNF_SYNC_VID_TPLAYTIME_S*/
+    HI_UNF_AVPLAY_EVENT_NEW_PICTURE_DECODED, /**<New video frame is decoded, indicates that the video decoder present a new video frameHI_UNF_VIDEO_FRAME_INFO_S*//**<CNcomment: , HI_UNF_VIDEO_FRAME_INFO_S .*/
+    HI_UNF_AVPLAY_EVENT_BUTT
+} HI_UNF_AVPLAY_EVENT_E;
+
+/**Mode of processing the buffer overflow*/
+/**CNcomment:   */
+typedef enum hiUNF_AVPLAY_OVERFLOW_E
+{
+    HI_UNF_AVPLAY_OVERFLOW_RESET,              /**<Reset during overflow*//**<CNcomment:   */
+    HI_UNF_AVPLAY_OVERFLOW_DISCARD,            /**<Discard during overflow*//**<CNcomment:   */
+    HI_UNF_AVPLAY_OVERFLOW_BUTT
+} HI_UNF_AVPLAY_OVERFLOW_E;
+
+/**Defines the parameters of HDCP output control */
+/**CNcomment: HDCP*/
+typedef struct hiUNF_AVPLAY_HDCPSTRATEGY_PARAM_S
+{
+    HI_U32 u32ImageWidth;                     /**<Width of image allowed by HDCP strategy*/ /**<CNcomment:  HDCP (tvp)*/
+    HI_U32 u32ImageHeight;                    /**<Height of image allowed by HDCP strategy*/ /**<CNcomment:  HDCP (tvp)*/
+}HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S;
+
+/**Defines the type of the event callback function.*/
+/**CNcomment:  */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para);
+
+/**Defines the type of the event callback function.*/
+/**CNcomment:  */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN64)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID *pPara);
+
+/**Defines the attribute of audio security.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_AUD_SECURITY_ATTR_S
+{
+    HI_BOOL    bEnable; /**<Audio dmx channel is security mode or not*//**<CNcomment: DMX*/
+}HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S;
+
+/**Defines the attribute ID of an AVPLAY.*/
+/**CNcomment: AVID */
+typedef enum hiUNF_AVPLAY_ATTR_ID_E
+{
+    HI_UNF_AVPLAY_ATTR_ID_STREAM_MODE = 0,  /**<Playing mode, HI_UNF_AVPLAY_ATTR_S*//**<CNcomment: , HI_UNF_AVPLAY_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_ADEC,             /**<Audio attribute, HI_UNF_ACODEC_ATTR_S*//**<CNcomment: , HI_UNF_ACODEC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_VDEC,             /**<Video attribute, HI_UNF_VCODEC_ATTR_S*//**<CNcomment: , HI_UNF_VCODEC_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_AUD_PID,          /**<Audio packet identifier (PID), HI_U32*//**<CNcomment: PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_VID_PID,          /**<Video PID, HI_U32*//**<CNcomment: PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_PCR_PID,          /**<PCR PID, HI_U32*//**<CNcomment: PCR PID, HI_U32.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_SYNC,             /**<Synchronization attribute, HI_UNF_SYNC_ATTR_S*//**<CNcomment: , HI_UNF_SYNC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_AFD,              /**<Whether to enable the active format descriptor (AFD), HI_BOOL* *//**<CNcomment: AFD  HI_BOOL * .*/
+    HI_UNF_AVPLAY_ATTR_ID_OVERFLOW,         /**<Overflow processing type, HI_UNF_AVPLAY_OVERFLOW_E* *//**<CNcomment:  , HI_UNF_AVPLAY_OVERFLOW_E * .*/
+
+    HI_UNF_AVPLAY_ATTR_ID_MULTIAUD,         /**<Multiple audio attribute,  HI_UNF_AVPLAY_MULTIAUD_ATTR_S **//**<CNcomment: , HI_UNF_AVPLAY_MULTIAUD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM,    /**<Frame Rate Parameter, HI_UNF_AVPLAY_FRMRATE_PARAM_S * *//**<CNcomment:,HI_UNF_AVPLAY_FRMRATE_PARAM_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMPACK_TYPE,     /**<3D Frame Packing Type, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * *//**<CNcomment:3D,HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * .*/
+    HI_UNF_AVPLAY_ATTR_ID_LOW_DELAY,        /**<Low Delay Attr, HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_TVP,              /**<Trusted Video Path Attr, HI_UNF_AVPLAY_TVP_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_TVP_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD,               /**<MS12 Attr, HI_UNF_AVPLAY_AD_ATTR_S * *//**<CNcomment: MS12 , HI_UNF_AVPLAY_AD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_HDR,              /**<HDR Attr, HI_UNF_AVPLAY_HDR_ATTR_S * *//**<CNcomment: HDR , HI_UNF_AVPLAY_HDR_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AUD_SECURITY,     /**<Dmx audio channel security mode, HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * *//**<CNcomment:  , HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD_PID,           /**<AD program id*/ /**<CNcomment: ADPID,HI_S32*/
+    HI_UNF_AVPLAY_ATTR_ID_START_POSITION,   /**< Set video start play position, HI_UNF_AVPLAY_START_POSITION_ATTR_S * *//**<CNcomment:  HI_UNF_AVPLAY_START_POSITION_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_EXTERNAL_AUDIO,   /**< Set external audio codec attr, HI_UNF_ACODEC_ATTR_S * *//**<CNcomment:  HI_UNF_ACODEC_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_BUTT
+} HI_UNF_AVPLAY_ATTR_ID_E;
+
+/**Defines the stream type of HDR.*/
+/**CNcomment: DOLBY HDR */
+typedef enum hiUNF_AVPLAY_HDR_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_SINGLE_VES = 0,    /**<Dolby Vision Dual layer Single VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_DUAL_VES,          /**<Dolby Vision Dual Layer Dual VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_SL_VES,               /**<Dolby Vision Single Layer VES Format*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_HDR_STREAM_TYPE_E;
+
+/**Defines the low delay mode.*/
+/**CNcomment:  */
+typedef enum
+{
+    HI_UNF_AVPLAY_LOW_DELAY_FIRST = 0,      /**<Low delay first*/ /**<CNcomment: .*/
+    HI_UNF_AVPLAY_LOW_DELAY_SMOOTH_LEVEL1, /**<Smooth first ,the delaytime is longer than LOW_DELAY_FIRST mode*/ /**<CNcomment: .FIRST*/
+    HI_UNF_AVPLAY_LOW_DELAY_SMOOTH_LEVEL2, /**<Smooth than level 1, the delaytime is longer than LOW_DELAY_FIRST mode*/ /**<CNcomment: level1.FIRST*/
+    HI_UNF_AVPLAY_LOW_DELAY_MODE_BUTT
+} HI_UNF_AVPLAY_LOW_DELAY_MODE_E;
+
+/**Defines the attribute of low delay.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_LOW_DELAY_ATTR_S
+{
+    HI_BOOL               bEnable;          /**<Is low delay enable or not*//**<CNcomment: */
+    HI_UNF_AVPLAY_LOW_DELAY_MODE_E enMode;  /**<Low delay mode*//**<CNcomment: */
+}HI_UNF_AVPLAY_LOW_DELAY_ATTR_S;
+
+/**Defines the attribute of trust video path.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_TVP_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is trusted video path enable or not*//**<CNcomment: */
+}HI_UNF_AVPLAY_TVP_ATTR_S;
+
+/**Defines the audio/video synchronization .*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_REGION_S
+{
+    HI_S32                s32VidPlusTime;        /**<Plus time range during video synchronization*//**<CNcomment:  */
+    HI_S32                s32VidNegativeTime;    /**<Negative time range during video synchronization*//**<CNcomment:  */
+    HI_BOOL               bSmoothPlay;           /**<Slow playing enable*//**<CNcomment:  */
+} HI_UNF_SYNC_REGION_S;
+
+/**Defines the audio/video synchronization attributes.*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_ATTR_S
+{
+    HI_UNF_SYNC_REF_E     enSyncRef;             /**<Audio-based synchronization, PCR-based synchronization, and free playing without synchronization*//**<CNcomment: PCR */
+    HI_UNF_SYNC_REGION_S  stSyncStartRegion;     /**<Synchronization start region*//**<CNcomment:  */
+    HI_UNF_SYNC_REGION_S  stSyncNovelRegion;     /**<Synchronization exception region*//**<CNcomment:  */
+    HI_S32                s32VidPtsAdjust;       /**<Video presentation time stamp (PTS) adjustment*//**<CNcomment: PTS */
+    HI_S32                s32AudPtsAdjust;       /**<Audio PTS adjustment*//**<CNcomment: PTS */
+
+    HI_U32                u32PreSyncTimeoutMs;   /**<Pre-synchronization timeout, in ms*//**<CNcomment:  */
+    HI_BOOL               bQuickOutput;          /**<Fast output enable*//**<CNcomment:  */
+} HI_UNF_SYNC_ATTR_S;
+
+/**Defines the playing attributes of an AVPLAY.*/
+/**CNcomment: AV */
+typedef struct hiUNF_AVPLAY_ATTR_S
+{
+    HI_U32                       u32DemuxId;   /**<ID of the DEMUX used by an AVPLAY*//**<CNcomment: AVPLAYDEMUX ID TS */
+    HI_UNF_AVPLAY_STREAM_ATTR_S  stStreamAttr; /**<Stream attributes*//**<CNcomment:  */
+} HI_UNF_AVPLAY_ATTR_S;
+
+/**Defines the synchronization status when an AVPLAY is running.*/
+/**CNcomment:  */
+typedef struct hiUNF_SYNC_STATUS_S
+{
+    HI_U32 u32FirstAudPts;    /**<PTS of the first audio frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32FirstVidPts;    /**<PTS of the first video frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32LastAudPts;     /**<PTS of the last audio frame*//**<CNcomment:  PTS .*/
+    HI_U32 u32LastVidPts;     /**<PTS of the last video frame*//**<CNcomment:  PTS .*/
+    HI_S32 s32DiffAvPlayTime; /**<Playing time difference between audio and video frames*//**<CNcomment:   .*/
+    HI_U32 u32PlayTime;       /**<Playing time*//**<CNcomment:  .*/
+    HI_U32 u32LocalTime;      /**<Local synchronization reference time*//**<CNcomment:  .*/
+} HI_UNF_SYNC_STATUS_S;
+
+/**Defines the status of a media buffer.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_BUF_STATUS_S
+{
+    HI_U32 u32BufId;                /**<Media buffer ID*//**<CNcomment:   */
+    HI_U32 u32BufSize;              /**<Media buffer size*//**<CNcomment:  */
+    HI_U32 u32BufRptr;              /*Read pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: ,Ts */
+    HI_U32 u32BufWptr;              /*Write pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: ,Ts */
+    HI_U32 u32UsedSize;             /**<Used size of the media buffer*//**<CNcomment:  */
+    HI_U32 u32CurrentAvailableSize; /**<Current available size of the media buffer for HI_UNF_AVPLAY_GetBuf()*//**<CNcomment:  */
+    HI_U32 u32FrameBufTime;         /**<Frame buffer time*//**<CNcomment:  */
+    HI_U32 u32FrameBufNum;          /**<The number of frames in frame buffer*//**<CNcomment:  VIDEO */
+    HI_BOOL bEndOfStream;           /**<Flag to indicate end of stream*//**<CNcomment:  VIDEO */
+} HI_UNF_AVPLAY_BUF_STATUS_S;
+
+/**Defines the playing status of an AVPLAY.*/
+/**CNcomment:AV */
+typedef enum hiUNF_AVPLAY_STATUS_E
+{
+    HI_UNF_AVPLAY_STATUS_STOP = 0,  /**<Stop*/      /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_PREPLAY,   /**<Buffer*/    /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_PLAY,      /**<Play*/      /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_TPLAY,     /**<Trick play, such as fast forward and rewind*/   /**<CNcomment: TPlay,  */
+    HI_UNF_AVPLAY_STATUS_PAUSE,     /**<Pause*/     /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_EOS,       /**<EOS*/       /**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_SEEK ,     /**<Seek play*/ /**<CNcomment:  */
+
+    HI_UNF_AVPLAY_STATUS_BUTT
+} HI_UNF_AVPLAY_STATUS_E;
+
+/**Defines the output value after the playing status of an AVPLAY is queried.*/
+/**CNcomment:AV */
+typedef struct hiUNF_AVPLAY_STATUS_INFO_S
+{
+    HI_UNF_SYNC_STATUS_S       stSyncStatus;      /**<Synchronization status*//**<CNcomment:  */
+    HI_UNF_AVPLAY_STATUS_E     enRunStatus;       /**<Running status*//**< CNcomment: */
+    HI_U32                     u32VidFrameCount;  /**<Count of played video frames*//**<CNcomment:  */
+    HI_U32                     u32AuddFrameCount; /**<Count of played audio frames*//**<CNcomment:  */
+    HI_UNF_AVPLAY_BUF_STATUS_S stBufStatus[HI_UNF_AVPLAY_BUF_ID_BUTT]; /**<Status of the media buffer*//**<CNcomment: */
+    HI_U32                     u32VidErrorFrameCount; /**<Number of error frames during video decoding*/ /**<CNcomment:  */
+    HI_U32                     u32AudErrorFrameCount; /**<Number of error frames during audio decoding*//**<CNcomment:  */
+    HI_U32                     u32VidFrameDropCount; /**<Number of dropped video frame*/ /**<CNcomment: */
+    HI_U32                     u32AudFrameDropCount; /**<Number of dropped audio frame*/ /**<CNcomment: */
+} HI_UNF_AVPLAY_STATUS_INFO_S;
+
+/**Defines the information about the playing program streams to be queried.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_STREAM_INFO_S
+{
+    HI_UNF_VCODEC_STREAMINFO_S stVidStreamInfo; /**<Video stream information*//**<CNcomment: */
+    HI_UNF_ACODEC_STREAMINFO_S stAudStreamInfo; /**<Audio stream information*//**<CNcomment: */
+} HI_UNF_AVPLAY_STREAM_INFO_S;
+
+/**Defines the information about an I frame.*//**CNcomment:I */
+typedef struct hiUNF_AVPLAY_I_FRAME_S
+{
+    HI_U8  *pu8Addr;    /**<User-state virtual address of a frame*//**<CNcomment: */
+    HI_U32 u32BufSize; /**<Frame size, in byte*//**<CNcomment: */
+    HI_UNF_VCODEC_TYPE_E enType;     /*Protocol type of a data segment*//**<CNcomment: */
+    HI_UNF_VCODEC_EXTATTR_U unExtAttr; /**<Extra attribute for video format vc1 and vp6*//**<CNcomment:vc1vp6*/
+} HI_UNF_AVPLAY_I_FRAME_S;
+
+/**Defines the decoder type. The occupied memory varies according to decoders.*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VCODEC_DEC_TYPE_E
+{
+    HI_UNF_VCODEC_DEC_TYPE_NORMAL,            /**<Normal type.*//**<CNcomment: */
+
+    /**<I frame decoding type. If an AVPLAY is used to decode I frames only (HI_UNF_AVPLAY_DecodeIFrame), you can select this type to reduce the memory usage.*/
+    /**<CNcomment:I avplayI(HI_UNF_AVPLAY_DecodeIFrame)  */
+    HI_UNF_VCODEC_DEC_TYPE_ISINGLE,
+
+    HI_UNF_VCODEC_DEC_TYPE_BUTT
+}HI_UNF_VCODEC_DEC_TYPE_E;
+
+/**Defines the level of the protocol supported by the decoder. This value affects the number of frame buffers allocated by the normal decoder.
+The greater the value, the more the required frame buffers.*/
+/**CNcomment: NORMAL  */
+typedef enum hiHI_UNF_VCODEC_PRTCL_LEVEL_E
+{
+    HI_UNF_VCODEC_PRTCL_LEVEL_MPEG = 0,     /**<All protocols except MVC *//**<CNcomment:MVC */
+    HI_UNF_VCODEC_PRTCL_LEVEL_H264 = 1,     /**<Same as HI_UNF_VCODEC_PRTCL_LEVEL_MPEG now *//**<CNcomment:HI_UNF_VCODEC_PRTCL_LEVEL_MPEG*/
+    HI_UNF_VCODEC_PRTCL_LEVEL_MVC,
+    HI_UNF_VCODEC_PRTCL_LEVEL_BUTT
+}HI_UNF_VCODEC_PRTCL_LEVEL_E;
+
+/**Defines the attributes when an AVPLAY enables the video decoder. The settings affect the memory occupied by the video decoder and decoding performance.*/
+/**CNcomment:AV  */
+typedef struct hiHI_UNF_AVPLAY_OPEN_OPT_S
+{
+    HI_UNF_VCODEC_DEC_TYPE_E    enDecType;       /**<Decoder type.*//**<CNcomment:*/
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;      /**<Maximum resolution supported by the decoder. This value affects the size of each frame buffer.*//**<CNcomment:  */
+    HI_UNF_VCODEC_PRTCL_LEVEL_E enProtocolLevel; /**<Supported protocol level. This value affects the number of frame buffers.*//**<CNcomment:  */
+}HI_UNF_AVPLAY_OPEN_OPT_S;
+
+/**Defines the attribute of MS12.*/
+/**CNcomment: MS12*/
+typedef struct hiUNF_AVPLAY_AD_ATTR_S
+{
+    HI_BOOL             bAdEnble;       /**<whether enable ad service (on/off)*/ /**<CNcomment: AD.*/
+    HI_BOOL             bAdToSomePort;  /**<whether enable ad only to some port,such as speaker/headphone etc*/ /**<CNcomment: false.*/
+    HI_U32              u32AdPid;       /**<AD program id*/ /**<CNcomment: ADPID.*/
+    HI_S16              s16AdBalance;   /**<AD Balance 0~-100 AD Volume attenuation percentage. 0~100 master Volume attenuation percentage*/ /**<CNcomment: 0~-100 , 0~100 */
+} HI_UNF_AVPLAY_AD_ATTR_S;
+
+/**Defines the attribute of HDR.*/
+/**CNcomment: HDR*/
+typedef struct hiUNF_AVPLAY_HDR_ATTR_S
+{
+    HI_BOOL                           bEnable;          /**<Is Dolby HDR enable or not*/ /**<CNcomment: Dolby HDR.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_E   enHDRStreamType;  /**<Dolby Vision VES Format*/ /**<CNcomment: Dolby HDR.*/
+    HI_UNF_VCODEC_TYPE_E              enElType;         /**<Video encoding type*/ /**<CNcomment: EL*/
+    HI_UNF_AVPLAY_OPEN_OPT_S          stElCodecOpt;     /**<Video decoding option*/ /**<CNcomment: */
+    HI_BOOL                           bCompatible;      /**<Dolby frame is compatible or not.*/ /**<CNcomment: Dolby.*/
+} HI_UNF_AVPLAY_HDR_ATTR_S;
+
+/**Defines the video display mode after an AVPLAY is stopped.*/
+/**CNcomment:AV */
+typedef enum hiUNF_AVPLAY_STOP_MODE_E
+{
+    HI_UNF_AVPLAY_STOP_MODE_STILL = 0,  /**<The last frame is still after an AVPLAY is stopped.*//**<CNcomment:stop */
+    HI_UNF_AVPLAY_STOP_MODE_BLACK = 1,  /**<The blank screen is displayed after an AVPLAY is stopped.*//**<CNcomment:stop */
+    HI_UNF_AVPLAY_STOP_MODE_BUTT
+} HI_UNF_AVPLAY_STOP_MODE_E;
+
+
+/**Defines the attributes when an AVPLAY is prestarted.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PRESTART_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTART_OPT_S;
+
+/**Defines the attributes when an AVPLAY is started.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_START_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_START_OPT_S;
+
+/**Defines the attributes when an AVPLAY is prestoped.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PRESTOP_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTOP_OPT_S;
+
+
+/**Defines the attributes when an AVPLAY is stopped.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_STOP_OPT_S
+{
+    /*
+         s32Timeout: end of stream timeout
+         s32Timeout = 0   Wait until streams are played in non-block mode, that is, the interface is returned immediately. CNcomment: CNend
+         s32Timeout > 0   Block timeout, in ms, CNcomment: CNend
+         s32Timeout = -1  Infinite wait,CNcomment: CNend
+     */
+    HI_U32                    u32TimeoutMs;    /**<Timeout*//**<CNcomment: */
+    HI_UNF_AVPLAY_STOP_MODE_E enMode;          /**<Video display mode*//**<CNcomment: */
+} HI_UNF_AVPLAY_STOP_OPT_S;
+
+/*Defines the attributes when an AVPLAY is paused.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_PAUSE_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PAUSE_OPT_S;
+
+/**Defines the direction of tplay*/
+/**CNcomment:AVTPLAY */
+typedef enum hiUNF_AVPLAY_TPLAY_DIRECT_E
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_FORWARD,     /**<Tplay forward*//**<CNcomment: TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BACKWARD,    /**<Tplay backward*//**<CNcomment: TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BUTT
+
+} HI_UNF_AVPLAY_TPLAY_DIRECT_E;
+
+/**Defines the attributes when the playing mode of an AVPLAY is tplay.*/
+/**CNcomment:AVTPALY */
+typedef struct hiAVPLAY_TPLAY_OPT_S
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_E    enTplayDirect;      /**<Tplay direction*//**<CNcomment: TPLAY */
+    HI_U32                          u32SpeedInteger;    /**<Integral part of tplay speed*//**<CNcomment: TPLAY */
+    HI_U32                          u32SpeedDecimal;    /**<Fractional part (calculated to three decimal places) of tplay speed*//**<CNcomment: TPLAY3 */
+} HI_UNF_AVPLAY_TPLAY_OPT_S;
+
+/**Defines the attributes when an AVPLAY is resumed.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_RESUME_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_RESUME_OPT_S;
+
+/**Defines the attributes when an AVPLAY is reset.*/
+/**CNcomment:AV */
+typedef struct hiAVPLAY_RESET_OPT_S
+{
+    HI_U32        u32SeekPtsMs;   /**<clear these datas which pts is smaller than u32SeekPtsMs in buffer *//**<CNcomment:bufferu32SeekPtsMs */
+} HI_UNF_AVPLAY_RESET_OPT_S;
+
+/**Defines the attributes when an AVPLAY is step.*/
+/**CNcomment:AV */
+typedef struct hiUNF_AVPLAY_STEP_OPT_S
+{
+    HI_U32       u32Reserved;
+}HI_UNF_AVPLAY_STEP_OPT_S;
+
+/**Defines the attributes when an AVPLAY is in Flushing Stream Status.*/
+/**CNcomment:AVFlush Stream */
+typedef struct hiUNF_AVPLAY_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S;
+
+/**Defines the attributes of multiple audio.*/
+/**CNcomment: */
+typedef struct hiUNF_AVPLAY_MULTIAUD_ATTR_S
+{
+    HI_U32                  u32PidNum;      /**<the number of Audio PID *//**< CNcomment:PID */
+    HI_U32                  *pu32AudPid;    /**<Pointer to the array of audio PID*//**< CNcomment:PID */
+    HI_UNF_ACODEC_ATTR_S    *pstAcodecAttr; /**<Pointer to the array of audio attribute*//**< CNcomment: */
+}HI_UNF_AVPLAY_MULTIAUD_ATTR_S;
+
+/**Defines the source of frame rate.*/
+/**CNcomment:  */
+typedef enum hiUNF_AVPLAY_FRMRATE_TYPE_E
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_PTS,         /**<Use the frame rate calculates from PTS*//**<CNcomment: PTS */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_STREAM,      /**<Use the frame rate comes from stream*//**<CNcomment:  */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER,        /**<Use the frame rate set by user*//**<CNcomment:  */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER_PTS,    /**<Use the frame rate set by user until the 2nd I frame comes, then use the frame rate calculates from PTS*//**<CNcomment: IPTS */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_BUTT
+}HI_UNF_AVPLAY_FRMRATE_TYPE_E;
+
+/**Defines the parameter of frame rate.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_FRMRATE_PARAM_S
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_E    enFrmRateType;  /**<The source of frame rate*//**<CNcomment:  */
+    HI_UNF_VCODEC_FRMRATE_S         stSetFrmRate;   /**<Setting frame rate*//**<CNcomment:  */
+}HI_UNF_AVPLAY_FRMRATE_PARAM_S;
+
+/**Defines commond to get vdec information, the parameter is HI_UNF_AVPLAY_VDEC_INFO_S.*/
+/**CNcomment: HI_UNF_AVPLAY_VDEC_INFO_S */
+#define HI_UNF_AVPLAY_GET_VDEC_INFO_CMD         0x20
+/**Defines commond to set TPLAY parameter, the parameter is HI_UNF_AVPLAY_TPLAY_OPT_S.*/
+/**CNcomment: TPLAYHI_UNF_AVPLAY_TPLAY_OPT_S*/
+#define HI_UNF_AVPLAY_SET_TPLAY_PARA_CMD        0x21
+/**Defines commond to set special control information of stream, the parameter is HI_UNF_AVPLAY_CONTROL_INFO_S*/
+/**CNcomment: HI_UNF_AVPLAY_CONTROL_INFO_S*/
+#define HI_UNF_AVPLAY_SET_CTRL_INFO_CMD         0x22
+
+/**Defines commond to set video sample type, HI_BOOL *, HI_TRUE: force Progressive, HI_FALSE: auto recognise Progressive or Interlance */
+/**CNcomment: , HI_TRUE: , HI_FALSE: */
+#define HI_UNF_AVPLAY_SET_PROGRESSIVE_CMD       0x23
+
+/**Defines commond to set video color space, the parameter is HI_UNF_COLOR_SPACE_E*/
+/**CNcomment: , HI_UNF_COLOR_SPACE_E*/
+#define HI_UNF_AVPLAY_SET_COLORSPACE_CMD        0x24
+
+/**Defines commond to set dpb full control, HI_BOOL* ,HI_TRUE:force delete min poc frame when dpb is full,HI_FALSE:return error when dpb is full*/
+/**CNcomment:dpb, HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_DPBFULL_CTRL_CMD      0x25
+
+/***fix  videophone scene by AVPLAY ,  format MJPEG**/
+#define HI_UNF_AVPLAY_SET_SCENE_MODE_CMD        0x26
+
+/**Defines commond to keep SPS/PPS(VDEC) info in vfmw,set it before avplay reset. HI_BOOL* ,HI_TRUE:keep SPS/PPS,HI_FALSE:not keep*/
+/**CNcomment:SPS/PPSVFMW, AVPLAY resetHI_BOOL*/
+#define HI_UNF_AVPLAY_KEEP_SPS_PPS_INFO_CMD     0x27
+
+/***Defines commond to get vdec handle, the parameter is HI_U32**/
+#define HI_UNF_AVPLAY_GET_VDEC_HANDLE_CMD       0x28
+
+/**Defines commond to set video last frame, the parameter is HI_BOOL*/
+/**CNcomment: VDEC, HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_VDEC_LSTFRAME_CMD     0x29
+
+/**Defines commond to set video last frame, the parameter is HI_U32,range is 0-0xffffffff*/
+/**CNcomment: VDEC POC, HI_U32 0-0xffffffff*/
+#define HI_UNF_AVPLAY_SET_VDEC_POC_THRESHOLD_CMD 0x2c
+
+/**Defines the mode of videophone.*/
+/**CNcomment: Videophone  */
+typedef enum hiUNF_AVPLAY_SCENE_MODE_E
+{
+   HI_UNF_AVPLAY_SCENE_MODE_NORMAL,     /**<Normal scene of non-voip*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_PREVIEW,   /**<Voip scene of the local end*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_REMOTE,   /**<Voip scene of the remote end*//**<CNcomment:  */
+   HI_UNF_AVPLAY_SCENE_MODE_VIRTUAL_REAL,     /**<Virtual reality *//**<CNcomment: VR */
+   HI_UNF_AVPLAY_SCENE_MODE_BUTT,
+} HI_UNF_AVPLAY_SCENE_MODE_E;
+
+
+/**Defines the type of AVPLAY invoke.*/
+/**CNcomment: AVPLAY Invoke */
+typedef enum hiUNF_AVPLAY_INVOKE_E
+{
+    HI_UNF_AVPLAY_INVOKE_ACODEC  = 0,   /**<Invoke commond to control audio codec*//**<CNcomment: Invoke */
+    HI_UNF_AVPLAY_INVOKE_VCODEC,        /**<Invoke commond to control video codec, HI_CODEC_VIDEO_CMD_S*//**<CNcomment: Invoke */
+    HI_UNF_AVPLAY_INVOKE_GET_PRIV_PLAYINFO, /**<Invoke commond to get private play infomation,the parameter is HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S*//**<CNcomment: Invoke HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S * */
+    HI_UNF_AVPLAY_INVOKE_SET_DISP_OPTIMIZE_FLAG, /**Defines commond to set Display Optimize Flag, The Parameter is HI_U32, 1: Enable, 0: Disable */
+    HI_UNF_AVPLAY_INVOKE_GET_GLOBAL_PLAYINFO,   /**<Get global play information of avplay*//**<CNcomment: AVPLAY */
+    HI_UNF_AVPLAY_INVOKE_SET_SYNC_MODE,  /**<Invoke commond to set sync mode, HI_U32, 0 normal sync, 1 use sync replace frc*//**<CNcomment: HI_U320: , 1: */
+    HI_UNF_AVPLAY_INVOKE_SET_TPLAY_AUDIO_ENABLE, /**<Invoke commond to enable audio tplay(support 0.25/0.5/0.9/0.95/1.05/1.1/1.25/1.5/2), HI_U32, 1: enable audio tplay, 0: disable audio tplay*//**<CNcomment: ( 0.25/0.5/0.9/0.95/1.05/1.1/1.25/1.5/2)HI_U321: , 0: */
+    HI_UNF_AVPLAY_INVOKE_SET_TPLAY_RESET_ENABLE,  /**<Invoke commond to set tplay mode, HI_U32, 0 do not reset avplay, 1 reset avplay*//**<CNcomment:tplay HI_U32,  0: reset avplay, 1: reset avplay*/
+    HI_UNF_AVPLAY_INVOKE_BUTT
+} HI_UNF_AVPLAY_INVOKE_E;
+
+/**Defines the decoding information of video codec.*/
+/**CNcomment: VDEC */
+typedef struct hiUNF_AVPLAY_VDEC_INFO_S
+{
+    HI_U32                  u32DispFrmBufNum;   /**<the number of display frame*//**<CNcomment:  */
+    HI_U32                  u32FieldFlag;       /**<The encoding mode of image, 0 frame mode, 1 filed mode*//**<CNcomment: , 0 1  */
+    HI_UNF_VCODEC_FRMRATE_S stDecFrmRate;      /**<decoding frame rate*//**<CNcomment:  */
+    HI_U32                  u32UndecFrmNum;     /**<the number of undecoded frame*//**<CNcomment:  */
+}HI_UNF_AVPLAY_VDEC_INFO_S;
+
+/**Defines the private status information.*/
+/**CNcomment: AVPLAY */
+typedef struct hiUNF_AVPLAY_PRIVATE_STATUS_INFO_S
+{
+    HI_U32 u32LastPts;   /**<PTS of the last audio or video frame*/ /**<CNcomment:  PTSPTS*/
+    HI_U32 u32LastPlayTime; /**< PlayTime of the last audio or video frame */ /**<CNcomment:  PlayTimePlayTime  */
+    HI_U32 u32DispOptimizeFlag; /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: */
+} HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S;
+
+/**Defines the special control information of stream.*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_CONTROL_INFO_S
+{
+    HI_U32 u32IDRFlag;               /**<IDR frame Flag, 1 means IDR(instantaneous decoding refresh) frame.*/ /**<CNcomment: IDR()1*/
+    HI_U32 u32BFrmRefFlag;           /**<Whether B frame is refer frame, 1 means B frame is refer frame.*/ /**<CNcomment: B1*/
+    HI_U32 u32ContinuousFlag;        /**<Whether send frame is continusous. 1 means continusous*/ /**<CNcomment: 1*/
+    HI_U32 u32BackwardOptimizeFlag;  /**<The Backward Optimize Flag*//**<CNcomment: .*/
+    HI_U32 u32DispOptimizeFlag;      /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: */
+}HI_UNF_AVPLAY_CONTROL_INFO_S;
+
+/**Defines the parameter when the stream is send by HI_UNF_AVPLAY_PutBufEx.*/
+/**CNcomment: PutBufEx */
+typedef struct hiUNF_AVPLAY_PUTBUFEX_OPT_S
+{
+    HI_BOOL bEndOfFrm;      /**<whether this package of stream is the end of one frame*//**<CNcomment:  */
+    HI_BOOL bContinue;      /**<whether this package of stream is contnued with the last package*//**<CNcomment:  */
+}HI_UNF_AVPLAY_PUTBUFEX_OPT_S;
+
+typedef struct hiUNF_AVPLAY_GLOBAL_PLAY_INFO_S
+{
+    HI_U32 u32ContentCount;
+} HI_UNF_AVPLAY_GLOBAL_PLAY_INFO_S;
+
+typedef struct hiUNF_AVPLAY_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32AspectWidth;     /**<aspect ratio: width*/ /**<CNcomment: */
+    HI_U32                              u32AspectHeight;    /**<aspect ratio: height*/ /**<CNcomment: */
+    HI_U32                              u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32                              u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+} HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S;
+
+/**Defines the avplay video start position .*/
+/**CNcomment:  */
+typedef struct hiUNF_AVPLAY_START_POSITION_ATTR_S
+{
+    HI_U32                              u32StartPosPts;     /**<Start play Pts*/ /**<CNcomment: Pts*/
+    HI_U32                              u32IdrPts;          /**<Instantaneous Decoding Refresh Pts */ /**<CNcomment: IPts*/
+}HI_UNF_AVPLAY_START_POSITION_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**
+\brief Initializes the AVPLAY module.CNcomment:AVPLAY CNend
+\attention \n
+Before calling ::HI_UNF_AVPLAY_Create to create an AVPLAY, you must call this application programming interface (API).
+CNcomment AVPLAY CNend
+\param  N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NOT_EXIST There is no AVPLAY. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NOT_DEV_FILE  The file is not an AVPLAY file. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_DEV_OPEN_ERR  An AVPLAY fails to be started. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Init(HI_VOID);
+
+/**
+\brief Deinitializes the AVPLAY module. CNcomment:AVPLAY CNend
+\attention \n
+Please call this API function, before call anyother API of AVPLAY module.
+CNcomment: ::HI_UNF_AVPLAY_Destroy CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT  The operation is invalid.  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_CLOSE_ERR  An AVPLAY fails to be stopped. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DeInit(HI_VOID);
+
+/**
+\brief Get video frame info. CNcomment: CNend
+\attention \n
+\param[out] pstVideoFrameInfo  Pointer to video frame info. For details, see the description of ::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNcomment:::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNend
+\param[in] hAvplay    AVPLAY handle . CNcomment:AVPLAY . CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The pointer is null.  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_FAILURE  Failure. CNcomment:. CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetVideoFrameInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S *pstVideoFrameInfo);
+
+/**
+\brief Obtains the default configuration of an AVPLAY. CNcomment:AV CNend
+\attention \n
+When calling this API to set the enCfg parameter, you must enter correct mode of the player to be created.\n
+It is recommended that you call this API to obtain the default AVPLAY attributes before creating an AVPLAY. This avoids creation failures due to incomplete or incorrect parameters.
+CNcomment:enCfg\n
+AVAVAV CNend
+\param[out] pstAvAttr  Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment: AV::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[in] enCfg       AVPLAY type. For details, see the description of ::HI_UNF_AVPLAY_STREAM_TYPE_E. CNcomment: AV::HI_UNF_AVPLAY_STREAM_TYPE_E. CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_UNF_AVPLAY_STREAM_TYPE_E enCfg);
+
+/**
+\brief Registers a dynamic audio decoding library. CNcomment: CNend
+\attention \n
+\param[in] pFileName Name of the file in the audio decoding library CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterAcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Registers a dynamic video decoding library. CNcomment: CNend
+\attention \n
+\param[in] pFileName Name of the file in the video decoding library CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterVcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Searches for registered dynamic audio decoding libraries based on the audio format.
+CNcomment:,  CNend
+\attention \n
+\param[in] enFormat Audio format CNcomment: CNend
+\param[out] penDstCodecID If an audio decoding library is found, its codec ID is returned.
+CNcomment:CodecID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FoundSupportDeoder(const HA_FORMAT_E enFormat,HI_U32 * penDstCodecID);
+
+
+/**
+\brief Sets private commands for a dynamic audio decoding library. These commands are used to call ha_codec.
+CNcomment:, ha_codec   CNend
+HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID * hDecoder, HI_VOID * pstConfigStructure);
+\attention \n
+\param[in] enDstCodecID  The audio Codec ID  CNcomment:ID CNend
+\param[in] pPara  Attribute structure CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ConfigAcodec(const HI_U32 enDstCodecID, HI_VOID *pPara);
+
+/**
+\brief Creates an AVPLAY. CNcomment:AV CNend
+\attention \n
+Note the following point when setting the input parameter pstAttr: The stream source can be HI_UNF_AVPLAY_STREAM_TYPE_ES (ESs input from the memory) or HI_UNF_AVPLAY_STREAM_TYPE_TS (ESs input from the memory and TSs input from the Tuner).
+CNcomment:pstAttrHI_UNF_AVPLAY_STREAM_TYPE_ESESHI_UNF_AVPLAY_STREAM_TYPE_TSTSTUNERTS CNend
+\param[in]  pstAvAttr   Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment:AV::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[out] phAvplay    Pointer to the handle of a created AVPLAY.CNcomment:AV CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_CREATE_ERR       The AVPLAY fails to be created. CNcomment:AVPLAY CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_HANDLE *phAvplay);
+
+/**
+\brief Destroys an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay);
+
+/**
+\brief Sets the attributes of an AVPLAY. CNcomment:AV CNend
+\attention \n
+You can set the audio/video PID, audio/video decoding type, and synchronization mode by calling this API.\n
+Different attribute IDs correspond to different data types. For details, see the Note part of HI_UNF_AVPLAY_ATTR_ID_E. The attribute types of the pPara and enAttrID parameters must be the same.\n
+Before setting HI_UNF_AVPLAY_ATTR_ID_ADEC (audio decoding attribute) and HI_UNF_AVPLAY_ATTR_ID_VDEC (video decoding attribute),\n
+you must disable the audio channel or video channel. The new attributes take effect when you enable the audio channel or video channel again.
+CNcomment:PID\n
+IDHI_UNF_AVPLAY_ATTR_ID_E[], pParaenAttrID\n
+HI_UNF_AVPLAY_ATTR_ID_ADEC(),HI_UNF_AVPLAY_ATTR_ID_VDEC()\n
+ CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] enAttrID        Attribute ID CNcomment:ID CNend
+\param[in] pPara  Data type corresponding to an attribute ID CNcomment:ID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, const HI_VOID *pPara);
+
+/**
+\brief Obtains the attributes of an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay          AVPLAY handle CNcomment:AV CNend
+\param[in] enAttrID         Attribute ID CNcomment:ID CNend
+\param[in] pPara   Data type corresponding to an attribute ID, CNcomment:ID CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Decodes I frames. CNcomment:I CNend
+\attention \n
+If pstCapPicture is null, the decoded I frames are displayed in the window,and do not need release memory; \n
+if pstCapPicture is not null, the information about I frames is reported, and need invoke ::HI_UNF_AVPLAY_ReleaseIFrame to release memory.
+You must stop the video decoder before calling this API. If I frames are being processed, do not enable the video decoder.
+CNcomment:pstCapPictureIwindowI,IHI_UNF_AVPLAY_ReleaseIFrameI
+I CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] pstFrame        Pointer to frame attributes CNcomment: CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DecodeIFrame(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_I_FRAME_S *pstFrame, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Release memory of I frame. CNcomment:I CNend
+\attention \n
+If you call HI_UNF_AVPLAY_DecodeIFrame with non-null pstCapPicture, you need call this API to release the memory.
+CNcomment:HI_UNF_AVPLAY_DecodeIFramepstCapPicture CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ReleaseIFrame(HI_HANDLE hAvplay, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Sets the mode of a video decoder. CNcomment: CNend
+\attention \n
+This API is used in trick play mode. Before switching the mode to the trick play mode, you must enable a decoder to decode only I frames by calling this API.\n
+Before switching the mode to the normal mode, you also need to set the mode of a decoder to normal by calling this API.
+CNcomment:I\n
+NORMAL CNend
+\param[in] hAvplay            AVPLAY handle CNcomment:AV CNend
+\param[in] enDecodeMode       Decoding mode CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetDecodeMode(HI_HANDLE hAvplay, HI_UNF_VCODEC_MODE_E enDecodeMode);
+
+/**
+\brief Registers an event on 32bit system. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent     Event type enumeration CNcomment: CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB);
+/**
+\brief Registers an event on 64bit system. CNcomment:64 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent     Event type enumeration CNcomment: CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent64(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN64 pfnEventCB);
+
+/**
+\brief Deregisters an event. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV CNend
+\param[in] enEvent   Event type enumeration CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent);
+
+/**
+\brief Enables an AVPLAY channel. CNcomment:AV CNend
+\attention \n
+You can enable an audio channel and a video channel for each AVPLAY. If you only need to play videos or audios, you can enable the corresponding channel to save resources.
+CNcomment:AV1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pPara    Pointer type. For details, see the description of ::HI_UNF_AVPLAY_OPEN_OPT_S. CNcomment:::HI_UNF_AVPLAY_OPEN_OPT_S. CNend
+    If enChn is set to HI_UNF_AVPLAY_MEDIA_CHAN_VID, this API is used to specify the maximum decoding performance of the video decoder.
+    If enChn is set to NULL, the maximum performance H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD is used by default.
+    The higher the configured decoding performance, the larger the required MMZ. It is recommended that you configure the performance as required.
+    CNcomment:enChnHI_UNF_AVPLAY_MEDIA_CHAN_VID
+    NULL: H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD
+    MMZ CNend
+\retval ::HI_SUCCESS Success             CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_VOID *pPara);
+
+/**
+\brief Disables an AVPLAY channel. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV CNend
+\param[in] enChn     Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn);
+
+/**
+\brief Start an AVPLAY to prepare play mode, which just demux ts stream. CNcomment:TSPREPLAY CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in prepare play mode. The audios and videos can be prepared play separately or simultaneously.
+CNcomment:PREPLAY CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:NULL. CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStart(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTART_OPT_S *pstPreStartOpt);
+
+/**
+\brief Starts an AVPLAY. The AVPLAY is in play mode. CNcomment:PLAY CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in play mode. The audios and videos can be played separately or simultaneously.
+CNcomment:PLAY CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:NULL. CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt);
+
+/**
+\brief Stop an AVPLAY to prepare stop mode,the interface is reserved for future use. CNcomment:AVPRESTOP, CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStopOpt   Pointer to stop mode. For details, see the description of ::HI_UNF_AVPLAY_PRESTOP_OPT_S. CNcomment:::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_ERR_AVPLAY_NOT_SUPPORT not support for the moment  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTOP_OPT_S *pstPreStopOpt);
+
+/**
+\brief Stops an AVPLAY. Then the AVPLAY is in stop mode. CNcomment:AVSTOP CNend
+\attention \n
+If you call this API, all selected channels stop playing. The playing audios and videos can be stopped separately or simultaneously.\n
+The parameter pstStopOpt->enMode takes effect only when a video channel is selected.\n
+If pstStopOpt->enMode is set to NULL or HI_UNF_AVPLAY_STOP_MODE_STILL, the last frame is kept still.\n
+If pstStopOpt->enMode is set to HI_UNF_AVPLAY_STOP_MODE_BLACK, the last frame is cleared, and the blank screen appears.\n
+When pstStopOpt->u32TimeoutMs is 0, the AVPLAY stops and this API is returned.\n
+When pstStopOpt->u32TimeoutMs is greater than 0, this API is blocked until the data in the buffer is used up.\n
+When pstStopOpt->u32TimeoutMs is greater than -1, this API is blocked until the data in the buffer is used up.\n
+To stop the audio or video separately when both the audio and video are enabled, you must set pstStopOpt->u32TimeoutMs to 0.
+CNcomment:\n
+pstStopOpt->enMode\n
+pstStopOpt->enModeHI_UNF_AVPLAY_STOP_MODE_STILL\n
+pstStopOpt->enModeHI_UNF_AVPLAY_STOP_MODE_BLACK\n
+pstStopOpt->u32TimeoutMs0\n
+pstStopOpt->u32TimeoutMs>0\n
+pstStopOpt->u32TimeoutMs=-1\n
+,pstStopOpt->u32TimeoutMs0. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStopOpt   Pointer to the clear screen mode. For details, see the description of ::HI_UNF_AVPLAY_STOP_OPT_S. CNcomment:::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Pauses an AVPLAY. Then the AVPLAY is in pause mode. CNcomment:AVPAUSE CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment: AV CNend
+\param[in] pstPauseOpt  Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt);
+
+/**
+\brief Plays videos or audios in trick play mode. Then the AVPLAY is in TPLAY mode. CNcomment:TPLAY CNend
+\attention \n
+pstTplayOpt->u32SpeedInteger is the integer part of speed, the range is 0-64.
+pstTplayOpt->u32SpeedDecimal is the decimal part of speed, the range is 0-999.
+CNcomment: pstTplayOpt->u32SpeedInteger0-64. CNend
+CNcomment: pstTplayOpt->u32SpeedDecimal30-999. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment: AV CNend
+\param[in] pstTplayOpt   The pointer of Tplay parameter,For details, see the description of ::HI_UNF_AVPLAY_TPLAY_OPT_S . CNcomment:TPLAY,HI_UNF_AVPLAY_TPLAY_OPT_S CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Tplay(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_TPLAY_OPT_S *pstTplayOpt);
+
+/**
+\brief Resumes an AVPLAY. Then the AVPLAY is in play mode. CNcomment:AVPLAY CNend
+\attention \n
+By calling this API, you can resume an AVPLAY from the trick play mode or pause mode rather than the stop mode.
+CNcomment: CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstResumeOpt  Pointer used for expansion. You can set it to NULL. CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt);
+
+/**
+\brief Resets an AVPLAY. In this case, the play mode is not changed. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstResetOpt   Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Reset(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESET_OPT_S *pstResetOpt);
+
+/**
+\brief Step play. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] pstStepOpt   Pointer used for expansion. You can set it to NULL. CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Step(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_STEP_OPT_S *pstStepOpt);
+
+/**
+\brief Applies for a buffer for storing the streams played by an AVPLAY. CNcomment:AV CNend
+\attention \n
+This API is used only when you want to play the ESs obtained from Internet or local ESs.\n
+The pstData parameter is used to return the start address and size of the buffer applied for.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates that the API waits for an infinite time; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, an error code indicating full buffer is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the audio and video buffers are full. In this case, you need to call the usleep(N*1000) function to release the CPU.
+Therefore, other threads can be scheduled.
+CNcomment:ES\n
+pstDataBuffer\n
+u32TimeOutMs00xffffffffu32TimeOutMs\n
+Bufferbuffer\n
+u32TimeOutMs0BufferBufferusleep(N*1000)cpu
+ CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID CNend
+\param[in] u32ReqLen   Size of the buffer applied for CNcomment: CNend
+\param[out] pstData    Pointer to the returned buffer CNcomment: CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms CNcomment:ms. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay,
+                            HI_UNF_AVPLAY_BUFID_E enBufId,
+                            HI_U32                u32ReqLen,
+                            HI_UNF_STREAM_BUF_S  *pstData,
+                            HI_U32                u32TimeOutMs);
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment: CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:\n
+PTSu32ptsMs-1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID. CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment: CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:, CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                         HI_U32 u32ValidDataLen, HI_U32 u32PtsMs);
+
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment: CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:, \n
+PTSu32ptsMs-1 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] enBufId     Buffer queue ID CNcomment:ID CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment: CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:, CNend
+\param[in] pPutOpt   the extern parameter of PutBufEx, see the description of ::HI_UNF_AVPLAY_PUTBUFEX_OPT_S.CNcomment:PutBufEx::HI_UNF_AVPLAY_PUTBUFEX_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBufEx(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                                       HI_U32 u32ValidDataLen, HI_U32 u32Pts, HI_UNF_AVPLAY_PUTBUFEX_OPT_S *pPutOpt);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TSAVDMXHandle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMXHandle CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAudChn);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TSAVDMXHandle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMXHandle CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAdAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAdAudChn);
+
+/**
+\brief Obtains the handle of the DMX video channel used by an AVPLAY in TS mode. CNcomment:TSAVDMXHandle. CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV CNend
+\param[in] phDmxVidChn    Pointer to the handle of a DMX video channel CNcomment:DMXHandle CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxVidChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxVidChn);
+
+
+/**
+\brief Obtains the status information about an AVPLAY. CNcomment:AV CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[out] pstStatusInfo  Pointer to the status of an AVPLAY. For details, see the description of HI_UNF_AVPLAY_STATUS_INFO_S. CNcomment:AVHI_UNF_AVPLAY_STATUS_INFO_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE          hAvplay,
+                                 HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo);
+
+
+/**
+\brief Obtains the information about audio and video streams. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[in] pstStreamInfo     Pointer to the information about audio and video streams. For details, see the description of HI_UNF_AVPLAY_STREAM_INFO_S. CNcomment:HI_UNF_AVPLAY_STREAM_INFO_S CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE          hAvplay,
+                                   HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo);
+
+/**
+\brief Obtains the information audio spectrums. CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV CNend
+\param[in] pSpectrum      Pointer to the array of audio spectrums. CNcomment: CNend
+\param[in] u32BandNum     Length of an audio spectrum array CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAudioSpectrum(HI_HANDLE hAvplay, HI_U16 *pSpectrum, HI_U32 u32BandNum);
+
+/**
+\brief Queries whether the AVPLAY buffer is empty. CNcomment:AVPLAY buffer CNend
+\attention \n
+N/A
+\param[in] hAvplay        AVPLAY handle CNcomment:AV CNend
+\param[out] pbIsEmpty      Pointer type. This pointer indicates whether the AVPLAY buffer is empty (the playing ends). CNcomment:buffer() CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsBuffEmpty(HI_HANDLE hAvplay, HI_BOOL * pbIsEmpty);
+
+/**
+\brief Switch the demux audio channel CNcomment:DEMUX CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] hNewDmxAud     New demux audio handle CNcomment:DMX CNend
+\param[out] phOldDmxAud     Old  demux audio handle CNcomment:DMX CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchDmxAudChn(HI_HANDLE hAvplay, HI_HANDLE hNewDmxAud, HI_HANDLE *phOldDmxAud);
+
+/**
+\brief Notify an AVPLAY the stream is end CNcomment:AVPLAY CNend
+\attention \n
+Call this interface to notice AVPLAY when the last package of stream has been sent,
+then check whether the last frame has been output by eos event or by invoking ::HI_UNF_AVPLAY_IsBuffEmpty,
+this interface is only apply to ES mode.
+CNcomment: AVPLAYEOS::HI_UNF_AVPLAY_IsBuffEmpty
+ES CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstFlushOpt   Pointer used for expansion. You can set it to NULL.CNcomment:NULL CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FlushStream(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S *pstFlushOpt);
+
+/**
+\brief AVPLAY private command invoking. CNcomment: AVPLAY CNend
+\attention \n
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enInvokeType  Type of private command invoking.CNcomment: CNend
+\param[in] pPara         Pointer to the parameter of invoking. CNcomment:Invoke CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Invoke(HI_HANDLE hAvplay, HI_UNF_AVPLAY_INVOKE_E enInvokeType, HI_VOID *pPara);
+
+/**
+\brief Accquire user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: CC CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[out] pstUserData  user data.CNcomment: CNend
+\param[out] penType      user data type. CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S *pstUserData, HI_UNF_VIDEO_USERDATA_TYPE_E *penType);
+
+/**
+\brief Accquire user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: CC CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstUserData  user data.CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S* pstUserData);
+
+/**
+\brief Extended interface for Accquire user data. CNcomment:  CNend
+\attention \n
+support Closed Caption Data,Active Format Description.
+CNcomment: CCAFD CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enType      user data type. CNcomment: CNend
+\param[out] pstUserData  user data.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Extended interface for Release user dada. CNcomment:  CNend
+\attention \n
+Only support Closed Caption Data,Active Format Description..
+CNcomment: CCAFD CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] enType      user data type. CNcomment: CNend
+\param[in] pstUserData  user data.CNcomment: CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief set stream HDR information. CNcomment: HDR CNend
+\attention \n
+Only support VP9 HDR.
+CNcomment: VP9 HDR  CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR CNend
+\param[in] bPaddingHdrInfo    if need padding HDR information to frame information. CNcomment:HDR CNend
+\param[in] u32PtsMs  current pts of HDR information.it must be set invaild(-1),when that can not available.CNcomment:HDRpts CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetHDRInfo(HI_HANDLE hAvplay, const HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo, HI_BOOL bPaddingHdrInfo, HI_U32 u32PtsMs);
+
+/**
+\brief Queries whether the AudioCodec is supported. CNcomment: AudioCodec  CNend
+\attention \n
+N/A
+\param[in] enCodecID        AudioCodec CNcomment: CNend
+\param[out] pbSupport      Pointer support. This pointer indicates whether the AudioCodec is supported. CNcomment:AudioCodec CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsAudioCodecSupport(const HA_CODEC_ID_E enCodecID, HI_BOOL* pbSupport);
+
+/**
+\brief Switch to external audio.  CNcomment: CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] bSwitchExternalAudio     whether switch to exteral audio: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_FAILUER     Call the function failed!. CNcomment:CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchToExternalAudio(HI_HANDLE hAvplay,HI_BOOL bSwitchExternalAudio);
+
+/**
+\brief Stc calibration by user.  CNcomment:STC  CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] StcPPM      stc ppm:STCPPM CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_FAILUER     Call the function failed!. CNcomment:CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_STCCalibration(HI_HANDLE hAvplay,HI_S32 StcPPM);
+
+/**
+\brief get stream HDR information. CNcomment: HDR CNend
+\attention \n
+Support getting HDR info.
+CNcomment:  HDR  CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR CNend
+
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetHDRInfo(HI_HANDLE hAvplay, HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_cc.h b/xbmc/platform/linux/hisi/hi_unf_cc.h
new file mode 100644
index 0000000000..cbf5b34f9c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_cc.h
@@ -0,0 +1,739 @@
+/******************************************************************************
+
+Copyright (C), 2012-2019, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name       : hi_unf_cc.h
+Version         : Initial draft
+Author          :
+Created Date    :
+Last Modified by:
+Description     :
+Function List   :
+Change History  :
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about CC module (CC).
+*/
+
+#ifndef _HI_UNF_CC_H_
+#define _HI_UNF_CC_H_
+
+#include "hi_type.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*****************************************************************************
+*                    Macro Definitions
+*****************************************************************************/
+#define ARIBCC_MAX_LANGUAGE 2
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CC */
+/** @{*/  /** <!-- [CC]*/
+
+/**CC data type*//** CNcomment:CC */
+typedef enum hiUNF_CC_DATA_TYPE_E
+{
+    HI_UNF_CC_DATA_TYPE_608,  /**<CC608*//**<CNcomment:CC608 */
+    HI_UNF_CC_DATA_TYPE_708,        /**<CC708*//**<CNcomment:CC708 */
+    HI_UNF_CC_DATA_TYPE_ARIB,       /**<ARIB CC*//**<CNcomment:ARIB CC */
+    HI_UNF_CC_DATA_TYPE_BUTT
+}HI_UNF_CC_DATA_TYPE_E;
+
+/**708CC service channel*//** CNcomment:708CC*/
+typedef enum hiUNF_CC_708_SERVICE_NUM_E
+{
+    HI_UNF_CC_708_SERVICE1 = 0x1, /**<708CC service 1*//**<CNcomment:708CC1 */
+    HI_UNF_CC_708_SERVICE2,       /**<708CC service 2*//**<CNcomment:708CC2 */
+    HI_UNF_CC_708_SERVICE3,       /**<708CC service 3*//**<CNcomment:708CC3 */
+    HI_UNF_CC_708_SERVICE4,       /**<708CC service 4*//**<CNcomment:708CC4 */
+    HI_UNF_CC_708_SERVICE5,       /**<708CC service 5*//**<CNcomment:708CC5 */
+    HI_UNF_CC_708_SERVICE6,       /**<708CC service 6*//**<CNcomment:708CC6 */
+    HI_UNF_CC_708_SERVICE_BUTT
+}HI_UNF_CC_708_SERVICE_NUM_E;
+
+/**CC608 data type*//** CNcomment:CC608line 21 */
+typedef enum hiUNF_CC_608_DATATYPE_E
+{
+    HI_UNF_CC_608_DATATYPE_CC1,       /**<CC1*//**<CNcomment:CC1 */
+    HI_UNF_CC_608_DATATYPE_CC2,       /**<CC2*//**<CNcomment:CC2 */
+    HI_UNF_CC_608_DATATYPE_CC3,       /**<CC3*//**<CNcomment:CC3 */
+    HI_UNF_CC_608_DATATYPE_CC4,       /**<CC4*//**<CNcomment:CC4 */
+    HI_UNF_CC_608_DATATYPE_TEXT1,     /**<TEXT1*//**<CNcomment:TEXT1 */
+    HI_UNF_CC_608_DATATYPE_TEXT2,     /**<TEXT2*//**<CNcomment:TEXT2 */
+    HI_UNF_CC_608_DATATYPE_TEXT3,     /**<TEXT3*//**<CNcomment:TEXT3 */
+    HI_UNF_CC_608_DATATYPE_TEXT4,     /**<TEXT4*//**<CNcomment:TEXT4 */
+    HI_UNF_CC_608_DATATYPE_BUTT
+}HI_UNF_CC_608_DATATYPE_E;
+
+/**standard color*//** CNcomment: */
+typedef enum hiUNF_CC_COLOR_E
+{
+    HI_UNF_CC_COLOR_DEFAULT=0x00000000,       /**<default color*//**<CNcomment: */
+    HI_UNF_CC_COLOR_BLACK=0xff000000,         /**<black*//**<CNcomment: */
+    HI_UNF_CC_COLOR_WHITE=0xffffffff,         /**<white*//**<CNcomment: */
+    HI_UNF_CC_COLOR_RED=0xffff0000,           /**<red*//**<CNcomment: */
+    HI_UNF_CC_COLOR_GREEN=0xff00ff00,         /**<green*//**<CNcomment: */
+    HI_UNF_CC_COLOR_BLUE=0xff0000ff,          /**<blue*//**<CNcomment: */
+    HI_UNF_CC_COLOR_YELLOW=0xffffff00,        /**<yellow*//**<CNcomment: */
+    HI_UNF_CC_COLOR_MAGENTA=0xffff00ff,       /**<magenta*//**<CNcomment: */
+    HI_UNF_CC_COLOR_CYAN=0xff00ffff,          /**<cyan*//**<CNcomment: */
+}HI_UNF_CC_COLOR_E;
+
+/**opacity*//** CNcomment: */
+typedef enum hiUNF_CC_OPACITY_E
+{
+    HI_UNF_CC_OPACITY_DEFAULT,         /**<default*//**<CNcomment: */
+    HI_UNF_CC_OPACITY_SOLID,           /**<opaque*//**<CNcomment: */
+    HI_UNF_CC_OPACITY_FLASH,           /**<flash*//**<CNcomment: */
+    HI_UNF_CC_OPACITY_TRANSLUCENT,     /**<translucent*//**<CNcomment: */
+    HI_UNF_CC_OPACITY_TRANSPARENT,     /**<transparent*//**<CNcomment: */
+    HI_UNF_CC_OPACITY_BUTT
+}HI_UNF_CC_OPACITY_E;
+
+/**justify*//** CNcomment:*/
+typedef enum hiUNF_CC_JUSTIFY_E
+{
+    HI_UNF_CC_JUSTIFY_LEFT,        /**<left*//**<CNcomment: */
+    HI_UNF_CC_JUSTIFY_RIGHT,       /**<rigth*//**<CNcomment: */
+    HI_UNF_CC_JUSTIFY_CENTER,      /**<center*//**<CNcomment: */
+    HI_UNF_CC_JUSTIFY_FULL,        /**<full*//**<CNcomment: */
+    HI_UNF_CC_JUSTIFY_BUTT
+}HI_UNF_CC_JUSTIFY_E;
+
+/**word wrap*//** CNcomment:*/
+typedef enum hiUNF_CC_WORDWRAP_E
+{
+    HI_UNF_CC_WW_DISABLE,         /**<disable*//**<CNcomment: */
+    HI_UNF_CC_WW_ENABLE,          /**<enable*//**<CNcomment: */
+    HI_UNF_CC_WW_BUTT
+}HI_UNF_CC_WORDWRAP_E;
+
+/**font style*//** CNcomment: */
+typedef enum hiUNF_CC_FONTSTYLE_E
+{
+    HI_UNF_CC_FONTSTYLE_DEFAULT,         /**<default*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_NORMAL,          /**<normal*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_ITALIC,          /**<italic*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_UNDERLINE,       /**<underline*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_ITALIC_UNDERLINE,/**<italic&underline*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_BUTT
+}HI_UNF_CC_FONTSTYLE_E;
+
+/**font size*//** CNcomment: */
+typedef enum hiUNF_CC_FONTSIZE_E
+{
+    HI_UNF_CC_FONTSIZE_DEFAULT,       /**<default font size *//**<CNcomment: */
+    HI_UNF_CC_FONTSIZE_SMALL,         /**<small*//**<CNcomment: */
+    HI_UNF_CC_FONTSIZE_STANDARD,      /**<standard*//**<CNcomment: */
+    HI_UNF_CC_FONTSIZE_LARGE,         /**<large*//**<CNcomment: */
+    HI_UNF_CC_FONTSIZE_BUTT
+} HI_UNF_CC_FONTSIZE_E;
+
+typedef enum hiUNF_CC_ARIB_SCALE_E
+{
+    HI_UNF_CC_ARIB_SCALE_NORMAL,
+    HI_UNF_CC_ARIB_SCALE_HALF_ALL,
+    HI_UNF_CC_ARIB_SCALE_HALF_WIDTH,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_HEIGHT,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_WIDTH,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_ALL,
+    HI_UNF_CC_ARIB_SCALE_TINY,
+    HI_UNF_CC_ARIB_SCALE_BUTT
+}HI_UNF_CC_ARIB_SCALE_E;
+
+typedef enum tagUNF_CC_ARIB_PRTDIRECT_E
+{
+    HI_UNF_CC_ARIB_PRINT_HORIZONTAL,
+    HI_UNF_CC_ARIB_PRINT_VERTICAL,
+} HI_UNF_CC_ARIB_PRTDIRECT_E;
+
+/**font name*//** CNcomment: */
+typedef enum  hiUNF_CC_FONTNAME_E
+{
+    HI_UNF_CC_FN_DEFAULT,                  /**<default *//**<CNcomment: */
+    HI_UNF_CC_FN_MONOSPACED,               /**<monospaced*//**<CNcomment:monospaced */
+    HI_UNF_CC_FN_PROPORT,                  /**<proport*//**<CNcomment:proport */
+    HI_UNF_CC_FN_MONOSPACED_NO_SERIAFS,    /**<monospaced with no seriafs*//**<CNcomment:monospaced() */
+    HI_UNF_CC_FN_PROPORT_NO_SERIAFS,       /**<proport with no seriafs*//**<CNcomment:proport() */
+    HI_UNF_CC_FN_CASUAL,                   /**<casual*//**<CNcomment:casual */
+    HI_UNF_CC_FN_CURSIVE,                  /**<cursive*//**<CNcomment:cursive */
+    HI_UNF_CC_FN_SMALL_CAPITALS,           /**<small capitals*//**<CNcomment: */
+    HI_UNF_CC_FN_BUTT
+}HI_UNF_CC_FONTNAME_E;
+
+/**font edge type*//** CNcomment: */
+typedef enum hiUNF_CC_EdgeType_E
+{
+    HI_UNF_CC_EDGETYPE_DEFAULT,            /**<default *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_NONE,               /**<none edge type *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_RAISED,             /**<raised *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_DEPRESSED,          /**<depressed *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_UNIFORM,            /**<uniform *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_LEFT_DROP_SHADOW,   /**<left drop shadow *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_RIGHT_DROP_SHADOW,  /**<right drop shadow *//**<CNcomment: */
+    HI_UNF_CC_EDGETYPE_BUTT
+}HI_UNF_CC_EdgeType_E;
+
+/**display format of caption display screen*//** CNcomment: */
+typedef enum hiUNF_CC_DF_E
+{
+    HI_UNF_CC_DF_720X480,       /**<caption display screen is 720*480*//**<CNcomment:720*480 */
+    HI_UNF_CC_DF_720X576,       /**<caption display screen is 720*576*//**<CNcomment:720*576 */
+    HI_UNF_CC_DF_960X540,       /**<caption display screen is 960*540*//**<CNcomment:960*540 */
+    HI_UNF_CC_DF_1280X720,      /**<caption display screen is 1280*720*//**<CNcomment:1280*720 */
+    HI_UNF_CC_DF_1920X1080,     /**<caption display screen is 1920*1080*//**<CNcomment:1920*1080 */
+    HI_UNF_CC_DF_BUTT
+} HI_UNF_CC_DF_E;
+
+/**CC display operation*//** CNcomment:CC */
+typedef enum hiUNF_CC_OPT_E
+{
+     HI_UNF_CC_OPT_DRAWTEXT = 0x1, /**<draw text *//**<CNcomment: */
+     HI_UNF_CC_OPT_DRAWBITMAP,     /**<draw bitmap *//**<CNcomment: */
+     HI_UNF_CC_OPT_FILLRECT,       /**<fill rect *//**<CNcomment: */
+     HI_UNF_CC_OPT_UPDATE,        /**<Display buffer on the screen. *//**<CNcomment: */
+     HI_UNF_CC_OPT_DRAWLINE,        /**<draw line. *//**<CNcomment:*/
+     HI_UNF_CC_OPT_BUTT
+} HI_UNF_CC_OPT_E;
+
+/**Arib CC rollup mode*//** CNcomment:arib CC rollup*/
+typedef enum hiUNF_CC_ARIB_ROLLUP_E
+{
+    HI_UNF_CC_ARIB_NON_ROLLUP,        /**<Non roll-up *//**<CNcomment:rollup*/
+    HI_UNF_CC_ARIB_ROLLUP,      /**<roll-up*//**<CNcomment:rollup*/
+    HI_UNF_CC_ARIB_ROLLUP_BUTT
+}HI_UNF_CC_ARIB_ROLLUP_E;
+
+
+/**Arib CC character coding*//** CNcomment:arib CC */
+typedef enum hiUNF_CC_ARIB_TCS_E
+{
+    HI_UNF_CC_ARIB_TCS_8BIT,         /**<the type of character codig is 8bit-code*//**<CNcomment:(8)*/
+    HI_UNF_CC_ARIB_TCS_BUTT
+}HI_UNF_CC_ARIB_TCS_E;
+
+/**Arib CC display format*//** CNcomment:arib CC*/
+typedef enum hiUNF_CC_ARIB_DF_E
+{
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_SD,                /**<horizontal writing in stardard density*/    /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_SD,                  /**<vertical writing in standard density*/      /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_HD,                /**<horizontal writing in high density*/        /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_HD,                  /**<vertical writing in high density*/          /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_WESTERN,           /**<horizontal writing of western language*/    /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_1920X1080,         /**<horizontal writing in 1920X1080*/           /**<CNcomment:1920X1080*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_1920X1080,           /**<vertical writing in 1920X1080*/             /**<CNcomment:1920X1080*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_960X540,           /**<horizontal writing in 960X540*/             /**<CNcomment:960X540*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_960X540,             /**<vertical writing in 960X540*/               /**<CNcomment:960X540*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_1280X720,          /**<horizontal writing in 1280X720*/            /**<CNcomment:1280X720*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_1280X720,            /**<vertical writing in 1280X720*/              /**<CNcomment:1280X720*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_720X480,           /**<horizontal writing in 720X480*/             /**<CNcomment:720X480*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_720X480,             /**<vertical writing in 720X480*/               /**<CNcomment:720X480*/
+    HI_UNF_CC_ARIB_DF_BUTT
+}HI_UNF_CC_ARIB_DF_E;
+
+/**Arib CC display mode*//** CNcomment:arib CC*/
+typedef enum hiUNF_CC_ARIB_DMF_E
+{
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_AUTO=0x0,           /**<atomatic display when received ,automatic display when recording and playback */                    /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_NOT,                /**<atomatic display when received ,Non-displayed automatically when recording and playback*/           /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_SELECT,             /**<atomatic display when received ,Selectable display when recording and playback*/                    /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_AUTO=0x4,            /**<non-displayed automatically when received, automatic display when recording and playback */         /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_NON,                 /**<non-displayed automatically when received,Non-displayed automatically when recording and playback*/ /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_SELECT,              /**<non-displayed automatically when received,Selectable display when recording and playback*/          /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_AUTO=0x8,         /**<selectable display when received, automatic display when recording and playback */                  /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_NON,              /**<selectable display when received,Non- displayed automatically when recording and playback*/         /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_SELECT,           /**<selectable display when received,Selectable display when recording and playback*/                   /**<CNcomment:*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_AUTO=0xc,        /**<automatic display/non-display under specific condition when received,automatic display when recording and playback */           /**<CNcomment:/*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_NON,             /**<automatic display/non-display under specific condition when received,Non-displayed automatically when recording and playback*/  /**<CNcomment:/*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_SELECT,          /**<automatic display/non-display under specific condition when received,Selectable display when recording and playback*/           /**<CNcomment:/*/
+    HI_UNF_CC_ARIB_DMF_BUTT
+}HI_UNF_CC_ARIB_DMF_E;
+
+/**Arib CC time control mode*//** CNcomment:arib CC*/
+typedef enum hiUNF_CC_ARIB_TMD_E
+{
+    HI_UNF_CC_ARIB_TMD_FREE,            /**<playback time is not restricted to synchronize to the clock*//**<CNcomment:*/
+    HI_UNF_CC_ARIB_TMD_REAL_TIME,       /**<playback time is given by PTS*//**<CNcomment:PTS*/
+    HI_UNF_CC_ARIB_TMD_OFFSET_TIME,     /**<playback time added with offset time should be the new playback time*//**<CNcomment:*/
+    HI_UNF_CC_ARIB_TMD_BUTT
+}HI_UNF_CC_ARIB_TMD_E;
+
+/**CC608 VBI data*//** CNcomment:CC608 VBI */
+typedef struct hiUNF_CC_VBI_DADA_S
+{
+    HI_U8 u8FieldParity; /**<parity field *//**<CNcomment: */
+    HI_U8 u8Data1;       /**<first byte *//**<CNcomment: */
+    HI_U8 u8Data2;       /**<second byte *//**<CNcomment: */
+}HI_UNF_CC_VBI_DADA_S;
+
+/**CC rect*//** CNcomment:CC*/
+typedef struct hiUNF_CC_RECT_S
+{
+    HI_U16 x;           /**<x cordinate *//**<CNcomment:x */
+    HI_U16 y;           /**<y cordinate *//**<CNcomment:y */
+    HI_U16 width;       /**<rect width *//**<CNcomment: */
+    HI_U16 height;      /**<rect heigth *//**<CNcomment: */
+}HI_UNF_CC_RECT_S;
+
+/**CC color components*//** CNcomment:CC */
+typedef struct hiUNF_CC_COLOR_S
+{
+    HI_U8 u8Blue;       /**<blue component *//**<CNcomment:B */
+    HI_U8 u8Green;      /**<green component *//**<CNcomment:G */
+    HI_U8 u8Red;        /**<red component *//**<CNcomment:R */
+    HI_U8 u8Alpha;      /**<alpha component *//**<CNcomment:00xFF */
+} HI_UNF_CC_COLOR_S;
+
+/**CC data with text format*//** CNcomment:CC */
+typedef struct hiUNF_CC_TEXT_S
+{
+    HI_U16                 *pu16Text;    /**<cc data,2 bytes,unicode *//**<CNcomment:ccunicode2 */
+    HI_U8                  u8TextLen;    /**<cc data length *//**<CNcomment:cc */
+
+    HI_UNF_CC_COLOR_S      stFgColor;    /**<cc foregroud color*//**<CNcomment:cc */
+    HI_UNF_CC_COLOR_S      stBgColor;    /**<cc backgroud color*//**<CNcomment:cc */
+    HI_UNF_CC_COLOR_S      stEdgeColor;   /**<cc edge color*//**<CNcomment:cc*/
+
+    HI_U8                  u8Justify;    /*see HI_UNF_CC_JUSTIFY_E,used when decode cc708*//**<CNcomment:cc */
+    HI_U8                  u8WordWrap;   /*see HI_UNF_CC_WORDWRAP_E,used when decode cc708*//**<CNcomment: */
+    HI_UNF_CC_FONTSTYLE_E  enFontStyle;  /*font style ,see HI_UNF_CC_FONTSTYLE_E*//**<CNcomment:cc */
+    HI_UNF_CC_FONTSIZE_E   enFontSize;   /*font size ,see HI_UNF_CC_FONTSIZE_E*//**<CNcomment:cc */
+    HI_UNF_CC_EdgeType_E   enEdgetype;  /**<cc edge type*//**<CNcomment:cc*/
+    HI_U8                  u8AribFontSize;   /*font size *//**<CNcomment:cc */
+    HI_UNF_CC_ARIB_SCALE_E enScaleType;
+    HI_U8                  u8CharInterval;
+    HI_U8                  u8LineInterval;
+    HI_UNF_CC_ARIB_PRTDIRECT_E enPrtDirect;
+} HI_UNF_CC_TEXT_S;
+
+/**CC data with bitmap format*//** CNcomment:CC */
+typedef struct hiUNF_CC_BITMAP_S
+{
+    HI_S32                 s32BitWidth;         /**<bit width, is 2/4/8/16/24/32 *//**<CNcomment:,2/4/8/16/24/32 */
+    HI_U8                  *pu8BitmapData;      /**<pixel data *//**<CNcomment: */
+    HI_U32                 u32BitmapDataLen;    /**<length of pixel data *//**<CNcomment: */
+    HI_UNF_CC_COLOR_S      astPalette[256];     /**<palette data *//**<CNcomment: */
+    HI_U32                 u32PaletteLen;       /**<length of palette data *//**<CNcomment: */
+} HI_UNF_CC_BITMAP_S;
+
+/**parameter of fill rect*//** CNcomment: */
+typedef struct hiUNF_CC_FILLRECT_S
+{
+    HI_UNF_CC_COLOR_S      stColor;      /**<color *//**<CNcomment: */
+} HI_UNF_CC_FILLRECT_S;
+
+typedef struct hiUNF_CC_LINE_S
+{
+    HI_U32 u32X1;      /*X1*/
+    HI_U32 u32Y1;      /*Y1*/
+    HI_U32 u32X2;      /*X2*/
+    HI_U32 u32Y2;      /*Y2*/
+    HI_UNF_CC_COLOR_S      stColor;      /**/
+} HI_UNF_CC_LINE_S;
+
+/**CC display param*//** CNcomment:CC */
+typedef struct hiUNF_CC_DISPLAY_PARAM_S
+{
+    HI_UNF_CC_OPT_E        enOpt;
+    HI_U32                 u32DisplayWidth; /**<display screen width*//**<CNcomment: */
+    HI_U32                 u32DisplayHeight;/**<display screen height*//**<CNcomment: */
+    HI_UNF_CC_RECT_S       stRect;          /**<cc display location*//**<CNcomment:cc */
+    union
+    {
+        HI_UNF_CC_TEXT_S   stText;          /**<CC data with text format*//**<CNcomment:CC */
+        HI_UNF_CC_BITMAP_S stBitmap;        /**<CC data with bitmap format*//**<CNcomment:CC */
+        HI_UNF_CC_FILLRECT_S stFillRect;    /**<parameter of fill rect*//**<CNcomment: */
+        HI_UNF_CC_LINE_S   stLine;          /**<CC data with line format*//**<CNcomment:CC */
+    } unDispParam;
+
+    HI_BOOL bBlit;                          /**<Whether display on screen. HI_TRUE for display immediately and HI_FALSE for save in buffer. */
+                                            /**<CNcomment:HI_TRUEHI_FALSEbuffer */
+} HI_UNF_CC_DISPLAY_PARAM_S;
+
+/**
+\brief cc get text size callback function. CNcomment: cc()CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[in] u16Str  string. CNcomment: CNend
+\param[in] s32StrNum  number of character. CNcomment: CNend
+\param[out] ps32Width  total width of character. CNcomment: CNend
+\param[out] ps32Heigth heigth of character. CNcomment: CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETTEXTSIZE_CB_FN)(HI_VOID* pUserData, HI_U16 *u16Str,HI_S32 s32StrNum, HI_S32 *ps32Width, HI_S32 *ps32Heigth);
+
+/**
+\brief cc get text size callback function(EX). CNcomment: cc()()CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[in] pstText  text data. CNcomment: CNend
+\param[out] ps32Width  total width of character. CNcomment: CNend
+\param[out] ps32Heigth heigth of character. CNcomment: CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETTEXTSIZE_EX_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_TEXT_S *pstText, HI_S32 *ps32Width, HI_S32 *ps32Heigth);
+
+
+/**
+\brief cc display callback function. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in] u32UserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[in] pstCCdisplayParam parameter of display. CNcomment: ccCNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_DISPLAY_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_DISPLAY_PARAM_S *pstCCdisplayParam);
+
+
+/**
+\brief cc get avplay pts callback function. CNcomment: ccPTSCNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[out] ps64CurrentPts current pts. CNcomment: PTSCNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETPTS_CB_FN)(HI_VOID* pUserData, HI_S64 *ps64CurrentPts);
+
+/**
+\brief cc data blit callback function. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[in] SrcRect source rect. CNcomment: CNend
+\param[in] DstRect destination rect. CNcomment: CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_BLIT_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_RECT_S *pstSrcRect, HI_UNF_CC_RECT_S *pstDstRect);
+
+/**
+\brief cc data blit callback function. CNcomment: cc vbi CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_CreateCNend
+\param[out] pstVBIOddDataField1 VBI data,odd field data. CNcomment: VBI,CNend
+\param[out] pstVBIEvenDataField2 VBI data,even field data. CNcomment: VBI,CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_VBI_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_VBI_DADA_S *pstVBIOddDataField1,HI_UNF_CC_VBI_DADA_S *pstVBIEvenDataField2);
+
+/**
+\brief output XDS packets in CC608. CNcomment: CC608XDSCNend
+\attention \n
+XDS packet is a third data service intended to supply program related and other information.
+CNcomment: XDSCNend
+\param[in] u8XDSClass XDS class. CNcomment: XDSCNend
+\param[in] u8XDSPacketType  XDS packet type. CNcomment: XDSCNend
+\param[in] pu8Data  XDS data. CNcomment: XDSCNend
+\param[in] u8DataLen  XDS data length. CNcomment: XDSCNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+Decoding of XDS packet data, see sample/cc/sample_cc_xds.c.
+CNcomment: XDSsdksample/cc/sample_cc_xds.cCNend
+*/
+typedef HI_S32 (*HI_UNF_CC_XDS_CB_FN)(HI_U8 u8XDSClass, HI_U8 u8XDSPacketType, HI_U8 *pu8Data, HI_U8 u8DataLen);
+
+
+/**user data in MPEG*//** CNcomment:MPEGUSERDATA */
+typedef struct hiUNF_CC_USERDATA_S
+{
+    HI_U8       *pu8userdata;  /**<cc user data in mpeg *//**<CNcomment:mpegcc */
+    HI_U32      u32dataLen;    /**<cc user data length *//**<CNcomment:cc */
+    HI_BOOL     bTopFieldFirst;/**<cc top field first flag *//**<CNcomment:cc */
+} HI_UNF_CC_USERDATA_S;
+
+/**CC608 config param *//** CNcomment:CC608  */
+/**CC608 just support 8 stardard colors*//**CNcomment:CC6088*/
+typedef struct hiUNF_CC_608_CONFIGPARAM_S
+{
+    HI_UNF_CC_608_DATATYPE_E    enCC608DataType;        /**<CC608 data type *//**<CNcomment:cc608 */
+    HI_U32                      u32CC608TextColor;      /**<CC608 text color *//**<CNcomment:cc608 */
+    HI_UNF_CC_OPACITY_E         enCC608TextOpac;        /**<CC608 text opacity *//**<CNcomment:cc608 */
+    HI_U32                      u32CC608BgColor;        /**<CC608 background color *//**<CNcomment:cc608 */
+    HI_UNF_CC_OPACITY_E         enCC608BgOpac;          /**<CC608 background opacity *//**<CNcomment:cc608 */
+    HI_UNF_CC_FONTSTYLE_E       enCC608FontStyle;       /**<CC608 font style *//**<CNcomment:cc608 */
+    HI_UNF_CC_DF_E              enCC608DispFormat;      /**<CC608 display format of caption display screen *//**<CNcomment:cc608 */
+    HI_BOOL                     bLeadingTailingSpace;   /**<CC608 leading/tailing space flag*//**<CNcomment: leading/tailing space*/
+} HI_UNF_CC_608_CONFIGPARAM_S;
+
+/**CC708 config param *//** CNcomment:CC708  */
+/**CC708 color specification CEA-708-B-1999.pdf section 9.20 Color Representation*//**CNcomment:CC708CEA-708-B-1999.pdf 9.20  */
+/**The specification does not define the specific color component, using the following component values in our version*/
+/***/
+/**CC708 support 64 colors.one of RGB color components can be 0x00,0x5f,0xaf,0xff*//**CNcomment:CC70864,RGB0x00,0x5f,0xaf,0xff4*/
+/** 0x    FF          FF          FF          FF*/       /**CNcomment: 0x FF     FF         FF          FF*/
+/**    reserve    red value   green value  blue value*/  /**                        */
+typedef struct hiUNF_CC_708_CONFIGPARAM_S
+{
+    HI_UNF_CC_708_SERVICE_NUM_E enCC708ServiceNum;      /**<CC708 service number *//**<CNcomment:cc708 */
+    HI_UNF_CC_FONTNAME_E        enCC708FontName;        /**<CC708 font name *//**<CNcomment:cc708 */
+    HI_UNF_CC_FONTSTYLE_E       enCC708FontStyle;       /**<CC708 font style *//**<CNcomment:cc708 */
+    HI_UNF_CC_FONTSIZE_E        enCC708FontSize;        /**<CC708 font size *//**<CNcomment:cc708 */
+    HI_U32                      u32CC708TextColor;      /**<CC708 text color *//**<CNcomment:cc708 */
+    HI_UNF_CC_OPACITY_E         enCC708TextOpac;        /**<CC708 text opacity *//**<CNcomment:cc708 */
+    HI_U32                      u32CC708BgColor;        /**<CC708 background color *//**<CNcomment:cc708 */
+    HI_UNF_CC_OPACITY_E         enCC708BgOpac;          /**<CC708 background opacity *//**<CNcomment:cc708 */
+    HI_U32                      u32CC708WinColor;       /**<CC708 window color *//**<CNcomment:cc708 */
+    HI_UNF_CC_OPACITY_E         enCC708WinOpac;         /**<CC708 window opacity *//**<CNcomment:cc708 */
+    HI_UNF_CC_EdgeType_E        enCC708TextEdgeType;    /**<CC708 text egde type *//**<CNcomment:cc708 */
+    HI_U32                      u32CC708TextEdgeColor;  /**<CC708 text edge color *//**<CNcomment:cc708 */
+    HI_UNF_CC_DF_E              enCC708DispFormat;      /**<CC708 display format of caption display screen *//**<CNcomment:cc708 */
+} HI_UNF_CC_708_CONFIGPARAM_S;
+
+/**ARIB CC config param *//** CNcomment:ARIB CC  */
+typedef struct hiUNF_CC_ARIB_CONFIGPARAM_S
+{
+    HI_U32      u32BufferSize;   /**<size of buffer which used to cache pes data,Recommends its value is 64K ~ 512K.note:This value can only be set when created,does not support dynamic setting*/
+                                 /**<CNcomment:PES64k~512K:*/
+} HI_UNF_CC_ARIB_CONFIGPARAM_S;
+
+/**CC data attribution *//** CNcomment:CC */
+typedef struct hiUNF_CC_ATTR_S
+{
+    HI_UNF_CC_DATA_TYPE_E enCCDataType;   /**<cc data type *//**<CNcomment:cc */
+    union
+    {
+        HI_UNF_CC_608_CONFIGPARAM_S  stCC608ConfigParam;   /**<CC608 config param *//**<CNcomment:CC608  */
+        HI_UNF_CC_708_CONFIGPARAM_S  stCC708ConfigParam;   /**<CC708 config param *//**<CNcomment:CC708  */
+        HI_UNF_CC_ARIB_CONFIGPARAM_S stCCARIBConfigParam;  /**<ARIB CC config param *//**<CNcomment:ARIB CC  */
+    } unCCConfig;
+} HI_UNF_CC_ATTR_S;
+
+/**CC instance param *//** CNcomment: */
+typedef struct hiUNF_CC_PARAM_S
+{
+    HI_UNF_CC_ATTR_S             stCCAttr;           /**<cc attribution *//**<CNcomment:cc */
+
+    HI_UNF_CC_GETPTS_CB_FN       pfnCCGetPts;        /**<get current pts callback function *//**<CNcomment:pts */
+    HI_UNF_CC_DISPLAY_CB_FN      pfnCCDisplay;       /**<cc display callback function *//**<CNcomment:cc */
+    HI_UNF_CC_GETTEXTSIZE_CB_FN  pfnCCGetTextSize;   /**<cc get text size callback function *//**<CNcomment:cc()  */
+    HI_UNF_CC_GETTEXTSIZE_EX_CB_FN pfnCCGetTextSizeEx;
+    HI_UNF_CC_BLIT_CB_FN         pfnBlit;            /**<cc data blit callback function *//**<CNcomment:cc */
+    HI_UNF_CC_VBI_CB_FN          pfnVBIOutput;       /**<output VBI data callback function *//**<CNcomment:VBI */
+    HI_UNF_CC_XDS_CB_FN          pfnXDSOutput;       /**<output XDS packets function *//**<CNcomment:CC608XDS */
+    HI_VOID*                     pUserData;        /**<user data,used in callback function *//**<CNcomment: */
+} HI_UNF_CC_PARAM_S;
+
+/*ARIB CC info node*//** CNcomment:arib cc */
+typedef struct hiUNF_CC_ARIB_INFONODE_S
+{
+    HI_U8 u8LanguageTag;                   /**<identification of language*//**<CNcomment: */
+    HI_UNF_CC_ARIB_DMF_E    enCCAribDMF;   /**<display mode *//**<CNcomment: */
+    HI_CHAR    acISO639LanguageCode[4];    /**<language code *//**<CNcomment: */
+    HI_UNF_CC_ARIB_DF_E enCCAribDF;        /**<display format *//**<CNcomment: */
+    HI_UNF_CC_ARIB_TCS_E enCCAribTCS;         /**<character coding *//**<CNcomment: */
+    HI_UNF_CC_ARIB_ROLLUP_E enCCAribRollup;    /**<roll-up mode *//**<CNcomment:roll-up */
+}HI_UNF_CC_ARIB_INFONODE_S;
+
+/*ARIB CC info struct*//** CNcomment:arib cc */
+typedef struct hiUNF_CC_ARIB_INFO_S
+{
+    HI_UNF_CC_ARIB_TMD_E enCCAribTMD;   /**<time control mode*//**<CNcomment: */
+    HI_U32 u32NumLanguage;       /**<number of languages *//**<CNcomment: */
+    HI_UNF_CC_ARIB_INFONODE_S stCCAribInfonode[ARIBCC_MAX_LANGUAGE];     /**<array of arib cc info *//**<CNcomment:arib cc */
+}HI_UNF_CC_ARIB_INFO_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/**
+\brief Initialize cc module. CNcomment: CCCNend
+\attention \n
+none. CNcomment: CNend
+\retval ::HI_SUCCESS initialize success. CNcomment: CNend
+\retval ::HI_FAILURE initialize failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Init(HI_VOID);
+
+/**
+\brief DeInitialize cc module. CNcomment: CCCNend
+\attention \n
+none. CNcomment: CNend
+\retval ::HI_SUCCESS deinitialize success. CNcomment: CNend
+\retval ::HI_FAILURE deinitialize failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_DeInit(HI_VOID);
+
+/**
+\brief Get default attribution in cc module. CNcomment: CCCNend
+\attention \n
+none. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_GetDefaultAttr(HI_UNF_CC_ATTR_S *pstDefaultAttr);
+
+/**
+\brief open cc module. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  pstAttr  cc attribution. CNcomment: CNend
+\param[out]  phCC  cc handle. CNcomment: ccCNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Create(HI_UNF_CC_PARAM_S *pstCCParam, HI_HANDLE *phCC);
+
+/**
+\brief close cc module. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Destroy(HI_HANDLE hCC);
+
+/**
+\brief start cc module. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Start(HI_HANDLE hCC);
+
+/**
+\brief stop cc module. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Stop(HI_HANDLE hCC);
+
+/**
+\brief reset cc module. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_Reset(HI_HANDLE hCC);
+
+/**
+\brief inject mpeg userdata to  cc module. CNcomment: mpegccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\param[in]  pstUserData  cc userdata structure used in inject cc data. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_InjectUserData(HI_HANDLE hCC, HI_UNF_CC_USERDATA_S *pstUserData);
+
+/**
+\brief inject cc pes data to cc module. CNcomment: pescc()CNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment:CNend
+\param[in]  pu8PesData  pes data address. CNcomment: pesCNend
+\param[in]  u32DataLen  pes data length. CNcomment: pesCNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_InjectPESData(HI_HANDLE hCC, HI_U8 *pu8PesData, HI_U32 u32DataLen);
+
+/**
+\brief get cc attribution. CNcomment: ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment: CNend
+\param[out]  pstCCAttr  cc attribution structure. CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_GetAttr(HI_HANDLE hCC, HI_UNF_CC_ATTR_S *pstCCAttr);
+
+/**
+\brief set cc attribution. CNcomment:ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  cc handle. CNcomment. CNcomment: CNend
+\param[in]  pstCCAttr  cc attribution structure. CNcomment:CNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_SetAttr(HI_HANDLE hCC, HI_UNF_CC_ATTR_S *pstCCAttr);
+
+
+/**
+\brief get cc arib info. CNcomment: arib ccCNend
+\attention \n
+none. CNcomment: CNend
+\param[in]  hCC  arib cc handle. CNcomment: CNend
+\param[out]  pstCCAttr  arib cc info structure. CNcomment:arib ccCNend
+\retval ::HI_SUCCESS success. CNcomment: CNend
+\retval ::HI_FAILURE failure. CNcomment: CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_CC_GetARIBCCInfo(HI_HANDLE hCC,HI_UNF_CC_ARIB_INFO_S *pstCCAribInfo);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_ci.h b/xbmc/platform/linux/hisi/hi_unf_ci.h
new file mode 100644
index 0000000000..3adb6b705f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_ci.h
@@ -0,0 +1,691 @@
+#ifndef __HI_UNF_CI_TYPE_H__
+#define __HI_UNF_CI_TYPE_H__
+
+#include "hi_error_mpi.h"
+#include "hi_common.h"
+#include <linux/string.h>
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CI*/
+/** @{ */  /** <!-- [CI] */
+
+/** support CI Port*/
+/** CNcomment:CI Port */
+typedef enum hiUNF_CI_PORT_E
+{
+    HI_UNF_CI_PORT_0,
+    HI_UNF_CI_PORT_1,
+    HI_UNF_CI_PORT_BUTT
+} HI_UNF_CI_PORT_E;
+
+/** support CI PCMCIA Cards(Module) */
+/** CNcomment:CI PCMCIA Cards(Module) */
+typedef enum hiUNF_CI_PCCD_E
+{
+    HI_UNF_CI_PCCD_A,
+    HI_UNF_CI_PCCD_B,
+    HI_UNF_CI_PCCD_BUTT
+} HI_UNF_CI_PCCD_E;
+
+/** Module on-off power control */
+/** CNcomment:Module */
+typedef enum hiUNF_CI_PCCD_CTRLPOWER_E
+{
+    HI_UNF_CI_PCCD_CTRLPOWER_ON,
+    HI_UNF_CI_PCCD_CTRLPOWER_OFF,
+    HI_UNF_CI_PCCD_CTRLPOWER_BUFF
+} HI_UNF_CI_PCCD_CTRLPOWER_E;
+
+/** Module ready state:ready/busy */
+/** CNcomment:Module:ready/busy */
+typedef enum hiUNF_CI_PCCD_READY_E
+{
+    HI_UNF_CI_PCCD_BUSY,
+    HI_UNF_CI_PCCD_READY
+} HI_UNF_CI_PCCD_READY_E, *HI_UNF_CI_PCCD_READY_E_PTR;
+
+/** Module online state:present/absent */
+/** CNcomment:Module:present/absent */
+typedef enum hiUNF_CI_PCCD_STATUS_E
+{
+    HI_UNF_CI_PCCD_STATUS_ABSENT,
+    HI_UNF_CI_PCCD_STATUS_PRESENT,
+    HI_UNF_CI_PCCD_STATUS_BUTT
+} HI_UNF_CI_PCCD_STATUS_E, *HI_UNF_CI_PCCD_STATUS_E_PTR;
+
+/** card call mode */
+/** CNcomment: */
+typedef enum hiUNF_CI_PCCD_ACCESSMODE_E
+{
+    HI_UNF_CI_PCCD_ACCESS_ATTR,
+    HI_UNF_CI_PCCD_ACCESS_IO,
+    HI_UNF_CI_PCCD_ACCESS_COMMON,
+    HI_UNF_CI_PCCD_ACCESS_BUTT
+} HI_UNF_CI_PCCD_ACCESSMODE_E;
+
+/** get state register mask code */
+/** CNcomment: */
+typedef enum hiUNF_CI_PCCD_STATUS_BIT_E
+{
+    HI_UNF_CI_PCCD_STATUS_BIT_ALL,  /**< get all bits */               /**< CNcomment: */
+    HI_UNF_CI_PCCD_STATUS_BIT_DA,   /**< get Data Available bit */     /**< CNcomment:Data Available */
+    HI_UNF_CI_PCCD_STATUS_BIT_FR,   /**< get Free bit */               /**< CNcomment:Free */
+    HI_UNF_CI_PCCD_STATUS_BIT_RE,   /**< get Read Error bit */         /**< CNcomment:Read Error */
+    HI_UNF_CI_PCCD_STATUS_BIT_WE,   /**< get Write Error bit */        /**< CNcomment:Write Error */
+    HI_UNF_CI_PCCD_STATUS_BIT_BUTT
+} HI_UNF_CI_PCCD_STATUS_BIT_E;
+
+/** The mode of CI Transport Stream Interface connection */
+/** CNcomment:CI TSI */
+typedef enum hiUNF_CI_TSI_MODE_E
+{
+    HI_UNF_CI_TSI_DAISY_CHAINED,      /**< Daisy-chained */
+    HI_UNF_CI_TSI_INDEPENDENT,        /**< Independent, non-daisy-chained */
+    HI_UNF_CI_TSI_BUTT
+}HI_UNF_CI_TSI_MODE_E;
+
+/** The mode of TS pass to the CI device*/
+/** CNcomment:CITS */
+typedef enum hiUNF_CI_TS_MODE_E
+{
+    HI_UNF_CI_TS_SERIAL,         /**< serial 1*/
+    HI_UNF_CI_TS_PARALLEL,       /**< Parallel TS, default */
+    HI_UNF_CI_TS_USB2SERIAL,     /**< USB input, serial output */
+    HI_UNF_CI_TS_USB2PARALLEL,   /**< USB input, parallel output */
+    HI_UNF_CI_TS_BUTT
+}HI_UNF_CI_TS_MODE_E;
+
+/** The TSI serial number of the CI device*/
+/** CNcomment:CITS */
+typedef enum hiUNF_CI_TSI_SERIAL_PORT_E
+{
+    HI_UNF_CI_TSI_SERIAL1 = 0x04,  /**< TSI serial 1*/
+    HI_UNF_CI_TSI_SERIAL2,         /**< TSI serial 2*/
+    HI_UNF_CI_TSI_SERIAL3,         /**< TSI serial 3*/
+    HI_UNF_CI_TSI_SERIAL4,         /**< TSI serial 4*/
+    HI_UNF_CI_TSI_SERIAL_BUTT
+}HI_UNF_CI_TSI_SERIAL_PORT_E;
+
+/** The command exchange channel between the host and device*/
+/** CNcomment:CI*/
+typedef enum hiUNF_CI_CMD_EXCHANGE_CHAN_E
+{
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_USB,
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_SPI,
+    HI_UNF_CI_EXCHANGE_CHAN_BUTT,
+}HI_UNF_CI_CMD_EXCHANGE_CHAN_E;
+
+/** CI device*/
+/** CNcomment:CI */
+typedef enum hiUNF_CI_DEV_E
+{
+    HI_UNF_CI_DEV_CIMAX,        /**< CIMaX, default */
+    HI_UNF_CI_DEV_CIMAXPLUS,    /**< CIMaX+ */
+    HI_UNF_CI_DEV_HICI,         /**< HICI */
+    HI_UNF_CI_DEV_STARCI2WIN,   /**< StarCI2Win */
+    HI_UNF_CI_DEV_BUTT
+}HI_UNF_CI_DEV_E;
+
+/** CIMaX device configuration */
+/** CNcomment:CIMaX */
+typedef struct hiUNF_CI_CIMAX_ATTR_S
+{
+    HI_U32  u32SMIBitWidth;         /**< SMI Bit Width */
+    HI_U32  u32SMIBaseAddr;         /**< SMI Base Address */
+    HI_U32  u32I2cNum;              /**< I2C Group */
+    HI_U8   u8DevAddress;           /**< I2C device address */
+}HI_UNF_CI_CIMAX_ATTR_S, *HI_UNF_CI_CIMAX_ATTR_S_PTR;
+
+/** CIMaX+ device configuration */
+/** CNcomment:CIMaX+ */
+typedef struct hiUNF_CI_CIMAXPLUS_ATTR_S
+{
+    HI_U32  u32ResetGpioNo; /**< The GPIO to reset the device */
+    HI_U32  u32IntGpioNo;   /**< The GPIO to receive the device's Interrupt signal */
+    HI_UNF_CI_TSI_SERIAL_PORT_E enTsiSerialPort[HI_UNF_CI_PCCD_BUTT]; /**< The TSI serial port of device*/
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_E  enCmdExchangeChan;     /**< The command exchange channel between the host and device*/
+    HI_U32  u32SPIDevNo;           /**< The SPI device number*/
+}HI_UNF_CI_CIMAXPLUS_ATTR_S, *HI_UNF_CI_CIMAXPLUS_ATTR_S_PTR;
+
+/** HICI device configuration */
+/** CNcomment:HICI */
+typedef struct hiUNF_CI_HICI_ATTR_S
+{
+    HI_BOOL bIsPowerCtrlGpioUsed;
+    HI_U32 u32PowerCtrlGpioNo[HI_UNF_CI_PCCD_BUTT];/**< The GPIO to power on/off the device */
+}HI_UNF_CI_HICI_ATTR_S, *HI_UNF_CI_HICI_ATTR_S_PTR;
+
+/** CI device configuration */
+/** CNcomment:CI */
+typedef struct hiUNF_CI_ATTR_S
+{
+    HI_UNF_CI_DEV_E enDevType;                          /**< CI device type */
+    HI_UNF_CI_TSI_MODE_E enTSIMode;                     /**< The mode of CI Transport Stream Interface connection */
+    HI_UNF_CI_TS_MODE_E enTSMode[HI_UNF_CI_PCCD_BUTT];     /**< The mode of TS pass to the CI device */
+    union
+    {
+        HI_UNF_CI_CIMAX_ATTR_S stCIMaX;
+        HI_UNF_CI_CIMAXPLUS_ATTR_S stCIMaXPlus;
+        HI_UNF_CI_HICI_ATTR_S stCIHICI;
+    }unDevAttr;
+}HI_UNF_CI_ATTR_S, *HI_UNF_CI_ATTR_S_PTR;
+
+/** TS control command */
+/** CNcomment:TS */
+typedef enum hiUNF_CI_PCCD_TSCTRL_E
+{
+    HI_UNF_CI_PCCD_TSCTRL_BYPASS,
+    HI_UNF_CI_PCCD_TSCTRL_SETMODE,
+    HI_UNF_CI_PCCD_TSCTRL_WRITETS,
+    HI_UNF_CI_PCCD_TSCTRL_BUTT
+}HI_UNF_CI_PCCD_TSCTRL_E;
+/** USB TS Write parameter */
+/** CNcomment:USB */
+typedef struct hiUNF_CI_PCCD_TSWRITE_S
+{
+    HI_U8* pu8Data;     /**< Write data [in]*/
+    HI_U32 u32Size;     /**< Write data size [in]*/
+}HI_UNF_CI_PCCD_TSWRITE_S;
+
+/** TS control parameter */
+/** CNcomment:TS */
+typedef union
+{
+    struct
+    {
+        HI_BOOL bByPass;    /**< TURE means bypass, FALSE means pass-through */  /**< CNcomment:TRUEbypass, FALSEpass-through */
+    }stByPass;
+
+    struct
+    {
+        HI_UNF_CI_TS_MODE_E enTSMode;        /**< TS mode: parallel/serial/USB */
+    }stMode;
+
+    HI_UNF_CI_PCCD_TSWRITE_S stWrite;
+
+    /* For extend */
+}HI_UNF_CI_PCCD_TSCTRL_PARAM_U;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      CI */
+/** @{ */  /** <!-- [CI]*/
+
+/**
+\brief CI init
+\brief CNcomment:CI  CNend
+\attention \n
+N/A
+\param    N/A                                         CNcomment: CNend
+\retval ::HI_SUCCESS              success             CNcomment:  CNend
+\retval ::HI_FAILURE              fail                CNcomment: CNend
+\retval ::HI_ERR_CI_OPEN_ERR      opening file fail   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Init(HI_VOID);
+
+/**
+\brief CI deinit
+\brief CNcomment:CI  CNend
+\attention \n
+N/A
+\param  N/A                                              CNcomment: CNend
+\retval ::HI_SUCCESS             success                 CNcomment: CNend
+\retval ::HI_FAILURE             fail                    CNcomment: CNend
+\retval ::HI_ERR_CI_CLOSE_ERR    closing file fail       CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_DeInit(HI_VOID);
+
+/**
+\brief Sets CI device configration.
+\brief CNcomment:CI  CNend
+\attention \n
+N/A
+\param[in] enCIPort  CI Port number.                     CNcomment:CI port CNend
+\param[in] pstCIAttr The pointer to a structure of CI device.
+                                                         CNcomment:CI CNend
+\retval ::HI_SUCCESS            success                  CNcomment: CNend
+\retval ::HI_FAILURE            fail                     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_SetAttr(HI_UNF_CI_PORT_E enCIPort, const HI_UNF_CI_ATTR_S *pstCIAttr);
+
+/**
+\brief Gets CI device configration.
+\brief CNcomment:CI  CNend
+\attention \n
+N/A
+\param[in] enCIPort  CI Port number.                     CNcomment:CI port CNend
+\param[in] pstCIAttr The pointer to a structure of CI device.
+                                                         CNcomment:CI CNend
+\retval ::HI_SUCCESS            success                  CNcomment: CNend
+\retval ::HI_FAILURE            fail                     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_GetAttr(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_ATTR_S *pstCIAttr);
+
+/**
+\brief open CI Port
+\brief CNcomment:CI Port CNend
+\attention \n
+N/A
+\param[in] enCIPort     CI Port number                    CNcomment:CI port CNend
+\retval ::HI_SUCCESS    success                           CNcomment: CNend
+\retval ::HI_FAILURE     fail                             CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port   CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error   CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Open(HI_UNF_CI_PORT_E enCIPort);
+
+/**
+\brief close CI Port
+\brief CNcomment:CI Port CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number   CNcomment:CI port CNend
+\retval ::HI_SUCCESS       success      CNcomment: CNend
+\retval ::HI_FAILURE       fail         CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Close(HI_UNF_CI_PORT_E enCIPort);
+
+/**
+\brief open CAM
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                       CNcomment:CI port CNend
+\param[in] enCardId     Card ID                                             CNcomment: CNend
+\retval ::HI_SUCCESS    success                                             CNcomment: CNend
+\retval ::HI_FAILURE     fail                                               CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA   invalid parameter                        CNcomment:  CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open   CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                     CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                     CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Open(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+ \brief close CAM
+ \brief CNcomment:CAM CNend
+
+ \attention \n
+N/A
+ \param[in] enCIPort   CI Port number   CNcomment:CI port CNend
+ \param[in] enCardId   Card Id          CNcomment: CNend
+ \retval ::HI_SUCCESS   success         CNcomment: CNend
+ \retval ::HI_FAILURE    fail           CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_CI_PCCD_Close(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+ \brief CAM power switch
+ \brief CNcomment:CAM CNend
+ \attention \n
+    Some solutions don't support power down for a single card, the calling of this interface
+    automatically detects a power outage card plug, if it is on ,it will keep power on
+    CNcomment: CNend
+ \param[in] enCIPort    CI Port number                                       CNcomment:CI port CNend
+ \param[in] enCardId    Card Id                                              CNcomment: CNend
+ \param[in] enCtrlPower power on\power off                                   CNcomment: CNend
+ \retval ::HI_SUCCESS      success                                           CNcomment: CNend
+ \retval ::HI_FAILURE      fail                                              CNcomment: CNend
+ \retval ::HI_ERR_CI_INVALID_PARA     invalid parameter                      CNcomment: CNend
+ \retval ::HI_ERR_CI_NOT_INIT         have not been initialized or not open  CNcomment: CNend
+ \retval ::HI_ERR_CI_UNSUPPORT        unsupported CI Port                    CNcomment:CI Port CNend
+ \retval ::HI_ERR_CI_REG_READ_ERR     read register error                    CNcomment: CNend
+ \retval ::HI_ERR_CI_REG_WRITE_ERR    write register error                   CNcomment: CNend
+ \retval ::HI_ERR_CI_CANNOT_POWEROFF  can not power off                      CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_CI_PCCD_CtrlPower(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_CTRLPOWER_E enCtrlPower);
+
+/**
+\brief CI reset
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment: CNend
+\retval ::HI_SUCCESS   success                                                CNcomment: CNend
+\retval ::HI_FAILURE   fail                                                   CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                      CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open  CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                    CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                    CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Reset(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM ready state checking
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                     CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                            CNcomment: CNend
+\param[out] penCardReady  state value                                        CNcomment: CNend
+\retval ::HI_SUCCESS      success                                            CNcomment: CNend
+\retval ::HI_FAILURE      fail                                               CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA   invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT       have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT      unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR   read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR  write register error                      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_IsReady(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_READY_E_PTR penCardReady);
+
+/**
+\brief check CAM if it is on
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment: CNend
+\param[out] penCardStatus  card up or card down                               CNcomment: CNend
+\retval ::HI_SUCCESS        success                                           CNcomment: CNend
+\retval ::HI_FAILURE        fail                                              CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Detect(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_STATUS_E_PTR penCardStatus);
+
+/**
+\brief CAM set access module
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment: CNend
+\param[in] enAccessMode mode you want to set                                  CNcomment: CNend
+\retval ::HI_SUCCESS        success                                           CNcomment: CNend
+\retval ::HI_FAILURE        fail                                              CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_SetAccessMode(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                    HI_UNF_CI_PCCD_ACCESSMODE_E enAccessMode);
+
+/**
+\brief CAM write or read state checking
+\brief CNcomment:CAM CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment: CNend
+\param[in] enStatus    status of the bit will check                           CNcomment: CNend
+\param[out] pu8Value   status code returned                                   CNcomment: CNend
+\retval ::HI_SUCCESS        success                                           CNcomment: CNend
+\retval ::HI_FAILURE        fail                                              CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_IO_READ_ERR       read IO error                           CNcomment:IO CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_GetStatus (HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                HI_UNF_CI_PCCD_STATUS_BIT_E enStatus, HI_U8 *pu8Value);
+
+/**
+\brief CAM IO read data
+\brief CNcomment:CAMIO CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                      CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment: CNend
+\param[out] pu8Buffer     data buffer                                         CNcomment:  CNend
+\param[in]  u32BufferLen  data buffer length                                  CNcomment: Buffer CNend
+\param[out] pu32ReadLen   data length that read successful                    CNcomment: CNend
+\retval ::HI_SUCCESS      success                                             CNcomment: CNend
+\retval ::HI_FAILURE        fail                                              CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment: CNend
+\retval ::HI_ERR_CI_IO_READ_ERR     read IO error                             CNcomment:IO CNend
+\see \n
+    HI_UNF_CI_PCCD_IOWrite()
+*/
+HI_S32 HI_UNF_CI_PCCD_IORead(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_U8 *pu8Buffer, HI_U32 u32BufferLen,
+                                            HI_U32 *pu32ReadLen);
+
+/**
+\brief CAM IO write data
+\brief CNcomment:CAMIO CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                      CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment: CNend
+\param[in] pu8Buffer      data buffer                                         CNcomment: CNend
+\param[in] u32WriteLen     byte number that have been  writen                 CNcomment: CNend
+\param[out] pu32WriteOKLen  data length that write successful                 CNcomment: CNend
+\param[in] enCIPort       operate CI port                                     CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment: CNend
+\param[out] pu8Buffer     data buffer                                         CNcomment:  CNend
+\param[out] pu32ReadLen   data length that read successful                    CNcomment: CNend
+\retval ::HI_SUCCESS      success                                             CNcomment: CNend
+\retval ::HI_FAILURE        fail                                              CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment: CNend
+\retval ::HI_ERR_CI_IO_WRITE_ERR    write IO error                            CNcomment:IO CNend
+\see \n
+    HI_UNF_CI_PCCD_IORead()
+*/
+HI_S32 HI_UNF_CI_PCCD_IOWrite(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_U8 *pu8Buffer, HI_U32 u32WriteLen, HI_U32 *pu32WriteOKLen);
+
+/**
+\brief check CAM CIS information
+\brief CNcomment:CAMCIS CNend
+\attention \n
+    reference EN50221.
+    CNcomment: EN50221. CNend
+\param[in] enCIPort       CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment: CNend
+\retval ::HI_SUCCESS      success                                                CNcomment: CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment: CNend
+\retval ::HI_ERR_CI_PCCD_CIS_READ      read CIS information fail                 CNcomment:CIS CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                          CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                         CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_CheckCIS(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief config CAM COR information
+\brief CNcomment:CAMCOR CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment: CNend
+\retval ::HI_SUCCESS      success                                                CNcomment: CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment: CNend
+\retval ::HI_ERR_CI_ATTR_WRITE_ERR     config COR fail                           CNcomment:COR CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment: CNend
+\see \n
+    N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_WriteCOR(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM IO reset
+\brief CNcomment:CAMIO CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment: CNend
+\retval ::HI_SUCCESS      success                                                CNcomment: CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          not supported CI Port                     CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_PCCD_TIMEOUT       timeout                                   CNcomment: CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment: CNend
+\see \n
+    HI_UNF_CI_PCCD_CheckCIS()
+*/
+HI_S32 HI_UNF_CI_PCCD_IOReset(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM negotiate buffer size
+\brief CNcomment:CAMbuffer size CNend
+\attention \n
+    N/A
+\param[in] enCIPort      CI Port number                                          CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment: CNend
+\param[in] pu16BufferSize   input  buffer size that master support               CNcomment:buffer size CNend
+\param[out] pu16BufferSize  output buffer size after consultation                CNcomment:buffer size CNend
+\retval ::HI_SUCCESS      success                                                CNcomment: CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_PCCD_TIMEOUT       timeout                                   CNcomment: CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment: CNend
+\retval ::HI_ERR_CI_IO_READ_ERR        read IO error                             CNcomment:IO CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_NegBufferSize(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                    HI_U16 *pu16BufferSize);
+
+/**
+\brief CAM TS control
+CNcomment: \brief CAMTS CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment: CNend
+\param[in] enCMD          control command                                        CNcomment: CNend
+\param[in] pParam         parameter that matching command                        CNcomment: CNend
+\retval ::HI_SUCCESS      success                                                CNcomment: CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment: CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment: CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment: CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment: CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_TSCtrl(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                        HI_UNF_CI_PCCD_TSCTRL_E enCMD, HI_UNF_CI_PCCD_TSCTRL_PARAM_U *pParam);
+
+/**
+\brief Get CAM CIS
+CNcomment:\brief CAMCIS
+\attention \n
+    N/A
+\param[in] enCIPort            CI Port number                                       CNcomment:CI port
+\param[in] enCardId           Card Id                                              CNcomment:
+\param[out] pu8CisBuffer       output CIS data                                      CNcomment:CAMCIS
+\param[in]  u32CisBufferLen the length of output CIS data buffer                 CNcomment:CAMCISBuffer
+\param[out] pu32CisLen      output CIS data length                                CNcomment:CAMCIS
+\retval ::HI_SUCCESS      success                                                CNcomment:
+\retval ::HI_FAILURE        fail                                                 CNcomment:
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:
+\retval ::HI_ERR_CI_PCCD_CIS_READ      read cis error                            CNcomment:CIS
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_GetCIS(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                             HI_U8 *pu8CisBuffer, HI_U32 u32CisBufferLen, HI_U32 *pu32CisLen);
+
+/**
+\brief config CAM COR information
+CNcomment:\brief CAMCOR
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:CI port
+\param[in] enCardId       Card Id                                                CNcomment:
+\param[in] u16Addr        COR register address                                   CNcomment:COR
+\param[in] u8Data         COR register data                                      CNcomment:COR
+\retval ::HI_SUCCESS      success                                                CNcomment:
+\retval ::HI_FAILURE        fail                                                 CNcomment:
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:CI Port
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:
+\retval ::HI_ERR_CI_ATTR_WRITE_ERR     config COR fail                           CNcomment:COR
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:
+\see \n
+    N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_WriteCOREx(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                  HI_U16 u16Addr, HI_U8 u8Data);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
\ No newline at end of file
diff --git a/xbmc/platform/linux/hisi/hi_unf_cipher.h b/xbmc/platform/linux/hisi/hi_unf_cipher.h
new file mode 100644
index 0000000000..7ccb7484d2
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_cipher.h
@@ -0,0 +1,1319 @@
+#ifndef __HI_UNF_CIPHER_H__
+#define __HI_UNF_CIPHER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+
+/** max length of SM2, unit: word */
+/** CNcomment: SM2word */
+#define SM2_LEN_IN_WROD                   (8)
+
+/** max length of SM2, unit: byte */
+/** CNcomment: SM2byte */
+#define SM2_LEN_IN_BYTE                   (SM2_LEN_IN_WROD * 4)
+
+/** CIPHER only update key, don't set the IV */
+/** CNcomment: CIPHER IV */
+#define CIPHER_IV_CHANGE_KEY_ONLY         (0)
+
+/** CIPHER set key and IV for first package */
+/** CNcomment: CIPHER IV*/
+#define CIPHER_IV_CHANGE_ONE_PKG          (1)
+
+/** CIPHER set key and IV for all package */
+/** CNcomment: CIPHER IV*/
+#define CIPHER_IV_CHANGE_ALL_PKG          (2)
+
+/** CIPHER only update IV for first package, don't update the key*/
+/** CNcomment: CIPHER IV */
+#define CIPHER_IV_CHANGE_ONE_PKG_IV_ONLY  (3)
+
+
+/** Cipher work mode */
+/** CNcomment:CIPHER */
+typedef enum hiHI_UNF_CIPHER_WORK_MODE_E
+{
+    HI_UNF_CIPHER_WORK_MODE_ECB,        /**<Electronic codebook (ECB) mode, ECB has been considered insecure and it is recommended not to use it.*/    /**< CNcomment:ECB,ECB*/
+    HI_UNF_CIPHER_WORK_MODE_CBC,        /**<Cipher block chaining (CBC) mode*/  /**< CNcomment:CBC */
+    HI_UNF_CIPHER_WORK_MODE_CFB,        /**<Cipher feedback (CFB) mode*/        /**< CNcomment:CFB */
+    HI_UNF_CIPHER_WORK_MODE_OFB,        /**<Output feedback (OFB) mode*/        /**< CNcomment:OFB */
+    HI_UNF_CIPHER_WORK_MODE_CTR,        /**<Counter (CTR) mode*/                /**< CNcomment:CTR */
+    HI_UNF_CIPHER_WORK_MODE_CCM,        /**<Counter (CCM) mode*/                /**< CNcomment:CCM */
+    HI_UNF_CIPHER_WORK_MODE_GCM,        /**<Counter (GCM) mode*/                /**< CNcomment:GCM */
+    HI_UNF_CIPHER_WORK_MODE_BUTT
+}HI_UNF_CIPHER_WORK_MODE_E;
+
+/** Cipher algorithm */
+/** CNcomment:CIPHER */
+typedef enum hiHI_UNF_CIPHER_ALG_E
+{
+    HI_UNF_CIPHER_ALG_DES           = 0x0,  /**< Data encryption standard (DES) algorithm,DES has been considered insecure and it is recommended not to use it. */     /**< CNcomment: DES*/
+    HI_UNF_CIPHER_ALG_3DES          = 0x1,  /**< 3DES algorithm */                               /**< CNcomment: 3DES */
+    HI_UNF_CIPHER_ALG_AES           = 0x2,  /**< Advanced encryption standard (AES) algorithm */ /**< CNcomment: AES */
+    HI_UNF_CIPHER_ALG_SM1           = 0x3,  /**<SM1 algorithm*/  /**< CNcomment: SM1 */
+    HI_UNF_CIPHER_ALG_SM4           = 0x4,  /**<SM4 algorithm*/  /**< CNcomment: SM4 */
+    HI_UNF_CIPHER_ALG_DMA           = 0x5,  /**<DMA copy*/  /**< CNcomment: DMA */
+    HI_UNF_CIPHER_ALG_BUTT          = 0x6
+}HI_UNF_CIPHER_ALG_E;
+
+/** Key length */
+/** CNcomment:  */
+typedef enum hiHI_UNF_CIPHER_KEY_LENGTH_E
+{
+    HI_UNF_CIPHER_KEY_AES_128BIT    = 0x0,  /**< 128-bit key for the AES algorithm */ /**< CNcomment:AES128bit */
+    HI_UNF_CIPHER_KEY_AES_192BIT    = 0x1,  /**< 192-bit key for the AES algorithm */ /**< CNcomment:AES192bit */
+    HI_UNF_CIPHER_KEY_AES_256BIT    = 0x2,  /**< 256-bit key for the AES algorithm */ /**< CNcomment:AES256bit */
+    HI_UNF_CIPHER_KEY_DES_3KEY      = 0x2,  /**< Three keys for the DES algorithm */  /**< CNcomment:DES3key */
+    HI_UNF_CIPHER_KEY_DES_2KEY      = 0x3,  /**< Two keys for the DES algorithm */    /**< CNcomment: DES2key  */
+    HI_UNF_CIPHER_KEY_DEFAULT       = 0x0,  /**< default key length, DES-8, SM1-48, SM4-16 */    /**< CNcomment: KeyDES-8, SM1-48, SM4-16*/
+}HI_UNF_CIPHER_KEY_LENGTH_E;
+
+/** Cipher bit width */
+/** CNcomment:  */
+typedef enum hiHI_UNF_CIPHER_BIT_WIDTH_E
+{
+    HI_UNF_CIPHER_BIT_WIDTH_64BIT   = 0x0,  /**< 64-bit width */   /**< CNcomment:64bit */
+    HI_UNF_CIPHER_BIT_WIDTH_8BIT    = 0x1,  /**< 8-bit width */    /**< CNcomment:8bit */
+    HI_UNF_CIPHER_BIT_WIDTH_1BIT    = 0x2,  /**< 1-bit width */    /**< CNcomment:1bit */
+    HI_UNF_CIPHER_BIT_WIDTH_128BIT  = 0x3,  /**< 128-bit width */  /**< CNcomment:128bit */
+}HI_UNF_CIPHER_BIT_WIDTH_E;
+
+/** Cipher control parameters */
+/** CNcomment: */
+typedef struct hiUNF_CIPHER_CTRL_CHANGE_FLAG_S
+{
+    HI_U32   bit1IV:4;              /**< Initial Vector change flag, 0-don't set, 1-set IV for first package, 2-set IV for each package  */ /**< CNcomment:, 0-1-2- */
+    HI_U32   bitsResv:28;           /**< Reserved */                     /**< CNcomment: */
+}HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S;
+
+/** Key ladder selecting parameters */
+/** CNcomment:key ladder */
+typedef enum hiUNF_CIPHER_CA_TYPE_E
+{
+    HI_UNF_CIPHER_CA_TYPE_R2R   = 0x0,      /**< Using R2R key ladder */                                                 /**< CNcomment:R2R key ladder */
+    HI_UNF_CIPHER_CA_TYPE_SP,               /**< Using SP key ladder */                                                  /**< CNcomment:SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA2,             /**< Using CSA2 key ladder */                                                /**< CNcomment:CSA2 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA3,             /**< Using CSA3 key ladder */                                                /**< CNcomment:CSA3 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_MISC,             /**< Using MISC ladder */                                                    /**< CNcomment:SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_GDRM,             /**< Using GDRM ladder */                                                    /**< CNcomment:GDRM key ladder */
+    HI_UNF_CIPHER_CA_TYPE_BLPK,             /**< Using BLPK ladder */                                                    /**< CNcomment:BLPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_LPK,              /**< Using LPK ladder */                                                     /**< CNcomment:LPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_IRDETO_HCA,       /**< Using high level code authentication key ladder*/                       /**< CNcomment:keyladder*/
+    HI_UNF_CIPHER_CA_TYPE_STBROOTKEY,       /**< Using for AntiCopy With STB_Root_Key  */                                /**< CNcomment:STB_Root_Key, */
+    HI_UNF_CIPHER_CA_TYPE_SECSTORE,         /**< Using SECSTORE keyladder */                                             /**< CNcomment:SecStore key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CLEARCW,          /**< Using Clear keyladder */                                                /**< CNcomment: key ladder */
+    HI_UNF_CIPHER_CA_TYPE_OTHER,            /**< Using Other keyladder */                                                /**< CNcomment: key ladder */
+    HI_UNF_CIPHER_CA_TYPE_BUTT
+}HI_UNF_CIPHER_CA_TYPE_E;
+
+/** Encryption/Decryption type selecting */
+/** CNcomment:CIPHER */
+typedef enum
+{
+    HI_UNF_CIPHER_TYPE_NORMAL       = 0x0,  /**< Create normal channel */                                                /**< CNcomment:  */
+    HI_UNF_CIPHER_TYPE_COPY_AVOID,          /**< Create special channel for avoid copy */                                /**< CNcomment:  */
+    HI_UNF_CIPHER_TYPE_NONSEC,              /**< Create unsecured channel, for internal use only */                      /**< CNcomment:  */
+    HI_UNF_CIPHER_TYPE_BUTT,
+}HI_UNF_CIPHER_TYPE_E;
+
+/** Structure of the cipher type */
+/** CNcomment: */
+typedef struct
+{
+    HI_UNF_CIPHER_TYPE_E enCipherType;
+}HI_UNF_CIPHER_ATTS_S;
+
+/** sm1 round config */
+/** CNcomment: sm1 */
+typedef enum hiHI_UNF_CIPHER_SM1_ROUND_E
+{
+    HI_UNF_CIPHER_SM1_ROUND_08 = 0x00,          /**< sm1 round 08 */ /**< CNcomment:SM108 */
+    HI_UNF_CIPHER_SM1_ROUND_10 = 0x01,          /**< sm1 round 10 */ /**< CNcomment:SM110 */
+    HI_UNF_CIPHER_SM1_ROUND_12 = 0x02,          /**< sm1 round 12 */ /**< CNcomment:SM112 */
+    HI_UNF_CIPHER_SM1_ROUND_14 = 0x03,          /**< sm1 round 14 */ /**< CNcomment:SM114 */
+    HI_UNF_CIPHER_SM1_ROUND_BUTT,
+}HI_UNF_CIPHER_SM1_ROUND_E;
+
+/** Structure of the cipher control information */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_CTRL_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:CAKey */
+    HI_UNF_CIPHER_CA_TYPE_E enCaType;                   /**< Select keyladder type when using advanced CA */                                                                  /**< CNcomment:CA,keyladder */
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_S;
+
+/** Structure of the cipher AES control information */
+/** CNcomment:AES */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_S
+{
+    HI_U32 u32EvenKey[8];                           /**< Key input, default use this key*/                                                                                /**< CNcomment:,  */
+    HI_U32 u32OddKey[8];                            /**< Key input, only valid for Multi encrypt/decrypt*/                                                                /**< CNcomment:,  */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_AES_S;
+
+/** Structure of the cipher AES CCM/GCM control information */
+/** CNcomment:AES CCM/GCM  */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_CCM_GCM_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_U32 u32IVLen;                                /**< IV lenght for CCM/GCM, which is an element of {7, 8, 9, 10, 11, 12, 13} for CCM, and is an element of [1-16] for GCM*/  /**< CNcomment: CCM/GCMIVCCM{7, 8, 9, 10, 11, 12, 13} GCM[1-16]*/
+    HI_U32 u32TagLen;                               /**< Tag lenght for CCM which is an element of {4,6,8,10,12,14,16}*/          /**< CNcomment: CCMTAG{4,6,8,10,12,14,16}*/
+    HI_U32 u32ALen;                                 /**< Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM*/
+    HI_U32 u32APhyAddr;                             /**< Physical address of Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM*/
+} HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+
+/** Structure of the cipher DES control information */
+/** CNcomment:DES */
+typedef struct hiHI_UNF_CIPHER_CTRL_DES_S
+{
+    HI_U32 u32Key[2];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_DES_S;
+
+/** Structure of the cipher 3DES control information */
+/** CNcomment:3DES */
+typedef struct hiHI_UNF_CIPHER_CTRL_3DES_S
+{
+    HI_U32 u32Key[6];                               /**< Key input */                                                                                                     /**< CNcomment: */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_3DES_S;
+
+/** Structure of the cipher SM1 control information */
+/** CNcomment:SM1 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM1_S
+{
+    HI_U32 u32EK[4];                               /**< Key of EK input */                                                                                                /**< CNcomment:EK */
+    HI_U32 u32AK[4];                               /**< Key of AK input */                                                                                                /**< CNcomment:AK */
+    HI_U32 u32SK[4];                               /**< Key of SK input */                                                                                                /**< CNcomment:SK */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment: */
+    HI_UNF_CIPHER_SM1_ROUND_E enSm1Round;           /**< SM1 round number, should be 8, 10, 12 or 14*/                                                                                                    /**< CNcomment:sm1 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_SM1_S;
+
+/** Structure of the cipher SM4 control information */
+/** CNcomment:SM4 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM4_S
+{
+    HI_U32 u32Key[4];                               /**< Key  input */                                                                                                    /**< CNcomment: */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment: */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment: */
+} HI_UNF_CIPHER_CTRL_SM4_S;
+
+/** Expand Structure of the cipher control information */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_CTRL_EX_S
+{
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment: */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment: */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:CAKey */
+    /**< Parameter for special algorithm
+        for AES, the pointer should point to HI_UNF_CIPHER_CTRL_AES_S;
+        for AES_CCM or AES_GCM, the pointer should point to HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+        for DES, the pointer should point to HI_UNF_CIPHER_CTRL_DES_S;
+        for 3DES, the pointer should point to HI_UNF_CIPHER_CTRL_3DES_S;
+        for SM1, the pointer should point to HI_UNF_CIPHER_CTRL_SM1_S;
+        for SM4, the pointer should point to HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    /**< CNcomment: 
+         AES,  HI_UNF_CIPHER_CTRL_AES_S;
+         AES_CCM  AES_GCM,  HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+         DES,  HI_UNF_CIPHER_CTRL_DES_S;
+         3DES,  HI_UNF_CIPHER_CTRL_3DES_S;
+         SM1,  HI_UNF_CIPHER_CTRL_SM1_S;
+         SM4,  HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    HI_VOID *pParam;
+} HI_UNF_CIPHER_CTRL_EX_S;
+
+/** Cipher data */
+/** CNcomment: */
+typedef struct hiHI_UNF_CIPHER_DATA_S
+{
+    HI_U32 u32SrcPhyAddr;     /**< phy address of the original data */   /**< CNcomment: */
+    HI_U32 u32DestPhyAddr;    /**< phy address of the purpose data */    /**< CNcomment: */
+    HI_U32 u32ByteLength;     /**< cigher data length*/                 /**< CNcomment: */
+    HI_BOOL bOddKey;    /**< Use odd key or even key*/                  /**< CNcomment: */
+} HI_UNF_CIPHER_DATA_S;
+
+/** Hash algrithm type */
+/** CNcomment: */
+typedef enum hiHI_UNF_CIPHER_HASH_TYPE_E
+{
+    HI_UNF_CIPHER_HASH_TYPE_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_IRDETO_CBCMAC,
+    HI_UNF_CIPHER_HASH_TYPE_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_SM3,
+    HI_UNF_CIPHER_HASH_TYPE_BUTT,
+}HI_UNF_CIPHER_HASH_TYPE_E;
+
+/** Hash init struct input */
+/** CNcomment: */
+typedef struct
+{
+    HI_U8 *pu8HMACKey;
+    HI_U32 u32HMACKeyLen;
+    HI_UNF_CIPHER_HASH_TYPE_E eShaType;
+}HI_UNF_CIPHER_HASH_ATTS_S;
+
+typedef enum hiHI_UNF_CIPHER_RSA_ENC_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_NO_PADDING,            /**< without padding */             /**< CNcomment:  */
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_0,          /**< PKCS#1 block type 0 padding*/  /**< CNcomment: PKCS#1block type 0*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_1,          /**< PKCS#1 block type 1 padding*/  /**< CNcomment: PKCS#1block type 1*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_2,          /**< PKCS#1 block type 2 padding*/  /**< CNcomment: PKCS#1block type 2*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA1,       /**< PKCS#1 RSAES-OAEP-SHA1 padding*/    /**< CNcomment: PKCS#1RSAES-OAEP-SHA1*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA224,     /**< PKCS#1 RSAES-OAEP-SHA224 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA224*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA256,     /**< PKCS#1 RSAES-OAEP-SHA256 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA256*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA384,     /**< PKCS#1 RSAES-OAEP-SHA384 padding*/    /**< CNcomment: PKCS#1RSAES-OAEP-SHA384*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA512,     /**< PKCS#1 RSAES-OAEP-SHA512 padding*/  /**< CNcomment: PKCS#1RSAES-OAEP-SHA512*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_PKCS1_V1_5,      /**< PKCS#1 RSAES-PKCS1_V1_5 padding*/   /**< CNcomment: PKCS#1PKCS1_V1_5*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_ENC_SCHEME_E;
+
+typedef enum hiHI_UNF_CIPHER_RSA_SIGN_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1 = 0x100, /**< PKCS#1 RSASSA_PKCS1_V15_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA1*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA224*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA256*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA384 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA384*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA512 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA512*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1,         /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA1*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA224*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA256*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA384*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA512*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_SIGN_SCHEME_E;
+
+typedef struct
+{
+    HI_U8  *pu8N;              /**< point to public modulus  */   /**< CNcomment: RSAN*/
+    HI_U8  *pu8E;              /**< point to public exponent */   /**< CNcomment: RSAE*/
+    HI_U16 u16NLen;            /**< length of public modulus, max value is 512Byte*/  /**< CNcomment: RSAN, 512Byte*/
+    HI_U16 u16ELen;            /**< length of public exponent, max value is 512Byte*/  /**< CNcomment: RSAE, 512Byte*/
+}HI_UNF_CIPHER_RSA_PUB_KEY_S;
+
+/** RSA private key struct */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_U8 *pu8N;                      /*!<  public modulus    */ /**< CNcomment: RSAN*/
+    HI_U8 *pu8E;                      /*!<  public exponent   */ /**< CNcomment: RSAE*/
+    HI_U8 *pu8D;                      /*!<  private exponent  */ /**< CNcomment: RSAD*/
+    HI_U8 *pu8P;                      /*!<  1st prime factor  */ /**< CNcomment: RSAP*/
+    HI_U8 *pu8Q;                      /*!<  2nd prime factor  */ /**< CNcomment: RSAQ*/
+    HI_U8 *pu8DP;                     /*!<  D % (P - 1)       */ /**< CNcomment: RSADP*/
+    HI_U8 *pu8DQ;                     /*!<  D % (Q - 1)       */ /**< CNcomment: RSADQ*/
+    HI_U8 *pu8QP;                     /*!<  1 / (Q % P)       */ /**< CNcomment: RSAQP*/
+    HI_U16 u16NLen;                   /**< length of public modulus */   /**< CNcomment: RSAN*/
+    HI_U16 u16ELen;                   /**< length of public exponent */  /**< CNcomment: RSAE*/
+    HI_U16 u16DLen;                   /**< length of private exponent */ /**< CNcomment: RSAD*/
+    HI_U16 u16PLen;                   /**< length of 1st prime factor,should be half of u16NLen */ /**< CNcomment: RSAPu16NLen1/2*/
+    HI_U16 u16QLen;                   /**< length of 2nd prime factor,should be half of u16NLen */ /**< CNcomment: RSAQu16NLen1/2*/
+    HI_U16 u16DPLen;                  /**< length of D % (P - 1),should be half of u16NLen */      /**< CNcomment: RSADPu16NLen1/2*/
+    HI_U16 u16DQLen;                  /**< length of D % (Q - 1),should be half of u16NLen */      /**< CNcomment: RSADQu16NLen1/2*/
+    HI_U16 u16QPLen;                  /**< length of 1 / (Q % P),should be half of u16NLen */      /**< CNcomment: RSAQPu16NLen1/2*/
+}HI_UNF_CIPHER_RSA_PRI_KEY_S;
+
+/** RSA public key encryption struct input */
+/** CNcomment:RSA  */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme;   /** RSA encryption scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;      /** RSA private key struct */ /** CNcomment:RSA */
+}HI_UNF_CIPHER_RSA_PUB_ENC_S;
+
+/** RSA private key decryption struct input */
+/** CNcomment:RSA  */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme; /** RSA encryption scheme */ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;    /** RSA private key struct */ /** CNcomment:RSA */
+}HI_UNF_CIPHER_RSA_PRI_ENC_S;
+
+/** RSA signature struct input */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme;  /** RSA signature scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;      /** RSA private key struct */ /** CNcomment:RSA */
+ }HI_UNF_CIPHER_RSA_SIGN_S;
+
+/** RSA signature verify struct input */
+/** CNcomment:RSA */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme; /** RSA signature scheme*/ /** CNcomment:RSA*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;     /** RSA public key struct */ /** CNcomment:RSA */
+ }HI_UNF_CIPHER_RSA_VERIFY_S;
+
+ /** SM2 signature struct input */
+/** CNcomment: SM2 */
+ typedef struct hiHI_UNF_CIPHER_SM2_SIGN_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_SIGN_S;
+
+/** SM2 signature verify struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_VERIFY_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_VERIFY_S;
+
+/** SM2 publuc key encryption struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_ENC_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_ENC_S;
+
+/** SM2 private key decryption struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_DEC_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_DEC_S;
+
+/** SM2 key generate struct input */
+/** CNcomment: SM2 */
+typedef struct hiHI_UNF_CIPHER_SM2_KEY_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_KEY_S;
+
+/** Elliptic curve domain parameters. */
+/** CNcomment: ECC */
+typedef struct
+{
+  HI_U8 *pu8p; /** Finite field: equal to p in case of prime field curves or equal to 2^n in case of binary field curves.*/
+  HI_U8 *pu8a; /** Curve parameter a (q-3 in Suite B).*/
+  HI_U8 *pu8b; /** Curve parameter b*/
+  HI_U8 *pu8GX;/** X coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8GY;/** Y coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8n; /** Prime which is the order of G point.*/
+  HI_U32 u32h; /**<  Cofactor, which is the order of the elliptic curve divided by the order of the point G. For the Suite B curves, h = 1.*/
+  HI_U32 u32keySize; /**<  Key size in bytes. It corresponds to the size in bytes of the prime pu8n*/
+} HI_UNF_CIPHER_ECC_PARAM_S;
+
+/** CENC subsample struct input */
+/** CNcomment: CENC subsample  */
+typedef struct hiHI_UNF_CIPHER_SUBSAMPLE_S
+{
+    HI_U32 u32ClearHeaderLen;
+    HI_U32 u32PayLoadLen;
+    HI_U32 u32PayloadPatternEncryptLen;
+    HI_U32 u32PayloadPatternClearLen;
+    HI_U32 u32PayloadPatternOffsetLen;
+}HI_UNF_CIPHER_SUBSAMPLE_S;
+
+typedef struct hiHI_UNF_CIPHER_SUBSAMPLE_EX_S
+{
+    HI_U32 u32ClearHeaderLen;
+    HI_U32 u32PayLoadLen;
+    HI_U32 u32PayloadPatternEncryptLen;
+    HI_U32 u32PayloadPatternClearLen;
+    HI_U32 u32PayloadPatternOffsetLen;
+    HI_U32 u32IvChange;
+    HI_U32 u32IV[4];
+}HI_UNF_CIPHER_SUBSAMPLE_EX_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define HI_UNF_CIPHER_Open(HI_VOID)    HI_UNF_CIPHER_Init(HI_VOID);
+#define HI_UNF_CIPHER_Close(HI_VOID)   HI_UNF_CIPHER_DeInit(HI_VOID);
+#define HI_UNF_CIPHER_HASH_TYPE_CBCMAC HI_UNF_CIPHER_HASH_TYPE_IRDETO_CBCMAC
+#define HI_UNF_CIPHER_CA_TYPE_HCA      HI_UNF_CIPHER_CA_TYPE_IRDETO_HCA
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+/* ---CIPHER---*/
+/**
+\brief  Init the cipher device.  CNcomment:CIPHER CNend
+\attention \n
+This API is used to start the cipher device.
+CNcomment:CIPHER CNend
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_FAILED_INIT  The cipher device fails to be initialized. CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Init(HI_VOID);
+
+
+/**
+\brief  Deinit the cipher device.
+CNcomment:\brief  CIPHER CNend
+\attention \n
+This API is used to stop the cipher device. If this API is called repeatedly, HI_SUCCESS is returned, but only the first operation takes effect.
+CNcomment:CIPHER CNend
+
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DeInit(HI_VOID);
+
+
+/**
+\brief Obtain a cipher handle for encryption and decryption.
+CNcommentCipher CNend
+
+\param[in] cipher attributes                                                    CNcomment:cipher  CNend
+\param[out] phCipher Cipher handle                                              CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment: API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_FAILED_GETHANDLE  The cipher handle fails to be obtained, because there are no available cipher handles. CNcomment: CIPHERCIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CreateHandle(HI_HANDLE* phCipher, const HI_UNF_CIPHER_ATTS_S *pstCipherAttr);
+
+
+/**
+\brief Destroy the existing cipher handle. CNcomment:CIPHER CNend
+\attention \n
+This API is used to destroy existing cipher handles.
+CNcomment:CIPHER CNend
+
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DestroyHandle(HI_HANDLE hCipher);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief CIPHER CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandleEx to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB mode.
+CNcomment:HI_UNF_CIPHER_ConfigHandleExCIPHER
+TDES64 bit
+ AES/DES/3DES/SM4 , ECB/CBC/CTR/OFB/CFB .CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] pstCtrl Cipher control information.                                  CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandle(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_S* pstCtrl);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief CIPHER CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandle to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM1/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB/CCM/GCM mode.
+CNcomment:HI_UNF_CIPHER_ConfigHandleCIPHER
+TDES64 bit
+ AES/DES/3DES/SM1/SM4 , ECB/CBC/CTR/OFB/CFB/CCM/GCM .CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] pstExCtrl Cipher control information.                                CNcomment:CIPHER CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandleEx(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_EX_S* pstExCtrl);
+
+
+/**
+\brief Performs encryption.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to perform encryption by using the cipher module.
+The length of the encrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:CIPHERTDES8AES160xFFFFFHI_UNF_CIPHER_ConfigHandleIV(pstCtrl->stChangeFlags.bit1IV1) CNend
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER CNend
+\param[in] u32SrcPhyAddr Physical address of the source data                    CNcomment: CNend
+\param[in] u32DestPhyAddr Physical address of the target data                   CNcomment: CNend
+\param[in] u32ByteLength   Length of the encrypted data                         CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Encrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Performs decryption.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to perform decryption by using the cipher module.
+The length of the decrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:CIPHERTDES8AES160xFFFFFHI_UNF_CIPHER_ConfigHandleIV(pstCtrl->stChangeFlags.bit1IV1) CNend
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER CNend
+\param[in] u32SrcPhyAddr Physical address of the source data.                   CNcomment: CNend
+\param[in] u32DestPhyAddr Physical address of the target data.                  CNcomment: CNend
+\param[in] u32ByteLength Length of the decrypted data                           CNcomment: CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Decrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Encrypt multiple packaged data.
+CNcomment:\brief  CNend
+\attention \n
+You can not encrypt more than 128 data package one time. When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When encrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:128HI_ERR_CIPHER_BUSY: HI_UNF_CIPHER_ConfigHandle CNend
+\param[in] hCipher cipher handle                                                                  CNcomment:CIPHER CNend
+\param[in] pstDataPkg data package ready for cipher                                               CNcomment: CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                   CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                        CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                             CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                            CNcomment: CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EncryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Decrypt multiple packaged data.
+CNcomment:\brief  CNend
+\attention \n
+You can not decrypt more than 128 data package one time.When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When decrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:128HI_ERR_CIPHER_BUSY: HI_UNF_CIPHER_ConfigHandle CNend
+\param[in] hCipher cipher handle                                                                 CNcomment:CIPHER CNend
+\param[in] pstDataPkg data package ready for cipher                                              CNcomment: CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                     CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                  CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                       CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                        CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                            CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                           CNcomment: CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DecryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Get the tag data of CCM/GCM.
+CNcomment:\brief CCM/GCMTAG CNend
+
+\attention \n
+This API is used to get the tag data of CCM/GCM.
+\param[in] hCipher cipher handle                                                CNcomment:CIPHER CNend
+\param[out] pu8Tag tag data of CCM/GCM                                          CNcomment:TAG CNend
+\param[in/out] pu32TagLen tag data length of CCM/GCM, the input should be 16 now. CNcomment:TAG16 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetTag(HI_HANDLE hCipher, HI_U8 *pu8Tag, HI_U32 *pu32TagLen);
+
+
+/**
+\brief Get the random number.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+CNcomment: CNend
+
+\param[out] pu32RandomNumber Point to the random number.                                        CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetRandomNumber(HI_U32 *pu32RandomNumber);
+
+/**
+\brief Get the random bytes.
+CNcomment:\brief  CNend
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+CNcomment: CNend
+
+\param[out] pu32RandomNumber Point to the random number.                                        CNcomment: CNend
+\param[in]  u32Bytes size of the random bytes.                                                  CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetMultiRandomBytes(HI_U8 *pu8RandomByte, HI_U32 u32Bytes);
+
+/**
+\brief Get the AES CBC-MAC value.
+CNcomment:\brief AES CBC-MAC CNend
+
+\attention \n
+This API is used to obtain the AES CBC-MAC value.
+CNcomment:AES CBC-MAC CNend
+\param[in] hCipherHandle:  The cipher handle.                                                   CNcomment:Cipher CNend
+\param[in] pInputData: input data.                                                              CNcomment: CNend
+\param[in] u32InputDataLen: input data length,the length should be multiple of 16 bytes if it is not the last block. CNcomment:block16byte CNend
+\param[in] bIsLastBlock: Whether this block is last block or not.                               CNcomment:block CNend
+\param[out] pOutputMAC: output CBC-MAC value,the length of pOutputMAC should be 16.             CNcomment:CBC-MAC   16CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CalcMAC(HI_HANDLE hCipherHandle, HI_U8 *pInputData, HI_U32 u32InputDataLen,
+                                        HI_U8 *pOutputMAC, HI_BOOL bIsLastBlock);
+
+
+/**
+\brief Init the hash module, if other program is using the hash module, the API will return failure.
+CNcomment:\brief HASHHASH CNend
+
+\attention \n
+N/A
+
+\param[in] pstHashAttr: The hash calculating structure input.                                      CNcomment:hash CNend
+\param[out] pHashHandle: The output hash handle.                                                CNcomment:hash CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashInit(HI_UNF_CIPHER_HASH_ATTS_S *pstHashAttr, HI_HANDLE *pHashHandle);
+
+
+/**
+\brief Calculate the hash, if the size of the data to be calculated is very big and the DDR ram is not enough, this API can calculate the data one block by one block. Attention: The input block length must be 64bytes alingned except for the last block.
+CNcomment:\brief hashblockblock block64CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandl:  Hash handle.                                        CNcomment:Hash CNend
+\param[in] pu8InputData:  The input data buffer.                            CNcomment: CNend
+\param[in] u32InputDataLen:  The input data length, attention: the block length input must be 64bytes aligned except the last block!            CNcomment: 64block CNend
+\retval ::HI_SUCCESS  Call this API successful.                             CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                  CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashUpdate(HI_HANDLE hHashHandle, HI_U8 *pu8InputData, HI_U32 u32InputDataLen);
+
+
+/**
+\brief Get the final hash value, after calculate all of the data, call this API to get the final hash value and close the handle.If there is some reason need to interupt the calculation, this API should also be call to close the handle.
+CNcomment:hashhashhashhash CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandle:  Hash handle.                                       CNcomment:Hash  CNend
+\param[out] pu8OutputHash:  The final output hash valueand its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.
+CNcomment:hashhashsha120sha22428sha256sm332sha38448sha51264 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                             CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                  CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashFinal(HI_HANDLE hHashHandle, HI_U8 *pu8OutputHash);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA public key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaEnc:   encryption struct.                                   CNcomment: CNend
+\param[in] pu8Input   input data to be encryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8Output output data to be encryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicEncrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaEnc,
+                                  HI_U8 *pu8Input, HI_U32 u32InLen,
+                                  HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaDec:   decryption struct.                                   CNcomment:  CNend
+\param[in] pu8Input   input data to be decryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Output output data to be decryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateDecrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaDec,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:   encryption struct.                                  CNcomment: CNend
+\param[in] pu8Input   input data to be encryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8Output output data to be encryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateEncrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaEnc,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA public key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:   decryption struct.                                CNcomment:  CNend
+\param[in] pu8Input   input data to be decryption                          CNcomment:  CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Output output data to be decryption                         CNcomment:  CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicDecrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaDec,
+                               HI_U8 *pu8Input, HI_U32 u32InLen,
+                               HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA signature a context with appendix, where a signers RSA private key is used.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:      signature struct.                                    CNcomment:  CNend
+\param[in] pu8Input       input context to be signaturemaybe null            CNcomment: , pu8HashData CNend
+\param[in] u32InLen:        length of input context to be signature              CNcomment:  CNend
+\param[in] pu8HashData    hash value of context,if NULL, let pu8HashData = Hash(context) automatically,its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.  Ncomment: HASH
+CNcomment:hashhashsha120sha22428sha256sm332sha38448sha51264HASH CNend
+\param[out] pu8OutSign    output message of signature                          CNcomment:  CNend
+\param[out] pu32OutSignLen: length of message of signature                       CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaSign(HI_UNF_CIPHER_RSA_SIGN_S *pstRsaSign,
+                             HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                             HI_U8 *pu8HashData,
+                             HI_U8 *pu8OutSign, HI_U32 *pu32OutSignLen);
+
+
+/**
+\brief RSA signature verification a context with appendix, where a signers RSA public key is used.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:    signature verification struct.                         CNcomment:  CNend
+\param[in] pu8Input       input context to be signature verificationmaybe null CNcomment: , pu8HashData CNend
+\param[in] u32InLen:        length of input context to be signature                CNcomment:  CNend
+\param[in] pu8HashData    hash value of context,if NULL, let pu8HashData = Hash(context) automatically,its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.  Ncomment: HASH
+CNcomment:hashhashsha120sha22428sha256sm332sha38448sha51264   Ncomment: HASHHASH CNend
+\param[in] pu8InSign      message of signature                                 CNcomment:  CNend
+\param[in] pu32InSignLen:   length of message of signature                       CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaVerify(HI_UNF_CIPHER_RSA_VERIFY_S *pstRsaVerify,
+                               HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                               HI_U8 *pu8HashData,
+                               HI_U8 *pu8InSign, HI_U32 u32InSignLen);
+
+/**
+\brief Generate a RSA private key.
+CNcomment:RSA CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits: bit numbers of the integer public modulus. CNcomment: RSAN CNend
+\param[in] u32Exponent: value of public exponent. CNcomment: RSAE CNend
+\param[out] ptRsaPriKey: private key struct. CNcomment: RSA CNend
+
+\retval ::HI_SUCCESS Call this API succussful. CNcomment:API CNend
+\retval ::HI_FAILURE Call this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaGenKey(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_UNF_CIPHER_RSA_PRI_KEY_S *pstRsaPriKey);
+
+/**
+\brief Computes CRT parameters dP, dQ and qInv from the two primes p and q and the public exponent e.
+CNcomment: pqCRTdP, dQ  qInv  CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits:     bit numbers of the integer public modulus.  CNcomment: RSAN CNend
+\param[in] u32Exponent:    value of public exponent.                   CNcomment: RSAE CNend
+\param[in] pu8P Buffer containing the prime number p used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTpu32NumBits/2. CNend
+\param[in] pu8Q Buffer containing the prime number q used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTqu32NumBits/2. CNend
+\param[out] pu8DP Buffer where to store the CRT exponent dP computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTdPu32NumBits/2. CNend
+\param[out] pu8DQ Buffer where to store the CRT exponent dQ computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTdQu32NumBits/2. CNend
+\param[out] pu8QP Buffer where to store the CRT exponent qInv computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRTqInvu32NumBits/2. CNend
+
+\param[out] ptRsaPriKey:   private key struct.                         CNcomment: RSA CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaComputeCrtParams(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_U8 *pu8P,
+                               HI_U8 *pu8Q, HI_U8 *pu8DP, HI_U8 *pu8DQ, HI_U8 *pu8QP);
+
+
+/**
+\brief SM2 signature a context with appendix, where a signers SM2 private key is used.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Sign:      signature struct.                                    CNcomment:  CNend
+\param[in] pu8Msg:          input context to be signaturemaybe null            CNcomment: , pu8HashData CNend
+\param[in] u32MsgLen:       length of input context to be signature              CNcomment:  CNend
+\param[out] pu8R           The R value of the signature result,its length is 32.CNcomment: R32 CNend
+\param[out] pu8S:           The S value of the signature result,its length is 32.CNcomment: S32 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Sign(HI_UNF_CIPHER_SM2_SIGN_S *pstSm2Sign, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 signature verification a context with appendix, where a signers SM2 public key is used.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Verify:    signature verification struct.                         CNcomment:  CNend
+\param[in] pu8Msg          input context to be signature verificationmaybe null CNcomment: , pu8HashData CNend
+\param[in] u32MsgLen:       length of input context to be signature                CNcomment:  CNend
+\param[in] pu8R            The R value of the signature result,its length is 32.  CNcomment: R32 CNend
+\param[in] pu8S:            The S value of the signature result,its length is 32.  CNcomment: S32 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Verify(HI_UNF_CIPHER_SM2_VERIFY_S *pstSm2Verify, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 encryption a plaintext with a RSA public key.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Enc:   encryption struct.                                   CNcomment:  CNend
+\param[in] pu8Msg     input data to be encryption                          CNcomment:  CNend
+\param[in] u32MsgLen:   length of input data to be encryption                CNcomment:  CNend
+\param[out] pu8C      output data to be encryption                         CNcomment:  CNend
+\param[out] pu32Clen:   length of output data to be encryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Encrypt(HI_UNF_CIPHER_SM2_ENC_S *pstSm2Enc,  HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8C, HI_U32 *pu32Clen);
+
+
+/**
+\brief RSA decryption a ciphertext with a SM2 private key.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Dec:   decryption struct.                                   CNcomment:  CNend
+\param[in] pu8C       input data to be decryption                          CNcomment:  CNend
+\param[out] u32Clen:    length of input data to be decryption                CNcomment:  CNend
+\param[out] pu8Msg    output data to be decryption                         CNcomment:  CNend
+\param[out] pu32MsgLen: length of output data to be decryption               CNcomment:  CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Decrypt(HI_UNF_CIPHER_SM2_DEC_S *pstSm2Dec, HI_U8 *pu8C, HI_U32 u32Clen, HI_U8 *pu8Msg, HI_U32 *pu32MsgLen);
+
+
+/**
+\brief Generate a SM2 key pair.
+CNcomment:SM2 CNend
+
+\attention \n
+N/A
+
+\param[out] pstSm2Key:   key pair struct.                               CNcomment: SM2 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2GenKey(HI_UNF_CIPHER_SM2_KEY_S *pstSm2Key);
+
+/**
+\brief CENC decryption a ciphertext.
+CNcomment: CENC CNend
+
+\attention \n
+This API is used to perform decryption ciphertext base on CENC format.
+CNcomment:CIPHERCENC CNend
+\param[in] hCipher Cipher handle                                                   CNcomment:CIPHER CNend
+\param[in] u8Key key for cipher decryption,its length should be 16.                CNcomment:CIPHER ,16. CNend
+\param[in] u8IV  iv for cipher decryption,its length should be 16.                 CNcomment:CIPHER IV ,16.CNend
+\param[in] u32NonSecInputPhyAddr non-secure Physical address of the source data    CNcomment: CNend
+\param[in] u32SecOutputPhyAddr secure Physical address of the target data          CNcomment: CNend
+\param[in] u32ByteLength   Length of the decrypted data                            CNcomment: CNend
+\param[in] u32FirstEncrypt offset of the first encrypt block data                  CNcomment:0~15 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                    CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                         CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.            CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                    CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CENCDecrypt(HI_HANDLE hCipher, HI_U8 *pu8Key, HI_U8 *pu8IV,
+                               HI_U32 u32NonSecInPhyAddr, HI_U32 u32SecOutPhyAddr, HI_U32 u32ByteLength,
+                               HI_U32 u32FirstEncryptOffset,
+                               HI_UNF_CIPHER_SUBSAMPLE_S *pstSubSample, HI_U32 u32SubsampleNum);
+
+/**
+\brief CENC decryption a ciphertext.
+CNcomment: CENC CNend
+
+\attention \n
+This API is used to perform decryption ciphertext base on CENC format.
+CNcomment:CIPHERCENC CNend
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER CNend
+\param[in] u8Key key for cipher decryption,its length should be 16.             CNcomment:CIPHER  CNend
+\param[in] bOddKey use odd key or not                                           CNcomment:CIPHER odd key CNend
+\param[in] u32NonSecInputPhyAddr non-secure Physical address of the source data    CNcomment: CNend
+\param[in] u32SecOutputPhyAddr secure Physical address of the target data          CNcomment: CNend
+\param[in] u32ByteLength   Length of the decrypted data                         CNcomment: CNend
+\param[in] u32FirstEncrypt offset of the first encrypt block data               CNcomment:0~15 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CENCDecryptEx(HI_HANDLE hCipher, HI_U8 *pu8Key, HI_BOOL bOddKey,
+                               HI_U32 u32NonSecInPhyAddr, HI_U32 u32SecOutPhyAddr, HI_U32 u32ByteLength,
+                               HI_U32 u32FirstEncryptOffset,
+                               HI_UNF_CIPHER_SUBSAMPLE_EX_S *pstSubSample, HI_U32 u32SubsampleNum);
+
+/**
+\brief Compute Diffie-Hellman shared secret as otherPubKey^privKey mod p.
+CNcomment: DH CNend
+
+\attention \n
+N/A
+
+\param[in] pu8P:  Buffer containing the DH prime modulus p used for the operation.  CNcomment: DHp. CNend
+\param[in] pu8PrivKey: Buffer containing the DH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: DHKey0 CNend
+\param[in] pu8OtherPubKey: Buffer containing the DH public key of the other peer. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHKey0 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: DHKey0 CNend
+\param[in] u32KeySize: DH key size. CNcomment: DH. CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhComputeKey(HI_U8 * pu8P, HI_U8 *pu8PrivKey, HI_U8 *pu8OtherPubKey,
+                                  HI_U8 *pu8SharedSecret, HI_U32 u32KeySize);
+
+
+/**
+\brief Generate Diffie-Hellman public/private key pair from g and p parameters. The public key is equal to g^x mod p, where x is random number considered as the private key.
+CNcomment: DH CNend
+
+\attention \n
+N/A
+
+\param[in] pu8G: Buffer containing the DH generator g used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHgKey0 CNend
+\param[in] pu8P: Buffer containing the DH generator p used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DHpKey0 CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: DHKey0, pu8OutputPrivKey CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: DHKey0, pu8InputPrivKeybuffer CNend
+\param[in] u32KeySize: DH key size.                       CNcomment: DH. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhGenKey(HI_U8 *pu8G, HI_U8 *pu8P, HI_U8 *pu8InputPrivKey,
+                                   HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKey,
+                                   HI_U32 u32KeySize);
+
+
+/**
+\brief Compute ECDH shared secret key. This key corresponds to the X coordinates of the computed P point.
+CNcomment: ECC DH CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDHKey0 CNend
+\param[in] pu8OtherPubKeyX: Buffer containing the X coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size.  CNcomment: ECDHXKey0 CNend
+\param[in] pu8OtherPubKeyY: Buffer containing the Y coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key Y coordinates is smaller than the buffer size.  CNcomment: ECDHYKey0 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: ECDHKey0 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdhComputeKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                                    HI_U8 *pu8OtherPubKeyX, HI_U8 *pu8OtherPubKeyY,
+                                    HI_U8 *pu8SharedSecret);
+
+
+/**
+\brief Generate ECC public/private key pair.
+CNcomment: ECDH CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: ECCKey0, pu8OutputPrivKey CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: ECCKey0, pu8InputPrivKeybuffer CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCX. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCY. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EccGenKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8InputPrivKey,
+                                    HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY);
+
+
+/**
+\brief Sign a message with ECDSA algorithm and returns an uncompressed signature made of the pair (r, s).
+CNcomment: ECDSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDHKey0 CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH  CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment:  CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment:  CNend
+\param[out] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: R CNend
+\param[out] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: S CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaSign(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                               HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                               HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                               HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/**
+\brief Verify an ECDSA signature made of an uncompressed pair (r, s).
+CNcomment: ECDSA CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECCKey0. CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCX. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECCY. CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH  CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment:  CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment:  CNend
+\param[in] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: R CNend
+\param[in] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: S CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaVerify(HI_UNF_CIPHER_ECC_PARAM_S *pstParams,
+                                 HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY,
+                                 HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                                 HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                                 HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_CIPHER_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_common.h b/xbmc/platform/linux/hisi/hi_unf_common.h
new file mode 100644
index 0000000000..d486d0fdd5
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_common.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_common.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_COMMON_H__
+#define __HI_UNF_COMMON_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Media_Common */
+/** @{ */  /** <!-- [Media_Common] */
+
+/**Defines the stream buffer.*/
+/**CNcomment:  */
+typedef struct hiUNF_STREAM_BUF_S
+{
+    HI_U8   *pu8Data;        /**<Data pointer*/ /**<CNcomment:  */
+    HI_U32  u32Size;         /**<Data size*/ /**<CNcomment:  */
+} HI_UNF_STREAM_BUF_S;
+
+/**Defines the private Es buffer address.*/
+typedef struct hiUNF_BUF_ADDR_S
+{
+        HI_U64 u64BufKerVirAddr;    /**<Es Buffer Kernel Virtual Address*/ /**<CNcomment: Buffer*/
+        HI_U64 u64BufPhyAddr;       /**<Es Buffer Physical Address*/ /**<CNcomment: Buffer*/
+}HI_UNF_BUF_ADDR_S;
+
+/**Defines the structure of the ES buffer.*/
+/**CNcomment: ES */
+typedef struct hiUNF_ES_BUF_S
+{
+    HI_U8 * pu8Buf;    /**<User-state virtual address of the buffer*/ /**<CNcomment: buffer*/
+    HI_U32 u32BufLen;  /**<Buffer length*/ /**<CNcomment: buffer*/
+    HI_U32 u32PtsMs;   /**<Presentation time stamp (PTS) value corresponding to the start of the stream. The invalid value is 0xFFFFFFFF.*/
+                       /**<CNcomment: PTS0xffffffff*/
+    HI_UNF_BUF_ADDR_S   stPriEsBufAddr;  /**<Private Es Buffer Address */ /**<CNcomment: Es buffer */
+}HI_UNF_ES_BUF_S;
+
+/* Crop parameter */
+typedef struct hiUNF_CROP_RECT_S
+{
+    HI_U32 u32LeftOffset;
+    HI_U32 u32TopOffset;
+    HI_U32 u32RightOffset;
+    HI_U32 u32BottomOffset;
+}HI_UNF_CROP_RECT_S;
+
+/**Defines the signal status of the input source.*/
+/**CNcomment:  */
+typedef enum hiUNF_SIG_STATUS_E
+{
+    HI_UNF_SIG_SUPPORT = 0,  /**<Stable signal*/            /**<CNcomment: */
+    HI_UNF_SIG_NO_SIGNAL,    /**<No signal*/                /**<CNcomment: */
+    HI_UNF_SIG_NOT_SUPPORT,  /**<Not support the signal*/   /**<CNcomment: */
+    HI_UNF_SIG_UNSTABLE,     /**<Unstable signal*/          /**<CNcomment: */
+    HI_UNF_SIG_BUTT          /**<Invalid value*/            /**<CNcomment: */
+} HI_UNF_SIG_STATUS_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_COMMON_ H*/
diff --git a/xbmc/platform/linux/hisi/hi_unf_demux.h b/xbmc/platform/linux/hisi/hi_unf_demux.h
new file mode 100644
index 0000000000..7ec59948f5
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_demux.h
@@ -0,0 +1,2238 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_demux.h
+Version       : Initial
+Author        : HiSilicon multimedia software group
+Created       : 2008-06-10
+Last Modified :
+Description   : HiSilicon DEMUX API declaration
+Function List :
+History       :
+* Version   Date         Author                           Defect No.     Description
+* main\1    2008-06-10   Jiang Lei (employee ID: 40671)     NULL         Created this file.
+* main\2    2010-04-02   Jiang Lei (employee ID: 40671)     NULL         modified for HD series.
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the DEMUX module.CNcomment:DEMUX CNend
+ */
+
+#ifndef __HI_UNF_DEMUX_H__
+#define __HI_UNF_DEMUX_H__
+
+#include "hi_unf_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DEMUX */
+/** @{ */  /** <!-- [DEMUX] */
+
+/**Maximum depth of a filter. */
+/**CNcomment:filter*/
+#define DMX_FILTER_MAX_DEPTH            16
+#define DMX_MAX_IDX_ACQUIRED_EACH_TIME  256
+
+/**Defines the capability of the DEMUX module*/
+/**CNcomment:DEMUX*/
+typedef struct hiUNF_DMX_CAPABILITY_S
+{
+    HI_U32 u32IFPortNum;        /**<Number of IF ports. */ /**< CNcomment: IF   (TS In Tuner ,IF  QAM)    */
+    HI_U32 u32TSIPortNum;       /**<Number of TS In ports. */ /**< CNcomment: TS In  (IFTuner ,IF  QAM)    */
+    HI_U32 u32TSOPortNum;       /**<Number of TS Out ports. */ /**< CNcomment: TS Out  */
+    HI_U32 u32RamPortNum;       /**<Number of Ram ports. */ /**< CNcomment: Ram     */
+    HI_U32 u32DmxNum;           /**<Number of DEMUX devices*/ /**< CNcomment:     */
+    HI_U32 u32ChannelNum;       /**<Number of channels, containing the audio and video channels */ /**< CNcomment: */
+    HI_U32 u32AVChannelNum;     /**<Number of av channels*/ /**< CNcomment: */
+    HI_U32 u32FilterNum;        /**<Number of filters*/ /**< CNcomment:   */
+    HI_U32 u32KeyNum;           /**<Number of keys*/ /**< CNcomment:   */
+    HI_U32 u32RecChnNum;        /**<Number of record channels */ /**< CNcomment: */
+    HI_U32 u32TagPortNum;       /**<Number of Tag ports. */ /**< CNcomment: Tag     */
+    HI_U32 u32TsioPortNum;      /**<Number of Tsio ports. */ /**< CNcomment: Tsio     */
+} HI_UNF_DMX_CAPABILITY_S;
+
+/**TSO port ID*/
+/**CNcomment:TSID */
+typedef enum hiUNF_DMX_TSO_PORT_E
+{
+    HI_UNF_DMX_PORT_TSO_0,      /**<The first TS OUT port . */ /**< CNcomment:TS Out 0 */
+    HI_UNF_DMX_PORT_TSO_1,
+    HI_UNF_DMX_PORT_TSO_2,
+    HI_UNF_DMX_PORT_TSO_3
+}HI_UNF_DMX_TSO_PORT_E;
+
+/**TS port ID*/
+/**CNcomment:TSID */
+typedef enum hiUNF_DMX_PORT_E
+{
+    HI_UNF_DMX_PORT_IF_0 = 0x0,  /**<The first IF port (port with  QAM  inside chipset). */ /**< CNcomment: IF 0 , (IF QAM) */
+    HI_UNF_DMX_PORT_IF_1,
+    HI_UNF_DMX_PORT_IF_2,
+    HI_UNF_DMX_PORT_IF_3,
+    HI_UNF_DMX_PORT_IF_4,
+    HI_UNF_DMX_PORT_IF_5,
+    HI_UNF_DMX_PORT_IF_6,
+    HI_UNF_DMX_PORT_IF_7,
+    HI_UNF_DMX_PORT_IF_8,
+    HI_UNF_DMX_PORT_IF_9,
+    HI_UNF_DMX_PORT_IF_10,
+    HI_UNF_DMX_PORT_IF_11,
+    HI_UNF_DMX_PORT_IF_12,
+    HI_UNF_DMX_PORT_IF_13,
+    HI_UNF_DMX_PORT_IF_14,
+    HI_UNF_DMX_PORT_IF_15,
+
+    HI_UNF_DMX_PORT_TSI_0 = 0x20,/**<The first TS IN  port . */ /**< CNcomment:TSIN 0 , (TSIN Tuner ) */
+    HI_UNF_DMX_PORT_TSI_1,
+    HI_UNF_DMX_PORT_TSI_2,
+    HI_UNF_DMX_PORT_TSI_3,
+    HI_UNF_DMX_PORT_TSI_4,
+    HI_UNF_DMX_PORT_TSI_5,
+    HI_UNF_DMX_PORT_TSI_6,
+    HI_UNF_DMX_PORT_TSI_7,
+    HI_UNF_DMX_PORT_TSI_8,
+    HI_UNF_DMX_PORT_TSI_9,
+    HI_UNF_DMX_PORT_TSI_10,
+    HI_UNF_DMX_PORT_TSI_11,
+    HI_UNF_DMX_PORT_TSI_12,
+    HI_UNF_DMX_PORT_TSI_13,
+    HI_UNF_DMX_PORT_TSI_14,
+    HI_UNF_DMX_PORT_TSI_15,
+
+    HI_UNF_DMX_PORT_RAM_0 = 0x80,/**<The first RAM port . */ /**< CNcomment:RAM 0 */
+    HI_UNF_DMX_PORT_RAM_1,
+    HI_UNF_DMX_PORT_RAM_2,
+    HI_UNF_DMX_PORT_RAM_3,
+    HI_UNF_DMX_PORT_RAM_4,
+    HI_UNF_DMX_PORT_RAM_5,
+    HI_UNF_DMX_PORT_RAM_6,
+    HI_UNF_DMX_PORT_RAM_7,
+    HI_UNF_DMX_PORT_RAM_8,
+    HI_UNF_DMX_PORT_RAM_9,
+    HI_UNF_DMX_PORT_RAM_10,
+    HI_UNF_DMX_PORT_RAM_11,
+    HI_UNF_DMX_PORT_RAM_12,
+    HI_UNF_DMX_PORT_RAM_13,
+    HI_UNF_DMX_PORT_RAM_14,
+    HI_UNF_DMX_PORT_RAM_15,
+
+    HI_UNF_DMX_PORT_TSIO_0 = 0xA0,/**<The first TSIO port . */ /**< CNcomment:TSIO 0 */
+    HI_UNF_DMX_PORT_TSIO_1,
+    HI_UNF_DMX_PORT_TSIO_2,
+    HI_UNF_DMX_PORT_TSIO_3,
+    HI_UNF_DMX_PORT_TSIO_4,
+    HI_UNF_DMX_PORT_TSIO_5,
+    HI_UNF_DMX_PORT_TSIO_6,
+    HI_UNF_DMX_PORT_TSIO_7,
+
+    HI_UNF_DMX_PORT_TAG_0 = 0xB0,/**<The first Tag port . */ /**< CNcomment:Tag 0 */
+    HI_UNF_DMX_PORT_TAG_1,
+    HI_UNF_DMX_PORT_TAG_2,
+    HI_UNF_DMX_PORT_TAG_3,
+    HI_UNF_DMX_PORT_TAG_4,
+    HI_UNF_DMX_PORT_TAG_5,
+    HI_UNF_DMX_PORT_TAG_6,
+    HI_UNF_DMX_PORT_TAG_7,
+
+    HI_UNF_DMX_PORT_BUTT
+} HI_UNF_DMX_PORT_E;
+
+
+/**TS port mode*/
+/**CNcomment:TS */
+typedef enum hiUNF_DMX_PORT_MODE_E
+{
+    HI_UNF_DMX_PORT_MODE_EXTERNAL,   /**<External TS input mode*/ /**< CNcomment:TS*/
+    HI_UNF_DMX_PORT_MODE_INTERNAL,   /**<Internal TS input mode*/ /**< CNcomment:TS*/
+    HI_UNF_DMX_PORT_MODE_RAM,        /**<Memory input mode*/ /**< CNcomment:*/
+
+    HI_UNF_DMX_PORT_MODE_BUTT
+} HI_UNF_DMX_PORT_MODE_E;
+
+/**TS port type*/
+/**CNcomment:TS */
+typedef enum hiUNF_DMX_PORT_TYPE_E
+{
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST,          /**<Parallel burst mode*/ /**< CNcomment:BURST             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_VALID,          /**<Parallel valid mode*/ /**< CNcomment:VALID             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_188,     /**<Self-sync 188 mode*/ /**< CNcomment:188             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_204,     /**<Self-sync 204 mode*/ /**< CNcomment:204             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_188_204, /**<self-sync 188/204 auto-identification mode */ /**< CNcomment:188/204 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL,                  /**<Serial sync mode, 1bit*/ /**< CNcomment:sync, 1bit */
+    HI_UNF_DMX_PORT_TYPE_USER_DEFINED,            /**<User defined mode*//**< CNcomment: */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT,              /**<Serial sync mode, 2bit*/ /**< CNcomment:sync, 2bit */
+    HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC,           /**<Serial nosync mode, 1bit */ /**< CNcomment:nosync, 1bit */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT_NOSYNC,       /**<Serial nosync mode, 2bit */ /**< CNcomment:nosync, 2bit */
+    HI_UNF_DMX_PORT_TYPE_AUTO,                    /**<Auto mode*/ /**< CNcomment:  */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_VALID_DUMMY_SYNC, /**<Parallel valid dummy sync mode*/ /**< CNcomment:VALID DUMMY SYNC TS*/
+    HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC_NOVALID,     /**<Serial nosync novalid mode, 1bit */ /**< CNcomment:nosync novalid, 1bit */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT_NOSYNC_NOVALID, /**<Serial nosync novalid mode, 2bit */ /**< CNcomment:nosync novalid, 2bit */
+
+    HI_UNF_DMX_PORT_TYPE_BUTT
+} HI_UNF_DMX_PORT_TYPE_E;
+
+/**TSO clock mode*/
+/**CNcomment:TS */
+typedef enum hiUNF_DMX_TSO_CLK_MODE_E
+{
+    HI_UNF_DMX_TSO_CLK_MODE_NORMAL,                  /**<Normal clock: clock always active*/ /**< CNcomment:,*/
+    HI_UNF_DMX_TSO_CLK_MODE_JITTER ,                  /**<Jittered clock: clock active only when outputing data*/ /**< CNcomment:Jittered ,, (valid)*/
+    HI_UNF_DMX_TSO_CLK_MODE_BUTT
+}HI_UNF_DMX_TSO_CLK_MODE_E;
+
+/**TSO valid mode*/
+/**CNcomment:TSvalid */
+typedef enum hiUNF_DMX_TSO_VALID_MODE_E
+{
+    HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT,          /**<Valid signal high when outputing datas*/ /**< CNcomment:valid*/
+    HI_UNF_DMX_TSO_VALID_ACTIVE_HIGH ,          /**<Valid signal always high*/ /**< CNcomment:valid*/
+    HI_UNF_DMX_TSO_VALID_ACTIVE_BUTT
+}HI_UNF_DMX_TSO_VALID_MODE_E;
+
+/**TSO port signal line selector*/
+/**CNcomment:TS */
+typedef enum hiUNF_DMX_TSO_SERIAL_BIT_E
+{
+    HI_UNF_DMX_TSO_SERIAL_BIT_0 = 0x0,          /**< Serial output data using data[0] as signal line*/ /**< CNcomment:data[0]*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_7 = 0x7,          /**< Serial output data using data[7] as signal line*/ /**< CNcomment:data[7]*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_BUTT
+}HI_UNF_DMX_TSO_SERIAL_BIT_E;
+
+/**TS out mode clock frequency*/
+/**CNcomment:TS ,,TS out  = TSO /*/
+typedef enum hiUNF_DMX_TSO_CLK_E
+{
+    HI_UNF_DMX_TSO_CLK_100M ,           /**< TS out mode clock frequency 100M*/ /**< CNcomment:TS100M*/
+    HI_UNF_DMX_TSO_CLK_150M ,           /**< TS out mode clock frequency 150M*/ /**< CNcomment:TS150M*/
+    HI_UNF_DMX_TSO_CLK_1200M ,          /**< TS out mode clock frequency 1200M*/ /**< CNcomment:TS1200M*/
+    HI_UNF_DMX_TSO_CLK_1500M ,          /**< TS out mode clock frequency 1500M*/ /**< CNcomment:TS1500M*/
+    HI_UNF_DMX_TSO_CLK_BUTT
+}HI_UNF_DMX_TSO_CLK_E;
+
+/** Tag sync mode */
+/** CNcomment: Tag */
+typedef enum hiUNF_DMX_TAG_SYNC_MODE_E
+{
+    HI_UNF_DMX_TAG_HEAD_SYNC = 0x0,          /** < tag sync signal at tag head*/ /**< CNcomment:synctag*/
+    HI_UNF_DMX_NORMAL_HEAD_SYNC = 0x1,    /** < tag sync signal at 47 heade*/ /** <CNcomment:sync47*/
+}HI_UNF_DMX_TAG_SYNC_MODE_E;
+
+/** TS Tag attributes */
+/** CNcomment: TS Tag */
+#define MAX_TAG_LENGTH (12)
+typedef struct hiUNF_DMX_TAG_PORT_ATTR_S
+{
+    HI_UNF_DMX_PORT_E enTSSource;                   /**<[IN]Source of this Tag port ,can choose from HI_UNF_DMX_PORT_TSI_XX*/ /**< CNcomment:Tag ,HI_UNF_DMX_PORT_TSI_XX*/
+    HI_U8             au8Tag[MAX_TAG_LENGTH];       /** <[IN]tag index value*/ /**< CNcomment:tag */
+    HI_U32            u32TagLen;   /** <[IN & OUT]Valid tag length(1 ~ 12bytes), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /** <CNcomment:tag(1~12),setTagAttr,getTagAttr*/
+    HI_BOOL           bEnabled;       /**<[IN & OUT]Port state(default disabled), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /**< CNcomment:(),setTagAttr,getTagAttr*/
+    HI_UNF_DMX_TAG_SYNC_MODE_E enSyncMod; /** <[IN & OUT]Sync mode(default HI_UNF_DMX_TAG_HEAD_SYNC), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /**<CNcomment:(HI_UNF_DMX_TAG_HEAD_SYNC ),setTagAttr,getTagAttr*/
+}HI_UNF_DMX_TAG_PORT_ATTR_S;
+
+
+/**TS out port attributes*/
+/**CNcomment:TS Out */
+typedef struct hiUNF_DMX_TSO_PORT_ATTR_S
+{
+    HI_BOOL                     bEnable;       /**<Port enable, default value HI_TRUE means enable*/ /**< CNcomment:,*/
+    HI_BOOL                     bClkReverse;   /**<Clock phase reverse, default value HI_FALSE means do not reverse the phase of clock*/ /**< CNcomment:,*/
+    HI_UNF_DMX_PORT_E           enTSSource;    /**<Source of this TS Out port ,can choose from HI_UNF_DMX_PORT_IF_0 to HI_UNF_DMX_PORT_TSI_9*/  /**< CNcomment:TS Out ,HI_UNF_DMX_PORT_IF_0 HI_UNF_DMX_PORT_TSI_9 */
+    HI_UNF_DMX_TSO_CLK_MODE_E   enClkMode;     /**<Clock mode: HI_UNF_DMX_TSO_CLK_MODE_NORMAL is the default value*/ /**< CNcomment::  HI_UNF_DMX_TSO_CLK_MODE_NORMAL*/
+    HI_UNF_DMX_TSO_VALID_MODE_E enValidMode;   /**<Wether valid signal always enable : HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT is the default value */ /**< CNcomment:Valid : :HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT  */
+    HI_BOOL                     bBitSync;       /**<The sync signal duration : HI_TRUE: only valid when output the first bit(default). HI_FALSE: keep when outputing the whole byte*/
+                                                /**< CNcomment:sync  : HI_TRUE: bit () . HI_FALSE:   */
+    HI_UNF_DMX_PORT_TYPE_E      enPortType;     /**<Port out put mode: serial(HI_UNF_DMX_PORT_TYPE_SERIAL), parallel(HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST) or serial 2bits(HI_UNF_DMX_PORT_TYPE_SERIAL2BIT) mode. default is serial(HI_UNF_DMX_PORT_TYPE_SERIAL)*/
+                                                /**< CNcomment:TSO:(HI_UNF_DMX_PORT_TYPE_SERIAL)(HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST) 2bit(HI_UNF_DMX_PORT_TYPE_SERIAL2BIT)  (HI_UNF_DMX_PORT_TYPE_SERIAL)*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_E enBitSelector;  /**<Port line sequence select In serial mode.only valid when using serial out put mode,HI_UNF_DMX_TSO_SERIAL_BIT_7 is the default value.*/
+                                                /**< CNcomment:,, HI_UNF_DMX_TSO_SERIAL_BIT_7*/
+    HI_BOOL                     bLSB;           /**<Out put byte endian .only valid when using serial out put mode: HI_FALSE: first output MSB (default). HI_TRUE:  first output LSB*/
+                                                /**< CNcomment:,: HI_FALSE:  () . HI_TRUE:   */
+    HI_UNF_DMX_TSO_CLK_E        enClk;          /**<TS out mode clock frequency,default is HI_UNF_DMX_TSO_CLK_150M*/ /**< CNcomment:TS, HI_UNF_DMX_TSO_CLK_150M*/
+    HI_U32                      u32ClkDiv;      /**<TS out mode clock frequency divider,must be times of 2 ,and must meet (2 <= u32ClkDiv <= 32) .default is 2*/ /**< CNcomment:TSO,2,232*/
+} HI_UNF_DMX_TSO_PORT_ATTR_S;
+
+
+/**TS port attributes*/
+/**CNcomment:TS*/
+typedef struct hiUNF_DMX_PORT_ATTR_S
+{
+    HI_UNF_DMX_PORT_MODE_E enPortMod;       /**<Port mode.Readonly*/ /**< CNcomment: */
+    HI_UNF_DMX_PORT_TYPE_E enPortType;      /**<Port type*/ /**< CNcomment: */
+    HI_U32 u32SyncLostTh;                   /**<Sync loss threshold.The default value is recommended.*/ /**< CNcomment: */
+    HI_U32 u32SyncLockTh;                   /**<Sync lock threshold.The default value is recommended.*/ /**< CNcomment: */
+    HI_U32 u32TunerInClk;                   /**<Whether to reverse the phase of the clock input from the tuner*/ /**< CNcomment:Tuner.0: (); 1: */
+    HI_U32 u32SerialBitSelector;            /**<Port line sequence select In parallel mode: 0: cdata[7] is the most significant bit (MSB) (default). 1: cdata[0] is the MSB.
+                                                            In serial mode: 1: cdata[0] is the data line (default). 0: cdata[7] is the data line.*/
+                                            /**< CNcomment::0: cdata[7]();1: cdata[0]
+                                                            :1: cdata[0](); 0: cdata[7]*/
+
+    HI_U32 u32TunerErrMod;                  /**<Level mode of the cerr_n line from the tuner to a DEMUX.
+                                                       0: A data error occurs when the cerr_n line is high.
+                                                       1: A data error occurs when the cerr_n line is low (default).*/
+                                            /**< CNcomment:tunerDEMUXcerr_n:
+                                                       0: cerr_n;
+                                                       1: cerr_n () */
+    HI_U32 u32UserDefLen1;                  /**<User defined length1,valid when enPortType is HI_UNF_DMX_PORT_TYPE_USER_DEFINED,188~255 *//**< CNcomment:1188~255 */
+    HI_U32 u32UserDefLen2;                  /**<User defined length2,valid when enPortType is HI_UNF_DMX_PORT_TYPE_USER_DEFINED,188~255 *//**< CNcomment:2188~255*/
+    HI_UNF_DMX_PORT_E enSerialPortShareClk; /**<Port of clock that this port shared, only valid for TSI port tpye *//**< CNcomment:TSI*/
+} HI_UNF_DMX_PORT_ATTR_S;
+
+/**Status of the TS port*/
+/**CNcomment:TS*/
+typedef struct hiUNF_DMX_PORT_PACKETNUM_S
+{
+    HI_U32  u32TsPackCnt;    /**<Number of TS packets received from the TS port*/ /**< CNcomment:TS*/
+    HI_U32  u32ErrTsPackCnt; /**<Number of error TS packets received from the TS port*/ /**< CNcomment:TS*/
+    HI_U32  u32TsSyncByteErrCnt;  /**<Number of sync byte error TS packets received from the TS port*/  /**< CNcomment:TS*/
+    HI_U32  u32TsSyncLossCnt;    /**<Number of sync loss TS packets received from the TS port*/ /**< CNcomment:TS*/
+    HI_U32  u32TsPackDrainedCnt;    /**<Number of Drained TS packets received from the TS port*/ /**< CNcomment:TS*/
+    HI_U32  u32PackDisCCCnt;    /**<Number of Discontinuity TS packets received from the TS port*/ /**< CNcomment:TS*/
+    HI_U32  u32PackDisCCCntCA;    /**<Number of Discontinuity TS packets received before descrambler from the TS port, the value is same as u32PackDisCCCnt*/ /**< CNcomment: TS,u32PackDisCCCnt*/
+} HI_UNF_DMX_PORT_PACKETNUM_S;
+
+/** Secure mode type*/
+/**CNcomment:*/
+typedef enum hiUNF_DMX_SECURE_MODE_E
+{
+    HI_UNF_DMX_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:*/
+    HI_UNF_DMX_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone*/
+
+    HI_UNF_DMX_SECURE_MODE_BUTT
+} HI_UNF_DMX_SECURE_MODE_E;
+
+/** TS buffer attribute*/
+/**CNcomment:TS buffer */
+typedef struct hiUNF_DMX_TSBUF_ATTR_S
+{
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;  /**<Secure indication*/ /**<CNcomment:*/
+    HI_U32  u32BufSize;                     /**<Buffer size*/ /**< CNcomment:*/
+}HI_UNF_DMX_TSBUF_ATTR_S;
+
+/**Status of a TS buffer of a DEMUX*/
+/**CNcomment:DEMUXTS Buffer */
+typedef struct hiUNF_DMX_TSBUF_STATUS_S
+{
+    HI_U32 u32BufSize;    /**<Buffer size*/ /**< CNcomment:*/
+    HI_U32 u32UsedSize;   /**<Used buffer size*/ /**< CNcomment:,0x100 */
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;  /**<Secure indication*/ /**<CNcomment:*/
+    HI_U32 u32HardwareUsedSize;             /**<Hardware Used Buffer Size, used for special scene*/ /**< CNcomment:buffer*/
+} HI_UNF_DMX_TSBUF_STATUS_S;
+
+/**Channel type*/
+/**CNcomment: */
+typedef enum hiUNF_DMX_CHAN_TYPE_E
+{
+    HI_UNF_DMX_CHAN_TYPE_SEC = 0, /**<Channel that receives sections data such as program specific information (PSI) or service information (SI) data*/ /**< CNcomment: PSI/SIsecitons*/
+    HI_UNF_DMX_CHAN_TYPE_PES,     /**<Channel that receives packetized elementary stream (PES) data*/ /**< CNcomment:PES*/
+    HI_UNF_DMX_CHAN_TYPE_AUD,     /**<Channel that receives audio data*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_TYPE_VID,     /**<Channel that receives video data*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_TYPE_POST,      /**<Entire-packet posting channel that receives an entire TS packet with a specific packet identifier (PID). */ /**< CNcomment:PIDTS*/
+    HI_UNF_DMX_CHAN_TYPE_ECM_EMM,   /**<Channel that receives entitlement control message (ECM) or entitlement management message (EMM) data*/ /**< CNcomment:ECMEMM*/
+
+    HI_UNF_DMX_CHAN_TYPE_BUTT
+} HI_UNF_DMX_CHAN_TYPE_E;
+
+/**Status of the channel*/
+/**CNcomment:channel*/
+typedef struct hiUNF_DMX_CHAN_PACKETNUM_S
+{
+    HI_U32          u32CCDiscCnt;   /**<CC Discontinuity Count */ /**< CNcomment:CC*/
+} HI_UNF_DMX_CHAN_PACKETNUM_S;
+
+/**Cyclic redundancy check (CRC) mode of a channel*/
+/**CNcomment:CRC */
+typedef enum hiUNF_DMX_CHAN_CRC_MODE_E
+{
+    HI_UNF_DMX_CHAN_CRC_MODE_FORBID = 0,                /**<The CRC check is disabled*/ /**< CNcomment:CRC */
+    HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD = 1,     /**<The CRC check is enabled, and the error Section data is discarded*/ /**< CNcomment:CRCSection */
+    HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_SEND = 2,        /**<The CRC check is enabled, and the error Section data is received*/ /**< CNcomment:CRCSection */
+    HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD = 3, /**<Whether the CRC check is performed depends on the syntax, and the error Section data is discarded*/ /**< CNcomment:CRCSection */
+    HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_SEND = 4,    /**<Whether the CRC check is performed depends on the syntax, and the error Section data is received*/ /**< CNcomment:CRCSection */
+
+    HI_UNF_DMX_CHAN_CRC_MODE_BUTT
+} HI_UNF_DMX_CHAN_CRC_MODE_E;
+
+/**Output mode of a channel*/
+/**CNcomment: */
+typedef enum hiUNF_DMX_CHAN_OUTPUT_MODE_E
+{
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY = 0x1,     /**<Mode of playing audios/videos or receiving data*/ /**< CNcomment: */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_REC  = 0x2,     /**<Recording mode*/ /**< CNcomment: */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY_REC = 0x3, /**<Mode of recording and playing data or receiving data*/ /**< CNcomment: */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_BUTT
+} HI_UNF_DMX_CHAN_OUTPUT_MODE_E;
+
+/**Channel attribute*/
+/**CNcomment:*/
+typedef struct hiUNF_DMX_CHAN_ATTR_S
+{
+    HI_U32 u32BufSize;                            /**<Buffer size used by channels*/ /**< CNcomment:buffer*/
+    HI_UNF_DMX_CHAN_TYPE_E enChannelType;         /**<Channel type*/ /**< CNcomment: */
+    HI_UNF_DMX_CHAN_CRC_MODE_E enCRCMode;         /**<CRC mode.It is valid for the DEMUX_CHAN_SEC channel.*/ /**< CNcomment:CRCDMX_CHAN_SEC  */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_E enOutputMode;   /**<Output mode of the channel data*/ /**< CNcomment: */
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;        /**<Secure channel indication*/ /**<CNcomment:*/
+} HI_UNF_DMX_CHAN_ATTR_S;
+
+/**Scrambled flag of the channel data*/
+/**CNcomment: */
+typedef enum hiUNF_DMX_SCRAMBLED_FLAG_E
+{
+    HI_UNF_DMX_SCRAMBLED_FLAG_TS,  /**<TS data is scrambled*/ /**< CNcomment:TS*/
+    HI_UNF_DMX_SCRAMBLED_FLAG_PES, /**<PES data is scrambled*/ /**< CNcomment:PES*/
+    HI_UNF_DMX_SCRAMBLED_FLAG_NO,  /**<Data is not scrambled*/ /**< CNcomment:*/
+
+    HI_UNF_DMX_SCRAMBLED_FLAG_BUTT
+} HI_UNF_DMX_SCRAMBLED_FLAG_E;
+
+/**Channel status*/
+/**CNcomment: */
+typedef enum hiUNF_DMX_CHAN_STATUS_E
+{
+    HI_UNF_DMX_CHAN_CLOSE = 0x0,        /**<The channel is stopped.*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_PLAY_EN = 0x1,      /**<The channel is playing audios/videos or receiving data.*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_REC_EN = 0x2,       /**<The channel is recording data.*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_PLAY_REC_EN = 0x3,  /**<The channel is recording and receiving data.*/ /**< CNcomment:*/
+} HI_UNF_DMX_CHAN_STATUS_E;
+
+/**Defines the channel status*/
+/** CNcomment:*/
+typedef struct hiUNF_DMX_CHAN_STATUS_S
+{
+    HI_UNF_DMX_CHAN_STATUS_E enChanStatus;   /**<Channel status*/ /**< CNcomment:*/
+} HI_UNF_DMX_CHAN_STATUS_S;
+
+/**Filter attribute*/
+/**CNcomment:*/
+typedef struct hiUNF_DMX_FILTER_ATTR_S
+{
+    HI_U32  u32FilterDepth;                     /**<Depth of a filter.*/ /**< CNcomment:*/
+    HI_U8   au8Match[DMX_FILTER_MAX_DEPTH];     /**<Matched bytes of a filter.The data is compared by bit.*/ /**< CNcomment:,bit*/
+    HI_U8   au8Mask[DMX_FILTER_MAX_DEPTH];      /**<Masked bytes of a filter. The conditions are set by bit. 0: no mask. Comparison is required. 1: mask. Comparison is not required.*/ /**< CNcomment:,bit, 0:mask, 1:mask*/
+    HI_U8   au8Negate[DMX_FILTER_MAX_DEPTH];    /**<Negated bytes of a filter. 0: not negated; 1: negated*/ /**< CNcomment:,byte, 0:,1:*/
+} HI_UNF_DMX_FILTER_ATTR_S;
+
+/**Type of the DEMUX data packet.*/
+/**CNcomment:DEMUX*/
+typedef enum hiUNF_DMX_DATA_TYPE_E
+{
+    HI_UNF_DMX_DATA_TYPE_WHOLE = 0,  /**<The data segment contains a complete data packet*/ /**< CNcomment:, SECTION*/
+    HI_UNF_DMX_DATA_TYPE_HEAD,       /**<The data segment contains the head of a data packet, but the data packet may not be complete*/ /**< CNcomment:, PES*/
+    HI_UNF_DMX_DATA_TYPE_BODY,       /**<This type is valid only for the PES data.The data segment contains the body of a data packet. */ /**< CNcomment:, PES*/
+    HI_UNF_DMX_DATA_TYPE_TAIL,       /**<This type is valid only for the PES data.The data segment contains the tail of a data packet, and is used to identify the end of a data packet.*/ /**< CNcomment:, PES*/
+
+    HI_UNF_DMX_DATA_TYPE_BUTT
+} HI_UNF_DMX_DATA_TYPE_E;
+
+/**DEMUX data packet*/
+/**CNcomment:DEMUX*/
+typedef struct hiUNF_DMX_DATA_S
+{
+    HI_U8   *pu8Data;                   /**<Data pointer*/ /**< CNcomment: */
+    HI_U32  u32Size;                    /**<Data length*/ /**< CNcomment: */
+    HI_UNF_DMX_DATA_TYPE_E enDataType;  /**<Data packet type*/ /**< CNcomment: */
+} HI_UNF_DMX_DATA_S;
+
+/**type of record*/
+/**CNcomment: */
+typedef enum hiUNF_DMX_REC_TYPE_E
+{
+    HI_UNF_DMX_REC_TYPE_SELECT_PID, /**<Record selected pid ts data *//**<CNcomment: PID TS*/
+    HI_UNF_DMX_REC_TYPE_ALL_PID,    /**<Record all pid ts data *//**<CNcomment: TS*/
+    HI_UNF_DMX_REC_TYPE_ALL_DATA,   /**<Record raw data,TLV etc *//**<CNcomment: TLV*/
+    HI_UNF_DMX_REC_TYPE_BUTT
+} HI_UNF_DMX_REC_TYPE_E;
+
+/**type of index*/
+/**CNcomment:  */
+typedef enum hiUNF_DMX_REC_INDEX_TYPE_E
+{
+    HI_UNF_DMX_REC_INDEX_TYPE_NONE,     /**<No index is created */  /**<CNcomment:  */
+    HI_UNF_DMX_REC_INDEX_TYPE_VIDEO,    /**<Video index */          /**<CNcomment:  */
+    HI_UNF_DMX_REC_INDEX_TYPE_AUDIO,    /**<Audio index */          /**<CNcomment:  */
+    HI_UNF_DMX_REC_INDEX_TYPE_BUTT
+} HI_UNF_DMX_REC_INDEX_TYPE_E;
+
+/**<TS stream type.*/
+/**<CNcomment: ts*/
+typedef enum hiUNF_DMX_TS_PACKET_TYPE_E
+{
+    HI_UNF_DMX_TS_PACKET_188,           /**<ts stream packet size of 188 bytes*//**<CNcomment: ts188*/
+    HI_UNF_DMX_TS_PACKET_192,           /**<ts stream packet size of 192 bytes*//**<CNcomment: ts192*/
+    HI_UNF_DMX_TS_PACKET_BUTT
+}HI_UNF_DMX_TS_PACKET_TYPE_E;
+
+/**record attribute*/
+/**CNcomment: */
+typedef struct hiUNF_DMX_REC_ATTR_S
+{
+    HI_U32                      u32DmxId;
+    HI_U32                      u32RecBufSize;  /**<Buffer size used by record */ /**< CNcomment:  */
+    HI_UNF_DMX_REC_TYPE_E       enRecType;      /**<Record type */ /**< CNcomment:  */
+    HI_BOOL                     bDescramed;     /**<HI_TRUE is the descrambled TS. HI_FALSE is the original TS. */ /**<CNcomment: HI_TRUETSHI_FALSE */
+    HI_UNF_DMX_REC_INDEX_TYPE_E enIndexType;    /**<Index type */ /**< CNcomment:  */
+    HI_U32                      u32IndexSrcPid; /**<The index information is formed according to the PID. when indexing video, it has to be set to the video of PID. when indexing audio, it has to be set to the audio of PID. */ /**< CNcomment: PIDPIDPID */
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Video encoding protocol. The protocol needs to be set only when the index type is HI_UNF_DMX_REC_INDEX_TYPE_VIDEO.*/ /**< CNcomment:  */
+    HI_UNF_DMX_SECURE_MODE_E    enSecureMode;   /**<Secure record indication*/ /**<CNcomment:*/
+    HI_UNF_DMX_TS_PACKET_TYPE_E enTsPacketType; /**<TS stream type of recorded TS.*/ /**<CNcomment: TS */
+} HI_UNF_DMX_REC_ATTR_S;
+
+/**record data*/
+/**CNcomment: */
+typedef struct hiUNF_DMX_REC_DATA_S
+{
+    HI_U8  *pDataAddr;      /**<Data address*/          /**<CNcomment:  */
+    HI_U32  u32DataPhyAddr; /**<Data physical address*/ /**<CNcomment:  */
+    HI_U32  u32Len;         /**<Data length*/           /**<CNcomment:  */
+    HI_BOOL bLastDataFlag;  /**<Last Data Flag */       /**<CNcomment:  */
+} HI_UNF_DMX_REC_DATA_S;
+
+/**index data*/
+/**CNcomment: */
+typedef struct hiUNF_DMX_REC_INDEX_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E   enFrameType;        /**< it is meaningless when indexing audio. */ /**<CNcomment:  */
+    HI_U32                      u32PtsMs;
+    HI_U64                      u64GlobalOffset;
+    HI_U32                      u32FrameSize;       /**< it is meaningless when indexing audio. */ /**<CNcomment:  */
+    HI_U32                      u32DataTimeMs;
+} HI_UNF_DMX_REC_INDEX_S;
+
+/**index and record data*/
+/**CNcomment: */
+typedef struct hiUNF_DMX_REC_DATA_INDEX_S
+{
+    HI_U32 u32IdxNum;                                   /**< Number of index */ /**<CNcomment:  */
+    HI_U32 u32RecDataCnt;                               /**< Number of record data block*/ /**<CNcomment:  ,1bufferblock  */
+    HI_UNF_DMX_REC_INDEX_S stIndex[DMX_MAX_IDX_ACQUIRED_EACH_TIME];
+    HI_UNF_DMX_REC_DATA_S  stRecData[2];
+} HI_UNF_DMX_REC_DATA_INDEX_S;
+
+/**record buffer status*/
+/**CNcomment: */
+typedef struct hiUNF_DMX_RECBUF_STATUS_S
+{
+    HI_U32  u32BufSize;     /**<Buffer size*/ /**< CNcomment: */
+    HI_U32  u32UsedSize;    /**<Used buffer*/ /**< CNcomment: */
+} HI_UNF_DMX_RECBUF_STATUS_S;
+
+/**Repeat CC mode of channel*//**CNcomment:CC */
+typedef enum hiUNF_DMX_CHAN_CC_REPEAT_MODE
+{
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_RSV   = 0x0,     /**<Receive CC repeat ts packet*/ /**< CNcomment:ccts*/
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_DROP  = 0x1,     /**<Drop CC repeat ts packet*/ /**< CNcomment:ccts */
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_BUTT = -1
+}HI_UNF_DMX_CHAN_CC_REPEAT_MODE_E;
+
+typedef struct hiUNF_DMX_CHAN_CC_REPEAT_SET_S
+{
+    HI_HANDLE hChannel;                               /**<The channel handle*/ /**< CNcomment:*/
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_E enCCRepeatMode;   /**<Repeat CC mode of channel*/ /**< CNcomment:CC*/
+}HI_UNF_DMX_CHAN_CC_REPEAT_SET_S;
+
+/** PUSI (Payload Unit Start Index) config structure*/
+/**CNcomment: PUSI  */
+typedef struct hiUNF_DMX_PUSI_SET_S
+{
+    HI_BOOL bPusi;                               /**< Value of Pusi , Default is HI_FALSE means receive ts packet without checking PUSI*/ /**< CNcomment:NoPusiEn  HI_FALSE TSPUSI*/
+}HI_UNF_DMX_PUSI_SET_S;
+
+/** TEI (Transport Error Index) config structure*/
+/**CNcomment: TEI  */
+typedef struct hiUNF_DMX_TEI_SET_S
+{
+    HI_U32   u32DemuxID;                    /**<The Subdiviece ID*/ /**< CNcomment:Demux ID*/
+    HI_BOOL bTei;                                   /**< Value of bTei , Default is HI_FALSE means receive ts packet even TEI equal 1*/ /**< CNcomment:TEICfg  HI_FALSE TEI1  TS*/
+}HI_UNF_DMX_TEI_SET_S;
+
+/** Define of how TSI and TSO to be attached */
+/**CNcomment: TSI/TSO */
+typedef struct hiUNF_DMX_TSI_ATTACH_TSO_S
+{
+    HI_UNF_DMX_PORT_E       enTSI;              /**<The TSI ID*/ /**< CNcomment:TSI ID*/
+    HI_UNF_DMX_TSO_PORT_E   enTSO;              /**<The TSO ID*/ /**< CNcomment:TSO ID*/
+}HI_UNF_DMX_TSI_ATTACH_TSO_S;
+
+typedef enum hiUNF_DMX_INVOKE_TYPE
+{
+    HI_UNF_DMX_INVOKE_TYPE_CHAN_CC_REPEAT_SET  = 0,  /**<dmx set channel extra attr,param:HI_UNF_DMX_CHAN_CC_REPEAT_SET_S*//**<CNcomment: HI_UNF_DMX_CHAN_CC_REPEAT_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_PUSI_SET,                    /**<dmx set PUSI flag,param:HI_UNF_DMX_PUSI_SET_S*//**<CNcomment:  NoPusiEn HI_UNF_DMX_PUSI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_TEI_SET,             /**<dmx set TEI flag,param:HI_UNF_DMX_TEI_SET_S*//**<CNcomment: Demux TEICfg HI_UNF_DMX_TEI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_TSI_ATTACH_TSO,      /**<Attach TSI with TSO ,param:HI_UNF_DMX_TSI_ATTACH_TSO_S*//**<CNcomment: TSI   TSO ,: TSI  TSO HI_UNF_DMX_TEI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_BUTT
+} HI_UNF_DMX_INVOKE_TYPE_E;
+
+/** Define cb context type */
+/**CNcomment:*/
+typedef enum hiUNF_DMX_CB_CONTEXT_TYPE_E
+{
+    HI_UNF_DMX_CB_CONTEXT_TYPE_SHARED = 0, /**<public shared context thread*//**<CNcomment: */
+    HI_UNF_DMX_CB_CONTEXT_TYPE_PRIVATE, /**<private context thread *//**<CNcomment:*/
+    HI_UNF_DMX_CB_CONTEXT_TYPE_BUTT
+}HI_UNF_DMX_CB_CONTEXT_TYPE_E;
+
+/** Declare section/pes/post cb function interface */
+/**CNcomment:section/pes/post*/
+typedef HI_S32 (*HI_UNF_DMX_CHAN_BUF_CB_FUNC)(HI_HANDLE hChannel, HI_U32 u32AcquiredNum, HI_UNF_DMX_DATA_S *pstBuf, HI_VOID *pUserData);
+
+/** Define cb descriptor */
+/**CNcomment:*/
+typedef struct hiUNF_DMX_CB_DESC_S
+{
+    HI_UNF_DMX_CB_CONTEXT_TYPE_E enContextType; /**<cb context type*//**<CNcomment:*/
+    HI_UNF_DMX_CHAN_BUF_CB_FUNC pfnChanBufCb; /**<section/pes/post cb function *//**<CNcomment:section/pes/post*/
+    HI_VOID *pUserData; /** user private data *//**<CNcomment: */
+}HI_UNF_DMX_CB_DESC_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      DEMUX */
+/** @{ */  /** <!-- [DEMUX] */
+
+/**
+\brief Initializes the DEMUX module.CNcomment:DEMUXCNend
+\attention \n
+Before using DEMUXs, you must call this application programming interface (API).\n
+Before using the personal video recorder (PVR) or audio/video player (AVPLAY), you need to initialize the DEMUX module.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:DEMUX\n
+PVRAVPLAYDEMUX\n
+CNend
+\param  N/A.CNcomment:CNend
+\retval ::HI_SUCCESS Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\see \n
+N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the DEMUX module. CNcomment:DEMUXCNend
+\attention \n
+After this API is called, the DEMUX module is stopped, and the DEMUX resources used by the process are released.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:DEMUXDEMUX\n
+CNend
+\param  N/A.CNcomment:CNend
+\retval ::HI_SUCCESS Success CNcomment:CNend
+\retval ::HI_FAILURE Calling this API fails. CNcomment:APICNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DeInit(HI_VOID);
+
+
+/**
+\brief Obtains the information about the service capabilities of the DEMUX module.The information includes the numbers of channels, filters, keys, ports, DEMUXs, and audio/video channels.
+CNcomment:DEMUXDEMUXCNend
+\attention \n
+N/A.CNcomment:CNend
+\param[out] pstCap   Pointer to the capability of the DEMUX module (output).CNcomment:DEMUXCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:CNend
+\see \n
+::HI_UNF_DMX_CAPABILITY_S
+*/
+HI_S32 HI_UNF_DMX_GetCapability(HI_UNF_DMX_CAPABILITY_S *pstCap);
+
+
+/**
+\brief Obtains the attributes of a DEMUX port.CNcomment:DEMUXCNend
+\attention \n
+ N/A.CNcomment:CNend
+\param[in] enPortId Port ID.CNcomment:CNend
+\param[out] pstAttr Pointer to the port attributes (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortAttr(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Sets the attributes of a DEMUX port.CNcomment:DEMUXCNend
+\attention \n
+It is recommended to query the default attributes of a DEMUX port by calling HI_UNF_DMX_GetTSPortAttr before modifying the attributes of the port.\n
+The port mode can be queried only, notice that it will lose TS data if call this function during receiving data.\n
+If the sync loss threshold and sync lock threshold are used, their default values are recommended.\n
+For details on how to set the input clock of the tuner, select the line sequence of the port, and set the level of the tuner error line, contact hardware engineers of HiSilicon\n
+and refer to tuner user manuals.
+CNcomment:HI_UNF_DMX_GetTSPortAttr\n
+TS\n
+\n
+tunertuner error\n
+tunerCNend
+\param[in] enPortId Port ID.CNcomment:CNend
+\param[in] pstAttr  Pointer to port attributes.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetTSPortAttr(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Obtains the attributes of a DEMUX TSO port.CNcomment:DEMUX TSCNend
+\attention \n
+ N/A.CNcomment:CNend
+\param[in] enPortId Port ID.CNcomment:CNend
+\param[out] pstAttr Pointer to the port attributes (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSOPortAttr(HI_UNF_DMX_TSO_PORT_E enPortId, HI_UNF_DMX_TSO_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Sets the attributes of a DEMUX TSO port.CNcomment:DEMUX TS CNend
+\attention \n
+It is recommended to query the default attributes of a DEMUX TSO port by calling HI_UNF_DMX_GetTSOPortAttr before modifying the attributes of the TSO port.
+CNcomment:HI_UNF_DMX_GetTSPortAttrCNend
+\param[in] enPortId Port ID.CNcomment:CNend
+\param[in] pstAttr  Pointer to port attributes.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetTSOPortAttr(HI_UNF_DMX_TSO_PORT_E enPortId, HI_UNF_DMX_TSO_PORT_ATTR_S *pstAttr);
+
+/**
+\brief Get the tag attributes.CNcomment:tag CNend
+\attention \n
+pstAttr.au8Tag is a key index, this interface will return corresponding tag attrs if this key value has registered, otherwise return default tag attrs.
+ N/A.CNcomment:pstAttr.au8TagtagtagCNend
+\param[in] enPortId  TagPort ID.CNcomment:TapPort IDCNend
+\param[in & out] pstAttr Pointer to the tag port attributes (output).CNcomment:tagCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTagPortAttr(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_TAG_PORT_ATTR_S *pstAttr);
+
+/**
+\brief Set the tag attributes.CNcomment:tagCNend
+\attention \n
+pstAttr.au8Tag is a key index, it will register this new tag if this key value has not registered. otherwise increase tag reference number.
+ N/A.CNcomment:pstAttr.au8TagtagtagtagCNend
+\param[in] enPortId  TagPort ID.CNcomment:TapPort IDCNend
+\param[in] pstAttr Pointer to the tag port attributes (output).CNcomment:tagCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+ */
+HI_S32 HI_UNF_DMX_SetTagPortAttr(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_TAG_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Attaches a DEMUX to a port.CNcomment:DEMUXCNend
+\attention \n
+Each DEMUX can be attached to only one port, but the data from a port can be delivered to multiple DEMUXs.\n
+After a DEMUX is attached to a port, the DEMUX starts to receive the data input from this port.\n
+If the DEMUX is not used, you can detach it by calling HI_UNF_DMX_DetachTSPort.\n
+The DEMUXs can be attached to different ports dynamically. That is, you can attach the DEMUXs without detaching them.\n
+If you call this API to attach a DEMUX to the same channel, the error code HI_SUCCESS is returned.
+CNcomment:DEMUXPORTPORTDEMUX\n
+DEMUX\n
+DEMUXHI_UNF_DMX_DetachTSPortDEMUX\n
+\n
+CNend
+\param[in] u32DmxId  DEMUX ID.CNcomment:DEMUXCNend
+\param[in] enPortId  Port ID.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+::HI_UNF_DMX_DetachTSPort
+*/
+HI_S32 HI_UNF_DMX_AttachTSPort(HI_U32 u32DmxId, HI_UNF_DMX_PORT_E enPortId);
+
+
+/**
+\brief Detaches a DEMUX from a port.CNcomment:DEMUXCNend
+\attention \n
+If a DEMUX is not used, you can detach it from the corresponding port by calling this API.\n
+This API can be called dynamically, and can be used to disable the input sources of a DEMUX.\n
+If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:DEMUXDEMUX\n
+DEMUX\n
+CNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUXCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+::HI_UNF_DMX_AttachTSPort
+*/
+HI_S32 HI_UNF_DMX_DetachTSPort(HI_U32 u32DmxId);
+
+
+/**
+\brief Obtains the ID of the port that is attached to a DEMUX. CNcomment:DEMUXCNend
+\attention \n
+If a DEMUX is not attached to any port, an error code is returned.CNcomment:DEMUXCNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUXCNend
+\param[out] penPortId  Pointer to the ID of the port that is attached to a DEMUX(output).CNcomment:DEMUXCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOATTACH_PORT  The DEMUX is not attached to any port.CNcomment:DEMUXCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortId(HI_U32 u32DmxId, HI_UNF_DMX_PORT_E *penPortId);
+
+/**
+\brief Obtains the default attributes of a TS Buffer.CNcomment:TS BufferCNend
+\attention \n
+It is recommended to query the default TS Buffer attributes before creating a TS Buffer, and then modify the attributes,\n
+notice the secure mode of default attributes is None Secure Mode.
+CNcomment:TS Buffer\n
+CNend
+\param[out] pstTsBufAttr Pointer to the structure of the TS Buffer attributes.CNcomment:TS BufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferDefaultAttr(HI_UNF_DMX_TSBUF_ATTR_S *pstTsBufAttr);
+
+/**
+\brief Creates a TS buffer for the RAM port to receive the TS data from Internet or local memory. CNcomment:RAMTS BufferTSCNend
+\attention \n
+A TS buffer can be created for the RAM port only.\n
+The buffer size must range from 4 KB to 16 MB.\n
+It is recommended to set the buffer size to an integral multiple of 4 KB. Otherwise, bottom alignment is performed inside.\n
+The TS buffer cannot be created for the same port for multiple times; otherwise, an error code is returned.
+CNcomment:RAMTS Buffer\n
+buffer4K16M\n
+buffer4K\n
+TS Buffer,CNend
+\param[in] enPortId  Port ID.CNcomment:CNend
+\param[in] u32TsBufSize Size of a TS buffer.CNcomment:TS BufferCNend
+\param[out] phTsBuffer  Pointer to the handle of a created TS buffer (output).CNcomment:TS Buffer CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_RECREAT_TSBUFFER  The TS buffer corresponding to the port is created.CNcomment:TS BufferCNend
+\see \n
+N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateTSBuffer(HI_UNF_DMX_PORT_E enPortId, HI_U32 u32TsBufSize, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Creates a TS buffer for the RAM port to receive the TS data from Internet or local memory. CNcomment:RAMTS BufferTSCNend
+\attention \n
+A TS buffer can be created for the RAM port only.\n
+The buffer size must range from 4 KB to 16 MB.\n
+It is recommended to set the buffer size to an integral multiple of 4 KB. Otherwise, bottom alignment is performed inside.\n
+The TS buffer cannot be created for the same port for multiple times; otherwise, an error code is returned.
+CNcomment:RAMTS Buffer\n
+buffer4K16M\n
+buffer4K\n
+TS Buffer,CNend
+\param[in] enPortId  Port ID.CNcomment:CNend
+\param[in] pstTsBufAttr Attributes of a TS buffer.CNcomment:TS BufferCNend
+\param[out] phTsBuffer  Pointer to the handle of a created TS buffer (output).CNcomment:TS Buffer CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_RECREAT_TSBUFFER  The TS buffer corresponding to the port is created.CNcomment:TS BufferCNend
+\see \n
+N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateTSBufferExt(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_TSBUF_ATTR_S *pstTsBufAttr, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Destroys an existing TS buffer. CNcomment:TS BufferCNend
+\attention \n
+A TS buffer cannot be destroyed repeatedly. If a TS buffer is destroyed, its handle is also destroyed.\n
+In addition, if a buffer is destroyed, its data is cleared. In this case, the get and put operations are not available.\n
+However, the data in channels is retained when a TS buffer is destroyed. To switch streams, you need disable the channel, and then enable the channel again.
+CNcomment:TS Buffer,handle\n
+bufferGetPut\n
+TS bufferCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyTSBuffer(HI_HANDLE hTsBuffer);
+
+/**
+\brief Behavior1, Default,need work with HI_UNF_DMX_PutTSBuffer. Obtains a TS buffer to input data.
+CNcomment:HI_UNF_DMX_PutTSBufferTS BufferCNend
+\attention \n
+If you call this API repeatedly, the address of the same buffer is returned.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:getbuffer\n
+\n
+\n
+\n
+buffer\n
+0\n
+u32TimeOutMs00xffffffffu32TimeOutMs\n
+BufferHI_ERR_DMX_TIMEOUT\n
+u32TimeOutMs0BufferTS Bufferusleep(10000)cpu
+CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] u32ReqLen Requested data length.CNcomment:CNend
+\param[out] pstData  Data buffer.CNcomment:bufferCNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:bufferCNend
+
+\Behavior2,Support multrtherad operate one tsbuffer,Only Valid wen CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y, need work with HI_UNF_DMX_PushTSBuffer and HI_UNF_DMX_ReleaseTSBuffer. Obtains a TS buffer to input data.
+CNcomment:TSbufferCFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=yHI_UNF_DMX_PushTSBufferHI_UNF_DMX_ReleaseTSBufferTS BufferCNend
+\attention \n
+If you call this API repeatedly and didn't call HI_UNF_DMX_ReleaseTSBuffer, the address of the different buffer block is
+returned and memory leak will be happened, this function must be couple with HI_UNF_DMX_ReleaseTSBuffer.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:getbufferHI_UNF_DMX_ReleaseTSBuffer
+HI_UNF_DMX_ReleaseTSBufferbuffer\n
+\n
+\n
+\n
+buffer\n
+0\n
+u32TimeOutMs00xffffffffu32TimeOutMs\n
+BufferHI_ERR_DMX_TIMEOUT\n
+u32TimeOutMs0BufferTS Bufferusleep(10000)cpu
+CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] u32ReqLen Requested data length.CNcomment:CNend
+\param[out] pstData  Data buffer.CNcomment:bufferCNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:bufferCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBuffer(HI_HANDLE hTsBuffer, HI_U32 u32ReqLen,
+            HI_UNF_STREAM_BUF_S *pstData, HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains a TS buffer to input data.CNcomment:TS BufferCNend
+\attention \n
+If you call this API repeatedly, the address of the same buffer is returned.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:getbuffer\n
+\n
+\n
+\n
+buffer\n
+0\n
+u32TimeOutMs00xffffffffu32TimeOutMs\n
+BufferHI_ERR_DMX_TIMEOUT\n
+u32TimeOutMs0BufferTS Bufferusleep(10000)cpu
+CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] u32ReqLen Requested data length.CNcomment:CNend
+\param[out] pstData  Data buffer.CNcomment:bufferCNend
+\param[out] pu32PhyAddr buffer physical address.CNcomment:bufferCNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:bufferCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferEx(HI_HANDLE hTsBuffer, HI_U32 u32ReqLen,
+            HI_UNF_STREAM_BUF_S *pstData, HI_U32 *pu32PhyAddr, HI_U32 u32TimeOutMs);
+
+/**
+\brief Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TSTS BufferCNend
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, if you call HI_UNF_DMX_PutTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:GetGetPut\n
+Put0\n
+PutGet\n
+PutGet\n
+Put10tsPut\nCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] u32ValidDataLen Valid data length.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_PutTSBuffer(HI_HANDLE hTsBuffer, HI_U32 u32ValidDataLen);
+
+/**
+\brief Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TSTS BufferCNend
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, if you call HI_UNF_DMX_PutTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:GetGetPut\n
+Put0\n
+PutGet\n
+PutGet\n
+Put10tsPut\nCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] u32ValidDataLen Valid data length.CNcomment:CNend
+\param[in] u32StartPos start position of the valid data. CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_PutTSBufferEx(HI_HANDLE hTsBuffer, HI_U32 u32ValidDataLen, HI_U32 u32StartPos);
+
+/**
+\brief Only valid when CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TSTS BufferCNend
+\attention \n
+This API must work after HI_UNF_DMX_GetTSBuffer success. That is, if you call HI_UNF_DMX_PushTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:GetGetPush\n
+Put0\n
+PushGet\n
+PushGet\n
+Push10tsPush\nCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] pstData, the pointer of HI_UNF_STREAM_BUF_S.CNcomment:bufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_PushTSBuffer(HI_HANDLE hTsBuffer, const HI_UNF_STREAM_BUF_S *pstData);
+
+/**
+\brief Only valid when CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y Release the Ts buffer Get by  HI_UNF_DMX_GetTSBuffer.CNcomment:HI_UNF_DMX_GetTSBufferTS buffer
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, you must call HI_UNF_DMX_ReleaseTSBuffer if HI_UNF_DMX_GetTSBuffer has success,
+if not, there will be memory leak happened.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length must be same as the data length queried by calling HI_UNF_DMX_GetTSBuffer.
+CNcomment:GetHI_UNF_DMX_GetTSBufferbuffer
+\n
+ReleaseGet\n
+ReleaseGet\n
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[in] pstData, the pointer of HI_UNF_STREAM_BUF_S.CNcomment:bufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_ReleaseTSBuffer(HI_HANDLE hTsBuffer, const HI_UNF_STREAM_BUF_S *pstData);
+
+/**
+\brief Resets a TS buffer to clear its data.CNcomment:TS BufferTS BufferCNend
+\attention \n
+If a TS buffer is reset, you can call HI_UNF_DMX_PutTSBuffer only after calling HI_UNF_DMX_GetTSBuffer.CNcomment:TS BuffergetputCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_ResetTSBuffer(HI_HANDLE hTsBuffer);
+
+/**
+\brief Obtains the status of a TS buffer. CNcomment:TS BufferCNend
+\attention \n
+You can query the size of a TS buffer and the used buffer size by calling this API. CNcomment:TS BufferCNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[out] pStatus  TS buffer status.CNcomment:TS BufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferStatus(HI_HANDLE hTsBuffer, HI_UNF_DMX_TSBUF_STATUS_S *pStatus);
+
+/**
+\brief Obtains the ID of the port corresponding to a TS buffer.CNcomment:TS BufferPort IDCNend
+\attention \n
+If you query the ID of the port corresponding to a TS buffer that is not applied for successfully, an error code is returned.
+CNcomment:TS buffer,CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\param[out] penPortId  ID of the port.corresponding to a TS buffer  CNcomment:TS BufferPort IDCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferPortId(HI_HANDLE hTsBuffer, HI_UNF_DMX_PORT_E *penPortId);
+
+/**
+\brief Obtains the handle of the TS buffer corresponding to a port ID.CNcomment:Port IDTS Buffer handleCNend
+\attention \n
+If you obtain the handle of a TS buffer that is not created, an error code is returned.CNcomment:TS buffer,CNend
+\param[in] enPortId   Port ID. CNcomment:CNend
+\param[out] phTsBuffer Handle of a TS buffer.CNcomment:TS BufferCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferHandle(HI_UNF_DMX_PORT_E enPortId, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Obtains the information about TS packets of a port.CNcomment:TSCNend
+\attention \n
+If you query the information about an unattached port, an error code is returned.
+CNcomment:,CNend
+\param[in] enPortId    Port ID. CNcomment:CNend
+\param[out] sPortStat   Number of TS packets .CNcomment:TSCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortPacketNum(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_PORT_PACKETNUM_S *sPortStat);
+
+/**
+\brief Obtains the information of a channel.CNcomment:channelCNend
+\attention \n
+\param[in] hChannel    Channel handle. CNcomment:Channel CNend
+\param[out] sChStat   Status of the channel .CNcomment:channelCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelPacketNum(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_PACKETNUM_S *sChStat);
+
+/**
+\brief Obtains the default attributes of a channel.CNcomment:CNend
+\attention \n
+It is recommended to query the default channel attributes before creating a channel, and then modify the attributes.\n
+By default, the attributes of the Section channel are returned. If other channels are used, you need to modify the attributes.
+CNcomment:\n
+sectionCNend
+\param[out] pstChAttr Pointer to the structure of the channel attributes.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelDefaultAttr(HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Creates a PID channel based on channel attributes.CNcomment:PIDCNend
+\attention \n
+It is recommended to call HI_UNF_DMX_GetChannelDefaultAttr to query default channel attributes before calling HI_UNF_DMX_CreateChannel.
+For the Section channel and ECM/EMM channel, you can set the CRC mode, and dynamically change the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+For other channels, the CRC check is always disabled. If you select other CRC modes, the CRC disable mode takes effect by default.\n
+You need to set the buffer size when creating a channel. The buffer size is in the unit of byte and the default size is 16 KB.\n
+It is recommended to set the buffer size to a value greater than 4 KB for the Section channel, ECM/EMM channel, or post channel. If the buffer size is smaller than 4 KB, the size of 4 KB is used by default.\n
+It is recommended to set the buffer size to a value greater than 64 KB for the PES channel. If the buffer size is smaller than 64 KB, the size of 64 KB is used by default.\n
+The playing channel and playing/recording channel cannot be created at the same time./n
+The audio/video playing channels are allocated and managed by the player.
+CNcomment:HI_UNF_DMX_GetChannelDefaultAttr\n
+sectionecm emmCRCCRC\n
+CRCCRCCRC\n
+Buffer16Kbuffer\n
+Sectionecm emmPOSTbuffer4K4K4K\n
+PES64Kbuffer64K64K\n
+\n
+PlayerCNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUXCNend
+\param[in] pstChAttr  Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:::HI_UNF_DMX_CHAN_ATTR_SCNend
+\param[out] phChannel  Pointer to the handle of an allocated channel.CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateChannel(HI_U32 u32DmxId, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr,
+            HI_HANDLE *phChannel);
+
+/**
+\brief Creates or reuse a channel based on PID.CNcomment:PID CNend
+\attention \n
+It is recommended to call HI_UNF_DMX_GetChannelDefaultAttr to query default channel attributes before calling HI_UNF_DMX_CreateChannel.
+For the Section channel and ECM/EMM channel, you can set the CRC mode, and dynamically change the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+For other channels, the CRC check is always disabled. If you select other CRC modes, the CRC disable mode takes effect by default.\n
+You need to set the buffer size when creating a channel. The buffer size is in the unit of byte and the default size is 16 KB.\n
+It is recommended to set the buffer size to a value greater than 4 KB for the Section channel, ECM/EMM channel, or post channel. If the buffer size is smaller than 4 KB, the size of 4 KB is used by default.\n
+It is recommended to set the buffer size to a value greater than 64 KB for the PES channel. If the buffer size is smaller than 64 KB, the size of 64 KB is used by default.\n
+The playing channel and playing/recording channel cannot be created at the same time./n
+The audio/video playing channels are allocated and managed by the player.
+CNcomment:HI_UNF_DMX_GetChannelDefaultAttr\n
+sectionecm emmCRCCRC\n
+CRCCRCCRC\n
+Buffer16Kbuffer\n
+Sectionecm emmPOSTbuffer4K4K4K\n
+PES64Kbuffer64K64K\n
+\n
+PlayerCNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUXCNend
+\param[in] u32Pid  PID. CNcomment: PID CNend
+\param[in] pstChAttr  Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:::HI_UNF_DMX_CHAN_ATTR_SCNend
+\param[out] phChannel  Pointer to the handle of an allocated channel.CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateChannelWithPID(HI_U32 u32DmxId, HI_U32 u32Pid, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr, HI_HANDLE *phChannel);
+
+/**
+\brief Destroys an existing PID channel.CNcomment:PIDCNend
+\attention \n
+If you release an enabled channel, the channel is disabled automatically. If you release a channel that is attached to a filter or key area, the channel is detached from the filter or key area automatically.\n
+However, the filter or key area is not released.\n
+It is recommended to explicitly detach channels by calling corresponding detach APIs. In this way, resources are managed in a unified manner.
+CNcomment:\n
+
+CNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the attributes of a channel.CNcomment:CNend
+\attention \n
+The API can be called only after a channel is allocated.CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:HandleCNend
+\param[out] pstChAttr  Pointer to the attributes of a specified channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:::HI_UNF_DMX_CHAN_ATTR_SCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelAttr(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Sets the attributes of a channel.CNcomment:CNend
+\attention \n
+The API can be called only after a channel is allocated.\n
+You cannot dynamically modify all attributes except the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+To be specific, the CRC mode can be changed dynamically after a channel is created.\n
+If you modify other attributes, the error code HI_ERR_DMX_INVALID_PARA is returned.
+CNcomment:\n
+CRCHI_UNF_DMX_SetChannelAttr\n
+CRC\n
+CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\param[in] pstChAttr    Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.  CNcomment: ::HI_UNF_DMX_CHAN_ATTR_SCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetChannelAttr(HI_HANDLE hChannel, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Sets the PID of a channel.CNcomment:PIDCNend
+\attention \n
+If you set the same PID for two channels of a DEMUX, the PID of the second channel is valid, and the PID of the first channel is changed to 0x1FFF.\n
+You must set the PID of a channel after the channel is disabled.\n
+If you set the PID of a channel to 0x1FFF, the channel cannot receive data. That is, the channel is disabled.
+CNcomment:DEMUXPIDPID0x1fff\n
+PID\n
+PID0x1fff,0x1fffCNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\param[in] u32Pid     Channel PID.CNcomment:PIDCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_OPENING_CHAN  The channel is enabled.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetChannelPID(HI_HANDLE hChannel, HI_U32 u32Pid);
+
+
+/**
+\brief Obtains the PID of a channel.CNcomment:PIDCNend
+\attention \n
+If no PID is set for a channel, the obtained value is 0x1FFF.\n
+You can obtain the channel PID after a channel is created.
+CNcomment:PIDPID0x1fff\n
+PIDCNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\param[out] pu32Pid   Pointer to the PID of a channel (output).CNcomment:PIDCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelPID(HI_HANDLE hChannel, HI_U32 *pu32Pid);
+
+
+/**
+\brief Enables a channel.CNcomment:CNend
+\attention \n
+If you call this API to enable a PID channel that has been enabled, no error occurs.\n
+If you call this API to enable a Section channel that is not attached to a filter, the channel cannot receive data.\n
+If you want to receive data without filter, you can create a filter and then set its filter depth to 0.
+CNcomment:PID\n
+section\n
+filterfilter0CNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_OpenChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Disables a channel.CNcomment:CNend
+\attention \n
+If you this API to disable a PID channel that has been disabled, no error occurs.CNcomment:PIDCNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CloseChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the status of a channel.CNcomment:CNend
+\attention \n
+You can call this API after a channel is created.CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\param[out] pstStatus  Pointer to the status of a channel (output). For details, see the description of ::HI_UNF_DMX_CHAN_STATUS_S.CNcomment:::HI_UNF_DMX_CHAN_STATUS_SCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelStatus(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_STATUS_S *pstStatus);
+
+/**
+\brief Obtains the ts count of a channel.CNcomment:tsCNend
+\attention \n
+You can call this API after a channel is created.CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\param[out] pu32TsCount  Pointer to the count of a channel (output).CNcomment:tsCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+ */
+HI_S32 HI_UNF_DMX_GetChannelTsCount(HI_HANDLE hChannel, HI_U32 *pu32TsCount);
+
+
+
+/**
+\brief Obtains the handle of the channel with a specific PID.CNcomment:PIDCNend
+\attention \n
+You must specify the DEMUX ID when calling this API, because the channel PIDs of different DEMUXs can be the same.\n
+You cannot query the PID that is equal to or greater than 0x1FFF; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If no channel with a specific PID is found, an error code is returned.
+CNcomment:DEMUXPIDDEMUX ID\n
+0x1fffPID\n
+PIDCNend
+\param[in] u32DmxId    DEMUX ID. CNcomment: DEMUXCNend
+\param[in] u32Pid      Channel PID.CNcomment:PIDCNend
+\param[out] phChannel Pointer to channel handle.CNcomment: HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_UNMATCH_CHAN  No matched channel is found.CNcomment:CNend
+\retval ::HI_ERR_DMX_OCCUPIED_PID  The same pid was found on multiple channels.CNcomment:PIDCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelHandle(HI_U32 u32DmxId , HI_U32 u32Pid, HI_HANDLE *phChannel);
+
+
+/**
+\brief Obtains the number of available channels of a DEMUX.CNcomment:DEMUXCNend
+\attention \n
+The returned number is the number of all remaining channels including the used audio/video channels.\n
+Because channels are allocated in a unified manner, the parameter u32DmxId is invalid.
+CNcomment:\n
+u32DmxIdCNend
+\param[in] u32DmxId         DEMUX ID. CNcomment: DEMUXCNend
+\param[out] pu32FreeCount   Pointer to the number of available channels of a DEMUX.CNcomment:DEMUXCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeChannelCount (HI_U32 u32DmxId, HI_U32 *pu32FreeCount);
+
+
+/**
+\brief Obtains the scrambled flag of the channel data.CNcomment:CNend
+\attention \n
+You can query the scrambled PES data and ES data.CNcomment:PESTSCNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\param[out] penScrambleFlag   Pointer to the scrambled flag of the channel data (output). For details, see the description of ::HI_UNF_DMX_SCRAMBLED_FLAG_E.CNcomment:::HI_UNF_DMX_SCRAMBLED_FLAG_ECNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetScrambledFlag(HI_HANDLE hChannel, HI_UNF_DMX_SCRAMBLED_FLAG_E *penScrambleFlag);
+
+/**
+\brief Creates a data filter.CNcomment:CNend
+\attention \n
+The maximum depth of a filter is 16 bytes.\n
+For details on how to set the attributes of a filter, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.\n
+You can set a filter when creating it. If you do not want to filter data, you can set the filter depth to 0.\n
+To modify the attributes of a filter, call HI_UNF_DMX_SetFilterAttr.\n
+The attributes can be modified dynamically.\n
+If a filter is used to filter the Section data, the valid byte is byte 1 and byte 4 to byte 18.\n
+If a filter is used to filter the PES data, the valid byte is byte 4 and byte 7 to byte 21.\n
+The filter can be used to filter the data of general-purpose channels only, including the Section channel, ECM/EMM channel, and PES channel.\n
+If a filter is allocated successfully, phFilter returns the handle of the created filter.
+CNcomment:16\n
+::HI_UNF_DMX_FILTER_ATTR_S\n
+0\n
+HI_UNF_DMX_SetFilterAttr\n
+\n
+Section1418\n
+PES4721\n
+sectionECM/EMMPES\n
+phFilterHandleCNend
+\param[in] u32DmxId    DEMUX ID. CNcomment: DEMUXCNend
+\param[in] pstFilterAttr   Pointer to the attributes of a filter (input).CNcomment:CNend
+\param[out] phFilter   Pointer to the handle of the created filter (output).CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_FILTER There is no available filter.CNcomment:filterCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateFilter(HI_U32 u32DmxId, const HI_UNF_DMX_FILTER_ATTR_S  *pstFilterAttr,
+            HI_HANDLE *phFilter);
+
+
+/**
+\brief Destroys an existing data filter.CNcomment:CNend
+\attention \n
+If a filter is attached to a general-purpose channel, you can call this API to release the filter when the channel is enabled or disabled.\n
+If no filter is attached to a Section channel, the channel cannot receive data. This restriction is not applicable to other channels.
+CNcomment:\n
+sectionCNend
+\param[in] hFilter  Filter handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyFilter(HI_HANDLE hFilter);
+
+
+/**
+\brief Releases all the filters attached to a channel.CNcomment:CNend
+\attention \n
+You can call this API to release all filters attached to a channel when the channel is enabled or disabled.CNcomment:CNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is valid.CNcomment:CNend
+\see \n
+N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DeleteAllFilter(HI_HANDLE hChannel);
+
+
+/**
+\brief Sets the filter criteria of a filter.CNcomment:CNend
+\attention \n
+The maximum filter depth u32FilterDepth is 16.\n
+For details on how to set the attributes of a filter, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.\n
+If a filter is used to filter the Section data, the valid byte is byte 1 and byte 4 to byte 18.\n
+If a filter is used to filter the PES data, the valid byte is byte 4 and byte 7 to byte 21.\n
+The attributes can be modified dynamically.
+CNcomment:u32FilterDepth16\n
+::HI_UNF_DMX_FILTER_ATTR_S\n
+Section1418\n
+PES4721\n
+CNend
+\param[in] hFilter   Filter handle.CNcomment:CNend
+\param[in] pstFilterAttr   Pointer to the attributes of a filter (input).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_ATTACHED_FILTER  The attributes cannot be set dynamically, because the filter is attached to a channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetFilterAttr(HI_HANDLE hFilter, const HI_UNF_DMX_FILTER_ATTR_S *pstFilterAttr);
+
+
+/**
+\brief Obtains the filter criteria of a filter.CNcomment:CNend
+\attention \n
+If you call the API before a filter is allocated, an error code is returned.
+CNcomment:CNend
+\param[in] hFilter   Filter handle.CNcomment:CNend
+\param[out] pstFilterAttr   Pointer to the attributes of a filter (output). For details, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.CNcomment:::HI_UNF_DMX_FILTER_ATTR_SCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetFilterAttr(HI_HANDLE hFilter, HI_UNF_DMX_FILTER_ATTR_S *pstFilterAttr);
+
+
+/**
+\brief  Attaches filters to a specific channel.CNcomment:CNend
+\attention \n
+One or more filters can be attached to a general-purpose channel. All filters are ORed.\n
+That is, if the data meets the filter criteria of a filter, the data is transmitted to the DMA buffer.\n
+Filters cannot be attached to the audio/video channel and post channel.\n
+If a filter is used, it cannot be attached to one or more channels repeatedly.\n
+If a filter and a channel do not belong to the same DEMUX, the filter cannot be detached from the channel.\n
+A filter can be attached to a general-purpose channel when the channel is enabled or disabled.
+CNcomment:\n
+DMA\n
+POST\n
+\n
+DEMUX\n
+CNend
+\param[in] hFilter  Filter handle.CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_ATTACHED_FILTER  The filter is attached.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT   No filter can be attached to the channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_AttachFilter(HI_HANDLE hFilter, HI_HANDLE hChannel);
+
+
+
+/**
+\brief Detaches a filter from a specific channel.CNcomment:CNend
+\attention \n
+If no filter is attached to a channel, the error code HI_FAILURE is returned when you call this API.\n
+If a filter and a channel do not belong to the same DEMUX, an error code is returned.\n
+A filter can be detached from a general-purpose channel when the channel is enabled or disabled.
+CNcomment:\n
+DEMUX\n
+CNend
+\param[in] hFilter   Filter handle.CNcomment:CNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOATTACH_FILTER  No filter is attached to any channel.CNcomment:filterCNend
+\retval ::HI_ERR_DMX_UNMATCH_FILTER  No filter is attached to the channel.CNcomment:filterCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DetachFilter(HI_HANDLE hFilter, HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the handle of the channel to which a filter is attached.CNcomment:CNend
+\attention \n
+Each filter corresponds to a channel. If a filter is not attached to a channel, the error code HI_ERR_DMX_NOATTACH_FILTER is returned.CNcomment:HI_ERR_DMX_NOATTACH_FILTERCNend
+\param[in] hFilter    Filter handle.CNcomment:CNend
+\param[out] phChannel   Pointer to the handle of the channel to which a filter is attached (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOATTACH_FILTER  No filter is attached to any channel.CNcomment:filterCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetFilterChannelHandle(HI_HANDLE hFilter, HI_HANDLE *phChannel);
+
+
+/**
+\brief Obtains the number of available filters of a DEMUX.CNcomment:DEMUXCNend
+\attention \n
+The number of unallocated filters is returned. The filters that are allocated but not attached to channels are excluded.
+CNcomment:CNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUXCNend
+\param[out]  pu32FreeCount  Pointer to the number of allocated filters (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeFilterCount(HI_U32 u32DmxId ,  HI_U32 * pu32FreeCount);
+
+
+/**
+\brief Obtains the handles of all channels that receive new data.CNcomment:CNend
+\attention \n
+When you call this API, the parameter pu32ChNum serves as the input parameter and is used to specify the data length pointed by phChannel. pu32ChNum indicates the number of channels to be queried.\n
+The number of channels must be initialized, and the initial value cannot be 0.\n
+It is recommended to set the number of channels to the total number. For details about the total number of channels.\n
+After you call this API successfully, the parameter pu32ChNum serves as the output parameter and is used to specify the valid data length pointed by phChannel.\n
+The block time is configurable (in ms). If u32TimeOutMs is set to 0, it indicates that the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait.\n
+If no data is received when the block time is exceeded, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If the wait time is 0, and no data is received in any channel, ::HI_ERR_DMX_NOAVAILABLE_DATA is returned.
+CNcomment:pu32ChNumphChannel\n
+0\n
+\n
+pu32ChNumphChannel\n
+00xffffffff\n
+\n
+0::HI_ERR_DMX_NOAVAILABLE_DATACNend
+\param[out] phChannel      Pointer to the number of channels. The number of channels depends on the value of pu32ChNum.CNcomment:pu32ChNumCNend
+\param[in] pu32ChNum    Pointer type
+                           Input: indicates the number of channel handles to which pChannelHandle points.
+                           Output: indicates the number of lower-layer channels that receive new data. The maximum value cannot be greater than the input value.
+                           CNcomment: :CNend
+                           CNcomment: pChannelHandleCNend
+                           CNcomment: CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  No data is received in any channel.CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_GetDataHandle(HI_HANDLE *phChannel, HI_U32 *pu32ChNum,
+            HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains whether data is received in some channels.CNcomment:CNend
+\attention \n
+This API is a supplementary interface of ::HI_UNF_DMX_GetDataHandle. You can call this API when you only want to check whether data is received in some channels.
+The handles of the channels to be queried are specified by phWatchChannel, and the number of channels to be queried is specified by u32WatchNum.\n
+If phWatchChannel is NULL, all channels are queried. The value of u32WatchNum cannot be 0.\n
+The block time is configurable (in ms). If u32TimeOutMs is set to 0, it indicates that the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait.\n
+If no data is received when the block time is exceeded, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If the wait time is 0, and no data is received in any channel, ::HI_ERR_DMX_NOAVAILABLE_DATA is returned.
+CNcomment:::HI_UNF_DMX_GetDataHandle\n
+phWatchChannelu32WatchNum\n
+phWatchChannelNULL,u32WatchNum0\n
+00xffffffff\n
+\n
+0::HI_ERR_DMX_NOAVAILABLE_DATACNend
+\param[in] phWatchChannel   Pointer to the number of handles of the channels to be queried. The number depends on the value of u32WatchNum.CNcomment:u32WatchNumCNend
+\param[in] u32WatchNum      Number of channels to be queried.CNcomment:CNend
+\param[in] phDataChannel    Pointer to the number of handles of the channels that contain data The number depends on the value of pu32ChNum.CNcomment:pu32ChNumCNend
+\param[out] pu32ChNum       Pointer to the number of lower-layer channels that receive new data. The maximum value cannot be greater than the input value.CNcomment:CNend
+\param[in] u32TimeOutMs     Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR   The pointer is null.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA   No data is received in any channel.CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT   The wait times out.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_SelectDataHandle(HI_HANDLE *phWatchChannel, HI_U32 u32WatchNum,
+            HI_HANDLE *phDataChannel, HI_U32 *pu32ChNum, HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains the received data packets from a specific channel.CNcomment:CNend
+\attention \n
+Before calling this API, you need to set the value of u32AcquireNum to specify the maximum number of buffers that can be queried. The number of buffers depends on the value of u32AcquireNum.\n
+The value of pu32AcquiredNum is not greater than that of u32AcquireNum.\n
+For the Section channel, ECM channel, or EMM channel, each data packet contains a complete Section.\n
+For the PES channel, each data packet may contain a complete PES. If the PES is too large, it is divided into multiple PES packets to transfer.\n
+The enDataType field determines whether a transferred data packet is complete.\n
+For the post channel, each data packet may contain one or more complete TS packets. Each TS packet consists of 188 bytes.\n
+For the audio/video channel, data cannot be obtained by calling this API. The audio data and video data are transferred to the decoder through internal interfaces.
+You cannot call this API repeatedly, but you can call this API once and release buffers for several times. Note that you must release buffers in sequence, and the address and size of the buffer to be released must be consistent with those obtained by calling HI_UNF_DMX_AcquireBuf.
+In addition, you can call HI_UNF_DMX_AcquireBuf again only after all data packets are released. Otherwise, the error code HI_ERR_DMX_REACQUIRE_BUF is returned.
+CNcomment:u32AcquireNumu32AcquireNum\n
+pu32AcquiredNumu32AcquireNum\n
+sectionECM/EMMsection\n
+PESpespespes\n
+enDataType\n
+POSTTSTS188\n
+\n
+\n
+CNend
+\param[in] hChannel            Channel handle.CNcomment:CNend
+\param[in] u32AcquireNum       Maximum number of obtained data packets.CNcomment:CNend
+\param[out] pu32AcquiredNum    Pointer to the actual number of obtained data packets.CNcomment:CNend
+\param[out] pstBuf             Pointer to the number of data packets. The number depends on the value of pu32AcquiredNum.CNcomment:pu32AcquiredNumCNend
+\param[in] u32TimeOutMs        Wait timeout, in ms.CNcomment:msCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  There is no valid data in the channel.CNcomment:CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out.CNcomment:CNend
+\retval ::HI_ERR_DMX_REACQUIRE_BUF  The data packet has been obtained.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireBuf(HI_HANDLE hChannel, HI_U32 u32AcquireNum,
+            HI_U32 * pu32AcquiredNum, HI_UNF_DMX_DATA_S *pstBuf,
+            HI_U32 u32TimeOutMs);
+
+
+/**
+\brief Releases the buffers for storing data packets after data packets are processed.CNcomment:CNend
+\attention \n
+If you release buffers by calling this API, the buffers must be those obtained by calling ::HI_UNF_DMX_AcquireBuf, and the addresses and sizes of these buffers cannot be changed.\n
+The number of released buffers can be less than the number of obtained buffers.
+CNcomment:::HI_UNF_DMX_AcquireBuf\n
+CNend
+\param[in] hChannel        Channel handl.CNcomment:CNend
+\param[in] u32ReleaseNum   Number of released buffers.CNcomment:CNend
+\param[in] pstBuf          Pointer to the number of released buffers. The number depends on the value of u32ReleaseNum.CNcomment:u32ReleaseNumCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseBuf(HI_HANDLE hChannel, HI_U32 u32ReleaseNum,
+            HI_UNF_DMX_DATA_S *pstBuf);
+
+/**
+\brief Obtains the received es data packets from a specific channel.CNcomment:esCNend
+\attention \n
+You can call this API to obtain video or audio es data.\n
+It's allowed to call repeatedly and then release in the same order.
+CNcomment:es.\n
+CNend
+\param[in] hChannel            Channel handle.CNcomment:CNend
+\param[out] pEsBuf             Pointer to the es data packets.CNcomment:esCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  There is no valid data in the channelCNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_AcquireEs(HI_HANDLE hChannel, HI_UNF_ES_BUF_S *pEsBuf);
+
+/**
+\brief Releases the es buffers after processed.CNcomment:esbufferCNend
+\attention \n
+If you release buffers by calling this API, the buffers must be those obtained by calling ::HI_UNF_DMX_AcquireEs, and the addresses and sizes of these buffers cannot be changed.
+CNcomment:::HI_UNF_DMX_AcquireEs.CNend
+\param[in] hChannel        Channel handl.CNcomment:CNend
+\param[in] pEsBuf          Pointer to the es data packets.CNcomment:esCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_ReleaseEs(HI_HANDLE hChannel, const HI_UNF_ES_BUF_S *pEsBuf);
+
+/**
+\brief Creates a record channel. CNcomment: CNend
+\attention \n
+A demux can be set only one recording channe.
+CNcomment: DEMUXCNend
+\param[in]  pstRecAttr  record attribute.   CNcomment: CNend
+\param[out] phRecChn    record handle.      CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel. CNcomment: CNend
+\retval ::HI_ERR_DMX_ALLOC_MEM_FAILED  memory allocate failure. CNcomment: CNend
+\retval ::HI_ERR_DMX_MMAP_FAILED  memory map failed. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_CreateRecChn(HI_UNF_DMX_REC_ATTR_S *pstRecAttr, HI_HANDLE *phRecChn);
+
+/**
+\brief Destroys an existing record channel. CNcomment: CNend
+\attention \n
+ N/A. CNcomment: CNend
+\param[in] hRecChn  record handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_DestroyRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would increase the recorded PID that we need. CNcomment: HI_UNF_DMX_REC_TYPE_SELECT_PIDPIDCNend
+\attention \n
+ N/A. CNcomment: CNend
+\param[in]  hRecChn     record handle.  CNcomment: CNend
+\param[in]  u32Pid      pid value.      CNcomment: PIDCNend
+\param[out] phChannel   channel handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AddRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid, HI_HANDLE *phChannel);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would delete increase PID. CNcomment: HI_UNF_DMX_REC_TYPE_SELECT_PIDPIDCNend
+\attention \n
+ N/A. CNcomment: CNend
+\param[in]  hRecChn     record handle.  CNcomment: CNend
+\param[in]  hChannel    channel handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_DelRecPid(HI_HANDLE hRecChn, HI_HANDLE hChannel);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would delete all increase PID. CNcomment: HI_UNF_DMX_REC_TYPE_SELECT_PIDPIDCNend
+\attention \n
+ N/A. CNcomment: CNend
+\param[in] hRecChn  record handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_DelAllRecPid(HI_HANDLE hRecChn);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would remove the specified PID. CNcomment: HI_UNF_DMX_REC_TYPE_ALL_PIDPIDCNend
+\attention \n
+chips do not support the function.
+CNcomment: CNend
+\param[in]  hRecChn record handle.  CNcomment: CNend
+\param[in]  u32Pid  pid value.      CNcomment: PIDCNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AddExcludeRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would cancel the PID that have been removed. CNcomment: HI_UNF_DMX_REC_TYPE_ALL_PIDPIDCNend
+\attention \n
+chips do not support the function.
+CNcomment: CNend
+\param[in]  hRecChn record handle.  CNcomment: CNend
+\param[in]  u32Pid  pid value.      CNcomment: PIDCNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_DelExcludeRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would cancel all the PID that have been removed. CNcomment: HI_UNF_DMX_REC_TYPE_ALL_PIDPIDCNend
+\attention \n
+chips do not support the function.
+CNcomment: CNend
+\param[in] hRecChn  record handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_DelAllExcludeRecPid(HI_HANDLE hRecChn);
+
+/**
+\brief Starts a recording channel. CNcomment: CNend
+\attention \n
+when the recording channel has been activated, it should use the interface to come back success.
+CNcomment: CNend
+\param[in] hRecChn  record handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_StartRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief Stops a recording channel. CNcomment: CNend
+\attention \n
+when the recording channel has been stopped, it should use the interface to come back success.
+CNcomment: CNend
+\param[in] hRecChn  record handle. CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_StopRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief Obtains record data. CNcomment: CNend
+\attention \n
+The obtained data must use the ::HI_UNF_DMX_ReleaseRecData function to release.
+CNcomment: ::HI_UNF_DMX_ReleaseRecDataCNend
+\param[in]  hRecChn         record handle.          CNcomment: CNend
+\param[out] pstRecData      record data.            CNcomment: CNend
+\param[in]  u32TimeOutMs    Wait timeout, in ms.    CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecData(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_S *pstRecData, HI_U32 u32TimeoutMs);
+
+/**
+\brief Releases record data. CNcomment: CNend
+\attention \n
+ N/A. CNcomment:CNend
+\param[in] hRecChn      record handle.  CNcomment: CNend
+\param[in] pstRecData   record data.    CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseRecData(HI_HANDLE hRecChn, const HI_UNF_DMX_REC_DATA_S *pstRecData);
+
+/**
+\brief Obtains index data. CNcomment: CNend
+\attention \n
+when indexing video or audio, it would use the interface to gain indexing data, or it will not support if you return.
+CNcomment: CNend
+\param[in]  hRecChn         record handle.          CNcomment: CNend
+\param[out] pstRecIndex     index data.             CNcomment: CNend
+\param[in]  u32TimeOutMs    Wait timeout, in ms.    CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_START_REC_CHAN  CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  no data. CNcomment: CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_INDEX_S *pstRecIndex, HI_U32 u32TimeoutMs);
+
+/**
+\brief Obtains index and rec data with synchronous. CNcomment:  CNend
+\attention \n
+1. when indexing video or audio, it would use the interface to gain indexing data and record TS data with synchronous, \n
+2. when recording all ts without index, .it would use the interface to gain only record TS data, as there is no index. \n
+3. Length of each block of record data is Alligned with 188 and 16 if it is not 0.
+CNcomment:
+1. TS\n
+2.allts TS\n
+3. 0188  16 CNend
+\param[in]  hRecChn         record handle.          CNcomment: CNend
+\param[out] pstRecDataIdx     index and record data.             CNcomment: TSCNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_START_REC_CHAN  CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  no data. CNcomment: CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecDataAndIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_INDEX_S* pstRecDataIdx);
+
+/**
+\brief Releases record data. CNcomment: CNend
+\attention \n
+ N/A. CNcomment:CNend
+\param[in] hRecChn      record handle.  CNcomment: CNend
+\param[in] pstRecDataIdx   record data and index.    CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_MDX_REC_BUFNOTMATCH  The param is not mattched . CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseRecDataAndIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_INDEX_S* pstRecDataIdx);
+/**
+\brief Obtains the status of a record buffer. CNcomment: CNend
+\attention \n
+ N/A. CNcomment:CNend
+\param[in]  hRecChn         record handle.          CNcomment: CNend
+\param[out] pstBufStatus    record buffer status.   CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+*/
+HI_S32  HI_UNF_DMX_GetRecBufferStatus(HI_HANDLE hRecChn, HI_UNF_DMX_RECBUF_STATUS_S *pstBufStatus);
+
+/**
+\brief register channel callback .CNcomment:CNend
+\attention \n
+ N/A. CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:HandleCNend
+\param[out] pstCbDesc  Pointer to the descriptor of a specified cb. For details, see the description of HI_UNF_DMX_CB_DESC_S.CNcomment: ::HI_UNF_DMX_CB_DESC_SCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_RegisterCallback(HI_HANDLE hChannel, HI_UNF_DMX_CB_DESC_S *pstCbDesc);
+
+/**
+\brief unregister channel callback.CNcomment:CNend
+\attention \n
+ N/A. CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_UnRegisterCallback(HI_HANDLE hChannel);
+
+/**
+\brief Set or get the extra attributes of a demux through the commands.CNcomment:DMXCNend
+\attention \n
+Diffrent CMD use diffrent param, for details see the description of HI_UNF_DMX_INVOKE_TYPE_E.\n
+CNcomment:HI_UNF_DMX_INVOKE_TYPE_E\n CNend
+\param[in] enCmd   Command type.CNcomment:CNend
+\param[in] pCmdPara    Pointer to command param.  CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A. CNcomment:CNend
+ */
+HI_S32 HI_UNF_DMX_Invoke(HI_UNF_DMX_INVOKE_TYPE_E enCmd, const HI_VOID *pCmdPara);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif  /* __HI_UNF_DEMUX_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_descrambler.h b/xbmc/platform/linux/hisi/hi_unf_descrambler.h
new file mode 100644
index 0000000000..5094a08896
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_descrambler.h
@@ -0,0 +1,360 @@
+/******************************************************************************
+ Copyright (C), 2009-2014, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : hi_unf_descrambler.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 2013/04/16
+ Description   :
+******************************************************************************/
+
+#ifndef __HI_UNF_DESCRAMBLER_H__
+#define __HI_UNF_DESCRAMBLER_H__
+
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Descrambler */
+/** @{ */  /** <!-- [Descrambler] */
+
+/**Conditional access (CA) type, indicating whether advanced CA is used.*/
+/**CNcomment:CACA*/
+typedef enum hiUNF_DMX_CA_TYPE_E
+{
+    HI_UNF_DMX_CA_NORMAL = 0,    /**<Common CA*/ /**< CNcomment:CA*/
+    HI_UNF_DMX_CA_ADVANCE,       /**<Advanced CA*/ /**< CNcomment:CA*/
+
+    HI_UNF_DMX_CA_BUTT
+} HI_UNF_DMX_CA_TYPE_E;
+
+/**CA Entropy reduction mode*/
+/**CNcomment:*/
+typedef enum hiUNF_DMX_CA_ENTROPY_REDUCTION_E
+{
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_CLOSE = 0,  /**<64bit*/
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_OPEN,       /**<48bit*/
+
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_BUTT
+} HI_UNF_DMX_CA_ENTROPY_E;
+
+
+/**Type of the descrambler protocol.*/
+/**CNcomment:*/
+typedef enum hiUNF_DMX_DESCRAMBLER_TYPE_E
+{
+    HI_UNF_DMX_DESCRAMBLER_TYPE_CSA2      = 0,       /**<CSA2.0*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_CSA3      ,          /**<CSA3.0*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_IPTV  ,          /**<AES IPTV of SPE*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_ECB   ,          /**<SPE AES ECB*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CI    ,          /**<SPE AES CIPLUS*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_CI    ,          /**<DES CIPLUS*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_CBC   ,          /**<DES CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_NS    ,          /**<AES NS-Mode, AES NOVEL*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_NS   ,          /**<SMS4 NS-Mode, SMS4 NOVEL*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_IPTV ,          /**<SMS4 IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_ECB  ,          /**<SMS4 ECB*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_CBC  ,          /**<SMS4 CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC   ,          /**<AES CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_IPTV,            /**<DES IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_IPTV,           /**<TDES IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_ECB,            /**<TDES ECB */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_CBC,            /**<TDES CBC */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_ECB_L,           /**<AES_ECB_L the clear stream left in the leading */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC_L,           /**<AES_CBC_L the clear stream left in the leading */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_ASA,                 /**<ASA 64/128 Algorithm */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CISSA,           /**<Common IPTV Software-oriented Scrambling Algorithm (CISSA) */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC_IDSA,        /**<AES128 CBC Payload / ATIS IIF Default Scrambling Algorithm (IDSA), the difference between AES_CBC_IDSA and AES_IPTV is AES_CBC_IDSA only support 0 IV */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CTR,             /**<AES CTR */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_BUTT
+} HI_UNF_DMX_DESCRAMBLER_TYPE_E;
+
+/**Attribute of the key area.*/
+/**CNcomment:*/
+typedef struct hiUNF_DMX_DESCRAMBLER_ATTR_S
+{
+    HI_UNF_DMX_CA_TYPE_E enCaType;                    /**<Whether the descrambler adopts advanced CA.*/ /**< CNcomment:CA*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_E enDescramblerType;  /**<Descrambling protocol type of the descrambler*/ /**< CNcomment:*/
+    HI_UNF_DMX_CA_ENTROPY_E enEntropyReduction;       /**<CA Entropy reduction mode,for CSA2.0*/ /**< CNcomment:CSA2.0*/
+} HI_UNF_DMX_DESCRAMBLER_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      Descrambler */
+/** @{ */  /** <!--[Descrambler]*/
+
+/**
+\brief Creates a key area.CNcomment:CNend
+\attention \n
+When creating a key area, you can ignore the DUMUX to which the key area belongs, because all DEMUXs share all key areas.
+CNcomment:DEMUXDEMUXCNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUXCNend
+\param[out] phKey     Pointer to the handle of a created key area.CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY There is no available key area. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateDescrambler(HI_U32 u32DmxId, HI_HANDLE *phKey);
+
+
+/**
+\brief Creates a key area. The key area type and descrambling protocol type can be selected.CNcomment:,CACNend
+\attention \n
+When an advanced CA key area is created, the descrambling protocol depends on the hardware and interface settings are ignored.\n
+CNcomment:CACNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUXCNend
+\param[in] pstDesramblerAttr  Pointer to the attributes of a key area.CNcomment:CNend
+\param[out] phKey      Pointer to the handle of a created key area.CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:HI_UNF_DMX_DESCRAMBLER_ATTR_SCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_CreateDescramblerExt(HI_U32 u32DmxId, const HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstDesramblerAttr, HI_HANDLE *phKey);
+
+/**
+\brief Destroys an existing key area.CNcomment:CNend
+\attention \n
+If a key area is attached to a channel, the key area needs to be detached from the channel first, but the channel is not disabled.\n
+If a key area is detached or destroyed before the attached channel is disabled, an error may occur during data receiving.
+CNcomment:\n
+CNend
+\param[in] hKey  Handle of the key area to be destroyed.CNcomment:HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyDescrambler(HI_HANDLE hKey);
+
+/**
+\brief Gets the attributes of a Descrambler.CNcomment:CNend
+\attention \n
+NA.\n
+CNcomment:CNend
+\param[in] hKey   key handle. CNcomment: keyCNend
+\param[out] pstAttr  Pointer to the attributes of a key area.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:HI_UNF_DMX_DESCRAMBLER_ATTR_SCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetDescramblerAttr(HI_HANDLE hKey, HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the attributes of a Descrambler.CNcomment:CNend
+\attention \n
+NA.\n
+CNcomment:CNend
+\param[in] hKey   key handle. CNcomment: keyCNend
+\param[out] pstAttr  Pointer to the attributes of a key area.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:HI_UNF_DMX_DESCRAMBLER_ATTR_SCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerAttr(HI_HANDLE hKey, HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the even keys of a key area. This API is used to configure the DEMUX descrambler based on even keys after the CA system obtains control words.CNcomment:CADEMUXCNend
+\attention \n
+pEvenKey points to the even key data to be set. The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.\n
+The initial value of each key is 0, which indicates that data is not descrambled.
+CNcomment:pEvenKey16bytebyteCW1CW2CW16\n
+\n
+0CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:CNend
+\param[in] pu8EvenKey  Pointer to the 16-byte even key data to be set.CNcomment:16CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerEvenKey(HI_HANDLE hKey, const HI_U8 *pu8EvenKey);
+
+
+/**
+\brief Sets the odd keys of a key area. This API is used to configure the DEMUX descrambler based on odd keys after the CA system obtains control words.CNcomment:CADEMUXCNend
+\attention \n
+pOddKey points to the odd key data to be set. The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.\n
+The initial value of each key is 0, which indicates that data is not descrambled.
+CNcomment:pOddKey16bytebyteCW1CW2CW16\n
+\n
+0CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:CNend
+\param[in] pu8OddKey   Pointer to the 16-byte odd key data to be set.CNcomment:16CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerOddKey(HI_HANDLE hKey, const HI_U8 *pu8OddKey);
+
+
+/**
+\brief Set Even IV.For algs do not use IV,do not care.CNcomment:CNend
+\attention \n
+pu8IVKey points to the iv key data to be set.The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.
+CNcomment:pu8IVKey16bytebyteCW1CW2CW16\n
+CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:CNend
+\param[in] pu8IVKey   Pointer to the 16-byte IV key data to be set.CNcomment:16CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerEvenIVKey(HI_HANDLE hKey, const HI_U8 *pu8IVKey);
+
+/**
+\brief Set Odd IV.For algs do not use IV,do not care.CNcomment:CNend
+\attention \n
+pu8IVKey points to the iv key data to be set.The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.
+CNcomment:pu8IVKey16bytebyteCW1CW2CW16\n
+CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:CNend
+\param[in] pu8IVKey    Pointer to the 16-byte IV key data to be set.CNcomment:16CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerOddIVKey(HI_HANDLE hKey, const HI_U8 *pu8IVKey);
+
+/**
+\brief Attaches a key area to a specific channel.CNcomment:CNend
+\attention \n
+A key area can be attached to multiple channels that belong to different DEMUXs.\n
+The static loading data in the key areas that are attached to all types of channels can be descrambled.\n
+The same key area or different key areas cannot be attached to the same channel.
+CNcomment:DEMUX\n
+\n
+CNend
+\param[in] hKey    Handle of the key area to be attached.CNcomment:CNend
+\param[in] hChannel   Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_ATTACHED_KEY  A key area is attached to the channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_AttachDescrambler(HI_HANDLE hKey, HI_HANDLE hChannel);
+
+
+/**
+\brief Detaches a key area from a channel.CNcomment:CNend
+\attention \n
+The key area used by a channel can be detached dynamically. That is, you can call this API to detach a key area at any time after it is attached.\n
+The scrambled data, however, may not be descrambled after the key area is detached, which causes data error.\n
+The value of a key area retains even after it is detached. If the key area is attached again, its value is still the previously configured value.\n
+If you do not want to descramble data, you can detach the corresponding key area or set all key values to 0.
+CNcomment:\n
+\n
+\n
+0CNend
+\param[in] hKey    Handle of the key area to be detached.CNcomment:CNend
+\param[in] hChannel  Channel handle.CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOATTACH_KEY  No key areas are attached to the channel.CNcomment:CNend
+\retval ::HI_ERR_DMX_UNMATCH_KEY  The specified key area is not attached to the specified channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_DetachDescrambler(HI_HANDLE hKey, HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the handle of the key area that is attached to a channel.CNcomment:CNend
+\attention \n
+If no key area is attached to the channel, the error code HI_ERR_DMX_NOATTACH_KEY is returned when you call this API.
+CNcomment:HI_ERR_DMX_NOATTACH_KEYCNend
+\param[in] hChannel  Handle of the channel to be queried.CNcomment:CNend
+\param[out] phKey     Pointer to the handle of the key area that is attached to a channel (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_DMX_NOATTACH_KEY  No key areas are attached to the channel.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetDescramblerKeyHandle(HI_HANDLE hChannel, HI_HANDLE *phKey);
+
+
+/**
+\brief Obtains the number of available key areas.CNcomment:CNend
+\attention \n
+Because key areas are shared by multiple DEMUXs, the first parameter is meaningless. Therefore, you only need to enter a valid value.CNcomment:DEMUXCNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUXCNend
+\param[out]  pu32FreeCount   Pointer to the number of available key areas (output).CNcomment:CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeDescramblerKeyCount(HI_U32 u32DmxId , HI_U32 * pu32FreeCount);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif  /* __HI_UNF_DESCRAMBLER_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_disp.h b/xbmc/platform/linux/hisi/hi_unf_disp.h
new file mode 100644
index 0000000000..265bed0608
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_disp.h
@@ -0,0 +1,1588 @@
+/******************************************************************************
+
+   Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_disp.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2009/12/15
+   Description   :
+   History       :
+   1.Date        : 2009/12/15
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+
+/**
+ * \file
+ **\brief : define DISPLAY module information
+ * \brief supply infor about display.
+ */
+
+#ifndef  __HI_UNF_DISP_H__
+#define  __HI_UNF_DISP_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_hdmi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+/**enum define about DISPLAY channel*/
+/**CNcomment:DISPLAY*/
+typedef enum hiUNF_DISP_E
+{
+    HI_UNF_DISPLAY0 = 0x0,  /**< DISPLAY0,Compatible with SD */ /**<CNcomment:DISPLAY0 */
+    HI_UNF_DISPLAY1,        /**< DISPLAY1 *//**<CNcomment: DISPLAY1 */
+    HI_UNF_DISPLAY2,        /**< DISPLAY2 *//**<CNcomment: DISPLAY2 */
+    HI_UNF_DISPLAY_BUTT
+}HI_UNF_DISP_E;
+
+/**max DAC count*/
+/**CNcomment:DAC*/
+#define MAX_DAC_NUM ( 6 )
+
+/**define the LCD data format*/
+/**CNcomment:LCD*/
+typedef enum hiHI_UNF_DISP_INTF_DATA_FMT
+{
+    HI_UNF_DISP_INTF_DATA_FMT_YUV422   = 0,         /**<YUV422,data width is 16*//**<CNcomment:YUV42216*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB565   = 0x8,       /**<RGB565,data width is 16*//**<CNcomment:RGB56516*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB444   = 0xa,       /**<RGB444,data width is 16*//**<CNcomment:RGB44416*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB666   = 0xb,       /**<RGB666,data width is 24*//**<CNcomment:RGB66624*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB888   = 0xc,       /**<RGB888,data widht is 24*//**<CNcomment:RGB88824*/
+    HI_UNF_DISP_INTF_DATA_FMT_BUTT
+}HI_UNF_DISP_INTF_DATA_FMT_E;
+
+/**define LCD output data width*/
+/**CNcomment:LCD*/
+typedef enum hiUNF_DISP_INTF_DATA_WIDTH_E
+{
+    HI_UNF_DISP_INTF_DATA_WIDTH8 = 0,       /**<8 bits*//**<CNcomment:8*/
+    HI_UNF_DISP_INTF_DATA_WIDTH16,          /**<16 bits*//**<CNcomment:16*/
+    HI_UNF_DISP_INTF_DATA_WIDTH24,          /**<24 bits*//**<CNcomment:24*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_BUTT
+}HI_UNF_DISP_INTF_DATA_WIDTH_E;
+
+/**define LCD timing */
+/**CNcomment:LCD*/
+typedef struct hiUNF_DISP_TIMING_S
+{
+    HI_U32                        VFB;            /**<vertical front blank*//**<CNcomment:*/
+    HI_U32                        VBB;            /**<vertical back blank*//**<CNcomment:*/
+    HI_U32                        VACT;           /**<vertical active area*//**<CNcomment:*/
+    HI_U32                        HFB;            /**<horizonal front blank*//**<CNcomment:*/
+    HI_U32                        HBB;            /**<horizonal back blank*//**<CNcomment:*/
+    HI_U32                        HACT;           /**<horizonal active area*/ /**<CNcomment:*/
+    HI_U32                        VPW;            /**<vertical sync pluse width*//**<CNcomment:*/
+    HI_U32                        HPW;            /**<horizonal sync pluse width*/ /**<CNcomment:*/
+    HI_BOOL                       IDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:*/
+    HI_BOOL                       IHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       IVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       ClockReversal;  /**<flag of clock is needed flip*//**<CNcomment:*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_E DataWidth;      /**<data width*/ /**<CNcomment:*/
+    HI_UNF_DISP_INTF_DATA_FMT_E   ItfFormat;      /**<data format.*//**<CNcomment:.*/
+
+    HI_BOOL DitherEnable;                           /**< flag of is enable Dither*//**<CNcomment:.*/
+    HI_U32  ClkPara0;                               /**<PLL  register SC_VPLL1FREQCTRL0  value *//**<CNcomment:PLL  SC_VPLL1FREQCTRL0  */
+    HI_U32  ClkPara1;                               /**<PLL  register SC_VPLL1FREQCTRL1 value*//**<CNcomment:PLL   SC_VPLL1FREQCTRL1*/
+
+    HI_BOOL bInterlace;                             /**<progressive or interlace*//**<CNcomment:*/
+    HI_U32  PixFreq;                                /**<pixel clock*//**<CNcomment:*/
+    HI_U32  VertFreq;                               /**<display rate*//**<CNcomment:*/
+    HI_U32  AspectRatioW;                           /**<width of screen*//**<CNcomment:*/
+    HI_U32  AspectRatioH;                           /**<height of screen*//**<CNcomment:*/
+    HI_BOOL bUseGamma;                              /**<gamma modulation*//**<CNcomment:*/
+    HI_U32  Reserve0;                               /**<reserved byte*//**<CNcomment:*/
+    HI_U32  Reserve1;                               /**<reserved byte*//**<CNcomment:*/
+} HI_UNF_DISP_TIMING_S;
+
+/**define video and graphics layers */
+/**CNcomment:*/
+typedef enum hiUNF_DISP_LAYER_E
+{
+    HI_UNF_DISP_LAYER_VIDEO = 0,                   /**<video layer *//**<CNcomment:*/
+    HI_UNF_DISP_LAYER_GFX,                  /**<graphics layer *//**<CNcomment:*/
+    HI_UNF_DISP_LAYER_BUTT
+}HI_UNF_DISP_LAYER_E;
+
+/**bt1120 interface ID */
+/**CNcomment:bt1120 ID  */
+typedef enum hiUNF_DISP_BT1120_E
+{
+    HI_UNF_DISP_BT1120_0,    /**<BT1120 interface 0 *//**<CNcomment:BT11200 */
+    HI_UNF_DISP_BT1120_BUTT,
+}HI_UNF_DISP_BT1120_E;
+
+/**BT656 interface ID */
+/**CNcomment:BT656 ID  */
+typedef enum hiUNF_DISP_BT656_E
+{
+    HI_UNF_DISP_BT656_0,    /**<BT656 interface 0 *//**<CNcomment:BT6560 */
+    HI_UNF_DISP_BT656_BUTT,
+}HI_UNF_DISP_BT656_E;
+
+/**LCD interface ID */
+/**CNcomment:LCD ID  */
+typedef enum hiUNF_LCD_E
+{
+    HI_UNF_DISP_LCD_0,    /**<LCD interface 0 *//**<CNcomment:LCD0 */
+    HI_UNF_DISP_LCD_BUTT,
+}HI_UNF_DISP_LCD_E;
+
+/**define the type of interface*/
+/**CNcomment:*/
+typedef enum  hiUNF_DISP_INTF_TYPE_E
+{
+    HI_UNF_DISP_INTF_TYPE_HDMI,     /**<HDMI interface type *//**<CNcomment:HDMI*/
+    HI_UNF_DISP_INTF_TYPE_LCD,      /**<LCD interface type *//**<CNcomment:LCD*/
+    HI_UNF_DISP_INTF_TYPE_BT1120,   /**<bt1120 digital interface type *//**<CNcomment:BT1120*/
+    HI_UNF_DISP_INTF_TYPE_BT656,    /**<bt656 digital interface type*//**<CNcomment:BT656*/
+    HI_UNF_DISP_INTF_TYPE_YPBPR,    /**<YPBPR interface type*//**<CNcomment:YPBPR*/
+    HI_UNF_DISP_INTF_TYPE_RGB,      /**<RGB interface type*//**<CNcomment:RGB*/
+    HI_UNF_DISP_INTF_TYPE_CVBS,     /**<CVBS interface type*//**<CNcomment:CVBS*/
+    HI_UNF_DISP_INTF_TYPE_SVIDEO,   /**<SVIDEO interface type*//**<CNcomment:SVIDEO*/
+    HI_UNF_DISP_INTF_TYPE_VGA,      /**<VGA interface type*//**<CNcomment:VGA*/
+    HI_UNF_DISP_INTF_TYPE_BUTT
+}HI_UNF_DISP_INTF_TYPE_E;
+
+/**define the YPBPR type struct of interface*/
+/**CNcomment:YPBPR*/
+typedef struct  hiUNF_DISP_INTF_YPBPR_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Ydac*/
+    HI_U8 u8DacPb;            /**<DAC num of Pb  *//**<CNcomment:Pbdac*/
+    HI_U8 u8DacPr;            /**<DAC num of Pr  *//**<CNcomment:Prdac*/
+}HI_UNF_DISP_INTF_YPBPR_S;
+
+/**define the RGB type struct of interface*/
+/**CNcomment:RGB*/
+typedef struct  hiUNF_DISP_INTF_RGB_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:Rdac*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:Gdac*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:Bdac*/
+    HI_BOOL bDacSync;         /**<G without sync signal  *//**<CNcomment:G*/
+}HI_UNF_DISP_INTF_RGB_S;
+
+/**define the VGA type struct of interface*/
+/**CNcomment:VGA*/
+typedef struct  hiUNF_DISP_INTF_VGA_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:Rdac*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:Gdac*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:Bdac*/
+}HI_UNF_DISP_INTF_VGA_S;
+
+/**define the CVBS type struct of interface*/
+/**CNcomment:CVBS*/
+typedef struct  hiUNF_DISP_INTF_CVBS_S
+{
+    HI_U8 u8Dac;              /**<DAC num of CVBS  *//**<CNcomment:CVBSdac*/
+}HI_UNF_DISP_INTF_CVBS_S;
+
+/**define the SVIDEO type struct of interface*/
+/**CNcomment:SVIDEO*/
+typedef struct  hiUNF_DISP_INTF_SVIDEO_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Ydac*/
+    HI_U8 u8DacC;             /**<DAC num of C   *//**<CNcomment:Cdac*/
+}HI_UNF_DISP_INTF_SVIDEO_S;
+
+/**define display interface struct*/
+/**CNcomment:*/
+typedef struct  hiUNF_DISP_INTF_S
+{
+    HI_UNF_DISP_INTF_TYPE_E enIntfType;         /**<interface type *//**<CNcomment:*/
+    union
+    {
+        HI_UNF_HDMI_ID_E        enHdmi;         /**<hdmi id *//**<CNcomment:HDMI */
+        HI_UNF_DISP_BT1120_E    enBT1120;       /**<bt1120 id *//**<CNcomment:BT1120*/
+        HI_UNF_DISP_BT656_E     enBT656;        /**<bt656 id *//**<CNcomment:BT656*/
+        HI_UNF_DISP_LCD_E       enLcd;          /**<lcd id *//**<CNcomment:LCD*/
+
+        HI_UNF_DISP_INTF_YPBPR_S    stYPbPr;    /**<intf config of YPBPR  *//**<CNcomment:YPBPR*/
+        HI_UNF_DISP_INTF_RGB_S      stRGB;      /**<intf config of RGB  *//**<CNcomment:RGB*/
+        HI_UNF_DISP_INTF_VGA_S      stVGA;      /**<intf config of VGA  *//**<CNcomment:VGA*/
+        HI_UNF_DISP_INTF_CVBS_S     stCVBS;     /**<intf config of CVBS  *//**<CNcomment:CVBS*/
+        HI_UNF_DISP_INTF_SVIDEO_S   stSVideo;   /**<intf config of SVIDEO  *//**<CNcomment:SVIDEO*/
+    }unIntf;
+}HI_UNF_DISP_INTF_S;
+
+
+/**Defines the device aspect ratio.*/
+/**CNcomment: */
+typedef enum hiUNF_DISP_ASPECT_RATIO_E
+{
+    HI_UNF_DISP_ASPECT_RATIO_AUTO,              /**<aspect ratio as device Resolution*//**<CNcomment: */
+    HI_UNF_DISP_ASPECT_RATIO_4TO3,              /**<4:3*//**<CNcomment: 43*/
+    HI_UNF_DISP_ASPECT_RATIO_16TO9,             /**<16:9*//**<CNcomment: 169*/
+    HI_UNF_DISP_ASPECT_RATIO_221TO1,            /**<221:100*//**<CNcomment: 221100*/
+    HI_UNF_DISP_ASPECT_RATIO_USER,              /**<user define*//**<CNcomment: */
+
+    HI_UNF_DISP_ASPECT_RATIO_BUTT
+}HI_UNF_DISP_ASPECT_RATIO_E;
+
+/**Defines the device aspect ratio struct.*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_ASPECT_RATIO_S
+{
+    HI_UNF_DISP_ASPECT_RATIO_E enDispAspectRatio;   /**<aspect ratio type of device*//**<CNcomment: */
+    HI_U32                     u32UserAspectWidth;  /**<user define width of device*//**<CNcomment: */
+    HI_U32                     u32UserAspectHeight; /**<user define height of device*//**<CNcomment: */
+}HI_UNF_DISP_ASPECT_RATIO_S;
+
+/**Defines algorithmic  control struct of display device.*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_ALG_CFG_S
+{
+    HI_BOOL bAccEnable;                             /**<acc alg*//**<CNcomment: acc*/
+    HI_BOOL bSharpEnable;                           /**<sharp alg*//**<CNcomment: sharp*/
+}HI_UNF_DISP_ALG_CFG_S;
+
+/**Defines VBI type.*/
+/**CNcomment: VBI*/
+typedef enum hiUNF_DISP_VBI_TYPE_E
+{
+    HI_UNF_DISP_VBI_TYPE_TTX = 0,                   /**<Teltext type*//**<CNcomment:teltext*/
+    HI_UNF_DISP_VBI_TYPE_CC,                        /**<Closed caption/V-Chip type *//**<CNcomment: /V-Chip*/
+    HI_UNF_DISP_VBI_TYPE_WSS,                       /**<Wide screen signal*//**<CNcomment:*/
+    HI_UNF_DISP_VBI_TYPE_BUTT
+} HI_UNF_DISP_VBI_TYPE_E;
+
+/**Defines VBI config struct.*/
+/**CNcomment: VBI*/
+typedef struct hiUNF_DISP_VBI_CFG_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI */
+    HI_U32                  u32InBufferSize;        /**<VBI data(pes) buffer size,more than 4K,suggest 4K*//**<CNcomment:VBI pes ,4K4K*/
+    HI_U32                  u32WorkBufferSize;      /**<VBI data buffer size used in driver,more than 2K,suggest 2K*//**<CNcomment:VBI2K2K*/
+} HI_UNF_DISP_VBI_CFG_S;
+
+/** define VBI information structure*/
+/**CNcomment: VBI*/
+typedef struct hiUNF_DISP_VBI_DATA_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI */
+    HI_U8                   *pu8DataAddr;           /**<Vbi data buffer virtual address*//**<CNcomment:Vbi*/
+    HI_U32                  u32DataLen;             /**<Vbi data lenght*//**<CNcomment:Vbi*/
+} HI_UNF_DISP_VBI_DATA_S;
+
+/**Defines the MAX buffer number.*/
+/** CNcomment:buffer */
+#define HI_DISP_CAST_BUFFER_MAX_NUMBER ( 16 )
+
+/**define CAST config */
+/**CNcomment:*/
+typedef struct hiUNF_DISP_CAST_ATTR_S
+{
+    HI_UNF_VIDEO_FORMAT_E enFormat;                                        /**<the output video format.*//**<CNcomment:*/
+    HI_U32                u32Width;                                       /**<the output video width.*//**<CNcomment:*/
+    HI_U32                u32Height;                                      /**<the output video height.*//**<CNcomment:*/
+    HI_BOOL               bLowDelay;                                      /**<work at low delay mode.*//**<CNcomment:*/
+    HI_U32                u32BufNum;                                      /**<the buffer number.*//**<CNcomment:buffer */
+    HI_BOOL               bUserAlloc;                                     /**<whether is user alloc memory*//**<CNcomment:*/
+    HI_U32                u32BufSize;                                     /**<each the buffer size.*//**<CNcomment:buffer */
+    HI_U32                u32BufStride;                                   /**<the horizonal stride.*//**<CNcomment:*/
+    HI_U32                u32BufPhyAddr[HI_DISP_CAST_BUFFER_MAX_NUMBER];  /**<the buffer physics address.*//**<CNcomment:buffer */
+    HI_BOOL               bCrop;                                          /**<whether enable crop .*//**<CNcomment:crop*/
+    HI_UNF_CROP_RECT_S    stCropRect;                                     /**<the crop wise .*//**<CNcomment:crop */
+} HI_UNF_DISP_CAST_ATTR_S;
+
+/**define color setting */
+/**CNcomment:*/
+typedef struct hiUNF_DISP_COLOR_SETTING_S
+{
+    HI_BOOL bGammaEnable;         /**<whether Gamma enable.*//**<CNcomment:Gamma */
+    HI_BOOL bUseCustGammaTable;   /**<whether use custom GammaTable.*//**<CNcomment:Gamma*/
+    HI_BOOL bColorCorrectEnable;  /**<whether Color Correct.*//**<CNcomment:*/
+    HI_S32  s32ColorTemp;         /**<color Temp.*//**<CNcomment:*/
+    HI_U32  u32Reserve;           /**<Reserve.*//**<CNcomment:*/
+    HI_VOID *pPrivate;            /**<Private.*//**<CNcomment:*/
+}HI_UNF_DISP_COLOR_SETTING_S;
+
+/**define the struct about color */
+/**CNcomment: */
+typedef struct  hiUNF_DISP_BG_COLOR_S
+{
+    HI_U8 u8Red;                  /**<red *//**<CNcomment:*/
+    HI_U8 u8Green;                /**<green*//**<CNcomment:*/
+    HI_U8 u8Blue;                 /**<blue*//**<CNcomment:*/
+} HI_UNF_DISP_BG_COLOR_S;
+
+/**define the struct about isogeny attributes */
+/**CNcomment: */
+typedef struct  hiUNF_DISP_ISOGENY_ATTR_S
+{
+    HI_UNF_DISP_E          enDisp; /**<channel id*//**<CNcomment: */
+    HI_UNF_ENC_FMT_E       enFormat;/**<format type*//**<CNcomment:*/
+}HI_UNF_DISP_ISOGENY_ATTR_S ;
+
+
+/********************************ENCODER STRUCT********************************/
+/** define the enum of Macrovision output type*/
+/** CNcomment:Macrovision*/
+typedef enum hiUNF_DISP_MACROVISION_MODE_E
+{
+    HI_UNF_DISP_MACROVISION_MODE_TYPE0,     /**<type 0:no protect process *//**<CNcomment:*/
+    HI_UNF_DISP_MACROVISION_MODE_TYPE1,     /**<type 1:AGC (automatic gain control) process only *//**<CNcomment: */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE2,     /**<type 2:AGC + 2-line color stripe *//**<CNcomment: */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE3,     /**<type 3:AGC + aggressive 4-line color stripe *//**<CNcomment:*/
+    HI_UNF_DISP_MACROVISION_MODE_CUSTOM,    /**<type of configure by user *//**<CNcomment: */
+    HI_UNF_DISP_MACROVISION_MODE_BUTT
+} HI_UNF_DISP_MACROVISION_MODE_E;
+
+/** CGMS type select */
+/**CNcomment:CGMS */
+typedef enum hiUNF_DISP_CGMS_TYPE_E
+{
+    HI_UNF_DISP_CGMS_TYPE_A = 0x00,     /**<CGMS type  A*//**<CNcomment:CGMS A*/
+    HI_UNF_DISP_CGMS_TYPE_B,            /**<CGMS type  B*//**<CNcomment:CGMS B*/
+
+    HI_UNF_DISP_CGMS_TYPE_BUTT
+}HI_UNF_DISP_CGMS_TYPE_E;
+
+/** definition of CGMS mode */
+/**CNcomment:CGMS */
+typedef enum hiUNF_DISP_CGMS_MODE_E
+{
+    HI_UNF_DISP_CGMS_MODE_COPY_FREELY  = 0,     /**<copying is permitted without restriction *//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NO_MORE = 0x01,  /**<No more copies are allowed (one generation copy has been made)*//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_ONCE    = 0x02,  /**<One generation of copies may be made *//**<CNcomment:*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NEVER   = 0x03,  /**<No copying is permitted *//**<CNcomment:*/
+
+    HI_UNF_DISP_CGMS_MODE_BUTT
+}HI_UNF_DISP_CGMS_MODE_E;
+
+/** definition of CGMS configuration */
+typedef struct hiUNF_DISP_CGMS_CFG_S
+{
+    HI_BOOL                 bEnable;            /**<HI_TRUE:CGMS is enabled; HI_FALSE:CGMS is disabled *//**<CNcomment:CGMS */
+    HI_UNF_DISP_CGMS_TYPE_E enType;             /**<type-A or type-B or None(BUTT) *//**<CNcomment:CGMS */
+    HI_UNF_DISP_CGMS_MODE_E enMode;             /**<CGMS mode. *//**<CNcomment:CGMS */
+}HI_UNF_DISP_CGMS_CFG_S;
+
+/**define WSS information structure*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_WSS_DATA_S
+{
+    HI_BOOL bEnable;                            /**<WSS configure enable HI_TRUE: enable,HI_FALSE: disnable*//**<CNcomment:WSSHI_TRUEHI_FALSE*/
+    HI_U16  u16Data;                            /**<Wss data */ /**<CNcomment:Wss*/
+}HI_UNF_DISP_WSS_DATA_S;
+
+
+/**define display 3D mode stucture*/
+/**CNcomment: */
+typedef enum hiUNF_DISP_3D_E
+{
+    HI_UNF_DISP_3D_NONE = 0,
+    HI_UNF_DISP_3D_FRAME_PACKING,                   /**<3d type:Frame Packing*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_HALF,               /**<3d type:Side by side half*//**<CNcomment:3d : */
+    HI_UNF_DISP_3D_TOP_AND_BOTTOM,                  /**<3d type:Top and Bottom*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_FIELD_ALTERNATIVE,               /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_LINE_ALTERNATIVE,                /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_FULL,               /**<3d type:Side by side full*//**<CNcomment:3d : */
+    HI_UNF_DISP_3D_L_DEPTH,                         /**<3d type:L+depth*//**<CNcomment:3d :L+DEPTH*/
+    HI_UNF_DISP_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d :L+depth+Graphics+Graphics-depth*/
+    HI_UNF_DISP_3D_BUTT
+}HI_UNF_DISP_3D_E;
+
+/**define display margin stucture*/
+/**CNcomment: */
+typedef struct hiUNF_DISP_OFFSET_S
+{
+    HI_U32 u32Left;    /**<left offset *//**<CNcomment:*/
+    HI_U32 u32Top;     /**<top offset *//**<CNcomment:*/
+    HI_U32 u32Right;   /**<right offset *//**<CNcomment:*/
+    HI_U32 u32Bottom;  /**<bottom offset *//**<CNcomment:*/
+}HI_UNF_DISP_OFFSET_S;
+
+/**define output signal type.*/
+/**CNcomment:*/
+typedef enum hiUNF_DISP_HDR_TYPE_E
+{
+    HI_UNF_DISP_HDR_TYPE_NONE = 0,      /**<Normal SDR signal output type *//**<CNcomment:SDR */
+    HI_UNF_DISP_HDR_TYPE_AUTO,          /**<Optimum signal output type automatically *//**<CNcomment:*/
+    HI_UNF_DISP_HDR_TYPE_AUTO_FOLLOW_FIRSTFRAME, /**<signal output type follow first frame type.*//**<CNcomment:*/
+    HI_UNF_DISP_HDR_TYPE_DOLBY,         /**<DolbyVision signal output type *//**<CNcomment:DolbyVision */
+    HI_UNF_DISP_HDR_TYPE_HDR10,         /**<HDR10 signal output type *//**<CNcomment:HDR10 */
+    HI_UNF_DISP_HDR_TYPE_HLG,           /**<HLG signal output type *//**<CNcomment:HLG */
+    HI_UNF_DISP_HDR_TYPE_DOLBY_LOW_LATENCY,/**<DolbyVision low latency output type *//**<CNcomment:DolbyVision */
+
+    HI_UNF_DISP_HDR_TYPE_BUTT
+} HI_UNF_DISP_HDR_TYPE_E;
+
+/**SD format should use BT601*/
+/**CNcomment:BT601*/
+typedef enum hiHI_UNF_DISP_COLOR_SPACE_E
+{
+    HI_UNF_DISP_COLOR_SPACE_AUTO = 0x0,     /**<  optimum output color space *//**<CNcomment:*/
+    HI_UNF_DISP_COLOR_SPACE_BT601,          /**< output  color space BT601, Not support*//**<CNcomment:BT601, */
+    HI_UNF_DISP_COLOR_SPACE_BT709,          /**< output  color space BT709*//**<CNcomment:BT709*/
+    HI_UNF_DISP_COLOR_SPACE_BT2020,         /**< output  color space BT2020*//**<CNcomment:BT2020*/
+    HI_UNF_DISP_COLOR_SPACE_BUTT
+}HI_UNF_DISP_COLOR_SPACE_E;
+
+/** definition of output hdr infomation */
+/**CNcomment:*/
+typedef struct hiUNF_DISP_OUTPUT_STATUS_S
+{
+    HI_UNF_DISP_HDR_TYPE_E enActualOutHDRType;
+    HI_UNF_DISP_COLOR_SPACE_E enActualOutColorSpace;
+}HI_UNF_DISP_OUTPUT_STATUS_S;
+
+/**define the struct about hdr mixed priority mode. */
+/**CNcomment:hdr */
+typedef enum hiUNF_DISP_HDR_PRIORITY_MODE{
+    HI_UNF_DISP_HDR_PRIORITY_VIDEO = 0,  /**< video and graphic tomapping to video   luminance.  */
+    HI_UNF_DISP_HDR_PRIORITY_GRAPHIC,    /**< video and graphic tomapping to graphic luminance. */
+    HI_UNF_DISP_HDR_PRIORITY_AUTO,       /**< video and graphic tomapping automatically according to scene.  Not support currently. */
+    HI_UNF_DISP_HDR_PRIORITY_MAX,
+} HI_UNF_DISP_HDR_PRIORITY_MODE;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+
+/**
+   \brief Initiallization DISP module.CNcomment:DISP CNend
+   \attention \n
+   Please call this API function, before call anyother API of DISP module.
+   CNcomment:DISP CNend
+   \param  none.CNcomment: CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_NOT_EXIST DISP device not exist.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NOT_DEV_FILE  DISP  not device file .CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_OPEN_ERR  DISP  open fail.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Init( HI_VOID );
+
+
+/**
+   \brief deinital.CNcomment:DISP CNend
+   \attention \n
+   please call API HI_UNF_DISP_Close and open all the DISP device, before call this API.
+   CNcomment:::HI_UNF_DISP_CloseDISP CNend
+   \param none.CNcomment: CNend
+   \retval ::HI_SUCCESS success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_DEV_CLOSE_ERR  DISP close fail.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DeInit( HI_VOID );
+
+
+/**
+   \brief Attach one DISP channel to anoter.CNcomment:DISP CNend
+   \attention \n
+   Please finish the attach operation before the DISP channel has been open, and currently we only support HD channel attach to SD channel.
+   CNcomment:DISPDISPDISP CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:DISP CNend
+   \param[in] enSrcDisp   source DISP channel.CNcomment:  DISP CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT  display not be initialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid opeation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Attach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief dettach DISP.CNcomment:DISP CNend
+   \attention \n
+   should  close the DISP channels, before do detach operation.
+   CNcomment:DISP CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:DISP CNend
+   \param[in] enSrcDisp    source DISP channel.CNcomment: DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Detach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief open DISP channel.CNcomment:DISP CNend
+   \attention \n
+   Please config the valid parameters before open DISP.
+   CNcomment:DISP CNend
+   \param[in] enDisp   DISP channel ID, please reference the define of HI_UNF_DISP_E.CNcomment:DISP::HI_UNF_DISP_E CNend
+   \retval ::HI_SUCCESS success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    DISP create fail.CNcomment:DISP CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Open( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  coase DISP channel.CNcomment:DISP CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS success. CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Close( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  set DISP interface parameter.CNcomment:DISP CNend
+   \attention \n
+   The API is uesed for set  interface attach .If the interface has been attached,must be detach it ,or return HI_ERR_DISP_INVALID_OPT;\n
+   There are 4 DAC provided by SOC 3712 v300. suggest, DAC 0/1/2 used by HD channel, DAC3 used by SD channel CVBS. \n
+   There are 6 DAC provided by SOC 3716 v100/v200/v300. suggest, DAC 0/1/2 used by HD channel, DAC3/4/5 used by SD channel.
+   CNcomment:API Detach\n
+   HI_ERR_DISP_INVALID_OPT;\n
+   3712 v300 4DAC0123CVBS\n
+   3716 v100/v200/v300 6DAC012345CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32IntfNum  DISP intf num of DISP channel.CNcomment:DISP CNend
+   \param[in] pstIntf  DISP intf para.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS   success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR      Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AttachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief cancel DISP interface parameter.CNcomment:DISP CNend
+   \attention \n
+   The API is uesed to  detach  interface.
+   CNcomment:API  CNend
+   \param[in] enDisp        DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32IntfNum  DISP interface number of DISP channel.CNcomment:DISP CNend
+   \param[in] pstIntf  DISP interface para.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS   success. CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR        Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DetachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief set DISP output format.CNcomment:DISP CNend
+   \attention \n
+   for HD DISP channel please set HD display format, and for SD DISP channel please set SD display format.\n
+   for scenario of HD,SD use same source, only support format which frame rate is 50Hz or 60Hz. \n
+   for scenario of HD,SD use same source, when this UNF API sets up HD DISP channel, \n
+   the SD DISP channel will be temporarily affected, and vice versa. \n
+   It is recommended to use HI_UNF_DISP_SetIsogenyAttr to set up both HD and SD DISP channels to avoid this impact.
+   CNcomment:DISPDISP\n
+   50Hz/60Hz1080P24/1080P25/1080P30\n
+   \n
+   HI_UNF_DISP_SetIsogenyAttr CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] enEncodingFormat    DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E enEncodingFormat );
+
+
+/**
+   \brief get DISP format.CNcomment:DISP CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] penEncodingFormat    poiner of DISP format.DCNcomment:ISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E *penEncodingFormat );
+
+
+/**
+   \brief set user define LCD clock parameter.CNcomment:LCD CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstTiming    poiner of DISP format.CNcomment:LCD CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief  get LCD parameter which had been config.CNcomment:DISPLCD CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstTiming      pointer of LCD paramter.CNcomment:LCD CNend
+   \retval ::HI_SUCCESS success.CNcomment:  CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief   set DISP layers Z order.CNcomment:DISPZ CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:3716 v100 v200 LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP CNend
+   \param[in] enLayer        layer ID which needed overlay to the DISP channel.CNcomment: DISP CNend
+   \param[in] enZFlag        the way of overlay.CNcomment:Z CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_LAYER_ZORDER_E enZFlag );
+
+
+/**
+   \brief  get DISP overlay z order.CNcomment:DISPZ CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:DISPDISPDISPDISP CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP CNend
+   \param[in] enLayer           CNcomment:DISP CNend
+   \param[in] pu32Zorder        CNcomment:Z CNend
+   \retval ::HI_SUCCESS success.CNcomment:  CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_U32 *pu32Zorder );
+
+
+/**
+   \brief set DISP back ground color.CNcomment:DISP CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp       CNcomment:DISP CNend
+   \param[in] pstBgColor   CNcomment:::HI_UNF_BG_COLOR_S CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetBgColor( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP back ground color.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:DISPDISPDISPDISP CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstBgColor   pointer of back ground color.CNcomment:  CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetBgColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP brightness.CNcomment:DISP CNend
+   \attention \n
+   if the value seted more than 100, we clip it to 100.CNcomment:100100 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Brightness   brightness value. the range is 0~100, 0 means the min brightness value.
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetBrightness( HI_UNF_DISP_E enDisp, HI_U32 u32Brightness );
+
+
+/**
+   \brief   get the DISP brightness.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Brightness    pointer of brightness. CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetBrightness( HI_UNF_DISP_E enDisp, HI_U32 *pu32Brightness );
+
+
+/**
+   \brief  set DISP contrast value.CNcomment:DISP CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:100100 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Contrast    contrast value. the range is 0~100, 0 means the min contrast value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetContrast( HI_UNF_DISP_E enDisp, HI_U32 u32Contrast );
+
+
+/**
+   \brief  get DISP contrast value.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Contrast   pointer of contrast. CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetContrast( HI_UNF_DISP_E enDisp, HI_U32 *pu32Contrast );
+
+
+/**
+   \brief   set DISP saturation.CNcomment:DISP CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:100100 CNend
+   \param[in] enDisp             DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Saturation      saturation value. the range is 0~100, 0 means the min saturation value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_DISP_SetSaturation( HI_UNF_DISP_E enDisp, HI_U32 u32Saturation );
+
+
+/**
+   \brief   get DISP saturation.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp                 DISP channel ID.CNcomment:DISP CNend
+   \param[out] pu32Saturation    pointer of saturation. CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetSaturation( HI_UNF_DISP_E enDisp, HI_U32 *pu32Saturation );
+
+
+/**
+   \brief  set DISP hueplus.CNcomment:DISP CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32HuePlus       hueplus value. the range is 0~100, 0 means the min hueplus value. \n
+   CNcomment:01000100 CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 u32HuePlus );
+
+
+/**
+   \brief get DISP hueplus.CNcomment:DISP CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:50\n
+   DISPDISPDISPDISP CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP CNend
+   \param[out] pu32HuePlus     pointer of hueplus. CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 *pu32HuePlus );
+
+
+/**
+   \brief  set Wss.CNcomment:WSSWide Screen Singnalling CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstWssData        pointer of Wss data description structure.CNcomment:WSS CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetWss( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_WSS_DATA_S *pstWssData );
+
+
+/**
+   \brief  set Macrovision mode.CNcomment:Macrovision CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP CNend
+   \param[in] enMode        Macrovision mode.  CNcomment:Macrovision::HI_UNF_MACROVISION_MODE_E CNend
+   \param[in] pData          pointer of Macrovision control data CNcomment: Macrovision CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E enMode, const HI_VOID *pData );
+
+
+/**
+   \brief get Macrovision mode.CNcomment: Macrovision CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] penMode    pointer of Macrovision mode. CNcomment:MACROVISION CNend
+   \param[out] pData      a data pointer only valid whenpenMode=HI_MACROVISION_MODE_CUSTOM.\n
+   CNcomment:penMode=HI_MACROVISION_MODE_CUSTOM CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E *penMode, const HI_VOID *pData );
+
+
+/**
+   \brief   set CGMS data.CNcomment:CGMSCopy Generation Management System CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp                   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstCgmsCfg             pointer of CGMS configuration  CNcomment:CGMS CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCgms( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_CGMS_CFG_S *pstCgmsCfg );
+
+
+/**
+   \brief chip do or not support Macrovision.CNcomment: Macrovision CNend
+   \attention \n
+   none.CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pbSupport    pointer of Macrovision flag. CNcomment:Macrovision  CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovisionSupport( HI_UNF_DISP_E enDisp, HI_BOOL *pbSupport );
+
+/**
+   \brief set aspect ratio attribute of display device.CNcomment:  CNend
+   \attention \n
+   If set AspectRatio USER mode ,must be set u32UserAspectWidth and u32UserAspectHeight \n
+   (theWidth/Height range is 1/64~64,if set zero means using current screen AspectRatio.) \n
+   If not AspectRatio USER mode ,it will be set value by enumeration means;In this mode u32UserAspectWidth and u32UserAspectHeight are invalid ;\n
+   If set AspectRatio AUTO mode , use current screen AspectRatio;
+   CNcomment:USERu32UserAspectWidth u32UserAspectHeight\n
+   1/64~64,0\n
+   USERu32UserAspectWidth u32UserAspectHeight\n
+   AUTO CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief get aspect ratio attribute of display device.CNcomment:  CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief set algorithmic attribute of display device.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstAlg    pointer of algorithmic attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief get algorithmic status of display device.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstAlg    pointer of algorithmic attribute of display device . CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief create VBI data channel.CNcomment: VBI CNend
+   \attention \n
+   Each VBI type can not  created  repeatedly,if created more than one time,it will be return HI_ERR_DISP_CREATE_ERR;
+   CNcomment:VBIHI_ERR_DISP_CREATE_ERR CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstCfg    pointer of parameter of VBI channel . CNcomment:VBI CNend
+   \param[out] phVbi    pointer of VBI handle . CNcomment:VBI CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_CreateVBI( HI_UNF_DISP_E enDisp, HI_UNF_DISP_VBI_CFG_S *pstCfg, HI_HANDLE *phVbi );
+
+
+/**
+   \brief destroy VBI data channel.CNcomment: VBI CNend
+   \attention \n
+   none.
+   CNcomment: CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI  CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyVBI( HI_HANDLE hVbi );
+
+
+/**
+   \brief send data to vbi channel.CNcomment: VBI CNend
+   \attention \n
+   After  call HI_UNF_DISP_CreateVBI creat VBI handle sucess,you can call API HI_UNF_DISP_SendVBIData send VBI data .
+   CNcomment:HI_UNF_DISP_CreateVBI VBIHI_UNF_DISP_SendVBIData   CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI  CNend
+   \param[in] pstVbiData      pointer of VBI data.CNcomment:VBI CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SendVBIData(HI_HANDLE hVbi, HI_UNF_DISP_VBI_DATA_S *pstVbiData);
+
+/**
+   \brief Get default attributes of screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[out]pstAttr     pointer of parameter .CNcomment:, CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetDefaultCastAttr(HI_UNF_DISP_E enDisp,HI_UNF_DISP_CAST_ATTR_S *pstAttr);
+
+
+/**
+   \brief create screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstAttr      pointer of parameter .CNcomment:, CNend
+   \param[out] phCast      handle of screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_CreateCast(HI_UNF_DISP_E enDisp, HI_UNF_DISP_CAST_ATTR_S * pstAttr, HI_HANDLE *phCast);
+
+
+/**
+   \brief destroy screen share channel.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyCast( HI_HANDLE hCast );
+
+
+/**
+   \brief enable screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \param[in] bEnable      enable screen share .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetCastEnable( HI_HANDLE hCast, HI_BOOL bEnable );
+
+
+/**
+   \brief get enable flag of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] phCast      handle of screen share .CNcomment: CNend
+   \param[out] bEnable     flag .CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetCastEnable( HI_HANDLE hCast, HI_BOOL *pbEnable );
+
+
+/**
+   \brief get frame info of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] hCast      handle of screen share .CNcomment: CNend
+   \param[out] pstFrameInfo        frame info.CNcomment: CNend
+   \param[in] u32TimeoutMs wait time in ms.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \retval ::HI_ERR_DISP_TIMEOUT          operation timeout. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo, HI_U32 u32TimeoutMs);
+
+
+/**
+   \brief release frame info of screen share.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] hCast      handle of screen share .CNcomment: CNend
+   \param[in] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseCastFrame( HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo );
+
+
+/**
+   \brief professional color modulation.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstCS      struct of color modulation.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \brief get color modulation parameter.CNcomment:  CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstCS      struct of color modulation.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \Snapshot truncation screen connection, intercepts the screen complete picture;CNcomment:; CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[out] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+/**
+   \Release Snapshot picture;CNcomment:; CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \param[in] pstFrameInfo     frame info.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+
+/**
+   \brief get color modulation parameter.CNcomment:DISP CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp      display channel.CNcomment: CNend
+   \retval ::HI_SUCCESS CNcomment: success. CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetDefaultPara( HI_UNF_DISP_E enDisp);
+
+
+/**
+   \brief set DISP 3D format.CNcomment:DISP3D CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[in] en3D             DISP 3D mode.CNcomment:DISP 3D CNend
+   \param[in] enEncodingFormat DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Set3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E en3D, HI_UNF_ENC_FMT_E enEncFormat);
+
+/**
+   \brief get DISP 3D format.CNcomment:DISP3D CNend
+   \attention \n
+   none. CNcomment: CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP CNend
+   \param[out] pen3D           DISP 3D mode.CNcomment:DISP 3D CNend
+   \param[out] penEncFormat    DISP format.CNcomment:DISP CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_Get3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E *pen3D, HI_UNF_ENC_FMT_E *penEncFormat);
+
+/**
+   \brief set right eye first for 3D output.CNcomment:3D CNend
+   \attention \n
+   Only take effect in 3D output mode. CNcomment: 3D CNend
+   \param[in] enDisp     DISP channel ID.CNcomment:DISP CNend
+   \param[in] bEnable   Right-Eye-First.CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetRightEyeFirst(HI_UNF_DISP_E enDisp, HI_BOOL bEnable);
+
+/**
+   \brief set virtual screen size of display.CNcomment: CNend
+   \attention \n
+   if not set ,default value is 1280*720. CNcomment: 720p. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Width  virtual screen width, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \param[in] u32Height  virtual screen height, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 u32Width, HI_U32 u32Height);
+
+/**
+   \brief get virtual screen size of display.CNcomment: CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] u32Width  virtual screen width, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \param[out] u32Height  virtual screen height, the range is [480, 3840].CNcomment:[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 *u32Width, HI_U32 *u32Height);
+
+
+/**
+   \brief set offset of display area in real screen.CNcomment:, CNend
+   \attention \n
+   must be 4 pixels aligned,if not set, the default value is 0. CNcomment: offset 4,0. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstOffset  offset in pixel, the range is [0, 200].CNcomment:[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief get offset of display area in real screen.CNcomment:, CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstOffset  offset in pixel, the range is [0, 200].CNcomment:[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief set isogeny attributes. It is recommended to use HI_UNF_DISP_SetIsogenyAttr to \n
+   set up both HD and SD DISP channels format when they have the same source.
+   \attention \n
+   none. CNcomment: HI_UNF_DISP_SetFormat \n
+     CNend
+   \param[in] pstIsogeny isogenous attributes.CNcomment: CNend
+   \param[in] u32ChannelNum  channel counts to be set in isogenous mode.CNcomment: CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetIsogenyAttr(const HI_UNF_DISP_ISOGENY_ATTR_S *pstIsogeny, const HI_U32 u32ChannelNum);
+
+/**
+   \brief set display output type.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] enHDRType   DISP type.CNcomment:HDR CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRType(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_HDR_TYPE_E enHDRType);
+
+/**
+   \brief Get display output type.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] penHDRType   DISP type.CNcomment:HDRCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRType(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_TYPE_E *penHDRType);
+
+/**
+   \brief Set display output color space.CNcomment:  CNend
+   \attention \n
+   should set sink capability with HI_UNF_DISP_SetSinkCapability api when set auto out color space.
+   CNcomment: AUTOHI_UNF_DISP_SetSinkCapability CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] enColorSpace output color space.CNcomment:CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_COLOR_SPACE_E enColorSpace);
+
+/**
+   \brief Get display output color space.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[out] penColorSpace output color space.CNcomment:CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputColorSpace(HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SPACE_E *penColorSpace);
+
+/**
+   \brief Set capability of sink .CNcomment: SinkCNend
+   \attention \n
+    Sink capability can acquire from hdmi, Strongly recommend to set sink capability when detect hdmi hot-plot event .
+    CNcomment: HDMISinkSink  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pstSinkCap output color space.CNcomment:SinkCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetSinkCapability( HI_UNF_DISP_E enDisp, const HI_UNF_EDID_BASE_INFO_S *pstSinkCap);
+
+/**
+   \brief Set alpha of video .CNcomment: alphaCNend
+   \attention \n
+    none  CNcomment: CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] u32Alpha video alpha value.CNcomment:alphaCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetVideoAlpha( HI_UNF_DISP_E enDisp, HI_U32 u32Alpha );
+
+/**
+   \brief Get alpha of video .CNcomment: alphaCNend
+   \attention \n
+    none CNcomment:  CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] pu32Alpha video alpha value.CNcomment:alphaCNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetVideoAlpha(HI_UNF_DISP_E enDisp, HI_U32 *pu32Alpha);
+
+
+/**
+   \brief Get display output status Information.CNcomment:  CNend
+   \attention \n
+   none. CNcomment:  CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP CNend
+   \param[out] pstOutputStatus.CNcomment: CNend
+   \retval ::HI_SUCCESS success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputStatus(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OUTPUT_STATUS_S *pstOutputStatus);
+
+
+/**
+   \brief set hdr mixed priority mode.CNcomment:hdr CNend
+   \attention: only take effect when output type is DolbyVision.CNcomment:DolbyVision CNend\n
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] enPriorityMode hdr priority mode.CNcomment:hdr. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRPriorityMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_PRIORITY_MODE enPriorityMode);
+
+/**
+   \brief get hdr mixed priority mode.CNcomment:hdr CNend
+   \attention \n
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP CNend
+   \param[in] penPriorityMode hdr priority mode.CNcomment:hdr. CNend
+   \retval ::HI_SUCCESS  success.CNcomment: CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment: CNend
+   \see \n
+   none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRPriorityMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_PRIORITY_MODE *penPriorityMode);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif
+/************************************** The End Of File **************************************/
diff --git a/xbmc/platform/linux/hisi/hi_unf_ecs.h b/xbmc/platform/linux/hisi/hi_unf_ecs.h
new file mode 100644
index 0000000000..a4272ed07c
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_ecs.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+ File Name     : hi_unf_ecs.h
+ Version       : Initial draft
+ Author        : HiSilicon multimedia software group
+ Created Date  : 2008-06-05
+ Last Modified by:
+ Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+ Function List :
+ Change History:
+ ******************************************************************************/
+#ifndef __HI_UNF_ECS_H__
+#define __HI_UNF_ECS_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+#include "hi_unf_frontend.h"
+#include "hi_unf_gpio.h"
+#include "hi_unf_ir.h"
+#include "hi_unf_pmoc.h"
+#include "hi_unf_wdg.h"
+#include "hi_unf_i2c.h"
+#include "hi_unf_otp.h"
+
+#endif /* __HI_UNF_ECS_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_edid.h b/xbmc/platform/linux/hisi/hi_unf_edid.h
new file mode 100644
index 0000000000..29b09539fc
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_edid.h
@@ -0,0 +1,500 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_edid.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013-8-28
+  Description   :
+  History       :
+  1.Date        : 2013-8-28
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+#ifndef __HI_UNF_EDID_H__
+#define __HI_UNF_EDID_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      EDID */
+/** @{*/  /** <!-- [EDID] */
+
+/**EDID Audio type enum*//**CNcomment:HDMI   */
+typedef enum hiUNF_EDID_AUDIO_FORMAT_CODE_E
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_RESERVED  = 0x00,  /**<Audio coding type, refer stream,default type*//**<CNcomment: */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM,               /**<Audio coding PCM type*//**<CNcomment:PCM */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3,               /**<Audio coding AC3 type*//**<CNcomment:AC3 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG1,             /**<Audio coding MPEG1 type*//**<CNcomment:MPEG1 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MP3,               /**<Audio coding MP3 type*//**<CNcomment:MP3 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG2,             /**<Audio coding MPEG2 type*//**<CNcomment:MPEG2 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AAC,               /**<Audio coding AAC type*//**<CNcomment:AAC */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS,               /**<Audio coding DTS type*//**<CNcomment:DTS */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC,             /**<Audio coding ATRAC type*//**<CNcomment:ATRAC */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ONE_BIT,           /**<Audio coding ONE BIT AUDIO type*//**<CNcomment:ONE_BIT */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DDP,               /**<Audio coding DDPLUS type*//**<CNcomment:DDPLUS */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS_HD,            /**<Audio coding DTS HD type*//**<CNcomment:DTS HD */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MAT,               /**<Audio coding MAT type*//**<CNcomment:MAT */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DST,               /**<Audio coding DST type*//**<CNcomment:DST */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_WMA_PRO,           /**<Audio coding WMA PRO type*//**<CNcomment:WMA PRO */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_BUTT,
+}HI_UNF_EDID_AUDIO_FORMAT_CODE_E;
+
+/**the max audio smprate count*//**CNcomment: */
+#define MAX_SAMPE_RATE_NUM 8
+
+/**the max audio bit depth count*//**CNcomment: */
+#define MAX_BIT_DEPTH_NUM  6
+
+/**EDID Audio Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_AUDIO_INFO_S
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E enAudFmtCode; /**<Audio coding type*//**<CNcomment: */
+    HI_UNF_SAMPLE_RATE_E            enSupportSampleRate[MAX_SAMPE_RATE_NUM]; /**<Audio sample rate*//**<CNcomment: */
+    HI_U32                          u32SupportSampleRateNum; /**<Audio sample rate num*//**<CNcomment: */
+    HI_U8                           u8AudChannel;      /**<Aud Channel of the coding type*//**<CNcomment: */
+
+    HI_UNF_BIT_DEPTH_E              bSupportBitDepth[MAX_BIT_DEPTH_NUM];/*sample bit depth,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM */
+    HI_U32                          u32SupportBitDepthNum; /*sample bit depth Num,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM */
+    HI_U32                          u32MaxBitRate;  /**enter max bit rate,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3 - HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC**//**<CNcomment:AC3-ATRAC */
+    HI_BOOL                         bSupportDolbyAtmos;/**<Dolby Atmos support or not*//**CNcomment:Dolby Atmos */
+}HI_UNF_EDID_AUDIO_INFO_S;
+
+/**EDID Audio speaker enum*//**CNcomment:EDID  */
+typedef enum hiUNF_EDID_AUDIO_SPEAKER_E
+{
+    HI_UNF_EDID_AUDIO_SPEAKER_FL_FR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_LFE     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RL_RR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLC_FRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RLC_RRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLW_FRW ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLH_FRH ,
+    HI_UNF_EDID_AUDIO_SPEAKER_TC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FCH     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_BUTT    ,
+} HI_UNF_EDID_AUDIO_SPEAKER_E;
+
+/**EDID MANUFACTURE Info struct*//**CNcomment:EDID */
+typedef struct hiUNF_EDID_MANUFACTURE_INFO_E
+{
+    HI_U8      u8MfrsName[4];            /**<Manufacture name*//**<CNcomment: */
+    HI_U32     u32ProductCode;           /**<Product code*//**<CNcomment:ID */
+    HI_U32     u32SerialNumber;          /**<Serial numeber of Manufacture*//**<CNcomment: */
+    HI_U32     u32Week;                  /**<the week of manufacture*//**<CNcomment:() */
+    HI_U32     u32Year;                  /**<the year of manufacture*//**<CNcomment:() */
+    HI_U8      u8pSinkName[14];          /**<Sink Name*//**<CNcomment:*/
+}HI_UNF_EDID_MANUFACTURE_INFO_S;
+
+
+/**EDID Display Base Parameters struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_BASE_PARA_S
+{
+    HI_U8      u8MaxImageWidth;               /**<The disp image max width  (0~255)cm*//**<CNcomment:  */
+    HI_U8      u8MaxImageHeight;              /**<The disp image max height (0~255)cm*//**<CNcomment:  */
+} HI_UNF_EDID_BASE_DISP_PARA_S;
+
+
+/**EDID Colorimety Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_COLORIMETRY_S
+{
+    HI_BOOL    bxvYCC601      ;          /**<The sink is support xcYCC601 or not flag*//**<CNcomment:xvYCC601 */
+    HI_BOOL    bxvYCC709      ;          /**<The sink is support xvYCC709 or not flag*//**<CNcomment:xvYCC709 */
+    HI_BOOL    bsYCC601       ;          /**<The sink is support sYCC601 or not flag*//**<CNcomment:sYCC601 */
+    HI_BOOL    bAdobleYCC601  ;          /**<The sink is support AdobleYCC601 or not flag*//**<CNcomment:AdobleYCC601 */
+    HI_BOOL    bAdobleRGB     ;          /**<The sink is support AdobleRGB or not flag*//**<CNcomment:AdobleRGB */
+    HI_BOOL    bBT2020cYCC    ;          /**<The sink is support BT2020cYCC or not flag*//**<CNcomment:BT2020cYCC */
+    HI_BOOL    bBT2020YCC     ;          /**<The sink is support BT2020YCC or not flag*//**<CNcomment:BT2020YCC */
+    HI_BOOL    bBT2020RGB     ;          /**<The sink is support BT2020RGB or not flag*//**<CNcomment:BT2020RGB */
+} HI_UNF_EDID_COLORIMETRY_S;
+
+/**EDID color space Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_COLOR_SPACE_S
+{
+    HI_BOOL    bRGB444        ;          /**<The sink is support RGB444 or not flag*//**<CNcomment:< RGB444 */
+    HI_BOOL    bYCbCr422      ;          /**<The sink is support YCbCr422 or not flag*//**<CNcomment:< YCbCr422 */
+    HI_BOOL    bYCbCr444      ;          /**<The sink is support YCbCr444 or not flag*//**<CNcomment:< YCbCr444 */
+    HI_BOOL    bYCbCr420      ;          /**<The sink is support YCbCr420 or not flag*//**<CNcomment:< YCbCr420 */
+} HI_UNF_EDID_COLOR_SPACE_S;
+
+/**EDID cec address Info struct*//**CNcomment:EDID cec */
+typedef struct hiUNF_EDID_CEC_ADDRESS_S
+{
+    HI_BOOL    bPhyAddrValid   ;          /**<the flag of phyiscs address is valid or not*//**<CNcomment:CEC */
+    HI_U8      u8PhyAddrA      ;          /**<phyiscs address A of CEC*//**<CNcomment:CECA */
+    HI_U8      u8PhyAddrB      ;          /**<phyiscs address B of CEC*//**<CNcomment:CECB */
+    HI_U8      u8PhyAddrC      ;          /**<phyiscs address C of CEC*//**<CNcomment:CECC */
+    HI_U8      u8PhyAddrD      ;          /**<phyiscs address D of CEC*//**<CNcomment:CECD */
+} HI_UNF_EDID_CEC_ADDRESS_S;
+
+/**EDID deep color Info struct*//**CNcomment:EDID  */
+typedef struct hiUNF_EDID_DEEP_COLOR_S
+{
+    HI_BOOL    bDeepColorY444   ;         /**<the Deep Color support YCBCR444-bits same with RGB-bits or not*//**<CNcomment: YCBCR 4:4:4  Deep Color RGBbit */
+    HI_BOOL    bDeepColor30Bit  ;         /**<the Deep Color support RGB 30 bit  or not *//**<CNcomment:RGB Deep Color 30bit  */
+    HI_BOOL    bDeepColor36Bit  ;         /**<the Deep Color support RGB 36 bit  or not *//**<CNcomment:RGB Deep Color 36bit  */
+    HI_BOOL    bDeepColor48Bit  ;         /**<the Deep Color support RGB 48 bit  or not *//**<CNcomment:RGB Deep Color 48bit  */
+} HI_UNF_EDID_DEEP_COLOR_S;
+
+typedef struct hiUNF_EDID_DEEP_COLOR_Y420_S
+{
+    HI_BOOL    bY420DeepColor30Bit  ;     /**<the Deep Color support YCBCR420  30 bit  or not *//**<CNcomment:YCBCR420 Deep Color 30bit  */
+    HI_BOOL    bY420DeepColor36Bit  ;     /**<the Deep Color support YCBCR420  36 bit  or not *//**<CNcomment:YCBCR420 Deep Color 36bit  */
+    HI_BOOL    bY420DeepColor48Bit  ;     /**<the Deep Color support YCBCR420  48 bit  or not *//**<CNcomment:YCBCR420 Deep Color 48bit  */
+} HI_UNF_EDID_DEEP_COLOR_Y420_S;
+
+typedef struct hiUNF_EDID_HDCP_S
+{
+    HI_BOOL     bHdcp14Support  ;         /**<the HDCP support HDCP1.4 or not *//**<CNcomment:HDCP1.4 */
+    HI_BOOL     bHdcp22Support  ;         /**<the HDCP support HDCP2.2 or not *//**<CNcomment:HDCP2.2 */
+} HI_UNF_EDID_HDCP_S;
+
+/**HDMI 3d enum type*/
+/**CNcomment: HDMI 3d  */
+typedef enum hiUNF_EDID_3D_TYPE_E
+{
+    HI_UNF_EDID_3D_FRAME_PACKETING                 = 0x00, /**<3d type:Frame Packing*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_FIELD_ALTERNATIVE               = 0x01, /**<3d type:Field alternative*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_LINE_ALTERNATIVE                = 0x02, /**<3d type:Line alternative*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_FULL               = 0x03, /**<3d type:Side by side full*//**<CNcomment:3d : */
+    HI_UNF_EDID_3D_L_DEPTH                         = 0x04, /**<3d type:L+depth*//**<CNcomment:3d :L+DEPTH*/
+    HI_UNF_EDID_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH = 0x05, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d :L+depth+Graphics+Graphics-depth*/
+    HI_UNF_EDID_3D_TOP_AND_BOTTOM                  = 0x06, /**<3d type:Top and Bottom*//**<CNcomment:3d :*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_HALF               = 0x08, /**<3d type:Side by side half*//**<CNcomment:3d : */
+    HI_UNF_EDID_3D_BUTT,
+}HI_UNF_EDID_3D_TYPE_E;
+
+/**3d Info struct*//**CNcomment: 3d  */
+typedef struct hiUNF_EDID_3D_INFO_S
+{
+    HI_BOOL    bSupport3D  ;                         /**<flag of 3d*//**<CNcomment:3d*/
+    HI_BOOL    bSupport3DType[HI_UNF_EDID_3D_BUTT] ; /**<supported 3d type*//**<CNcomment:3d*/
+} HI_UNF_EDID_3D_INFO_S;
+
+/**EDID detailed Timing Info struct*//**CNcomment: EDID */
+typedef struct hiUNF_EDID_TIMING_S
+{
+    HI_U32                        u32VFB;          /**<vertical front blank*//**<CNcomment:*/
+    HI_U32                        u32VBB;          /**<vertical back blank*//**<CNcomment:*/
+    HI_U32                        u32VACT;         /**<vertical active area*//**<CNcomment:*/
+    HI_U32                        u32HFB;          /**<horizonal front blank*//**<CNcomment:*/
+    HI_U32                        u32HBB;          /**<horizonal back blank*//**<CNcomment:*/
+    HI_U32                        u32HACT;         /**<horizonal active area*/ /**<CNcomment:*/
+    HI_U32                        u32VPW;          /**<vertical sync pluse width*//**<CNcomment:*/
+    HI_U32                        u32HPW;          /**<horizonal sync pluse width*/ /**<CNcomment:*/
+    HI_BOOL                       bIDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:*/
+    HI_BOOL                       bIHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:*/
+    HI_BOOL                       bIVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:*/
+    HI_U32                        u32ImageWidth;   /**<image width *//**<CNcomment:*/
+    HI_U32                        u32ImageHeight;  /**<image height *//**<CNcomment: */
+    HI_U32                        u32AspectRatioW; /**<aspect ratio width *//**<CNcomment: */
+    HI_U32                        u32AspectRatioH; /**<aspect ratio height *//**<CNcomment: */
+    HI_BOOL                       bInterlace;      /**<flag of interlace *//**<CNcomment: */
+    HI_S32                        u32PixelClk;     /**<pixelc clk for this timing *//**<CNcomment: */
+} HI_UNF_EDID_TIMING_S;
+
+/**the max audio capability count*//**CNcomment: */
+#define HI_UNF_EDID_MAX_AUDIO_CAP_COUNT  16
+
+/**EDID Dolby capability in VSVDB version 0*//**CNcomment: EDID VSVDB0Dolby*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_0_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal *//**<CNcomment:YUV422-12BitDolby*/
+    HI_BOOL     b2160P60;               /* capable of processing a max timming 3840X2160p60(HI_TRUE) /3840X2160p30(HI_FALSE) *//**<CNcomment:4kp604kp30 */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:global dimming(HI_TRUE)(HI_FALSE)*/
+    HI_U16      u16White_X;             /* white point chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0. */
+    HI_U16      u16White_Y;             /* white point  chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0.*/
+    HI_U8       u8DMmajorVersion;       /* the major version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U8       u8DMminorVersion;       /* the minor version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U16      u16TargetMinPQ;         /* Perceptual quantization(PQ)-encoded value of minimum display luminance */
+    HI_U16      u16TargetMaxPQ;         /* PQ-encoded value of maximum display luminance */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_0_S;
+
+/**EDID Dolby capability in VSVDB version 1*//**CNcomment: EDID VSVDB1Dolby*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_1_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal; For low-latency dolbyvision this flag is ingnored *//**<CNcomment:YUV422-12BitDolby, Low-latency */
+    HI_BOOL     b2160P60;               /* capable of processing a max timming 3840X2160p60(HI_TRUE) /3840X2160p30(HI_FALSE); For low-latency dolbyvision this bit maybe ingnored,relay on supported video format from the E-EDID *//**<CNcomment:4kp604kp30, Low-latency */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:global dimming(HI_TRUE)(HI_FALSE)*/
+    HI_BOOL     bColorimetry;           /* this bit is valid only u8VSVDBVersion = 1. 0: Dolby Vision HDMI sink's colorimetry is close to Rec.709, 1: EDR HDMI sink's colorimetry is close to P3, if Byte[9] to Byte[14] are present, ignores this bit. *//**<CNcomment:0Dolby Vision SinkRec.7091Dolby Vision SinkP3Byte[9]Byte[14]*/
+    HI_U8       u8DMVersion;            /* 0:based on display management v2.x; 1:based on the video and blending pipeline v3.x; 2-7: reserved. only support when u8VSVDBVersion = 1. */
+    HI_U8       u8LowLatency;           /* 0:supports only standard DolbyVison; 1: Supports low latency with 12-bit YCbCr 4:2:2 interface using the HDMI native 12-bit YCbCr4:2:2 pixel encoding and standard Dolby Vision interface; 2-3:reserved */
+    HI_U16      u16TargetMinLuminance;  /* minimum display luminance = (100+50*CV)cd/m2, where CV is the value */
+    HI_U16      u16TargetMaxLuminance;  /* maximum display luminance = (CV/127)^2cd/m2, where CV is the value */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_1_S;
+
+/**EDID Dolby capability in VSVDB version 2*//**CNcomment: EDID VSVDB2Dolby*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_2_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal */
+    HI_BOOL     bBackLightContol;       /* supports Backlight Control */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:global dimming(HI_TRUE)(HI_FALSE)*/
+    HI_U8       u8DMVersion;            /* 0:based on display management v2.x; 1:based on the video and blending pipeline v3.x; 2-7: reserved. only support when u8VSVDBVersion = 1. */
+    HI_U8       u8BackLtMinLuma;        /* minimum luminance level 0:25cd/m2 1:50cd/m2 2:75cd/m2 3:100cd/m2 */
+    HI_U8       u8Interface;            /* 0:support only "low latency with YUV422" 1:support both "low latency with YUV422" and YUV444/RGB_10/12bit* 2:support both "standard DolbyVision" and "low latency with YUV422" 3:support "standard DolbyVision" "low latency YUV422 YUV444/RGB_10/12bit" */
+    HI_U8       u8YUV444RGB444_10b12b;  /* 0:not support 1:support YUV444/RGB444_10bit 2:support YUV444/RGB444_12bit 3:reserved */
+    HI_U16      u16TargetMinPQv2;       /* maximum display luminance, in the PQ-encoded value= u16TargetMinPQv2*20. A code value of 31 is approximately equivalent to 1cd/m2 */
+    HI_U16      u16TargetMaxPQv2;       /* minimum display luminance, in the PQ-encoded value= 2055+u16TargetMaxPQv2*65. */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_2_S;
+
+/**EDID union of Dolby capability.*//**CNcomment: EDID Dolby*/
+typedef union hiUNF_EDID_DOLBY_CAPS_U
+{
+    HI_UNF_EDID_DOLBY_CAPS_VER_0_S stVer0;
+    HI_UNF_EDID_DOLBY_CAPS_VER_1_S stVer1;
+    HI_UNF_EDID_DOLBY_CAPS_VER_2_S stVer2;
+}HI_UNF_EDID_DOLBY_CAPS_U;
+
+/**EDID Dolby capability.see <Dolby  Vision  HDMI Transmission Specification> *//**CNcomment: EDID DolbyDolby  Vision  HDMI Transmission Specification*/
+typedef struct hiUNF_EDID_DOLBY_CAP_S
+{
+    HI_U8       u8VSVDBVersion;         /**<the version of VSVDB, value of 0-version0, 1-version1 2-version2, others means we not support at present. see <Dolby Vision HDMI Transmission Specification issue 2.9>*//**<CNcomment:VSVDB,00,11,22*/
+    HI_UNF_EDID_DOLBY_CAPS_U unVersionCaps; /**<DolbyVision capability in Dolby VSVDB. stVer0(u8VSVDBVersion=0) and stVer1(u8VSVDBVersion=1) and stVer2(u8VSVDBVersion=2).*//**<CNcomment:DolbyDolby VSVDBstVer0(u8VSVDBVersion=0),stVer1(u8VSVDBVersion=1),stVer2(u8VSVDBVersion=2),*/
+}HI_UNF_EDID_DOLBY_CAP_S;
+
+/**EDID EOTF support. *//**CNcomment:EDID EOTF */
+typedef struct hiUNF_EDID_EOTF_S
+{
+    HI_BOOL bEotfSdr;               /**<Traditional gamma - SDR Luminance Range. *//**<CNcomment:SinkSDR EOTF*/
+    HI_BOOL bEotfHdr;               /**<Traditional gamma - HDR Luminance Range. *//**<CNcomment:SinkHDR EOTF*/
+    HI_BOOL bEotfSmpteSt2084;       /**<SMPTE ST 2084 *//**<CNcomment:SinkSmpteSt2084 EOTF*/
+    HI_BOOL bEotfHLG;               /**<Hybrid Log-Gamma(HLG) based on Recommendation ITU-R BT.2100-0 *//**<CNcomment:SinkHybrid Log-Gamma(HLG) */
+    HI_BOOL bEotfFuture;            /**<Future EOTF *//**<CNcomment:SinkEOTF*/
+}HI_UNF_EDID_EOTF_S;
+
+/**EDID Supported Static Metadata Descriptor *//**CNcomment:EDID Metadata */
+typedef struct hiUNF_EDID_HDR_METADATA_TYPE_S
+{
+    HI_BOOL bDescriptorType1;       /**<Support Static Metadata Type 1 or not.*//**<CNcomment:Sinkmetadata1*/
+}HI_UNF_EDID_HDR_METADATA_TYPE_S;
+
+/**EDID HDR capability,see <CEA-861.3-2015> *//**CNcomment:EDID HDRCEA-861.3-2015 */
+typedef struct hiUNF_EDID_HDR_CAP_S{
+
+    HI_UNF_EDID_EOTF_S                  stEotf;                 /**<EOTF support. *//**<CNcomment:SinkEOTF*/
+    HI_UNF_EDID_HDR_METADATA_TYPE_S     stMetadata;             /**<static metadata descriptor type(ID) support. *//**<CNcomment:Sinkmetadata*/
+    HI_U8                               u8MaxLuminance_CV;      /**<Desired Content Max Luminance Data. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink*/
+    HI_U8                               u8AverageLumin_CV;      /**<Desired Content Max Frame-average Luminance. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink*/
+    HI_U8                               u8MinLuminance_CV;      /**<Desired Content Min Luminance Data. Real value(in 1cd/m^2) = u8MaxLuminance_CV * (u8MinLuminance_CV/255)^2 / 100  *//**<CNcomment:Sink*/
+}HI_UNF_EDID_HDR_CAP_S;
+
+/**EDID Latency capability,see <HDMI1.4b> Page154 *//**CNcomment:Latency<HDMI1.4b> 154 */
+typedef struct hiUNF_EDID_LATENCY_S{
+    HI_BOOL  bLatencyPresent;                  /**<Latency info is valid. *//**<CNcomment:Latency*/
+    HI_U32   u32PVideoLatency;                 /**<video latency for progressive video formats.in milliseconds *//**<CNcomment:latencyms*/
+    HI_U32   u32PAudioLatency;                 /**<audio latency for progressive video formats.in milliseconds *//**<CNcomment:latencyms*/
+    HI_U32   u32IVideoLatency;                 /**<video latency for interlaced video formats.in milliseconds *//**<CNcomment:latencyms*/
+    HI_U32   u32IAudioLatency;                 /**<audio latency for interlaced video formats.in milliseconds *//**<CNcomment:latencyms*/
+}HI_UNF_EDID_LATENCY_S;
+
+
+/**HDMI sink capability of interface*/
+/**CNcomment: HDMI sink  */
+typedef struct hiUNF_EDID_BASE_INFO_S
+{
+    HI_BOOL                         bSupportHdmi;           /**<The Device suppot HDMI or not,the device is DVI when nonsupport HDMI*//**<CNcomment:HDMIDVI.*/
+    HI_UNF_ENC_FMT_E                enNativeFormat;         /**<The sink native video format*//**<CNcomment: */
+    HI_BOOL                         bSupportFormat[HI_UNF_ENC_FMT_BUTT]; /**<video capability,HI_TRUE:support the video display format;HI_FALSE:nonsupport the video display foramt*//**<CNcomment:,HI_TRUEHI_FALSE */
+    HI_UNF_EDID_3D_INFO_S           st3DInfo;               /**<3d Info*//**<CNcomment:3d  */
+    HI_UNF_EDID_DEEP_COLOR_S        stDeepColor;            /**<YCBCR/RGB deep color Info*//**<CNcomment:YCBCR/RGB deep color */
+    HI_UNF_EDID_COLORIMETRY_S       stColorMetry;           /**<colorimetry Info*//**<CNcomment: */
+    HI_UNF_EDID_COLOR_SPACE_S       stColorSpace;           /**<color space Info*//**<CNcomment: */
+    HI_BOOL                         bYccQrangeSelectable;   /**<flag of YCC Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:SinkRGB/ HI_TRUEsinkHI_FALSEsink*/
+    HI_BOOL                         bRgbQrangeSelectable;   /**<flag of RGB Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:SinkYCC/ HI_TRUEsinkHI_FALSEsink*/
+
+    HI_UNF_EDID_AUDIO_INFO_S        stAudioInfo[HI_UNF_EDID_MAX_AUDIO_CAP_COUNT];   /**<audio Info*//**<CNcomment: */
+    HI_U32                          u32AudioInfoNum;                                /**<num of audio Info*//**<CNcomment:  */
+    HI_BOOL                         bSupportAudioSpeaker[HI_UNF_EDID_AUDIO_SPEAKER_BUTT];/**<speaker Info*//**<CNcomment:speaker  */
+
+    HI_U8                           u8ExtBlockNum;          /**<edid extend block num Info*//**<CNcomment:edid */
+
+    HI_U8                           u8Version;              /**<the version of manufacture*//**<CNcomment: */
+    HI_U8                           u8Revision;             /**<the revision of manufacture*//**<CNcomment: */
+    HI_UNF_EDID_MANUFACTURE_INFO_S  stMfrsInfo;
+
+    HI_UNF_EDID_CEC_ADDRESS_S       stCECAddr;              /**<cec address Info*//**<CNcomment:cec */
+    HI_BOOL                         bSupportDVIDual;        /**<the DVI support dual-link or not *//**<CNcomment: DVI dual-link  */
+    HI_BOOL                         bSupportsAI;            /**<support AI or not *//**<CNcomment: Supports_AI  */
+    HI_UNF_EDID_TIMING_S            stPerferTiming;         /**<first detailed timing Info*//**<CNcomment:VESA */
+    HI_U32                          u32MaxTMDSClock;        /**<Max TMDS clock in MHz*//**<CNcomment:TMDS(MHz) */
+    HI_BOOL                         bSupportY420Format[HI_UNF_ENC_FMT_BUTT];/**<video capability,HI_TRUE:support the video display format in YCBCR420;HI_FALSE:nonsupport the video display foramt  in YCBCR420*//**<CNcomment:,HI_TRUEYCBCR420HI_FALSE */
+    HI_UNF_EDID_DEEP_COLOR_Y420_S   stY420DeepColor;        /**<YCBCR deep color Info*//**<CNcomment:YCBCR420 deep color  */
+
+    HI_BOOL                         bDolbySupport;          /**<Dolby support flag.When VSVDB is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:VSVDBHI_TRUE;HI_FALSE.*/
+    HI_UNF_EDID_DOLBY_CAP_S         stDolby;                /**<Dolby capability*//**<CNcomment:Dolby */
+    HI_BOOL                         bHdrSupport;            /**<HDR support flag.When HDR Static Metadata Data Block is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:HDR (HI_UNF_EDID_EOTF_SHI_TRUE)HI_TRUE;HI_FALSE.*/
+    HI_UNF_EDID_HDR_CAP_S           stHdr;                  /**<HDR capability*//**<CNcomment:HDR */
+    HI_UNF_EDID_HDCP_S              stHDCPSupport;          /**<HDCP capability,HI_TRUE:support the HDCP version;HI_FALSE:nonsupport the HDCP version*//**<CNcomment:HDCP,HI_TRUEHDCPHI_FALSE */
+    HI_UNF_EDID_BASE_DISP_PARA_S    stBaseDispPara;         /**<the parameters of display*//**<CNcomment:  */
+    HI_UNF_EDID_LATENCY_S           stLatency;              /**<Latency information*//**<CNcomment: Latency  */
+
+} HI_UNF_EDID_BASE_INFO_S;
+
+/**enum define about Video port*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_VIDEO_PORT_E
+{
+    HI_UNF_EDID_VIDEO_PORT_VGA   = 0x00,/**<VGA port *//**<CNcomment: VGA */
+    HI_UNF_EDID_VIDEO_PORT_DVI,         /**<DVI port *//**<CNcomment: DVI */
+    HI_UNF_EDID_VIDEO_PORT_HDMI,        /**<HDMI port *//**<CNcomment: HDMI  */
+    HI_UNF_EDID_VIDEO_PORT_BUTT
+} HI_UNF_EDID_VIDEO_PORT_E;
+
+/**enum define about timing protocol type*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_TIMING_TYPE_E
+{
+    HI_UNF_EDID_TIMING_TYPE_DMT= 0x00,/**< DMT  protocol Timing *//**<CNcomment: DMT */
+    HI_UNF_EDID_TIMING_TYPE_861,/**< 861D  protocol Timing *//**<CNcomment: 861D */
+    HI_UNF_EDID_TIMING_TYPE_CVT,/**< CVT  protocol Timing *//**<CNcomment: CVT */
+    HI_UNF_EDID_TIMING_TYPE_CVT_RB,/**< CVT_RB  protocol Timing *//**<CNcomment: CVT_RB */
+    HI_UNF_EDID_TIMING_TYPE_GTF,/**< GTF  protocol Timing *//**<CNcomment: GTF */
+    HI_UNF_EDID_TIMING_TYPE_BUTT
+} HI_UNF_EDID_TIMING_TYPE_E;
+
+/**enum define about timing type*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_TIMING_ATTR_E
+{
+    HI_UNF_EDID_TIMING_ATTR_NONE = 0x00,/**< None *//**<CNcomment:  */
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_TIMING,/**< None *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_VERTICAL_FREQ,/**< None *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_BUTT
+} HI_UNF_EDID_TIMING_ATTR_E;
+
+/**Detailed Timing Definitions Sync Signal Definitions*/
+/**CNcomment:*/
+typedef enum hiUNF_EDID_SYNC_TYPE_E
+{
+    /*Analog Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_ACS_WS_GREEN    = 0x00,     /**<Analog Composite Sync - Without Serrations - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_WS_ALL,                 /**<Analog Composite Sync - Without Serrations - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_DS_GREEN,               /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_ACS_DS_ALL,                 /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_WS_GREEN,              /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On Green Signal only*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_WS_ALL,                /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On all three (RGB) video signals*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_BACS_DS_GREEN,              /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment:  */
+    HI_UNF_EDID_SYNC_BACS_DS_ALL,                /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment:  */
+    /*Digital Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_DCS_WS,                     /**<Digital Composite Sync - Without Serrations*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_DCS_DS,                     /**<Digital Composite Sync - With Serrations (H-sync during V-sync)*//**<CNcomment: */
+    HI_UNF_EDID_SYNC_DSS_VN_HN,                  /**<Digital Separate Sync Vsync(-) Hsync(-)*//**<CNcomment: (-)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VN_HP,                  /**<Digital Separate Sync Vsync(-) Hsync(+)*//**<CNcomment: (-)(+)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HN,                  /**<Digital Separate Sync Vsync(+) Hsync(-)*//**<CNcomment: (+)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HP,                  /**<Digital Separate Sync Vsync(+) Hsync(+)*//**<CNcomment: (+)(+)*/
+    HI_UNF_EDID_SYNC_BUTT
+} HI_UNF_EDID_SYNC_TYPE_E;
+
+
+/**Simple Timing Definitions*/
+/**CNcomment:*/
+typedef struct hiUNF_EDID_SIMPLE_TIMING_S
+{
+    HI_U32              u32Vact;    /**<  Active Line *//**<CNcomment: */
+    HI_U32              u32Hact;/**< Active Pixels *//**<CNcomment: */
+    HI_U32              u32VerFreq;/**<Ver Frequency *//**<CNcomment:  */
+    HI_UNF_EDID_TIMING_TYPE_E          enTimingType;/**< Timing protocol type *//**<CNcomment: */
+    HI_UNF_EDID_TIMING_ATTR_E          enTimingAttr;/**<timing type *//**<CNcomment: :*/
+} HI_UNF_EDID_SIMPLE_TIMING_S;
+
+/**Detailed Timing Definitions*/
+/**CNcomment:*/
+typedef struct hiUNF_EDID_DETAIL_TIMING_S
+{
+    HI_UNF_EDID_TIMING_S                stTiming; /**<  Detailed Timing *//**<CNcomment: */
+    HI_UNF_EDID_SYNC_TYPE_E             enSyncType;/**Detailed Timing Definitions Sync Signal Definitions*//**CNcomment:*/
+    HI_UNF_EDID_TIMING_ATTR_E           enTimingAttr;/**<timing type *//**<CNcomment: :*/
+} HI_UNF_EDID_DETAIL_TIMING_S;
+
+/**EDID information*/
+/**CNcomment:EDID*/
+typedef struct hiUNF_EDID_INFO_S
+{
+    HI_UNF_EDID_BASE_INFO_S         stEDIDBaseInfo;/**< EDID base information *//**<CNcomment: EDID */
+    HI_UNF_EDID_VIDEO_PORT_E        enVideoPort;                  /**<video port  *//**<CNcomment:  */
+    HI_UNF_EDID_SIMPLE_TIMING_S*    pstSimpleTiming;    /**<Simple timing   *//**<CNcomment: */
+    HI_U32                          u32SimpleTimingNum;/**<Simple timing number *//**<CNcomment: */
+    HI_UNF_EDID_DETAIL_TIMING_S*    pstDetailTiming;    /**<Simple timing *//**<CNcomment: */
+    HI_U32                          u32DetailTimingNum;/**<Simple timing number *//**<CNcomment: */
+} HI_UNF_EDID_INFO_S;
+
+
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      EDID*/
+/** @{*/  /** <!-- [EDID] */
+
+
+/**
+\brief parse the edid information. CNcomment:EDID CNend
+\attention \n
+\param[in]  u32EdidLength EDID data length . CNcomment:EDID   CNend
+\param[in]  *pu8Edid  EDID data point . CNcomment:EDID CNend
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDIDCNend
+
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_EDID_EdidParse(HI_U8* pu8Edid, HI_U32 u32EdidLength, HI_UNF_EDID_INFO_S* pstEdidInfo);
+
+/**
+\brief release the edid information. CNcomment:EDID CNend
+\attention \n
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDIDCNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_VOID HI_UNF_EDID_EdidRelease(HI_UNF_EDID_INFO_S * pstEdidInfo);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_EDID_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_frontend.h b/xbmc/platform/linux/hisi/hi_unf_frontend.h
new file mode 100644
index 0000000000..fb16da1d6a
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_frontend.h
@@ -0,0 +1,2547 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name       : hi_unf_frontend.h
+Version         : Initial draft
+Author          : HiSilicon multimedia software group
+Created Date    : 2008-06-05
+Description     : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List   :
+Change History  :
+ ******************************************************************************/
+#ifndef __HI_UNF_FRONTEND_H__
+#define __HI_UNF_FRONTEND_H__
+
+#include "hi_common.h"
+
+#include "hi_unf_i2c.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_I2C_MAX_NUM_USER (15)    /** Maximum I2C channel ID*/ /** CNcomment:I2C*/
+
+#define HI_UNF_DISEQC_MSG_MAX_LENGTH    (6)     /** DiSEqC message length*/  /** CNcomment:DiSEqC*/
+#define HI_UNF_DISEQC_MAX_REPEAT_TIMES  (4)     /** DiSEqC message max repeat times*/ /** CNcomment:DiSEqC*/
+#define MAX_TS_LINE 11                      /** The NO of ts lines that can be configured*/ /** CNcomment:ts*/
+#define TER_MAX_TP              (20)
+
+#define DISEQC_MAX_MOTOR_PISITION (255) /** DiSEqC motor max stored position*/ /** CNcomment:DiSEqC*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+
+/** Sample data, complex format*/
+/** CNcomment: , */
+typedef struct  hiUNF_TUNER_SAMPLE_DATA_S
+{
+    HI_S32 s32DataIP;   /*sample data, i component*/    /**<CNcomment:I*/
+    HI_S32 s32DataQP;   /*sample data, q component*/    /**<CNcomment:Q*/
+} HI_UNF_TUNER_SAMPLE_DATA_S;
+
+/** Sample data length*/
+/** CNcomment: */
+typedef enum hiUNF_TUNER_SAMPLE_DATALEN_E
+{
+    HI_UNF_TUNER_SAMPLE_DATALEN_32,         /*sample 32 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_64,         /*sample 64 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_128,        /*sample 128 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_256,        /*sample 256 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_512,        /*sample 512 pts*/      /**<CNcomment:512*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_1024,       /*sample 1024 pts*/     /**<CNcomment:1024*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_2048,       /*sample 2048 pts*/     /**<CNcomment:2048*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_BUTT        /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_SAMPLE_DATALEN_E;
+
+/** Modulation mode*/
+/** CNcomment: */
+typedef enum hiUNF_QAM_TYPE_E
+{
+    HI_UNF_MOD_TYPE_DEFAULT,          /**<Default QAM mode. The default QAM mode is HI_UNF_MOD_TYPE_QAM_64 at present.*/                /**<CNcomment:QAM, HI_UNF_MOD_TYPE_QAM_64 */
+    HI_UNF_MOD_TYPE_QAM_16 = 0x100,   /**<Enumeration corresponding to the 16QAM mode*/                                                 /**<CNcomment:16QAM*/
+    HI_UNF_MOD_TYPE_QAM_32,           /**<Enumeration corresponding to the 32QAM mode*/                                                 /**<CNcomment:32QAM*/
+    HI_UNF_MOD_TYPE_QAM_64,           /**<Enumeration corresponding to the 64QAM mode*/                                                 /**<CNcomment:64QAM*/
+    HI_UNF_MOD_TYPE_QAM_128,          /**<Enumeration corresponding to the 128QAM mode*/                                                /**<CNcomment:128QAM*/
+    HI_UNF_MOD_TYPE_QAM_256,          /**<Enumeration corresponding to the 256QAM mode*/                                                /**<CNcomment:256QAM*/
+    HI_UNF_MOD_TYPE_QAM_512,          /**<Enumeration corresponding to the 512QAM mode*/                                                /**<CNcomment:512QAM*/
+
+    HI_UNF_MOD_TYPE_BPSK = 0x200,     /**<Enumeration corresponding to the binary phase shift keying (BPSK) mode. */                    /**<CNcomment:BPSK*/
+    HI_UNF_MOD_TYPE_QPSK = 0x300,     /**<Enumeration corresponding to the quaternary phase shift keying (QPSK) mode. */                /**<CNcomment:QPSK*/
+    HI_UNF_MOD_TYPE_DQPSK,
+    HI_UNF_MOD_TYPE_8PSK,             /**<Enumeration corresponding to the 8 phase shift keying (8PSK) mode*/                           /**<CNcomment:8PSK*/
+    HI_UNF_MOD_TYPE_16APSK,           /**<Enumeration corresponding to the 16-Ary Amplitude and Phase Shift Keying (16APSK) mode*/      /**<CNcomment:16APSK*/
+    HI_UNF_MOD_TYPE_32APSK,           /**<Enumeration corresponding to the 32-Ary Amplitude and Phase Shift Keying (32APSK) mode*/      /**<CNcomment:32APSK*/
+    HI_UNF_MOD_TYPE_64APSK,           /**<Enumeration corresponding to the 64-Ary Amplitude and Phase Shift Keying (64APSK) mode*/      /**<CNcomment:64APSK*/
+    HI_UNF_MOD_TYPE_128APSK,          /**<Enumeration corresponding to the 128-Ary Amplitude and Phase Shift Keying (128APSK) mode*/    /**<CNcomment:128APSK*/
+    HI_UNF_MOD_TYPE_256APSK,          /**<Enumeration corresponding to the 256-Ary Amplitude and Phase Shift Keying (256APSK) mode*/    /**<CNcomment:256APSK*/
+    HI_UNF_MOD_TYPE_8VSB,             /**<Enumeration corresponding to (8VSB) mode*/                                                    /**<CNcomment:8VSB*/
+    HI_UNF_MOD_TYPE_16VSB,            /**<Enumeration corresponding to (16VSB) mode*/                                                   /**<CNcomment:16VSB*/
+    HI_UNF_MOD_TYPE_VLSNR_SET1,         /**<Enumeration corresponding to (VLSNR_SET1) mode,only used in DVB-S2X*/                       /**<CNcomment:VLSNR_SET1DVB-S2X*/
+    HI_UNF_MOD_TYPE_VLSNR_SET2,         /**<Enumeration corresponding to (VLSNR_SET2) mode,only used in DVB-S2X*/                       /**<CNcomment:VLSNR_SET2DVB-S2X*/
+    HI_UNF_MOD_TYPE_8APSK,              /**<Enumeration corresponding to (8APSK) mode,only used in DVB-S2x*/                            /**<CNcomment:8APSKDVB-S2X*/
+
+    /**<Enumeration corresponding to the auto mode. For DVB-S/S2, if detect modulation type fail, it will return auto*/
+    /**<CNcomment:AUTO*/
+    HI_UNF_MOD_TYPE_AUTO,
+
+    HI_UNF_MOD_TYPE_BUTT              /**<Invalid Modulation mode*/       /**<CNcomment:*/
+} HI_UNF_MODULATION_TYPE_E;
+
+/** Frequency locking status of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum  hiUNF_TUNER_LOCK_STATUS_E
+{
+    HI_UNF_TUNER_SIGNAL_DROPPED = 0,       /**<The signal is not locked.*/  /**<CNcomment:*/
+    HI_UNF_TUNER_SIGNAL_LOCKED,            /**<The signal is locked.*/      /**<CNcomment:*/
+    HI_UNF_TUNER_SIGNAL_BUTT               /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_TUNER_LOCK_STATUS_E;
+
+/** Output mode of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_OUTPUT_MODE_E
+{
+    HI_UNF_TUNER_OUTPUT_MODE_DEFAULT               = 0,   /**<Default mode*/                       /**<CNcomment:*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_A       = 1,   /**<Parallel mode A*/                    /**<CNcomment:A*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_B       = 2,   /**<Parallel mode B*/                    /**<CNcomment:B*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL                = 3,   /**<Serial mode 74.25M*/                 /**<CNcomment:74.25M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_50             = 4,   /**<Serial mode 50M*/                    /**<CNcomment:50M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_2BIT           = 5,   /**<Serial mode witch 2 bit data line*/  /**<CNcomment:2bit*/
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_PARALLEL     = 6,   /**<FULLBAND Parallel mode */            /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_3WIRE = 7,   /**<FULLBAND SERIAL three wire mode */   /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_4WIRE = 8,   /**<FULLBAND SERIAL four wire mode */    /**<CNcomment:FULLBAND */
+    HI_UNF_TUNER_OUTPUT_MODE_BUTT                         /**<Invalid value*/                      /**<CNcomment:*/
+} HI_UNF_TUNER_OUPUT_MODE_E;
+
+/** Output order*/
+/** CNcomment:TUNER */
+typedef enum hiUNF_TUNER_OUTPUT_TS_E
+{
+    HI_UNF_TUNER_OUTPUT_TSDAT0,        /**<data0*/                       /**<CNcomment:0bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT1,        /**<data1*/                       /**<CNcomment:1bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT2,        /**<data2*/                       /**<CNcomment:2bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT3,        /**<data3*/                       /**<CNcomment:3bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT4,        /**<data4*/                       /**<CNcomment:4bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT5,        /**<data5*/                       /**<CNcomment:5bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT6,        /**<data6*/                       /**<CNcomment:6bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT7,        /**<data7*/                       /**<CNcomment:7bit*/
+    HI_UNF_TUNER_OUTPUT_TSSYNC,        /**<sync*/                        /**<CNcomment:sync*/
+    HI_UNF_TUNER_OUTPUT_TSVLD,         /**<valid*/                       /**<CNcomment:valid*/
+    HI_UNF_TUNER_OUTPUT_TSERR,         /**<err*/                         /**<CNcomment:err*/
+    HI_UNF_TUNER_OUTPUT_BUTT           /**<Invalid value*/               /**<CNcomment:*/
+} HI_UNF_TUNER_OUTPUT_TS_E;
+
+/** ts output port order*/
+/** CNcomment:ts */
+typedef struct hiUNF_TUNER_TSOUT_SET_S
+{
+    HI_UNF_TUNER_OUTPUT_TS_E enTSOutput[MAX_TS_LINE];   /**<ts output port order*/    /**<CNcomment:ts*/
+} HI_UNF_TUNER_TSOUT_SET_S;
+
+/** Signal type of the tuner*/
+/** CNcomment:TUNER*/
+typedef enum    hiTUNER_SIG_TYPE_E
+{
+    HI_UNF_TUNER_SIG_TYPE_CAB       = 1,        /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX A/C(DVB_C)*/
+    HI_UNF_TUNER_SIG_TYPE_SAT       = 2,        /**<Satellite signal*/      /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T     = 4,        /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T2    = 8,        /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_ISDB_T    = 16,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_ATSC_T    = 32,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_DTMB      = 64,       /**<Terrestrial signal*/    /**<CNcomment:*/
+    HI_UNF_TUNER_SIG_TYPE_J83B      = 128,      /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX B(US Cable)*/
+    HI_UNF_TUNER_SIG_TYPE_ABSS      = 256,      /**ABS-S signal */          /**<CNcomment: */
+    HI_UNF_TUNER_SIG_TYPE_BUTT                  /**<Invalid value*/         /**<CNcomment:*/
+} HI_UNF_TUNER_SIG_TYPE_E;
+
+/** type of TUNER device*/
+/** CNcomment:TUNER*/
+typedef enum    hiUNF_TUNER_DEV_TYPE_E
+{
+    HI_UNF_TUNER_DEV_TYPE_XG_3BL        = 0,    /**<XG_3BL,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616        = 1,    /**<CD1616,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_ALPS_TDAE     = 2,    /**<ALPS_TDAE,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDCC          = 3,    /**<TDCC,                   Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250      = 4,    /**<TDA18250*/                                 /**<CNcomment:TDA18250*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616_DOUBLE = 5,    /**<CD1616 with double agc, Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MT2081        = 6,    /**<MT2081,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TMX7070X      = 7,    /**<THOMSON7070X,           Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_R820C         = 8,    /**<R820C*/                                    /**<CNcomment:R820C*/
+    HI_UNF_TUNER_DEV_TYPE_MXL203        = 9,    /**<MXL203 */                                  /**<CNcomment:MXL203*/
+    HI_UNF_TUNER_DEV_TYPE_AV2011        = 10,   /**<AV2011*/                                   /**<CNcomment:AV2011*/
+    HI_UNF_TUNER_DEV_TYPE_SHARP7903     = 11,   /**<SHARP7903,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL101        = 12,   /**<MXL101,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL603        = 13,   /**<MXL603*/                                   /**<CNcomment:MXL603*/
+    HI_UNF_TUNER_DEV_TYPE_IT9170        = 14,   /**<IT9170,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_IT9133        = 15,   /**<IT9133,                 Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA6651       = 16,   /**<TDA6651,                Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250B     = 17,   /**<TDA18250B*/                                /**<CNcomment:TDA18250B*/
+    HI_UNF_TUNER_DEV_TYPE_M88TS2022     = 18,   /**<M88TS2022,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_RDA5815       = 19,   /**<RDA5815*/                                  /**<CNcomment:RDA5815*/
+    HI_UNF_TUNER_DEV_TYPE_MXL254        = 20,   /**<MXL254*/                                   /**<CNcomment:MXL254*/
+    HI_UNF_TUNER_DEV_TYPE_CXD2861       = 21,   /**<CXD2861,                Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_SI2147        = 22,   /**<Si2147*/                                   /**<CNcomment:Si2147*/
+    HI_UNF_TUNER_DEV_TYPE_RAFAEL836     = 23,   /**<Rafael836*/                                /**<CNcomment:Rafael836*/
+    HI_UNF_TUNER_DEV_TYPE_MXL608        = 24,   /**<MXL608*/                                   /**<CNcomment:MXL608*/
+    HI_UNF_TUNER_DEV_TYPE_MXL214        = 25,   /**<MXL214*/                                   /**<CNcomment:MXL214*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18280      = 26,   /**<TDA18280*/                                 /**<CNcomment:TDA18280*/
+    HI_UNF_TUNER_DEV_TYPE_TDA182I5A     = 27,   /**<TDA182I5A*/                                /**<CNcomment:TDA182I5A*/
+    HI_UNF_TUNER_DEV_TYPE_SI2144        = 28,   /**<Si2144*/                                   /**<CNcomment:Si2144*/
+    HI_UNF_TUNER_DEV_TYPE_AV2018        = 29,   /**<AV2018*/                                   /**<CNcomment:AV2018*/
+    HI_UNF_TUNER_DEV_TYPE_MXL251        = 30,   /**<MXL251*/                                   /**<CNcomment:MXL251*/
+    HI_UNF_TUNER_DEV_TYPE_M88TC3800     = 31,   /**<M88TC3800,              Not supported*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_MXL601        = 32,   /**< MXL601 */                                 /**<CNcomment:MXL601*/
+    HI_UNF_TUNER_DEV_TYPE_MXL683        = 33,   /**<MXL683*/                                   /**<CNcomment:MXL683*/
+    HI_UNF_TUNER_DEV_TYPE_AV2026        = 34,   /**<AV2026*/                                   /**<CNcomment:AV2026*/
+    HI_UNF_TUNER_DEV_TYPE_R850          = 35,   /**<R850*/                                     /**<CNcomment:R850*/
+    HI_UNF_TUNER_DEV_TYPE_R858          = 36,   /**<R858*/                                     /**<CNcomment:R858*/
+    HI_UNF_TUNER_DEV_TYPE_MXL541        = 37,   /**<MXL541*/                                   /**<CNcomment:MXL541*/
+    HI_UNF_TUNER_DEV_TYPE_MXL581        = 38,   /**<MXL581*/                                   /**<CNcomment:MXL581*/
+    HI_UNF_TUNER_DEV_TYPE_MXL582        = 39,   /**<MXL582*/                                   /**<CNcomment:MXL582*/
+    HI_UNF_TUNER_DEV_TYPE_MXL661        = 40,   /**<MXL661*/                                   /**<CNcomment:MXL661*/
+    HI_UNF_TUNER_DEV_TYPE_BUTT                  /**<Invalid value*/                            /**<CNcomment:*/
+} HI_UNF_TUNER_DEV_TYPE_E ;
+
+/** Type of the demod device*/
+/** CNcomment:demod*/
+typedef enum    hiUNF_DEMOD_DEV_TYPE_E
+{
+    HI_UNF_DEMOD_DEV_TYPE_NONE,                 /**<Not supported*/                         /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3130I       = 0x100,  /**<Internal QAM, same as HI_UNF_DEMOD_DEV_TYPE_INTERNAL0*/
+                                                /**<CNcomment:QAM,HI_UNF_DEMOD_DEV_TYPE_INTERNAL0*/
+    HI_UNF_DEMOD_DEV_TYPE_3130E       = 0x101,  /**<External Hi3130*/                       /**<CNcomment:QAM hi3130*/
+    HI_UNF_DEMOD_DEV_TYPE_J83B        = 0x102,  /**<suppoort j83b*/                         /**<CNcomment:j83b*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6211     = 0x103,  /**<Avalink 6211*/                          /**<CNcomment:Avalink 6211*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL101      = 0x104,  /**<Maxlinear mxl101,    Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88472     = 0x105,  /**<PANASONIC mn88472*/                     /**<CNcomment:PANASONIC mn88472*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9170      = 0x106,  /**<ITE it9170,          Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9133      = 0x107,  /**<ITE it9133,          Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3136        = 0x108,  /**<External Hi3136*/                       /**<CNcomment:hi3136*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL254      = 0x10A,  /**<External mxl254*/                       /**<CNcomment:MXL254*/
+    HI_UNF_DEMOD_DEV_TYPE_CXD2837     = 0x10B,  /**Sony cxd2837,         Not supported*/    /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_3137        = 0x10C,  /**External Hi3137*/                        /**<CNcomment:hi3137*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL214      = 0x10D,  /**<External mxl214*/                       /**<CNcomment:MXL214*/
+    HI_UNF_DEMOD_DEV_TYPE_TDA18280    = 0x10E,  /**<External tda18280*/                     /**<CNcomment:tda18280*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL251      = 0x111,  /**<External mxl251*/                       /**<CNcomment:MXL251*/
+    HI_UNF_DEMOD_DEV_TYPE_ATBM888X    = 0x113,  /**External ATBM888X*/                      /**<CNcomment:ATBM888X*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88473     = 0x114,  /**< Panasonic 88473 */                     /**<CNcomment:Panasonic 88473 */
+    HI_UNF_DEMOD_DEV_TYPE_MXL683      = 0x115,  /**<External mxl683*/                       /**<CNcomment:mxl683*/
+    HI_UNF_DEMOD_DEV_TYPE_TP5001      = 0x116,  /**External TP5001*/                        /**<CNcomment:TP5001*/
+    HI_UNF_DEMOD_DEV_TYPE_HD2501      = 0x117,  /**External HD2501*/                        /**<CNcomment:HD2501*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6381     = 0x118,  /**External AVL6381*/                       /**<CNcomment:AVL6381*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL541      = 0x119,  /**External MXL541*/                        /**<CNcomment:MXL541*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL581      = 0x11A,  /**External MXL581*/                        /**<CNcomment:MXL581*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL582      = 0x11B,  /**External MXL582*/                        /**<CNcomment:MXL582*/
+    HI_UNF_DEMOD_DEV_TYPE_INTERNAL0   = 0x11C,  /**Internal Demod*/                         /**<CNcomment:*/
+    HI_UNF_DEMOD_DEV_TYPE_BUTT                  /**<Invalid value*/                         /**<CNcomment:*/
+} HI_UNF_DEMOD_DEV_TYPE_E;
+
+/** Defines the cable transmission signal.*/
+/** CNcomment:CABLE*/
+typedef struct  hiUNF_CAB_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<Frequency, in kHz*/         /**<CNcomment:kHz*/
+    HI_U32                      u32SymbolRate;      /**<Symbol rate, in bit/s*/     /**<CNcomment:bps */
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<QAM mode*/                  /**<CNcomment:QAM*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:kHz*/
+} HI_UNF_CAB_CONNECT_PARA_S;
+
+/** Guard interval of OFDM*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_GUARD_INTV_E
+{
+    HI_UNF_TUNER_FE_GUARD_INTV_DEFALUT = 0,     /**<default guard interval mode*/   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_128,           /**<1/128*/                         /**<CNcomment:1/128*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_32,            /**<1/32*/                          /**<CNcomment:1/32*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_16,            /**<1/16*/                          /**<CNcomment:1/16*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_8,             /**<1/8*/                           /**<CNcomment:1/8*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_4,             /**<1/4*/                           /**<CNcomment:1/4*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_128,          /**<19/128*/                        /**<CNcomment:19/128*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_256,          /**<19/256*/                        /**<CNcomment:19/256*/
+    HI_UNF_TUNER_FE_GUARD_INTV_BUTT             /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_FE_GUARD_INTV_E;
+
+/** OFDM Mode, used in multi-carrier modulation*/
+/** CNcomment:OFDM*/
+typedef enum hiUNF_TUNER_FE_FFT_E
+{
+    HI_UNF_TUNER_FE_FFT_DEFAULT = 0,   /**<default mode*/     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_1K ,           /**<1k mode*/          /**<CNcomment:1k*/
+    HI_UNF_TUNER_FE_FFT_2K ,           /**<2k mode*/          /**<CNcomment:2k*/
+    HI_UNF_TUNER_FE_FFT_4K ,           /**<4k mode*/          /**<CNcomment:4k*/
+    HI_UNF_TUNER_FE_FFT_8K ,           /**<8k mode*/          /**<CNcomment:8k*/
+    HI_UNF_TUNER_FE_FFT_16K ,          /**<16k mode*/         /**<CNcomment:16k*/
+    HI_UNF_TUNER_FE_FFT_32K ,          /**<32k mode*/         /**<CNcomment:32k*/
+    HI_UNF_TUNER_FE_FFT_64K ,          /**<64k mode*/         /**<CNcomment:64k*/
+    HI_UNF_TUNER_FE_FFT_BUTT           /**<Invalid value*/    /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FFT_E;
+
+/** Hierarchical modulation mode, only used in DVB-T*/
+/** CNcomment:DVB-T*/
+typedef enum hiUNF_TUNER_FE_HIERARCHY_E
+{
+    HI_UNF_TUNER_FE_HIERARCHY_DEFAULT = 0,      /**<hierarchical modulation default mode*/      /**<CNcomment:*/
+    HI_UNF_TUNER_FE_HIERARCHY_NO,               /**<no hierarchical modulation mode*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA1,           /**<hierarchical mode, alpha = 1*/              /**<CNcomment:, alpha = 1*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA2,           /**<hierarchical mode, alpha = 2*/              /**<CNcomment:, alpha = 2*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA4,           /**<hierarchical mode, alpha = 4*/              /**<CNcomment:, alpha = 4*/
+    HI_UNF_TUNER_FE_HIERARCHY_BUTT              /**<Invalid value*/                             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_HIERARCHY_E;
+
+/** TS Priority, only used in DVB-T*/
+/** CNcomment:DVB-T*/
+typedef enum hiUNF_TUNER_TS_PRIORITY_E
+{
+    HI_UNF_TUNER_TS_PRIORITY_NONE = 0,      /**<no priority mode*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_HP,            /**<high priority mode*/        /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_LP,            /**<low priority mode*/         /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_TS_PRIORITY_E;
+
+/** base channel or lite channel, only used in DVB-T2*/
+/** CNcomment:DVB-T2*/
+typedef enum hiUNF_TUNER_TER_MODE_E
+{
+    HI_UNF_TUNER_TER_MODE_BASE = 0,     /**< the channel is base mode*/         /**<CNcomment:base*/
+    HI_UNF_TUNER_TER_MODE_LITE,         /**< the channel is lite mode*/         /**<CNcomment:lite*/
+    HI_UNF_TUNER_TER_MODE_BUTT      /**<Invalid value*/            /**<CNcomment:*/
+} HI_UNF_TUNER_TER_MODE_E;
+
+/** Stream type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_STREAM_TYPE_E
+{
+    HI_UNF_TUNER_TER_STREAM_TYPE_GFPS = 0,    /**< Generic Fixed Packet size Stream*/     /**<CNcomment:*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GCS,         /**< Generic Continuous Stream*/            /**<CNcomment:*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GSE,         /**< Generic Stream Encapsulated*/          /**<CNcomment:GSE*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_TS,          /**< Trasport Stream*/                      /**<CNcomment:TS*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GSE_HEM,     /**< GSE in High Efficiency Mode*/          /**<CNcomment:GSEHEM*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_TS_HEM,      /**< TS in High Efficiency Mode*/           /**<CNcomment:TSHEM*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_BUTT         /**< Invalid value*/                        /**<CNcomment:*/
+} HI_UNF_TUNER_TER_STREAM_TYPE_E;
+
+/** DVB-T2 data PLP's ISSY type*/
+/** CNcomment:DVB-T2*/
+typedef enum hiUNF_TUNER_DVBT2_ISSY_E
+{
+    HI_UNF_TUNER_DVBT2_ISSY_NO = 0,   /**< No Input Stream SYnchronizer*/        /**<CNcomment:ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_SHORT,    /**< Short Input Stream SYnchronizer*/     /**<CNcomment:ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_LONG,     /**< Long Input Stream SYnchronizer*/      /**<CNcomment:ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_BUTT      /**< Invalid value*/                       /**<CNcomment:*/
+} HI_UNF_TUNER_DVBT2_ISSY_E;
+
+/** TS clock polarization*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TSCLK_POLAR_E
+{
+    HI_UNF_TUNER_TSCLK_POLAR_FALLING,       /**<Falling edge*/      /**<CNcomment:*/
+    HI_UNF_TUNER_TSCLK_POLAR_RISING,        /**<Rising edge*/       /**<CNcomment:*/
+    HI_UNF_TUNER_TSCLK_POLAR_BUTT           /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TSCLK_POLAR_E;
+
+/** TS format*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TS_FORMAT_E
+{
+    HI_UNF_TUNER_TS_FORMAT_TS,              /**<188*/               /**<CNcomment:188*/
+    HI_UNF_TUNER_TS_FORMAT_TSP,             /**<204*/               /**<CNcomment:204*/
+    HI_UNF_TUNER_TS_FORMAT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TS_FORMAT_E;
+
+/** TS serial PIN*/
+/** CNcomment:TS*/
+typedef enum hiUNF_TUNER_TS_SERIAL_PIN_E
+{
+    HI_UNF_TUNER_TS_SERIAL_PIN_0,           /**<Serial pin 0, default*/  /**<CNcomment:0bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_7,           /**<Serial pin 7*/           /**<CNcomment:7bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_BUTT         /**<Invalid value*/          /**<CNcomment:*/
+} HI_UNF_TUNER_TS_SERIAL_PIN_E;
+
+/** ISDBT layer information,each layer can be received indepent*/
+/** CNcomment:ISDBT*/
+typedef enum hiUNF_TUNER_ISDBT_MONITOR_LAYER_E
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_ALL,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_A,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_B,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_C,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_BUTT
+}HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E;
+/** Tuner RF AGC mode*/
+/** CNcomment:agc*/
+typedef enum hiUNF_TUNER_RFAGC_MODE_E
+{
+    /**< Inverted polarization, default.This setting is used for a tuner whose gain decreases with increased AGC voltage*/   /**<CNcomment:agc*/
+    HI_UNF_TUNER_RFAGC_INVERT,
+
+    /**< Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage*/             /**<CNcomment:agc*/
+    HI_UNF_TUNER_RFAGC_NORMAL,
+    HI_UNF_TUNER_RFAGC_BUTT                  /**<Invalid value*/                                                             /**<CNcomment:*/
+} HI_UNF_TUNER_RFAGC_MODE_E;
+
+/** TS sync head length */
+typedef enum hiUNF_TUNER_TS_SYNC_HEAD_E
+{
+    HI_UNF_TUNER_TS_SYNC_HEAD_AUTO,
+    HI_UNF_TUNER_TS_SYNC_HEAD_8BIT,
+    HI_UNF_TUNER_TS_SYNC_HEAD_BUTT
+} HI_UNF_TUNER_TS_SYNC_HEAD_E;
+
+/** Tuner IQ spectrum mode*/
+/** CNcomment:IQ*/
+typedef enum hiUNF_TUNER_IQSPECTRUM_MODE_E
+{
+    HI_UNF_TUNER_IQSPECTRUM_NORMAL,         /**<The received signal spectrum is not inverted*/    /**<CNcomment:IQ*/
+    HI_UNF_TUNER_IQSPECTRUM_INVERT,         /**<The received signal spectrum is inverted*/        /**<CNcomment:IQ*/
+    HI_UNF_TUNER_IQSPECTRUM_BUTT            /**<Invalid value*/                                   /**<CNcomment:*/
+} HI_UNF_TUNER_IQSPECTRUM_MODE_E;
+
+/** DiSEqC Wave Mode*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQCWAVE_MODE_E
+{
+    HI_UNF_TUNER_DISEQCWAVE_NORMAL,         /**<Waveform produced by demod*/                 /**<CNcomment:demod*/
+    HI_UNF_TUNER_DISEQCWAVE_ENVELOPE,       /**<Waveform produced by LNB control device*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQCWAVE_BUTT            /**<Invalid value*/                              /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQCWAVE_MODE_E;
+
+/** LNB power supply and control device*/
+/** CNcomment:LNB*/
+typedef enum hiUNF_LNBCTRL_DEV_TYPE_E
+{
+    HI_UNF_LNBCTRL_DEV_TYPE_NONE,           /**<No LNB control device*/      /**<CNcomment:*/
+    HI_UNF_LNBCTRL_DEV_TYPE_MPS8125,        /**<MPS8125*/                    /**<CNcomment:MPS8125*/
+    HI_UNF_LNBCTRL_DEV_TYPE_ISL9492,        /**<ISL9492*/                    /**<CNcomment:ISL9492*/
+    HI_UNF_LNBCTRL_DEV_TYPE_A8300,          /**<A8300*/                      /**<CNcomment:A8300*/
+    HI_UNF_LNBCTRL_DEV_TYPE_A8297,
+    HI_UNF_LNBCTRL_DEV_TYPE_TPS65233,       /**<TPS65233*/                   /**<CNcomment:TPS65233*/
+    HI_UNF_LNBCTRL_DEV_TYPE_BUTT            /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_LNBCTRL_DEV_TYPE_E;
+
+/** FEC code Rate*/
+/** CNcomment:FEC*/
+typedef enum hiUNF_TUNER_FE_FECRATE_E
+{
+    HI_UNF_TUNER_FE_FEC_AUTO = 0,
+    HI_UNF_TUNER_FE_FEC_1_2,           /**<1/2*/           /**<CNcomment:1/2*/
+    HI_UNF_TUNER_FE_FEC_2_3,           /**<2/3*/           /**<CNcomment:2/3*/
+    HI_UNF_TUNER_FE_FEC_3_4,           /**<3/4*/           /**<CNcomment:3/4*/
+    HI_UNF_TUNER_FE_FEC_4_5,           /**<4/5*/           /**<CNcomment:4/5*/
+    HI_UNF_TUNER_FE_FEC_5_6,           /**<5/6*/           /**<CNcomment:5/6*/
+    HI_UNF_TUNER_FE_FEC_6_7,           /**<6/7*/           /**<CNcomment:6/7*/
+    HI_UNF_TUNER_FE_FEC_7_8,           /**<7/8*/           /**<CNcomment:7/8*/
+    HI_UNF_TUNER_FE_FEC_8_9,           /**<8/9*/           /**<CNcomment:8/9*/
+    HI_UNF_TUNER_FE_FEC_9_10,          /**<9/10*/          /**<CNcomment:9/10*/
+    HI_UNF_TUNER_FE_FEC_1_4,           /**<1/4*/           /**<CNcomment:1/4*/
+    HI_UNF_TUNER_FE_FEC_1_3,           /**<1/3*/           /**<CNcomment:1/3*/
+    HI_UNF_TUNER_FE_FEC_2_5,           /**<2/5*/           /**<CNcomment:2/5*/
+    HI_UNF_TUNER_FE_FEC_3_5,           /**<3/5*/           /**<CNcomment:3/5*/
+    HI_UNF_TUNER_FE_FEC_13_45,         /**<13/45*/         /**<CNcomment:13/45*/
+    HI_UNF_TUNER_FE_FEC_9_20,          /**<9/20*/          /**<CNcomment:9/20*/
+    HI_UNF_TUNER_FE_FEC_11_20,         /**<11/20*/         /**<CNcomment:11/20*/
+    HI_UNF_TUNER_FE_FEC_5_9_L,         /**<5/9L*/          /**<CNcomment:5/9L*/
+    HI_UNF_TUNER_FE_FEC_26_45_L,       /**<26/45L*/        /**<CNcomment:26/45L*/
+    HI_UNF_TUNER_FE_FEC_23_36,         /**<23/36*/         /**<CNcomment:23/36*/
+    HI_UNF_TUNER_FE_FEC_25_36,         /**<25/36*/         /**<CNcomment:25/36*/
+    HI_UNF_TUNER_FE_FEC_13_18,         /**<13/18*/         /**<CNcomment:13/18*/
+    HI_UNF_TUNER_FE_FEC_1_2_L,         /**<1/2L*/          /**<CNcomment:1/2L*/
+    HI_UNF_TUNER_FE_FEC_8_15_L,        /**<8/15L*/         /**<CNcomment:8/15L*/
+    HI_UNF_TUNER_FE_FEC_26_45,         /**<26/45*/         /**<CNcomment:26/45*/
+    HI_UNF_TUNER_FE_FEC_3_5_L,         /**<3/5L*/          /**<CNcomment:3/5L*/
+    HI_UNF_TUNER_FE_FEC_28_45,         /**<28/45*/         /**<CNcomment:28/45*/
+    HI_UNF_TUNER_FE_FEC_2_3_L,         /**<2/3L*/          /**<CNcomment:2/3L*/
+    HI_UNF_TUNER_FE_FEC_7_9,           /**<7/9*/           /**<CNcomment:7/9*/
+    HI_UNF_TUNER_FE_FEC_77_90,         /**<77/90*/         /**<CNcomment:77/90*/
+    HI_UNF_TUNER_FE_FEC_32_45,         /**<32/45*/         /**<CNcomment:32/45*/
+    HI_UNF_TUNER_FE_FEC_11_15,         /**<11/15*/         /**<CNcomment:11/15*/
+    HI_UNF_TUNER_FE_FEC_32_45_L,       /**<32/45*/         /**<CNcomment:32/45L*/
+    HI_UNF_TUNER_FE_FEC_29_45_L,       /**<29/45L*/        /**<CNcomment:29/45L*/
+    HI_UNF_TUNER_FE_FEC_31_45_L,       /**<31/45*/         /**<CNcomment:31/45L*/
+    HI_UNF_TUNER_FE_FEC_11_15_L,       /**<11/15L*/        /**<CNcomment:11/15L*/
+    HI_UNF_TUNER_FE_FEC_11_45,         /**<11/45*/         /**<CNcomment:11/45*/
+    HI_UNF_TUNER_FE_FEC_4_15,          /**<4/15*/          /**<CNcomment:4/15*/
+    HI_UNF_TUNER_FE_FEC_14_45,         /**<14/45*/         /**<CNcomment:14/45*/
+    HI_UNF_TUNER_FE_FEC_7_15,          /**<7/15*/          /**<CNcomment:7/15*/
+    HI_UNF_TUNER_FE_FEC_8_15,          /**<8/15*/          /**<CNcomment:8/15*/
+    HI_UNF_TUNER_FE_FEC_2_9,           /**<2/9*/           /**<CNcomment:2/9*/
+    HI_UNF_TUNER_FE_FEC_1_5,           /**<2/9*/           /**<CNcomment:2/9*/
+    HI_UNF_TUNER_FE_FECRATE_BUTT       /**<Invalid value*/ /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FECRATE_E;
+
+/** Parameter for ISDB-T layer exist or not*/
+/** CNcomment:ISDB-T*/
+typedef union hiUNF_TUNER_ISDBT_LAYERS_IDENTIFY_U
+{
+    struct
+    {
+        HI_U8 u8LayerAExist:1;  /*[0]*/
+        HI_U8 u8LayerBExist:1;  /*[1]*/
+        HI_U8 u8LayerCExist:1;  /*[2]*/
+        HI_U8 reserved:5;       /*[7:3]*/
+    }bits;
+
+    HI_U8 ExistanceFlag;
+}HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U;
+
+/** Parameter for ISDB-T layer configuration*/
+/** CNcomment:ISDB-T*/
+typedef struct hiUNF_TUNER_MONITOR_LAYERS_CONFIG_S
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E enMonitorLayer;  /**<ISDB-T layer exist or not*/ /**<CNcomment:ISDB-T*/
+} HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S;
+
+
+/** Parameter for ISDB-T layer information*/
+/** CNcomment:ISDB-T */
+typedef struct hiUNF_TUNER_ISDBT_LAYERS_INFO_S
+{
+    HI_U8 u8LayerSegNum;            /**<layer segment number*/              /**<CNcomment:segment*/
+    HI_U8 u8LayerReserved[3];
+    HI_UNF_TUNER_FE_HIERARCHY_E enLayerHierMod; /**<layer hierarchy mode*/  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E   enLayerFECRate; /**<layer FEC rate*/        /**<CNcomment:*/
+    HI_UNF_MODULATION_TYPE_E    enLayerModType; /**<layer modulation type*/ /**<CNcomment:*/
+}HI_UNF_TUNER_ISDBT_LAYERS_INFO_S;
+
+/** Parameter for ISDB-T TMCC information*/
+/** CNcomment:ISDB-TTMCC */
+typedef struct hiUNF_TUNER_TMCC_INFO_S
+{
+    HI_U8 u8EmergencyFlag;  /**<the start flag for emergency alarm broadcasting*/                   /**<CNcomment:*/
+    HI_U8 u8PartialFlag;    /**<partial reception flag*/                                            /**<CNcomment:*/
+    HI_U8 u8PhaseShiftCorr; /**<phase shift correction value for connected segment transmission*/   /**<CNcomment:*/
+    HI_U8 u8IsdbtSystemId;  /**<system identification[0 = ISDB_T,1 = ISDB_T_SB]*/                   /**<CNcomment:*/
+
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersAInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersBInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersCInfoBits;
+
+    HI_U8 u8TMCCReserved[4];    /**<Reserve*/                                                       /**<CNcomment:*/
+} HI_UNF_TUNER_TMCC_INFO_S;
+
+/** ADC port select*/
+/** CNcomment:ADC*/
+typedef enum hiUNF_TUNER_ADC_PORT_E
+{
+    HI_UNF_TUNER_ADC0,          /**<ADC0 port*/   /**<CNcomment:ADC0*/
+    HI_UNF_TUNER_ADC1,          /**<ADC1 port*/   /**<CNcomment:ADC1*/
+    HI_UNF_TUNER_ADC_BUTT
+}HI_UNF_TUNER_ADC_PORT_E;
+
+/** Satellite extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_SAT_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demodMHz*/
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tunerMHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts*/
+    HI_UNF_TUNER_DISEQCWAVE_MODE_E enDiSEqCWave;    /**<DiSEqC Wave Mode*/                        /**<CNcomment:DiSEqC*/
+    HI_UNF_LNBCTRL_DEV_TYPE_E      enLNBCtrlDev;    /**<LNB power supply and control device*/     /**<CNcomment:LNB*/
+    HI_U16                         u16LNBDevAddress;/**<LNB control device address*/              /**<CNcomment:LNBi2c*/
+} HI_UNF_TUNER_SAT_ATTR_S;
+
+/** Terrestrial extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_TER_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demodMHz*/
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tunerMHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts*/
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                     /**<CNcomment:ts*/
+} HI_UNF_TUNER_TER_ATTR_S;
+
+/** Cable extended attribution*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_CAB_ATTR_S
+{
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U32                         u32DemodClk;     /**< Demod reference clock frequency, KHz */
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**< TS clock polarization */
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**< TS format */
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**< TS serial PIN */
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                   /**<CNcomment:ts*/
+} HI_UNF_TUNER_CAB_ATTR_S;
+
+/** Polarization type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_POLARIZATION_E
+{
+    HI_UNF_TUNER_FE_POLARIZATION_H,     /**<Horizontal Polarization*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_V,     /**<Vertical Polarization*/             /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_L,     /**<Left-hand circular Polarization*/   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_R,     /**<Right-hand circular Polarization*/  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_BUTT,  /**<Invalid value*/                     /**<CNcomment:*/
+} HI_UNF_TUNER_FE_POLARIZATION_E;
+
+/** Pilot type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_PILOT_E
+{
+    HI_UNF_TUNER_PILOT_OFF,         /**<Pilot off*/               /**<CNcomment:*/
+    HI_UNF_TUNER_PILOT_ON,          /**<Pilot on*/                /**<CNcomment:*/
+    HI_UNF_TUNER_PILOT_BUTT         /**<Invalid value*/           /**<CNcomment:*/
+} HI_UNF_TUNER_PILOT_E;
+
+/** FEC length*/
+/** CNcomment:FEC */
+typedef enum hiUNF_TUNER_SAT_FEC_FRAME_MODE_E
+{
+    HI_UNF_TUNER_SAT_FEC_FRAME_NORMAL,  /**<nomal FEC Frame*/       /**<CNcomment:FECDVB-S/S2/S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_SHORT,   /**<short FEC Frame*/       /**<CNcomment:FECDVB-S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_MEDIUM,  /**<medium FEC Fream*/      /**<CNcomment:FECDVB-S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_BUTT     /**<Invalid value*/         /**<CNcomment:*/
+} HI_UNF_TUNER_SAT_FEC_FRAME_MODE_E;
+
+/** Roll off*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_ROLLOFF_E
+{
+    HI_UNF_TUNER_ROLLOFF_35,        /**<Roll off 0.35*/           /**<CNcomment:0.35*/
+    HI_UNF_TUNER_ROLLOFF_25,        /**<Roll off 0.25*/           /**<CNcomment:0.25*/
+    HI_UNF_TUNER_ROLLOFF_20,        /**<Roll off 0.20*/           /**<CNcomment:0.20*/
+    HI_UNF_TUNER_ROLLOFF_15,        /**<Roll off 0.15*/           /**<CNcomment:0.15*/
+    HI_UNF_TUNER_ROLLOFF_10,        /**<Roll off 0.10*/           /**<CNcomment:0.10*/
+    HI_UNF_TUNER_ROLLOFF_05,        /**<Roll off 0.05*/           /**<CNcomment:0.05*/
+    HI_UNF_TUNER_ROLLOFF_BUTT       /**<Invalid value*/           /**<CNcomment:*/
+} HI_UNF_TUNER_ROLLOFF_E;
+
+/** Stream typef*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_SAT_STREAM_TYPE_E
+{
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GENERIC_PACKETIZED,  /**< Generic Packetized Stream*/         /**<CNcomment:*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GENERIC_CONTINUOUS,  /**< Generic Continuous Stream*/         /**<CNcomment:*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_HEM,             /**< GSE in High Efficiency Mode*/       /**<CNcomment:GSEHEM*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_TRANSPORT,           /**< Trensport Stream*/                  /**<CNcomment:TS*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_LITE,            /**< GSE-Lite*/                          /**<CNcomment:GSE-Lite*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_LITE_HEM,        /**< GSE-Lite in High Efficiency Mode*/  /**<CNcomment:GSE-LiteHEM*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_T2MI,                /**< T2MI Stream*/                       /**<CNcomment:T2MI*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_BUTT                 /**< Invalid value*/                     /**<CNcomment:*/
+} HI_UNF_TUNER_SAT_STREAM_TYPE_E;
+
+/** FEC Type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_FECTYPE_E
+{
+    HI_UNF_TUNER_FE_DVBS,               /**<DVB-S*/                         /**<CNcomment:DVB-S*/
+    HI_UNF_TUNER_FE_DVBS2,              /**<DVB-S2*/                        /**<CNcomment:DVB-S2*/
+    HI_UNF_TUNER_FE_DIRECTV,            /**<DIRECTV*/                       /**<CNcomment:DIRECTV*/
+    HI_UNF_TUNER_FE_DVBS2X,             /**<DVB-S2X*/                       /**<CNcomment:DVB-S2X*/
+    HI_UNF_TUNER_FE_BUTT                /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_FE_FECTYPE_E;
+
+/** LNB type*/
+/** CNcomment:LNB*/
+typedef enum hiUNF_TUNER_FE_FE_LNBTYPE_E
+{
+    HI_UNF_TUNER_FE_LNB_SINGLE_FREQUENCY,   /**<Single LO frequency*/       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_DUAL_FREQUENCY,     /**<Dual LO frequency*/         /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_UNICABLE,           /**<Unicable LNB */             /**<CNcomment:unicable*/
+    HI_UNF_TUNER_FE_LNB_TRIPLE_FREQUENCY,   /**<Triple LO frequency*/       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_UNICABLE2,          /**<Unicable2 LNB */             /**<CNcomment:unicable2*/
+    HI_UNF_TUNER_FE_LNB_TYPE_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_TYPE_E;
+
+/** LNB band type*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_LNB_BAND_E
+{
+    HI_UNF_TUNER_FE_LNB_BAND_C,             /**<C */                        /**<CNcomment:C*/
+    HI_UNF_TUNER_FE_LNB_BAND_KU,            /**<Ku */                       /**<CNcomment:Ku*/
+    HI_UNF_TUNER_FE_LNB_BAND_KA,            /**<Ka */                       /**<CNcomment:Ka*/
+    HI_UNF_TUNER_FE_LNB_BAND_BUTT           /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_BAND_E;
+
+/** LNB power control*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_FE_LNB_POWER_E
+{
+    HI_UNF_TUNER_FE_LNB_POWER_OFF,          /**<LNB power off*/                                                     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_POWER_ON,           /**<LNB power auto, 13V/18V, default*/                                  /**<CNcomment:13/18V*/
+    HI_UNF_TUNER_FE_LNB_POWER_ENHANCED,     /**<LNB power auto, 14V/19V, some LNB control device can support.*/     /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_POWER_BUTT          /**<Invalid value*/                                                     /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_POWER_E;
+
+/** Antenna power control*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_ANTENNA_POWER_E
+{
+    HI_UNF_TUNER_TER_ANTENNA_POWER_OFF,     /**<Antenna power off*/          /**<CNcomment:*/
+    HI_UNF_TUNER_TER_ANTENNA_POWER_ON,      /**<Antenna power on*/           /**<CNcomment:*/
+    HI_UNF_TUNER_TER_ANTENNA_POWER_BUTT     /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_TUNER_TER_ANTENNA_POWER_E;
+
+/** Demod standby or wake up status*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_DEMOD_STATUS_E
+{
+    HI_UNF_TUNER_DEMODE_WAKE_UP = 0,        /**<Demod wake up*/              /**<CNcomment:*/
+    HI_UNF_TUNER_DEMODE_STANDBY,            /**<Demod standby*/              /**<CNcomment:*/
+    HI_UNF_TUNER_DEMOD_STATUS_BUTT          /**<Invalid value*/              /**<CNcomment:*/
+}HI_UNF_TUNER_DEMOD_STATUS_E;
+
+/** LNB 22K tone status, for Ku band LNB*/
+/** CNcomment:22kKu*/
+typedef enum hiUNF_TUNER_FE_LNB_22K_E
+{
+    HI_UNF_TUNER_FE_LNB_22K_OFF,            /**<22k off*/                    /**<CNcomment:22k*/
+    HI_UNF_TUNER_FE_LNB_22K_ON,             /**<22k on*/                     /**<CNcomment:22k*/
+    HI_UNF_TUNER_FE_LNB_22K_BUTT            /**<Invalid value*/              /**<CNcomment:*/
+} HI_UNF_TUNER_FE_LNB_22K_E;
+
+/** 0/12V switch*/
+/** CNcomment:0/12V*/
+typedef enum hiUNF_TUNER_SWITCH_0_12V_E
+{
+    HI_UNF_TUNER_SWITCH_0_12V_NONE,         /**< None, default*/            /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_0_12V_0,            /**< 0V*/                       /**<CNcomment:0V*/
+    HI_UNF_TUNER_SWITCH_0_12V_12,           /**< 12V*/                      /**<CNcomment:12V*/
+    HI_UNF_TUNER_SWITCH_0_12V_BUTT          /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_0_12V_E;
+
+/** 22KHz switch*/
+/** CNcomment:22K*/
+typedef enum hiUNF_TUNER_SWITCH_22K_E
+{
+    HI_UNF_TUNER_SWITCH_22K_NONE,           /**< None, default*/            /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_22K_0,              /**< 0*/                        /**<CNcomment:0kHz*/
+    HI_UNF_TUNER_SWITCH_22K_22,             /**< 22KHz*/                    /**<CNcomment:22kHz*/
+    HI_UNF_TUNER_SWITCH_22K_BUTT            /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_22K_E;
+
+/** Tone burst switch*/
+/** CNcomment:Tone burst*/
+typedef enum hiUNF_TUNER_SWITCH_TONEBURST_E
+{
+    HI_UNF_TUNER_SWITCH_TONEBURST_NONE,     /**< Don't send tone burst, default*/ /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_0,        /**< Tone burst 0*/                   /**<CNcomment:0 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_1,        /**< Tone burst 1*/                   /**<CNcomment:1 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_BUTT      /**<Invalid value*/                   /**<CNcomment:*/
+} HI_UNF_TUNER_SWITCH_TONEBURST_E;
+
+/** pilot pattern */
+typedef enum hiUNF_TUNER_TER_PILOT_PATTERN_E
+{
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP1 = 0,  /**< pilot pattern pp1 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP2,      /**< pilot pattern pp2 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP3,      /**< pilot pattern pp3 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP4,      /**< pilot pattern pp4 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP5,      /**< pilot pattern pp5 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP6,      /**< pilot pattern pp6 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP7,      /**< pilot pattern pp7 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP8,      /**< pilot pattern pp8 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_BUTT
+} HI_UNF_TUNER_TER_PILOT_PATTERN_E;
+
+/** information for channel mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_CHANNEL_MODE_E
+{
+    HI_UNF_TUNER_TER_PURE_CHANNEL = 0,      /**< pure channel*/     /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MIXED_CHANNEL,         /**< mixed channel*/    /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CHANNEL_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_CHANNEL_MODE_E;
+
+/** information for carrier mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_TER_CARRIER_MODE_E
+{
+    HI_UNF_TUNER_TER_EXTEND_CARRIER = 0,    /**< extend carrier*/   /**<CNcomment:*/
+    HI_UNF_TUNER_TER_NORMAL_CARRIER,        /**< normal carrier*/   /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_CARRIER_MODE_E;
+
+/** CNcomment:code and modulation */
+typedef enum hiUNF_TUNER_CODE_MODULATION_E
+{
+    HI_UNF_TUNER_CODE_MODULATION_VCM_ACM,       /**< VCM/ACM*/      /**<CNcomment:/*/
+    HI_UNF_TUNER_CODE_MODULATION_CCM,           /**< CCM*/          /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_MULTISTREAM,   /**< MultiStream*/  /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_BUTT           /**<Invalid value*/ /**<CNcomment:*/
+} HI_UNF_TUNER_CODE_MODULATION_E;
+
+/** information for constellation mode*/
+/** CNcomment:*/
+typedef enum hiUNF_TUNER_CONSTELLATION_MODE_E
+{
+    HI_UNF_TUNER_CONSTELLATION_STANDARD = 0,    /**< standard constellation*/   /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_ROTATION,        /**< rotation constellation*/   /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_BUTT        /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_CONSTELLATION_MODE_E;
+
+/** FEC frame length*/
+/** CNcomment:FEC*/
+typedef enum hiUNF_TUNER_TER_FEC_FRAME_MODE_E
+{
+    HI_UNF_TUNER_TER_FEC_FRAME_NORMAL = 0,      /**< normal fec frame*/ /**<CNcomment:fec*/
+    HI_UNF_TUNER_TER_FEC_FRAME_SHORT,           /**< short fec frame*/  /**<CNcomment:fec*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_BUTT        /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_TER_FEC_FRAME_MODE_E;
+
+/** Structure of the satellite transmission signal.*/
+/** CNcomment:Satellite*/
+typedef struct  hiUNF_SAT_CONNECT_PARA_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/ /**<CNcomment:kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/     /**<CNcomment:Symb/s */
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/          /**<CNcomment:*/
+    HI_U32                         u32ScrambleValue; /**<Physical layer initial scrambling code,range 0~262141,the default value must be 0,when signal sender config some TP using not 0,
+    then receiver must modify this value the same as sender,if not,signal will be unlock,the modified value maybe told by signal sender.*/
+    /**<CNcomment:0~262141.0,0*/
+} HI_UNF_SAT_CONNECT_PARA_S;
+
+/** configure lock tp PLP parameter,only in DVB-T2 */
+/** CNcomment:DVB-T2*/
+typedef struct hiUNF_TUNER_TER_PLP_PARA_S
+{
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:ID*/
+    HI_U8                       u8CommPlpId;        /**<common PLP id*/         /**<CNcomment:ID*/
+    HI_U8                       u8Combination;      /**<PLP combination*/       /**<CNcomment:*/
+} HI_UNF_TUNER_TER_PLP_PARA_S;
+
+/** Terestrial connect param*/
+/** CNcomment:*/
+typedef struct  hiUNF_TER_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<freq in KHz*/               /**<CNcomment:kHz*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:kHz*/
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<modulation type*/           /**<CNcomment:*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;      /**<dvb-t2 channel mode*/       /**<CNcomment:dvb-t2*/
+    HI_UNF_TUNER_TS_PRIORITY_E  enDVBTPrio;         /**<dvb-t TS priority*/         /**<CNcomment:dvb-t*/
+    HI_UNF_TUNER_TER_PLP_PARA_S stPLPParam;         /**< PLP parameter*/            /**<CNcomment:*/
+} HI_UNF_TER_CONNECT_PARA_S;
+
+/** Structure of the satellite transmission signal's detailed information.*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_SAT_SIGNALINFO_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/              /**<CNcomment:kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/                  /**<CNcomment:Symb/s*/
+    HI_UNF_MODULATION_TYPE_E       enModType;       /**<Modulation type*/                         /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/                       /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECTYPE_E      enSATType;       /**<Saterllite standard, DVB-S/S2/DIRECTV*/   /**<CNcomment: DVB-S/S2/DIRECTV*/
+    HI_UNF_TUNER_FE_FECRATE_E      enFECRate;       /**<FEC rate*/                                /**<CNcomment:*/
+    HI_UNF_TUNER_CODE_MODULATION_E enCodeModulation;
+    HI_UNF_TUNER_ROLLOFF_E         enRollOff;       /**<Rolloff*/                                 /**<CNcomment:*/
+    HI_UNF_TUNER_PILOT_E           enPilot;         /**<Pilot*/                                   /**<CNcomment:*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_MODE_E    enFECFrameMode;     /**<FEC fream mode*/                 /**<CNcomment:FEC*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_E enStreamType;    /**<Stream type*/                             /**<CNcomment:*/
+} HI_UNF_TUNER_SAT_SIGNALINFO_S;
+
+/** PLP type of DVB-T2.*/
+/** CNcomment:T2*/
+typedef enum hiUNF_TUNER_T2_PLP_TYPE_E
+{
+    HI_UNF_TUNER_T2_PLP_TYPE_COM=0,         /**<common type*/              /**<CNcomment:*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT1,          /**<data1 type*/               /**<CNcomment:1*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT2,          /**<data2 type*/               /**<CNcomment:2*/
+    HI_UNF_TUNER_T2_PLP_TYPE_BUTT           /**<Invalid value*/            /**<CNcomment:*/
+} HI_UNF_TUNER_T2_PLP_TYPE_E;
+
+/** Structure of the terrestrial transmission signal's detailed information.*/
+/** CNcomment:*/
+typedef struct  hiUNF_TUNER_TER_SIGNALINFO_S
+{
+    HI_U32                              u32Freq;                /**<Frequency, in kHz*/         /**<CNcomment:kHz*/
+    HI_U32                              u32BandWidth;           /**<Band width, in KHz*/        /**<CNcomment:KHz */
+    HI_UNF_MODULATION_TYPE_E            enModType;              /**<Modulation type*/           /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E           enFECRate;              /**<FEC rate*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FECRATE_E           enLowPriFECRate;
+    HI_UNF_TUNER_FE_GUARD_INTV_E        enGuardIntv;            /**<GI mode*/                   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_E               enFFTMode;              /**<FFT mode*/                  /**<CNcomment:FFT*/
+    HI_UNF_TUNER_FE_HIERARCHY_E         enHierMod;              /**<Hierarchical Modulation and alpha, only used in DVB-T*/
+                                                                /**<CNcomment:hierachicalalpha*/
+    HI_UNF_TUNER_TS_PRIORITY_E          enTsPriority;           /**<The TS priority, only used in DVB-T*/
+                                                                /**<CNcomment:ts priority, DVB-T*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E          enPLPType;              /**<PLP type*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_TER_PILOT_PATTERN_E    enPilotPattern;         /**<pilot pattern*/             /**<CNcomment:*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_E     enCarrierMode;          /**<carrier mode*/              /**<CNcomment:*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_E   enConstellationMode;    /**<constellation mode*/        /**<CNcomment:*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_E   enFECFrameMode;         /**<FEC frame length*/          /**<CNcomment:FEC*/
+    HI_UNF_TUNER_TER_MODE_E             enChannelMode;          /**<Base channel or Lite channel, only used in DVB-T2 */            /**<CNcomment:BaseLiteDVB-T2*/
+    HI_UNF_TUNER_DVBT2_ISSY_E           enDVBT2ISSY;            /**<DVB-T2 ISSY type */        /**<CNcomment:ISSY*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_E      enStreamType;           /**<Stream type */             /**<CNcomment:*/
+    HI_U16                              u16CellID;              /**< Cell ID*/                 /**<CNcomment:ID*/
+    HI_U16                              u16NetworkID;           /**< NetWork ID*/              /**<CNcomment:ID*/
+    HI_U16                              u16SystemID;            /**< System ID*/               /**<CNcomment:ID*/
+} HI_UNF_TUNER_TER_SIGNALINFO_S;
+
+/** Structure of the ISDB-T terrestrial transmission signal's detailed information.*/
+/** CNcomment:ISDB-T*/
+typedef struct  hiUNF_TUNER_ISDB_T_SIGNALINFO_S
+{
+    HI_U32                                  u32Freq;            /**<Frequency, in kHz */        /**<CNcomment:: kHz */
+    HI_U32                                  u32BandWidth;       /**<Band width, in KHz */       /**<CNcomment:KHz */
+    HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U    unISDBTLayers;      /**<the transmission and used information of ISDBT layer*/          /**<CNcomment:ISDBT*/
+    HI_UNF_TUNER_TMCC_INFO_S                stISDBTTMCCInfo;    /**<the para of ISDBT layer*/   /**<CNcomment:ISDBT*/
+    HI_UNF_TUNER_FE_GUARD_INTV_E            enGuardIntv;        /**<GI mode*/                   /**<CNcomment:*/
+    HI_UNF_TUNER_FE_FFT_E                   enFFTMode;          /**<FFT mode*/                  /**<CNcomment:FFT*/
+} HI_UNF_TUNER_ISDB_T_SIGNALINFO_S;
+
+/** signal information.*/
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_SIGNALINFO_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;              /**<Signal transmission type*/    /**<CNcomment:*/
+
+    union
+    {
+        HI_UNF_TUNER_SAT_SIGNALINFO_S stSat;        /**<Signal info of satellite*/    /**<CNcomment:*/
+        HI_UNF_TUNER_TER_SIGNALINFO_S stTer;        /**<Signal info of terrestrial*/  /**<CNcomment:*/
+        HI_UNF_TUNER_ISDB_T_SIGNALINFO_S stIsdbT;/**<Signal info of ISDB-T terrestrial*/  /**<CNcomment:ISDB-T*/
+    } unSignalInfo;
+} HI_UNF_TUNER_SIGNALINFO_S;
+
+/** unicable multi-switch port.*/
+/** CNcomment:unicable*/
+typedef enum hiUNF_TUNER_SATPOSITION_E
+{
+    HI_UNF_TUNER_SATPOSN_A,    /**<unicable switch port A*/    /**<CNcomment:A*/
+    HI_UNF_TUNER_SATPOSN_B,    /**<unicable switch port B*/    /**<CNcomment:B*/
+    HI_UNF_TUNER_SATPOSN_BUT   /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_SATPOSITION_E;
+
+/** LNB configurating parameters*/
+/** CNcomment:LNB*/
+typedef struct hiUNF_TUNER_FE_LNB_CONFIG_S
+{
+    HI_UNF_TUNER_FE_LNB_TYPE_E  enLNBType;      /**<LNB type*/                              /**<CNcomment:LNB*/
+    HI_U32                      u32LowLO;       /**< Low Local Oscillator Frequency, MHz */ /**<CNcomment:LNBMHz*/
+    HI_U32                      u32HighLO;      /**< High Local Oscillator Frequency, MHz*/ /**<CNcomment:LNBMHz*/
+    HI_U32                      u32MediumLO;      /**< Medium Local Oscillator Frequency, MHz*/ /**<CNcomment:LNBMHz*/
+    HI_UNF_TUNER_FE_LNB_BAND_E  enLNBBand;      /**< LNB band, C or Ku */                   /**<CNcomment:LNBCKu*/
+
+    /** Structure of the unicable device attribute.*/
+    /** CNcomment:Unicable*/
+    HI_U8 u8UNIC_SCRNO;                         /**< SCR number, 0-31 */                     /**<CNcomment:SCR0-31*/
+    HI_U32 u32UNICIFFreqMHz;                    /**< SCR IF frequency, unit MHz */          /**<CNcomment:SCR MHz*/
+    HI_UNF_TUNER_SATPOSITION_E enSatPosn;       /**< unicable multi-switch port */          /**<CNcomment:unicable*/
+    HI_BOOL bPinProtect;                        /**< UB with pin protect */                     /**<CNcomment:pin*/
+} HI_UNF_TUNER_FE_LNB_CONFIG_S;
+
+/** tuner attribution.*/
+/** CNcomment:TUNER*/
+typedef struct  hiHI_UNF_TUNER_ATTR_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E     enSigType;          /**<Signal type*/                               /**<CNcomment:*/
+    HI_UNF_TUNER_DEV_TYPE_E     enTunerDevType;     /**<Tuner type*/                                /**<CNcomment:TUNER*/
+    HI_U32                      u32TunerAddr;       /*The i2c address of tuner, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_DEMOD_DEV_TYPE_E     enDemodDevType;     /**<QAM type*/                                  /**<CNcomment:QAM*/
+    HI_U32                      u32DemodAddr;       /*The i2c address of demod, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_TUNER_OUPUT_MODE_E   enOutputMode ;      /**<Output mode of transport streams (TSs)*/    /**<CNcomment:TS*/
+    HI_U8                       enI2cChannel;       /**<I2C channel used by the demod*/             /**<CNcomment:DEMODI2C*/
+    HI_U8                       enTunerI2cChannel;  /**<I2C channel used by the tuner*/             /**<CNcomment:TUNERI2C tuner demodI2CR858*/
+    HI_U32                      u32ResetGpioNo;     /**<Demod reset GPIO NO.*/                      /**<CNcomment:gpio*/
+    HI_U32                      u32MemoryMode;      /**<Only valid in Hi3716MV430 DVBT2,0 is low memory mode,1 is high memory mode.Low memory mode default,COMMON PLP is not supported in this mode.*/
+                                                    /**<CNcomment: Hi3716MV430DVB-T2 01COMMON PLP*/
+} HI_UNF_TUNER_ATTR_S;
+
+/** Frequency locking parameters of the tuner*/
+/** CNcomment:TUNER*/
+typedef struct  hiUNF_TUNER_CONNECT_PARA_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;          /**<Signal type*/                       /**<CNcomment:*/
+
+    union
+    {
+        HI_UNF_CAB_CONNECT_PARA_S stCab;        /**<Cable transmission signal*/         /**<CNcomment:CABLE*/
+        HI_UNF_TER_CONNECT_PARA_S stTer;        /**<Terrestrial transmission signal*/   /**<CNcomment:*/
+        HI_UNF_SAT_CONNECT_PARA_S stSat;        /**<Satellite transmission signal*/     /**<CNcomment:*/
+    } unConnectPara;
+} HI_UNF_TUNER_CONNECT_PARA_S ;
+
+/** Frequency locking status and parameters of the tuner*/
+/** CNcomment:TUNER*/
+typedef struct  hiUNF_TUNER_STATUS_S
+{
+    HI_UNF_TUNER_LOCK_STATUS_E  enLockStatus ;  /**<Frequency locking status*/               /**<CNcomment:*/
+    HI_UNF_TUNER_CONNECT_PARA_S stConnectPara;  /**<Actual frequency locking parameters*/    /**<CNcomment:*/
+} HI_UNF_TUNER_STATUS_S;
+
+/** Tuner blind scan type*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_MODE_E
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_AUTO = 0,       /**<Blind scan automatically*/  /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_MANUAL,         /**<Blind scan manually*/       /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_BUTT            /**<Invalid value*/             /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_MODE_E;
+
+/** Definition of blind scan event type*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_EVT_E
+{
+    HI_UNF_TUNER_BLINDSCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_NEWRESULT,       /**<Find new channel*/  /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_EVT_E;
+
+/** Definition of tuner blind scan status*/
+/** CNcomment:TUNER*/
+typedef enum hiUNF_TUNER_BLINDSCAN_STATUS_E
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_STATUS_E;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_STATUS_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E;
+
+/** Structure of satellite TP*/
+/** CNcomment:TUNERTP*/
+typedef struct  hiUNF_TUNER_SAT_TPINFO_S
+{
+    HI_U32                          u32Freq;            /**<Downlink frequency, in kHz*/    /**<CNcomment:kHz*/
+    HI_U32                          u32SymbolRate;      /**<Symbol rate, in bit/s*/         /**<CNcomment:bps */
+    HI_UNF_TUNER_FE_POLARIZATION_E  enPolar;            /**<Polarization type*/             /**<CNcomment:*/
+    HI_U8                           cbs_reliablity;     /**<TP reliability*/                /**<CNcomment:TP*/
+} HI_UNF_TUNER_SAT_TPINFO_S;
+
+/** Structure of terrestrial tp information*/
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_TER_CHANNEL_ATTR_S
+{
+    HI_U32 u32Frequency;        /**<frequency of TP,unit KHz*/                /**<CNcomment:KHz*/
+    HI_U32 u32BandWidth;        /**<BandWidth of TP,unit KHz*/                /**<CNcomment:KHz*/
+    HI_U8  u8DVBTMode;          /**<signal type.0--DVB-T2,1--DVB-T*/          /**<CNcomment:.0--DVB-T2,1--DVB-T*/
+    HI_U8  u8PlpIndex;          /**<plp index*/                               /**<CNcomment:*/
+    HI_U8  u8PlpId;             /**<plp id*/                                  /**<CNcomment:ID*/
+    HI_U8  u8CommId;            /**<common plp id*/                           /**<CNcomment:ID*/
+    HI_U8  u8Combination;       /**<plp combination flag*/                    /**<CNcomment:*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;  /**<channel attribute*/             /**<CNcomment:*/
+    HI_UNF_TUNER_TS_PRIORITY_E  enTSPri;        /**<TS priority, only in DVB-T*/    /**<CNcomment:TSDVB-T*/
+} HI_UNF_TUNER_TER_CHANNEL_ATTR_S;
+
+/** Notify structure of tuner blind scan */
+/** CNcomment:TUNER*/
+typedef union hiUNF_TUNER_BLINDSCAN_NOTIFY_U
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_E* penStatus;             /**<Scanning status*/            /**<CNcomment:*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/          /**<CNcomment:*/
+    HI_UNF_TUNER_SAT_TPINFO_S* pstResult;                   /**<Scanning result*/            /**<CNcomment:*/
+} HI_UNF_TUNER_BLINDSCAN_NOTIFY_U;
+
+/** Parameter of the satellite tuner blind scan */
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_SAT_BLINDSCAN_PARA_S
+{
+    /**<LNB Polarization type, only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;
+
+    /**<LNB 22K signal status, for Ku band LNB which has dual LO, 22K ON will select high LO and 22K off select low LO,
+        only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB 22KKuLNBONOFF*/
+    HI_UNF_TUNER_FE_LNB_22K_E      enLNB22K;
+
+    /**<Blind scan start IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:()kHz*/
+    HI_U32                         u32StartFreq;
+
+    /**<Blind scan stop IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:()kHz*/
+    HI_U32                         u32StopFreq;
+
+    /**<The execution of the blind scan may change the 13/18V or 22K status.
+        If you use any DiSEqC device which need send command when 13/18V or 22K status change,
+        you should registe a callback here. Otherwise, you can set NULL here.*/
+    /**<CNcomment:22KDiSEqC13/18V22K
+        NULL */
+    HI_VOID (*pfnDISEQCSet)(HI_U32 u32TunerId, HI_UNF_TUNER_FE_POLARIZATION_E enPolar,
+                            HI_UNF_TUNER_FE_LNB_22K_E enLNB22K);
+
+    /**<Callback when scan status change, scan progress change or find new channel.*/
+    /**<CNcomment:*/
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_BLINDSCAN_EVT_E enEVT, HI_UNF_TUNER_BLINDSCAN_NOTIFY_U * punNotify);
+} HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E;
+
+typedef union hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E* penStatus;         /**<Scanning status*/   /**<CNcomment:*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/ /**<CNcomment:*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S;
+
+/** Structure of terrestrial scan*/
+/** CNcomment:TUNERDVB-T/T2*/
+typedef struct hiUNF_TUNER_UNICABLE_SCAN_PARA_S
+{
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E enEVT, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S *pNotify);
+} HI_UNF_TUNER_UNICABLE_SCAN_PARA_S;
+
+/** Parameter of the tuner blind scan */
+/** CNcomment:TUNER*/
+typedef struct hiUNF_TUNER_BLINDSCAN_PARA_S
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_E enMode;            /**<Scanning mode*/            /**<CNcomment:*/
+    union
+    {
+        HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S stSat;    /**<Scanning parameter*/        /**<CNcomment:*/
+    } unScanPara;
+} HI_UNF_TUNER_BLINDSCAN_PARA_S;
+
+/** PLP information */
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_TER_PLP_INFO_S
+{
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:ID*/
+    HI_U8                       u8PlpGrpId;         /**<PLP group id*/          /**<CNcomment:ID*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E  enPlpType;          /**<PLP type*/              /**<CNcomment:*/
+} HI_UNF_TUNER_TER_PLP_INFO_S;
+
+/** DiSEqC Level*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_LEVEL_E
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_1_X,      /**<1.x, one way*/                  /**<CNcomment:1.x */
+    HI_UNF_TUNER_DISEQC_LEVEL_2_X,      /**<2.x, two way, support reply*/   /**<CNcomment:2.xReply*/
+    HI_UNF_TUNER_DISEQC_LEVEL_BUTT      /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LEVEL_E;
+
+/** Receive status of DiSEqC reply massage*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_RECV_STATUS_E
+{
+    HI_UNF_TUNER_DISEQC_RECV_OK,        /**<Receive successfully*/          /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_UNSUPPORT, /**<Device don't support reply*/    /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_TIMEOUT,   /**<Receive timeout*/               /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_ERROR,     /**<Receive fail*/                  /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_RECV_BUTT       /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECV_STATUS_E;
+
+/** Structure of the DiSEqC send massage */
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_SENDMSG_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;        /**<Device level*/                         /**<CNcomment:*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_E enToneBurst;    /**<Tone Burst */                          /**<CNcomment:tone*/
+    HI_U8                           au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Message data*/   /**<CNcomment:*/
+    HI_U8                           u8Length;       /**<Message length*/                       /**<CNcomment:*/
+    HI_U8                           u8RepeatTimes;  /**<Message repeat times*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SENDMSG_S;
+
+/** Structure of the DiSEqC reply massage */
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RECVMSG_S
+{
+    HI_UNF_TUNER_DISEQC_RECV_STATUS_E enStatus;     /**<Recieve status*/                                 /**<CNcomment:*/
+    HI_U8                             au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Recieve message data*/   /**<CNcomment:*/
+    HI_U8                             u8Length;     /**<Recieve message length*/                         /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECVMSG_S;
+
+typedef struct hiUNF_TUNER_SCR_UB_S
+{
+    HI_U32          u32SCRNo;
+    HI_S32          s32CenterFreq;      /**<Unit MHz*/
+}HI_UNF_TUNER_SCR_UB_S;
+
+/** DiSEqC Switch port*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_SWITCH_PORT_E
+{
+    HI_UNF_TUNER_DISEQC_SWITCH_NONE = 0,         /**<none*/                                 /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_1,           /**<port1*/                                /**<CNcomment:1*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_2,           /**<port2*/                                /**<CNcomment:2*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_3,           /**<port3*/                                /**<CNcomment:3*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_4,           /**<port4*/                                /**<CNcomment:4*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_5,           /**<port5*/                                /**<CNcomment:5*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_6,           /**<port6*/                                /**<CNcomment:6*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_7,           /**<port7*/                                /**<CNcomment:7*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_8,           /**<port8*/                                /**<CNcomment:8*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_9,           /**<port9*/                                /**<CNcomment:9*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_10,          /**<port10*/                               /**<CNcomment:10*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_11,          /**<port11*/                               /**<CNcomment:11*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_12,          /**<port12*/                               /**<CNcomment:12*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_13,          /**<port13*/                               /**<CNcomment:13*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_14,          /**<port14*/                               /**<CNcomment:14*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_15,          /**<port15*/                               /**<CNcomment:15*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_16,          /**<port16*/                               /**<CNcomment:16*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_BUTT         /**<Invalid value*/                        /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SWITCH_PORT_E;
+
+/** Parameter for DiSEqC 1.0/2.0 switch
+   Some DiSEqC device need set polarization(13/18V) and 22K, you can set them here. */
+/** CNcomment:DiSEqC 1.0/2.0 
+   DiSEqC22K */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH4PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/            /**<CNcomment:*/
+    HI_UNF_TUNER_FE_POLARIZATION_E    enPolar;  /**<Polarization type */            /**<CNcomment:*/
+    HI_UNF_TUNER_FE_LNB_22K_E         enLNB22K; /**<22K status*/                    /**<CNcomment:22k*/
+} HI_UNF_TUNER_DISEQC_SWITCH4PORT_S;
+
+/** Parameter for DiSEqC 1.1/2.1 switch */
+/** CNcomment:DiSEqC 1.1/2.1  */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH16PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/            /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/             /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_SWITCH16PORT_S;
+
+/** DiSEqC motor limit setting*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_LIMIT_E
+{
+    HI_UNF_TUNER_DISEQC_LIMIT_OFF,              /**<Disable Limits*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_EAST,             /**<Set East Limit*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_WEST,             /**<Set West Limit*/                /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_BUTT              /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LIMIT_E;
+
+/** Difinition of DiSEqC motor move direction*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_DIR_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_EAST,          /**<Move east*/                     /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_WEST,          /**<Move west*/                     /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_BUTT           /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_MOVE_DIR_E;
+
+/** Difinition of DiSEqC motor move type*/
+/** CNcomment:DiSEqC*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_TYPE_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW,         /**<1 step one time, default*/      /**<CNcomment:1 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW1,        /**<2 step one time*/               /**<CNcomment:2 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW2,        /**<3 step one time*/               /**<CNcomment:3 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW3,        /**<4 step one time*/               /**<CNcomment:4 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW4,        /**<5 step one time*/               /**<CNcomment:5 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST,         /**<6 step one time*/               /**<CNcomment:6 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST1,        /**<7 step one time*/               /**<CNcomment:7 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST2,        /**<8 step one time*/               /**<CNcomment:8 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST3,        /**<9 step one time*/               /**<CNcomment:9 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST4,        /**<10 step one time*/               /**<CNcomment:10 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_CONTINUE,          /**<Continuous moving*/             /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_BUTT          /**<Invalid value*/                 /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_MOVE_TYPE_E;
+
+/** Parameter for DiSEqC motor store position*/
+/** CNcomment:*/
+typedef struct hiUNF_TUNER_DISEQC_POSITION_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:*/
+    HI_U32                      u32Pos;         /**<Index of position, 0-255*/          /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_POSITION_S;
+
+/** Parameter for DiSEqC motor limit setting*/
+/** CNcomment:Limit*/
+typedef struct hiUNF_TUNER_DISEQC_LIMIT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_LIMIT_E enLimit;        /**<Limit setting*/                     /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_LIMIT_S;
+
+/** Parameter for DiSEqC motor moving*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_MOVE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_E enType;     /**<Moving type*/                   /**<CNcomment:()*/
+} HI_UNF_TUNER_DISEQC_MOVE_S;
+
+/** Parameter for DiSEqC motor running*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RUN_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:*/
+    HI_U32                          u32RunningSteps;        /**<0 mean running continus;1~128 mean running steps every time.*/
+                                                            /**<CNcomment:01~128step*/
+} HI_UNF_TUNER_DISEQC_RUN_S;
+
+/** Parameter for DiSEqC motor recalculate*/
+/** CNcomment:DiSEqC*/
+typedef struct hiUNF_TUNER_DISEQC_RECALCULATE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/           /**<CNcomment:*/
+    HI_U8                       u8Para1;        /**<Parameter 1*/                   /**<CNcomment:1*/
+    HI_U8                       u8Para2;        /**<Parameter 2*/                   /**<CNcomment:2*/
+    HI_U8                       u8Para3;        /**<Parameter 3*/                   /**<CNcomment:3*/
+    HI_U8                       u8Reserve;      /**<Reserve*/                       /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_RECALCULATE_S;
+
+/** Parameter for USALS*/
+/** CNcomment:USALS */
+typedef struct hiUNF_TUNER_DISEQC_USALS_PARA_S
+{
+    HI_U16 u16LocalLongitude;   /**<local longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:0.10-18001800-36003600-*/
+    HI_U16 u16LocalLatitude;    /**<local latitude, is 10*latitude, in param N:0-900, S:900-1800(1800-latitude)*/
+                                /**<CNcomment:0.10-900900-18001800-*/
+    HI_U16 u16SatLongitude;     /**<sat longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:0.10-18001800-36003600-*/
+    HI_U16 u16Angular;          /**<calculate result, out param*/
+                                /**<CNcomment:*/
+} HI_UNF_TUNER_DISEQC_USALS_PARA_S;
+
+/** Parameter for USALS goto angular*/
+/** CNcomment:USALS*/
+typedef struct hiUNF_TUNER_DISEQC_USALS_ANGULAR_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/                                       /**<CNcomment:*/
+    HI_U16                      u16Angular;     /**<Angular, calculated by HI_UNF_TUNER_DISEQC_CalcAngular()*/  /**<CNcomment:HI_UNF_TUNER_DISEQC_CalcAngular*/
+} HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+/*---TUNER---*/
+/**
+\brief Initializes the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+\param N/A                                    CNcomment: CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+\param  N/A                    CNcomment: CNend
+\retval ::HI_SUCCESS Success   CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DeInit(HI_VOID);
+
+/**
+\brief  Obtains the default attributes of the tuner.
+CNcomment:\brief  TUNERCNend
+\attention \n
+This API is available only after the tuner is initialized.
+CNcomment:TUNERCNend
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2CNend
+\param[out] pstTunerAttr The default attributes of the tuner are returned. CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success.                                      CNcomment:  CNend
+\retval ::HI_FAILURE Calling this API fails.                                               CNcomment: API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The Frontend module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:PORT  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:PORT  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDeftAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTunerAttr tuner attributes                            CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL The input I2C channel is invalid. CNcomment:I2C  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetAttr(HI_U32  u32tunerId , const HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief While using satellite channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstSatTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETSATATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_SAT_ATTR_S *pstSatTunerAttr);
+
+/**
+\brief While using terrestrial channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetTerAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_TER_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief While using cable channel, sets the current attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetCabAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_CAB_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief Obtains the attributes of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+This API is available only after the tuner is initialized.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.                CNcomment:TUNER0-2 CNend
+\param[out] pstTunerAttr   The current attributes of the tuner are returned. CNcomment:TUNERCNend
+\retval ::HI_SUCCESS Success                                                 CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                                CNcomment: API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Starts the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_FAILURE Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_INIT  Opening The TUNER module  fails. CNcomment:CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Open (HI_U32    u32tunerId);
+
+
+/**
+\brief Stops the tuner.
+CNcomment:\brief TUNERCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:TUNERCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.     CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS Success                                      CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                     CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Close(HI_U32    u32tunerId);
+
+
+/**
+\brief Locks the frequency of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] pstConnectPara   Information about the frequency of the tuner  CNcomment:TUNERCNend
+\param[in] u32TimeOut  Wait timeout (in ms) when the frequency of the tuner \n
+is locked. The value 0 indicates no wait, and any other value indicates the \n
+maximum wait period.
+                                                                          CNcomment:TUNER0msCNend
+\retval ::HI_SUCCESS Success                                              CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_CONNECT The signal is locked unsuccessfully . CNcomment:CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Connect(HI_U32  u32tunerId , const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara,HI_U32 u32TimeOut);
+
+
+/**
+\brief  set TS out.CNcomment:TS CNend
+\attention \n
+\Please call this API to set TS out. \n
+\There are 12 signals in ts interface, ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clk.\n
+\There're 12 pins in HI3136 or HI3130v200 chip, and each pin can be set to output ts_dat[0..7], ts_sync,\n
+\ts_vld or ts_err, but ts_clk is binded to one pin, cannot be setted.\n
+CNcomment:ts12ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clkHI3136/HI3130V200 12ts\n
+ts_clkts_clkpstTSOUT->enTSOutput[0..7]TS_OUT0..TS_OUT7;\n
+pstTSOUT->enTSOutput[8..10]TS_SYNC,TS_VALID,TS_ERRCNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] pstTSOUT   pointer of ts pin.                                  CNcomment:ts::HI_UNF_TUNER_TSOUT_SET_S CNend
+\retval ::HI_SUCCESS                                                      CNcomment: success. CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTSOUT Setting tsout fails. CNcomment:ts out  CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_TUNER_SetTSOUT(HI_U32 u32TunerId, HI_UNF_TUNER_TSOUT_SET_S *pstTSOUT);
+
+/**
+\brief Obtains the frequency locking status and parameters of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in] u32TimeOut frequency locking timeout, unit: ms, frequency locking time is related to strength of signal CNcomment:CNend
+               if you want to get the state of locking, the u32TimeOut should be set 100ms at least;
+               if the u32TimeOut is 0, just config register without locking state, return HI_SUCCESS
+               CNcomment: 100ms
+                          0HI_SUCCESSCNend
+\param[out] pstTunerStatus: The current frequency locking status and parameters of the tuner are returned. Note: This parameter is valid only when HI_SUCCESS is returned.  CNcomment: TUNER CNend
+\retval ::HI_SUCCESS Success                    CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetStatus(HI_U32    u32tunerId , HI_UNF_TUNER_STATUS_S  *pstTunerStatus);
+
+
+/**
+\brief Obtains the current bit error rate (BER) of the tuner. The BER is expressed by using the scientific notation.
+CNcomment:\brief TUNER CNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] pu32BER  Pointer to the current BER of the tuner The error bit rate consists of three elements. Their definitions are as follows:
+                      Their definitions are as follows:
+                    pu32BER[0]: integral part of the base number of the BER
+                    pu32BER[1]: decimal part of the base number of the BER x 1000
+                    pu32BER[2]: absolute value of the exponential of the BER
+                    For example, if the BER is 2.156E-7, the values of the three elements are
+                    2, 156, and 7 respectively.
+                    The three elements are valid only when HI_SUCCESS is returned.
+                    Otherwise, the application layer sets a large value as required, for example, 0.5 (the values of the three elements are 5, 0, and 1 respectively).
+                         0.5 (the values of the three elements are 5, 0, and 1 respectively).
+CNcomment:\param[out] pu32BER  TUNER :
+                              pu32BER[0]:
+                              pu32BER[1]:1000
+                              pu32BER[2]:
+                              :2.156E-7
+                              21567
+                              
+                              (0.5501)CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetBER(HI_U32   u32tunerId , HI_U32 *pu32BER);
+
+
+/**
+\brief Obtains the current signal-to-noise ratio (SNR) of the tuner.
+CNcomment:\brief TUNER CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SNR  Pointer to the current SNR of the tuner,SNR unit:dB,not reserves fractional part.
+                    This parameter is valid only when HI_SUCCESS is returned.
+                   Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pu32SNR  TUNERdB
+                              
+                              CNend
+\retval ::HI_SUCCESS Success                   CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSNR(HI_U32   u32tunerId , HI_U32 *pu32SNR );
+
+/**
+\brief Obtains the current precise signal-to-noise ratio (SNR) of the tuner.
+CNcomment:\brief TUNER CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pdSNR  Pointer to the current SNR of the tuner,SNR unit:dB,and reserves fractional part.
+                    This parameter is valid only when HI_SUCCESS is returned.
+                   Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pdSNR  TUNERdB
+                              
+                              CNend
+\retval ::HI_SUCCESS Success                   CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPreciseSNR(HI_U32   u32tunerId , HI_DOUBLE *pdSNR );
+
+
+/**
+\brief Obtains the current signal strength of the tuner.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SignalStrength  Pointer to the current signal strength of the tuner
+                            For cable signal, the value of *pu32SignalStrength ranges from 20~120.
+                            For satellite signal, the value is 0~100, unit in percent.
+                            For terrestrial signal, the value is 0~100, unit in percent.
+                  This parameter is valid only when HI_SUCCESS is returned.
+                  Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pu32SignalStrength  TUNER
+                            Cable*pu32SignalStrength20~120
+                            Satellite*pu32SignalStrength0~100
+                            Terrestrial*pu32SignalStrength0~100
+                            
+                            CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalStrength(HI_U32   u32tunerId , HI_U32 *pu32SignalStrength );
+
+/**
+\brief Obtains the current signal quality of the tuner, returns a percentage value.
+CNcomment:\brief TUNER( DVB_C J83B)CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32SignalQuality   Output pointer.                       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALQUALITY Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalQuality(HI_U32 u32TunerId, HI_U32 *pu32SignalQuality);
+
+/**
+\brief Obtains the actual frequency and symbol rate of the current tuner for cable,terrestrial and satellite
+signal, for terrestrial signal, symbol rate means nothing, ignore it.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu32Freq   Pointer to the current frequency of the tuner. CNcomment:TUNERCNend
+\param[out] pu32Symb   Points to the current symbol rate.             CNcomment: CNend
+\retval ::HI_SUCCESS Success                                          CNcomment: CNend
+\retval ::HI_FAILURE  Calling this API fails.                         CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetRealFreqSymb( HI_U32 u32TunerId, HI_U32 *pu32Freq, HI_U32 *pu32Symb );
+
+/**
+\brief Obtains current signal information of the TUNER, used in satellite and terrestrial, not necessary for cable.
+CNcomment:\brief TUNERCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pstSignalInfo Pointer to a signal info structure.         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALINFO  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SIGNALINFO_S *pstSignalInfo);
+
+/**
+\brief Sets the LNB parameter.
+CNcomment:\brief LNBCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstLNB      Pointer to a LNB parameter structure.          CNcomment:LNBCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBConfig(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_CONFIG_S *pstLNB);
+
+/**
+\brief Sets the LNB power.
+CNcomment:\brief LNBCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLNBPower  The enumeration of the LNB power type.         CNcomment:LNBCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBPower(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_POWER_E enLNBPower);
+
+/**
+\brief Gets PLP number, only used in DVB-T2.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[out] pu8PLPNum  The PLP number.                                CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_GETPLPNUM  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPLPNum(HI_U32 u32TunerId, HI_U8 *pu8PLPNum);
+
+
+
+
+/**
+\brief Sets PLP ID, only used in DVB-T2.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPLPPara  The PLP parameters.                                       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetPLPPara(HI_U32 u32TunerId, HI_UNF_TUNER_TER_PLP_PARA_S *pstPLPPara);
+
+/**
+\brief Get PLP information, only used in DVB-T2.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] u32PLPIndex  PLP index.                                    CNcomment:CNend
+\param[out] pstPLPInfo  The PLP information.                          CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_TUNER_GetPLPInfo(HI_U32 u32TunerId, HI_U32 u32PLPIndex, HI_UNF_TUNER_TER_PLP_INFO_S *pstPLPInfo);
+
+/**
+\brief Set antenna power.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enPower  The antenna power status.                         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened.      CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid.  CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetAntennaPower(HI_U32 u32TunerId, HI_UNF_TUNER_TER_ANTENNA_POWER_E enPower);
+
+
+/**
+\brief Starts blind scan.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to the blind scan parameter.       CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_BLINDSCAN Blind scan busy. CNcomment: CNend
+
+\see Please refer to definition of HI_UNF_TUNER_BLINDSCAN_PARA_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStart(HI_U32 u32TunerId, const HI_UNF_TUNER_BLINDSCAN_PARA_S *pstPara);
+
+/**
+\brief Stops blind scan.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStop(HI_U32 u32TunerId);
+
+/**
+\brief TUNER standby.
+CNcomment:\brief TUNER(  DVB_C J83Bpmoc )  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_STANDBY  Calling this CMD fails. CNcomment:ioctl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Standby(HI_U32 u32TunerId);
+
+/**
+\brief Wakes up TUNER.
+CNcomment:\brief TUNER(  DVB_C J83Bpmoc ) CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_WAKEUP  Calling this CMD fails. CNcomment:ioctl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_WakeUp( HI_U32 u32TunerId);
+/*ZHTQ ADD*/
+HI_S32 TUNER_DISEQC_SendMessage(HI_U32 u32TunerId,
+                                           const HI_UNF_TUNER_DISEQC_SENDMSG_S * pstSendMsg);
+
+HI_S32 TUNER_DISEQC_RecvMessage(HI_U32 u32TunerId,
+                                           HI_UNF_TUNER_DISEQC_RECVMSG_S * pstRecvMsg);
+
+/**
+\brief Sends and receives DiSEqC message, only the devices supporting DiSEqC 2.x support receive message.
+CNcomment:\brief DiSEqCDiSEqC 2.xCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER, 0-2 CNend
+\param[in] pstSendMsg  The pointer to a sending message structure.    CNcomment:CNend
+\param[out] pstRecvMsg The pointer to a receiving message structure.If your device is DiSEqC 1.x, you can pass NULL here.
+CNcomment:\param[out] pstRecvMsg DiSEqC 1.xNULLCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Send DiSEqC message fail. CNcomment: CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Recv DiSEqC message fail. CNcomment: CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SendRecvMessage(HI_U32 u32TunerId,
+                                           const HI_UNF_TUNER_DISEQC_SENDMSG_S * pstSendMsg,
+                                           HI_UNF_TUNER_DISEQC_RECVMSG_S * pstRecvMsg);
+
+/**
+\brief Sets 0/12V switch. Don't support now.
+CNcomment:\brief 0/12VCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch012V(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_0_12V_E enPort);
+
+/**
+\brief Sets 22KHz switch.
+CNcomment:\brief 22KHzCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch22K(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_22K_E enPort);
+
+/**
+\brief Sets tone burst switch.
+CNcomment:\brief Tone burstCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enStatus    The enumeration of the switch port.            CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC  Calling this CMD fails. CNcomment:ioctl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SwitchToneBurst(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_TONEBURST_E enStatus);
+
+//#ifdef DISEQC_SUPPORT
+/**
+\brief Sets DiSEqC 1.0/2.0 switch, at most 4 port.
+CNcomment:\brief DiSEqC 1.0/2.04CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see Please refer to definition of HI_UNF_TUNER_DISEQC_SWITCH4PORT_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch4Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH4PORT_S* pstPara);
+
+/**
+\brief Sets DiSEqC 1.1/2.1 switch, supports 8in1, 16in1 switches.
+CNcomment:\brief DiSEqC 1.1/2.1816CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch16Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH16PORT_S* pstPara);
+
+/**
+\brief Lets the DiSEqC motor store current position.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_StorePos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Lets the DiSEqC motor move to stored position.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoPos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Enables or disables the DiSEqC motor's limit setting.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a limit parameter structure.    CNcomment:limitCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SetLimit(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LIMIT_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief DiSEqCHI_UNF_TUNER_DISEQC_MoveHI_UNF_TUNER_DISEQC_RunStep
+HI_UNF_TUNER_DISEQC_MoveHI_UNF_TUNER_DISEQC_RunStepCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Move(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_MOVE_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_RunStep(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_RUN_S* pstPara);
+
+/**
+\brief Halts DiSEqC motor.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC motor.         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Stop(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Lets the DiSEqC motor recalculate its stored positions.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a recaulculate parameter structure.
+                                                                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Recalculate(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_RECALCULATE_S* pstPara);
+
+/**
+\brief Calculates the angular, basing on site-longitude, site-latitude and satellite-longitude.
+CNcomment:\brief USALSCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in/out] pstPara The pointer to a USALS parameter structure.    CNcomment:USALSCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_CalcAngular(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_USALS_PARA_S* pstPara);
+
+/**
+\brief Gotos the indicated angular.
+CNcomment:\brief USALSCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] pstPara     The pointer to a USALS angular structure.      CNcomment:USALSCNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoAngular(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S* pstPara);
+
+/**
+\brief Resets DiSEqC device.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Reset(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief DiSEqC device standby.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Standby(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Wakes up DiSEqC device.
+CNcomment:\brief DiSEqCCNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_WakeUp(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Acquire data to display constellation.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:, 51210242048 3CNend
+\param[out] pstData       The buffer to store data.                          CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetConstellationData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_UNF_TUNER_SAMPLE_DATA_S *pstData);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:, 51210242048 3CNend
+\param[out] pu32Data      The buffer to store data.                          CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSpectrumData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_U32 *pu32Data);
+
+/**
+\brief Get the upper limit time according to the connect parameter.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  pstConnectPara     The pointer to store the connect parameter.   CNcomment:CNend
+\param[out] pu32TimeOutMs      The upper limit time.                         CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:  CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDefaultTimeout(HI_U32  u32tunerId, const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara, HI_U32 *pu32TimeOutMs);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief VCMIDVCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicPowerOff(HI_U32 u32TunerId,HI_U8 u8SCRNO);
+
+/**
+\brief Each SaTCR generates a tone at the center frequency of its associated band-pass filter.
+CNcomment: unicabletone CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicSCRxOn(HI_U32 u32TunerId);
+
+/**
+\brief Allows to check the application number.
+CNcomment: unicableCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\param[in]  u8AppNo     application number.   CNcomment:unicableCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicConfig(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8AppNo);
+
+/**
+\brief Allows to check LNB local oscillator frequencies.
+CNcomment: unicable LNBCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicableCNend
+\param[in]  u8LoFreqNo     local oscillator number.   CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicLOFREQ(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8LoFreqNo);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief VCMIDVCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:IDCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatIsiID(HI_U32 u32TunerId, HI_U8 u8IsiID);
+
+/**
+\brief Get total vcm streams number.
+CNcomment:\brief VCMCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  *pu32TotalStream      total streams number.                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatTotalStream(HI_U32 u32TunerId, HI_U8 *pu8TotalStream);
+
+/**
+\brief Get isi id,by setting stream number,will get isi id.
+CNcomment:\brief VCMIDCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  u8Stream      stream number,can be 0-n.                          CNcomment:CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:IDCNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatIsiID(HI_U32 u32TunerId, HI_U8 u8StreamIndex, HI_U8 *pu8IsiID);
+
+/**
+\brief scan 950~2150 frequency range,and find out the user bands.
+CNcomment: 950~2150MHzCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_ScanUserBands(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_PARA_S stScanPara);
+
+/**
+\brief exit from user band scanning .
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_ExitScanUserBands(HI_U32 u32TunerId);
+
+/**
+\brief get user band number after finishing scan .
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] pu32UbNum    Total number of user band after finishing scan.     CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_GetUserBandsNum(HI_U32 u32TunerId, HI_U32 *pu32UbNum);
+
+/**
+\brief Copy scanned results,get user bands information.
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[out] pstUbInfo     user bands information struct array,used to save user band number/user band frequency.       CNcomment:CNend
+\param[in]  u32UbInfoNum  the number of user bands information structs.      CNcomment:CNend
+\param[out]  pu32Num     the number of user bands actual obtained.           CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_GetUserBandsInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SCR_UB_S *pstUbInfo, HI_U32 u32UbInfoNum, HI_U32 *pu32Num);
+
+/**
+\brief config the scrambing code sequces on physical layer.
+CNcomment: CNend
+\attention \n
+N/A
+\param[in]  u32TunerId           Tuner port ID. The port ID can be 0-2.      CNcomment:TUNER0-2 CNend
+\param[in]  u32ScrambleValue     Initial scrambling code. Range 0-262141,
+                                when value is not 0, signal is special       CNcomment:0-2621410 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetScramble(HI_U32 u32TunerId, HI_U32 u32ScrambleValue);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.                                                                          CNcomment:TUNER0-2 CNend
+\param[in]  u32freqStartInHz     The sample data start freqency (Hz), For examle: 435000000 Hz, 698000000 Hz (1000HZ~1300000000HZ).     CNcomment:( ): 435000000 Hz,698000000 Hz(: 1000HZ~1300000000HZ)CNend
+\param[in]  u32freqStepInHz     The sample data step(Hz), For examle: 10000 Hz, 20000 Hz (greater than 10000Hz).                CNcomment:( ): 10000 Hz,20000 Hz (: 10000Hz )CNend
+\param[in]  u32numOfFreqSteps     The sample data number, For examle: 1000, 10000.                                          CNcomment:: 1000,10000CNend
+\param[out] ps16powerData      The buffer to store data.                                                                                      CNcomment:CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetTunerPowerSpectrumData(HI_U32 u32TunerId, HI_U32 u32freqStartInHz,HI_U32 u32freqStepInHz,HI_U32 u32numOfFreqSteps,HI_S16 *ps16powerData);
+
+/**
+\brief config which ISDBT layer is select to receive.
+CNcomment: ISDBTA/B/CCNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER0-2 CNend
+\param[in]  pstMonLayersConfig    the layers configuration.                              CNcomment: CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment: CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_MonitorISDBTLayer(HI_U32 u32TunerId, HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S *pstMonLayersConfig);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_gpio.h b/xbmc/platform/linux/hisi/hi_unf_gpio.h
new file mode 100644
index 0000000000..3d5750e750
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_gpio.h
@@ -0,0 +1,269 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_gpio.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_GPIO_H__
+#define __HI_UNF_GPIO_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      GPIO */
+/** @{*/  /** <!-- [GPIO] */
+
+#define HI_UNF_GPIO_Open  HI_UNF_GPIO_Init
+#define HI_UNF_GPIO_Close HI_UNF_GPIO_DeInit
+
+/**type of GPIO interrupt*/
+/** CNcomment:GPIO */
+typedef enum hiUNF_GPIO_INTTYPE_E
+{
+    HI_UNF_GPIO_INTTYPE_UP, /**<spring by the up edge*/                 /**< CNcomment:*/
+    HI_UNF_GPIO_INTTYPE_DOWN, /**<spring by the down edge*/               /**< CNcomment:*/
+    HI_UNF_GPIO_INTTYPE_UPDOWN, /**<spring by both the up and down edge*/   /**< CNcomment:*/
+    HI_UNF_GPIO_INTTYPE_HIGH, /**<spring by the high level*/              /**< CNcomment:*/
+    HI_UNF_GPIO_INTTYPE_LOW, /**<spring by the low level*/               /**< CNcomment:*/
+    HI_UNF_GPIO_INTTYPE_BUTT, /**<Invalid value*/                        /**< CNcomment:*/
+} HI_UNF_GPIO_INTTYPE_E;
+
+/**GPIO output type*/
+/** CNcomment:GPIO */
+typedef enum hiUNF_GPIO_OUTPUTTYPE_E
+{
+	HI_UNF_GPIO_OUTPUTTYPE_CMOS,
+	HI_UNF_GPIO_OUTPUTTYPE_OD,
+	HI_UNF_GPIO_OUTPUTTYPE_BUTT,		
+}HI_UNF_GPIO_OUTPUTTYPE_E;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      GPIO*/
+/** @{*/  /** <!-- [GPIO] */
+
+/**
+ \brief Starts the general-purpose input/output (GPIO) device.
+CNcomment:\brief GPIOGeneral Purpose Input/OutputCNend
+
+ \attention \n
+This API can be called repeatedly.
+CNcomment:CNend
+
+ \param  N/A       CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_FAILURE			Initialize GPIO failed.                 	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_OPEN_ERR  Initialize GPIO failed.                 	CNcomment:GPIOCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_Init(HI_VOID);
+
+/**
+ \brief Stops the GPIO device.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+This API can be called repeatedly.
+CNcomment:CNend
+ \param  N/A  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_CLOSE_ERR  Deinitialize GPIO failed.                 	CNcomment:GPIOCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_DeInit(HI_VOID);
+
+/**
+ \brief Reads data from a GPIO pin.
+CNcomment:\brief GPIOCNend
+
+ \attention The pin number is defined as follows: Pin number = GPIO group ID x 8 + GPIO pin ID in the group\n
+For example, GPIO1_2 indicates pin 2 in group 1, and the pin number is 10 (1 x 8 + 2).\n
+Both pin group ID and pin number are numbered from 0. Each HD chip provides GPIO pins number reference to HD chip hardware manual.\n
+CNcomment:\attention :  = GPIO*8 + GPIO\n
+GPIO1_2,12=1*8+2=10\n
+GPIO0gpio\n CNend
+
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[out] pbHighVolt   Pointer to the input level of a pin.  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_INVALID_OPT  Invalid Operation.              			CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_ReadBit(HI_U32 u32GpioNo, HI_BOOL  *pbHighVolt);
+
+/**
+ \brief Writes data to a GPIO pin.
+CNcomment:\brief GPIOCNend
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] bHighVolt  Output level of a pin              CNcomment:CNend
+                      0: low level                       CNcomment:0:  CNend
+                      1: high level                      CNcomment:1 CNend
+                     Others: high level                  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_INVALID_OPT  Invalid Operation.              			CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_WriteBit(HI_U32 u32GpioNo, HI_BOOL bHighVolt );
+
+/**
+ \brief Sets the direction (input or output) of a GPIO pin.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+When setting the operating mode of a GPIO pin, ensure that it works in GPIO mode only.\n
+This is because the GPIO pin may be multiplexed.\n
+CNcomment:GPIOGPIOCNend
+
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] bInput  Boolean variable that indicates the direction of a pin  CNcomment:CNend
+                   HI_TRUE: input pin  HI_TRUE.                           CNcomment:CNend
+                   HI_FALSE: output pin HI_FALSE.                         CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetDirBit(HI_U32 u32GpioNo, HI_BOOL bInput);
+
+/**
+ \brief Obtains the direction (input or output) of a GPIO pin.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:0103CNend
+ \param[out] pbInput   Pointer to the boolean variable that indicates the direction of a pin.  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_GetDirBit(HI_U32 u32GpioNo, HI_BOOL    *pbInput);
+
+/**
+ \brief Starts the cipher device.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] enIntType    interrupt type                                CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INTTYPE_NOT_SUPPORT  interupt type is not support.       CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_FAILED_SETINT  set interupt type failed.              	CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetIntType(HI_U32 u32GpioNo, HI_UNF_GPIO_INTTYPE_E enIntType);
+
+/**
+ \brief set GPIO single pin interrupt enable
+CNcomment:\brief GPIOCNend
+ \attention \n
+interrupte type HI_UNF_GPIO_INTTYPE_LOW and HI_UNF_GPIO_INTTYPE_HIGH is not support
+CNcomment:HI_UNF_GPIO_INTTYPE_LOW  HI_UNF_GPIO_INTTYPE_HIGHCNend
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] bEnable  HI_TRUE: interrupt enable, HI_FALSE: interrupt disable CNcomment:HI_TRUE:  ,HI_FALSE: CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_FAILED_SETENABLE  enable interupt failed.              	CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetIntEnable(HI_U32 u32GpioNo, HI_BOOL bEnable);
+
+/**
+ \brief query GPIO interrupt, report it if there is interrupter happen.\n
+CNcomment:\brief GPIOGPIOCNend
+ \attention \n
+N/A
+ \param[out] p32GpioNo    get interrupt pin number.        CNcomment:CNend
+ \param[in] u32TimeoutMs  get interrupt timeout.           CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_FAILED_GETINT  Query interupt failed.              	CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_QueryInt(HI_U32 *p32GpioNo, HI_U32 u32TimeoutMs);
+
+/**
+ \brief Obtains the output type (od or cmos) of a GPIO pin.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:0103CNend
+ \param[in] enOutputType   Pointer to the enumerate variable that indicates the direction of a pin.  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_FAILED_SETOUTPUTTYPE Get output type failed.				CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetOutputType(HI_U32 u32GpioNo, HI_UNF_GPIO_OUTPUTTYPE_E  enOutputType);
+
+/**
+ \brief Obtains the output type (od or cmos) of a GPIO pin.
+CNcomment:\brief GPIOCNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:0103CNend
+ \param[out] penOutputType   Pointer to the enumerate variable that indicates the output type of a pin.  CNcomment:CNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIOCNend
+ \retval ::HI_ERR_GPIO_FAILED_GETOUTPUTTYPE Get output type failed.				CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_GetOutputType(HI_U32 u32GpioNo, HI_UNF_GPIO_OUTPUTTYPE_E  *penOutputType);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_GPIO_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_hdcp.h b/xbmc/platform/linux/hisi/hi_unf_hdcp.h
new file mode 100644
index 0000000000..e39cb4eed1
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_hdcp.h
@@ -0,0 +1,77 @@
+#ifndef __HI_UNF_HDCP_H__
+#define __HI_UNF_HDCP_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HDCP */
+/** @{ */  /** <!-- [HDCP] */
+
+typedef struct hiUNF_DECRYPT_HDCP_S
+{
+	HI_U8 u8KSV[5];                         /**< HDCP KSV:40bits, Orignal data */
+	HI_U8 u8PrivateKey[280];                /**< HDCP Device Private key:40*56bits, Orignal data */
+}HI_UNF_HDCP_DECRYPT_S;
+
+/** Encrypted HDCP key */
+/** CNcomment:HDCP key */
+typedef struct hiUNF_ENCRYPT_HDCP_S
+{
+	HI_U8 u8EncryptKey[384];
+}HI_UNF_HDCP_ENCRYPT_S;
+
+typedef struct hiUNF_HDCPKEY_HDCP_S
+{
+    HI_BOOL bIsUseHdcpRootKey;            /**< This parameter is used to select the key(key in otp or a fixed key by hisilicon). */   /**< CNcomment: OTP/EFUSEHdcpRootKeyHDCP key. CNend*/
+    HI_U8  u8ToolAesKey[16];                 /**< The AES Key used by tool to encrypt the original hdcp key. */   /**< CNcomment: HDCPHDCP KeyAES. CNend*/
+    HI_U8  u8ToolAesIV[16];                 /**< The AES IV used by tool to encrypt the original hdcp key. */   /**< CNcomment: HDCPHDCP KeyAES. CNend*/
+    HI_BOOL EncryptionFlag;               /**< HI_TRUE:Encryption, HI_FALSE: Unencryption */    /**< CNcomment: HI_TRUE: HDCP Key, HI_FALSE:HDCP Key. CNend*/
+    union
+    {
+        HI_UNF_HDCP_DECRYPT_S DecryptData;
+        HI_UNF_HDCP_ENCRYPT_S EncryptData;
+    }key;									/**< Key = DecryptData,if EncryptionFlag == HI_FALSE.if EncryptionFlag == HI_TRUE,key = Encrpytiondata */
+    HI_U32 Reserved;                        /**< Reserved for future use */
+}HI_UNF_HDCP_HDCPKEY_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HDCP */
+/** @{ */  /** <!-- [HDCP] */
+
+
+/**
+\brief Encrypt HDCP key. HDCP key is encrypted using hdcp root key in otp when bIsUseOTPRootKey equals 'HI_TRUE' or using key defined by hisilicon when bIsUseOTPRootKey equals 'HI_FALSE'.
+\n Additional descryption:Only the 'HDMIIP_HDCPKey' is encrypted. The HDCP key format shows belows:
+\n        head                HDMIIP_HDCPKey               CRC32_0 CRC32_1
+\n		|-------|-----------------------------------------|------|------|
+\n
+\brief CNcomment: HDCP key bIsUseOTPRootKey OTPRootKeykey CNend
+\attention \n The encrypted data(u8OutEncryptKey) include two CRC32 values.CRC32_1 is used to verify the integration of the whole data, and CRC32_0 is used to debug.  CNcomment: u8OutEncryptKey2CRCCRC32_1 CRC32_0 CNend
+\param[in] :pstHdcpKey.This parameter is used to define hdcp key in encrypted mode or clear mode.  CNcomment: HDCP key,/. CNend
+\param[out]:pu8OutEncryptKey. Output the encrypted hdcp key.   CNcomment: HDCP KEY CNend
+\param[in] :u32OutEncryptKeyBufLength. The buffer length of pu8OutEncryptKey.  CNcomment: pu8OutEncryptKey. CNend
+\param[out]:pu32OutEncryptKeyLength. The length of data that write to pu8OutEncryptKey.   CNcomment: pu8OutEncryptKey CNend
+\retval HI_SUCCESS  Call this API succussful.  	CNcomment:API CNend
+\retval HI_FAILURE  Call this API fails.  		CNcomment:API CNend
+*/
+HI_S32  HI_UNF_HDCP_EncryptHDCPKey(HI_UNF_HDCP_HDCPKEY_S *pstHdcpKey,
+                                   HI_U8 *pu8OutEncryptKey,
+                                   HI_U32 u32OutEncryptKeyBufLength,
+                                   HI_U32 *pu32OutEncryptKeyLength);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_HDCP_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_hdmi.h b/xbmc/platform/linux/hisi/hi_unf_hdmi.h
new file mode 100644
index 0000000000..e99ac704ad
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_hdmi.h
@@ -0,0 +1,1326 @@
+
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_hdmi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009-12-10
+  Description   :
+  History       :
+  1.Date        : 2009-12-10
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_HDMI_H__
+#define __HI_UNF_HDMI_H__
+
+/* add include here */
+#include "hi_unf_common.h"
+#include "hi_unf_sound.h"
+#include "hi_unf_edid.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**the max infoframe length*//**CNcomment: */
+#define HI_UNF_HDMI_MAX_INFOFRAME_LEN   0X20
+
+/**HDMI default value*//**CNcomment:HDMI  */
+#define HI_UNF_HDMI_DEFAULT_SETTING     0x00
+
+/**HDMI interface ID *//**CNcomment:HDMIID  */
+typedef enum hiUNF_HDMI_ID_E
+{
+    HI_UNF_HDMI_ID_0         = 0,          /**<HDMI interface 0*/ /**<CNcomment:HDMI0 */
+    HI_UNF_HDMI_ID_BUTT
+} HI_UNF_HDMI_ID_E;
+
+/**HDMI event type*//**CNcomment: HDMI */
+typedef enum hiUNF_HDMI_EVENT_TYPE_E
+{
+    HI_UNF_HDMI_EVENT_HOTPLUG = 0x10,       /**<HDMI HotPlug event type*//**<CNcomment:<HDMI */
+    HI_UNF_HDMI_EVENT_NO_PLUG,              /**<HDMI unplug event type*//**<CNcomment:HDMI Cable  */
+    HI_UNF_HDMI_EVENT_EDID_FAIL,            /**<HDMI read edid fail event type*//**<CNcomment:HDMI EDID */
+    HI_UNF_HDMI_EVENT_HDCP_FAIL,            /**<HDCP authentication fail event type *//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_HDCP_SUCCESS,         /**<HDCP authentication succeed event type*//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_RSEN_CONNECT,         /**<TMDS link is connected*//**<CNcomment:TMDS */
+    HI_UNF_HDMI_EVENT_RSEN_DISCONNECT,      /**<TMDS link is disconnected*//**<CNcomment:TMDS */
+    HI_UNF_HDMI_EVENT_HDCP_USERSETTING,     /**<HDMI Reset *//**<CNcomment:HDCP */
+    HI_UNF_HDMI_EVENT_BUTT
+}HI_UNF_HDMI_EVENT_TYPE_E;
+
+/*Video color space mode*//**CNcomment:*/
+typedef enum hiUNF_HDMI_VIDEO_MODE
+{
+    HI_UNF_HDMI_VIDEO_MODE_RGB444,          /**<RGB444 output mode*//**<CNcomment:RGB444 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR422,        /**<YCBCR422 output mode*//**<CNcomment:YCBCR422 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR444,        /**<YCBCR444 output mode*//**<CNcomment:YCBCR444 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR420,        /**<YCBCR420 output mode*//**<CNcomment:YCBCR420 */
+    HI_UNF_HDMI_VIDEO_MODE_BUTT
+}HI_UNF_HDMI_VIDEO_MODE_E;
+
+/*HDMI Output Aspect Ratio*//**CNcomment:HDMI*/
+typedef enum hiUNF_HDMI_ASPECT_RATIO_E
+{
+    HI_UNF_HDMI_ASPECT_RATIO_NO_DATA,        /**<Aspect Ratio unknown *//**<CNcomment: */
+    HI_UNF_HDMI_ASPECT_RATIO_4TO3,           /**<Aspect Ratio 4:3  *//**<CNcomment:4:3*/
+    HI_UNF_HDMI_ASPECT_RATIO_16TO9,          /**<Aspect Ratio 16:9 *//**<CNcomment:16:9 */
+    HI_UNF_HDMI_ASPECT_RATIO_64TO27,
+    HI_UNF_HDMI_ASPECT_RATIO_256TO135,
+    HI_UNF_HDMI_ASPECT_RATIO_FUTURE,
+    HI_UNF_HDMI_ASPECT_RATIO_BUTT
+}HI_UNF_HDMI_ASPECT_RATIO_E;
+
+
+/**HDMI Deep color mode*//**CNcomment: HDMI  */
+typedef enum hiUNF_HDMI_DEEP_COLOR_E
+{
+    HI_UNF_HDMI_DEEP_COLOR_24BIT = 0x00,    /**<HDMI Deep color 24bit mode*//**<CNcomment:HDMI 24bit   */
+    HI_UNF_HDMI_DEEP_COLOR_30BIT,           /**<HDMI Deep color 30bit mode*//**<CNcomment:HDMI 30bit   */
+    HI_UNF_HDMI_DEEP_COLOR_36BIT,           /**<HDMI Deep color 36bit mode*//**<CNcomment:HDMI 36bit   */
+    HI_UNF_HDMI_DEEP_COLOR_OFF   = 0xff,
+    HI_UNF_HDMI_DEEP_COLOR_BUTT
+}HI_UNF_HDMI_DEEP_COLOR_E;
+
+/**HDMI AVI infoframe BarInfo enum*//**CNcomment: HDMI AVI BarInfo  */
+typedef enum hiUNF_HDMI_BARINFO_E
+{
+   HDMI_BAR_INFO_NOT_VALID,                 /**<Bar Data not valid *//**<CNcomment:Bar  */
+   HDMI_BAR_INFO_V,                         /**<Vertical bar data valid *//**<CNcomment:Bar  */
+   HDMI_BAR_INFO_H,                         /**<Horizental bar data valid *//**<CNcomment:bar  */
+   HDMI_BAR_INFO_VH                         /**<Horizental and Vertical bar data valid *//**<CNcomment:Bar */
+}HI_UNF_HDMI_BARINFO_E;
+
+/**HDMI AVI infofram ScanInfo enum*//**CNcomment: HDMI AVI ScanInfo  */
+typedef enum hiUNF_HDMI_SCANINFO_E
+{
+    HDMI_SCAN_INFO_NO_DATA      = 0,        /**< No Scan information*//**<CNcomment:  */
+    HDMI_SCAN_INFO_OVERSCANNED  = 1,        /**< Scan information, Overscanned (for television) *//**<CNcomment::  */
+    HDMI_SCAN_INFO_UNDERSCANNED = 2,        /**< Scan information, Underscanned (for computer) *//**<CNcomment::   */
+    HDMI_SCAN_INFO_FUTURE
+}HI_UNF_HDMI_SCANINFO_E;
+
+/**HDMI AVI InfoFrame picture scale enum*//**CNcomment: HDMI AVI Picture scale  */
+typedef enum hiUNF_HDMI_PICTURE_SCALING_E
+{
+    HDMI_PICTURE_NON_UNIFORM_SCALING,       /**< No Known, non-uniform picture scaling  *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_H,                 /**< Picture has been scaled horizentally *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_V,                 /**< Picture has been scaled Vertically *//**<CNcomment:  */
+    HDMI_PICTURE_SCALING_HV                 /**< Picture has been scaled Horizentally and Vertically   *//**<CNcomment:  */
+} HI_UNF_HDMI_PICTURE_SCALING_E;
+
+/**HDMI AVI InfoFrame colorimetry enum*//**CNcomment: HDMI AVI   */
+typedef enum hiUNF_HDMI_COLORSPACE_E
+{
+    HDMI_COLORIMETRY_NO_DATA,               /**<Colorimetry No Data option*//**<CNcomment:Colorimetry No Data */
+    HDMI_COLORIMETRY_ITU601,                /**<Colorimetry ITU601 option*//**<CNcomment:Colorimetry ITU601 */
+    HDMI_COLORIMETRY_ITU709,                /**<Colorimetry ITU709 option*//**<CNcomment:Colorimetry ITU709 */
+    HDMI_COLORIMETRY_EXTENDED,              /**<Colorimetry extended option*//**<CNcomment:Colorimetry  */
+    HDMI_COLORIMETRY_XVYCC_601,             /**<Colorimetry xvYCC601 extened option*//**<CNcomment:Colorimetry xvYCC601 */
+    HDMI_COLORIMETRY_XVYCC_709,             /**<Colorimetry xvYCC709 extened option*//**<CNcomment:Colorimetry xvYCC709 */
+    HDMI_COLORIMETRY_S_YCC_601,             /**<Colorimetry S YCC 601 extened option*//**<CNcomment:Colorimetry S YCC 601 */
+    HDMI_COLORIMETRY_ADOBE_YCC_601,         /**<Colorimetry ADOBE YCC 601 extened option*//**<CNcomment:Colorimetry ADOBE YCC 601 */
+    HDMI_COLORIMETRY_ADOBE_RGB,             /**<Colorimetry ADOBE RGB extened option*//**<CNcomment:Colorimetry ADOBE RGB */
+    HDMI_COLORIMETRY_2020_CONST_LUMINOUS,    /**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020:BT2020cYCC */
+    HDMI_COLORIMETRY_2020_NON_CONST_LUMINOUS,/**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020:BT2020RGBBT2020YCC*/
+} HI_UNF_HDMI_COLORSPACE_E;
+
+/**HDMI AVI InfoFrame RGB range enum*//**CNcomment: HDMI AVI RGB  */
+typedef enum hiUNF_HDMI_RGB_QUAN_RAGE_E
+{
+    HDMI_RGB_QUANTIZATION_DEFAULT_RANGE,    /**< Defaulr range, it depends on the video format *//**<CNcomment: */
+    HDMI_RGB_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:16-234 */
+    HDMI_RGB_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment: 0-255 */
+} HI_UNF_HDMI_RGB_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame YCC quantization range enum *//**CNcomment:HDMI AVI YCC  */
+typedef enum hiUNF_HDMI_YCC_QUAN_RAGE_E
+{
+    HDMI_YCC_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:16-234 */
+    HDMI_YCC_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment: 0-255 */
+}HI_UNF_HDMI_YCC_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame AVI video content type enum*//**CNcomment:HDMI AVI AVI  */
+typedef enum hiUNF_HDMI_CONTENT_TYPE_E
+{
+    HDMI_CONTNET_GRAPHIC,                   /**< Graphics type*//**<CNcomment: */
+    HDMI_CONTNET_PHOTO,                     /**< Photo type*//**<CNcomment: */
+    HDMI_CONTNET_CINEMA,                    /**< Cinema type*//**<CNcomment: */
+    HDMI_CONTNET_GAME                       /**< Game type*//**<CNcomment: */
+}HI_UNF_HDMI_CONTENT_TYPE_E;
+
+/**HDMI Priority judgments strategy enum*//**CNcomment:HDMI  */
+typedef enum hiUNF_HDMI_DEFAULT_ACTION_E
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_NULL,   /**<Default action null*//**<CNcomment: */
+    HI_UNF_HDMI_DEFAULT_ACTION_HDMI,   /**<Default action HDMI*//**<CNcomment:HDMI */
+    HI_UNF_HDMI_DEFAULT_ACTION_DVI,    /**<Default action DVI*//**<CNcomment:DVI */
+    HI_UNF_HDMI_DEFAULT_ACTION_BUTT
+}HI_UNF_HDMI_DEFAULT_ACTION_E;
+
+
+/**The hotplug callback function interface */
+/**CNcomment:  */
+typedef void (*HI_UNF_HDMI_CALLBACK)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+/**HDMI Callback Struct*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_CALLBACK_FUNC_S
+{
+    HI_UNF_HDMI_CALLBACK pfnHdmiEventCallback;  /**<callback function pointer*//**<CNcomment:*/
+    HI_VOID             *pPrivateData;         /**<callback funtion param*//**<CNcomment:*/
+ }HI_UNF_HDMI_CALLBACK_FUNC_S;
+
+/**HDMI Open Param*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_OPEN_PARA_S
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_E enDefaultMode;/**<HDMI Priority judgments strategy enum*//**<CNcomment:HDMI  */
+}HI_UNF_HDMI_OPEN_PARA_S;
+
+/**Current HDCP version enum*/
+/**CNcomment:HDCP */
+typedef enum hiUNF_HDMI_HDCP_VERSION_E
+{
+    HI_UNF_HDMI_HDCP_VERSION_NONE,      /**<HDCP version, none HDCP*//**<CNcomment:HDCP */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP14,    /**<HDCP version, HDCP1.4*//**<CNcomment:HDCP1.4 */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP22,    /**<HDCP version, HDCP2.2*//**<CNcomment:HDCP2.2 */
+    HI_UNF_HDMI_HDCP_VERSION_BUTT
+}HI_UNF_HDMI_HDCP_VERSION_E;
+
+/**HDMI status*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_STATUS_S
+{
+    HI_BOOL                 bConnected;             /**<The Device is connected or disconnected *//**<CNcomment: */
+    HI_BOOL                 bSinkPowerOn;           /**<The sink is PowerOn or not*//**<CNcomment:Sink */
+    HI_BOOL                 bAuthed;                /**<HDCP Authentication *//**<CNcomment:HDCP  */
+    HI_U8                   u8Bksv[5];              /**<Bksv of sink 40bits*//**<CNcomment:Bksv */
+    HI_UNF_HDMI_HDCP_VERSION_E enHDCPVersion;       /**<Current HDCP version*//**<CNcomment:HDCP */
+}HI_UNF_HDMI_STATUS_S;
+
+/**Current HDCP mode enum*/
+/**CNcomment:HDCP */
+typedef enum hiUNF_HDMI_HDCP_MODE_E
+{
+    HI_UNF_HDMI_HDCP_MODE_AUTO,         /**< HDCP auto mode,priority is 2.2 then 1.4 to set HDCP according to sink's HDCP-capability *//**<CNcomment:HDCPHDMISinkHDCP2.21.4 */
+    HI_UNF_HDMI_HDCP_MODE_1_4,          /**< forec to HDCP1.4 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:HDCP1.4sinksink */
+    HI_UNF_HDMI_HDCP_MODE_2_2,          /**< forec to HDCP2.2 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:HDCP2.2sinksink */
+    HI_UNF_HDMI_HDCP_BUTT
+}HI_UNF_HDMI_HDCP_MODE_E;
+
+/**the config parameter of HDMI interface*/
+/**CNcomment:HDMI  */
+typedef struct hiUNF_HDMI_ATTR_S
+{
+    HI_BOOL                 bEnableHdmi;         /**<force to HDMI or DVI,the value must set before HI_UNF_HDMI_Start or behind HI_UNF_HDMI_Stop*//**<CNcomment:HDMI,DVI. HI_UNF_HDMI_StartHI_UNF_HDMI_Stop  */
+
+    HI_BOOL                 bEnableVideo;        /**<parameter must set HI_TRUE,or the HDMI diver will force to set HI_TRUE*//**<CNcomment:HI_TRUE, HI_FALSE:HDMIHI_TRUE */
+
+    HI_UNF_HDMI_VIDEO_MODE_E enVidOutMode;       /**<HDMI output vedio mode VIDEO_MODE_YCBCR,VIDEO_MODE_YCBCR444,VIDEO_MODE_YCBCR422,VIDEO_MODE_RGB444 *//**<CNcomment:HDMIVIDEO_MODE_YCBCR444VIDEO_MODE_YCBCR422VIDEO_MODE_RGB444 */
+    HI_UNF_HDMI_DEEP_COLOR_E enDeepColorMode;    /**<Deep Color output mode,defualt: HI_UNF_HDMI_DEEP_COLOR_24BIT *//**<CNcomment:DeepColor, HI_UNF_HDMI_DEEP_COLOR_24BIT */
+    HI_BOOL                 bxvYCCMode;          /**<the xvYCC output mode,default:HI_FALSE*//**<CNcomment:< xvYCCHI_FALSE */
+
+    HI_BOOL                 bEnableAudio;        /**<Enable flag of Audio*//**CNcomment:Enable */
+
+    HI_BOOL                 bEnableAviInfoFrame; /**<Enable flag of AVI InfoFrame,suggestion:enable *//**<CNcomment: AVI InfoFrame */
+    HI_BOOL                 bEnableAudInfoFrame; /**<Enable flag of Audio InfoFrame,suggestion:enable*//**<CNcomment: AUDIO InfoFrame */
+    HI_BOOL                 bEnableSpdInfoFrame; /**<Enable flag of SPD info frame,suggestion:disable*//**<CNcomment: SPD InfoFrame  */
+    HI_BOOL                 bEnableMpegInfoFrame;/**<Enable flag of MPEG info frame,suggestion:disable*//**<CNcomment: MPEG InfoFrame  */
+
+    HI_BOOL                 bHDCPEnable;         /**<0:HDCP disable mode,1:eable HDCP mode.see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< 0:HDCP1:HDCPHI_UNF_HDMI_HdcpEanble */
+
+    HI_BOOL                 bEnableVidModeAdapt; /**<Enable flag of vedio mode & DVI adapting case of user setting incorrect,default:HI_TRUE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:DVI   */
+    HI_BOOL                 bEnableDeepClrAdapt; /**<Enable flag of deep color mode adapting case of user setting incorrect,default: HI_FALSE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:() */
+    HI_BOOL                 bAuthMode;           /**<Enable flag of authentication, suggestion:disable *//**<CNcomment: */
+    HI_UNF_HDMI_HDCP_MODE_E enHDCPMode;          /**<HDCP mode:HI_UNF_HDMI_HDCP_MODE_AUTO, HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2,see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< HDCPHI_UNF_HDMI_HDCP_MODE_AUTO()HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2. HI_UNF_HDMI_HdcpEanble */
+}HI_UNF_HDMI_ATTR_S;
+
+/**HDMI infoFrame type definition*/
+/**CNcomment: HDMI  */
+typedef enum tagHI_UNF_HDMI_INFOFRAME_TYPE_E
+{
+    HI_INFOFRAME_TYPE_AVI,          /**<HDMI AVI InfoFrame type defintion*//**<CNcomment:HDMI AVI InfoFrame  */
+    HI_INFOFRAME_TYPE_SPD,          /**<HDMI SPD InfoFrame type defintion*//**<CNcomment:HDMI SPD InfoFrame  */
+    HI_INFOFRAME_TYPE_AUDIO,        /**<HDMI AUDIO InfoFrame type defintion*//**<CNcomment:HDMI AUDIO InfoFrame  */
+    HI_INFOFRAME_TYPE_MPEG,         /**<HDMI MPEG InfoFrame type defintion*//**<CNcomment:HDMI MPEG InfoFrame  */
+    HI_INFOFRAME_TYPE_VENDORSPEC,   /**<HDMI Specific InfoFrame type defintion*//**<CNcomment:HDMI Vendor Specific InfoFrame  */
+    HI_INFOFRAME_TYPE_BUTT
+}HI_UNF_HDMI_INFOFRAME_TYPE_E;
+
+/**HDMI AVI InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI AVI , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AVI_INFOFRAME_VER2_S
+{
+    HI_UNF_ENC_FMT_E               enTimingMode;            /**<AVI video timing format*//**<CNcomment:AVItiming */
+    HI_UNF_HDMI_VIDEO_MODE_E       enOutputType;            /**<AVI video output color space*//**<CNcomment:AVI */
+    HI_BOOL                        bActive_Infor_Present;   /**<AVI video Active_Infor_Present flag*//**<CNcomment:AVIActive_Infor_Present */
+    HI_UNF_HDMI_BARINFO_E          enBarInfo;               /**<AVI video BarInfo type*//**<CNcomment:AVIBarInfo */
+    HI_UNF_HDMI_SCANINFO_E         enScanInfo;              /**<AVI video ScanInfo type*//**<CNcomment:AVIScanInfo */
+    HI_UNF_HDMI_COLORSPACE_E       enColorimetry;           /**<AVI video Colorimetry type*//**<CNcomment:AVIColorimetry */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enAspectRatio;           /**<AVI video AspectRatio type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enActiveAspectRatio;     /**<AVI video Active AspectRatio type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_PICTURE_SCALING_E  enPictureScaling;        /**<AVI video picture scaling type*//**<CNcomment:AVIscaling */
+    HI_UNF_HDMI_RGB_QUAN_RAGE_E    enRGBQuantization;       /**<AVI video RGB Quantization*//**<CNcomment:AVIRGB */
+    HI_BOOL                        bIsITContent;            /**<AVI video ITContent flag*//**<CNcomment:AVIITcontent */
+    HI_U32                         u32PixelRepetition;      /**<AVI video Pixel Repetition flag*//**<CNcomment:AVI */
+
+    HI_UNF_HDMI_CONTENT_TYPE_E     enContentType;           /**<AVI video content type*//**<CNcomment:AVI */
+    HI_UNF_HDMI_YCC_QUAN_RAGE_E    enYCCQuantization;       /**<AVI video YCC Quantization*//**CNcomment:*< AVIYCC */
+
+    HI_U32                         u32LineNEndofTopBar;     /**<AVI video EndofTopBar coordinate,defualt:0 *//**<CNcomment:AVIEndofTopBar0 */
+    HI_U32                         u32LineNStartofBotBar;   /**<AVI video StartofBotBar coordinate,defualt:0*//**<CNcomment:AVIStartofBotBar0 */
+    HI_U32                         u32PixelNEndofLeftBar;   /**<AVI video EndofLeft coordinate,defualt:0*//**<CNcomment:AVIEndofLeft0 */
+    HI_U32                         u32PixelNStartofRightBar;/**<AVI video StartofRightBar coordinate,defualt:0*//**<CNcomment:AVIStartofRightBar0 */
+}HI_UNF_HDMI_AVI_INFOFRAME_VER2_S;
+
+/**HDMI AUDIO InfoFrame parameter struct ,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AUD_INFOFRAME_VER1_S
+{
+    HI_U32                            u32ChannelCount;          /**<audio frequency channel count*//**<CNcomment:  */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E   enCodingType;             /**<audio frequency coding type,default 0;Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32SampleSize;            /**<audio frequency sample size,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32SamplingFrequency;     /**<audio frequency sampling frequency ,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32ChannelAlloc;          /**<audio frequency channel allocable ,default 0,Refer to Stream Header*//**<CNcomment: 0Refer to Stream Header */
+    HI_U32                            u32LevelShift;            /**<audio frequency Levelshift ,default 0,Refer to Stream Header*//**<CNcomment: Levelshift0Refer to Stream Header */
+    HI_BOOL                           u32DownmixInhibit;        /**<audio frequency DownmixInhibit ,default 0,Refer to Stream Header*//**<CNcomment: DownmixInhibit0Refer to Stream Header */
+}HI_UNF_HDMI_AUD_INFOFRAME_VER1_S;
+
+/**HDMI SPD InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI SPD , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_SPD_INFOFRAME_S
+{
+    HI_U8                          u8VendorName[8];          /**<vendor name*//**<CNcomment: */
+    HI_U8                          u8ProductDescription[16]; /**<product Description*//**<CNcomment: */
+    HI_U8                          u8SrcDevInfo;             /**<Source Device Information  *//**<CNcomment: */
+}HI_UNF_HDMI_SPD_INFOFRAME_S;
+
+/**HDMI Source HDMI MPEG InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI MPEG , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_MPEGSOURCE_INFOFRAME_S
+{
+    HI_U32                         u32MPEGBitRate;           /**<MPEG bit Rate*//**<CNcomment:MPEG */
+    HI_BOOL                        bIsFieldRepeated;         /**<FieldRepeater flag*//**<CNcomment:FieldRepeater */
+}HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S;
+
+/**HDMI Vendor Specific InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI VSIF  , EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_VENDORSPEC_INFOFRAME_S
+{
+    HI_U32                         u32RegistrationId;       /**<Registration Id*//**<CNcomment:ID */
+}HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S;
+
+/**HDMI InfoFrame unit struct*/
+/**CNcomment: HDMI  */
+typedef union hiUNF_HDMI_INFOFRAME_UNIT_U
+{
+    HI_UNF_HDMI_AVI_INFOFRAME_VER2_S   stAVIInfoFrame;      /**<AVI FrameInfo*//**<CNcomment:AVI */
+    HI_UNF_HDMI_AUD_INFOFRAME_VER1_S   stAUDInfoFrame;      /**<Audio FrameInfo*//**<CNcomment:AUD */
+    HI_UNF_HDMI_SPD_INFOFRAME_S        stSPDInfoFrame;      /**<SPD FrameInfo*//**<CNcomment:SPD */
+    HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S stMPEGSourceInfoFrame;/**<MPEGSource FrameInfo*//**<CNcomment:MPEGSource */
+    HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S stVendorSpecInfoFrame;/**<VS FrameInfo*//**<CNcomment:VS */
+}HI_UNF_HMDI_INFORFRAME_UNIT_U;
+
+/**HDMI InfoFrame struct */
+/**CNcomment: HDMI  */
+typedef struct hiUNF_HDMI_INFOFRAME_S
+{
+    HI_UNF_HDMI_INFOFRAME_TYPE_E    enInfoFrameType;  /**<InfoFrame type*//**CNcomment:<InfoFrame */
+    HI_UNF_HMDI_INFORFRAME_UNIT_U   unInforUnit;      /**<InfoFrame unit data*//**CNcomment:<InfoFrame */
+}HI_UNF_HDMI_INFOFRAME_S;
+
+
+/* CEC */
+/** CEC interrelated Opcode:Please refer to CEC 15 Message Descriptions */
+/** CNcomment: CEC  */
+
+/* General Protocol messages */
+
+/**"Feature Abort" Used as a response to indicate that the device does not support the requested message type, or that it cannot execute it at the present time. */
+/**CNcomment:"Feature Abort"*/
+#define CEC_OPCODE_FEATURE_ABORT                  0X00
+/**"Abort" Message This message is reserved for testing purposes.*/
+/**CNcomment:"Abort"*/
+#define CEC_OPCODE_ABORT_MESSAGE                  0XFF
+
+/* One Touch Play Feature*/
+
+/**"Active Source" Used by a new source to indicate that it has started to transmit a stream OR used in response to a "Request Active Source"*/
+/**CNcomment:"Active Source""Request Active Source"*/
+#define CEC_OPCODE_ACTIVE_SOURCE                  0X82
+/**"Image View On" Sent by a source device to the TV whenever it enters the active state (alternatively it may send "Text View On").*/
+/**CNcomment:TV"Image View On"*/
+#define CEC_OPCODE_IMAGE_VIEW_ON                  0X04
+/**"Text View On" As "Image View On", but should also remove any text, menus and PIP windows from the TV's display.*/
+/**CNcomment:"Text View On" "Image View On"TV*/
+#define CEC_OPCODE_TEXT_VIEW_ON                   0X0D
+
+/* Routing Control Feature*/
+
+/**"Inactive Source" Used by the currently active source to inform the TV that it has no video to be presented to the user, or is going into standby as the result of a local user command on the device. */
+/**CNcomment: "Inactive Source"*/
+#define CEC_OPCODE_INACTIVE_SOURCE                0X9D
+/**"Request Active Source" Used by a new device to discover the status of the system.*/
+/**CNcomment: "Request Active Source"*/
+#define CEC_OPCODE_REQUEST_ACTIVE_SOURCE          0X85
+/**"Routing Change" Sent by a CEC Switch when it is manually switched to inform all other devices on the network that the active route below the switch has changed. */
+/**CNcomment: CEC "Routing Change"*/
+#define CEC_OPCODE_ROUTING_CHANGE                 0X80
+/**"Routing Information" Sent by a CEC Switch to indicate the active route below the switch.*/
+/**CNcomment: CEC"Routing Information"*/
+#define CEC_OPCODE_ROUTING_INFORMATION            0X81
+/**"Set Stream Path" Used by the TV to request a streaming path from the specified physical address.*/
+/**CNcomment: TV */
+#define CEC_OPCODE_SET_STREAM_PATH                0X86
+
+/* Standby Feature*/
+
+/**"Standby" Switches one or all devices into standby mode. Can be used as a broadcast message or be addressed to a specific device.See section CEC 13.3 for important notes on the use of this message */
+/**CNcomment: "Standby"*/
+#define CEC_OPCODE_STANDBY                        0X36
+
+/* One Touch Record Feature*/
+
+/**"Record Off" Requests a device to stop a recording. */
+/**CNcomment: "Record Off"*/
+#define CEC_OPCODE_RECORD_OFF                     0X0B
+/**"Record On" Attempt to record the specified source. */
+/**CNcomment: "Record On"*/
+#define CEC_OPCODE_RECORD_ON                      0X09
+/**"Record Status" Used by a Recording Device to inform the initiator of the message "Record On" about its status. */
+/**CNcomment: "Record Status""Record On"*/
+#define CEC_OPCODE_RECORD_STATUS                  0X0A
+/**"Record TV Screen" Request by the Recording Device to record the presently displayed source. */
+/**CNcomment: "Record TV Screen"*/
+#define CEC_OPCODE_RECORD_TV_SCREEN               0X0F
+
+/* Timer Programming Feature*/
+
+/**"Clear Analogue Timer" Used to clear an Analogue timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_ANALOGUE_TIMER           0X33
+/**"Clear Digital Timer" Used to clear a Digital timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_DIGITAL_TIMER            0X99
+/**"Clear External Timer" Used to clear an External timer block of a device. */
+/**CNcomment: */
+#define CEC_OPCODE_CLEAR_EXTERNAL_TIMER           0XA1
+/**"Set Analogue Timer" Used to set a single timer block on an Analogue Recording Device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_ANALOGUE_TIMER             0X34
+/**"Set Digital Timer" Used to set a single timer block on a Digital Recording Device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_DIGITAL_TIMER              0X97
+/**"Set External Timer" Used to set a single timer block to record from an external device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_EXTERNAL_TIMER             0XA2
+/**"Set Timer Program Title" Used to set the name of a program associated with a timer block. Sent directly after sending a "Set Analogue Timer" or "Set Digital Timer" message. The name is then associated with that timer block. */
+/**CNcomment: "Set Analogue Timer" "Set Digital Timer" */
+#define CEC_OPCODE_SET_TIMER_PROGRAM_TITLE        0X67
+/**"Timer Cleared Status" Used to give the status of a "Clear Analogue Timer", "Clear Digital Timer" or "Clear External Timer" message. */
+/**CNcomment: "Timer Cleared Status""Clear Analogue Timer""Clear Digital Timer""Clear External Timer"*/
+#define CEC_OPCODE_TIMER_CLEARED_STATUS           0X43
+/**"Timer Status" Used to send timer status to the initiator of a "Set Timer" message. */
+/**CNcomment: "Timer Status"Set Timer"*/
+#define CEC_OPCODE_TIMER_STATUS                   0X35
+
+/* System Information Feature*/
+
+/**"CEC Version" Used to indicate the supported CEC version, in response to a "Get CEC Version" */
+/**CNcomment: "CEC Version"CEC"Get CEC Version"*/
+#define CEC_OPCODE_CEC_VERSION                    0X9E
+/**"Get CEC Version" Used by a device to enquire which version of CEC the target supports */
+/**CNcomment: "Get CEC Version"CEC*/
+#define CEC_OPCODE_GET_CEC_VERSION                0X9F
+/**"Give Physical Address" A request to a device to return its physical address. */
+/**CNcomment: */
+#define CEC_OPCODE_GIVE_PHYSICAL_ADDRESS          0X83
+/**"Report Physical Address" Used to inform all other devices of the mapping between physical and logical address of the initiator.*/
+/**CNcomment: */
+#define CEC_OPCODE_REPORT_PHYSICAL_ADDRESS        0X84
+/**"Get Menu Language" Sent by a device capable of character generation (for OSD and Menus) to a TV in order to discover the currently selected Menu language.Also used by a TV during installation to discover the currently set menu language of other devices.*/
+/**CNcomment: "Get Menu Language"TvTV*/
+#define CEC_OPCODE_GET_MENU_LANGUAGE              0X91
+/**"Set Menu Language" Used by a TV or another device to indicate the menu language. */
+/**CNcomment: "Set Menu Language"Tv*/
+#define CEC_OPCODE_SET_MENU_LANGUAGE              0X32
+
+/*  Deck Control Feature*/
+
+/**"Deck Control" Used to control a device's media functions. */
+/**CNcomment: "Deck control"*/
+#define CEC_OPCODE_DECK_CONTROL                   0X42
+/**"Deck Status" Used to provide a deck's status to the initiator of the "Give Deck Status" message. */
+/**CNcomment: "Deck Status ""Give Deck Status"Deck*/
+#define CEC_OPCODE_DECK_STATUS                    0X1B
+/**"Give Deck Status" Used to request the status of a device, regardless of whether or not it is the current active source. */
+/**CNcomment: "Give Deck Status"*/
+#define CEC_OPCODE_GIVE_DECK_STATUS               0X1A
+/**"Play" Used to control the playback behaviour of a source device. */
+/**CNcomment: "Play"*/
+#define CEC_OPCODE_PLAY                           0X41
+
+/* Tuner Control Feature*/
+
+/**"Give Tuner Device Status" Used to request the status of a tuner device. */
+/**CNcomment: "Give Tuner Device Status"*/
+#define CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS       0X08
+/**"Select Analogue Service" Directly selects an Analogue TV service */
+/**CNcomment: "Select Analogue Service"*/
+#define CEC_OPCODE_SELECT_ANALOGUE_SERVICE        0X92
+/**"Select Digital Service" Directly selects a Digital TV, Radio or Data Broadcast Service */
+/**CNcomment: "Select Digital Service"*/
+#define CEC_OPCODE_SELECT_DIGITAL_SERVICE         0X93
+/**"Tuner Device Status" Use by a tuner device to provide its status to the initiator of the "Give Tuner Device Status" message. */
+/**CNcomment: "Tuner Device Status"" Give Tuner Device Status"*/
+#define CEC_OPCODE_TUNER_DEVICE_STATUS            0X07
+/**"Tuner Step Decrement" Used to tune to next lowest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"*/
+#define CEC_OPCODE_TUNER_STEP_DECREMENT           0X06
+/**"Tuner Step Increment" Used to tune to next highest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"*/
+#define CEC_OPCODE_TUNER_STEP_INCREMENT           0X05
+
+/* Vendor Specific Command*/
+
+/**"Device Vendor ID" Reports the vendor ID of this device. */
+/**CNcomment: "Device Vendor ID"ID*/
+#define CEC_OPCODE_DEVICE_VENDOR_ID               0X87
+/**"Give Device Vendor ID" Requests the Vendor ID from a device. */
+/**CNcomment: "Give Device Vendor ID"ID*/
+#define CEC_OPCODE_GIVE_DEVICE_VENDOR_ID          0X8C
+/**"Vendor Command" Allows vendor specific commands to be sent between two devices. */
+/**CNcomment: "Vendor Command"*/
+#define CEC_OPCODE_VENDOR_COMMAND                 0X89
+/**"Vendor Command With ID" Allows vendor specific commands to be sent between two devices or broadcast. */
+/**CNcomment: "Vendor Command With ID"*/
+#define CEC_OPCODE_VENDOR_COMMAND_WITH_ID         0XA0
+/**"Vendor Remote Button Down" Indicates that a remote control button has been depressed. */
+/**CNcomment: "Vendor Remote Button Down"*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN      0X8A
+/**"Vendor Remote Button Up" Indicates that a remote control button (the last button pressed indicated by the Vendor Remote Button Down message) has been released. */
+/**CNcomment: "Vendor Remote Button Up" "Vendor Remote Button Down"*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP        0X8B
+
+/* OSD Display Feature*/
+
+/**"Set OSD String" Used to send a text message to output on a TV. */
+/**CNcomment: "Set OSD String"*/
+#define CEC_OPCODE_SET_OSD_STRING                 0X64
+/**"Give OSD Name" Used to request the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment: */
+#define CEC_OPCODE_GIVE_OSD_NAME                  0X46
+/**"Set OSD Name" Used to set the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment: */
+#define CEC_OPCODE_SET_OSD_NAME                   0X47
+
+/* Device Menu Control Feature*/
+
+/**"Menu Request" A request from the TV for a device to show/remove a menu or to query if a device is currently showing a menu. */
+/**CNcomment: "Menu Request"/*/
+#define CEC_OPCODE_MENU_REQUEST                   0X8D
+/**"Menu Status" Used to indicate to the TV that the device is showing/has removed a menu and requests the remote control keys to be passed though. */
+/**CNcomment: "Menu Status"/*/
+#define CEC_OPCODE_MENU_STATUS                    0X8E
+/**"User Control Pressed" Used to indicate that the user pressed a remote control button or switched from one remote control button to another. */
+/**CNcomment: "User Control Pressed".*/
+#define CEC_OPCODE_USER_CONTROL_PRESSED           0X44
+/**"User Control Released" Indicates that user released a remote control button (the last one indicated by the "User Control Pressed" message) */
+/**CNcomment: "User Control Released""User Control Released".*/
+#define CEC_OPCODE_USER_CONTROL_RELEASED          0X45
+
+/* Power Status Feature*/
+
+/**"Give Device Power Status" Used to determine the current power status of a target device */
+/**CNcomment: "Give Device Power Status"*/
+#define CEC_OPCODE_GIVE_DEVICE_POWER_STATUS       0X8F
+/**"Report Power Status" Used to inform a requesting device of the current power status */
+/**CNcomment: "Report Power Status"*/
+#define CEC_OPCODE_REPORT_POWER_STATUS            0X90
+
+/* System Audio Control Feature*/
+
+/**"Give Audio Status" Requests an amplifier to send its volume and mute status */
+/**CNcomment: "Give Audio Status"*/
+#define CEC_OPCODE_GIVE_AUDIO_STATUS              0X71
+/**"Give System Audio Mode Status" Requests the status of the System Audio Mode */
+/**CNcomment: "Give System Audio Mode Status"*/
+#define CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS  0x7D
+/**"Report Audio Status" Reports an amplifier's volume and mute status */
+/**CNcomment: "Report Audio Status"*/
+#define CEC_OPCODE_REPORT_AUDIO_STATUS            0X7A
+/**"Set System Audio Mode" Turns the System Audio Mode On or Off. */
+/**CNcomment: "Set System Audio Mode"/*/
+#define CEC_OPCODE_SET_SYSTEM_AUDIO_MODE          0X72
+/**"System Audio Mode Request" A device implementing System Audio Control and which has volume control RC buttons (eg TV or STB) requests to use System Audio Mode to the amplifier */
+/**CNcomment: (stbtv) System Audio Mode*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST      0X70
+/**"System Audio Mode Status" Reports the current status of the System Audio Mode */
+/**CNcomment: "System Audio Mode Status"*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS       0X7E
+
+/* Audio Rate Control Feature*/
+
+/**"Set Audio Rate" Used to control audio rate from Source Device. */
+/**CNcomment: "Set Audio Rate"*/
+#define CEC_OPCODE_SET_AUDIO_RATE                 0X9A
+
+/**POLL message have no opcode, So, we just use this value */
+/**CNcomment: "POLL"*/
+#define CEC_OPCODE_POLLING_MESSAGE                0XFE
+
+/**HDMI CEC logical address,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef enum hiUNF_CEC_LOGICALADD_S
+{
+    HI_UNF_CEC_LOGICALADD_TV               = 0X00, /**<TV*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_1      = 0X01, /**<Record device 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_2      = 0X02, /**<Record device 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_1          = 0X03, /**<Tuner 1*//**CNcomment:< 1*/
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_1        = 0X04, /**<play device 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_AUDIOSYSTEM      = 0X05, /**<audio system*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_TUNER_2          = 0X06, /**<tuner 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_3          = 0X07, /**<tuner 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_2        = 0X08, /**<play device 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_3      = 0X09, /**<Record device 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_TUNER_4          = 0X0A, /**<tuner 4*//**CNcomment:< 4 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_3        = 0X0B, /**<play device 3*//**CNcomment:< 3 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_1       = 0X0C, /**<reserved 1*//**CNcomment:< 1 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_2       = 0X0D, /**<reserved 2*//**CNcomment:< 2 */
+    HI_UNF_CEC_LOGICALADD_SPECIALUSE       = 0X0E, /**<special use*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_BROADCAST        = 0X0F, /**<broadcast*//**CNcomment:< */
+    HI_UNF_CEC_LOGICALADD_BUTT
+}HI_UNF_CEC_LOGICALADD_S;
+
+/**HDMI CEC command type,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef enum hiUNF_CEC_CMDTYPE_E
+{
+    HI_UNF_CEC_STRUCTCOMMAND,                    /**<CEC struct command*//**<CNcomment:CEC  */
+    HI_UNF_CEC_RAWCOMMAND,                       /**<CEC raw command*//**<CNcomment:CEC  */
+    HI_UNF_CEC_BUTT
+}HI_UNF_CEC_CMDTYPE_E;
+
+/**HDMI CEC Raw Data struct,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CECHDMI 1.4a */
+typedef struct hiUNF_CEC_RAWDATA_S
+{
+    HI_U8                              u8Length;  /**<CEC raw data lengh*//**<CNcomment:cec  */
+    HI_U8                              u8Data[15];     /**<CEC raw data*//**<CNcomment:CEC  */
+}HI_UNF_CEC_RAWDATA_S;
+
+/**HDMI CEC user Interface Command Opcode,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC HDMI 1.4a */
+typedef enum hiUNF_CEC_UICMD_E
+{
+    HI_UNF_CEC_UICMD_SELECT                      = 0x00,
+    HI_UNF_CEC_UICMD_UP                          = 0x01,
+    HI_UNF_CEC_UICMD_DOWN                        = 0x02,
+    HI_UNF_CEC_UICMD_LEFT                        = 0x03,
+    HI_UNF_CEC_UICMD_RIGHT                       = 0x04,
+    HI_UNF_CEC_UICMD_RIGHT_UP                    = 0x05,
+    HI_UNF_CEC_UICMD_RIGHT_DOWN                  = 0x06,
+    HI_UNF_CEC_UICMD_LEFT_UP                     = 0x07,
+    HI_UNF_CEC_UICMD_LEFT_DOWN                   = 0x08,
+    HI_UNF_CEC_UICMD_ROOT_MENU                   = 0x09,
+    HI_UNF_CEC_UICMD_SETUP_MENU                  = 0x0A,
+    HI_UNF_CEC_UICMD_CONTENTS_MENU               = 0x0B,
+    HI_UNF_CEC_UICMD_FAVORITE_MENU               = 0x0C,
+    HI_UNF_CEC_UICMD_EXIT                        = 0x0D,
+    HI_UNF_CEC_UICMD_NUM_0                       = 0x20,
+    HI_UNF_CEC_UICMD_NUM_1                       = 0x21,
+    HI_UNF_CEC_UICMD_NUM_2                       = 0x22,
+    HI_UNF_CEC_UICMD_NUM_3                       = 0x23,
+    HI_UNF_CEC_UICMD_NUM_4                       = 0x24,
+    HI_UNF_CEC_UICMD_NUM_5                       = 0x25,
+    HI_UNF_CEC_UICMD_NUM_6                       = 0x26,
+    HI_UNF_CEC_UICMD_NUM_7                       = 0x27,
+    HI_UNF_CEC_UICMD_NUM_8                       = 0x28,
+    HI_UNF_CEC_UICMD_NUM_9                       = 0x29,
+    HI_UNF_CEC_UICMD_DOT                         = 0x2A,
+    HI_UNF_CEC_UICMD_ENTER                       = 0x2B,
+    HI_UNF_CEC_UICMD_CLEAR                       = 0x2C,
+    HI_UNF_CEC_UICMD_NEXT_FAVORITE               = 0x2F,
+    HI_UNF_CEC_UICMD_CHANNEL_UP                  = 0x30,
+    HI_UNF_CEC_UICMD_CHANNEL_DOWN                = 0x31,
+    HI_UNF_CEC_UICMD_PREVIOUS_CHANNEL            = 0x32,
+    HI_UNF_CEC_UICMD_SOUND_SELECT                = 0x33,
+    HI_UNF_CEC_UICMD_INPUT_SELECT                = 0x34,
+    HI_UNF_CEC_UICMD_DISPLAY_INFORMATION         = 0x35,
+    HI_UNF_CEC_UICMD_HELP                        = 0x36,
+    HI_UNF_CEC_UICMD_PAGE_UP                     = 0x37,
+    HI_UNF_CEC_UICMD_PAGE_DOWN                   = 0x38,
+    HI_UNF_CEC_UICMD_POWER                       = 0x40,
+    HI_UNF_CEC_UICMD_VOLUME_UP                   = 0x41,
+    HI_UNF_CEC_UICMD_VOLUME_DOWN                 = 0x42,
+    HI_UNF_CEC_UICMD_MUTE                        = 0x43,
+    HI_UNF_CEC_UICMD_PLAY                        = 0x44,
+    HI_UNF_CEC_UICMD_STOP                        = 0x45,
+    HI_UNF_CEC_UICMD_PAUSE                       = 0x46,
+    HI_UNF_CEC_UICMD_RECORD                      = 0x47,
+    HI_UNF_CEC_UICMD_REWIND                      = 0x48,
+    HI_UNF_CEC_UICMD_FAST_FORWARD                = 0x49,
+    HI_UNF_CEC_UICMD_EJECT                       = 0x4A,
+    HI_UNF_CEC_UICMD_FORWARD                     = 0x4B,
+    HI_UNF_CEC_UICMD_BACKWARD                    = 0x4C,
+    HI_UNF_CEC_UICMD_STOP_RECORD                 = 0x4D,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD                = 0x4E,
+    HI_UNF_CEC_UICMD_ANGLE                       = 0x50,
+    HI_UNF_CEC_UICMD_SUBPICTURE                  = 0x51,
+    HI_UNF_CEC_UICMD_VIDEO_ON_DEMAND             = 0x52,
+    HI_UNF_CEC_UICMD_ELECTRONIC_PROGRAM_GUIDE    = 0x53,
+    HI_UNF_CEC_UICMD_TIMER_PROGRAMMING           = 0x54,
+    HI_UNF_CEC_UICMD_INITIAL_CONFIGURATION       = 0x55,
+    HI_UNF_CEC_UICMD_PLAY_FUNCTION               = 0x60,
+    HI_UNF_CEC_UICMD_PAUSE_PLAY_FUNCTION         = 0x61,
+    HI_UNF_CEC_UICMD_RECORD_FUNCTION             = 0x62,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD_FUNCTION       = 0x63,
+    HI_UNF_CEC_UICMD_STOP_FUNCTION               = 0x64,
+    HI_UNF_CEC_UICMD_MUTE_FUNCTION               = 0x65,
+    HI_UNF_CEC_UICMD_RESTORE_VOLUME_FUNCTION     = 0x66,
+    HI_UNF_CEC_UICMD_TUNE_FUNCTION               = 0x67,
+    HI_UNF_CEC_UICMD_SELECT_MEDIA_FUNCTION       = 0x68,
+    HI_UNF_CEC_UICMD_SELECT_AV_INPUT_FUNCTION    = 0x69,
+    HI_UNF_CEC_UICMD_SELECT_AUDIO_INPUT_FUNCTION = 0x6A,
+    HI_UNF_CEC_UICMD_POWER_TOGGLE_FUNCTION       = 0x6B,
+    HI_UNF_CEC_UICMD_POWER_OFF_FUNCTION          = 0x6C,
+    HI_UNF_CEC_UICMD_POWER_ON_FUNCTION           = 0x6D,
+    HI_UNF_CEC_UICMD_F1_BLUE                     = 0x71,
+    HI_UNF_CEC_UICMD_F2_RED                      = 0x72,
+    HI_UNF_CEC_UICMD_F3_GREEN                    = 0x73,
+    HI_UNF_CEC_UICMD_F4_YELLOW                   = 0x74,
+    HI_UNF_CEC_UICMD_F5                          = 0x75,
+    HI_UNF_CEC_UICMD_DATA                        = 0x76
+}HI_UNF_CEC_UICMD_E;
+
+/**HDMI CEC operand command,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC HDMI 1.4a */
+/**member stUIOpcode:
+\ member stUIOpcode not support when "CEC OPERAND FORCE RAWDATA" set Y on make menuconfig options
+\ or just support when u8Opcode is <User Control Pressed>
+\ CNcomment:
+\ make menuconfigCEC OPERAND FORCE RAWDATA, stUIOpcode;
+\ u8Opcode<User Control Pressed>stUIOpcode
+*/
+typedef union hiUNF_CEC_Operand_t
+{
+    HI_UNF_CEC_RAWDATA_S               stRawData;   /**<CEC raw date*//**<CNcomment:CEC  */
+    HI_UNF_CEC_UICMD_E                 stUIOpcode;  /**<CEC user interface command*//**<CNcomment:CEC */
+}HI_UNF_CEC_Operand_t;
+
+/**HDMI CEC struct command*/
+/**CNcomment: HDMI CEC  */
+typedef struct hiUNF_HDMI_CEC_CMD_S
+{
+    HI_UNF_CEC_LOGICALADD_S  enSrcAdd;     /**<logical address of source *//**<CNcomment: */
+    HI_UNF_CEC_LOGICALADD_S  enDstAdd;     /**<logical address of destination*//**<CNcomment: */
+    HI_U8                    u8Opcode;     /**<opration code*//**<CNcomment:*/
+    HI_UNF_CEC_Operand_t     unOperand;    /**<operand*//**<CNcomment:*/
+}HI_UNF_HDMI_CEC_CMD_S;
+
+/**HDMI CEC status struct*/
+/**CNcomment: HDMI CEC  */
+typedef struct hiUNF_HDMI_CEC_STATUS_S
+{
+    HI_BOOL bEnable;                                 /**<the flag of CEC work,HI_TRUE:CEC work enable,HI_FALSE:CEC no work ,other parameter no effect*/ /**<CNcomment:CEC HI_TRUE,CECHI_FASLE,CEC */
+    HI_U8   u8PhysicalAddr[4];                       /**<CEC physics address*/ /**<CNcomment:CEC  */
+    HI_U8   u8LogicalAddr;                           /**<CEC logic address,defualt 0x03*//**<CNcomment:CEC 0x03. */
+    HI_U8   u8Network[HI_UNF_CEC_LOGICALADD_BUTT];   /**<CEC network struct ,1:the device can response CEC command*/ /**<CNcomment:CEC 1CEC */
+}HI_UNF_HDMI_CEC_STATUS_S;
+
+/**HDMI CEC Regcallback param struct */
+/**CNcomment: HDMI CEC  */
+typedef HI_VOID (*HI_UNF_HDMI_CECCALLBACK)(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S *pstCECCmd, HI_VOID *pData);
+
+
+/**HDMI Callback Struct*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_CECCALLBACK_FUNC_S
+{
+    HI_UNF_HDMI_CECCALLBACK pfnCECCallBack;       /**<callback function pointer*//**<CNcomment:*/
+    HI_VOID                *pPrivateData;         /**<callback funtion param*//**<CNcomment:*/
+ }HI_UNF_HDMI_CECCALLBACK_EXT_S;
+
+
+
+/**HDMI HDCP key struct*/
+/**CNcomment: HDMI HDCP  */
+typedef struct hiUNF_HDMI_LOAD_KEY_S
+{
+    HI_U8 *pu8InputEncryptedKey;            /**<Encrypted key pointer *//**<CNcomment: */
+    HI_U32 u32KeyLength;                    /**<Encrypted key length*//**<CNcomment: */
+}HI_UNF_HDMI_LOAD_KEY_S;
+
+/**HDMI HDCP SRM(system renewability messages) struct*/
+/**CNcomment: HDMI HDCP SRM() */
+typedef struct hiUNF_HDMI_SRM_S
+{
+    HI_U8 *pu8SrmData;              /**<SRM raw data *//**<CNcomment:SRM  */
+    HI_U32 u32SrmLen;               /**<Length of SRM *//**<CNcomment: */
+} HI_UNF_HDMI_SRM_S;
+
+
+/**< HDCP-capability struct *//**<CNcomment:HDCP  */
+typedef struct{
+    HI_BOOL        bHdcp14Support;  /**<sink support HDCP1.4 *//**<CNcomment:sinkHDCP1.4 */
+    HI_BOOL        bHdcp22Support;  /**<sink support HDCP2.2 *//**<CNcomment:sinkHDCP2.2 */
+}HI_UNF_HDMI_HDCP_CAP_S;
+
+/**HDMI HDCP eanble parameter*/
+/**CNcomment: HDMI HDCP  */
+typedef struct hiUNF_HDMI_HDCP_PARAM_S{
+    HI_BOOL                 bHdcpEnable;    /**<set HI_TRUE to enable HDCP,set HI_FALSE to disable HDCP. *//**<CNcomment:HI_TRUEHDCP;HI_FALSEHDCP*/
+    HI_UNF_HDMI_HDCP_MODE_E enHdcpMode;     /**<HDCP mode of authentication,suggest that according to HDCP-capability. *//**<CNcomment:HDCPsink*/
+
+}HI_UNF_HDMI_HDCP_PARAM_S;
+
+/**HDMI HDCP error code*/
+/**CNcomment: HDMI HDCP*/
+typedef enum hiUNF_HDMI_HDCP_ERR_E
+{
+    HI_UNF_HDMI_HDCP_ERR_UNDO = 0x00,           /**< undo hdcp. *//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_NONE,                  /**< no error. *//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_UNHPD,                 /**< eanble HDCP when HPD is low. *//**<CNcomment:HPD*/
+    HI_UNF_HDMI_HDCP_ERR_NO_TIMMING,            /**< no timming.Enable HDCP before HDMI start. *//**<CNcomment:HDMIHDCP(HDMI )*/
+    HI_UNF_HDMI_HDCP_ERR_LOADKEY_FAIL,          /**< no loadkey.Only for HDCP1.4 *//**<CNcomment:HDCP1.4 key*/
+    HI_UNF_HDMI_HDCP_ERR_ON_REVOCATION_LIST,    /**< recieve ID/BKSV list on revocation list.*//**<CNcomment:()DCP*/
+    HI_UNF_HDMI_HDCP_ERR_RECEIVER_FAIL,         /**< receiver respond error.*//**<CNcomment:*/
+    HI_UNF_HDMI_HDCP_ERR_MAXDEV_EXCEEDED,       /**< more than 127 downstream devices,  or the capacity of the KSV Fifo, are attached.*//**<CNcomment:127KSV Fifo*/
+    HI_UNF_HDMI_HDCP_ERR_MAXCASCADE_EXCEEDED,   /**< more than seven levels of video repeater have been cascaded together*//**<CNcomment:7*/
+    HI_UNF_HDMI_HDCP_ERR_REPEATER_FAIL,         /**< repeater respond error.*//**<CNcomment:repeater*/
+
+}HI_UNF_HDMI_HDCP_ERR_E;
+
+/**HDMI HDCP status */
+/**CNcomment: HDMI HDCP*/
+typedef struct hiUNF_HDCP_STATUS_S{
+    HI_UNF_HDMI_HDCP_VERSION_E      enHdcpVersion;  /**< HDCP current version.*//**<CNcomment:HDCP*/
+    HI_BOOL                         bHdcpEnable;    /**< HDCP enable status.*//**<CNcomment:HDCP*/
+    HI_UNF_HDMI_HDCP_ERR_E          enHdcpErrCode;  /**< HDCP error code.*//**<CNcomment:HDCP */
+}HI_UNF_HDCP_STATUS_S;
+
+
+/**HDMI Delay struct*/
+/**CNcomment: HDMI  */
+typedef struct hiUNF_HDMI_DELAY_S
+{
+    HI_U32  u32MuteDelay;           /**<delay for avmute *//**<CNcomment:avmute */
+    HI_U32  u32FmtDelay;            /**<delay for setformat *//**<CNcomment: */
+    HI_BOOL bForceFmtDelay;         /**<force setformat delay mode *//**<CNcomment: */
+    HI_BOOL bForceMuteDelay;        /**<force avmute delay mode *//**<CNcomment:mute */
+}HI_UNF_HDMI_DELAY_S;
+
+/**HDMI Resume start flag*/
+/**CNcomment: HDMI */
+typedef enum hiUNF_HDMI_RESUME_START_E
+{
+    HI_UNF_HDMI_RESUME_AND_START = 0,   /**<HDMI starts when the system is resumed*//**<CNcomment:ResumeHDMIstart*/
+    HI_UNF_HDMI_RESUME_NOT_START        /**<HDMI not start when the system is resumed*//**<CNcomment:ResumeHDMIstart*/
+} HI_UNF_HDMI_RESUME_START_E;
+
+/**HDMI advanced attribute struct*/
+/**CNcomment: HDMI */
+typedef struct hiUNF_HDMI_ADVANCED_ATTR_S
+{
+    HI_UNF_HDMI_RESUME_START_E enResumeStart;
+}HI_UNF_HDMI_ADVANCED_ATTR_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**
+\brief the whole initialization of the hdmi. CNcomment:HDMI CNend
+\attention  this func should be called before vo_init and after disp_init. CNcomment:DISPSetupVOSetup CNend
+\param CNcomment: CNend
+\retval HI_SUCCESS  success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Init(HI_VOID);
+
+
+/**
+\brief deinit the hdmi. CNcomment:HDMI CNend
+\attention  this must be called after vo exited and before disp  exited . CNcomment:VOExitDISPExit CNend
+\param CNcomment: CNend
+\retval HI_SUCCESS      success.CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_DeInit(HI_VOID);
+
+
+/**
+\brief create hdmi device. CNcomment:HDMI CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMI CNend
+\param[in] pstOpenPara  When get GetSinkCapability failed,defalut set sink device to DVI/HDMI mode.CNcomment:(DVI/HDMI) CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Open(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_OPEN_PARA_S *pstOpenPara);
+
+/**
+\brief close the handler created by  HI_UNF_HDMI_Open. CNcomment:HI_UNF_HDMI_Open CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Close(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief get current hdmi status. CNcomment:hdmi CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\param[out] pHdmiStatus hdmi cuttent status. CNcomment:HDMI CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_STATUS_S *pHdmiStatus);
+
+/**
+\brief to get the capability of sink connect to stbbox. CNcomment:HDMI Sink CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[out] pCapability  the capability of the sink .CNcomment:SINK CNend
+\retval HI_SUCCESS       success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi. CNcomment:MPI CNend
+\see ::HI_UNF_EDID_BASE_INFO_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetSinkCapability(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_EDID_BASE_INFO_S *pCapability);
+
+/**
+\brief set the attr of given hdmi interface. CNcomment:HDMI CNend
+\attention the setting will take effect after HI_UNF_HDMI_Start is called.Suggest that HI_UNF_HDMI_Stop before change enDeepColorMode to reduce noisy.
+\param[in] enHdmi      hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstAttr     the attr of given hdmi interface.CNcomment:HDMI CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the current attr of the give hdmi interface. CNcomment:HDMI CNend
+\attention \n
+\param[in] enHdmi hdmi device id.CNcomment: HDMIID CNend
+\param[out] pstAttr     the attr of given hdmi interface. CNcomment:HDMI CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see HI_UNF_HDMI_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the cec working status. CNcomment:CEC CNend
+\attention  user can get the cec working status through this func. CNcomment:CEC\n CNend
+\param[in] enHdmi       hdmi device id.CNcomment:HDMIID CNend
+\param[in] pStatus     get cec working status. CNcomment:CEC  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CECStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_STATUS_S  *pStatus);
+
+
+/**
+\brief send the cec data. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCmd      the cec cmd data.CNcomment:Cec Command  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd);
+
+
+/**
+\brief get the cec data received. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCmd    the cec cmd data. CNcomment:Cec Command  CNend
+\param[in] timeout    timeout for getting cec cmd, unit: 10ms;
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd, HI_U32 timeout);
+
+/**
+\brief register CEC callback function. CNcomment:CEC CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCallback    the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_CECCALLBACK,HI_UNF_HDMI_RegCECCallBackFuncExt\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+/**
+\brief unregister CEC callback function. CNcomment:CEC CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pCECCallback  the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\NOTE:: You should un-register when finished using the CEC_CALLBACK function before HI_UNF_HDMI_DeInit.Associate with HI_UNF_HDMI_RegCECCallBackFunc.CNcomment: CNend
+\see ::HI_UNF_HDMI_CECCALLBACK,HI_UNF_HDMI_UnRegCECCallBackFuncExt\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+
+/**
+\brief register CEC callback function, only use with HI_UNF_HDMI_RegCECCallbackFuncExt. CNcomment:CEC HI_UNF_HDMI_UnRegCECCallBackFunc CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pstCallBackFunc    the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\NOTE:: You can use the interface deliver a private data pointer.But HI_UNF_HDMI_RegCECCallBackFunc can't support.You can select one of them.CNcomment: HI_UNF_HDMI_RegCECCallBackFunc, CNend
+\see ::HI_UNF_HDMI_CECCALLBACK_EXT_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCECCallBackFuncExt(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK_EXT_S *pstCallBackExt);
+
+/**
+\brief unregister CEC callback function. CNcomment:CEC CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] pstCallBackFunc  the cec callback handle. CNcomment: CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\NOTE:: You should un-register when finished using the CEC_CALLBACK function before HI_UNF_HDMI_DeInit.Associate with HI_UNF_HDMI_RegCECCallBackFuncExt.CNcomment: CNend
+\see ::HI_UNF_HDMI_CECCALLBACK_EXT_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCECCallBackFuncExt(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK_EXT_S *pstCallBackExt);
+
+
+/**
+\brief enable the cec func. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Enable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief disable the cec func. CNcomment:CEC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Disable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief  set and send infoframe. CNcomment:InfoFrame CNend
+\attention \n
+\param[in] enHdmi       hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstInfoFrame the inforframe content.CNcomment:InfoFrame CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+/**
+\brief get the infoframe infor. CNcomment:InfoFrame CNend
+\attention \n
+\param[in] enHdmi       hdmi device id. CNcomment:HDMIID CNend
+\param[in] enInfoFrameType the info frame type such as avi or audio or gcp etc. CNcomment:InfoFrame CNend
+\param[out] pstInfoFrame   the inforframe content.CNcomment:InfoFrame CNend
+\retval HI_SUCCESS      success.CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_TYPE_E enInfoFrameType, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+
+
+/**
+\brief  start the hdmi works. CNcomment:HDMI CNend
+\attention \n
+this should be called after HI_UNF_HDMI_SetAttr.
+CNcomment:HDMIHI_UNF_HDMI_SetAttr CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Start(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief stop  the hdmi. CNcomment:hdmi CNend
+\attention \n
+this func should be called  when hdmi plug out.
+CNcomment:HDMIHDMI CNend
+\param[in] enHdmi  hdmi device id. CNcomment:HDMIID CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Stop(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief set the deep color mode. CNcomment:HDMI DeepColor CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMIID CNend
+\param[in] enDeepColor deep color mode,please refer to the HI_UNF_HDMI_DEEP_COLOR_E definiton.CNcomment:DeepColor::HI_UNF_HDMI_DEEP_COLOR_E  CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDeepColor(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DEEP_COLOR_E enDeepColor);
+
+/**
+\brief switch the xvycc on or off. CNcomment:HDMI xvYCC  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] bEnalbe   whether to enable xvycc mode or not .CNcomment:xvYCC CNend
+\retval HI_SUCCESS    success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetxvYCCMode(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bEnalbe);
+
+/**
+\brief switch the mute of av  on or off. CNcomment:HDMI AV mute  CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] bAvMute   whether to mute the av.CNcomment:mute AV CNend
+\retval HI_SUCCESS     success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAVMute(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bAvMute);
+
+/**
+\brief get the edid information forcelly. CNcomment:EDID,EDID CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[out] *u8Edid  the buffer allocated externally, buffer size must be 512. CNcomment:EDIDbufferEDIDbuffer 512,; CNend
+\param[in] u32EdidBufSize  size of the Edid buffer. CNcomment:EDIDbuffer CNend
+\param[out] *u32EdidLength  the data lenth of  original edid. CNcomment:EDID CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_Force_GetEDID(HI_UNF_HDMI_ID_E enHdmi, HI_U8 *u8Edid, HI_U32 u32EdidBufSize, HI_U32 *u32EdidLength);
+
+
+/**
+\brief register callback function. CNcomment: CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_Open and after HI_UNF_HDMI_Init
+because HI_UNF_HDMI_Open will trigger hotplug event.
+And this function can only register one function
+If call this func two times,then the 2nd callback function will cover 1st one.
+CNcomment:HI_UNF_HDMI_InitHI_UNF_HDMI_Open \n
+Openhotplug \n
+ CNend
+\param CNcomment: CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment: CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+
+/**
+\brief unregister CallbackFunc. CNcomment: CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_DeInit and after HI_UNF_HDMI_Close
+CNcomment:HI_UNF_HDMI_CloseHI_UNF_HDMI_DeInit CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment: CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+/**
+\brief Load HDCP key. CNcomment:hdcpkey CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] *pstLoadKey  key struct length and point CNcomment:key   CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_LoadHDCPKey(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_LOAD_KEY_S *pstLoadKey);
+
+/**
+\brief Set SRM, it is called by user, it can be call more time,only remain the last one when set success.Ncomment:SRM CNend
+\param[in]  enHdmi  hdmi channel id. CNcomment:HDMIID CNend
+\param[in]  pstSrm SRM raw dataCNcomment:SRM  CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_SetSrm(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_SRM_S *pstSrm);
+
+/**
+\brief to get the HDCP-capability of sink connect to stbbox. CNcomment:HDMI SinkHDCP CNend
+\attention in HI_UNF_HDMI_GetSinkCapability,HI_UNF_EDID_BASE_INFO_S's stHDCPSupport is triggered by HotPlug,some Sink get HDCP-capability fail when HotPlug.Base on these,it is suggested that use HI_UNF_HDMI_GetHdcpCapability force to get HDCP-capability from sink.When retval is HI_FAILURE,it is suggested that use HI_UNF_HDMI_GetHdcpCapability to get more times until retval is HI_SUCCESS.
+\CNcomment:HI_UNF_EDID_BASE_INFO_SstHDCPSupportHotPlugsinkHI_UNF_HDMI_GetHdcpCapabilitysinkHDCPHI_FAILURE,HI_SUCCESS CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[out] pstHdcpCap  the HDCP capability of the sink .CNcomment:SINKHDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpCapability(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_CAP_S *pstHdcpCap);
+
+/**
+\brief to enable HDCP authentication dynamically after HI_UNF_HDMI_Start. CNcomment:HDCP CNend
+\attention the interface must call after HI_UNF_HDMI_Start.And ,it is suggested that select enHdcpMode according to sink's HDCP-capability.
+\CNcomment:HI_UNF_HDMI_StartsinkHDCP CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstParm  hdcp parameter when enable.CNcomment:HDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_PARAM_S *pstParm);
+
+/**
+\brief to get HDCP status. CNcomment:HDCP CNend
+\attention suggest the interface call after getting HDCP event.CNcomment:HDCP CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstStatus  hdcp status.CNcomment:HDCP CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:/ CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpStatus(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDCP_STATUS_S *pstStatus);
+
+
+/**
+\brief get the edid information forcelly. CNcomment:EEPROMEDID CNend
+\attention \n
+Difference with two interface for get EDID
+HI_UNF_HDMI_Force_GetEDID : Reread EDID from Sink,and write it to EEPROM
+HI_UNF_HDMI_ReadEDID : read edid from EEPROM,not Real-time read from Sink
+CNcomment:EDID
+HI_UNF_HDMI_Force_GetEDID EdidEEPROM
+HI_UNF_HDMI_ReadEDID EEPROMEdidEDID CNend
+\param[out] *u8Edid  the buffer allocated externally, buffer size must be 512. CNcomment:EDIDbufferEDIDbuffer 512,; CNend
+\param[in] u32EdidBufSize  size of the Edid buffer. CNcomment:EDIDbuffer CNend
+\param[out] *u32EdidLength  the data lenth of  original edid. CNcomment:EDID CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_ReadEDID(HI_U8 *u8Edid, HI_U32 u32EdidBufSize, HI_U32 *u32EdidLength);
+
+/**
+\brief Get HDMI runtime delay. CNcomment:hdmi CNend
+\attention \n
+CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:  CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/**
+\brief Set HDMI runtime delay. CNcomment:hdmi CNend
+\attention \n
+if not use this interface, then use hdmi inner delay
+CNcomment:,delay CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:  CNend
+\retval HI_SUCCESS   success.   CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/**
+\brief set the advanced attr of given hdmi interface. CNcomment:HDMI CNend
+\attention when the pstAdvancedAttr->enResumeStart is set to HI_UNF_HDMI_RESUME_NOT_START, resuming the system needs to call HI_UNF_HDMI_Start().
+\param[in] enHdmi      hdmi device id.CNcomment:HDMIID CNend
+\param[in] pstAdvancedAttr     the attr of given hdmi interface.CNcomment:HDMI CNend
+\retval HI_SUCCESS     success.  CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see ::HI_UNF_HDMI_ADVANCED_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAdvancedAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ADVANCED_ATTR_S *pstAdvancedAttr);
+
+/**
+\brief get the current advanced attr of the give hdmi interface. CNcomment:HDMI CNend
+\attention \n
+\param[in] enHdmi hdmi device id.CNcomment: HDMIID CNend
+\param[out] pstAdvancedAttr     the attr of given hdmi interface. CNcomment:HDMI CNend
+\retval HI_SUCCESS      success. CNcomment: CNend
+\retval please refer to the err code definitino of mpi.CNcomment:MPI CNend
+\see HI_UNF_HDMI_ADVANCED_ATTR_S\n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_HDMI_GetAdvancedAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ADVANCED_ATTR_S *pstAdvancedAttr);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __HI_UNF_HDMI_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_i2c.h b/xbmc/platform/linux/hisi/hi_unf_i2c.h
new file mode 100644
index 0000000000..c38f526d60
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_i2c.h
@@ -0,0 +1,248 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_i2c.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_I2C_H__
+#define __HI_UNF_I2C_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      I2C */
+/** @{*/  /** <!-[I2C]*/
+
+#define HI_UNF_I2C_Open  HI_UNF_I2C_Init
+#define HI_UNF_I2C_Close HI_UNF_I2C_DeInit
+
+/**Maximum I2C channel ID*/ /**CNcomment:I2C*/
+#define HI_I2C_MAX_NUM_USER (15)
+
+/**Rate type of the I2C module*/
+/**CNcomment:I2C */
+typedef enum hiUNF_I2C_RATE_E
+{
+    HI_UNF_I2C_RATE_10K = 0, /**<Standard rate: 10 kbit/s*/         /**<CNcomment:10kbit/s*/
+    HI_UNF_I2C_RATE_50K, /**<Standard rate: 50 kbit/s*/   /**<CNcomment:50kbit/s*/
+    HI_UNF_I2C_RATE_100K, /**<Standard rate: 100 kbit/s*/  /**<CNcomment:100kbit/s*/
+    HI_UNF_I2C_RATE_200K, /**<Standard rate: 200 kbit/s*/  /**<CNcomment:200kbit/s*/
+    HI_UNF_I2C_RATE_300K, /**<Standard rate: 300 kbit/s*/  /**<CNcomment:300kbit/s*/
+    HI_UNF_I2C_RATE_400K, /**<Fast rate: 400 kbit/s*/      /**<CNcomment:400kbit/s*/
+
+    HI_UNF_I2C_RATE_BUTT
+} HI_UNF_I2C_RATE_E;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      I2C*/
+/** @{*/  /** <!-- -I2C=*/
+
+/**
+ \brief Init the I2C device.
+CNcomment:\brief I2Cthe Inter-Integrated CircuitCNend
+
+ \param N/A                                                               CNcomment:CNend
+ \retval 0 Success                                                        CNcomment:CNend
+ \retval ::HI_ERR_I2C_OPEN_ERR  Open I2c Error				  CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Init (HI_VOID);
+
+/**
+ \brief  DeInit the I2C device.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+This API is called after I2C operations are completed.\n
+CNcomment:I2C\n CNend
+
+ \param N/A                                                        CNcomment:CNend
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::HI_ERR_I2C_CLOSE_ERR  Close I2c Error.	 	   CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DeInit(HI_VOID);
+
+/**
+ \brief  Get the number of I2C module.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API to get the number of I2C module befor read/write data.\n
+CNcomment:I2CI2C\n CNend
+
+ \param N/A                                                        CNcomment:CNend
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_GetCapability(HI_U32 *pu32I2cNum);
+
+/**
+The I2C device is not initialized.
+CNcomment:\brief GpioI2cCNend
+
+ \attention \n
+If the specified GPIO pins are used, this API fails to be called.\n
+CNcomment:Gpio\n CNend
+
+ \param[out] u32I2cNum  ID of the obtained I2C bus                            CNcomment:I2CCNend
+ \param[in] u32SCLGpioNo  SCL Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \param[in] u32SDAGpioNo  SDA Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:0103CNend
+ \retval 0 Success                                                           CNcomment:CNend
+ \retval ::HI_FAILURE	Create gpioi2c failed								CNcomment:CNend
+ \retval ::HI_ERR_I2C_NULL_PTR 		The pointer parameter is NULL			CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid.               CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_CreateGpioI2c(HI_U32 *pu32I2cNum, HI_U32 u32SCLGpioNo, HI_U32 u32SDAGpioNo);
+
+/**
+ \brief Destroys a inter-integrated circuit (I2C) channel that simulates the general-purpose input/output (GPIO) function.
+CNcomment:\brief GpioI2cCNend
+
+ \attention \n
+If the I2C channel is not used, a code indicating success is returned.\n
+CNcomment:GpioI2c\n CNend
+
+ \param[in] u32I2cNum ID of the I2C bus to be destroyed        CNcomment:I2CCNend
+ \retval 0  Success                                            CNcomment:CNend
+ \retval ::HI_FAILURE	Destroy gpioi2c failed				  CNcomment:CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid. CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DestroyGpioI2c(HI_U32 u32I2cNum);
+
+/**
+ \brief Reads data by using the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be read           CNcomment:I2CCNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus      CNcomment:I2CCNend
+ \param[in] u32RegAddr  On-chip offset address of a device        CNcomment:CNend
+ \param[in] u32RegAddrCount  Length of an on-chip offset address. CNcomment:CNend
+                      1: 8-bit sub address                       CNcomment:18bitCNend
+                      2: 16-bit sub address                      CNcomment:216bitCNend
+                      3: 24-bit sub address                      CNcomment:324bitCNend
+                      4: 32-bit sub address                      CNcomment:432bitCNend
+
+ \param[out] pu8Buf   Buffer for storing the data to be read                            CNcomment:BufferCNend
+ \param[in] u32Length  Length of the data to be read                                    CNcomment:CNend
+ \retval 0 Success                                                                      CNcomment:CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_FAILED_READ  Data fails to be read by using the I2C bus.          CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Read(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                       HI_U32 u32RegAddrCount, HI_U8 *pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Writes data by using the I2C bus. That is, you can call this API to write data to the device mounted on the I2C bus through the I2C channel.
+CNcomment:\brief I2CI2CI2CCNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be written         CNcomment:I2CCNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus       CNcomment:I2CCNend
+ \param[in] u32RegAddr  On-chip offset address of a device         CNcomment:CNend
+ \param[in] u32RegAddrCount Length of an on-chip offset address.   CNcomment:CNend
+                    1: 8-bit sub address                          CNcomment:18bitCNend
+                    2: 16-bit sub address                         CNcomment:216bitCNend
+                    3: 24-bit sub address                         CNcomment:324bitCNend
+                    4: 32-bit sub address                         CNcomment:432bitCNend
+
+ \param[in]  pu8Buf   Buffer for storing the data to be written                         CNcomment:BufferCNend
+ \param[in] u32Length  Length of the data to be written                                 CNcomment:CNend
+ \retval 0  Success                                                                     CNcomment:CNend
+ \retval ::HI_FAILURE	Write data failed					  	CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_FAILED_WRITE  Data fails to be written by using the I2C bus.      CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Write(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                        HI_U32 u32RegAddrCount, HI_U8 * pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:i2cgpio  i2c \nCNend
+CNcomment:400Kbit/s\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:I2CCNend
+ \param[in] enI2cRate  I2C clock rate. For details about the definition, see the description of ::HI_UNF_I2C_RATE_E. CNcomment:I2C::HI_UNF_I2C_RATE_ECNend
+ \retval 0  Success                                                                                                  CNcomment:CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRate(HI_U32 u32I2cNum, HI_UNF_I2C_RATE_E enI2cRate);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief I2CCNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:i2cgpio  i2c \n
+400Kbit/s\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:I2CCNend
+ \param[in] u32I2cRate  I2C clock rate.  CNcomment:I2CCNend
+ \retval 0  Success                                                                                                  CNcomment:CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2CCNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2CCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRateEx(HI_U32 u32I2cNum, HI_U32 u32I2cRate);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_ir.h b/xbmc/platform/linux/hisi/hi_unf_ir.h
new file mode 100644
index 0000000000..d4250f7754
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_ir.h
@@ -0,0 +1,408 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_ir.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of IR
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_IR_H__
+#define __HI_UNF_IR_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+//#include "hi_unf_keyled.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      IR */
+/** @{ */  /** <!-- [IR] */
+
+/**status of key*/
+/**CNcomment:*/
+typedef enum  hiUNF_KEY_STATUS_E
+{
+    HI_UNF_KEY_STATUS_DOWN = 0 ,   /**<Pressed*/   /**<CNcomment: */
+    HI_UNF_KEY_STATUS_HOLD ,       /**<Hold*/      /**<CNcomment: */
+    HI_UNF_KEY_STATUS_UP ,         /**<Released*/  /**<CNcomment: */
+
+    HI_UNF_KEY_STATUS_BUTT
+}HI_UNF_KEY_STATUS_E ;
+
+/**Code type supported by the infrared (IR) module*/
+/**CNcomment:IR*/
+typedef enum hiUNF_IR_CODE_E
+{
+    HI_UNF_IR_CODE_NEC_SIMPLE = 0,  /**<NEC with simple repeat code*/   /**<CNcomment:NEC with simple repeat code*/
+    HI_UNF_IR_CODE_TC9012,          /**<TC9012 code*/                   /**<CNcomment:TC9012*/
+    HI_UNF_IR_CODE_NEC_FULL,        /**<NEC with full repeat code*/     /**<CNcomment:NEC with full repeat code*/
+    HI_UNF_IR_CODE_SONY_12BIT,      /**<SONY 12-bit code */             /**<CNcomment:SONY 12BIT*/
+    HI_UNF_IR_CODE_RAW,               /**<Raw code*/	                    /**<CNcomment:raw */
+    HI_UNF_IR_CODE_BUTT
+}HI_UNF_IR_CODE_E;
+
+/**List of IR code type. For details about HI_UNF_IR_STD, see HI_UNF_IR_CODE_E.*/
+/**CNcomment:IR,HI_UNF_IR_STDHI_UNF_IR_CODE_E */
+typedef enum hiUNF_IR_PROTOCOL_E
+{
+    HI_UNF_IR_NEC,               /**<For NEC protocol*/                          /**<CNcomment:NEC*/
+    HI_UNF_IR_RC6A = 10,         /**<For RC6A protocol*/                         /**<CNcomment:RC6A*/
+    HI_UNF_IR_RC5,               /**<For RC5 protocol*/                          /**<CNcomment:RC5*/
+    HI_UNF_IR_LOW_LATENCY_PROTOCOL,
+    HI_UNF_IR_RC6_MODE0,         /**<For RC6 mode 0*/                            /**<CNcomment:RC6 mode0*/
+    HI_UNF_IR_RCMM,              /**<For RCMM 24/32 protocol*/                   /**<CNcomment:RCMM 24/32*/
+    HI_UNF_IR_RUWIDO,            /**<For Ruwido protocol*/                       /**<CNcomment:Ruwido*/
+    HI_UNF_IR_RCRF8,             /**<For RCRF8 protocol*/                        /**<CNcomment:RCRF8*/
+    HI_UNF_IR_MULTIPLE,          /**<For multiple protocol support*/             /**<CNcomment:Multiple*/    
+    HI_UNF_IR_RMAP,              /**<For RMAP protocol with Mancester coding*/   /**<CNcomment:RMAP */
+    HI_UNF_IR_RSTEP,             /**<For RSTEP protocol*/                        /**<CNcomment:RSTEP*/
+    HI_UNF_IR_RMAP_DOUBLEBIT,    /**<For RMAP protocol with Double bit coding*/  /**<CNcomment:RMAP bit*/
+    HI_UNF_IR_LOW_LATENCY_PRO_PROTOCOL,
+    HI_UNF_IR_XMP,               /**<For XMP protocol*/                          /**<CNcomment:XMP*/
+    HI_UNF_IR_USER_DEFINED,      /**<For user protocol*/                         /**<CNcomment:*/    
+    HI_UNF_IR_PROTOCOL_BUTT 
+} HI_UNF_IR_PROTOCOL_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      IR */
+/** @{ */  /** <!-- [IR] */
+/*---IR---*/
+
+/**
+\brief Starts the IR device.
+CNcomment:\brief IRCNend
+
+\attention \n
+This API can be called repeatedly. Key IDs can be received only after you can start the IR device, and then call HI_UNF_IR_Enable. \n
+CNcomment:HI_UNF_IR_EnableCNend
+
+\param N/A                                                                   CNcomment: CNend
+\retval HI_SUCCESS Success                                                   CNcomment: CNend
+\retval ::HI_ERR_IR_OPEN_ERR   The IR device fails to open                   CNcomment:IR CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Init(HI_VOID);
+
+#define HI_UNF_IR_Open() HI_UNF_IR_Init()
+
+/**
+\brief Stops the IR device.
+CNcomment:\brief IRCNend
+
+\attention \n
+This API can be called repeatedly. \n
+CNcomment:CNend
+
+\param  N/A                                                                  CNcomment: CNend
+\retval HI_SUCCESS Success                                                   CNcomment: CNend
+\retval ::HI_ERR_IR_CLOSE_ERR  The IR device fails to close.                 CNcomment:IR CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_DeInit(HI_VOID);
+
+#define HI_UNF_IR_Close() HI_UNF_IR_DeInit()
+
+/**
+\brief Enables the IR device.
+CNcomment:\brief IRCNend
+\attention \n
+N/A
+\param[in] bEnable  IR enable. HI_TRUE: enabled; HI_FALSE: disabled           CNcomment:IR , HI_TRUE , HI_FALSE CNend
+\retval HI_SUCCESS Success                                                    CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.               CNcomment:IR CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                   CNcomment: CNend
+\retval ::HI_ERR_IR_ENABLE_FAILED It fails to enable IR device.               CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Enable ( HI_BOOL bEnable);
+
+/**
+\brief Obtains the protocol type of a remote control.
+CNcomment:\brief  CNend
+
+\attention \n
+This interface is only supported in IR_STD mode. And it must be used after function "HI_UNF_IR_GetValueWithProtocol".\n
+CNcomment:IR_STDHI_UNF_IR_GetValueWithProtocol CNend
+
+\param[out]  penProtocol  protocol type pointer,reference HI_UNF_IR_PROTOCOL_E for detail   CNcomment:  ::HI_UNF_IR_PROTOCOL_E CNend
+\retval HI_SUCCESS Success                                                            CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.                                 CNcomment:  CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_IR_GetProtocol(HI_UNF_IR_PROTOCOL_E *penProtocol);
+
+/**
+\brief obtain name of remote control protocol
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_LIRC is effective, this interface is not supported now.
+CNcomment:IR_TYPE=IR_LIRC CNend
+
+\param[out]  pProtocolName  used to save first address of the protocol name buffer    CNcomment: CNend
+\param[in]   s32BufLen      used to save length of the protocol name buffer           CNcomment: CNend
+\retval ::HI_ERR_IR_UNSUPPORT   It is not supported.                                  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetProtocolName(HI_CHAR *pProtocolName, HI_S32 s32BufLen);
+
+/**
+\brief Obtains the key values and key status of the remote control.
+CNcomment:\brief  CNend
+
+\attention \n
+
+\param[out]  penPressStatus  Key status. For details about the definition, see the description of ::HI_UNF_KEY_STATUS_E.  CNcomment:::HI_UNF_KEY_STATUS_E CNend
+\param[out]  pu64KeyId  Key value                                                     CNcomment: CNend
+\param[out]  pszProtocolName  used to save first address of the protocol name buffer    CNcomment: CNend
+\param[in]   s32NameSize      used to save length of the protocol name buffer           CNcomment: CNend
+\param[in] u32TimeoutMs  Timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block  CNcomment:, , 0 - , 0xFFFFFFFF- CNend
+\retval HI_SUCCESS Success                                                            CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.                                 CNcomment:  CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                           CNcomment: CNend
+\retval ::HI_ERR_IR_SET_BLOCKTIME_FAILED  The IR device fails to set block time.      CNcomment: CNend
+\retval ::HI_ERR_IR_READ_FAILED  The IR device fails to read key.                     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetValueWithProtocol(HI_UNF_KEY_STATUS_E *penPressStatus, HI_U64 *pu64KeyId,
+                                      HI_CHAR *pszProtocolName, HI_S32 s32NameSize, HI_U32 u32TimeoutMs);
+
+#define HI_UNF_IR_GetValue(penPressStatus, pu64KeyId, u32TimeoutMs) HI_UNF_IR_GetValueWithProtocol(penPressStatus, \
+                                                                                                   pu64KeyId, NULL, 0, \
+                                                                                                   u32TimeoutMs)
+
+
+/**
+\brief Set key fetch or symbol fetch from ir driver.
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:IR_TYPE=IR_S2CNend
+
+\param[in] mode 0 means key mode. 1 means symbol mode                                 CNcomment:01 CNend
+\retval HI_SUCCESS Success                                                            CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                           CNcomment: CNend
+\retval ::HI_ERR_IR_SET_FETCHMETHOD_FAILED  The IR device fails to set fetch method.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetFetchMode(HI_S32 s32Mode);
+
+/**
+\brief Obtains the raw symbols from ir driver.
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:IR_TYPE=IR_S2CNend
+
+\param[out]  pu64lower  lower pluse value                                             CNcomment: CNend
+\param[out]  pu64upper  upper space value                                             CNcomment: CNend
+\param[in] s32TimeoutMs read timeout .                                                CNcomment:CNend
+
+\retval HI_SUCCESS Success                                                            CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized. 					  CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.								  CNcomment:  CNend
+\retval ::HI_ERR_IR_SET_BLOCKTIME_FAILED  The IR device fails to set block time.      CNcomment: CNend
+\retval ::HI_ERR_IR_READ_FAILED  The IR device fails to read key.					  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetSymbol(HI_U64 *pu64First, HI_U64* pu64Second, HI_U32 u32TimeoutMs);
+
+/**
+\brief Enables or disables the function of reporting the released status of a key.
+CNcomment:\brief CNend
+
+\attention \n
+The function is enabled by default.
+CNcomment:CNend
+
+\param[in] bEnable      Key released enable.  CNcomment:CNend
+                        0: disabled           CNcomment:0CNend
+                        1: enabled            CNcomment: 1CNend
+\retval HI_SUCCESS  Success                                             CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.         CNcomment:IR CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.             CNcomment: CNend
+\retval ::HI_ERR_IR_SET_KEYUP_FAILED  It fails to enable released key.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableKeyUp(HI_BOOL bEnable);
+
+/**
+\brief Enables or disables the function of reporting the same key value. If keys are pressed and held down, data is continuously transmitted to the receive buffer. Therefore, you can enable or disable this function for applications as required.
+CNcomment:\brief CNend
+
+\attention \n
+The function is enabled by default.\n
+This API must work with HI_UNF_IR_RepKeyTimeoutVal. The API HI_UNF_IR_RepKeyTimeoutVal is used to set the interval of reporting the same key value.\n
+If the function of reporting the same key value is enabled, the keys are pressed and held down, and the interval is set to 300 ms, data is reported once every 300 ms.
+If the function is disabled, data is reported only once regardless of how long the keys are held down.
+CNcomment:\n 
+HI_UNF_IR_RepKeyTimeoutValHI_UNF_IR_RepKeyTimeoutVal\n 
+300300\n 
+CNend
+\param[in] bEnable     Repeat key report enable.    CNcomment:CNend
+                       0: disabled                  CNcomment:0CNend
+                       1: enabled                   CNcomment:1CNend
+\retval HI_SUCCESS Success                                                     CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT   The IR device is not initialized.               CNcomment:IR CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                   CNcomment: CNend
+\retval ::HI_ERR_IR_SET_REPEAT_FAILED   It fails to enable repeat key.         CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableRepKey(HI_BOOL bEnable);
+
+/**
+\brief Sets the interval (in ms) of reporting the same key value.
+CNcomment:\brief ms CNend
+
+\attention \n
+This API is unavailable if the function of reporting the same key value is disabled by calling HI_UNF_IR_IsRepKey.
+CNcomment:HI_UNF_IR_IsRepKeyCNend
+
+\param[in] u32TimeoutMs   Interval of reporting the same key value. The interval ranges from 0 ms to 65,536 ms.\n
+						  The value 0 will be set to 108, and the value bigger than 65536 will be set to 65536 \n
+                          CNcomment:0ms65536ms \n
+						  01086553665536CNend
+\retval HI_SUCCESS Success CNcomment:                                          CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                CNcomment:IR CNend
+\retval ::HI_ERR_IR_SET_REPKEYTIMEOUT_FAILED  It fails to set repeat key timeout.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetRepKeyTimeoutAttr(HI_U32 u32TimeoutMs);
+
+/**
+\brief Sets the code type of the remote control.
+CNcomment:\brief CNend
+
+\attention \n
+when IR_TYPE=IR_STD is effective.
+CNcomment:IR_TYPE=IR_STDCNend
+
+
+\param[in] enIRCode Four standard code types of the remote control are supported by default.  CNcomment:4CNend
+                     HI_UNF_IR_CODE_NEC_SIMPLE:Nec With Simple code type. CNcomment:Nec Simple  CNend
+                     HI_UNF_IR_CODE_TC9012:TC9012 code type.              CNcomment:TC9012      CNend
+                     HI_UNF_IR_CODE_NEC_FULL:Nec With Full code type.     CNcomment:Nec Full    CNend
+                     HI_UNF_IR_CODE_SONY_12BIT:Sony 12 Bit code type.     CNcomment:Sony 12 bit CNend
+\retval HI_SUCCESS Success                                                 CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.            CNcomment:IR CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.               CNcomment: CNend
+\retval ::HI_ERR_IR_SETFORMAT_FAILED It fails to set IR code type.         CNcomment:IR CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetCodeType(HI_UNF_IR_CODE_E enIRCode);
+
+/**
+\brief  Resets the IR device.
+CNcomment:\brief  IRCNend
+
+\attention \n
+This API is used to delete the key values in the buffer.
+CNcomment:bufferCNend
+
+\param N/A         CNcomment: CNend
+\retval HI_SUCCESS Success                                                      CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR CNend
+\retval ::HI_ERR_IR_RESET_FAILED  The IR device fails to reset.                 CNcomment:IR CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Reset(HI_VOID);
+
+/**
+\brief enable an infrared code.
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:IR_TYPE=IR_S2CNend
+
+\param N/A         CNcomment: CNend
+\retval HI_SUCCESS Success                                                      CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment:  CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment: CNend
+\retval ::HI_ERR_IR_ENABLE_PROT_FAILED  It fails to enable an infrared code.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableProtocol(const HI_CHAR* pszProtocolName);
+
+/**
+\brief disable an infrared code.
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:IR_TYPE=IR_S2CNend
+
+\param N/A         CNcomment: CNend
+\retval HI_SUCCESS Success                                                      CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment:  CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment: CNend
+\retval ::HI_ERR_IR_DISABLE_PROT_FAILED   It fails to disalbe an infrared code. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_DisableProtocol(const HI_CHAR* pszProtocolName);
+
+/**
+\brief get the enable or disable status of  an infrared code.
+CNcomment:\brief  CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:IR_TYPE=IR_S2CNend
+
+\param N/A         CNcomment: CNend
+\retval HI_SUCCESS Success                                                      CNcomment: CNend
+\retval HI_FAILURE Failure                                                      CNcomment: CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment:  CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment: CNend
+\retval ::HI_ERR_IR_GET_PROTENABLE_FAILED It fails to get status of an infrared code.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetProtocolEnabled(const HI_CHAR* pszProtocolName, HI_BOOL *pbEnabled);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_IR_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_keyled.h b/xbmc/platform/linux/hisi/hi_unf_keyled.h
new file mode 100644
index 0000000000..08311c8a42
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_keyled.h
@@ -0,0 +1,476 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_keyled.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the KEYLED
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_KEYLED_H__
+#define __HI_UNF_KEYLED_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      KEYLED */
+/** @{ */  /** <!-- [KEYLED] */
+/**keyled type*/
+/**CNcomment:KEYLED */
+typedef enum  hiUNF_KEYLED_TYPE_E
+{
+    HI_UNF_KEYLED_TYPE_74HC164 = 0x0, /**<KEYLED type:74HC164*/                   /**<CNcomment:KEYLED: 74HC164 */
+    HI_UNF_KEYLED_TYPE_PT6961,    /**<KEYLED type: PT6961*/                       /**<CNcomment:KEYLEDPT6961 */
+    HI_UNF_KEYLED_TYPE_CT1642,    /**<KEYLED type: CT1642*/                       /**<CNcomment:KEYLEDCT1642 */
+    HI_UNF_KEYLED_TYPE_PT6964,	  /**<KEYLED type: PT6964*/                       /**<CNcomment:KEYLEDPT6964 */
+    HI_UNF_KEYLED_TYPE_FD650,     /**<KEYLED type: FD650*/                        /**<CNcomment:KEYLEDFD650 */
+    HI_UNF_KEYLED_TYPE_GPIOKEY,   /**<KEYLED type :GPIOKEY*/   					 /**<CNcomment:GPIO*/
+    HI_UNF_KEYLED_TYPE_BUTT       
+}HI_UNF_KEYLED_TYPE_E;
+
+/**Blink frequency level of the LED*/
+/**CNcomment:LED*/
+typedef enum hiUNF_KEYLED_LEVEL_E
+{
+    HI_UNF_KEYLED_LEVEL_1 = 0x01,   /**<Level 1, slowest*/  /**<CNcomment:1,*/
+    HI_UNF_KEYLED_LEVEL_2,          /**<Level 2*/           /**<CNcomment:2 */
+    HI_UNF_KEYLED_LEVEL_3,          /**<Level 3*/           /**<CNcomment:3 */
+    HI_UNF_KEYLED_LEVEL_4,          /**<Level 4*/           /**<CNcomment:4 */
+    HI_UNF_KEYLED_LEVEL_5,          /**<Level 5, fastest*/  /**<CNcomment:5 , */
+
+    HI_UNF_KEYLED_LEVEL_BUTT
+}HI_UNF_KEYLED_LEVEL_E;
+
+/**Blink sequence of LEDs*/
+/**CNcomment:LED*/
+typedef enum hiUNF_KEYLED_LIGHT_E
+{
+    HI_UNF_KEYLED_LIGHT_1 = 0x01,   /**<The first LED blinks.*/   /**<CNcomment:1LED*/
+    HI_UNF_KEYLED_LIGHT_2,          /**<The second LED blinks.*/  /**<CNcomment:2LED*/
+    HI_UNF_KEYLED_LIGHT_3,          /**<The third LED blinks.*/   /**<CNcomment:3LED*/
+    HI_UNF_KEYLED_LIGHT_4,          /**<The fourth LED blinks.*/  /**<CNcomment:4LED*/
+    HI_UNF_KEYLED_LIGHT_ALL,        /**<All LEDs blink.*/        /**<CNcomment:LED*/
+    HI_UNF_KEYLED_LIGHT_NONE,       /**<All LEDs do not blink.*/  /**<CNcomment:LED*/
+
+    HI_UNF_KEYLED_LIGHT_BUTT
+}HI_UNF_KEYLED_LIGHT_E;
+
+/**Display time of each LED*/
+/**CNcomment:LED*/
+typedef struct hiUNF_KEYLED_Time_S
+{
+    HI_U32 u32Hour;           /**<Hour*/   /**<CNcomment:*/
+    HI_U32 u32Minute;         /**<Minute*/ /**<CNcomment:*/
+}HI_UNF_KEYLED_TIME_S, *HI_UNF_KEYLED_TIME_S_PTR;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      KEYLED */
+/** @{ */  /** <!-- [KEYLED] */
+/**---- keyled ----*/
+
+/**
+\brief Initializes the KEYLED module.
+CNcomment:\brief KEYLEDCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:CNend
+
+\param N/A                                             CNcomment: CNend
+\retval ::HI_SUCCESS Success                           CNcomment: CNend
+\retval ::HI_FAILURE  The KEYLED device fails to open. CNcomment:KEYLED CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the KEYLED module.
+CNcomment:\brief KEYLEDCNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:CNend
+
+\param N/A                                             CNcomment: CNend
+\retval ::HI_SUCCESS Success                           CNcomment: CNend
+\retval ::HI_FAILURE  The KEYLED device fails to close. CNcomment:KEYLED CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_DeInit(HI_VOID);
+
+/**
+\brief Selects the type of the KEYLED.
+CNcomment:\brief KEYLEDCNend
+
+\attention \n
+It is recommended to call this API once after the KEYLED module is initialized.
+CNcomment:CNend
+
+\param[in] enKeyLedType   KEYLED type                                           CNcomment:keyled CNend
+\retval ::HI_SUCCESS   Success                                                  CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The parameter is invalid.                 CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_SelectType(HI_UNF_KEYLED_TYPE_E enKeyLedType);
+
+/**
+\brief Enables the key function.
+CNcomment:\brief CNend
+\attention \n
+The KEYLED module starts to receive key values after the key function is enabled.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.\n
+CNcomment:\n
+CNend
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Open(HI_VOID);
+
+/**
+\brief Disables the key function.
+CNcomment:\brief CNend
+
+\attention \n
+The KEYLED module stops receiving key IDs after the key function is disabled.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.\n
+CNcomment:\n
+,CNend
+
+\param N/A                                                                      CNcomment: CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Close(HI_VOID);
+
+/**
+\brief Clears the key values that are not received.
+CNcomment:\brief CNend
+
+\attention \n
+This API is used to clear the buffer for storing the key values. In this way, the initial state is returned.
+CNcomment:bufferCNend
+\param N/A Success                                                              CNcomment: CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Reset(HI_VOID);
+
+
+/**
+\brief Obtains a key value.
+CNcomment:\brief CNend
+
+\attention \n
+This API is used to obtain the key value that is received first in the buffer. After this API is called, the key value and key status are returned.\n
+The key status contains pressed, hold and released.\n
+This API needs to work with ::HI_UNF_KEY_SetBlockTime.\n
+If there are no key values, the API waits until timeout occurs. In this case, the error code ::HI_ERR_KEYLED_TIMEOUT is returned.\n
+If the timeout is set to 0 in non-block mode, the error code ::HI_ERR_KEYLED_NO_NEW_KEY is returned when there are no key values.\n
+If the timeout is set to 0xFFFFFFFF, it indicates infinite wait.\n
+CNcomment:buffer\n
+\n
+::HI_UNF_KEY_SetBlockTime\n
+\n
+0\n
+0xffffffffCNend
+\param[out] pu32PressStatus Key status: pressed(0x0), hold(0x1) or released(0x2) CNcomment:CNend
+\param[out] pu32KeyId  Key value                                                 CNcomment:CNend
+\retval ::HI_SUCCESS  Success                                                    CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.          CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NULL_PTR  The pointer is null.                           CNcomment: CNend
+\retval ::HI_ERR_KEYLED_NO_NEW_KEY  There are no key values.                     CNcomment: CNend
+\retval ::HI_ERR_KEYLED_TIMEOUT  Waiting for key values times out.               CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_GetValue(HI_U32 * pu32PressStatus, HI_U32 * pu32KeyId);
+
+/**
+\brief Sets the timeout of reading key IDs.
+CNcomment:\brief CNend
+
+\attention \n
+If the timeout is set to 0, the API is not blocked. If there is no key ID, the error code HI_ERR_KEYLED_NO_NEW_KEY is returned.\n
+If the timeout is set to 0xFFFFFFFF, it indicates infinite wait.\n
+The default time is 500 ms.\n
+CNcomment:0\n
+0xffffffff\n 
+500msCNend
+\param[in] u32BlockTimeMs   Timeout, in ms                               CNcomment:msCNend
+\retval ::HI_SUCCESS Success                                             CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_SetBlockTime(HI_U32 u32BlockTimeMs);
+
+
+/**
+\brief Set the time of pressing a key repeatedly.
+CNcomment:\brief CNend
+
+\attention \n
+If a key is pressed for a period of time, it considers that the key is pressed repeatedly.\n
+The time ranges from 108 ms to 65536 ms. If the time is not within the range, the time is automatically restricted to this range.\n
+The default time is 200 ms.\n
+CNcomment:\n
+108ms65536ms\n
+200msCNend
+
+\param[in] u32RepTimeMs  Time of pressing a key repeatedly, in ms       CNcomment:msCNend
+\retval ::HI_SUCCESS Success                                            CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized. CNcomment: CNend
+\see \n 
+N/A
+*/
+HI_S32 HI_UNF_KEY_RepKeyTimeoutVal(HI_U32 u32RepTimeMs);
+
+/**
+\brief Enables or disables the function of reporting the same key ID.
+CNcomment:\brief CNend
+
+\attention \n
+The ID of a pressed key is reported consecutively only after the report function is enabled.\n
+CNcomment:CNend
+
+\param[in] u32IsRepKey Repeat key report enable. 1: enabled; 0: disabled   CNcomment:1 0 CNend
+\retval ::HI_SUCCESS Success                                               CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_IsRepKey(HI_U32 u32IsRepKey);
+
+/**
+\brief Enables or disables the function of reporting the released status of a key.
+CNcomment:\brief CNend
+
+\attention \n
+The released statuses of keys are reported only after the report function is enabled. Otherwise, only the pressed statuses are reported.\n
+CNcomment:CNend
+
+\param[in] u32IsKeyUp Repeat key report enable. 1: enabled; 0: disabled  CNcomment:1 0 CNend
+\retval ::HI_SUCCESS Success                                             CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment: CNend
+\see \n 
+N/A
+*/
+HI_S32 HI_UNF_KEY_IsKeyUp(HI_U32 u32IsKeyUp);
+
+/**
+\brief Enables the display function of LEDs.
+CNcomment:\brief CNend
+
+\attention \n
+The LEDs work only after the display function is enabled.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.\n
+CNcomment:\n
+CNend
+
+\param N/A                                     CNcomment: CNend
+\retval ::HI_SUCCESS Success                   CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.    CNcomment: Ioctrl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Open(HI_VOID);
+
+/**
+\brief Disables the display function of LEDs.
+CNcomment:\brief CNend
+
+\attention \n
+The LEDs do not work after the display function is disabled.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.\n
+CNcomment:\n
+,CNend
+ 
+\param N/A                                    CNcomment: CNend
+\retval ::HI_SUCCESS Success                  CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.   CNcomment: Ioctrl CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Close(HI_VOID);
+
+
+/**
+\brief Displays characters based on the type of the input code.
+CNcomment:\brief CNend
+
+\attention \n
+Each LED displays a character that corresponds to the value of one byte.\n
+During displaying, the values of the four characters to be displayed need to be combined to form a 32-bit unsigned int data segment. The data serves as the parameter value of this API.\n
+The four LEDs from left to right display bit[7:0], bit[15:8], bit[23:16], and bit[31:24] of the data respectively.\n
+For example, if you want to display "0123" on LEDs, you need to combine the display values corresponding to these characters to form the following unsigned int variable:\n
+  Unsigned int parameter = 0x03 + (0x9F <<8) + (0x25<<16) + (0x0D <<24);\n
+Where, 0x03, 0x9F, 0x25, and 0x0D are the display values of 0, 1, 2, and 3 respectively.\n
+The following shows the mapping between the segments of a 7-segment LED and data bits:\n
+       --7--       \n
+      |     |      \n
+     2|     |6     \n
+      |--1--       \n
+      |     |      \n
+     3|     |5     \n
+       --4-- .0    \n
+The common display characters and values of the LEDs on HiSilicon demo board are as follows in the case of co-anode (the display characters and values need to be reversed in the case of co-cathode):
+  Digitals 0-9: 0x03, 0x9F, 0x25, 0x0D, 0x99, 0x49, 0x41, 0x1F, 0x01, 0x09\n
+  Upper-case letters A-Z (the characters that cannot be displayed are expressed as 0xFF):\n
+     0xFF, 0xFF, 0x63, 0xFF, 0x61, 0x71, 0xFF, 0x91, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF,\n
+     0xFF, 0x03, 0x31, 0xFF, 0xFF, 0x49, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n
+  Lower-case letters a-z (the characters that cannot be displayed are expressed as 0xFF):\n
+    0xFF, 0xC1, 0xE5, 0x85, 0x21, 0xFF, 0x09, 0xD1, 0xDF, 0xFF, 0xFF, 0x9F, 0xFF,\n
+    0xD5, 0xC5, 0x31, 0x19, 0xFF, 0x49, 0xFF, 0xC7, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF
+CNcomment:	\n
+4 unsiged int32bit\n
+4 LED bit[7:0]bit[15:8]bit[23:16]bit[31:24]\n
+LED 0123Unsigned int \n
+   Unsigned int parameter = 0x03 + (0x9F <<8) + (0x25<<16) + (0x0D <<24)\n
+0x030x9F0x250x0D 0123\n
+bit:\n
+       --7--       \n
+      |     |      \n
+     2|     |6     \n
+      |--1--       \n
+      |     |      \n
+     3|     |5     \n
+       --4-- .0    \n
+DEMO()\n
+  . 0-90x03, 0x9F, 0x25, 0x0D, 0x99, 0x49, 0x41, 0x1F, 0x01, 0x09\n
+  . A-Z0xFF \n
+     0xFF, 0xFF, 0x63, 0xFF, 0x61, 0x71, 0xFF, 0x91, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF,\n
+     0xFF, 0x03, 0x31, 0xFF, 0xFF, 0x49, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n
+  . a-z0xFF \n
+     0xFF, 0xC1, 0xE5, 0x85, 0x21, 0xFF, 0x09, 0xD1, 0xDF, 0xFF, 0xFF, 0x9F, 0xFF,\n
+     0xD5, 0xC5, 0x31, 0x19, 0xFF, 0x49, 0xE1, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF CNend
+\param[in] u32CodeValue 4-digit value to be displayed                   CNcomment:4CNend
+\retval ::HI_SUCCESS Success                                            CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                             CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Display(HI_U32 u32CodeValue);
+
+
+/**
+\brief Displays the time on LEDs.
+CNcomment:\brief CNend
+
+\attention \n
+The values of hour and minute need to be converted into corresponding decimal values. For example, if you want to display 22:45, you need to set hour to 22 and set minute to 45.\n
+After the start time is set, the time is displayed on LEDs. At the same time, the colon (:) in the time blinks at the frequency of 1 Hz.\n
+Because the time is displayed in 24-hour format, the maximum value of hour is 23, and the maximum value of minute is 59.\n
+CNcomment:2245hour=22minute=45\n
+1HZ\n
+242359CNend
+
+\param[in] stLedTime Time                                                CNcomment:CNend
+\retval ::HI_SUCCESS  Success                                            CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The input parameter is invalid.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_DisplayTime(HI_UNF_KEYLED_TIME_S stLedTime);
+
+/**
+\brief Sets the ID of the blinked LED.
+CNcomment:\brief LED CNend
+
+\attention \n
+The IDs of the LEDs on the board are 1, 2, 3, and 4 from left to right. If you want 4 LEDs to blink together, set 5.\n
+CNcomment:12344:5CNend
+
+\param[in] enPin  Pin ID                                                 CNcomment:CNend
+\retval ::HI_SUCCESS Success                                             CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The input parameter is invalid.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetFlashPin(HI_UNF_KEYLED_LIGHT_E enPin);
+
+/**
+\brief Sets the blink level of an LED.
+CNcomment:\brief LED CNend
+
+\attention \n
+The higher the level, the faster an LED blinks.
+CNcomment:CNend
+
+\param[in] enLevel  Blink level from 1 to 5.                             CNcomment::1  5 CNend
+\retval ::HI_SUCCESS Success                                             CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA The input parameter is invalid.     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetFlashFreq(HI_UNF_KEYLED_LEVEL_E enLevel);
+
+/**
+\brief  whether enable the lockfreq led.
+CNcomment:\brief LEDCNend
+
+\attention \n
+At present,only FD650 KEYLED support this.
+CNcomment:FD650CNend
+
+\param[in] setLock  If lock ,set to HI_TRUE. Otherwise,set to HI_FALSE.                            CNcomment:LOCKLEDHI_TRUEHI_FALSE.CNend
+\retval ::HI_SUCCESS Success                                             CNcomment: CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA The input parameter is invalid.     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetLockPin(HI_BOOL setLock);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_KEYLED_H__ */
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_klad.h b/xbmc/platform/linux/hisi/hi_unf_klad.h
new file mode 100644
index 0000000000..9f8b505af1
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_klad.h
@@ -0,0 +1,270 @@
+/******************************************************************************
+
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2016-12-08
+Last Modified :
+Description   : Key ladder basic API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_H__
+#define __HI_UNF_KLAD_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      KLAD */
+/** @{ */  /** <!-- [KLAD] */
+
+#define HI_UNF_KLAD_MAX_KEY_LEN     (16)
+
+/*
+Level: 1
+Algorithm: TDES/AES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_BLPK       (0x0000)
+
+/*
+Level: 1
+Algorithm: TDES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_SWPK       (0x0001)
+
+/*
+Level: 0
+Algorithm: NA
+Target Engine: Multicipher - fixed
+*/
+#define HI_UNF_KLAD_TYPE_STBROOTKEY (0x0002)
+
+/*
+Level: 0
+Algorithm: NA
+Target Engine: Demux - CSA2/CSA3/AES/DES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_TYPE_CLEARCW    (0x0003)
+
+/*
+Level: 1
+Algorithm: TDES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_STBM_R2R   (0x0004)
+
+
+/**Target engine of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_CSA2             = 0x0000,   /**<Demux PAYLOAD CSA2 */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_CSA3             = 0x0010,   /**<Demux PAYLOAD CSA3 */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC_IDSA     = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_ECB          = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC_CI       = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CLRSTART_ECB = 0x0024,   /**<Demux PAYLOAD AES  CLRSTART ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CLRSTART_CBC = 0x0025,   /**<Demux PAYLOAD AES  CLRSTART CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CTR          = 0x0026,   /**<Demux PAYLOAD AES  CTR */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_IPTV         = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_CIPLUS       = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_CBC          = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_NOVEL        = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_NOVEL       = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_IPTV        = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_ECB         = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_CBC         = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC          = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_IPTV        = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_ECB         = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_CBC         = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_ASA              = 0x0091,   /**<Demux PAYLOAD ASA */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC              = 0x4020,   /**<Cipher AES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_ECB              = 0x4021,   /**<Cipher AES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC_PIFF         = 0x4022,   /**<Cipher AES CBC PIFF */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC_APPLE        = 0x4023,   /**<Cipher AES CBC APPLE */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CTR              = 0x4024,   /**<Cipher AES CTR */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_GCM              = 0x4028,   /**<Cipher AES GCM */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_TDES_CBC             = 0x4040,   /**<Cipher AES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_TDES_ECB             = 0x4041,   /**<Cipher AES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_FIXED,                               /**<Can't config by software */
+    HI_UNF_KLAD_TARGET_ENGINE_BUTT
+} HI_UNF_KLAD_TARGET_ENGINE_E;
+
+/**Encryption algorithm of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_ALG_TYPE_TDES = 0,      /**<Encryption algorithm : TDES*/
+    HI_UNF_KLAD_ALG_TYPE_AES,           /**<Encryption algorithm : AES*/
+    HI_UNF_KLAD_ALG_TYPE_BUTT
+} HI_UNF_KLAD_ALG_TYPE_E;
+
+/**Level of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_LEVEL1 = 0,
+    HI_UNF_KLAD_LEVEL2,
+    HI_UNF_KLAD_LEVEL3,
+    HI_UNF_KLAD_LEVEL4,
+    HI_UNF_KLAD_LEVEL5,
+    HI_UNF_KLAD_LEVEL6,
+    HI_UNF_KLAD_LEVEL_BUTT
+} HI_UNF_KLAD_LEVEL_E;
+
+/**Session key*/
+typedef struct
+{
+    HI_UNF_KLAD_LEVEL_E enLevel;
+    HI_U8 au8Key[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_SESSION_KEY_S;
+
+/**Content key*/
+typedef struct
+{
+    HI_BOOL bOdd;
+    HI_U8 au8Key[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_CONTENT_KEY_S;
+
+typedef struct
+{
+    HI_U8 au8ClearKey[HI_UNF_KLAD_MAX_KEY_LEN];
+    HI_U8 au8EncKey[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_ENC_KEY_S;
+
+/**Attributes of key ladder*/
+typedef struct
+{
+    HI_U32 u32KladType;
+    HI_UNF_KLAD_ALG_TYPE_E enAlg;
+    HI_UNF_KLAD_TARGET_ENGINE_E enEngine;
+} HI_UNF_KLAD_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      KLAD */
+/** @{ */  /** <!--[KLAD]*/
+
+/**
+\brief Init the key ladder device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Init(HI_VOID);
+
+/**
+\brief Deinit the key ladder device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_DeInit(HI_VOID);
+
+/**
+\brief Create a handle of key ladder
+\param[in] u32Type  key ladder type, ref: HI_UNF_KLAD_TYPE_
+\param[out] phKlad  Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Create(HI_HANDLE* phKlad);
+
+/**
+\brief Destroy key ladder handle
+\param[in] hKlad    Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Destroy(HI_HANDLE hKlad);
+
+/**
+\brief Attach key ladder to the taget, include mcipher, plcipher, demux
+\param[in] hKlad    Handle of key ladder
+\param[in] hTarget  Handle of target
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Attach(HI_HANDLE hKlad, HI_HANDLE hTarget);
+
+/**
+\brief Detach a key ladder from a target
+\param[in] hKlad    Handle of key ladder
+\param[in] hTarget  Handle of target
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Detach(HI_HANDLE hKlad, HI_HANDLE hTarget);
+
+/**
+\brief Set the attributes of a key ladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstAttr  Pointer to the attributes of a key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetAttr(HI_HANDLE hKlad, HI_UNF_KLAD_ATTR_S* pstAttr);
+
+/**
+\brief Get the attributes of a key ladder
+\param[in] hKlad    Handle of key ladder
+\param[out] pstAttr Pointer to the attributes of a key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_GetAttr(HI_HANDLE hKlad, HI_UNF_KLAD_ATTR_S* pstAttr);
+
+/**
+\brief Set session key of a keyladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the session key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetSessionKey(HI_HANDLE hKlad, HI_UNF_KLAD_SESSION_KEY_S* pstKey);
+
+/**
+\brief Set content key of a keyladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the content key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetContentKey(HI_HANDLE hKlad, HI_UNF_KLAD_CONTENT_KEY_S* pstKey);
+
+/**
+\brief Generate an encrypted key
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the encrypted key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_GenerateEncKey(HI_HANDLE hKlad, HI_UNF_KLAD_ENC_KEY_S* pstKey);
+
+/**
+\brief Send STB rootkey to cipher
+\param[in] hKlad    Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SendSTBRootkeyToCipher(HI_HANDLE hKlad);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_klad_common_ca.h b/xbmc/platform/linux/hisi/hi_unf_klad_common_ca.h
new file mode 100644
index 0000000000..f61b8cb481
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_klad_common_ca.h
@@ -0,0 +1,82 @@
+/******************************************************************************
+
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad_common_ca.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2016-12-08
+Last Modified :
+Description   : Key ladder API declaration for common ca
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_COMMON_CA_H__
+#define __HI_UNF_KLAD_COMMON_CA_H__
+
+#include "hi_type.h"
+#include "hi_unf_klad.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      COMMON_CA */
+/** @{ */  /** <!-- [COMMON_CA] */
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_CSA2   0x3f00
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA3
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_CSA3   0x3f01
+
+/*
+Level: 2/3/4/5 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - AES/NOVEL/SM4; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_SP     0x3f02
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_R2R    0x3f03
+
+/*
+Level: 2/3/4/5 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2/CSA3/AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_MISC   0x3f04
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      COM_CA */
+/** @{ */  /** <!-- [COM_CA] */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_COMMON_CA_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_klad_dcas.h b/xbmc/platform/linux/hisi/hi_unf_klad_dcas.h
new file mode 100644
index 0000000000..ec50049fe9
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_klad_dcas.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+
+Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad_dcas.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2017-03-21
+Last Modified :
+Description   : Key ladder API declaration for DCAS
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_DCAS_H__
+#define __HI_UNF_KLAD_DCAS_H__
+
+#include "hi_type.h"
+#include "hi_unf_klad.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup       */
+/** @{ */  /** <!-- [DCAS] */
+
+
+/*
+Level: 1
+Algorithm: AES
+Target Engine: NA
+*/
+#define HI_UNF_KLAD_DCAS_TYPE_RKD    0x0c00
+
+/*
+Level: 3
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2/CSA3/AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_DCAS_TYPE_K30    0x0c01
+
+
+/**da nonce*/
+typedef struct hiUNF_KLAD_DCAS_DA_NONCE_S
+{
+    HI_U8 au8Nonce[HI_UNF_KLAD_MAX_KEY_LEN];
+    HI_U8 au8DaNonce[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_DCAS_DA_NONCE_S;
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DCAS */
+/** @{ */  /** <!-- [DCAS] */
+
+
+/**
+\brief Generate K30 DA nonce
+\param[in] hKlad    Handle of key ladder
+\param[in/out] pstDaNonce    pointer to the DA nonce
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_DCAS_K30GenDaNonce(HI_HANDLE hKlad, HI_UNF_KLAD_DCAS_DA_NONCE_S *pstDaNonce);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_DCAS_H__ */
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_mailbox.h b/xbmc/platform/linux/hisi/hi_unf_mailbox.h
new file mode 100644
index 0000000000..989d95efa1
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_mailbox.h
@@ -0,0 +1,151 @@
+/******************************************************************************
+
+  Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_mailbox.h
+  Version       : Initial Draft
+  Author        : Hisilicon hisecurity team
+  Created       : 2016-11-4
+  Description   :
+  History       :
+  1.Date        :
+  Author        : sdk
+  Modification  :
+
+*******************************************************************************/
+#ifndef __HI_UNF_MAILBOX_H__
+#define __HI_UNF_MAILBOX_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+
+/** Mailbox ID */
+#define MID_SCPU_COMMON          (0x01)
+#define MID_TCPU_COMMON          (0x40)
+#define MID_ACPU_COMMON          (0x60)
+
+typedef struct
+{
+    HI_VOID *pMessage;
+    HI_U32 u32MessageLen;
+    HI_VOID *pOutBuffer;
+    HI_U32 *pu32OutBufferLen;
+} HI_UNF_MAILBOX_BUFFER_S;
+
+/******************************* API declaration *****************************/
+
+/**
+\brief Initializes the mailbox module. CNcomment:Mailbox CNend
+\attention \n
+Before calling other functions in this file, you must call this application programming interface (API).
+\param N/A
+\retval ::HI_SUCCESS  Success.       CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Init(HI_VOID);
+
+/**
+\brief Deinitializes the mailbox module. CNcomment:Mailbox CNend
+\attention \n
+N/A
+\param N/A                           CNcomment: CNend
+\retval ::HI_SUCCESS  Success.       CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_DeInit(HI_VOID);
+
+/**
+\brief Open mailbox device.                      CNcomment: mailbox  maibox  CNend
+\attention \n
+N/A
+\param[out] pHandle: Create handle/A             CNcomment: CNend
+\param[in]  u32Id:  mailbox ID, now it is fixed to MID_ACPU_COMMON/A  CNcomment: CNend
+
+\retval ::HI_SUCCESS  Call this API successful.  CNcomment: CNend
+\retval ::HI_FAILURE  Call this API failure.     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Open(HI_HANDLE* pHandle, HI_U32 u32Id);
+
+/**
+\brief Destory mailbox instance.                 CNcomment: mailbox  CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A    CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.  CNcomment: CNend
+\retval ::HI_FAILURE  Call this API failure.     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Close(HI_HANDLE handle);
+
+/**
+\brief  send data by mailbox.                    CNcomment: mailbox  CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\param [in] u32ReceiverId: mailbox ID of data receiver/A
+\param [in/out] pstBuffer: intput and output buffer/A
+\param [in] u32Flags: mailbox mode. 0 means block mode, 1 means timeout mode/A
+\param [in] u32Param: mailbox max wait time, it is valid when mailbox mode is set to 1/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Send
+(
+    HI_HANDLE handle,
+    HI_U32 u32ReceiverId,
+    HI_UNF_MAILBOX_BUFFER_S *pstBuffer,
+    HI_U32 u32Flags,
+    HI_U32 u32Param
+);
+
+/**
+\brief  start transaction.                    CNcomment: CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_BeginTransaction(HI_HANDLE handle);
+
+/**
+\brief  end transaction.                    CNcomment: CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_EndTransaction(HI_HANDLE handle);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif /** __HI_UNF_MAILBOX_H__*/
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_mce.h b/xbmc/platform/linux/hisi/hi_unf_mce.h
new file mode 100644
index 0000000000..a98c52f484
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_mce.h
@@ -0,0 +1,253 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_mce.h
+  Version       : Initial Draft
+  Author        : HiSilicon multimedia software group
+  Created       : 2011-xx-xx
+  Description   : hi_unf_mce.h header file
+  History       :
+  1.Date        : 2011/xx/xx
+    Author      :
+    Modification: This file is created.
+
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the logo and play contents and related configuration information.
+ */
+#ifndef __HI_UNF_MCE_H__
+#define __HI_UNF_MCE_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+#include "hi_unf_vo.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_frontend.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* End of #ifdef __cplusplus */
+
+/********************************Struct Definition********************************/
+/** \addtogroup      MCE */
+/** @{ */  /** <!-- [MCE] */
+
+
+/** Defines the logo parameter*/
+/** CNcomment:Logo*/
+typedef struct hiUNF_MCE_LOGO_PARAM_S
+{
+    HI_BOOL     bLogoEnable;    /**<Whether logo is enable*//**<CNcomment: Logo*/
+    HI_U32      u32LogoLen;     /**<Length of logo data*//**<CNcomment: Logo*/
+}HI_UNF_MCE_LOGO_PARAM_S;
+
+
+/*fastplay supports the decoding mode of ADEC*//**<CNcomment:fastplay ADEC */
+typedef enum hiUNF_MCE_ADEC_TYPE_E
+{
+    HI_UNF_MCE_ADEC_TYPE_MP2 = 0,       /**<MP2 format*//**<CNcomment:MP2  */
+    HI_UNF_MCE_ADEC_TYPE_MP3 = 1,       /**<MP3 format*//**<CNcomment:MP3  */
+    HI_UNF_MCE_ADEC_TYPE_BUTT           /**<Invalid format*//**<CNcomment:  */
+}HI_UNF_MCE_ADEC_TYPE_E;
+
+/**fastplay supports the decoding mode of VDEC*//**<CNcomment:fastplay VDEC */
+typedef enum hiUNF_MCE_VDEC_TYPE_E
+{
+    HI_UNF_MCE_VDEC_TYPE_MPEG2 = 0,     /**<MPEG2 format*//**<CNcomment:MPEG2   */
+    HI_UNF_MCE_VDEC_TYPE_MPEG4 = 1,     /**<MPEG4 format*//**<CNcomment:MPEG4   */
+    HI_UNF_MCE_VDEC_TYPE_H264  = 2,     /**<H264 format*//**<CNcomment:H264   */
+    HI_UNF_MCE_VDEC_TYPE_AVS   = 3,     /**<AVS format*//**<CNcomment:AVS    */
+    HI_UNF_MCE_VDEC_TYPE_HEVC  = 4,     /**<HEVC format*//**<CNcomment:H265   */
+    HI_UNF_MCE_VDEC_TYPE_BUTT           /**<Invalid format*//**<CNcomment:  */
+}HI_UNF_MCE_VDEC_TYPE_E;
+
+
+/**Parameters for digital video broadcasting (DVB) play configuration*//**<CNcomment:DVB  */
+typedef struct hiUNF_MCE_DVB_PARAM_S
+{
+    HI_U32                      u32PcrPid;      /**<Program clock reference (PCR) packet ID (PID)*//**<CNcomment:pcr pid*/
+    HI_U32                      u32VideoPid;    /**<Video PID*//**<CNcomment: pid*/
+    HI_U32                      u32AudioPid;    /**<Audio PID*//**<CNcomment: pid*/
+    HI_UNF_MCE_VDEC_TYPE_E      enVideoType;    /**<Video type*//**<CNcomment: */
+    HI_UNF_MCE_ADEC_TYPE_E      enAudioType;    /**<Audio type*//**<CNcomment: */
+    HI_U32                      u32Volume;      /**<volume of output*//**<CNcomment: */
+    HI_UNF_TRACK_MODE_E         enTrackMode;    /**<Track mode. Only HI_UNF_TRACK_MODE_STEREO is supported.*//**<CNcomment: */
+    HI_UNF_VO_DEV_MODE_E        enDevMode;      /**<Working mode of the VO device*//**<CNcomment:dev  vo   */
+    HI_UNF_TUNER_CONNECT_PARA_S stConnectPara;  /**<Tuner connect parameter*//**<CNcomment:Tuner.*/
+    HI_UNF_TUNER_FE_LNB_CONFIG_S    stLnbCfg;   /**<LNB config*//**<CNcomment:LNB  */
+    HI_UNF_TUNER_FE_LNB_POWER_E            enLNBPower;/**<LNB Power*//**<CNcomment:LNB */
+    HI_UNF_TUNER_DISEQC_SWITCH16PORT_S     st16Port;/**<Switch16 parameter*//**<CNcomment:Switch16 */
+    HI_UNF_TUNER_DISEQC_SWITCH4PORT_S      st4Port;/**<Switch4 parameter*//**<CNcomment:Switch4 */
+    HI_UNF_TUNER_SWITCH_22K_E              enSwitch22K; /**<22K switch parameter*//**<CNcomment:22K */
+}HI_UNF_MCE_DVB_PARAM_S;
+
+/**Play parameter configuration of transport stream (TS) files*//**<CNcomment:TS */
+typedef struct hiUNF_MCE_TSFILE_PARAM_S
+{
+    HI_U32                      u32ContentLen;  /**File length*//**<CNcomment:  */
+    HI_U32                      u32PcrPid;      /**<pcr pid*//**<CNcomment:pcr pid  */
+    HI_U32                      u32VideoPid;    /**<Video PID*//**<CNcomment: pid. */
+    HI_U32                      u32AudioPid;    /**<Audio PID*//**<CNcomment: pid. */
+    HI_UNF_MCE_VDEC_TYPE_E      enVideoType;    /**<Video type*//**<CNcomment:  */
+    HI_UNF_MCE_ADEC_TYPE_E      enAudioType;    /**<Audio type*//**<CNcomment:  */
+    HI_U32                      u32Volume;      /**<volume of output *//**<CNcomment: */
+    HI_UNF_TRACK_MODE_E         enTrackMode;    /**<Track mode. Only HI_UNF_TRACK_MODE_STEREO is supported.*//**<CNcomment: */
+    HI_UNF_VO_DEV_MODE_E        enDevMode;      /**<mode of vo device  *//**<CNcomment:vo  */
+}HI_UNF_MCE_TSFILE_PARAM_S;
+
+#define ANI_MAX_PIC_SUPPORT (30)
+typedef struct hiUNF_MCE_ANI_PARAM_S
+{
+    HI_U32  u32ContentLen;  /**File length*//**<CNcomment:  */
+    HI_U32  u32PicCount;
+    HI_U32  au32PicTime[ANI_MAX_PIC_SUPPORT];
+}HI_UNF_MCE_ANI_PARAM_S;
+
+/**Play type*//**<CNcomment:*/
+typedef enum hiUNF_MCE_PLAY_TYPE_E
+{
+    HI_UNF_MCE_TYPE_PLAY_DVB     = 0,   /**<DVB type*/ /**<CNcomment:DVB  */
+    HI_UNF_MCE_TYPE_PLAY_TSFILE  = 1,   /**<TS file type*/ /**<CNcomment:ts  */
+    HI_UNF_MCE_TYPE_PLAY_ANI     = 2,   /**<ES file type*/ /**<CNcomment:es  */
+    HI_UNF_MCE_TYPE_PLAY_BUTT
+}HI_UNF_MCE_PLAY_TYPE_E;
+
+
+/**Play configuration*//**<CNcomment: */
+typedef struct hiUNF_MCE_PLAY_PARAM_S
+{
+    HI_UNF_MCE_PLAY_TYPE_E          enPlayType;     /**<Play type*//**<CNcomment:*/
+    HI_BOOL                         bPlayEnable;    /**<Whether play is enable*//**<CNcomment: */
+
+    union
+    {
+        HI_UNF_MCE_DVB_PARAM_S     stDvbParam;      /**<dvb parameter*//**<CNcomment:dvb*/
+        HI_UNF_MCE_TSFILE_PARAM_S  stTsParam;       /**<ts parameter*//**<CNcomment:ts*/
+        HI_UNF_MCE_ANI_PARAM_S     stAniParam;      /**<es parameter*//**<CNcomment:es*/
+    }unParam;
+
+    HI_BOOL                         bContentValid;  /**<whether mce content is valid *//**<CNcomment:mce */
+}HI_UNF_MCE_PLAY_PARAM_S;
+
+/**Mode of Play Control*//**CNcomment: */
+typedef enum hiUNF_MCE_PLAYCTRL_MODE_E
+{
+    HI_UNF_MCE_PLAYCTRL_BY_TIME,    /**<play control by time*//**<CNcomment:*/
+    HI_UNF_MCE_PLAYCTRL_BY_COUNT,   /**<play control by count*//**<CNcomment:*/
+    HI_UNF_MCE_PLAYCTRL_BUTT
+}HI_UNF_MCE_PLAYCTRL_MODE_E;
+
+/**Defines the parameter of fastplay stop*//**CNcomment: */
+typedef struct hiUNF_MCE_STOPPARM_S
+{
+    HI_UNF_AVPLAY_STOP_MODE_E   enStopMode;     /**<Mode of Stop,see ::HI_UNF_AVPLAY_STOP_MODE_E*//**<CNcomment:::HI_UNF_AVPLAY_STOP_MODE_E*/
+    HI_UNF_MCE_PLAYCTRL_MODE_E  enCtrlMode;     /**<Mode of Play Control*//**<CNcomment: */
+    HI_U32                      u32PlayTimeMs;    /**<Play time*//**<CNcomment: */
+    HI_U32                      u32PlayCount;   /**<Play count*//**<CNcomment: */
+} HI_UNF_MCE_STOPPARM_S;
+
+/**Defines the parameter of fastplay exit*//**CNcomment: */
+typedef struct hiUNF_MCE_EXITPARAM_S
+{
+    HI_HANDLE   hNewWin;          /**<Handle of new window*//**<CNcomment: */
+}HI_UNF_MCE_EXITPARAM_S;
+
+/**Defines the parameter of fastplay init*//**CNcomment: */
+typedef struct hiUNF_MCE_INIT_PARAM_S
+{
+    HI_U32      u32Reserved;
+}HI_UNF_MCE_INIT_PARAM_S;
+
+
+/** @} */  /** <!-- ==== Struct Definition end ==== */
+
+/********************************API declaration********************************/
+/** \addtogroup      MCE */
+/** @{ */  /** <!-- [MCE]*/
+
+/**
+\brief init mce  CNcomment:MCE CNend
+\attention \n
+Initializes the media control engine (MCE) before call other MCE API.
+CNcomment:MCE CNend
+\param[in]  pstInitParam  Pointer to MCE init parameter, reserved. CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_MCE_DEV_NOT_EXIST      Device is not exist. CNcomment: CNend
+\retval :: HI_ERR_MCE_NOT_DEVICE      Not a device. CNcomment: CNend
+\retval :: HI_ERR_MCE_DEV_OPEN_ERR      Parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_MCE_Init(HI_UNF_MCE_INIT_PARAM_S *pstInitParam);
+
+/**
+\brief deinit mce  CNcomment:MCE CNend
+\attention \n
+Destroys all MCE resources.  CNcomment:MCE CNend
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_MCE_DeInit(HI_VOID);
+
+/**
+\brief deinit mce  CNcomment: CNend
+\attention \n
+Destroys the logo.  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment: CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_MCE_ClearLogo(HI_VOID);
+
+/**
+\brief  stop fastplay. CNcomment:fastplay CNend
+\attention \n
+If enCtrlMode is HI_UNF_MCE_PLAYCTRL_BY_TIME, u32PlayTime is valid; if enCtrlMode is HI_UNF_MCE_PLAYCTRL_BY_COUNT, u32PlayCount is valid
+CNcomment: enCtrlModeHI_UNF_MCE_PLAYCTRL_BY_TIMEu32PlayTime, HI_UNF_MCE_PLAYCTRL_BY_COUNTu32PlayCount CNend
+\param[in]  pstStopParam  Pointer to fastplay  stop parameter. CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment: CNend
+\retval :: HI_ERR_MCE_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_MCE_PARAM_INVALID      Parameter is invalid. CNcomment CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MCE_Stop(HI_UNF_MCE_STOPPARM_S *pstStopParam);
+
+
+/**
+\brief  Exit fastplay and destrory fastplay source CNcomment:fastplay,fastplay CNend
+\attention \n
+N/A
+\param[in]  pstExitParam  Pointer to fastplay  exit parameter. CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment: CNend
+\retval :: HI_ERR_MCE_PARAM_INVALID      Parameter is invalid. CNcomment CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MCE_Exit(HI_UNF_MCE_EXITPARAM_S *pstExitParam);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_otp.h b/xbmc/platform/linux/hisi/hi_unf_otp.h
new file mode 100644
index 0000000000..f8e05778c5
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_otp.h
@@ -0,0 +1,1121 @@
+/******************************************************************************
+
+  Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2016/10/9
+  Description   :
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the otp module.
+          CNcomment: OTP  CNend
+ */
+#ifndef __HI_UNF_OTP_H__
+#define __HI_UNF_OTP_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+/** CA VendorID */
+typedef enum {
+    HI_UNF_OTP_VENDORID_COMMON     = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_OTP_VENDORID_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_OTP_VENDORID_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_OTP_VENDORID_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_OTP_VENDORID_NDS        = 0x04,        /**<NDS Chipset*/
+    HI_UNF_OTP_VENDORID_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_OTP_VENDORID_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_OTP_VENDORID_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_OTP_VENDORID_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_OTP_VENDORID_SAFEVIEW   = 0x09,        /**<SAFEVIEW CA Chipset*/
+    HI_UNF_OTP_VENDORID_LATENSE    = 0x0a,        /**<LATENSE CA Chipset*/
+    HI_UNF_OTP_VENDORID_SH_TELECOM = 0x0b,        /**<SH_TELECOM CA Chipset*/
+    HI_UNF_OTP_VENDORID_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_OTP_VENDORID_VIACCESS   = 0x0d,        /**<VIACCESS CA Chipset*/
+    HI_UNF_OTP_VENDORID_BUTT
+} HI_UNF_OTP_VENDORID_E;
+
+/** FLASH device types*/
+typedef enum {
+    HI_UNF_OTP_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_OTP_FLASH_TYPE_NAND,           /**<nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_NOR,            /**<nor flash*/
+    HI_UNF_OTP_FLASH_TYPE_EMMC,           /**<eMMC*/
+    HI_UNF_OTP_FLASH_TYPE_SPI_NAND,       /**<spi_nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_OTP_FLASH_TYPE_BUTT
+} HI_UNF_OTP_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum {
+    HI_UNF_OTP_JTAG_MODE_OPEN     = 0,
+    HI_UNF_OTP_JTAG_MODE_PROTECT,
+    HI_UNF_OTP_JTAG_MODE_CLOSED,
+    HI_UNF_OTP_JTAG_MODE_BUTT
+} HI_UNF_OTP_JTAG_MODE_E;
+
+/** Rootkey type*/
+typedef enum {
+    HI_UNF_OTP_OEM_ROOTKEY        = 0,
+    HI_UNF_OTP_HDCP_ROOTKEY,
+    HI_UNF_OTP_STB_ROOTKEY,
+    HI_UNF_OTP_SW_ROOTKEY,
+    HI_UNF_OTP_STBTA_ROOTKEY,
+    HI_UNF_OTP_ROOTKEY_BUTT
+} HI_UNF_OTP_ROOTKEY_E;
+
+/** TA MSID(Trusted Application Market Segment ID) */
+typedef enum {
+    HI_UNF_OTP_TA_INDEX_1 = 0,
+    HI_UNF_OTP_TA_INDEX_2,
+    HI_UNF_OTP_TA_INDEX_3,
+    HI_UNF_OTP_TA_INDEX_4,
+    HI_UNF_OTP_TA_INDEX_5,
+    HI_UNF_OTP_TA_INDEX_6,
+    HI_UNF_OTP_TA_INDEX_BUTT
+} HI_UNF_OTP_TA_INDEX_E;
+
+#define OTP_FIELD_VALUE_MAX_LEN 1024
+#define OTP_FIELD_NAME_MAX_LEN 32
+typedef struct {
+    HI_BOOL bBurn;
+    HI_CHAR aszFieldName[OTP_FIELD_NAME_MAX_LEN]; //32
+    HI_U32 u32ValueLen;
+    HI_U8 au8Value[OTP_FIELD_VALUE_MAX_LEN]; //4
+    HI_BOOL bLock;
+} HI_UNF_OTP_BURN_PV_ITEM_S;
+
+/** UART type
+ChipSet: HI3796MV200/HI3716MV450
+UART0:For REE CPU, TEE CPU and LPMCU.
+UART1:Reserved.
+UART2:Reserved.
+UART3:Only for SMCU
+
+ChipSet: HI3716MV430
+UART0:For REE CPU,SMCU.
+UART1:Reserved.
+UART2:SECURE CPU.
+UART3:Reserved
+*/
+typedef enum {
+    HI_UNF_OTP_UART0 = 0,
+    HI_UNF_OTP_UART1,
+    HI_UNF_OTP_UART2,
+    HI_UNF_OTP_UART3,
+    HI_UNF_OTP_BUTT,
+} HI_UNF_OTP_UART_TYPE_E;
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+#define HI_UNF_OTP_Open(HI_VOID) HI_UNF_OTP_Init(HI_VOID)
+#define HI_UNF_OTP_Close(HI_VOID) HI_UNF_OTP_DeInit(HI_VOID)
+
+/**
+\brief Initializes the otp module. CNcomment:OTP CNend
+\attention \n
+Before calling other functions in this file, you must call this application programming interface (API).
+CNcomment OTP CNend
+\param N/A
+\retval ::HI_SUCCESS  Success.   CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_Init(HI_VOID);
+
+/**
+\brief Deinitializes the otp module. CNcomment:OTP CNend
+\attention \n
+N/A
+\param N/A                                        CNcomment: CNend
+\retval ::HI_SUCCESS  Success.   CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_DeInit(HI_VOID);
+
+
+/**
+\brief Set customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:customer keycustomer key CNend
+\attention \n
+N/A
+\param[in] pKey:  Customer key to be written to otp.                    CNcomment:Customer keyOTP CNend
+\param[in] u32KeyLen:  The length of customer key, must be 16bytes.     CNcomment:Customer key16           CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+/**
+\brief Get customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:customer key CNend
+\attention \n
+N/A
+\param[in] pKey:Buffer to store the customer key read from otp.     CNcomment:customer keybuffer CNend
+\param[in] u32KeyLen:The length of buffer, must be 16bytes.             CNcomment:customer key 16 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+
+/**
+\brief Set stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to set the private data, should be between 0 and 15.  CNcomment:stbprivData0~15 CNend
+\param[in] u8Data:  The private data to be set.                         CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetStbPrivData(HI_U32 u32Offset, HI_U8 u8Data);
+
+/**
+\brief Get stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to get the private data, should be between 0 and 15.  CNcomment:stbprivData0~15 CNend
+\param[out] pu8Data:  The data read from otp.                           CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbPrivData(HI_U32 u32Offset, HI_U8 *pu8Data);
+
+/**
+\brief burn chipset to normal chipset CNcomment: CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToNormalChipset(HI_VOID);
+
+/**
+\brief Burn nomal chipset to secure chipset
+\brief CNcomment: CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToSecureChipset(HI_VOID);
+
+/**
+\brief Get idword lock status CNcomment:IDWord CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to IDWord lock status. CNcomment: CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetIDWordLockFlag(HI_BOOL *pbLockFlag);
+/**
+\brief  Set hdcp root key to otp, 16bytes length.
+\brief CNcomment:hdcp root key16 CNend
+\attention \n
+N/A
+\param[in] pu8RootKey:  Set hdcp root key to otp.                   CNcommenthdcp root keyOTP CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Get hdcp root key from otp, 16bytes length.
+\brief CNcomment:hdcp root key16 CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to hdcp root key from otp.               CNcomment:OTPhdcp root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Lock hdcp root key in otp.
+\brief CNcomment:hdcp root keyhdcp root key CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockHdcpRootKey(HI_VOID);
+
+/**
+\brief  Get hdcp root Key lock flag.
+\brief CNcomment:hdcp root key CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to hdcp root key lock flag from otp.     CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetHdcpRootKeyLockFlag(HI_BOOL *pbLock);
+
+/**
+\brief Set stb root key to otp.
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[in] u8StbRootKey:  Point to stb root key value.                  CNcomment:Stb root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Get stb root key from otp.
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to stb root key from otp.                CNcomment:Stb root key CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Lock stb root key in otp.
+\brief CNcomment:stb root keystb root key CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockStbRootKey(HI_VOID);
+
+/**
+\brief Get stb root Key lock flag
+\brief CNcomment:stb root key CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to stb root key lock flag from otp.      CNcomment: CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbRootKeyLockFlag(HI_BOOL *pbLockFlag);
+
+
+/**
+\brief Get CA Vendor ID. CNcomment: CNend
+\attention \n
+N/A
+\param[out] penVendorID:  CA VendorID. CNcomment: CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetVendorID(HI_UNF_OTP_VENDORID_E *penVendorID);
+
+/**
+\brief Get the serial number of the STB. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8StbSn serial number of the STB. CNcomment: CNend
+\param[in/out] pu32Len point to the length of serial number of the STB, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetStbSN(HI_U8 *pu8StbSN, HI_U32 *pu32Len);
+
+/**
+\brief Set the serial number of the STB. CNcomment: CNend
+\attention \n
+The serial number of the STB is set before delivery. The serial number can be set once only and takes effects after the STB restarts.
+CNcomment: CNend
+\param[in] pu8StbSn point to serial number of the STB. CNcomment: CNend
+\param[in] u32Len The length of serial number of the STB, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetStbSN(HI_U8 *pu8StbSN, HI_U32 u32Len);
+
+/**
+\brief set the type of flash memory for security startup. CNcomment:Flash CNend
+\attention N/A
+\param[in]  enFlashType Type of the flash memory for security startup. CNcomment: Flash CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootMode(HI_UNF_OTP_FLASH_TYPE_E enFlashType);
+
+
+/**
+\brief Disables the self-boot. CNcomment:, boot/ CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:SelfBoot CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Get the self-boot status. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable Pointer to the self-boot status, true means DISABLE. CNcomment:true CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetSelfBootStat(HI_BOOL *pbDisable);
+
+
+/**
+\brief Force decrypt the BootLoader. CNcomment:BootLoader CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment:
+FlashBootLoader CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableBootDecrypt(HI_VOID);
+
+
+/**
+\brief Get the BootLoader Decryption status. CNcomment:BootLoader CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to bootLoader Decryption status. CNcomment:Bootloader CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetBootDecryptStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the security startup. This API should be used after the API HI_UNF_OTP_SetBootMode.
+CNcomment:HI_UNF_OTP_COMMON_SetBootMode CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableSCS(HI_VOID);
+
+
+/**
+\brief Get the security startup status function. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to bootLoader SCS status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetSCSStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the Trust Zone. CNcomment:Trust ZoneCNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableTrustZone(HI_VOID);
+
+
+/**
+\brief Get the Trust Zone status.
+CNcomment:TrustZone CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to trust zone status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetTrustZoneStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the market segment identifier. CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8MSID Point to MSID. CNcomment: CNend
+\param[in/out] pu32Len Point to MSID length, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetMSID(HI_U8 *pu8MSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Set the market segment identifier CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8MSID Point to MSID. CNcomment: CNend
+\param[in/out] u32MSIdLen MSID length, current is 4. CNcomment:4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetMSID(HI_U8 *pu8MSID, HI_U32 u32Len);
+
+
+/**
+\brief Get the secure os market segment identifier CNcomment:OS  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8SOSMSID Point to SOS MSID. CNcomment:OS CNend
+\param[in/out] pu32Len Point to SOS MSID length, current is 4. CNcomment:OS4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the sos market segment identifier CNcomment:OS  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8SOSMSID Point to SOSMSID. CNcomment:OS CNend
+\param[in] u32Len MSID length, current is 4. CNcomment:OS4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 u32Len);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: 16 CNend
+\param[in] pu8Value CNcomment: otp  CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongData(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U8 *pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: 16 CNend
+\param[out] pu8Value CNcomment: otp  CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongData(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U8 *pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: ,16 CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongDataLock(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:LongData CNend
+\attention \n
+None CNcomment: CNend
+\param[in] u32Offset CNcomment: ,16 CNend
+\param[in] u32Length CNcomment: otp,16  CNend
+\param[out] pu32Lock CNcomment: 0,1,2  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongDataLock(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U32 u32Length,  HI_U32 *pu32Lock);
+
+/**
+\brief disable wake up from ddr. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeup(HI_VOID);
+
+
+/**
+\brief Get wake up from ddr status. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbDisable Point to DDR WakeUp status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupStat(HI_BOOL *pbDisable);
+
+/**
+\brief Lock the whole OTP area. CNcomment:OTP CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_LockGlobalOTP(HI_VOID);
+
+
+
+/**
+\brief Get global otp lock status function. CNcomment:OTP CNend
+\attention \n
+None CNcomment: CNend
+\param[out]  pbEnable Point to global OTP lock status. CNcomment:OTP CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetGlobalOTPLockStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable runtime-check. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\param[in]  None
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableRuntimeCheck(HI_VOID);
+
+
+/**
+\brief Get runtime-check status CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to runtime Check status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetRuntimeCheckStat(HI_BOOL *pbEnable);
+
+/**
+\brief Disable DDR wakeup check. CNcomment:CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeupCheck(HI_VOID);
+
+
+/**
+\brief Get ddr wakeup check status. CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Point to DDR Wakeup Check status. CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupCheckStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable ddr scramble. CNcomment: CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_EnableDDRScramble(HI_VOID);
+
+
+/**
+\brief Get ddr scramble status CNcomment:  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbEnable Pointer to DDR Scramble Stat. CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRScrambleStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the mode of the JTAG. CNcomment:JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the JTAG. CNcomment:JTAG CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the mode of the TEE JTAG. CNcomment: TEE JTAG CNend
+\attention \n
+None CNcomment: CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the TEE JTAG. CNcomment: TEE JTAG CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:\n
+\n
+\n
+ CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the boot version identifier CNcomment:boot  CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8VersionID Point to version ID. CNcomment:boot CNend
+\param[in/out] pu32VersionIdLen Point to the length of version ID, current is 4. CNcomment:boot4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetBootVersionID(HI_U8 *pu8VersionID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the boot version identifier CNcomment:boot  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8VersionID Point to version ID. CNcomment:boot CNend
+\param[in] u32Len The length of version ID, current is 4. CNcomment:boot4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootVersionID(HI_U8 *pu8VersionID, HI_U32 u32Len);
+
+
+/**
+\brief Set root key to otp. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enRootkeyType:   Type of rootkey.        CNcomment: CNend
+\param[in] pu8Rootkey: Point to root key value.     CNcomment: CNend
+\param[in] u32Len: The length of root key.          CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRootKey(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_U8 *pu8Rootkey, HI_U32 u32Len);
+
+
+/**
+\brief Get root key lock status.                    CNcomment:OTP CNend
+\attention \n
+N/A
+\param[in] enRootkeyType: Type of rootkey.          CNcomment: CNend
+\param[out] pbLock: Point to root key lock status.  CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRootKeyLockStat(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_BOOL *pbLock);
+
+/**
+\brief Set RSA key to otp. CNcomment:RSA CNend
+\attention \n
+N/A
+\param[in] pu8Key: Point to RSA key value.         CNcomment:RSA CNend
+\param[in] u32KeyLen: The length of RSA key.       CNcomment:RSA CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRSAKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get rsa lock status. CNcomment:RSA lock CNend
+\attention \n
+N/A
+\param[out] pbLock: Rsa lock status.   CNcomment:RSA lock CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRSALockStat(HI_BOOL *pbLock);
+
+
+/**
+\brief Burn product PV to otp. CNcomment:OTP CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment: CNend
+\param[in] u32Num: The nember of config table.         CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/**
+\brief Verify product PV. CNcomment:PV CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment: CNend
+\param[in] u32Num: The nember of config table.         CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_VerifyProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/**
+\brief Set TEE enable lock flag. CNcomment:TEE CNend
+\attention \n
+None CNcomment: CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetTEECtrlLock(HI_VOID);
+
+/**
+\brief Get TEE enable lock flag. CNcomment: TEE CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pbTEEEnL: Point to TEE lock status. CNcomment:TEE CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetTEECtrlLock(HI_BOOL *pbTEEEnL);
+
+/**
+\brief Set the ASC(ACPU Start Code) market segment ID. CNcomment: ASC(ACPU Start Code) CNend
+\attention \n
+None CNcomment: CNend
+\param[in] pu8ASCMSID: Point to ASC market segment ID. CNcomment:ASC CNend
+\param[in] u32Len: ASC market segment ID length, current is 4. CNcomment:ASC 4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetASCMSID (HI_U8 *pu8ASCMSID, HI_U32 u32Len);
+
+/**
+\brief Get the ASC(ACPU Start Code) market segment ID. CNcomment:ASC(ACPU Start Code) CNend
+\attention \n
+None CNcomment: CNend
+\param[out] pu8ASCMSID: Point to ASC market segment identifier. CNcomment:ASC CNend
+\param[in] pu32Len: ASC market segment ID length, current is 4. CNcomment:ASC4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetASCMSID(HI_U8 *pu8ASCMSID, HI_U32 *pu32Len);
+
+/**
+\brief Sets TA ID and TA market segment ID. CNcomment:TA IDTA  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enIndex: TA ID and TA market segment ID index. CNcomment:TA IDTA  CNend
+\param[in] u32TAID: TA ID. CNcomment:TA ID CNend
+\param[in] u32MSID: TA market Segment ID. CNcomment:TA CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_SetTAIDAndMSID(const HI_UNF_OTP_TA_INDEX_E enIndex, HI_U32 u32TAID, HI_U32 u32MSID);
+
+/**
+\brief Get TA ID and TA market segment ID. CNcomment:TA IDTA  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enIndex: TA ID and TA market segment ID index. CNcomment:TA IDTA  CNend
+\param[out] pu32TAID: TA ID. CNcomment:TA ID CNend
+\param[out] pu32MSID: TA market segment ID. CNcomment:TA CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetTAIDAndMSID(const HI_UNF_OTP_TA_INDEX_E enIndex, HI_U32 *pu32TAID, HI_U32 *pu32MSID);
+
+/**
+\brief Disable UART(Universal Asynchronous Receiver/Transmitter) output. CNcomment:UART  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enUartType: UART type. CNcomment:UART  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_NOT_SUPPORT Not support for this chipset. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DisableUART(HI_UNF_OTP_UART_TYPE_E enUartType);
+/**
+\brief Get UART(Universal Asynchronous Receiver/Transmitter) status. CNcomment:UART  CNend
+\attention \n
+None CNcomment: CNend
+\param[in] enUartType: UART type. CNcomment:UART  CNend
+\param[out] pbDisable Pointer to UART Stat. CNcomment:UART CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_NOT_SUPPORT Not support for this chipset. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_GetUARTStat(HI_UNF_OTP_UART_TYPE_E enUartType, HI_BOOL *pbDisable);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_otp_common_ca.h b/xbmc/platform/linux/hisi/hi_unf_otp_common_ca.h
new file mode 100644
index 0000000000..e68f2eff3b
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_otp_common_ca.h
@@ -0,0 +1,267 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_common_ca.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_COMMON_CA_H__
+#define __HI_UNF_OTP_COMMON_CA_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_COMMON_CA */
+/** @{ */  /** <!-- [OTP_COMMON_CA] */
+
+/** advanced CA session serect key class*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV1 = 0,   /**<session serect key level 1*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV2,       /**<session serect key level 2*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV3,       /**<session serect key level 3*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV4,       /**<session serect key level 4*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV5,       /**<session serect key level 5*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_LEV_E;
+
+
+/** advanced CA session serect key class*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_DEMUX_CIPHER = 0,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_DEMUX,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_CIPHER,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_NULL,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E;
+
+
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_CSA2 = 0,
+    HI_UNF_OTP_COMMON_CA_KLAD_CSA3,
+    HI_UNF_OTP_COMMON_CA_KLAD_SP,
+    HI_UNF_OTP_COMMON_CA_KLAD_MISC,
+    HI_UNF_OTP_COMMON_CA_KLAD_R2R,
+    HI_UNF_OTP_COMMON_CA_KLAD_LP,
+    HI_UNF_OTP_COMMON_CA_KLAD_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E;
+
+/** Rootkey type*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_CSA2 = 0,
+    HI_UNF_OTP_COMMON_CA_CSA3,
+    HI_UNF_OTP_COMMON_CA_SP,
+    HI_UNF_OTP_COMMON_CA_MISC,
+    HI_UNF_OTP_COMMON_CA_R2R,
+    HI_UNF_OTP_COMMON_CA_LP,
+    HI_UNF_OTP_COMMON_CA_BOOT,
+    HI_UNF_OTP_COMMON_CA_BUTT
+} HI_UNF_OTP_COMMON_CA_ROOTKEY_E;
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_COMMON_CA */
+/** @{ */  /** <!-- [OTP_COMMON_CA] */
+
+
+/**
+\brief Set the chipID. CNcomment:ID CNend
+\attention \n
+\param[in] pu8ChipID point to chip id. CNcomment:ID CNend
+\param[in] u32Len The length of ChipID, current is 8. CNcomment:ID8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetChipID(HI_U8 *pu8ChipID, HI_U32 u32Len);
+
+
+/**
+\brief Get the chipID. CNcomment:ID CNend
+\attention \n
+\param[out] pu8ChipID point to chip id. CNcomment:ID CNend
+\param[in/out] pu32Len Point to the length of ChipID, current output length is 8. CNcomment:ID8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetChipID(HI_U8 *pu8ChipID, HI_U32 *pu32Len);
+
+
+/**
+\brief Set klad level. CNcomment:keylad CNend
+\attention \n
+N/A
+\param[in] enType: klad type.   CNcomment:Klad CNend
+\param[in] enLevel: klad level. CNcomment:Klad CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetKladLevel(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_LEV_E enLevel);
+
+
+/**
+\brief Get klad level. CNcomment:keylad CNend
+\attention \n
+N/A
+\param[in] enType: klad type.       CNcomment:Klad CNend
+\param[out] penLevel: klad level.   CNcomment:Klad CNend
+\retval ::HI_SUCCESS  Success.      CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.      CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladLevel(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_LEV_E *penLevel);
+
+
+/**
+\brief Set klad target. CNcomment:keylad CNend
+\attention \n
+N/A
+\param[in] enType: klad type.           CNcomment:Klad CNend
+\param[in] enTarget: target type.       CNcomment: CNend
+\retval ::HI_SUCCESS  Success.          CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.          CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetKladTarget(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E enTarget);
+
+
+/**
+\brief Get klad target control. CNcomment:keylad CNend
+\attention \n
+N/A
+\param[in] enType: klad type.           CNcomment:Klad CNend
+\param[out] penTarget: target type.     CNcomment: CNend
+\retval ::HI_SUCCESS  Success.          CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.          CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladTarget(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E *penTarget);
+
+/**
+\brief Disable keyladder. CNcomment:keyladder CNend
+\attention \n
+N/A
+\param[in] enType: klad type.               CNcomment:Klad CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_DisableKlad(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType);
+
+/**
+\brief Get klad disable status. CNcomment:klad CNend
+\attention \n
+N/A
+\param[in] enType: klad type.               CNcomment:Klad CNend
+\param[out] pbEnable:  Klad enable status.  CNcomment:Klad CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladStat(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_BOOL *pbEnable);
+
+
+/**
+\brief Set root key to otp. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enType: Type of keyladder rootkey.       CNcomment: CNend
+\param[in] pu8Key: Point to root key value.         CNcomment: CNend
+\param[in] u32KeyLen: The length of root key.       CNcomment: CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetRootKey(HI_UNF_OTP_COMMON_CA_ROOTKEY_E enType, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get root key lock status.                    CNcomment:OTP CNend
+\attention \n
+N/A
+\param[in] enRootkeyType: Type of rootkey.          CNcomment: CNend
+\param[out] pbLock: Point to root key lock status.  CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetRootKeyLockStat(HI_UNF_OTP_COMMON_CA_ROOTKEY_E enType, HI_BOOL *pbLock);
+
+/**
+\brief Set JTAG key to otp. CNcomment:JTAG CNend
+\attention \n
+N/A
+\param[in] pu8Key: Point to JTAG key value.         CNcomment:JTAG CNend
+\param[in] u32KeyLen: The length of JRAG key.       CNcomment:JTAG CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetJTAGKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get JTAG key lock status.                    CNcomment:JTAG key CNend
+\attention \n
+N/A
+\param[out] pbLock: Point to JTAG key lock status.  CNcomment:JTAG key CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetJTAGKeyLockStat(HI_BOOL *pbLock);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_COMMON_CA_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_otp_customize.h b/xbmc/platform/linux/hisi/hi_unf_otp_customize.h
new file mode 100644
index 0000000000..755245c3b2
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_otp_customize.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_verimatrix.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_CUSTOMIZE_H__
+#define __HI_UNF_OTP_CUSTOMIZE_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_CUSTOMIZE */
+/** @{ */  /** <!-- [OTP_CUSTOMIZE] */
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_CUSTOMIZE */
+/** @{ */  /** <!-- [OTP_CUSTOMIZE] */
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_CUSTOMIZE_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_otp_dcas.h b/xbmc/platform/linux/hisi/hi_unf_otp_dcas.h
new file mode 100644
index 0000000000..a8319c8e85
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_otp_dcas.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_dcas.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_DCAS_H__
+#define __HI_UNF_OTP_DCAS_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_DCAS */
+/** @{ */  /** <!-- [OTP_DCAS] */
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_DCAS */
+/** @{ */  /** <!-- [OTP_DCAS] */
+
+
+/**
+\brief Get the chipID. CNcomment:ID CNend
+\attention \n
+\param[out] pu8ChipID point to chip id. CNcomment:ID CNend
+\param[in/out] pu32Len Point to the length of ChipID, current output length is 8. CNcomment:ID8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment: CNend
+\see \n
+None CNcomment: CNend
+*/
+HI_S32 HI_UNF_OTP_DCAS_GetChipID(HI_U8 *pu8ChipID, HI_U32 *pu32Len);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_DCAS_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_payloadcipher.h b/xbmc/platform/linux/hisi/hi_unf_payloadcipher.h
new file mode 100644
index 0000000000..a7bd8daaa6
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_payloadcipher.h
@@ -0,0 +1,239 @@
+/******************************************************************************
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name   :  hi_unf_payloadcipher.h
+Author        :  Hisilicon multimedia software group
+Created      :  2016/10/21
+Description :
+******************************************************************************/
+#ifndef __HI_UNF_PAYLOADCIPHER_H__
+#define __HI_UNF_PAYLOADCIPHER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PayloadCipher */
+/** @{ */  /** <!-- [PayloadCipher] */
+
+/** Max pidFilter Num */
+/**CNcomment:PID*/
+#define HI_UNF_PLCIPHER_PIDFILTER_NUM 16
+
+/** PLCipher algorithm */
+/** CNcomment:PLCipher*/
+typedef enum
+{
+    HI_UNF_PLCIPHER_ALG_AES_IPTV            = 0x20,  /**<AES IPTV*/
+    HI_UNF_PLCIPHER_ALG_AES_ECB             = 0x21,  /**<AES ECB*/
+    HI_UNF_PLCIPHER_ALG_AES_CBC             = 0x22,  /**<AES CBC*/
+    HI_UNF_PLCIPHER_ALG_AES_CISSA           = 0x23,  /**<AES CISSA*/
+    HI_UNF_PLCIPHER_ALG_BUTT                = 0x84
+}HI_UNF_PLCIPHER_ALG_E;
+
+/** PLCipher Key Type */
+/** CNcomment:PLCipher Key */
+typedef enum
+{
+    HI_UNF_PLCIPHER_KEY_EVEN       = 0,   /**< Even key type */ /**< CNcomment:KEY*/
+    HI_UNF_PLCIPHER_KEY_ODD        = 1,   /**< Odd key type */ /**< CNcomment:KEY*/
+    HI_UNF_PLCIPHER_KEY_BUTT,
+}HI_UNF_PLCIPHER_KEY_EVENODD_E;
+
+/** Structure of the plcipher control information */
+/** CNcomment: */
+typedef struct
+{
+    HI_UNF_PLCIPHER_ALG_E enAlg;                   /**< Algorithm  type*/ /**< CNcomment:*/
+    HI_BOOL bPIDFilterEn;                          /**< Pid filter switch, default disable, plcipher will encrypt all pids in the ts when the switch is setted with HI_FALSE, and plcipher will just encrypt the assigned pids when the switch is setted with HI_TRUE*/
+                                                   /**< CNcomment:Pid plcipherTSPIDplcipherPID*/
+    HI_U32  u32PidNum;                             /**< valid when bPIDFilterEn is HI_TRUE, the pid number need to be filted.*/ /**< CNcomment:bPIDFilterEnHI_TRUEPID*/
+    HI_U16  u16PID[HI_UNF_PLCIPHER_PIDFILTER_NUM]; /**< valid when bPIDFilterEn is HI_TRUE, the pid arrays need to be filted.*/ /**< CNcomment:bPIDFilterEnHI_TRUEPID*/
+    HI_UNF_PLCIPHER_KEY_EVENODD_E enEvenOdd;       /**< Even Odd type, for keyladder encrypt even or odd key set */ /**< CNcomment:keyladder */
+} HI_UNF_PLCIPHER_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PayloadCipher */
+/** @{ */  /** <!--[PayloadCipher]*/
+
+/**
+\brief Initializes the PLCIPHER module.CNcomment:PLCIPHERCNend
+\attention \n
+Before using PLCIPHERs, you must call this application programming interface (API).\n
+Before using the ts level encryption function, you need to initialize the PLCIPHER module.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:PLCIPHER\n
+TSPLCIPHER\n
+CNend
+\param  N/A.CNcomment:CNend
+\retval ::HI_SUCCESS Success. CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\see \n
+N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Init(HI_VOID);
+
+/**
+\brief Deinitializes the PLCIPHER module. CNcomment:PLCIPHERCNend
+\attention \n
+After this API is called, the PLCIPHER module is stopped, and the PLCIPHER resources used by the process are released.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:PLCIPHERPLCIPHER\n
+CNend
+\param  N/A.CNcomment:CNend
+\retval ::HI_SUCCESS Success CNcomment:CNend
+\retval ::HI_FAILURE Calling this API fails. CNcomment:APICNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_DeInit(HI_VOID);
+
+/**
+\brief Creates a PLCIPHER channel for encryption.CNcomment:PLCIPHERCNend
+\param[out] phPLCipher     Pointer to the handle of a PLCIPHER.CNcomment:PLCIPHER HandleCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_FAILED_GETHANDLE There is no more PLCIPHER channel left. CNcomment:PLCIPHERCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Create(HI_HANDLE *phPLCipher);
+
+/**
+\brief Destroys an existing PLCIPHER channel.CNcomment:PLCIPHERCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel to be destroyed.CNcomment:PLCIPHER CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Destroy(HI_HANDLE hPLCipher);
+
+/**
+\brief Gets the attributes of a PLCIPHER channel.CNcomment:PLCIPHERCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[out] pstAttr  Pointer to the attributes of a PLCIPHER channel.CNcomment:PLCIPHERCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_GetAttr(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the attributes of a PLCIPHER channel.CNcomment:PLCIPHERCNend
+\attention \n
+plcipher will encrypt all pids in the ts when bPIDFilterEn is setted with HI_FALSE,\n
+and plcipher will just encrypt the assigned pids when bPIDFilterEn is setted with HI_TRUE.
+CNcomment:bPIDFilterEn HI_FALSEplcipherTSPIDbPIDFilterEn HI_TRUEplcipherPIDCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[in] pstAttr  Pointer to the attributes of a PLCIPHER channel.CNcomment:PLCIPHERCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_SetAttr(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the CW keys of a PLCIPHER channel. This API is used to configure the PLCIPHER channel.CNcomment:PLCIPHERPLCIPHERCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[in] enKeyEvenOdd  Type of CW key odd or even.CNcomment:CNend
+\param[in] pu8Key  Pointer to odd or even CW key buffer to be set, always a 8 or 16 bytes array.CNcomment:816CNend
+\param[in] u32KeyLen  The length of CW key data to be set, always 8 or 16.CNcomment:816CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_SetKey(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_KEY_EVENODD_E enKeyEvenOdd, const HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets the IV vector of a PLCIPHER channel. This API is used to configure the PLCIPHER channel.CNcomment:PLCIPHERIVPLCIPHERIVCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[in] enIVEvenOdd  Type of IV vector odd or even.CNcomment:IVCNend
+\param[in] pu8IV  Pointer to odd or even IV vector buffer to be set, always a 8 or 16 bytes array.CNcomment:IV816CNend
+\param[in] u32IVLen  The length of IV vector to be set, always 8 or 16.CNcomment:IV816CNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+
+HI_S32 HI_UNF_PLCIPHER_SetIV(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_KEY_EVENODD_E enIVEvenOdd, const HI_U8 *pu8IV, HI_U32 u32IVLen);
+
+/**
+\brief Encrypt TS package data in a PLCIPHER channel.CNcomment:PLCIPHERTSTSCNend
+\attention \n
+PLCIPHER support pSrcBuf and pDestBuf are the same address, in other word, PLCIPHER support encryption at the same adress.
+CNcomment:PLCIPHERpSrcBufpDestBufPLCIPHERCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[in] pSrcBuf  The physical address(must be 16 bytes align) of TS package data to be encrypted.CNcomment:VOIDTS16CNend
+\param[in] pDestBuf  The physical address(must be 16 bytes align) of the encryted TS package data.CNcomment:VOIDTS16CNend
+\param[in] u32Length  The length of TS package data to be encrypted.CNcomment:TSCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Encrypt(HI_HANDLE hPLCipher, HI_VOID* pSrcBuf, HI_VOID* pDestBuf, HI_U32 u32Length);
+
+/**
+\brief Decrypt TS package data in a PLCIPHER channel.CNcomment:PLCIPHERTSTSCNend
+\attention \n
+PLCIPHER support pSrcBuf and pDestBuf are the same address, in other word, PLCIPHER support decryption at the same adress.
+CNcomment:PLCIPHERpSrcBufpDestBufPLCIPHERCNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER CNend
+\param[in] pSrcBuf  The physical address(must be 16 bytes align) of TS package data to be decrypted.CNcomment:VOIDTS16CNend
+\param[in] pDestBuf  The physical address(must be 16 bytes align) of the decryted TS package data.CNcomment:VOIDTS16CNend
+\param[in] u32Length  The length of TS package data to be decrypted.CNcomment:TSCNend
+\retval ::HI_SUCCESS Success.CNcomment:CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:APICNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:PLCIPHERCNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:CNend
+\see \n
+ N/A.CNcomment:CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Decrypt(HI_HANDLE hPLCipher, HI_VOID* pSrcBuf, HI_VOID* pDestBuf, HI_U32 u32Length);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_PAYLOADCIPHER_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_pdm.h b/xbmc/platform/linux/hisi/hi_unf_pdm.h
new file mode 100644
index 0000000000..a5e3567d44
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_pdm.h
@@ -0,0 +1,443 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2014, HiSilicon Technologies Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_pdm.h
+  Version       : Initial Draft
+  Author        : HiSilicon multimedia software group
+  Created       : 2011-xx-xx
+  Description   : hi_unf_pdm.h header file
+  History       :
+  1.Date        : 2011/xx/xx
+    Author      :
+    Modification: This file is created.
+
+******************************************************************************/
+
+#ifndef __HI_UNF_PDM_H__
+#define __HI_UNF_PDM_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_mce.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PDM */
+/** @{ */  /** <!-- [PDM] */
+
+/**Defines the base config parameter*/
+/** CNcomment:*/
+typedef struct hiUNF_PDM_DISP_PARAM_S
+{
+    HI_UNF_DISP_E               enSrcDisp;          /**<source display*//**<CNcomment: display*/
+    HI_UNF_ENC_FMT_E            enFormat;           /**<Format*//**<CNcomment: */
+    HI_U32                      u32Brightness;      /**<Brightness*//**<CNcomment: */
+    HI_U32                      u32Contrast;        /**<Contrast*//**<CNcomment: */
+    HI_U32                      u32Saturation;      /**<Saturation*//**<CNcomment: */
+    HI_U32                      u32HuePlus;         /**<HuePlus*//**<CNcomment: */
+    HI_BOOL                     bGammaEnable;       /**<Is Gamma enable*//**<CNcomment: gamma*/
+    HI_UNF_DISP_BG_COLOR_S      stBgColor;          /**<Background Color*//**<CNcomment: */
+    HI_UNF_DISP_INTF_S          stIntf[HI_UNF_DISP_INTF_TYPE_BUTT];     /**<configuration of display interface*//**<CNcomment: */
+    HI_UNF_DISP_TIMING_S        stDispTiming;       /**<Display timeing*//**<CNcomment: */
+
+    HIGO_PF_E                   enPixelFormat;      /**<Pixel format*//**<CNcomment: */
+    HI_UNF_DISP_OFFSET_S        stDispOffset;       /**<Display margin info*//**<CNcomment: */
+    HI_U32                      u32VirtScreenWidth; /**<Virtual screen width*//**<CNcomment: */
+    HI_U32                      u32VirtScreenHeight;    /**<Virtual screen height*//**<CNcomment: */
+
+    HI_UNF_DISP_ASPECT_RATIO_S  stAspectRatio;      /**<The device aspect ratio*//**<CNcomment: */
+    HI_UNF_HDMI_VIDEO_MODE_E    enVidOutMode;       /**<HDMI output vedio mode*//**<CNcomment:HDMI*/
+    HI_UNF_HDMI_DEEP_COLOR_E    enDeepColorMode;    /**<Deep Color output mode*//**<CNcomment:DeepColor*/
+}HI_UNF_PDM_DISP_PARAM_S;
+
+typedef struct hiUNF_PDM_SOUND_PARAM_S
+{
+    HI_U32                    u32PortNum;  /**<Outport number attached sound*/ /**<CNcomment:Sound*/
+    HI_UNF_SND_OUTPORT_S stOutport[HI_UNF_SND_OUTPUTPORT_MAX];  /**<Outports attached sound*/ /**<CNcomment:Sound*/
+    HI_U32               au32Volume[HI_UNF_SND_OUTPUTPORT_MAX];
+}HI_UNF_PDM_SOUND_PARAM_S;
+
+typedef struct hiUNF_PDM_PMOC_PARAM_S
+{
+    HI_U32      u32Flag;  /**<Restore the standby mode, 1: enable; 0: disable>*/ /**<CNcomment:1:; 0:*/
+}HI_UNF_PDM_PMOC_PARAM_S;
+
+typedef enum hiUNF_PDM_BASEPARAM_TYPE_E
+{
+    HI_UNF_PDM_BASEPARAM_DISP0 = 0,     /*HI_UNF_PDM_DISP_PARAM_S * */
+    HI_UNF_PDM_BASEPARAM_DISP1,         /*HI_UNF_PDM_DISP_PARAM_S * */
+    HI_UNF_PDM_BASEPARAM_SOUND0 = 10,
+    HI_UNF_PDM_BASEPARAM_SOUND1,
+    HI_UNF_PDM_BASEPARAM_SOUND2,
+    HI_UNF_PDM_BASEPARAM_HDMI = 20,
+    HI_UNF_PDM_BASEPARAM_PMOC = 30,
+
+    HI_UNF_PDM_BASEPARAM_BUTT = 0xFFFF,
+}HI_UNF_PDM_BASEPARAM_TYPE_E;
+
+typedef struct hiUNF_PDM_HDMI_PARAM_S
+{
+    HI_U8    *pu8EDID;
+    HI_U32   *pu32EDIDLen;
+}HI_UNF_PDM_HDMI_PARAM_S;
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PDM */
+/** @{ */  /** <!-- [PDM] */
+/**
+\brief Obtains the basic configuration information.  CNcomment:BASE CNend
+\attention \n
+N/A
+\param[in]  pstBaseParam   Pointer to the basic parameters.  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetBaseParam(HI_UNF_PDM_BASEPARAM_TYPE_E enType, HI_VOID *pData);
+
+
+/**
+\brief Modifies the basic configuration information.  CNcomment:BASE CNend
+\attention \n
+N/A
+\param[in]  pstBaseParam Pointer to the basic parameters.  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateBaseParam(HI_UNF_PDM_BASEPARAM_TYPE_E enType, HI_VOID *pData);
+
+/**
+\brief Obtains the basic configuration information from the flash memory.
+CNcomment:LOGO CNend
+\attention \n
+N/A
+\param[in]  pstLogoParam   Pointer to the logo parameter  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetLogoParam(HI_UNF_MCE_LOGO_PARAM_S *pstLogoParam);
+
+/**
+\brief Modifies the configuration of the logo parameter.  CNcomment:LOGO CNend
+\attention \n
+Update logo parameter, you must invoke this function befor update data of logo
+\CNcomment:logologo CNend
+\param[in]  pstLogoParam   Pointer to the logo parameter  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateLogoParam(HI_UNF_MCE_LOGO_PARAM_S *pstLogoParam);
+
+
+/**
+\brief Obtains the logo data from the flash memory. CNcomment:LOGO CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the logo data that is written from the flash memory CNcomment:buf CNend
+\param[in]  u32Size  Size of the logo data to be written  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetLogoContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Modifies the logo data.  CNcomment:LOGO CNend
+\attention \n
+Update data in logo partition, You must invoke HI_UNF_PDM_UpdateLogoParam to update logo parameter before invoke this function
+\CNcomment:logoHI_UNF_PDM_UpdateLogoParamlogo CNend
+\param[in]  pu8Content   Pointer to the logo data that is read from the flash memory  CNcomment:buf CNend
+\param[in]  u32Size   Size of the logo data to be read  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateLogoContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+/**
+\brief Obtains the playing configuration information.  CNcomment:PLAY CNend
+\attention \n
+N/A
+\param[in]  pstPlayParam   Playing configuration information  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief   Modifies the playing configuration information.  CNcomment:PLAY CNend
+\attention \n
+Update play parameter, you must invoke this function befor update data of play
+\CNcomment:playplay CNend
+\param[in]  pstPlayParam  Playing configuration information  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief Obtains the data being playing from the flash memory.  CNcomment:PLAY CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the data that is read from the flash memory  CNcomment:buf CNend
+\param[in]  u32Size  Size of the data being played that is read from the flash memory  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Updates the playing data part. CNcomment:PLAY CNend
+\attention \n
+Update data in play partition, You must invoke HI_UNF_PDM_UpdatePlayParam to update plat parameter before invoke this function
+\CNcomment:playHI_UNF_PDM_UpdatePlayParamplay CNend
+\param[in]  pu8Content  Pointer to the data that is written to the flash memroy  CNcomment:buf CNend
+\param[in]  u32Size  Size of the data being played  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+/**
+\brief Obtains the playing configuration information from backup partition.  CNcomment:PLAY CNend
+\attention \n
+N/A
+\param[in]  pstPlayParam   Playing configuration information  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayBakParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief   Modifies the playing configuration information to backup partition.  CNcomment:PLAY CNend
+\attention \n
+Update play parameter, you must invoke this function befor update data of play
+\CNcomment:playplay CNend
+\param[in]  pstPlayParam  Playing configuration information  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayBakParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief Obtains the playing content from backup partition.  CNcomment:PLAY CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the data that is read from the flash memory  CNcomment:buf CNend
+\param[in]  u32Size  Size of the data being played that is read from the flash memory  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayBakContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Updates the playing content to backup partition. CNcomment:PLAY CNend
+\attention \n
+Update data in play partition, You must invoke HI_UNF_PDM_UpdatePlayBakParam to update plat parameter before invoke this function
+\CNcomment:playHI_UNF_PDM_UpdatePlayBakParamplay CNend
+\param[in]  pu8Content  Pointer to the data that is written to the flash memroy  CNcomment:buf CNend
+\param[in]  u32Size  Size of the data being played  CNcomment: CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayBakContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Obtains the device cfg info.  CNcomment: CNend
+\attention \n
+N/A
+\param[in]  pstrCfgName Pointer to the cfg name,for exampe,
+"MAC" to get the MAC address,"SN" to get the SN number.
+Other configure items can be refered from the Readme file and BurnConfig.ini in HiproInfo tool directory.
+CNcomment:,"MAC"MAC,"SN"SN,
+HiproInfo Readme CNend
+\param[in]  pstrCfgValue Pointer to the cfg output buffer  CNcomment:
+bufferbuffer CNend
+\param[in]  u32Size  Size of the output buffer  CNcomment:buffer CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error.
+CNcomment:Flash CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:
+Flash CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment
+: CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:
+Flash CNend
+\retval :: HI_ERR_PDM_GET_DEVINFO_ERR      Parse device info failed. CNcomment
+:device info  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PDM_GetDeviceInfo(const HI_CHAR * pstrCfgName, HI_CHAR * pstrCfgValue, HI_U32 u32Size);
+
+/**
+\brief Get specific Reserve mem data. when the target buffer less than Reserve mem, this function
+can only get "u32Size" size data or the whole data will be obtained.CNcomment:.
+bufferu32Size CNend
+\attention \n
+\param[in]  pstrName  Pointer to the reserve memery name  CNcomment: CNend
+\param[in]  pBuf  Pointer to the out buffer used to get data  CNcomment:buffer CNend
+\param[in]  u32Size  The size of the pBuf  CNcomment: pBuf  CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_PARAM_INVALID para invalid. CNcomment: CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_INVALID_OPT   The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PDM_GetReserveMemData(const HI_CHAR *pstrName, HI_VOID *pBuf, HI_U32 u32Size);
+
+/**
+\brief Get specific Reserve mem addr .CNcomment:. CNend
+\attention \n
+\param[in]   pstrName  Pointer to the reserve memery name  CNcomment: CNend
+\param[out]  pPhyAddr  Pointer to Phyaddr  CNcomment: CNend
+\param[out]  pVirAddr  Pointer to Viraddr  CNcomment:  CNend
+\param[out]  pBufLen   The size of reserve mem  CNcomment:  CNend
+\retval ::HI_SUCCESS       Success. CNcomment: CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment: CNend
+\retval :: HI_ERR_PDM_PARAM_INVALID para invalid. CNcomment: CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment: CNend
+\retval :: HI_ERR_PDM_INVALID_OPT   The operation is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetReserveMemAddr(const HI_CHAR *pstrName, HI_U64 *pPhyAddr,  HI_U8 *pVirAddr, HI_U32 *pBufLen);
+
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+
+
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_pmoc.h b/xbmc/platform/linux/hisi/hi_unf_pmoc.h
new file mode 100644
index 0000000000..609df2b17f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_pmoc.h
@@ -0,0 +1,479 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_pmoc.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the PMOC
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_PMOC_H__
+#define __HI_UNF_PMOC_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#include "hi_unf_keyled.h"
+
+#include "hi_unf_ir.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PMOC */
+/** @{ */  /** <!-- [PMOC] */
+
+/**ARM mode*/
+/**CNcomment:ARM*/
+typedef enum hiUNF_PMOC_MODE_E
+{
+    HI_UNF_PMOC_MODE_NORMAL = 0,    /**<Normal*/     /**<CNcomment: */
+    HI_UNF_PMOC_MODE_SLOW,          /**<Not support*/ /**<CNcomment:  */
+    HI_UNF_PMOC_MODE_DOZE,          /**<Not support*/ /**<CNcomment:  */
+    HI_UNF_PMOC_MODE_SLEEP,         /**<Sleep*/      /**<CNcomment: */
+
+    HI_UNF_PMOC_MODE_BUTT
+}HI_UNF_PMOC_MODE_E;
+
+
+/**standby woken type*/
+/**CNcomment: */
+typedef enum hiUNF_PMOC_ACTUAL_WKUP_E
+{
+    HI_UNF_PMOC_WKUP_IR = 0,      /**<Woken by the IR module*/                /**<CNcomment:IR */
+    HI_UNF_PMOC_WKUP_KEYLED,      /**<Woken by the keys on the front panel*/  /**<CNcomment:KEY */
+    HI_UNF_PMOC_WKUP_TIMEOUT,     /**<Woken by the timing interrupt*/         /**<CNcomment: */
+    HI_UNF_PMOC_WKUP_ETH,         /**<Woken by the ethernet interrupt*/       /**<CNcomment: */
+    HI_UNF_PMOC_WKUP_USB,         /**<Woken by the USB interrupt*/            /**<CNcomment:USB */
+    HI_UNF_PMOC_WKUP_GPIO,        /**<Woken by the GPIO interrupt*/           /**<CNcomment:GPIO */
+    HI_UNF_PMOC_WKUP_CEC,        /**<Woken by the CEC */                     /**<CNcomment:CEC  */
+    HI_UNF_PMOC_WKUP_BUTT
+}HI_UNF_PMOC_ACTUAL_WKUP_E;
+
+typedef enum hiUNF_PMOC_SCENE_E
+{
+    HI_UNF_PMOC_SCENE_STANDARD = 0,  /**<Standard scenario*/                    /**<CNcomment: */
+    HI_UNF_PMOC_SCENE_ETH,           /**<Forward scenario over the ETH port */  /**<CNcomment:() */
+    HI_UNF_PMOC_SCENE_PHONE,         /**<Calling scenario(not support)*/        /**<CNcomment:() */
+    HI_UNF_PMOC_SCENE_BUTT
+}HI_UNF_PMOC_SCENE_E;
+
+typedef enum hiUNF_PMOC_ETH_E
+{
+    HI_UNF_PMOC_ETH_0 = 0x01,        /**<The first ETH.*/    /**<CNcomment:1*/
+    HI_UNF_PMOC_ETH_1 = 0x02,        /**<The second ETH.*/   /**<CNcomment:2*/
+    HI_UNF_PMOC_ETH_BUTT = 0x04
+}HI_UNF_PMOC_ETH_E;
+
+/**Defines the modules working in smart standby */
+/**CNcomment: */
+typedef enum hiUNF_PMOC_HOLD_MOD_E
+{
+    HI_UNF_PMOC_HOLD_ETH = 0x0001,   /**<Keep eth working */    /**<CNcomment: */
+    HI_UNF_PMOC_HOLD_WIFI = 0x0002,  /**<Keep WIFI working */   /**<CNcomment:WIFI */
+    HI_UNF_PMOC_HOLD_USB = 0x0004,   /**<Keep USB working */    /**<CNcomment:USB */
+    HI_UNF_PMOC_HOLD_TUNER = 0x0008, /**<Keep tuner working */  /**<CNcomment:Tuner */
+    HI_UNF_PMOC_HOLD_DEMUX = 0x0010, /**<Keep demux working */  /**<CNcomment:Demux */
+    HI_UNF_PMOC_HOLD_SDIO = 0x0020,  /**<Keep SDIO working */   /**<CNcomment:SD */
+    HI_UNF_PMOC_HOLD_SCI = 0x0040,   /**<Keep SCI working */    /**<CNcomment:SCI */
+    HI_UNF_PMOC_HOLD_VENC = 0x0080,  /**<Keep VENC working */   /**<CNcomment:VENC */
+    HI_UNF_PMOC_HOLD_PNG = 0x0100,   /**<Keep PNG working */    /**<CNcomment:PNG */
+    HI_UNF_PMOC_HOLD_JPGE = 0x0200,  /**<Keep JPGE working */   /**<CNcomment:JPGE */
+    HI_UNF_PMOC_HOLD_JPEG = 0x0400,  /**<Keep JPEG working */   /**<CNcomment:JPEG */
+    HI_UNF_PMOC_HOLD_WDG = 0x0800,   /**<Keep WDG working */    /**<CNcomment:WDG */
+    HI_UNF_PMOC_HOLD_HDMI = 0x1000,  /**<Keep HDMI working */   /**<CNcomment:HDMI */
+    HI_UNF_PMOC_HOLD_VO = 0x2000,    /**<Keep VO working */     /**<CNcomment:VO */
+    HI_UNF_PMOC_HOLD_DISP = 0x4000,  /**<Keep DISP working */   /**<CNcomment:DISP */
+    HI_UNF_PMOC_HOLD_AO = 0x8000,    /**<Keep AO working */     /**<CNcomment:AO */
+    HI_UNF_PMOC_HOLD_AI = 0x10000,   /**<Keep AI working */     /**<CNcomment:AI */
+    HI_UNF_PMOC_HOLD_ADSP = 0x20000, /**<Keep ADSP working */   /**<CNcomment:ADSP */
+    HI_UNF_PMOC_HOLD_CIPHER = 0x40000, /**<Keep CIPHER working */   /**<CNcomment:CIPHER */
+    HI_UNF_PMOC_HOLD_VDEC = 0x80000, /**<Keep VDEC working */   /**<CNcomment:VDEC */
+    HI_UNF_PMOC_HOLD_VPSS = 0x100000, /**<Keep VPSS working */  /**<CNcomment:VPSS */
+    HI_UNF_PMOC_HOLD_OTP = 0x200000, /**<Keep OTP working */    /**<CNcomment:OTP */
+    HI_UNF_PMOC_HOLD_TDE = 0x400000, /**<Keep TDE working */    /**<CNcomment:TDE */
+    HI_UNF_PMOC_HOLD_I2C = 0x800000, /**<Keep I2C working */    /**<CNcomment:I2C */
+    HI_UNF_PMOC_HOLD_GPIO = 0x1000000,/**<Keep GPIO working */  /**<CNcomment:GPIO */
+    HI_UNF_PMOC_HOLD_BUTT = 0x80000000,
+}HI_UNF_PMOC_HOLD_MOD_E;
+
+#define PMOC_WKUP_IRKEY_MAXNUM 6
+#define FILTER_VALUE_COUNT   (31)
+#define FILTER_COUNT         (4)
+
+typedef struct hiUNF_PMOC_WAKEUP_FRAME
+{
+    HI_U32  u32MaskBytes;  /**<Mask byte, bitN to control u8Value[N]. 0: invalid, 1: valid*/  /**<CNcomment: value, bitNu8Value[N], 01 */
+    HI_U8   u8Offset;      /**<Filter offset, should be bigger than or equal to 12*/          /**<CNcomment: 12*/
+    HI_U8   u8Value[FILTER_VALUE_COUNT];   /**<Filter value*/                                 /**<CNcomment: */
+    HI_BOOL bFilterValid;  /**<Valid filter, 0: invalid, 1: valid*/                           /**<CNcomment: 01*/
+}HI_UNF_PMOC_WAKEUP_FRAME_S, *HI_UNF_WAKEUP_FRAME_S_PTR;
+
+typedef struct hiUNF_PMOC_NETWORK
+{
+    HI_UNF_PMOC_ETH_E          enEthIndex;         /**<Eth index, can set several eth once*/  /**<CNcomment: */
+    HI_BOOL                    bUcPacketEnable;    /**<Single packet enable*/                 /**<CNcomment:  */
+    HI_BOOL                    bMagicPacketEnable; /**<Magic packet enable*/                  /**<CNcomment: */
+    HI_BOOL                    bWakeupFrameEnable; /**<Wakeup Frame enable*/                  /**<CNcomment:  */
+    HI_UNF_PMOC_WAKEUP_FRAME_S stFrame[FILTER_COUNT];         /**<Filter frame*/              /**<CNcomment:  */
+    HI_U32                     u32TimeToDeepStandby;          /**<time to deep standby(unit:s)*/      /**<CNcomment: (:) */
+}HI_UNF_PMOC_NETWORK_S, *HI_UNF_PMOC_NETWORK_S_PTR;
+
+/**Defines the standby wake-up conditions.*/
+/**CNcomment:*/
+typedef struct hiUNF_PMOC_WKUP_S
+{
+    /**<Number of supported values of the power key. For the raw IR remote control, the number cannot be greater than the maximum key value 6 that is defined by the macro definition PMOC_WKUP_IRKEY_MAXNUM. Only one key value is supported for other remote controls.*/
+    /**<CNcomment:powerraw : PMOC_WKUP_IRKEY_MAXNUM(<=6)*/
+    HI_U32 u32IrPmocNum;
+
+    HI_U32 u32IrPowerKey0[PMOC_WKUP_IRKEY_MAXNUM];  /**<Lower-bit value of the power key on an IR remote control*/  /**<CNcomment: power  */
+    HI_U32 u32IrPowerKey1[PMOC_WKUP_IRKEY_MAXNUM];  /**<Upper-bit value of the power key on an IR remote control*/  /**<CNcomment: power  */
+    HI_U32 u32IrSymbol[64];                         /**<Value of the raw power key of IR*/                          /**<CNcomment: */
+    HI_U32 u32KeypadPowerKey;                           /**<Value of the power key*/                                    /**<CNcomment: power */
+    HI_U32 u32WakeUpTime;                               /**<Preconfigured Wake-up time, in second*/                     /**<CNcomment: ,   */
+    HI_UNF_PMOC_NETWORK_S stNetwork;                    /**<Network parameter*/                                         /**<CNcomment:*/
+    HI_BOOL bMouseKeyboardEnable;                       /**<Mouse and key wake-up enable*/                              /**<CNcomment:*/
+    HI_BOOL bResumeResetEnable;                         /**<When resume, reset board enable*/                           /**<CNcomment:*/
+    HI_BOOL bGpioWakeUpEnable;                          /**<Gpio wake up enable */                                      /**<CNcomment:GPIO*/
+    HI_U32 u32GpioNo;                                   /**<Gpio wake up number */                                      /**<CNcomment:GPIO*/
+    HI_BOOL bCECWakeUpEnable;                          /**< CEC wake up enable */                                      /**<CNcomment:CEC*/
+}HI_UNF_PMOC_WKUP_S, *HI_UNF_PMOC_WKUP_S_PTR;
+
+/**Configures the time displayed on the front panel in standby mode.*/
+/**CNcomment: */
+typedef struct hiUNF_PMOC_TIME_S
+{
+    HI_U32 u32Hour;            /**<Hour*/     /**<CNcomment: */
+    HI_U32 u32Minute;          /**<Minute*/   /**<CNcomment: */
+    HI_U32 u32Second;          /**<Second*/   /**<CNcomment: */
+}HI_UNF_PMOC_TIME_S, *HI_UNF_PMOC_TIME_S_PTR;
+
+/**Configures the display mode of the front panel in standby mode.*/
+/**CNcomment: */
+typedef struct hiUNF_PMOC_STANDBY_MODE_S
+{
+    HI_U32             u32Mode;      /**<0: no display; 1: display the digits represented by u32DispCod; 2: display the time represented by stTimeInfo*/     /**<CNcomment:0 :  1 : u32DispCode; 2 : stTimeInfo. */
+    HI_U32             u32DispCode;  /**<Digits displayed on the front panel when u32Mode is 1, value range from 0000 to 9999, do not support hex */         /**<CNcomment:u32Mode10000999916 */
+    HI_UNF_PMOC_TIME_S stTimeInfo; /**<Time displayed on the front panel when u32Mode is 2*/                                                                 /**<CNcomment:u32Mode2*/
+}HI_UNF_PMOC_STANDBY_MODE_S, *HI_UNF_PMOC_STANDBY_MODE_S_PTR;
+
+/**Type of the device that is woken in standby mode*/
+/**CNcomment: */
+typedef struct hiUNF_PMOC_DEV_TYPE_S
+{
+    HI_UNF_IR_CODE_E     irtype;    /**<Type of the IR remote control*/  /**<CNcomment: */
+    HI_UNF_KEYLED_TYPE_E kltype;  /**<Type of the front panel*/        /**<CNcomment: */
+}HI_UNF_PMOC_DEV_TYPE_S, *HI_UNF_PMOC_DEV_TYPE_S_PTR;
+
+/**Mode of last wakeup*/
+/**CNcomment:*/
+typedef struct hiUNF_PMOC_WAKEUP_MODE_S
+{
+    HI_UNF_PMOC_ACTUAL_WKUP_E  enWakeUpMode; /**<Wake-up mode returned from last wakeup*/     /**<CNcomment: */
+    HI_U64                     u64IRPowerKey;  /**<The IR power key of last wakeup*/          /**<CNcomment: */
+    HI_U32                     u32GPIONo;     /**<Gpio number of last wakeup*/                /**<CNcomment:GPIO*/
+}HI_UNF_PMOC_WAKEUP_MODE_S, *HI_UNF_PMOC_WAKEUP_MODE_S_PTR;
+
+/** Define of chip temperature */
+/**CNcomment: */
+typedef struct hiUNF_PMOC_CHIP_TEMP_S
+{
+    HI_S32 s32ChipSensor1Temp; /**<The temperature of chip sensor1 in millidegree Celsius */  /**<CNcomment: */
+    HI_S32 s32ChipSensor2Temp; /**<Reserved now*/ /**<CNcomment:  */
+    HI_S32 s32ChipSensor3Temp; /**<Reserved now*/ /**<CNcomment:  */
+    HI_S32 s32ChipSensor4Temp; /**<Reserved now*/ /**<CNcomment:  */
+}HI_UNF_PMOC_CHIP_TEMP_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PMOC */
+/** @{ */  /** <!-- [PMOC] */
+/*---- pm ----*/
+
+/**
+\brief Starts the power management on chip (PMoC) device.
+CNcomment:\brief CNend
+
+\attention \n
+The ARM can be switched to another operating mode and then to low-power mode only after the PMoC device is started.\n
+CNcomment:ARMCNend
+
+\param N/A                                                               CNcomment: CNend
+\retval HI_SUCCESS Success                                               CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_INIT  The PMoC device fails to open.        CNcomment:PMoC CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_Init(HI_VOID);
+
+/**
+\brief Stops the PMoC device.
+CNcomment:\brief CNend
+
+\attention \n
+N/A
+\param  N/A                                                             CNcomment: CNend
+\retval HI_SUCCESS Success                                              CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_DeInit(HI_VOID);
+
+/**
+\brief Sets the mode to which the ARM is switched and obtains the wake-up mode.
+CNcomment:\brief ARMARMCNend
+
+\attention \n
+If the ARM enters the HI_UNF_PMOC_MODE_SLEEP mode, programs stop running at once. The subsequent code can be executed only after the ARM is woken up.\n
+Before enabling the standby mode, you must start the IR device, key device on the front panel; otherwise, the interrupts of these devices are masked. As a result, the corresponding wake-up modes cannot be achieved.\n
+Do not access DDRs after the ARM enters the sleep mode. Therefore, the functions of display output, video output, DEMUX input, and audio/video decoding must be disabled.\n
+CNcomment:ARMHI_UNF_PMOC_MODE_SLEEP\n
+IRKEY\n
+DDRDEMUXCNend
+
+\param[in] enSystemMode   Mode of the ARM in low-power mode                CNcomment: ARMCNend
+
+\param[out]  penWakeUpStatus Wake-up mode returned from the HI_UNF_PMOC_MODE_SLEEP mode. For details about the definition, see the description of ::HI_UNF_PMOC_ACTUAL_WKUP_E. \n
+                         CNcomment: HI_UNF_PMOC_MODE_SLEEP::HI_UNF_PMOC_ACTUAL_WKUP_E CNend
+\retval HI_SUCCESS Success                                                 CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT   The PMoC device is not started.           CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to enter standby            CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SwitchSystemMode(HI_UNF_PMOC_MODE_E enSystemMode, HI_UNF_PMOC_ACTUAL_WKUP_E * penWakeUpStatus);
+
+/**
+\brief Sets the wake-up mode of the ARM.
+CNcomment:\brief ARMCNend
+
+\attention \n
+You can query the original IR code values by referring to IR remote manuals.\n
+In addition, you can query the relationships between the keys and key IDs by checking the connection between hardware and chips.\n
+CNcomment:IR\n
+CNend
+
+\param[in] pstAttr  Wake-up mode of the ARM                             CNcomment:ARMCNend
+\retval HI_SUCCESS Success                                              CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.            CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.           CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_SETWAKEUPVAL It fails to set power val.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetWakeUpAttr(HI_UNF_PMOC_WKUP_S_PTR pstAttr);
+
+/**
+\brief Gets the wake-up mode of the ARM.
+CNcomment:\brief ARMCNend
+
+\attention \n
+
+\param[out] pstAttr  Wake-up mode of the ARM                            CNcomment:ARMCNend
+\retval HI_SUCCESS Success                                              CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.            CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.           CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_GETWAKEUPVAL It fails to set power val.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetWakeUpAttr(HI_UNF_PMOC_WKUP_S_PTR pstAttr);
+
+
+/**
+\brief set display content when wake up.
+CNcomment:\brief CNend
+
+\attention \n
+content that the panel display when standby
+CNcomment:\n CNend
+
+\param[in] pstStandbyMode  display content:time or channel or no display   CNcomment:: or  or CNend
+\retval HI_SUCCESS  success                                                CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby display      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetStandbyDispMode(HI_UNF_PMOC_STANDBY_MODE_S_PTR pstStandbyMode);
+
+/**
+\brief Obtains the current system mode.
+CNcomment:\brief CNend
+
+\attention \n
+This API is abandoned and only used for forward compatible. It always returns normal state.\n
+CNcomment:\n CNend
+
+\param[in] penSystemMode  Mode to be obtained                   CNcomment:CNend
+\retval HI_SUCCESS Success                                      CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started. CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_ReadSystemMode(HI_UNF_PMOC_MODE_E * penSystemMode);
+
+/**
+\brief Sets the operating scenario.
+CNcomment:\brief CNend
+
+\attention \n
+Only the standby scenario is supported currently.\n
+CNcomment:\n CNend
+
+\param[in] eScene  Standby scenario                               CNcomment:CNend
+\retval HI_SUCCESS Success                                        CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT    The PMoC device is not started. CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The parameter is invalid.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetScene(HI_UNF_PMOC_SCENE_E eScene);
+
+/**
+\brief Sets the types of the devices related to standby such as front panel and IR remote control.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param[in] pdevType  Standby device that needs to be supported in standby       CNcomment:CNend
+\retval HI_SUCCESS  success                                                CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby devices.     CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetDevType(HI_UNF_PMOC_DEV_TYPE_S_PTR pdevType);
+
+/**
+\brief when standby, GPIO pin control 12v and 5v power,relate to hardware.
+CNcomment:\brief ,GPIO12V05V0CNend
+
+\attention \n
+when standby, the outside power controled by STANDBY_PWROFF pin, the function can be ignored.\n
+when some part of outside power controled by GPIO pin, use this function will decrease standby power.\n
+CNcomment:STANDBY_PWROFF\n
+GPIO,CNend
+
+\param[in] u32GpioNo  GPIO pin index, choose the fifth[40,47] CNcomment:GPIO,5[40, 47] CNend
+\param[in] bHighOrLow GPIO output control                     CNcomment:GPIO CNend
+\retval HI_SUCCESS  success                                                CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby Gpio.        CNcomment:Gpio CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetPwrOffGpio(HI_U32 u32GpioNo, HI_BOOL bHighOrLow);
+
+/**
+\brief Get the period during standby status.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param[out] pu32Period  The period of standby. CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_GETPERIOD  It fails to get standby period.    CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetStandbyPeriod(HI_U32 *pu32Period);
+
+
+/**
+\brief Switch to smart standby status.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param[in] u32HoldModules  The modules working in smart standby .          CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_SUCCESS            Standby success.                           CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_EnterSmartStandby(HI_U32 u32HoldModules);
+
+/**
+\brief Quit smart standby status.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param  N/A                                                                CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_SUCCESS            Quit standby success.                      CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_QuitSmartStandby(HI_VOID);
+
+/**
+\brief Get the Parameters of last wake up.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param[out] pstAttr  The Parameters of last waking up. CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_GETWAKEUPMODE  It fails to get parameters of last waking up.    CNcomment: CNend
+\retval ::HI_SUCCESS            Getting waking up parameters succeeded.            CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetWakeUpMode(HI_UNF_PMOC_WAKEUP_MODE_S_PTR pstAttr);
+
+/**
+\brief Get the temperatures of the chip.
+CNcomment:\brief CNend
+
+\attention \n
+
+\param[out] pstChipTemp  The temperatures of the chip sensors. CNcomment: CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment: CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment: CNend
+\retval ::HI_ERR_PMOC_FAILED_GETTEMPERATURE  It fails to get chip temp.    CNcomment: CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_PMOC_GetChipTemp(HI_UNF_PMOC_CHIP_TEMP_S *pstChipTemp);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_PMOC_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_pq.h b/xbmc/platform/linux/hisi/hi_unf_pq.h
new file mode 100644
index 0000000000..a829953c70
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_pq.h
@@ -0,0 +1,636 @@
+/******************************************************************************
+
+  Copyright (C), 2012-2014, Hisilicon Tech. Co., Ltd.
+
+******************************************************************************
+  File Name     : hi_unf_pq.h
+  Version       : Initial Draft
+  Author        : sdk
+  Created       : 2014/4/23
+  Description   :
+
+******************************************************************************/
+
+#ifndef __HI_UNF_PQ_H__
+#define __HI_UNF_PQ_H__
+
+#include "hi_type.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+/******************************************************************************/
+
+
+/********************************Struct Definition********************************/
+/** \addtogroup      PQ */
+/** @{ */  /** <!-- [PQ] */
+
+/**<Image Mode Set Different Parameters Under Different Mode*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_IMAGE_MODE_E
+{
+    HI_UNF_OPTION_MODE_NATURAL    = 0,  /**<Natural mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_PERSON     = 1,  /**<Person mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_FILM       = 2,  /**<Film mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_UD         = 3,  /**<User Defined mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_NORMAL     = 4,  /**<Normal mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_VIDEOPHONE = 5,  /**<Video Phone mode*/ /**<CNcomment: CNend*/
+    HI_UNF_OPTION_MODE_GALLERY    = 6,  /**<Gallery mode*/ /**<CNcomment: CNend*/
+
+    HI_UNF_OPTION_MODE_BUTT,
+} HI_UNF_PQ_IMAGE_MODE_E;
+
+typedef enum hiUNF_PQ_HDR_MODE_E
+{
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_SDR   = 0,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_HDR10 = 1,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_HLG   = 2,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_SDR     = 3,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_HDR10   = 4,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_HLG     = 5,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_SDR     = 6,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_HDR10   = 7,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_HLG     = 8,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_SDR     = 9,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_HDR10   = 10,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_HLG     = 11,
+
+    HI_UNF_PQ_HDR_PROCESS_SCENE_BUTT,
+} HI_UNF_PQ_HDR_PROCESS_SCENE_E;
+
+/******************************************************************************/
+typedef struct hiUNF_PQ_SETHDROFFSET_S
+{
+    HI_UNF_PQ_HDR_PROCESS_SCENE_E enHdrProcessScene;
+    HI_U32       u32HdrMode;
+    HI_U32       u32Bright;
+    HI_U32       u32Contrast;
+    HI_U32       u32Satu;
+    HI_U32       u32Hue;
+    HI_U32       u32R;
+    HI_U32       u32G;
+    HI_U32       u32B;
+    HI_U32       u32darkCv;
+    HI_U32       u32brightCv;
+    HI_U32       u32ACCdark;
+    HI_U32       u32ACCbrigt;
+} HI_UNF_PQ_SETHDROFFSET_S;
+/******************************************************************************/
+
+/**<Demo Mode*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_DEMO_E
+{
+    HI_UNF_PQ_DEMO_SHARPNESS = 0,   /**<Sharpen */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_DCI,             /**<Dynamic Contrast Improvement */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_COLOR,           /**<Automatic Color Management */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_SR,              /**<Super Resolution */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_TNR,             /**<Time Noise Reduction */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_DEI,             /**<De interlace */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_DBM,             /**<Digital Noise Reduction; include DB DM DR DS*/ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_SNR,             /**<Space Noise Reduction */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_ALL,             /**<All Algorithm */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_DEMO_BUTT
+} HI_UNF_PQ_DEMO_E;
+
+/**<Demo Display Mode*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_DEMO_MODE_E
+{
+    HI_UNF_PQ_DEMO_MODE_FIXED_R,    /**<Fixed Enable Right */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_MODE_FIXED_L,    /**<Fixed Enable Left */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_MODE_SCROLL_R,   /**<Enable Right; and Roll from Left to right */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_DEMO_MODE_SCROLL_L,   /**<Enable Left; and Roll from Left to right */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_DEMO_MODE_BUTT
+} HI_UNF_PQ_DEMO_MODE_E;
+
+/**<Algorithm Moudle*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_MODULE_E
+{
+    HI_UNF_PQ_MODULE_SHARPNESS = 0, /**<Sharpen */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_DCI,           /**<Dynamic Contrast Improvement */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_COLOR,         /**<Automatic Color Management */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_SR,            /**<Super Resolution */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_TNR,           /**<Time Noise Reduction */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_DBM,           /**<Digital Noise Reduction; include DB DM DR DS*/ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_SNR,           /**<Space Noise Reduction */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_MODULE_MCDI,          /**<Motion Compensation DeInterlace */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_MODULE_ALL,           /**<All Algorithm */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_MODULE_BUTT
+} HI_UNF_PQ_MODULE_E;
+
+/**<Spuer Resolution Demo Mode*/
+/**<CNcomment:SR CNend*/
+typedef enum hiUNF_PQ_SR_DEMO_E
+{
+    HI_UNF_PQ_SR_DISABLE  = 0, /**<Close SR */ /**<CNcomment:SR, CNend*/
+    HI_UNF_PQ_SR_ENABLE_R,     /**<SR open at right hand side */ /**<CNcomment:SR CNend*/
+    HI_UNF_PQ_SR_ENABLE_L,     /**<SR open at left hand side */ /**<CNcomment:SR CNend*/
+    HI_UNF_PQ_SR_ENABLE_A,     /**<SR open all screen */ /**<CNcomment:SR CNend*/
+
+    HI_UNF_PQ_SR_DEMO_BUTT
+} HI_UNF_PQ_SR_DEMO_E;
+
+/**<Custom Colors Parameter*/
+/**<CNcomment: CNend*/
+typedef struct  hiUNF_PQ_SIX_BASE_S
+{
+    HI_U32  u32Red;       /**<Red; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Green;     /**<Green; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Blue;      /**<Blue; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+
+    HI_U32  u32Cyan;      /**<Cyan; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Magenta;   /**<Magenta; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Yellow;    /**<Yellow; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+} HI_UNF_PQ_SIX_BASE_S;
+
+/**<Custom Color Temperature Parameter*/
+/**<CNcomment: CNend*/
+typedef struct  hiUNF_PQ_COLORTEMPERATURE_S
+{
+    HI_U32  u32Red;       /**<Red; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Green;     /**<Green; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+    HI_U32  u32Blue;      /**<Blue; Range:0~100 */ /**<CNcomment::0~100 CNend*/
+} HI_UNF_PQ_COLORTEMPERATURE_S;
+
+/**<Portrait Colors Parameter*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_FLESHTONE_E
+{
+    HI_UNF_PQ_FLESHTONE_GAIN_OFF  = 0,   /**<Portrait Model Strength Off */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_LOW  = 1,   /**<Portrait Model Strength Low */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_MID  = 2,   /**<Portrait Model Strength Middle */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_HIGH = 3,   /**<Portrait Model Strength High */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_FLESHTONE_GAIN_BUTT
+}  HI_UNF_PQ_FLESHTONE_E;
+
+/**<Color Optimization Model*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_COLOR_SPEC_MODE_E
+{
+    HI_UNF_PQ_COLOR_MODE_RECOMMEND  = 0, /**<Optimization Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_MODE_BLUE       = 1, /**<Blue Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_MODE_GREEN      = 2, /**<Green Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_MODE_BG         = 3, /**<Cyan Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_MODE_ORIGINAL   = 4, /**<Original Model */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_COLOR_MODE_BUTT
+} HI_UNF_PQ_COLOR_SPEC_MODE_E;
+
+/**<Intelligent Colors Form*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_PQ_COLOR_ENHANCE_E
+{
+    HI_UNF_PQ_COLOR_ENHANCE_FLESHTONE       = 0,  /**<Portrait Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_ENHANCE_SIX_BASE        = 1,  /**<Custom Model */ /**<CNcomment: CNend*/
+    HI_UNF_PQ_COLOR_ENHANCE_SPEC_COLOR_MODE = 2,  /**<Special Color Model */ /**<CNcomment: CNend*/
+
+    HI_UNF_PQ_COLOR_ENHANCE_BUTT
+} HI_UNF_PQ_COLOR_ENHANCE_E;
+
+/**<Intelligent Colors Parameter*/
+/**<CNcomment: CNend*/
+typedef struct  hiUNF_PQ_COLOR_ENHANCE_S
+{
+    HI_UNF_PQ_COLOR_ENHANCE_E  enColorEnhanceType;  /**<Color Model */ /**<CNcomment CNend*/
+    union
+    {
+        HI_UNF_PQ_FLESHTONE_E        enFleshtone;   /**<Portrait Model Parameter */ /**<CNcomment CNend*/
+        HI_UNF_PQ_SIX_BASE_S         stSixBase;     /**<Custom Model Parameter */ /**<CNcomment CNend*/
+        HI_UNF_PQ_COLOR_SPEC_MODE_E  enColorMode;   /**<Special Color Model Parameter */ /**<CNcomment CNend*/
+    } unColorGain;
+} HI_UNF_PQ_COLOR_ENHANCE_S;
+
+typedef enum hiUNF_PQ_IMAGE_TYPE_E
+{
+    HI_UNF_PQ_IMAGE_GRAPH = 0,          /**<graph image */ /**<CNcomment:  CNend*/
+    HI_UNF_PQ_IMAGE_VIDEO,              /**<video image */ /**<CNcomment:  CNend*/
+
+    HI_UNF_PQ_IMAGE_BUTT
+} HI_UNF_PQ_IMAGE_TYPE_E;
+
+typedef struct hiUNF_PQ_IMAGE_PARAM_S
+{
+    HI_U32       u32Brightness;         /**<Brightness; Range:0~100; recommended: 50 */ /**<CNcomment:: 0~100: 50 CNend*/
+    HI_U32       u32Contrast;           /**<Contrast; Range:0~100; recommended: 50 */ /**<CNcomment:: 0~100: 50 CNend*/
+    HI_U32       u32Hue;                /**<HuePlus; Range:0~100; recommended: 50 */ /**<CNcomment:: 0~100: 50 CNend*/
+    HI_U32       u32Saturation;         /**<Saturation; Range:0~100; recommended: 50 */ /**<CNcomment:: 0~100: 50 CNend*/
+} HI_UNF_PQ_IMAGE_PARAM_S;
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PQ */
+/** @{ */  /** <!-- [PQ] */
+
+/******************************************************************************/
+/**
+ \brief Set PQ mode . CNcomment:  CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] enImageMode Destination DISP channel PQ mode CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_PQ_SetImageMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_MODE_E enImageMode);
+
+
+/**
+ \brief Get PQ mode . CNcomment:  CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] penImageMode  pointer of image mode CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_PQ_GetImageMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_MODE_E *penImageMode);
+
+/**
+ \brief Set the default PQ configuration for video parameter test.  CNcomment: PQ CNend
+ \attention \n
+ \param[in] N/A CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \see \n
+ N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_PQ_SetDefaultParam(HI_VOID);
+
+
+/**
+ \brief Initializes the picture quality unit (PQU). CNcomment: PQ CNend
+ \attention \n
+Before calling the PQU, you must call this application programming interface (API).
+CNcomment: PQ CNend
+ \param[in] N/A CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_PQ_DEV_NOT_EXIST No PQ device exists. CNcomment:  CNend
+ \retval ::HI_ERR_PQ_NOT_DEV_FILE The file is not a PQ file. CNcomment:  CNend
+ \retval ::HI_ERR_PQ_DEV_OPENED The PQ device fails to be started. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_PQ_Init(HI_VOID);
+
+
+/**
+ \brief Deinitializes the PQU. CNcomment: PQ CNend
+ \attention \n
+ \param[in] N/A CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_PQ_DeInit(HI_VOID);
+
+
+/**
+ \brief Get Brightness. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] pu32Brightness   CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetBrightness(HI_UNF_DISP_E enChan, HI_U32 *pu32Brightness);
+
+
+/**
+ \brief Set Brightness. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] u32Brightness; Range:0~100 CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetBrightness(HI_UNF_DISP_E enChan, HI_U32 u32Brightness);
+
+
+/**
+ \brief Get Contrast. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel  CNcomment:  CNend
+ \param[out] pu32Contrast; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetContrast(HI_UNF_DISP_E enChan, HI_U32 *pu32Contrast);
+
+
+/**
+ \brief Set Contrast. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] u32Contrast; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetContrast(HI_UNF_DISP_E enChan, HI_U32 u32Contrast);
+
+
+/**
+ \brief Get Saturation. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] pu32Saturation; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSaturation(HI_UNF_DISP_E enChan, HI_U32 *pu32Saturation);
+
+
+/**
+ \brief Set Saturation. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] u32Saturation; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetSaturation(HI_UNF_DISP_E enChan, HI_U32 u32Saturation);
+
+
+/**
+ \brief Get Hue. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] pu32Hue; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetHue(HI_UNF_DISP_E enChan, HI_U32 *pu32Hue);
+
+
+/**
+ \brief Set Hue. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] u32Hue; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetHue(HI_UNF_DISP_E enChan, HI_U32 u32Hue);
+
+/**
+\brief  set color temperature. CNcomment: CNend
+\attention \n
+none.CNcomment: CNend
+\param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+\param[in] colortemp           temperature value. the range is 0~100, 0 means the min value. \n
+CNcomment:01000100 CNend
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_PQ_SetColorTemperature(HI_UNF_DISP_E enChan, HI_UNF_PQ_COLORTEMPERATURE_S stColorTemperature);
+
+
+/**
+\brief  set color temperature. CNcomment: CNend
+\attention \n
+none.CNcomment: CNend
+\param[in] enDisp              DISP channel ID.CNcomment:DISP CNend
+\param[in] colortemp           temperature value. the range is 0~100, 0 means the min value. \n
+CNcomment:01000100 CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_PQ_GetColorTemperature(HI_UNF_DISP_E enChan, HI_UNF_PQ_COLORTEMPERATURE_S *pstColorTemperature);
+
+/**
+ \brief Set Basic image para. CNcomment:. CNend
+ \attention \n
+ \param[in] enType: Graph or Video  CNcomment:  CNend
+ \param[in] enChan: Destination DISP channel  CNcomment:  CNend
+ \param[in] stParam:Basic Image Param CNcomment:CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetBasicImageParam(HI_UNF_PQ_IMAGE_TYPE_E enType, HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_PARAM_S stParam);
+
+
+/**
+ \brief Get Basic image para. CNcomment: CNend
+ \attention \n
+ \param[in] enType: Graph or Video  CNcomment:  CNend
+ \param[in] enChan: Destination DISP channel  CNcomment:  CNend
+ \param[in] pstParam:Basic Image Param CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetBasicImageParam(HI_UNF_PQ_IMAGE_TYPE_E enType, HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_PARAM_S *pstParam);
+
+
+/**
+ \brief Get SR Demo Mode. CNcomment:SR CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] *penType, SR Demo Mode  CNcomment:SR  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSRMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_SR_DEMO_E *penType);
+
+
+/**
+ \brief  Set SR Demo Mode. CNcomment:SR CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] enType, SR Demo Mode  CNcomment:SR  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetSRMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_SR_DEMO_E enType);
+
+
+/**
+ \brief Get Sharpness. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[out] pu32Sharpness; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSharpness(HI_UNF_DISP_E enChan, HI_U32 *pu32Sharpness);
+
+
+/**
+ \brief Set Sharpness. CNcomment: CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment:  CNend
+ \param[in] u32Sharpness; Range:0~100  CNcomment: : 0~100 CNend
+ \retval ::HI_SUCCESS  Success CNcomment:  CNend
+ */
+HI_S32 HI_UNF_PQ_SetSharpness(HI_UNF_DISP_E enChan, HI_U32 u32Sharpness);
+
+/**
+ \brief Get Color Enhance Type and Para. CNcomment: CNend
+ \attention \n
+ \param[out] pstColorEnhanceParam  CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetColorEnhanceParam(HI_UNF_PQ_COLOR_ENHANCE_S *pstColorEnhanceParam);
+
+
+/**
+ \brief Set Color Enhance Type and Para. CNcomment: CNend
+ \attention \n
+ \param[out] stColorEnhanceParam  CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetColorEnhanceParam(HI_UNF_PQ_COLOR_ENHANCE_S stColorEnhanceParam);
+
+
+/** Dynamic Contrast Improvement(DCI)
+ \brief Get Dynamic Contrast Improvement(DCI) Range  CNcomment:DCI CNend
+ \attention \n
+ \param[out] pu32DCIlevel; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDynamicContrast(HI_U32 *pu32DCIlevel);
+
+
+/**
+ \brief Get DCI Range  CNcomment:DCI CNend
+ \attention \n
+ \param[in] u32DCIlevel; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDynamicContrast(HI_U32 u32DCIlevel);
+
+
+/**
+ \brief Get noise reduction strength CNcomment: CNend
+ \attention \n
+ \param[out] pu32NRLevel: noise reduction level; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetNR(HI_UNF_DISP_E enChan, HI_U32 *pu32NRLevel);
+
+
+/**
+ \brief  Set noise reduction strength CNcomment: CNend
+ \attention \n
+ \param[in] u32NRLevel: noise reduction level; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetNR(HI_UNF_DISP_E enChan, HI_U32 u32NRLevel);
+
+/**
+ \brief Get digital noise reduction strength CNcomment: CNend
+ \attention \n
+ \param[out] pu32NRLevel: noise reduction level; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDNR(HI_UNF_DISP_E enChan, HI_U32 *pu32DNRLevel);
+
+
+/**
+ \brief  Set digital noise reduction strength CNcomment: CNend
+ \attention \n
+ \param[in] u32NRLevel: noise reduction level; Range:0~100 CNcomment:: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDNR(HI_UNF_DISP_E enChan, HI_U32 u32DNRLevel);
+
+
+
+/**
+ \brief  Set Algorithm Moudle on-off  CNcomment: CNend
+ \attention \n
+ \param[in] enFlags   CNcomment: CNend
+ \param[in] u32OnOff  CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ */
+HI_S32 HI_UNF_PQ_SetPQModule(HI_UNF_PQ_MODULE_E enFlags, HI_U32 u32OnOff);
+
+
+/**
+ \brief Get Algorithm Moudle on-off  CNcomment: CNend
+ \attention \n
+ \param[in]  enFlags   CNcomment: CNend
+ \param[out] pu32OnOff CNcomment: CNend
+ \retval ::HI_SUCCESS  Success CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetPQModule(HI_UNF_PQ_MODULE_E enFlags, HI_U32 *pu32OnOff);
+
+
+/**
+ \brief Set Demo Mode on-off  CNcomment: CNend
+ \attention \n
+ \param[in] enFlags   CNcomment: CNend
+ \param[in] u32OnOff  CNcomment: CNend
+ \retval ::HI_SUCCESS CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemo(HI_UNF_PQ_DEMO_E enFlags, HI_U32 u32OnOff);
+
+
+/**
+ \brief Set Demo Display Mode  CNcomment: CNend
+ \attention \n
+ \param[in] enChan    CNcomment: CNend
+ \param[in] enMode    CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemoMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_DEMO_MODE_E enMode);
+
+
+/**
+ \brief Get Demo Display Mode  CNcomment: CNend
+ \attention \n
+ \param[in] enChan    CNcomment: CNend
+ \param[out] enMode   CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDemoMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_DEMO_MODE_E *penMode);
+
+/**
+ \brief Set Demo Display Mode Coordinate CNcomment: CNend
+ \attention \n
+ \param[in] u32X Range:0~100 Default:50 CNcomment: :0~100 :50 CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemoCoordinate(HI_U32 u32X);
+
+
+/**
+ \brief Get Demo Display Mode Coordinate CNcomment: CNend
+ \attention \n
+ \param[out] pu32X  Range:0~100 Default:50 CNcomment: :0~100 :50 CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDemoCoordinate(HI_U32 *pu32X);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_PQ_H__ */
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_pvr.h b/xbmc/platform/linux/hisi/hi_unf_pvr.h
new file mode 100644
index 0000000000..7efbf80d79
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_pvr.h
@@ -0,0 +1,1530 @@
+/******************************************************************************
+
+  Copyright (C) Hisilicon Technologies Co., Ltd. 2008-2018. All rights reserved.
+
+ ******************************************************************************
+  File Name     : hi_unf_pvr.h
+  Version       : Initial draft
+  Author        : HiSilicon multimedia software group
+  Created Date   : 2008-04-09
+  Description   : hi_pvr_api.h header file
+  Change History:
+  Date        : 2008-04-09
+    Author      : sdk
+    Description: This file is created.
+
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the personal video recorder (PVR). CNcomment: PVR CNend
+ */
+#ifndef __HI_UNF_PVR_H__
+#define __HI_UNF_PVR_H__
+
+#include "hi_type.h"
+#include "hi_debug.h"
+#include "hi_unf_cipher.h"
+#include "hi_unf_common.h"
+#include "hi_unf_avplay.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"
+{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup    PVR */
+/** @{ */  /** <!--[PVR]*/
+
+/**Recommended value of the recording attribute u32ScdBufSize*//** CNcomment: u32ScdBufSize */
+#define PVR_STUB_SC_BUF_SZIE (7*4*2048)
+
+/**Recommended value of the recording attribute u32DavBufSize when the recording attribute enTsPacketType is HI_UNF_PVR_TS_PACKET_188 and Resolution is FHD and below*//** CNcomment:  enTsPacketTypeHI_UNF_PVR_TS_PACKET_188,FHD,u32DavBufSize */
+#define PVR_STUB_TSDATA_SIZE (188*12*2048)
+
+/**Recommended value of the recording attribute u32DavBufSize when the recording attribute enTsPacketType is HI_UNF_PVR_TS_PACKET_192 and Resolution is FHD and below*//**<CNcomment: enTsPacketTypeHI_UNF_PVR_TS_PACKET_192,FHD,u32DavBufSize */
+#define PVR_STUB_TSDATA_SIZE_192 (192*12*2048)
+
+/*****************Macro Definition*******************************/
+/**Maximum length of the file name, in byte*//** CNcomment:  :*/
+#define PVR_MAX_FILENAME_LEN            256
+/**Maximum length of the encryption key, in byte. Note: The valid key length may not be the maximum length, and depends on the encryption algorithm.*/
+/** CNcomment: ::  */
+#define PVR_MAX_CIPHER_KEY_LEN          128
+/**Maximum length of the user data, in byte*//** CNcomment:   : */
+#define PVR_MAX_USERDATA_LEN            (1024*1024)
+#define PVR_MAX_CADATA_LEN              (16*1024)
+/**<Maximum number of PID for one recording*//**<CNcomment: PID*/
+#define HI_UNF_PVR_REC_MAX_PID_NUM (32)
+
+/**<Flag value of trick play with audio*//**<CNcomment: */
+#define HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE     (0x0A000000)
+
+/***********************************************************
+                Data Structure Definition
+ ***********************************************************/
+
+/***** Common Data Structures*****/
+
+/** Secure mode type*/
+/**CNcomment:*/
+typedef enum hiUNF_PVR_SECURE_MODE_E
+{
+    HI_UNF_PVR_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:*/
+    HI_UNF_PVR_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone*/
+
+    HI_UNF_PVR_SECURE_MODE_BUTT
+} HI_UNF_PVR_SECURE_MODE_E;
+
+/**Cyclic control data structure of the PVR index file*//** CNcomment: PVR index */
+typedef struct hiPVR_CYC_HEADER_INFO_S
+{
+    HI_U32 u32StartFrame;     /**<Offset of the start frame in the index file. The start frame is at u32StartFrame.*//**<CNcomment: index, u32StartFrame*/
+    HI_U32 u32EndFrame;       /**<Offset of the end frame in the index file. The end frame is at u32EndFrame - 1.*//**<CNcomment: index, u32EndFrame-1*/
+    HI_U32 u32LastFrame;      /**<Offset of the last frame in the index file. The last frame is at u32LastFrame - 1.*//**<CNcomment: index, u32LastFrame-1*/
+    HI_U32 u32IsRewind;       /**<Whether to record the file in rewind mode. 0: no rewind; 1: rewind*//**<CNcomment: , 0 , 1 */
+}PVR_CYC_HEADER_INFO_S;
+
+/**Structure of the file header in the PVR index file*//** CNcomment: PVR index */
+typedef struct hiPVR_IDX_HEADER_INFO_S
+{
+    HI_U32 u32StartCode;                          /**<Start code (0x5A5A5A5A)*//**<CNcomment: (0x5A5A5A5A) */
+    HI_U32 u32HeaderLen;                          /**<Length from u32StartCode to UsrData*//**<CNcomment: u32StartCodeUsrData */
+    PVR_CYC_HEADER_INFO_S stCycInfo;              /**<Records the cyclic control information in the index file*//**<CNcomment: index */
+    HI_U64 u64ValidSize;                          /**<Size of the valid content in a file, in byte*//**<CNcomment: Byte */
+    HI_U32 u32Reserved;                           /**<Reserved, for alignment*//**<CNcomment: */
+    HI_U32 u32UsrDataInfoLen;                     /**<User information length*//**<CNcomment:  */
+    HI_U32 u32CADataInfoLen;
+}PVR_IDX_HEADER_INFO_S;
+
+/**Index data saved in the PVR index file*//** CNcomment: PVR index */
+typedef struct hiPVR_INDEX_ENTRY_S
+{
+    HI_U16 u16FrameTypeAndGop;                    /**<2-bit frame type and 14-bit group of pictures (GOP)*/
+    HI_U16 u16UpFlowFlag;                         /**<DAV overflow flag*/
+    HI_U32 s32CycTimes;                           /**<Number of times that the file is rewound*/
+    HI_U64 u64GlobalOffset;                       /**<Total global offset (rewind ignored), in byte*/
+    HI_U32 u32DisplayTimeMs;                      /**<Display time (in ms), no rewind*/
+    HI_U32 u32FrameSize;                          /**<Frame size*/
+    HI_U64 u64Offset;                             /**<Frame offset in a stream file*/
+    HI_U32 u32PtsMs;                              /**<Presentation time stamp (PTS), in ms*/
+    HI_U16 u16IndexType;                          /**<Index type*/
+    HI_U16 u161stFrameOfTT;                       /**<Useless*/
+}PVR_INDEX_ENTRY_S,*PTR_PVR_INDEX_ENTRY;
+
+
+/**Encryption or decryption configuration of the PVR*//** CNcomment:  PVR */
+typedef struct hiUNF_PVR_CIPHER_S
+{
+    HI_BOOL             bDoCipher;                             /**<Whether to perform encryption or decryption. When this parameter is set to HI_FALSE, other parameters are invalid.*//**<CNcomment:  HI_FALSE */
+    HI_UNF_CIPHER_ALG_E enType;                                /**<Encryption or decryption algorithm type that supports only the AES, DES, and 3DES*//**<CNcomment: AESDES3DES */
+    HI_U8               au8Key[PVR_MAX_CIPHER_KEY_LEN];        /**<In normal PVR,it's cipher key.If advance security PVR, it's Keyladder's first session key*//**<CNcomment: PVRCipherPVRKeyladder */
+    HI_U32              u32KeyLen;                             /**<Cipher key length*//**<CNcomment:  */
+}HI_UNF_PVR_CIPHER_S;
+
+/**Type of the PVR event*//** CNcomment:  PVR */
+typedef enum hiUNF_PVR_EVENT_E
+{
+    HI_UNF_PVR_EVENT_PLAY_EOF                       = 0x001,          /**<A file is played at the end of file (EOF).*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_PLAY_SOF                       = 0x002,          /**<A file is played to the start of file (SOF).*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_PLAY_ERROR                     = 0x003,          /**<An internal error occurs during playing.*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_PLAY_REACH_REC                 = 0x004,          /**<The playing speed reaches the recording speed during time shift.*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_PLAY_FIRST_FRAME_DISPLAYED     = 0x005,          /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: */
+    HI_UNF_PVR_EVENT_PLAY_RESV                      = 0x00f,          /**<Reserved*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_REC_DISKFULL                   = 0x010,          /**<The disk is full.*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_REC_ERROR                      = 0x011,          /**<An internal error occurs during recording.*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_REC_OVER_FIX                   = 0x012,          /**<The length of the recorded data reaches the specified length. after report this event, in non-rewind mode, pvr stop recording; In rewind mode, pvr keep recording.*//**<CNcomment: .  */
+    HI_UNF_PVR_EVENT_REC_REACH_PLAY                 = 0x013,          /**<The recording speed reaches the playing speed during time shift.*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_REC_DISK_SLOW                  = 0x014,          /**<The storage speed of the disk is slower than the recording speed.*//**<CNcomment:  */
+    HI_UNF_PVR_EVENT_REC_REWIND_TO_LINEAR_COMPLETE  = 0x015,          /**<Rewinding switch to non-rewinding completed.the success or failure of the callback event reported*//**<CNcomment: */
+    HI_UNF_PVR_EVENT_RECFILE_LINEARIZATION_COMPLETE = 0x016,          /**<File linearization completed.the success or failure of the callback event reported*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_REC_EOS                        = 0x017,          /**<all the data in the record buffer is received.*//*<CNcomment:PVRbufferTS*/
+    HI_UNF_PVR_EVENT_REC_RESV                       = 0x01f,          /**<Reserved*//**<CNcomment:   */
+    HI_UNF_PVR_EVENT_BUTT                           = 0x020           /**<Invalid event type*//**<CNcomment:  */
+} HI_UNF_PVR_EVENT_E;
+
+/**Callback function of PVR event*//** CNcomment: PVR */
+typedef void (*eventCallBack)(HI_U32 u32ChnID, HI_UNF_PVR_EVENT_E EventType, HI_S32 s32EventValue, HI_VOID *args);
+
+/**Type of recorded and played streams of the PVR*//** CNcomment: PVR */
+typedef enum hiUNF_PVR_STREAM_TYPE_E
+{
+    HI_UNF_PVR_STREAM_TYPE_TS,        /**<Transport stream (TS)*//**<CNcomment:  TS */
+    HI_UNF_PVR_STREAM_TYPE_PES,       /**<Packetized elementary stream (PES)*//**<CNcomment: PES */
+    HI_UNF_PVR_STREAM_TYPE_ALL_TS,    /**<All types of streams. That is, the streams at all frequencies are recorded.*//**<CNcomment:  */
+    HI_UNF_PVR_STREAM_TYPE_OTHER,     /**<Invalid*//**<CNcomment:   */
+    HI_UNF_PVR_STREAM_TYPE_BUTT
+} HI_UNF_PVR_STREAM_TYPE_E;
+
+/**Index type*//** CNcomment:  */
+typedef enum hiUNF_PVR_REC_INDEX_TYPE_E
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_NONE,      /**<No index is created. You need to select this type when recording all streams.*//**<CNcomment: <  */
+    HI_UNF_PVR_REC_INDEX_TYPE_VIDEO,     /**<The index is created based on videos.*//**<CNcomment: < */
+    HI_UNF_PVR_REC_INDEX_TYPE_AUDIO,     /**<The index is created based on audios. *//**<CNcomment: < */
+    HI_UNF_PVR_REC_INDEX_TYPE_BUTT       /**<Invalid*//**<CNcomment: <   */
+} HI_UNF_PVR_REC_INDEX_TYPE_E;
+
+/**Information about a stream file recorded by the PVR*//** CNcomment:  PVR */
+typedef struct hiUNF_PVR_FILE_ATTR_S
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIdxType;          /**<Index type*//**<CNcomment:   */
+    HI_U32                      u32FrameNum;        /**<For a video file: number of frames in the file. For an audio file: number of PESs in the file*//**<CNcomment:  ;PES */
+    HI_U32                      u32StartTimeInMs;   /**<Start time of the file, in ms*//**<CNcomment: PTSms */
+    HI_U32                      u32EndTimeInMs;     /**<End time of the file, in ms*//**<CNcomment: PTSms  */
+    HI_U64                      u64ValidSizeInByte; /**<Valid data length of the file, in byte *//**<CNcomment:  byte */
+} HI_UNF_PVR_FILE_ATTR_S;
+
+/***** Data Structures for Recording  *****/
+/** Record statuses*/
+/**INVALID -> INIT -> RUNNING -> STOPPING ->    STOP ->    INVALID  (saveIndex)  (saveStream)*/
+
+/**Status of a recording channel*//** CNcomment:  */
+typedef enum hiUNF_PVR_REC_STATE_E
+{
+  HI_UNF_PVR_REC_STATE_INVALID,        /**<Not initialized*//**<CNcomment:      */
+  HI_UNF_PVR_REC_STATE_INIT,           /**<Initialized*//**<CNcomment:        */
+  HI_UNF_PVR_REC_STATE_RUNNING,        /**<Recording*//**<CNcomment:        */
+  HI_UNF_PVR_REC_STATE_PAUSE,          /**<Pause*//**<CNcomment:          */
+  HI_UNF_PVR_REC_STATE_STOPPING,       /**<Stopping*//**<CNcomment:     */
+  HI_UNF_PVR_REC_STATE_STOP,           /**<<Stopped*//**<CNcomment:     */
+  HI_UNF_PVR_REC_STATE_PID_CHANGE,     /**<PID is changing*//**<CNcomment: PID*/
+  HI_UNF_PVR_REC_STATE_BUTT            /**<Invalid*//**<CNcomment: */
+} HI_UNF_PVR_REC_STATE_E;
+
+/**<Record pid info when pid changed.*//**<CNcomment: Pidpid*/
+typedef struct hiUNF_PVR_PID_CHANGE_INFO_S
+{
+    HI_U32                      u32PidNum;                              /**<pid number in u32PidList.*//**<CNcomment: pidListpid*/
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIndexType;                            /**<Index type.*//**<CNcomment: */
+    HI_U32                      u32IndexPid;                            /**<Index PID.*//**<CNcomment: PID*/
+    HI_UNF_VCODEC_TYPE_E        enVidType;                              /**<Video Type.*//**<CNcomment:, HI_UNF_PVR_REC_INDEX_TYPE_VIDEO, */
+    HI_U32                      u32PidList[HI_UNF_PVR_REC_MAX_PID_NUM]; /**<Pid List*//**<CNcomment: pid*/
+}HI_UNF_PVR_PID_CHANGE_INFO_S;
+
+/**<Packet Type of stream.*//**<CNcomment: */
+typedef enum hiUNF_PVR_TS_PACKET_TYPE_E
+{
+    HI_UNF_PVR_TS_PACKET_188 = 0,       /**<Packet size is 188 byte*//**<CNcomment: 188*/
+    HI_UNF_PVR_TS_PACKET_192,           /**<Packet size is 192 byte*//**<CNcomment: 192*/
+    HI_UNF_PVR_TS_PACKET_BUTT           /**<Invalid*//**<CNcomment: */
+}HI_UNF_PVR_TS_PACKET_TYPE_E;
+
+/**<PID is changing callback type. <CNcomment: PIDCNend
+\param[in] u32ChnId  Record chanel ID CNcomment:IDCNend
+\param[in] pstOldPidInfo    Pointer to the old pid info CNcomment:PIDPIDCNend
+\param[in] pstNewPidInfo    Pointer to the new pid info CNcomment:PIDPIDCNend
+\param[in] pArgs    user data CNcomment:CNend
+*/
+typedef HI_S32 ( *PidChangeCallBack)(HI_U32 u32ChnId, HI_UNF_PVR_PID_CHANGE_INFO_S *pstOldPidInfo, HI_UNF_PVR_PID_CHANGE_INFO_S *pstNewPidInfo, HI_VOID *pArgs);
+
+/**Attributes of a recording channel*//** CNcomment:  */
+typedef struct hiUNF_PVR_REC_ATTR_S
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIndexType;                           /**<Index type, static attribute.*//**<CNcomment:   */
+    HI_UNF_VCODEC_TYPE_E        enIndexVidType;                        /**<Video encoding protocol with which the stream (for which an index is to be created) complies. The protocol (static attribute) needs to be set only when the index type is HI_UNF_PVR_REC_INDEX_TYPE_VIDEO.*/
+                                                                       /**<CNcomment: , HI_UNF_PVR_REC_INDEX_TYPE_VIDEO,  */
+    HI_U32                      u32IndexPid;                           /**<Index PID, static attribute.*//**<CNcomment:  PID*/
+    HI_U32                      u32DemuxID;                            /**<Recording DEMUX ID, static attribute.*//**<CNcomment:  DEMUX*/
+    HI_U32                      u32DavBufSize;                         /**<Size (in byte) of a data stream buffer, static attribute.*//**<CNcomment:  Byte  */
+    HI_U32                      u32ScdBufSize;                         /**<Size (in byte) of an index data buffer, static attribute.*//**<CNcomment:  Byte*/
+    HI_U32                      u32UsrDataInfoSize;                    /**<Size (in byte) of the private user data, static attribute.*//**<CNcomment:  Byte  */
+    HI_BOOL                     bIsClearStream;                        /**<Whether to record streams as clear streams, static attribute. This item indicates that the stored streams are clear streams or scrambled streams. If the programs to be recorded are scrambled streams, the clear streams can be recorded only after a descrambler is configured for the audio/video channel of the DEMUX.
+                                                                       The recording module of the PVR does not descramble the scrambled streams.*/
+                                                                       /**<CNcomment: DEMUXCA,PVR*/
+    HI_UNF_PVR_STREAM_TYPE_E    enStreamType;                          /**<Type of the data to be recorded, static attribute.*//**<CNcomment: */
+    HI_UNF_PVR_CIPHER_S         stEncryptCfg;                          /**<Stream encryption configuration, static attribute.*//**<CNcomment: */
+    HI_U64                      u64MaxFileSize;                        /**<Size of the file to be recorded, static attribute. If the value is 0, it indicates that there is no limit on the file size. The minimum file size is 52428800 bytes (50 MB). If the disk space is sufficient, it is recommended to set the file size to a value greater than 512 MB. The file size cannot be 0 in rewind mode. */
+                                                                       /**<CNcomment: 050M,512M0 */
+    HI_U64                      u64MaxTimeInMs;                        /**<Max play time of the file to be recorded, static attribute. If the value is 0, it indicates that there is no limit on the file play time. The minimum file time is 60*1000 MS (1 Min).  The file size  and file time cannot both be 0 in rewind mode.*/
+                                                                       /**<CNcomment: 060*1000(1)0*/
+    HI_BOOL                     bRewind;                               /**<Whether to rewind, If this item is set to HI_TRUE, the PVR rewinds to the file header to record streams after the recorded file size reaches u64MaxFileSize. If this item is set to HI_FALSE, the PVR stops recording after the recorded file size reaches u64MaxFileSize.*/
+                                                                       /**<CNcomment: HI_TRUEu64MaxFileSizeHI_FALSEu64MaxFileSize*/
+    HI_CHAR                     szFileName[PVR_MAX_FILENAME_LEN];      /**<Name of a stream file, static attribute*//**<CNcomment: */
+    HI_U32                      u32FileNameLen;                        /**<Length of a stream file name, static attribute. You need to set the item to strlen (szFileName).*//**<CNcomment: strlenszFileName */
+    HI_UNF_PVR_SECURE_MODE_E    enSecureMode;                          /**<Secure channel indication*/ /**<CNcomment:*/
+    HI_BOOL                     bAppendRec;                            /**<Whether to append record,static attribute.If this item is set to HI_TRUE, and the parameters transferred from the upper-layer meets the:(a).add the recording file name the same as that of the before.(b). corresponding to the file name of the file is a wrap-around. (c). bRewind is HI_FALSE. (d). be consistent with the index type. (e).PID information is consistent with the previously.
+                                                                                                                   (f). was recording time of the recording files must be greater than or equal to 60s. (g). maximum file size or the maximum recording time is exceeded.The Append recording starts.Otherwise,Append recording failed.If this item is set to HI_FALSE,not need to Append recording.*/
+                                                                        /**<CNcomment: HI_TRUE(a).(b)(c)bRewindHI_FALSE(d)(e)PID.
+                                                                                                                    (f)60s(g) HI_FALSE,*/
+    HI_UNF_PVR_TS_PACKET_TYPE_E enTsPacketType;                        /**<Packet Type of the stream to be recorded.*//**<CNcomment: */
+    HI_U32                      u32Reserved;
+}HI_UNF_PVR_REC_ATTR_S;
+
+/**Status of a PVR buffer*//** CNcomment:PVR */
+typedef struct hiUNF_PVR_BUF_STATUS_S
+{
+    HI_U32 u32BufSize;       /**<Buffer size*//**<CNcomment:        */
+    HI_U32 u32UsedSize;      /**<Used buffer size*//**<CNcomment:  */
+} HI_UNF_PVR_BUF_STATUS_S;
+
+typedef struct hiUNF_PVR_APPEND_REC_INFO_S
+{
+    HI_BOOL bAppendRec;            /**<if current record is appended*//**<CNcomment:     */
+    HI_U32 u32Reserved;
+    HI_U64 u64AppendOffset;        /**<the offset of beginning to append, only valid if bAppRec=HI_TRUE*//**<CNcomment: ,     */
+}HI_UNF_PVR_APPEND_REC_INFO_S;
+
+/**Status of a recording channel.
+The following describes the relationships among u32CurTimeInMs, u32StartTimeInMs, and u32EndTimeInMs by taking examples:
+1. Assume that the total recording time is 10000 ms, and no rewind occurs. In this case, u32StartTimeInMs is 0 ms, u32EndTimeInMs is 10000 ms, and u32CurTimeInMs is 10000 ms.
+2. Assume that the total recording time is 10000 ms, and rewind occurs at 8000 ms. In this case, u32StartTimeInMs is 2000 ms, u32EndTimeInMs is 10000 ms, and u32CurTimeInMs is 8000 ms.
+*/
+/** CNcomment:.
+u32CurTimeInMsu32StartTimeInMsu32EndTimeInMs
+110000u32StartTimeInMs 0u32EndTimeInMs 10000 u32CurTimeInMs10000
+2100008000u32StartTimeInMs 2000u32EndTimeInMs 10000 u32CurTimeInMs8000
+*/
+typedef struct hiUNF_PVR_REC_STATUS_S
+{
+    HI_UNF_PVR_REC_STATE_E      enState;                 /**<Current status of a channel*//**<CNcomment:     */
+    HI_U32                      u32Reserved;             /**<Reserved, for alignment*//**<CNcomment:     */
+    HI_U64                      u64CurWritePos;          /**<Current recording position of file, in byte*//**<CNcomment: byte */
+    HI_U32                      u32CurWriteFrame;        /**<Number of currently recorded frames*//**<CNcomment:                   */
+    HI_U32                      u32CurTimeInMs;          /**<Current recording time (in ms). The value is the valid time for recording the file.*//**<CNcomment: */
+    HI_U32                      u32StartTimeInMs;        /**<Actual start time for recording files. Before the recording is rewound, the time is that of the first frame; after the recording is rewound, the time is the rewind time.*//**<CNcomment:  */
+    HI_U32                      u32EndTimeInMs;          /**<Time of the end frame in the recorded file. Before the recording is rewound, the time is that of the last frame.*//**<CNcomment:    */
+    HI_UNF_PVR_BUF_STATUS_S     stRecBufStatus;          /**<Status of the recording channel buffer*//**<CNcomment:    */
+    HI_UNF_PVR_APPEND_REC_INFO_S stAppendRecInfo;        /**the infomation for append-recording*//**<CNcomment:    */
+}HI_UNF_PVR_REC_STATUS_S;
+
+/** Data structures for playing */
+
+/**Playing direction of the PVR: forward*//** CNcomment:PVR: */
+#define HI_UNF_PVR_PLAY_DIRECTION_FORWARD             (1)
+/**Playing direction of the PVR: backward*//** CNcomment: PVR: */
+#define HI_UNF_PVR_PLAY_DIRECTION_BACK                (-1)
+
+/**Type of the playing position*//** CNcomment:  */
+typedef enum hiUNF_PVR_PLAY_POS_TYPE_E
+{
+  HI_UNF_PVR_PLAY_POS_TYPE_SIZE,              /**<The playing position is expressed by size (in byte). This type is not supported currently.*//**<CNcomment: byte */
+  HI_UNF_PVR_PLAY_POS_TYPE_TIME,              /**<The playing position is expressed by time (in ms).*//**<CNcomment: ms */
+  HI_UNF_PVR_PLAY_POS_TYPE_FRAME,             /**<The playing position is expressed by the number of frames or PESs. This type is not supported currently.*//**<CNcomment: PES  */
+  HI_UNF_PVR_PLAY_POS_TYPE_BUTT               /**<Invalid*//**<CNcomment:*/
+} HI_UNF_PVR_PLAY_POS_TYPE_E;
+
+/**Status of a playing channel*//** CNcomment:   */
+typedef enum hiUNF_PVR_PALY_STATE_E
+{
+    HI_UNF_PVR_PLAY_STATE_INVALID,       /**<Not initialized*//**<CNcomment:             */
+    HI_UNF_PVR_PLAY_STATE_INIT,          /**<Initialized*//**<CNcomment:               */
+    HI_UNF_PVR_PLAY_STATE_PLAY,          /**<Normal playing*//**<CNcomment:           */
+    HI_UNF_PVR_PLAY_STATE_PAUSE,         /**<Pause*//**<CNcomment:                 */
+    HI_UNF_PVR_PLAY_STATE_FF,            /**<Fast forward*//**<CNcomment:                 */
+    HI_UNF_PVR_PLAY_STATE_FB,            /**<Fast backward*//**<CNcomment:                 */
+    HI_UNF_PVR_PLAY_STATE_SF,            /**<Slow forward*//**<CNcomment:                 */
+    HI_UNF_PVR_PLAY_STATE_SB,            /**<Slow backward*//**<CNcomment:         */
+    HI_UNF_PVR_PLAY_STATE_STEPF,         /**<Step forward*//**<CNcomment:            */
+    HI_UNF_PVR_PLAY_STATE_STEPB,         /**<Step backward*//**<CNcomment:             */
+    HI_UNF_PVR_PLAY_STATE_STOP,          /**<Stop*//**<CNcomment:                 */
+    HI_UNF_PVR_PLAY_STATE_BUTT           /**<Invalid*//**<CNcomment:         */
+} HI_UNF_PVR_PLAY_STATE_E;
+
+/**Identifier of the playing speed*//** CNcomment:  */
+typedef enum hiUNF_PVR_PLAY_SPEED_E
+{
+    HI_UNF_PVR_PLAY_SPEED_NORMAL            = 1024,                                     /**<Normal playing speed*//**<CNcomment:    */
+    HI_UNF_PVR_PLAY_SPEED_2X_FAST_FORWARD   = 2 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at two times the normal speed*//**<CNcomment:2            */
+    HI_UNF_PVR_PLAY_SPEED_4X_FAST_FORWARD   = 4 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at four times the normal speed*//**<CNcomment:4            */
+    HI_UNF_PVR_PLAY_SPEED_8X_FAST_FORWARD   = 8 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at eight times the normal speed*//**<CNcomment:8            */
+    HI_UNF_PVR_PLAY_SPEED_12X_FAST_FORWARD   = 12 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at 12 times the normal speed*//**<CNcomment:12            */
+    HI_UNF_PVR_PLAY_SPEED_16X_FAST_FORWARD  = 16 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 16 times the normal speed*//**<CNcomment:16           */
+    HI_UNF_PVR_PLAY_SPEED_24X_FAST_FORWARD   = 24 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at 24 times the normal speed*//**<CNcomment:24            */
+    HI_UNF_PVR_PLAY_SPEED_32X_FAST_FORWARD  = 32 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 32 times the normal speed*//**<CNcomment:32           */
+    HI_UNF_PVR_PLAY_SPEED_64X_FAST_FORWARD  = 64 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 64 times the normal speed*//**<CNcomment:64           */
+    HI_UNF_PVR_PLAY_SPEED_1X_FAST_BACKWARD  = -1 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at 1 times the normal speed, not support*//**<CNcomment:1 */
+    HI_UNF_PVR_PLAY_SPEED_2X_FAST_BACKWARD  = -2 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at two times the normal speed*//**<CNcomment:2            */
+    HI_UNF_PVR_PLAY_SPEED_4X_FAST_BACKWARD  = -4 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at four times the normal speed*//**<CNcomment:4            */
+    HI_UNF_PVR_PLAY_SPEED_8X_FAST_BACKWARD  = -8 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at eight times the normal speed*//**<CNcomment:8            */
+    HI_UNF_PVR_PLAY_SPEED_12X_FAST_BACKWARD   = -12 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast backward at 12 times the normal speed*//**<CNcomment:12            */
+    HI_UNF_PVR_PLAY_SPEED_16X_FAST_BACKWARD = -16 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 16 times the normal speed*//**<CNcomment:16           */
+    HI_UNF_PVR_PLAY_SPEED_24X_FAST_BACKWARD   = -24 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast backward at 24 times the normal speed*//**<CNcomment:24            */
+    HI_UNF_PVR_PLAY_SPEED_32X_FAST_BACKWARD = -32 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 32 times the normal speed*//**<CNcomment:32           */
+    HI_UNF_PVR_PLAY_SPEED_64X_FAST_BACKWARD = -64 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 64 times the normal speed*//**<CNcomment:64           */
+    HI_UNF_PVR_PLAY_SPEED_0_75X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL * 3/ 4,         /**<Slow forward at 3/4 times the normal speed*//**<CNcomment:3/4          */
+    HI_UNF_PVR_PLAY_SPEED_2X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 2,         /**<Slow forward at 1/2 times the normal speed*//**<CNcomment:1/2          */
+    HI_UNF_PVR_PLAY_SPEED_4X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 4,         /**<Slow forward at 1/4 times the normal speed*//**<CNcomment:1/4          */
+    HI_UNF_PVR_PLAY_SPEED_8X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 8,         /**<Slow forward at 1/8 times the normal speed*//**<CNcomment:1/8          */
+    HI_UNF_PVR_PLAY_SPEED_16X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 16,        /**<Slow forward at 1/16 times the normal speed*//**<CNcomment:1/16         */
+    HI_UNF_PVR_PLAY_SPEED_32X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 32,        /**<Slow forward at 1/32 times the normal speed*//**<CNcomment:1/32         */
+    HI_UNF_PVR_PLAY_SPEED_64X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 64,        /**<Slow forward at 1/64 times the normal speed*//**<CNcomment:1/64         */
+    HI_UNF_PVR_PLAY_SPEED_0_75X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL *3/ (-4),      /**<Slow backward at 3/4 times the normal speed.*//**<CNcomment:3/4  */
+    HI_UNF_PVR_PLAY_SPEED_2X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-2),      /**<Slow backward at 1/2 times the normal speed. *//**<CNcomment:1/2  */
+    HI_UNF_PVR_PLAY_SPEED_4X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-4),      /**<Slow backward at 1/4 times the normal speed.*//**<CNcomment:1/4  */
+    HI_UNF_PVR_PLAY_SPEED_8X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-8),      /**<Slow backward at 1/8 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/8  */
+    HI_UNF_PVR_PLAY_SPEED_16X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-16),     /**<Slow backward at 1/16 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/16 */
+    HI_UNF_PVR_PLAY_SPEED_32X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-32),     /**<Slow backward at 1/32 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/32 */
+    HI_UNF_PVR_PLAY_SPEED_64X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-64),     /**<Slow backward at 1/64 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/64 */
+
+    HI_UNF_PVR_PLAY_SPEED_0_5X_WITH_AUDIO = (HI_UNF_PVR_PLAY_SPEED_NORMAL / 2) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Slow forward with audio at 0.5 times the normal speed*//**<CNcomment:0.5*/
+    HI_UNF_PVR_PLAY_SPEED_0_8X_WITH_AUDIO = (4 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 5) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,     /**<Slow forward with audio at 0.8 times the normal speed*//**<CNcomment:0.8*/
+    HI_UNF_PVR_PLAY_SPEED_0_9X_WITH_AUDIO = (9 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 10) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Slow forward with audio at 0.9 times the normal speed*//**<CNcomment:0.9*/
+    HI_UNF_PVR_PLAY_SPEED_1_1X_WITH_AUDIO = (11 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 10) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.1 times the normal speed*//**<CNcomment:1.1*/
+    HI_UNF_PVR_PLAY_SPEED_1_2X_WITH_AUDIO = (6 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 5) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.2 times the normal speed*//**<CNcomment:1.2*/
+    HI_UNF_PVR_PLAY_SPEED_1_5X_WITH_AUDIO = (3 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 2) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.5 times the normal speed*//**<CNcomment:1.5*/
+    HI_UNF_PVR_PLAY_SPEED_BUTT                                                          /**<Invalid value*//**<CNcomment:         */
+} HI_UNF_PVR_PLAY_SPEED_E;
+
+/**Trick mode*//** CNcomment:   */
+typedef struct hiUNF_PVR_PLAY_MODE_S
+{
+    HI_UNF_PVR_PLAY_SPEED_E               enSpeed;    /**<For details about the playing speed, see the description of HI_UNF_PVR_PLAY_SPEED_E.*//**<CNcomment: HI_UNF_PVR_PLAY_SPEED_E */
+}HI_UNF_PVR_PLAY_MODE_S;
+
+typedef enum hiUNFPVR_TRICKPLAYTOEND_ACTION_E
+{
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_STOP = 0, /**report event and stop channel when fast forward to end of the file or fast backward to the start**//**<CNcomment:**/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_PLAY,     /**report event and switch to normal play when fast forward to end of the file or fast backward to the start**//**<CNcomment:**/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_BUTT        /**Invalid option**//**<CNcomment:**/
+}HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E;
+
+/**Attributes of a playing channel*//** CNcomment: */
+typedef struct hiUNF_PVR_PLAY_ATTR_S
+{
+    HI_UNF_PVR_STREAM_TYPE_E        enStreamType;                         /**<Type of the played stream, static attributes. At present, only the TS is supported.*//**<CNcomment: TS*/
+    HI_BOOL                         bIsClearStream;                       /**<Whether the stream to be played is the clear stream, static attribute. Scrambled streams can be played in normal mode only rather than in trick mode.*//**<CNcomment:  */
+    HI_UNF_PVR_CIPHER_S             stDecryptCfg;                         /**<Decryption configuration, static attribute                  *//**<CNcomment:                   */
+    HI_CHAR                         szFileName[PVR_MAX_FILENAME_LEN];     /**<Name of the file that contains the streams to be played, static attribute        *//**<CNcomment:         */
+    HI_U32                          u32FileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szFileName).*//**<CNcomment: strlenszFileName */
+    HI_UNF_PVR_SECURE_MODE_E        enSecureMode;                         /**<Secure channel indication*/ /**<CNcomment:*/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E  enTrickPlayToEndAction;             /**option for timeshift play, reference the HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E**//**<CNcomment:**/
+}HI_UNF_PVR_PLAY_ATTR_S;
+
+
+/**Description of the playing position*//** CNcomment:   */
+typedef struct hiUNF_PVR_PLAY_POSITION_S
+{
+    HI_UNF_PVR_PLAY_POS_TYPE_E  enPositionType;       /**<Position type*//**<CNcomment:            */
+    HI_S32                      s32Whence;            /**<Offset type, including SEEK_SET, SEEK_CUR, or SEEK_END*//**<CNcomment:SEEK_SET/SEEK_CUR/SEEK_END*/
+    HI_S64                      s64Offset;            /**<Offset. If the offset type is time, the offset is in the unit of millisecond; if the offset type is frame, the offset is in the unit of frame.*//**<CNcomment:  */
+}HI_UNF_PVR_PLAY_POSITION_S;
+
+/**Information required for creating an index file*//** CNcomment:  */
+typedef struct hiUNF_PVR_GEN_IDX_ATTR_S
+{
+    HI_U32                      u32UsrDataInfoLen;         /**<Length of the user data*//**<CNcomment:  */
+    HI_U32                      u32IdxPid;                 /**<Index PID*//**<CNcomment: Pid */
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIdxType;                 /**<Index type*//**<CNcomment:  */
+}HI_UNF_PVR_GEN_IDX_ATTR_S;
+
+/**Status of a playing channel*//** CNcomment: */
+typedef struct hiUNF_PVR_PLAY_STATUS_S
+{
+    HI_UNF_PVR_PLAY_STATE_E     enState;                              /**<Status of a playing channel*//**<CNcomment:                                  */
+    HI_UNF_PVR_PLAY_SPEED_E     enSpeed;                              /**<Playing speed of a playing channel*//**<CNcomment:                             */
+    HI_U64                      u64CurPlayPos;                        /**<Start position (byte) of the current frame in the file*//**<CNcomment:byte      */
+    HI_U32                      u32CurPlayFrame;                      /**<Start position (number of frames or PESs) of the current frame in the file*//**<CNcomment:PES       */
+    HI_U32                      u32CurPlayTimeInMs;                   /**<PTS of the current frame, in ms*//**<CNcomment: PTS,                      */
+}HI_UNF_PVR_PLAY_STATUS_S;
+
+/**<Data file attribution *//** CNcomment:*/
+typedef struct hiUNF_PVR_DATA_ATTR_S
+{
+    HI_U32     u32ChnID;                              /**<PVR channel, just consider one channel*//**<CNcomment: PVR */
+    HI_CHAR    CurFileName[PVR_MAX_FILENAME_LEN];     /**<Current reading file 's name include direction.If there are multi-node, the file name maybe different*//**<CNcomment:   */
+    HI_CHAR    IdxFileName[PVR_MAX_FILENAME_LEN+5];
+    HI_U64     u64FileStartPos;                       /**<Position of start frame ,it should be considered if rewind record ,0 invalid*//**<CNcomment:,0  */
+    HI_U64     u64FileEndPos;                         /**<Position of end frame ,it should be considered if rewind record ,0 invalid*//**<CNcomment:,0   */
+    HI_U64     u64GlobalOffset;
+    HI_U64     u64FileReadOffset;
+} HI_UNF_PVR_DATA_ATTR_S;
+
+/**<save buffer infomation *//**<CNcomment: buffer */
+typedef struct hiUNF_PVR_BUF_S
+{
+    HI_U8 *pu8VirAddr;        /**<virtual address*//**<CNcomment:*/
+    HI_U32 u32PhyAddr;        /**<physical address*//**<CNcomment:*/
+    HI_U32 u32Len;            /**<buffer length*//**<CNcomment:buffer */
+}HI_UNF_PVR_BUF_S;
+
+/**<Read or write data extra callback *//** CNcomment:*/
+typedef enum hiUNF_PVR_EXTRA_CALLBACK_E
+{
+    HI_UNF_PVR_EXTRA_READ_CALLBACK,          /**<Read data callback *//**<CNcomment:*/
+    HI_UNF_PVR_EXTRA_WRITE_CALLBACK,         /**<Write data callback*//**<CNcomment:*/
+    HI_UNF_PVR_EXTRA_CALLBACK_BUTT           /**<Invalid*//**<CNcomment:         */
+} HI_UNF_PVR_EXTRA_CALLBACK_E;
+
+/**<the record channel attribute ID *//** CNcomment:ID*/
+typedef enum hiUNF_PVR_REC_ATTR_ID_E
+{
+    HI_UNF_PVR_REC_ATTR_ID_REWIND = 0,                   /**<change the rewind attribute,only support changing the rewind attribute to not rewind, HI_BOOL*//** <CNcomment: */
+    HI_UNF_PVR_REC_ATTR_ID_FILE_FRAGMENT_SIZE,           /**<set the file fragment size when recording in merged storage PVR, HI_U64*//**<CNcomment:PVR*/
+    HI_UNF_PVR_REC_ATTR_ID_BUTT                          /**<Invalid*//**<CNcomment:         */
+} HI_UNF_PVR_REC_ATTR_ID_E;
+
+/**Attributes of Linearization channel*//** CNcomment: */
+typedef struct hiUNF_PVR_LINEARIZATION_ATTR_S
+{
+    HI_CHAR                     szSrcFileName[PVR_MAX_FILENAME_LEN];     /**<File name to be linearized, static attribute        *//**<CNcomment:         */
+    HI_U32                      u32SrcFileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szSrcFileName).*//**<CNcomment: strlenszSrcFileName */
+    HI_CHAR                     szDstFileName[PVR_MAX_FILENAME_LEN];     /**<After the linearization of the file name, static attribute        *//**<CNcomment:         */
+    HI_U32                      u32DstFileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szDstFileName).*//**<CNcomment: strlenszDstFileName */
+}HI_UNF_PVR_LINEARIZATION_ATTR_S;
+
+/**status of Linearization channel*//** CNcomment: */
+typedef struct hiUNF_PVR_LINEARIZATION_STATUS_S
+{
+    HI_U32  u32TotalFrameNum;               /**The total number of frames currently processed for the file..*//**<CNcomment: */
+    HI_U32  u32CurrentFixFrameNum;          /**The current number of frames processed..*//**<CNcomment: */
+}HI_UNF_PVR_LINEARIZATION_STATUS_S;
+
+/**<Callback function type when asynchronously processing truncate. CNcomment:truncateCNend
+\param[in] pszSrcFileName  Pointer to the original file name CNcomment:CNend
+\param[in] u32SrcFileNameLen    The length of original file name CNcomment:CNend
+\param[in] pszDstFileName    Pointer to the destination file name  CNcomment:CNend
+\param[in] u32DstFileNameLen   The length of destination file name  CNcomment:CNend
+\param[in] s32ErrCode The error code of truncate CNcomment:truncateCNend
+\param[in] pArgs    User private data CNcomment:CNend
+\note: This callback function only needs to be processed asynchronously CNcomment:CNend
+*/
+typedef HI_S32 (*TruncateCallBack)(HI_CHAR *pszSrcFileName, HI_U32 u32SrcFileNameLen, HI_CHAR *pszDstFileName, HI_U32 u32DstFileNameLen, HI_S32 s32ErrCode, HI_VOID *pArgs);
+
+/*Attributes of truncate*/
+typedef struct hiUNF_PVR_RECFILE_TRUNCATE_INFO_S
+{
+    HI_BOOL             bSync;                  /**Whether need to be synchronized*//**<CNcomment: */
+    HI_U32              u32PaddingTimeMs;       /**Redundant data that guarantees data integrity*//**<CNcomment: */
+    HI_BOOL             bTruncateHead;          /**Whether need to be deal with Head*//**<CNcomment: */
+    HI_U32              u32StartTimeMs;         /**Expected starting position*//**<CNcomment: */ /* <= u32StartTimeMs-u32PaddingTimeMs*/
+    HI_BOOL             bTruncateTail;          /**Whether need to be deal with Tail*//**<CNcomment: */
+    HI_U32              u32EndTimeMs;           /**Expected end position*//**<CNcomment: **/ /* >= u32EndTimeMs+u32PaddingTimeMs*/
+    TruncateCallBack    pfnAsyncCB;             /**The callback funcation of Asynchronously*//**<CNcomment: */
+    HI_VOID             *pArgs;                 /**The private data of callback*//**<CNcomment: */
+}HI_UNF_PVR_RECFILE_TRUNCATE_INFO_S;
+
+/**<Read or write data extra callback type. CNcomment:CNend
+\param[in] pstDataAttr  Pointer to the attributes of current used data file CNcomment: CNend
+\param[in] pu8DataAddr    Pointer to the virtual address CNcomment:CNend
+\param[in] u32PhyAddr    Pointer to the physical address CNcomment:CNend
+\param[in] u32Offset    offset CNcomment:CNend
+\param[in] u32DataSize buffer size CNcomment:buffer CNend
+*/
+typedef HI_S32 ( *ExtraCallBack)(HI_UNF_PVR_DATA_ATTR_S *pstDataAttr, HI_U8 *pu8DataAddr, HI_U32 u32PhyAddr, HI_U32 u32Offset, HI_U32 u32DataSize);
+
+/**<Read or write data extend callback type. CNcomment:CNend
+\param[in] pstDataAttr  Pointer to the attributes of current used data file CNcomment: CNend
+\param[in] pstDstBuf    Pointer to the attributes of destination buffer CNcomment:buffer CNend
+\param[in] pstSrcBuf    Pointer to the attributes of source buffer CNcomment:buffer CNend
+\param[in] u32Offset    offset CNcomment:CNend
+\param[in] u32DataSize buffer size CNcomment:buffer CNend
+\param[in] pUserData    user data CNcomment:CNend
+\note: This callback has two different from the ExtraCallBack: 1) support different address for src/dst buffer; 2) support the use of user's private data. the address of src/dst buffer are different for tee record.
+	   CNcomment:ExtraCallBack1)buffer2)TEEbufferCNend
+*/
+typedef HI_S32 (*ExtendCallBack)(HI_UNF_PVR_DATA_ATTR_S *pstDataAttr, HI_UNF_PVR_BUF_S *pstDstBuf, HI_UNF_PVR_BUF_S *pstSrcBuf,
+                                    HI_U32 u32Offset, HI_U32 u32DataSize, HI_VOID *pUserData);
+
+/**Defines the attributes when an recording channel is in Flushing Stream Status.*/
+/**CNcomment:PVRFlush Stream */
+typedef struct hiUNF_PVR_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_PVR_FLUSH_STREAM_OPT_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PVR  */
+/** @{ */  /** <!-- [PVR]*/
+
+/***** Application programming interfaces (APIs) for the PVR recoding module*****/
+
+/**
+\brief Initializes the PVR recording module. CNcomment:PVR CNend
+\attention \n
+If you initialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.
+Before using the APIs of the PVR recording module, you must call this API. Otherwise, other APIs are unavailable.
+CNcomment: .
+PVR CNend
+\param N/A CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors. CNcomment: API CNend
+\see \n
+::HI_UNF_PVR_RecDeInit
+*/
+HI_S32 HI_UNF_PVR_RecInit(HI_VOID);
+
+/**
+\brief Deinitializes the PVR recording module. CNcomment: PVR CNend
+\attention \n
+If you deinitialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.\n
+Before deintializing the PVR recording module, you must release all the recording channels. Otherwise,
+the error code HI_ERR_PVR_BUSY is returned.
+CNcomment:\n
+PVRHI_ERR_PVR_BUSY CNend
+\param N/A CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors.CNcomment: API CNend
+\retval ::HI_ERR_PVR_BUSY  The PVR recording module is being used. CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment:  CNend
+\see \n
+::HI_UNF_PVR_RecInit
+*/
+HI_S32 HI_UNF_PVR_RecDeInit(HI_VOID);
+
+/**
+\brief Creates a recording channel. CNcomment: 1 CNend
+\attention \n
+The PVR recording module automatically generates an .idx index file based on the file name specified in pAttr. \n
+The PVR recording module splits the recorded streams files to ensure that the size of each file is not greater than 4 GB (the size of each file is about 3.99 GB). \n
+The names of streams files are szFileName, szFileName.0001, szFileName.0002, szFileName.0003, szFileName.0004.\n
+If the file specified in pAttr already exists, it is replaced.\n
+If the index file to be created by the PVR recording module already exists, the file is also replaced.\n
+If the PVR calls the APIs of other modules (such as the APIs of the audio module, video module, and DEMUX module), the error codes of other modules may be returned.\n
+the error codes of other modules may be returned. For details, see the definitions of the error codes of corresponding modules.This description is applicable to the following APIs.
+This description is applicable to the following APIs.
+CNcomment:PVRpAttr".idx"\n
+PVR4G3.99G
+szFileNameszFileName.0001szFileName.0002szFileName.0003szFileName.0004\n
+pAttr\n
+PVR\n
+PVRAPIAPIDEMUX API
+API  CNend
+\param[in] pu32ChnID   ID of the obtained recording channel  CNcomment: ID CNend
+\param[in] pstRecAttr  Pointer to the attributes of a channel   CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR The pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid.  CNcomment:   CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME  The file name is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_EXIST The file already exists.  CNcomment: CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT  There is no available channel.   CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The file cannot be opened.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_INDEX_CANT_MKIDX  The index file cannot be opened.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_REC_INVALID_DMXID The DEMUX ID received during recording is incorrect.  CNcomment: DEMUX ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecCreateChn(HI_U32 *pu32ChnID, const HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief  Releases a specified recording channel. CNcomment:  CNend
+\attention \n
+CNcomment:If the channel to be released is not stopped, the error code HI_ERR_PVR_BUSY is returned.
+::HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID   ID of the channel to be released CNcomment:  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_BUSY  The current operation is forbidden because the channel is busy. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecDestroyChn(HI_U32 u32ChnID);
+
+/**
+\brief Sets the attributes of a recording channel. CNcomment:  CNend
+\attention \n
+You can modify only the dynamic attributes by calling this API.
+CNcomment: CNend
+\param[in] u32ChnID   Channel ID CNcomment:  CNend
+\param[in] pstRecAttr  Attribute to be set  CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The function is not supported. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecSetChn(HI_U32 u32ChnID, const HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief Obtains the attributes of a recording channel. CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32ChnID   Channel ID CNcomment:  CNend
+\param[out] pstRecAttr   Pointer to the obtained channel attributes   CNcomment: CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The specified channel is not initialized.   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecGetChn(HI_U32 u32ChnID, HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief Starts a recording channel. CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32ChnID Channel ID   CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized. CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID    The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   The specified channel is not initialized.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_ALREADY       The specified channel has been started.  CNcomment:  CNend
+\retval ::HI_FAILURE                 This API fails to be called due to system errors.  CNcomment:API CNend
+\see \n
+::HI_UNF_PVR_RecStopChn
+*/
+HI_S32 HI_UNF_PVR_RecStartChn(HI_U32 u32ChnID);
+
+/**
+\brief Stops a recording channel. CNcomment:  CNend
+\attention \n
+If a recording channel is working in time-shift playing mode, the channel cannot be stopped until the time-shift operation stops.
+In this case, the error code HI_ERR_PVR_BUSY is returned if you call this API.
+CNcomment:1 \n
+HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID   Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.    CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT     The specified channel is not initialized. CNcomment: CNend
+\retval ::HI_ERR_PVR_ALREADY         The specified channel has been stopped.    CNcomment: CNend
+\retval ::HI_ERR_PVR_BUSY            The current operation is forbidden because the channel is busy. CNcomment: CNend
+\see \n
+::HI_UNF_PVR_RecStartChn
+*/
+HI_S32 HI_UNF_PVR_RecStopChn(HI_U32 u32ChnID);
+
+/**
+\brief Pauses a recording channel. CNcomment:  CNend
+\attention \n
+It should be called under recording mode and can be repeated call.
+CNcomment: CNend
+\param[in] u32ChnID   Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  PVR isn't playing or pausing. CNcomment: PVR CNend
+\see \n
+::HI_UNF_PVR_RecResumeChn
+*/
+HI_S32 HI_UNF_PVR_RecPauseChn(HI_U32 u32ChnID);
+
+/**
+\brief Resumes a recording channel. CNcomment:  CNend
+\attention \n
+It should be called under recording mode and can be repeated call.
+CNcomment: CNend
+\param[in] u32ChnID   Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  PVR isn't playing or paused.CNcomment: PVR CNend
+\see \n
+::HI_UNF_PVR_RecPauseChn
+*/
+HI_S32 HI_UNF_PVR_RecResumeChn(HI_U32 u32ChnID);
+
+/**
+\brief Obtains the status of a recording channel.CNcomment:   CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[out] pstRecStatus   Pointer to the recording status   CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID   The channel ID is invalid.   CNcomment:  CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecGetStatus(HI_U32 u32ChnID, HI_UNF_PVR_REC_STATUS_S *pstRecStatus);
+
+
+/***** APIs for the PVR playing module *****/
+/**
+\brief Initializes the PVR playing module. CNcomment: PVR CNend
+\attention \n
+If you initialize the PVR playing module repeatedly, the error code HI_SUCCESS is returned.\n
+Before using the APIs of the PVR playing module, you must call this API. Otherwise, other APIs are unavailable.
+CNcomment: \n
+PVR CNend
+\param N/A
+\retval ::HI_SUCCESS         Success CNcomment: CNend
+\retval ::HI_FAILURE           This API fails to be called due to system errors.    CNcomment:API CNend
+\see \n
+::HI_UNF_PVR_PlayDeInit
+*/
+HI_S32 HI_UNF_PVR_PlayInit(HI_VOID);
+
+/**
+\brief Deinitializes the PVR playing module.  CNcomment:PVR CNend
+\attention \n
+If you deinitialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.\n
+Before deintializing the PVR playing module, you must release all the playing channels. Otherwise, the error code HI_ERR_PVR_BUSY is returned.
+CNcomment: \n
+PVR::HI_ERR_PVR_BUSY CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE          This API fails to be called due to system errors.   CNcomment: API CNend
+\retval ::HI_ERR_PVR_BUSY  The PVR playing module is being used.  CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized.CNcomment:  PVR CNend
+\see \n
+::HI_UNF_PVR_PlayInit
+*/
+HI_S32 HI_UNF_PVR_PlayDeInit(HI_VOID);
+
+/**
+\brief Creates a playing channel. CNcomment:1 CNend
+\attention \n
+The PVR playing module automatically searches for an .idx index file based on the file name specified in pAttr.
+If the index file does not exist, the PVR playing module attempts to play the stream file, but cannot support some features,
+such as fast forward, fast backward, or seek. The features vary according to versions of the software developer's kit (SDK).
+Only the playing function is supported in the current version.
+The played file may be the file that is being recorded (that is, time-shift playing).
+The audio/video player (AVPLAY) indicated by hAVPLAY must be stopped.
+CNcomment:PVRpAttr".idx" \n
+PVR
+SEEK\n
+
+hAVPlayavplaystop CNend
+\param[out] pu32ChnID  ID of the obtained playing channel  CNcomment: ID CNend
+\param[in] pstPlayAttr  Pointer to the channel attributes CNcomment:  CNend
+\param[in] hAvplay      AVPLAY handle. It specifies the APVPLAY to be used. CNcomment: avplayavplay CNend
+\param[in] hTsBuffer  TS buffer handle. It specifies that TS buffer that is used for playback. In general, the TS port corresponding to the TS buffer must be attached to the DEMUX corresponding to the AVPLAY.
+tCNcomment:s bufferts bufferts buffertshAVPlaydemux CNend
+\retval ::HI_SUCCESS   Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT       The PVR recording module is not initialized.  CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_NUL_PTR            The pointer is null. CNcomment:   CNend
+\retval ::HI_ERR_DMX_INVALID_PARA        The parameter is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME   The file name is invalid.   CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_EXIST          The file already exists.  CNcomment: CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT        There is no available channel. CNcomment:   CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN      The file cannot be opened.   CNcomment:   CNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST      The file cannot be played because it does not exist. CNcomment:  CNend
+\retval ::HI_ERR_PVR_NO_MEM             The buffer required for playing cannot be allocated due to insufficient memory. CNcomment: Buffer CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ   The file cannot be read.  CNcomment:    CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayCreateChn(HI_U32 *pu32ChnID, const HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr, HI_HANDLE hAvplay, HI_HANDLE hTsBuffer);
+
+/**
+\brief Releases a specified playing channel. CNcomment: CNend
+\attention \n
+If the channel to be released is not stopped, the error code HI_ERR_PVR_BUSY is returned.
+CNcomment:::HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID  ID of the channel to be released CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT     The PVR recording module is not initialized.   CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID       The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_BUSY  The current operation is forbidden because the channel is busy.  CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayDestroyChn(HI_U32 u32ChnID);
+
+/**
+\brief
+Starts a time-shift playing channel.
+You can call this API to start a time-shift playing channel based on the entered IDs of recording channels. To be specific, this API automatically initializes a playing channel to play files based on the parameter configuration of the corresponding recording channel.
+CNcomment:11 CNend
+\attention \n
+This API is not recommended. It is used to be compatible with other interfaces. You are recommended to call HI_UNF_PVR_PlayCreateChn and HI_UNF_PVR_PlayStartChn in sequence to start to play. If you want to enable the time-shift playing mode,
+you only need to set same names for the file to be played and recorded file. Then the PVR automatically identifies the same names, and enters the time-shift playing mode.
+After HI_UNF_PVR_PlayStartTimeShift is called, HI_UNF_PVR_PlayCreateChn is automatically called to allocate a playing channel. Therefore, you do not need to call HI_UNF_PVR_PlayNewChn.\n
+In addition, before calling HI_UNF_PVR_PlayStartTimeShift, you must start the corresponding recording channel. Otherwise, the error code HI_ERR_PVR_REC_INVAL_STATE is returned.\n
+After you start a time-shift playing channel by calling this API, the corresponding recording channel cannot be stopped or destroyed until time-shift playing stops.
+CNcomment:HI_UNF_PVR_PlayCreateChnHI_UNF_PVR_PlayStartChn
+PVR
+1HI_UNF_PVR_PlayCreateChnHI_UNF_PVR_PlayCreateChn \n
+HI_ERR_PVR_REC_INVAL_STATE \n
+1 CNend
+\param[out] pu32PlayChnID   ID of a playing channel CNcomment: CNend
+\param[in] u32RecChnID    ID of the recording channel to be time-shifted CNcomment:  CNend
+\param[in] hAvplay     AVPLAY handle. It specifies the APVPLAY to be used.   CNcomment:avplayavplay CNend
+\param[in] hTsBuffer    TS buffer handle. It specifies that TS buffer that is used for playback. In general, the TS port corresponding to the TS buffer must be attached to the DEMUX corresponding to the AVPLAY.
+CNcomment:ts bufferts bufferts buffertshAVPlaydemux CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR The pointer is null.  CNcomment: CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_DMXID The DEMUX ID received during playing is incorrect. CNcomment:DEMUX ID CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid. CNcomment:  CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT The specified channel is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_PVR_ALREADY  The specified channel has been started. CNcomment: CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT  There is no available playing channel.CNcomment:  CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  The recording channel is not started.CNcomment:   CNend
+\retval ::HI_ERR_PVR_NO_MEM   The buffer required for playing cannot be allocated due to insufficient memory.CNcomment: Buffer CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors. CNcomment:API CNend
+\see \n
+::HI_UNF_PVR_PlayStopTimeShift
+*/
+HI_S32 HI_UNF_PVR_PlayStartTimeShift(HI_U32 *pu32PlayChnID, HI_U32 u32RecChnID, HI_HANDLE hAvplay, HI_HANDLE hTsBuffer);
+
+/**
+\brief Stops a playing channel.  CNcomment: CNend
+\attention \n
+This API must work with ::HI_UNF_PVR_PlayStartTimeShift, and this API can be only used to stop the playing channel that is started by calling ::HI_UNF_PVR_PlayStartTimeShift.
+You must call ::HI_UNF_PVR_PlayStopTimeShift rather than ::HI_UNF_PVR_PlayStopChn to stop the playing channel that is started by calling ::HI_UNF_PVR_PlayStartTimeShift.
+
+CNcomment:::HI_UNF_PVR_PlayStartTimeShift::HI_UNF_PVR_PlayStartTimeShift \n
+::HI_UNF_PVR_PlayStartTimeShift::HI_UNF_PVR_PlayStopChn CNend
+\param[in] u32PlayChnID Channel ID  CNcomment: CNend
+\param[in] pstStopOpt  Pointer to the attribute structure when the AVPLAY stops CNcomment: CNend
+\retval ::HI_SUCCESS  SuccessCNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized. CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID        The channel ID is invalid. CNcomment:   CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment:  CNend
+\retval ::HI_ERR_PVR_ALREADY            The specified channel has been started.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE    The channel status is incorrect. For example, you call this API to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+CNcomment:::HI_UNF_PVR_PlayStartChn CNend
+\see \n
+::HI_UNF_PVR_PlayStartTimeShift
+*/
+HI_S32 HI_UNF_PVR_PlayStopTimeShift(HI_U32 u32PlayChnID, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Sets the attributes of a playing channel. CNcomment: CNend
+\attention \n
+You can set the dynamic attributes only by calling this API.
+CNcomment: CNend
+\param[in] u32ChnID    Channel ID CNcomment:  CNend
+\param[in] pstPlayAttr  Pointer to the channel attributes to be set  CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The function is not supported. CNcomment: CNend
+\see \n
+::HI_UNF_PVR_PlayGetChn
+*/
+HI_S32 HI_UNF_PVR_PlaySetChn(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr);
+
+/**
+\brief  Obtains the attributes of a playing channel. CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32ChnID   Channel ID CNcomment:CNcomment: CNend
+\param[out] pstPlayAttr   Pointer to the obtained channel attributes CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized.CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID   The channel ID is invalid. CNcomment:   CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   The specified channel is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_PVR_NUL_PTR      The pointer is null.  CNcomment:   CNend
+\see \n
+::HI_UNF_PVR_PlaySetChn
+*/
+HI_S32 HI_UNF_PVR_PlayGetChn(HI_U32 u32ChnID, HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr);
+
+/**
+\brief  Starts a playing channel. CNcomment: CNend
+\attention \n
+You can call this API to start the channel that is created by calling ::HI_UNF_PVR_PlayCreateChn only once. To pause or resume playing,
+you need to call ::HI_UNF_PVR_PlayPauseChn and ::HI_UNF_PVR_PlayResumeChn respectively.
+CNcomment:::HI_UNF_PVR_PlayCreateChn/
+::HI_UNF_PVR_PlayPauseChn::HI_UNF_PVR_PlayResumeChn CNend
+\param[in] u32ChnID Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT     The PVR recording module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_ALREADY        The specified channel has been started.   CNcomment:  CNend
+\retval ::HI_FAILURE                 This API fails to be called due to system errors. CNcomment: API CNend
+\see \n
+::HI_UNF_PVR_PlayStopChn
+*/
+HI_S32 HI_UNF_PVR_PlayStartChn(HI_U32 u32ChnID);
+
+/**
+\brief  Stops a playing channel. CNcomment: CNend
+\attention \n
+This API must work with ::HI_UNF_PVR_PlayStartChn, and this API can be only used to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+You must call ::HI_UNF_PVR_PlayStopChn rather than HI_UNF_PVR_PlayStopTimeShift to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+CNcomment:::HI_UNF_PVR_PlayStartChn::HI_UNF_PVR_PlayStartChn \n
+::HI_UNF_PVR_PlayStartChn::HI_UNF_PVR_PlayStopTimeShift CNend
+\param[in] u32ChnID  Channel ID CNcomment: CNend
+\param[in] pstStopOpt  Pointer to the attribute structure when the AVPLAY stops  CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized. CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_ALREADY        The specified channel has been started.  CNcomment:   CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE The channel status is incorrect. For example, you call this API to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartTimeShift.
+CNcomment:::HI_UNF_PVR_PlayStartTimeShift CNend
+\see \n
+::HI_UNF_PVR_PlayStartChn
+*/
+HI_S32 HI_UNF_PVR_PlayStopChn(HI_U32 u32ChnID, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief  Pauses a playing channel. CNcomment: CNend
+\attention \n
+If you call this API when the channel is paused, the error code HI_SUCCESS is returned.\n
+If you call this API is called when the channel is stopped, the error code HI_ERR_PVR_PLAY_INVALID_STATE is returned.
+CNcomment:::HI_UNF_PVR_PlayPauseChn \n
+::HI_ERR_PVR_PLAY_INVALID_STATE CNend
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS  Success CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT      The PVR recording module is not initialized. CNcomment:  PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment:   CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.  CNcomment: CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped. CNcomment:  CNend
+\see \n
+::HI_UNF_PVR_PlayResumeChn
+*/
+HI_S32 HI_UNF_PVR_PlayPauseChn(HI_U32 u32ChnID);
+
+/**
+\brief Resumes a playing channel. You can resume a playing channel or enable a playing channel to exit the pause mode by calling this API.
+CNcomment: CNend
+\attention \n
+This API must work with HI_UNF_PVR_PlayPauseChn. In addition, a channel can be resumed only when it is paused.
+CNcomment:::HI_UNF_PVR_PlayPauseChn CNend
+\param[in] u32ChnID Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT       The PVR recording module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.   CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT     The specified channel is not initialized.   CNcomment: CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE The specified channel is not paused.   CNcomment: CNend
+\see \n
+::HI_UNF_PVR_PlayPauseChn
+*/
+HI_S32 HI_UNF_PVR_PlayResumeChn(HI_U32 u32ChnID);
+
+/**
+\brief Starts the trick playing mode. You can call this API to start the trick playing mode. In this mode, the operations include fast forward, fast backward, slow playing, and normal playing.
+CNcomment: CNend
+\attention \n
+If you want to switch the trick playing mode to the normal playing mode, you only need to the playing speed in trick playing mode to PVR_PLAY_SPEED_NORMAL.
+CNcomment:PVR_PLAY_SPEED_NORMAL CNend
+\param[in] u32ChnID      Channel ID CNcomment:  CNend
+\param[in] pstTrickMode   Pointer to the information about the trick playing mode  CNcomment: CNend
+\retval ::HI_SUCCESS   Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized.   CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.      CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment: CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped.  CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA      The parameter is invalid.     CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT    The trick playing mode is not supported.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayTPlay(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_MODE_S *pstTrickMode);
+
+/**
+\brief Seeks a specified position to play, seeks by size and frame is not supported currently. CNcomment:, CNend
+\attention \n
+If you call this API when the channel is disabled, the error code :HI_ERR_PVR_PLAY_INVALID_STATE is returned.\n
+If the sought position is out of the boundary, the position is adjusted to the boundary automatically.\n
+If you seek the position backward or from the start of a file, the next I frame in the corresponding position is sought. Otherwise, the previous I frame is sought.\n
+If you seek the position forward or from the end of a file, the previous I frame in the corresponding position is sought. Otherwise, the next I frame is sought.\n
+If no I frame is found, an error code is returned.
+CNcomment:::HI_ERR_PVR_PLAY_INVALID_STATE\n
+seek\n
+seekseekseekII\n
+seekseekseekII\n
+I CNend
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] pstPosition Pointer to the playing position.  CNcomment: CNend
+\retval ::HI_SUCCESS  Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID        The channel ID is invalid.   CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment: CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE  The channel status is incorrect, that is , the channel has been stopped.  CNcomment:  CNend
+\retval ::HI_ERR_DMX_INVALID_PARA       The parameter is invalid.   CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT     The seek mode is not supported.   CNcomment:Seek CNend
+\retval ::HI_ERR_PVR_FILE_TILL_END       No corresponding frame is sought till the end of a file.  CNcomment:Seek CNend
+\retval ::HI_ERR_PVR_FILE_TILL_START   No corresponding frame is sought till the start of a file.    CNcomment:Seek CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ     The file cannot be read.   CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlaySeek(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_POSITION_S *pstPosition);
+
+/**
+\brief Plays streams by frame. You can call this API to start step forward mode or step backward mode.
+CNcomment:  CNend
+\attention \n
+Step backward mode is not supported currently. CNcomment: CNend
+\param[in] u32ChnID     Channel ID  CNcomment: CNend
+\param[in] s32Direction  Playing direction. If the value is greater than or equal to 0, the direction is forward; if the value is less than 0, the direction is backward. CNcomment:  00 CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized. CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.    CNcomment:  CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped. CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT   This function is not supported.  CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayStep(HI_U32 u32ChnID, HI_S32 s32Direction);
+
+/**
+\brief Obtains the playing status of the PVR. CNcomment:PVR CNend
+\attention \n
+Before calling this API to obtain the playing status, you must create a player.
+CNcomment: CNend
+\param[in] u32ChnID
+\param[in] pstStatus
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_BUSY   The system is busy. Please try again later. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayGetStatus(HI_U32 u32ChnID, HI_UNF_PVR_PLAY_STATUS_S *pstStatus);
+
+/**
+\brief Obtains the information about the stream file recorded by the PVR based on the ID of the playing channel.  CNcomment:IDPVR CNend
+\attention \n
+You can call this API to obtain the fixed information about the file to be played. However, the information is variable in the time-shift scenario.
+You can call ::HI_UNF_PVR_PlayGetStatus to obtain the current playing position during playing.\n
+You can call ::HI_UNF_PVR_RecGetStatus to obtain the current recording position during time shifting.
+In addition, if both recording and playing do not start, you can call ::HI_UNF_PVR_GetFileAttrByFileName to obtain the attributes of a file.
+CNcomment: 
+::HI_UNF_PVR_PlayGetStatus \n
+::HI_UNF_PVR_RecGetStatus
+::HI_UNF_PVR_GetFileAttrByFileName CNend
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] pAttr Pointer to the playing status
+\param[in] pAttr   CNcomment: CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_INIT            The PVR playing module is not initialized.  CNcomment:PVR CNend
+\retval ::HI_ERR_PVR_NUL_PTR           The pointer is null.   CNcomment:  CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.   CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT        The specified channel is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN      The file cannot be opened.  CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ    The file cannot be read.   CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayGetFileAttr(HI_U32 u32ChnID, HI_UNF_PVR_FILE_ATTR_S *pAttr);
+
+/**
+\brief
+Obtains the information about a stream file.
+By calling this API, you can obtain the information about a specified stream file without creating a playing channel.
+CNcomment: CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+You can call this API to obtain the attributes of a stream file at any time.
+CNcomment:. CNend
+\param[in] pFileName Name of a stream file  CNcomment: CNend
+\param[in] pAttr   Pointer to the playing status   CNcomment: CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR       The pointer is null.    CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The file cannot be opened.  CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ   The file cannot be read. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_GetFileAttrByFileName(const HI_CHAR *pFileName, HI_UNF_PVR_FILE_ATTR_S *pAttr);
+
+/**
+\brief  Writes the user data. CNcomment:  CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+The value of u32UsrDataLen cannot be greater than that of u32UsrDataInfoSize. The value of u32UsrDataInfoSize (one of recording channel attributes) is set before a file is recorded.
+The user data is saved in the index file.\n
+You need to write the user data after starting a recording channel.
+CNcomment:pFileName \n
+u32UsrDataLenu32UsrDataInfoSize \n
+ \n
+ CNend
+\param[in] pFileName Name of a stream file CNcomment:  CNend
+\param[in] pInfo    Pointer to the user data. The memory is allocated by customers. CNcomment: CNend
+\param[in] u32UsrDataLen   Length of the user data CNcomment:  CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR       The pointer is null.   CNcomment:  CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN   The file cannot be opened.CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The file cannot be read.  CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA    The parameter is invalid.  CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_SetUsrDataInfoByFileName(const HI_CHAR *pFileName, HI_U8 *pInfo, HI_U32 u32UsrDataLen);
+
+/**
+\brief  Reads the user data. CNcomment:  CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+The return value of pUsrDataLen indicates the length of the obtained user data. The value is the smaller one between the values of u32BufLen and actual length of the user data.
+The actual length of the user data is greater than or equal to the maximum length of the user data set by calling HI_UNF_PVR_RecCreateChn. In this way, all user data can be read.\n
+The PVR does not save the length of the user data set by calling HI_UNF_PVR_SetUsrDataInfoByFileName, but save the maximum length of the user data set by calling HI_UNF_PVR_RecCreateChn.
+CNcomment:pFileName \n
+pUsrDataLenu32BufLen""
+""HI_UNF_PVR_RecNewChn \n
+PVRHI_UNF_PVR_SetUsrDataInfoByFileNameHI_UNF_PVR_RecNewChn CNend
+\param[in] pFileName    Name of a stream file CNcomment: CNend
+\param[in] pInfo    User data buffer. The memory is allocated by customers.   CNcomment: CNend
+\param[in] u32BufLen   Buffer length .CNcomment: CNend
+\param[in] pUsrDataLen Actual length of the obtained user data .CNcomment: CNend
+\retval ::HI_SUCCESS  Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null.      CNcomment:  CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN    The file cannot be opened. CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ    The file cannot be read.  CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA      The parameter is invalid.  CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_GetUsrDataInfoByFileName(const HI_CHAR *pFileName, HI_U8 *pInfo, HI_U32 u32BufLen, HI_U32* pUsrDataLen);
+
+/**
+\brief  Registers an event callback function. You can call this API to register a callback function for PVR event. In this way, you can handle the events occurred during PVR recording and playing.
+CNcomment: PVRPVR CNend
+\attention \n
+You can call ::HI_UNF_PVR_UnRegisterEvent to deregister an event. If a registered event is not deregistered, it is always valid.
+For the PVR_EVENT_PLAY_REACH_REC message, it is recommended to stop the playing of the PVR by calling the registered callback function, and switch the playing mode to live mode of the AVPLAY.
+If the recording attribute is set to non-rewind, the PVR_EVENT_REC_OVER_FIX message is reported at the end of recording when the recording length reaches the specified length.
+When the recording attribute is set to rewind, the PVR_EVENT_REC_OVER_FIX message is reported during each rewind. In this case, the value of s32EventValue of the message handling callback function is the times of rewind (counting from 1).
+The PVR_EVENT_REC_REACH_PLAY message is reported when the recording speed will reach the playing speed. In this case, the value of s32EventValue is the number of bytes between the recording position and the playing position.
+CNcomment: ::HI_UNF_PVR_UnRegisterEvent1
+PVR_EVENT_PLAY_REACH_RECPVRAVPLAY
+PVR_EVENT_REC_OVER_FIX
+PVR_EVENT_REC_OVER_FIXs32EventValue(1)
+PVR_EVENT_REC_REACH_PLAYs32EventValue CNend
+\param[in] enEventType  Type of the event to be registered.  CNcomment:  CNend
+\param[in] callBack   Event handling callback function.   CNcomment:  CNend
+\param[in] args      Parameters of a customized callback function.    CNcomment: CNend
+\retval ::HI_SUCCESS   Success CNcomment:  CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_INVAL   The event is invalid.  CNcomment:  CNend
+\retval ::HI_ERR_PVR_ALREADY         The registering event has been registered.    CNcomment:  CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_NOREG    Registration fails because the callback function pointer is incorrect. CNcomment:   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterEvent(HI_UNF_PVR_EVENT_E enEventType, eventCallBack callBack, HI_VOID *args);
+
+/**
+\brief  Deregisters a PVR event. CNcomment: PVR CNend
+\attention \n
+You can call this API to deregister an event. If a registered event is not deregistered, it is always valid.
+CNcomment: 1 CNend
+\param[in] enEventType      Type of the event to be deregistered    CNcomment:  CNend
+\retval ::HI_SUCCESS   Success  CNcomment: CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_INVAL  The event is invalid. CNcomment:  CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_NOREG  The deregistering event is not registered. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterEvent(HI_UNF_PVR_EVENT_E enEventType);
+
+/**
+\brief Create index file by ts file. CNcomment: CNend
+\attention \n
+This function is not supported currently.
+CNcomment:  CNend
+\param[in] pstTsFileName
+\param[in] pstIdxFileName
+\param[in] pAttr
+\retval ::HI_SUCCESS Success CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  This function is not supported. CNcomment:  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_CreateIdxFile(HI_U8* pstTsFileName, HI_U8* pstIdxFileName, HI_UNF_PVR_GEN_IDX_ATTR_S* pAttr);
+
+/**
+\brief Controls whether to output debugging information.  CNcomment: CNend
+\attention \n
+The debugging information about the severity level higher than the error level is output.
+CNcomment:error  CNend
+\param[in] enDebugLevel  Output level of the debugging information CNcomment:  CNend
+\retval none
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_PVR_ConfigDebugInfo(HI_LOG_LEVEL_E enDebugLevel);
+
+/**
+\brief  Deletes the stream files and index files generated during recording. CNcomment: CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+After this API is called, the stream files and index files generated during stream recording are deleted.
+If a stream file is greater than 4 GB, multiple files named data.ts, data.ts.0001, data.ts.0002, data.ts.0003, and ... are generated. To delete these files, you only need to enter the file name data.ts.
+CNcomment:pFileName\n
+\n
+4Gdata.ts, data.ts.0001, data.ts.0002, data.ts.0003 ...\n
+"data.ts" CNend
+\param[in] pFileName  Name of a stream file  CNcomment: CNend
+\retval none
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_PVR_RemoveFile(const HI_CHAR *pFileName);
+
+
+/**
+\brief
+Register extra write callback function.When the stream file need to be extra processed  CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32ChnID    Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   ? CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterExtraCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtraCallBack fCallback, HI_VOID *args);
+
+/**
+\brief Deregisters extra write callback function.When the stream file need to be extra processed  CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:    CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterExtraCallBack(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType);
+
+/**
+\brief
+Register extra write callback function.When the stream file need to be extra processed  CNcomment:  CNend
+\attention \n
+N/A
+\param[in] u32ChnID    Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\param[in] fCallback  Callback function CNcomment: CNend
+\param[in] pUserData  arguments of the Callback function CNcomment: CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   ? CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterExtendCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtendCallBack fCallback, HI_VOID *pUserData);
+
+/**
+\brief Deregisters extra write callback function.When the stream file need to be extra processed  CNcomment: CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\param[in] fCallback  Callback function CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:    CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterExtendCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtendCallBack fCallback);
+
+/**
+\brief register the callback function Which is called by PVR when the app informs pvr to change the recorded pids CNcomment:PIDCNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\param[in] fCallback  Callback function CNcomment:  CNend
+\param[in] pArgs  Callback function's parameters CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:    CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterPidChangeCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, PidChangeCallBack fCallback, HI_VOID *pArgs);
+
+/**
+\brief unregister the callback function which is called by PVR when the app informs pvr to change the recorded pids  CNcomment:PID CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment:  CNend
+\param[in] fCallback  Callback function CNcomment:  CNend
+\retval ::HI_SUCCESS Success  CNcomment:  CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:    CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_PVR_UnRegisterPidChangeCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, PidChangeCallBack fCallback);
+
+
+
+/**
+\brief create pid channel and create the binding relationship of rec channel.  CNcomment:PID   CNend
+\attention \n
+You can call this api after creating the rec channl successfully.  CNcomment:
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] u32Pid  PID value CNcomment: PID  CNend
+\retval ::HI_SUCCESS  Success. CNcomment: CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecAddPID(HI_U32 u32ChnID, HI_U32 u32Pid);
+
+/**
+\brief destroy pid channel and destroy the relationship with rec channel.  CNcomment:PID   CNend
+\attention \n
+You can call this api before destroying the rec channl.  CNcomment:
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] u32Pid  PID value CNcomment: PID  CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecDelPID(HI_U32 u32ChnID, HI_U32 u32Pid);
+
+/**
+\brief destroy any pid channel which has binding relationship with rec channel.  CNcomment:PID  CNend
+\attention \n
+
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecDelAllPID(HI_U32 u32ChnID);
+
+/**
+\brief change the record pid.  CNcomment: Pid CNend
+\attention \n
+\param[in] u32ChnId  Channel ID  CNcomment: CNend
+\param[in] pstPidInfo  PID info  CNcomment: PID CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:CNend
+\retval ::HI_ERR_PVR_NUL_PTR  The pointer is null. CNcomment:CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecChangePid(HI_U32 u32ChnId, HI_UNF_PVR_PID_CHANGE_INFO_S *pstPidInfo);
+
+/**
+\brief Set the recording channel attribute, only supports the rewind state is set to non-rewind state.  CNcomment:  CNend
+\attention \n
+
+\param[in] u32ChnID  Channel ID  CNcomment: CNend
+\param[in] enRecAttrID  attribute ID  CNcomment:ID CNend
+\param[in] pPara  Extra parameters  CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR module is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The record channel not support this operatin. CNcomment: CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecSetAttr(HI_U32 u32ChnID, HI_UNF_PVR_REC_ATTR_ID_E enRecAttrID, const HI_VOID *pPara);
+
+/**
+\brief Be Linear.  CNcomment:  CNend
+\attention \n
+
+\param[out] pu32ChnId  Channel ID  CNcomment: CNend
+\param[in] pstRepaireAttr  Linearization parameters  CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST  The specified file does not exist. CNcomment:   CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVRCNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The record channel not support this operatin. CNcomment: CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The specified file is not open. CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The specified file is not readable. CNcomment: CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileStartLinearization(HI_U32 *pu32ChnId, const HI_UNF_PVR_LINEARIZATION_ATTR_S *pstRepaireAttr);
+
+/**
+\brief Get linear progress.  CNcomment:  CNend
+\attention \n
+
+\param[in] u32ChnId  Channel ID  CNcomment: CNend
+\param[out] pstLineariztionStatus  Linearization channel status  CNcomment:CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileLinearizationGetStatus(HI_U32 u32ChnId, HI_UNF_PVR_LINEARIZATION_STATUS_S *pstLineariztionStatus);
+
+/**
+\brief stop Linear.  CNcomment:  CNend
+\attention \n
+
+\param[in] pu32ChnId  Channel ID  CNcomment: CNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileStopLinearization(HI_U32 u32ChnId);
+
+/**
+\brief Be Linear.  CNcomment: PVRCNend
+\attention \n
+\param[in] pszSrcFileName  The original file name to be processed CNcomment: CNend
+\param[in] u32SrcFileNameLen  The length of the original file name CNcomment:  CNend
+\param[in] pszDstFileName  The Destination file name to be processed CNcomment: CNend
+\param[in] u32DstFileNameLen  The length of the Destination file name CNcomment:  CNend
+\param[in] pstTruncInfo  Pointer to the attributes of truncate CNcomment:truncateCNend
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  PVR does not support current operation. CNcomment: PVRCNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST  The specified file does not exist. CNcomment:   CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The specified file is not open. CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The specified file is not readable. CNcomment: CNend
+\retval ::HI_ERR_PVR_NO_MEM  Failed to malloc memory. CNcomment: CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME  Invalid file name. CNcomment: CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileTruncate(const HI_CHAR *pszSrcFileName, HI_U32 u32SrcFileNameLen, const HI_CHAR *pszDstFileName, HI_U32 u32DstFileNameLen, const HI_UNF_PVR_RECFILE_TRUNCATE_INFO_S *pstTruncInfo);
+
+
+/**
+\brief notify the record channel that the stream is end, PVR will try to receive all the un-aligned by 47K ts data from demux and report
+\        the event of HI_UNF_PVR_EVENT_REC_EOS if all the ts data has been received. if this api is not called, PVR won't receive the un-aligned of 47K ts data from the demux.
+\CNcomment:PVRdemux47KHI_UNF_PVR_EVENT_REC_EOS.
+\ CNcomment       PVRdemux47K.CNend
+\ attention: before calling the API, APP should make sure that no data is injected to the port of demux used by the record channel;
+\                  if this API is called, the length of ts data reported by ExtraCallBack/ExtendCallBack isn't always aligned
+\                  for the recording which the injecting data is always running(E.x. dvb/iptv recording), this API should not be called.
+\ CNcomment: APIAPPdemux portCNend
+\ CNcomment              ExtraCallBack/ExtendCallBack.CNend
+\ CNcomment              (dvb/iptv).CNend
+\param[in] u32ChnId  Channel ID  CNcomment: CNend
+\param[in] pstOpt  Pointer used for expansion. You can set it to NULL  CNcomment:NULL CNend
+\retval ::HI_SUCCESS if successing to configure, others if failure. CNcomment:HI_SUCCESSCNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFlushStream(HI_U32 u32RecChnID, HI_UNF_PVR_FLUSH_STREAM_OPT_S *pstOpt);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+
+#endif /* End of #ifndef __HI_UNF_PVR_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_pwm.h b/xbmc/platform/linux/hisi/hi_unf_pwm.h
new file mode 100644
index 0000000000..98e2f5424a
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_pwm.h
@@ -0,0 +1,162 @@
+/******************************************************************************
+
+   Copyright (C), 2011-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_pwm.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2013/10/28
+   Description   :
+   History       :
+   1.Date        : 2013/10/28
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ **\brief : define PWM module information
+ * \brief supply infor about display.
+ */
+
+#ifndef __HI_UNF_PWM_H__
+#define __HI_UNF_PWM_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PWM */
+/** @{ */  /** <!-- [PWM] */
+
+/**enum define about PWM*/
+/**CNcomment: PWM*/
+typedef enum hiUNF_PWM_E
+{
+    HI_UNF_PWM_0 = 0,   /**< PWM0 */
+    HI_UNF_PWM_1,       /**< PWM1 */
+    HI_UNF_PWM_2,       /**< PWM2 */
+    
+    HI_UNF_PWM_BUTT
+}HI_UNF_PWM_E;
+
+/**Define the PWM attributes*/
+/**CNcomment: PWM*/
+typedef struct hiUNF_PWM_ATTR_S
+{
+    HI_U32      u32Freq;        /**< Frequency(HZ)*//**< CNcomment: , HZ*/
+    HI_U32      u32DutyRatio;   /**< Duty ratio(calculated to three decimal places)*//**<CNcomment: */
+}HI_UNF_PWM_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PWM */
+/** @{ */  /** <!-- [PWM] */
+
+/**
+\brief Initializes the PWM module.CNcomment:PWM CNend
+\attention \n
+Before calling anyother interface, you must call this application programming interface (API) first.
+CNcomment PWM CNend
+\param  N/A
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_DEV_NOT_EXIST    There is no PWM. CNcomment:PWM CNend
+\retval ::HI_ERR_PWM_OPEN_ERR         Open PWM failed. CNcomment:PWM CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Init(HI_VOID);
+
+/**
+\brief DeInitializes the PWM module.CNcomment:PWM CNend
+\attention N/A
+\param  N/A
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_DEV_NOT_EXIST    There is no PWM. CNcomment:PWM CNend
+\retval ::HI_ERR_PWM_CLOSE_ERR        Open PWM failed. CNcomment:PWM CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_DeInit(HI_VOID);
+
+/**
+\brief Opem PWM.CNcomment:PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM::HI_UNF_PWM_E CNend
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Open(HI_UNF_PWM_E enPWM);
+
+/**
+\brief Close PWM.CNcomment:PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM::HI_UNF_PWM_E CNend
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Close(HI_UNF_PWM_E enPWM);
+
+/**
+\brief Set PWM attributes.CNcomment:PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM::HI_UNF_PWM_E CNend
+\param[out] pstAttr  Pointer of PWM attributes. CNcomment:PWM::HI_UNF_PWM_ATTR_S CNend
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_GetAttr(HI_UNF_PWM_E enPWM, HI_UNF_PWM_ATTR_S *pstAttr);
+
+/**
+\brief Set PWM attributes.CNcomment:PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM::HI_UNF_PWM_E CNend
+\param[in] pstAttr  Pointer of PWM attributes. CNcomment:PWM::HI_UNF_PWM_ATTR_S CNend
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_SetAttr(HI_UNF_PWM_E enPWM, HI_UNF_PWM_ATTR_S *pstAttr);
+
+/**
+\brief Send signal to PWM.CNcomment:PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM::HI_UNF_PWM_E CNend
+\param[in] u32CarrierTimeUs  The duration of carrier signal(us). CNcomment:(us) CNend
+\param[in] u32LowLevelTimeUs  The duration of low-level signal(us). CNcomment:(us) CNend
+\retval ::HI_SUCCESS                  Success CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_SendSignal(HI_UNF_PWM_E enPWM, HI_U32 u32CarrierTimeUs, HI_U32 u32LowLevelTimeUs);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
+
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_sci.h b/xbmc/platform/linux/hisi/hi_unf_sci.h
new file mode 100644
index 0000000000..b7c03ca1c3
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_sci.h
@@ -0,0 +1,652 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_sci.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_SCI_H__
+#define __HI_UNF_SCI_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SCI */
+/** @{*/  /** <!-- [SCI] */
+
+/**Output configuration of the smart card interface clock (SCICLK) pin*/
+/** CNcomment:SCICLK*/
+typedef enum  hiUNF_SCI_MODE_E
+{
+    HI_UNF_SCI_MODE_CMOS = 0, /**<Complementary metal-oxide semiconductor (CMOS) output*/   /**<CNcomment:CMOS*/
+    HI_UNF_SCI_MODE_OD, /**<Open drain (OD) output*/                                  /**<CNcomment:OD*/
+    HI_UNF_SCI_MODE_BUTT
+} HI_UNF_SCI_MODE_E;
+
+/**SCI port*/
+/** CNcomment:SCI  */
+typedef enum hiUNF_SCI_PORT_E
+{
+    HI_UNF_SCI_PORT0, /**< SCI port 0*/  /**<CNcomment:SCI0*/
+    HI_UNF_SCI_PORT1, /**< SCI port 1*/  /**<CNcomment:SCI1*/
+    HI_UNF_SCI_PORT_BUTT
+} HI_UNF_SCI_PORT_E;
+
+/**Status of the SCI card*/
+/** CNcomment: */
+typedef enum hiUNF_SCI_STATUS_E
+{
+    HI_UNF_SCI_STATUS_UNINIT = 0, /**<The SCI card is not initialized.(Reserved status) */               /**<CNcomment: SCI() */
+    HI_UNF_SCI_STATUS_FIRSTINIT, /**<The SCI card is being initialized.(Reserved status)*/             /**<CNcomment:SCI()*/
+    HI_UNF_SCI_STATUS_NOCARD, /**<There is no SCI card.*/                          /**<CNcomment: */
+    HI_UNF_SCI_STATUS_INACTIVECARD, /**<The SCI card is not activated (unavailable).*/   /**<CNcomment: */
+
+    //   HI_UNF_SCI_STATUS_CARDFAULT, /**<The SCI card is faulty.*/                        /**<CNcomment:*/
+    HI_UNF_SCI_STATUS_WAITATR, /**<The SCI card is waiting for the ATR data.*/      /**<CNcomment:ATR*/
+    HI_UNF_SCI_STATUS_READATR, /**<The SCI card is receiving the ATR data.*/        /**<CNcomment:ATR*/
+    HI_UNF_SCI_STATUS_ATR_ERROR, /**<The ATR is wrong.*/                        /**<CNcomment:ATR*/
+    HI_UNF_SCI_STATUS_READY, /**<The SCI card is available (activated).*/         /**<CNcomment: */
+    HI_UNF_SCI_STATUS_RX, /**<The SCI card is busy receiving data.*/           /**<CNcomment: */
+    HI_UNF_SCI_STATUS_TX /**<The SCI card is busy transmitting data.*/        /**<CNcomment: */
+} HI_UNF_SCI_STATUS_E;
+
+/**SCI protocol*/
+/** CNcomment:SCI  */
+typedef enum hiUNF_SCI_PROTOCOL_E
+{
+    HI_UNF_SCI_PROTOCOL_T0, /**<7816 T0 protocol*/   /**<CNcomment:7816 T0  */
+    HI_UNF_SCI_PROTOCOL_T1, /**<7816 T1 protocol*/   /**<CNcomment:7816 T1  */
+    HI_UNF_SCI_PROTOCOL_T14, /**<7816 T14 protocol*/  /**<CNcomment:7816 T14  */
+    HI_UNF_SCI_PROTOCOL_BUTT
+} HI_UNF_SCI_PROTOCOL_E;
+
+/**SCI active level*/
+/** CNcomment:SCI*/
+typedef enum hiUNF_SCI_LEVEL_E
+{
+    HI_UNF_SCI_LEVEL_LOW, /**<Active low*/   /**<CNcomment: */
+    HI_UNF_SCI_LEVEL_HIGH, /**<Active high*/  /**<CNcomment: */
+    HI_UNF_SCI_LEVEL_BUTT
+} HI_UNF_SCI_LEVEL_E;
+
+/** Secure mode type*/
+/**CNcomment:*/
+typedef enum hiUNF_SCI_SECURE_MODE_E
+{
+    HI_UNF_SCI_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:*/
+    HI_UNF_SCI_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone*/
+
+    HI_UNF_SCI_SECURE_MODE_BUTT
+} HI_UNF_SCI_SECURE_MODE_E;
+
+/**SCI system parameters*/
+/**CNcomment:SCI  */
+typedef struct hiUNF_SCI_PARAMS_S
+{
+    HI_UNF_SCI_PORT_E     enSciPort; /**<SCI port ID*/                                                      /**<CNcomment:SCI  */
+    HI_UNF_SCI_PROTOCOL_E enProtocolType; /**<Used protocol type*/                                    /**<CNcomment: */
+    HI_U32                ActalClkRate; /**<Actual clock rate conversion factor F*/                     /**<CNcomment:F  */
+    HI_U32                ActalBitRate; /**<Actual bit rate conversion factor D*/                         /**<CNcomment:D  */
+    HI_U32                Fi; /**<Clock factor returned by the answer to reset (ATR)*/                      /**<CNcomment:ATR  */
+    HI_U32                Di; /**<Bit rate factor returned by the ATR*/                                     /**<CNcomment:ATR  */
+    HI_U32                GuardDelay; /**<Extra guard time N*/                                        /**<CNcomment:N */
+    HI_U32                CharTimeouts; /**<Character timeout of T0 or T1*/                             /**<CNcomment:T0 T1*/
+    HI_U32                BlockTimeouts; /**<Block timeout of T1 */                                     /**<CNcomment:T1*/
+    HI_U32                TxRetries; /**<Number of transmission retries*/                                   /**<CNcomment:*/
+} HI_UNF_SCI_PARAMS_S, *HI_UNF_SCI_PARAMS_S_PTR;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SCI*/
+/** @{*/  /** <!-- [SCI] */
+
+/**
+ \brief Initializes the SCI.   CNcomment:SCICNend
+ \attention \n
+ \param  N/A                   CNcomment:CNend
+ \retval 0 Success             CNcomment:CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Init(HI_VOID);
+
+/**
+ \brief Deinitializes the SCI. CNcomment:SCICNend
+ \attention \n
+ \param  N/A                   CNcomment:CNend
+ \retval 0 Success             CNcomment:0 CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_DeInit(HI_VOID);
+
+/**
+ \brief Set the SCI SecurityMod.              CNcomment:SCICNend
+ \attention \n
+ \param[in]  SecurityMode        System mode  CNcomment:
+ \retval 0 Success               CNcomment:0 CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetSecurityMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_SECURE_MODE_E SecurityMode);
+
+/**
+ \brief Starts an SCI device to initialize it based on the input port and protocol. If there is an SCI card, the card is also initialized.\n
+CNcomment:SCISmart Card InterfaceSCICNend
+\attention \n
+After an SCI device is started, it is initialized based on the default configuration.\n
+If you modify the configuration, you need to call HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+If you remove and then insert the SCI card, you need to call HI_UNF_SCI_ResetCard to reset the card.\n
+You need to set frequency parameters when enabling an SCI device. The actual SCI clock provided by the chip is obtained by using the clock divider.\n
+The clock divider is calculated based on the externally transferred clock frequency parameters. The fractional part of the clock divider is discarded during calculation. \n
+Therefore, an enhanced error occurs when the SCI clock is obtained by dividing the system clock by the clock divider. You need to set the actual output frequency of \n
+the SCI card based on the close output frequency. The SCI clock is calculated as follows: Fsci_clk = Frefclk/[(Clkicc + 1) x 2]. Where, Frefclk is the 96 MHz system clock, \n
+Fsci_clk is the SCI clock required by peripherals, and clkicc is the required clock divider of registers. clkicc is calculated as follows: Clkicc = Frefclk/(2 x Fsci_clk) - 1. \n
+The clkicc may be a floating point value, but only the integral part is used. Therefore, the configured frequency is different from the actual frequency.\n
+
+CNcomment: SCI\n 
+HI_UNF_SCI_ResetCard\n 
+HI_UNF_SCI_ResetCard\n 
+SCI  \n
+\n
+ \n
+ Fsci_clk = Frefclk/[(Clkicc + 1) x 2];Frefclk96MFsci_clk \n
+sci,Clkicc = Frefclk/(2 x Fsci_clk) - 1;clkicc \n
+CNend
+
+ \param[in] enSciPort     ID of an SCI port. The port ID can be 0 or 1.  CNcomment:SCI01CNend
+ \param[in] enSciProtocol Protocol type.                                  CNcomment:CNend
+ \param[in] u32Frequency    Frequency of the SCI card to be set, in kHz. For the T0 and T1 cards, the frequency ranges from 1 MHz to 5 MHz; for the T14 card, the frequency must be set to 6 MHz.  CNcomment:SCIT0T11MHz5MHzT146MHzkhzCNend
+ \retval 0 Success.                                                       CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  SCI  No SCI device is started.           CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.            CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Open(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 u32Frequency);
+
+/**
+ \brief Stops an SCI device.
+CNcomment:SCICNend
+
+ \attention \n
+This API cannot be called repeatedly.
+CNcomment:CNend
+
+ \param[in] enSciPort     ID of an SCI port. The port ID can be 0 or 1.  CNcomment:SCI01CNend
+ \retval 0 Success.                                                       CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.               CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.            CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Close(HI_UNF_SCI_PORT_E enSciPort);
+
+/**
+ \brief Performs a warm reset on an SCI card.
+CNcomment:SCICNend
+
+ \attention \n
+If no SCI card is inserted, the reset fails.\n
+If you modify the configuration of an SCI device, you need to call HI_S32 HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+In addition, if you remove and insert an SCI card after calling HI_UNF_SCI_Open, you also need to call HI_S32 HI_UNF_SCI_ResetCard to reset the card.
+CNcomment:\n
+SCI\n
+SCICNend
+
+ \param[in] enSciPort   ID of an SCI port. The port ID can be 0 or 1                                             CNcomment:SCI01CNend
+ \param[in] bWarmResetValid   Reset mode.  HI_TRUE: warm reset; HI_FALSE: cold reset (recommended)    			 CNcomment:HI_TRUE: ; HI_FALSE: CNend
+ \retval 0 Success.                                                                                              CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ResetCard(HI_UNF_SCI_PORT_E enSciPort, HI_BOOL bWarmResetValid);
+
+/**
+ \brief Deactivates an SCI card.
+CNcomment:SCICNend
+
+ \attention \n
+After an SCI card is deactivated, the card cannot be read or written until it is reset.
+CNcomment:CNend
+
+ \param[in] enSciPort ID of an SCI port. The port ID can be 0 or 1.         CNcomment:SCI01CNend
+ \retval 0   Success.                                                        CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT No SCI device is started.                    CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.               CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_DeactiveCard(HI_UNF_SCI_PORT_E enSciPort);
+
+/**
+ \brief Obtains the ATR data of an SCI card.
+CNcomment:SCIATRCNend
+
+ \attention \n
+N/A
+ \param[in]  enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[out]  pu8AtrBuf   Address for storing the obtained ATR data.                                               CNcomment:ATRCNend
+ \param[in]  u32AtrBufSize  Length of the ATR data read from the buffer.                                          CNcomment:ATR  buffer CNend
+ \param[out]  pu8AtrRcvCount Actual number of ATR data segments.                                                   CNcomment:ATRCNend
+ \retval 0   Success.                                                                                             CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	  CNcomment: CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                     CNcomment:CNend
+ \retval ::HI_ERR_SCI_NO_ATR  There is no ATR data.                                                               CNcomment:ATRCNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			  				  CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetATR(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pu8AtrBuf, HI_U32 u32AtrBufSize, HI_U8 *pu8AtrRcvCount);
+
+/**
+ \brief Obtains the status of an SCI card.
+CNcomment:SCICNend
+
+ \attention \n
+This API is a non-block API. You can transfer data to an SCI card by calling HI_UNF_SCI_Send or HI_UNF_SCI_Receive only when the card status is HI_UNF_SCI_STATUS_READY.\n
+CNcomment:HI_UNF_SCI_STATUS_READYHI_UNF_SCI_SendHI_UNF_SCI_ReceiveCNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[out] penSCIStatus  Status of an SCI card.                                                                CNcomment: SCICNend
+ \retval 0 Success.                                                                                              CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	 CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetCardStatus(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_STATUS_E *penSciStatus);
+
+/**
+ \brief Transmits data to an SCI card.
+CNcomment:SCICNend
+
+ \attention \n
+Data must be transmitted based on application protocols.\n
+Data cannot be transmitted consecutively.\n
+In addition, data is transmitted and received in block mode. Therefore, when a large number of data is being transmitted, the transmission may fail if the timeout is too small.\n
+CNcomment: \n
+ \n
+CNend
+
+ \param[in] enSciPort   ID of an SCI port. The port ID can be 0 or 1.                                            CNcomment:SCI01CNend
+ \param[in]  pSciSendBuf Address for storing the data to be transmitted.                                          CNcomment:CNend
+ \param[in] u32SendLen  Number of data segments (in byte) to be transmitted.                                      CNcomment:, BYTECNend
+ \param[out]  pu32ActLen Number of transmitted data segments (in byte).                                            CNcomment:, BYTECNend
+ \param[in] u32TimeoutMs Wait timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block.                        CNcomment:, , 0 - , 0xFFFFFFFF-CNend
+ \retval 0 Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  SCI  No SCI device is started.                                                   CNcomment:CNend
+ \retval ::HI_ERR_SCI_NULL_PTR  The pointer is invalid.                                                     	 CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                                     CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			CNcomment:CNend
+ \retval ::HI_ERR_SCI_SEND_ERR  The transmission operation fails.                                             	CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Send(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciSendBuf, HI_U32 u32SendLen, HI_U32 *pu32ActLen,
+                       HI_U32 u32TimeoutMs);
+
+/**
+ \brief Receives data from an SCI card.
+CNcomment:SCICNend
+
+ \attention \n
+You must set the data length obtained by each upper-layer application based on the protocol. If the length of the obtained data is greater than that of the returned data, this API is returned after timeout occurs.\n
+CNcomment:CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[out]  pSciReceiveBuf   Address for storing the received data.                                              CNcomment:CNend
+ \param[in] u32ReceiveLen  Number of data segments (in byte) to be received.                                      CNcomment:, BYTECNend
+ \param[out]  pu32ActLen   Number of received data segments (in byte).                                             CNcomment:, BYTECNend
+ \param[in] u32TimeOutMs  Wait timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block.                       CNcomment:, , 0 - , 0xFFFFFFFF-CNend
+ \retval 0 Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                       CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_NULL_PTR  The pointer is invalid.                                                     	 CNcomment: CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \retval ::HI_ERR_SCI_RECEIVE_ERR  The reception operation fails.                                             	CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Receive(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciReceiveBuf, HI_U32 u32ReceiveLen, HI_U32 *pu32ActLen,
+                          HI_U32 u32TimeOutMs);
+
+/**
+ \brief Sets the active level of the VCCEN signal.
+CNcomment:VCCENCNend
+ \attention \n
+The active level needs to be set based on the circuits of hardware, and the low level is active by default.\n
+After changing the active level, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:HI_UNF_SCI_ResetCardCNend
+
+ \param[in] enSciPort ID of an SCI port. The port ID can be 0 or 1.                                              CNcomment:SCI01CNend
+ \param[in] enSciVcc  Active level of a signal. HI_FALSE: active low; HI_TRUE: active high  Active level of a signal. HI_FALSE: active low; HI_TRUE: active high.  CNcomment:HI_FALSEHI_TRUECNend
+ \retval 0   Success.                                                                                             CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                       CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigVccEn(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_LEVEL_E enSciVcc);
+
+/**
+ \brief Sets the active level of the DETECT signal.
+CNcomment:DETECTCNend
+
+ \attention \n
+The active level needs to be set based on the circuits of hardware, and the high level is active by default.\n
+After changing the active level, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:HI_UNF_SCI_ResetCardCNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[in] enSciDetect Active level of a signal. HI_FALSE: active low; HI_TRUE: active high.                     CNcomment:HI_FALSEHI_TRUECNend
+ \retval 0  Success.                                                                                              CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigDetect(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_LEVEL_E enSciDetect);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:CNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:ODHI_UNF_SCI_ResetCardCNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[in] enClkMode  Mode of a clock signal.                                                                    CNcomment:CNend
+ \retval 0 Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigClkMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enClkMode);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:RESETCNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:ODHI_UNF_SCI_ResetCardCNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[in] enClkMode  Mode of a reset signal.                                                                    CNcomment:CNend
+ \retval 0 Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			                 CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOTSUPPORT	Current chipset not support config RESET output type.                        CNcomment:RESETCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigResetMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enResetMode);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:POWERENCNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:ODHI_UNF_SCI_ResetCardCNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[in] enClkMode  Mode of a poweren signal.                                                                    CNcomment:CNend
+ \retval 0 Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			                 CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOTSUPPORT	Current chipset not support config POWEREN output type.                      CNcomment:POWERENCNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigVccEnMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enVccEnMode);
+
+
+/**
+ \brief Changes the card slot.
+CNcomment:CNend
+
+ \attention \n
+When you call HI_UNF_SCI_Open, the primary card is used by default, that is, port 0 is used.\n
+After you switch to a new SCI device, all the preceding SCI APIs are called to operate the new SCI device.\n
+In addition, after a new SCI device is switched, the device is initialized based on the default configuration.\n
+If any modifications are made, you need to call HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+If the SCI port to be switched to is the same as the current active port, an error code is returned.\n
+CNcomment:HI_UNF_SCI_Open0\n
+SCISCISCI\n
+SCI\n
+HI_UNF_SCI_ResetCard\n
+SCICNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param[in] enSciProtocol  Protocol type.                                                                         CNcomment:CNend
+ \param[in] u32Frequency Frequency of the SCI card to be set, in kHz. For the T0 and T1 cards, the frequency ranges from 1 MHz to 5 MHz; for the T14 card, the frequency must be set to 6 MHz. CNcomment:SCIT0T11MHz~5MHzT146MHzkHzCNend
+ \retval 0  Success.                                                                                              CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	 CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SwitchCard(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 u32Frequency);
+
+/**
+ \brief Sets the clock rate factor (in ETU) and baud rate regulator factor for special cards.
+CNcomment:etu CNend
+
+ \attention \n
+This API needs to be called only for special cards.
+The configured values must match the clock rate conversion factor F and bit rate regulator factor D defined in the protocol.
+You can also set the factors to the values defined in the card specifications. Note that the values must be set correctly.
+CNcomment:
+FD
+CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI01CNend
+ \param [in] 	u32ClkFactor  Clock rate conversion factor, ranging from 372 to 2048. For details, see the factor F and card features in the protocol.	CNcomment:3722048 FCNend
+ \param [in] 	u32BaudFactor	Baud rate regulator factor 1, 2 x n (n = 1-16). For details, see the factor D and card features in the protocol. CNcomment:12*n (n=116) DCNend
+ \retval  0 	Success.                                                                                               CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                          CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                                       CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			   CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetEtuFactor(HI_UNF_SCI_PORT_E enSciPort, HI_U32 u32ClkFactor, HI_U32 u32BaudFactor);
+
+/**
+ \brief \brief Sets the extra guard time for transmitting two consecutive bytes from the terminal to an IC card. The guard time is the interval between the start edges of two consecutive bytes.
+CNcomment:ICCNend
+
+ \attention \n
+This setting is performed based on related features only for the cards that require extra character guard time.
+In general, the default value is used or the interval guard time is automatically set based on the ART analysis result.
+CNcomment:
+ATRCNend
+ \param [in] 	enSciPort	ID of an SCI port. The port ID can be 0 or 1.      	CNcomment:SCI01CNend
+ \param [in] 	u32GuardTime  Extra guard time, ranging from 0 to 254 ETU.	   	CNcomment:0254  etuCNend
+ \retval 0  Success.	                                                       		CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                  		CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.               		CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                          CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetGuardTime(HI_UNF_SCI_PORT_E enSciPort, HI_U32 u32GuardTime);
+
+/**
+ \brief Sets the baud rate supported by the SCI card through protocol and parameters selection (PPS) negotiation or performs negotiation by using the F and D factors returned by the ATR to switch the protocol of a card.
+CNcomment:PPS ATR FDCNend
+\attention \n
+PPS negotiation is available only when the SCI card supports this function.
+The negotiated baud rate must be supported by the SCI card.
+The command words for negotiation must comply with the specifications defined in section 9.2 "PPS request and response" in the 7816-3 protocol.
+CNcomment:PPS 
+
+7816-3 9.2 PPS request and responseCNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                                 CNcomment:SCI01CNend
+ \param [in] 	pSciSendBuf  PPS negotiation command combined based on card specifications. If the default negotiation mode is used, the command word can be left empty.   CNcomment:PPSCNend
+ \param [in]	Sendlen	   Length of the command word to be transmitted, ranging from 0 bytes to 5 bytes. The value 0 indicates that the default negotiation mode is used.   CNcomment: (05),0CNend
+ \param [in]	RecTimeouts  PPS response timeout after commands are transmitted. The value ranges from 1 ms to 10000 ms.  CNcomment: PPS (1-10000),CNend
+ \retval 0 	Success.                                                                               		CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                         		CNcomment:SCICNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                      		CNcomment:CNend
+ \retval ::HI_ERR_SCI_NULL_PTR		The pointer is null.                                          		CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                          	CNcomment:CNend
+ \retval ::HI_ERR_SCI_RECEIVE_ERR  A reception error occurs.                                       		CNcomment:CNend
+ \retval ::HI_ERR_SCI_PPS_PTYPE_ERR 	The protocol type for PPS negotiation is incorrect.           		CNcomment:PPSCNend
+ \retval ::HI_ERR_SCI_PPS_FACTOR_ERR 	The F factor and D factor for PPS negotiation are incorrect. 	        CNcomment:PPSFDCNend
+ \retval ::HI_ERR_SCI_PPS_NOTSUPPORT_ERR  The PPS negotiation type is not supported.               		CNcomment:PPSCNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_NegotiatePPS(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciSendBuf, HI_U32 Sendlen, HI_U32 RecTimeouts);
+
+/**
+ \brief  Obtains the PPS data for the card response after PPS negotiation is successful.
+CNcomment:PPS ,PPS CNend
+ \attention \n
+This API takes effect only after PPS negotiation is successful.
+CNcomment:PPS ,CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                   CNcomment:SCI01CNend
+ \param [out] 	pRecBuf   Address of the buffer for storing the data to be received.   	CNcomment:buffer CNend
+ \param [out]	pDataLen	  Required length of the received data.                      CNcomment:CNend
+ \retval 0  Success.	                                                                	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                        	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NULL_PTR	The pointer is null.                                	CNcomment:CNend
+ \retval ::HI_ERR_SCI_PPS_NOTSUPPORT_ERR  The PPS negotiation type is not supported. 	CNcomment:PPSCNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetPPSResponData(HI_UNF_SCI_PORT_E enSciPort, HI_U8* pRecBuf, HI_U32* pDataLen);
+
+/**
+brief  Obtains the SCI parameter values including the protocol, ATR clock factor, ATR bit rate factor, actual clock factor, actual bit rate factor, number of retries, guard delay, character wait timeout, and block wait timeout.
+CNcomment:sci ATR 
+GuardDelay CNend
+ \attention \n
+This API is available only after HI_UNF_SCI_Init and HI_UNF_SCI_ResetCard are called.
+CNcomment: ,CNend
+
+ \param [in] 	enSciPort	 ID of an SCI port. The port ID is 0 or 1.                      CNcomment:SCI01CNend
+ \param [out] 	pParams   Pointer to the data type of the data structure to be received.   	CNcomment:CNend
+ \retval 0 	Success.                                                                     	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                             	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NULL_PTR		The pointer is null.                                    CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  	The SCI device is not initialized.                      CNcomment:CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetParams(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PARAMS_S_PTR pParams);
+
+/**
+ \brief  Sets the character timeout of T0 and T1 separately based on the current protocol type.
+CNcomment:T0T1CNend
+
+ \attention \n
+The timeout can be set only after the SCI card is reset successfully. The protocol type must be consistent with the current card type. In general, the timeout is obtained by parsing the ATR. That is, the timeout needs to be set only when card communication fails.
+CNcomment:,ATRCNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.   CNcomment:SCI01CNend
+ \param [in] 	enSciProtocol  Protocol type.                           	CNcomment:CNend
+ \param [in]	MaxCharTime  Maximum character timeout. The value of MaxCharTime for T0 ranges from 960 to 244800, and the value of MaxCharTime for T1 ranges from 12 to 32779.	  CNcomment:T0(960244800),T1(1232779)CNend
+ \retval 0 	Success.                                                  	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.         	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.             	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NO_ATR  	The SCI card fails to be reset.        	CNcomment:CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetCharTimeout(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 MaxCharTime);
+
+/**
+ \brief  Sets the block timeout of T1.
+CNcomment:T1CNend
+\attention \n
+The timeout can be set only after the SCI card is reset successfully. In general, the timeout is obtained by parsing the ATR. That is, the timeout needs to be set only in special cases
+CNcomment:,ATRCNend
+
+ \param [in] 	enSciPort	 ID of an SCI port. The port ID is 0 or 1.                         	CNcomment:SCI01CNend
+ \param [in] 	MaxBlockTime   Maximum block timeout. The value ranges from 971 to 491531.   	CNcomment:(971491531)CNend
+ \retval 0 	Success.                                                                        		CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                		CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                   	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NO_ATR  		The SCI card fails to be reset.                            	CNcomment:CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetBlockTimeout(HI_UNF_SCI_PORT_E enSciPort, HI_U32 MaxBlockTime);
+
+/**
+ \brief  Sets the maximum number of transmission retries after a check error occurs.
+CNcomment:CNend
+\attention \n
+The number can be set only after the SCI card is reset successfully.
+CNcomment:,CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                   CNcomment:SCI01CNend
+ \param [in] 	TxRetryTimes   Number of transmission retries, ranging from 0 to 7.    	CNcomment:(07)CNend
+ \retval 0 	Success.                                                                  	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                         	CNcomment:CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             	CNcomment:CNend
+ \retval ::HI_ERR_SCI_NO_ATR  	The SCI card fails to be reset.	                       	CNcomment:CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetTxRetries(HI_UNF_SCI_PORT_E enSciPort, HI_U32 TxRetryTimes);
+
+/** @}*/  /** <!-- ==== API Declaration End ====*/
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_SCI_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_session_manager.h b/xbmc/platform/linux/hisi/hi_unf_session_manager.h
new file mode 100644
index 0000000000..384cdb5e01
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_session_manager.h
@@ -0,0 +1,189 @@
+/******************************************************************************
+
+Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_session_manager.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2017-08-11
+Last Modified :
+Description   : Session manager(known as SMG)plays an important role in SMP.It protects modules that are working
+                in SMP from attacking.Known attacking measures are :buffer address distortion, module
+                attachment switching ,etc.Before SMG takes effect, it should be initialized ,intent need to
+                be set and related modules in SMP need to be added.
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_SESSION_MANAGER_H__
+#define __HI_UNF_SESSION_MANAGER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HI_UNF_SESSION_MANAGER */
+/** @{ */  /** <!-- [HI_UNF_SESSION_MANAGER] */
+
+
+/** the type of session manager attribute */
+typedef struct
+{
+    HI_U32 u32SessionID;
+} HI_UNF_SM_ATTR_S;
+
+/** the type of session manager modid */
+typedef enum
+{
+    HI_UNF_SM_MODULE_KEYLADDER = 0,
+    HI_UNF_SM_MODULE_DESCRAMBLER,
+    HI_UNF_SM_MODULE_CIPHER,
+    HI_UNF_SM_MODULE_PLCIPHER,
+    HI_UNF_SM_MODULE_DEMUX,
+    HI_UNF_SM_MODULE_VDEC,
+    HI_UNF_SM_MODULE_AVPLAY,
+    HI_UNF_SM_MODULE_PVR,
+    HI_UNF_SM_MOODULE_BUTT
+} HI_UNF_SM_MODULE_E;
+
+typedef enum
+{
+    HI_UNF_SM_CIPHER_TYPE_ENCRYPT,
+    HI_UNF_SM_CIPHER_TYPE_DECRYPT,
+    HI_UNF_SM_CIPHER_TYPE_BUTT
+} HI_UNF_SM_CIPHER_TYPE_E;
+
+typedef struct
+{
+    union
+    {
+        HI_UNF_SM_CIPHER_TYPE_E enCipherType;
+        HI_U32 u32DemuxID;
+        HI_U32 u32Reserve;
+    } unModAttr;
+    HI_HANDLE hHandle;
+} HI_UNF_SM_MODULE_S;
+
+typedef enum
+{
+    HI_UNF_SM_INTENT_DEFAULT = 0,
+    HI_UNF_SM_INTENT_WATCH,
+    HI_UNF_SM_INTENT_RECORD,
+    HI_UNF_SM_INTENT_EXPORT,
+    HI_UNF_SM_INTENT_BUTT
+} HI_UNF_SM_INTENT_E;
+
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HI_UNF_SESSION_MANAGER */
+/** @{ */  /** <!-- [HI_UNF_SESSION_MANAGER] */
+
+/**
+\brief Init the session manager device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_SM_Init(HI_VOID);
+
+
+/**
+\brief Deinit the session manager device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_SM_DeInit(HI_VOID);
+
+/**
+\brief Create a session manager instance.
+\attention \n
+\param[out] phSM       Handle of session manager.
+\param[in] pstSMAttr   Pointer to the attributes of session manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_Create(HI_HANDLE *phSM, HI_UNF_SM_ATTR_S *pstSMAttr);
+
+/**
+\brief add handle need to be managed by session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\param[in] enModID     Handle module.
+\param[in] pstModule   Resource need to manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_AddResource(HI_HANDLE hSM, HI_UNF_SM_MODULE_E enModID, HI_UNF_SM_MODULE_S *pstModule);
+
+/**
+\brief del handle need to be remove by session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\param[in] enModID     Handle module.
+\param[in] pstModule   Resource need to manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_DelResource(HI_HANDLE hSM, HI_UNF_SM_MODULE_E enModID, HI_UNF_SM_MODULE_S *pstModule);
+
+/**
+\brief destroy session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_Destroy(HI_HANDLE hSM);
+
+/**
+\brief get session manager handle by service id.
+\attention \n
+\param[in] u32SessionID     source handle module.
+\param[out] pSM             handle to search.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_GetSMHandleBySID(HI_U32 u32SessionID, HI_HANDLE *pSM);
+
+/**
+\brief set session manager intent.
+\attention \n
+\param[in] hSM         session manager handle.
+\param[in] enIntent    intent to set.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_SM_SetIntent(HI_HANDLE hSM, HI_UNF_SM_INTENT_E enIntent);
+
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* End of #ifndef HI_UNF_SESSION_MANAGER*/
diff --git a/xbmc/platform/linux/hisi/hi_unf_so.h b/xbmc/platform/linux/hisi/hi_unf_so.h
new file mode 100644
index 0000000000..8041977c6f
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_so.h
@@ -0,0 +1,449 @@
+/**
+ \file
+ \brief Subtitle output Module
+ \author Shenzhen Hisilicon Co., Ltd.
+ \version 1.0
+ \author
+ \date 2010-03-10
+ */
+
+#ifndef __HI_UNF_SO_H__
+#define __HI_UNF_SO_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup     SUBTITLEOUT */
+/** @{ */  /** <!-- SUBTITLEOUT */
+
+/** Number of palette *//** CNcomment: */
+#define HI_UNF_SO_PALETTE_ENTRY (256)
+
+/** Invalid pts value *//** CNcomment:PTS */
+#define HI_UNF_SO_NO_PTS        (-1)
+
+/** The max node in SO *//** CNcomment:SO */
+#define HI_UNF_SO_MAX_NODE_NUM  (20)
+
+/** The max buffer size *//** CNcomment:SO */
+#define HI_UNF_SO_MAX_BUFFER_SIZE (0x200000)
+
+
+/** Subtitle type *//** CNcomment: */
+typedef enum hiUNF_SO_SUBTITLE_TYPE_E
+{
+    HI_UNF_SUBTITLE_BITMAP = 0x0,  /**<Bmp subtitle *//**<CNcomment: */
+    HI_UNF_SUBTITLE_TEXT,          /**<Text subtitle *//**<CNcomment:string */
+    HI_UNF_SUBTITLE_ASS,           /**<Ass/ssa sbutitle *//**<CNcomment:ass */
+    HI_UNF_SUBTITLE_BUTT
+} HI_UNF_SO_SUBTITLE_TYPE_E;
+
+/** Message type of subtitle *//** CNcomment:teltext */
+typedef enum hiUNF_SO_DISP_MSG_TYPE_E
+{
+    HI_UNF_SO_DISP_MSG_NORM  = 0x0,     /**<Draw the subtitle *//**<CNcomment: */
+    HI_UNF_SO_DISP_MSG_ERASE,           /**<Clear the subtitle *//**<CNcomment: */
+    HI_UNF_SO_DISP_MSG_END              /**<Message of drawing a page *//**<CNcomment: */
+} HI_UNF_SO_DISP_MSG_TYPE_E;
+
+/** The parameter of clear region *//** CNcomment: */
+typedef struct hiUNF_SO_CLEAR_PARAM_S
+{
+    HI_U32 x, y, w, h;     /**<Postion of clearing *//**<CNcomment: */
+    HI_S64 s64ClearTime;   /**<Clear operation time,larger than or equal to s64NodePts+u32Duration*//**<CNcomment:,s64NodePts+u32Duration */
+    HI_S64 s64NodePts;     /**<the present pts of sub *//**<CNcomment: */
+    HI_U32 u32Duration;    /**<the present duration of sub *//**<CNcomment: */
+} HI_UNF_SO_CLEAR_PARAM_S;
+
+/** Color components  *//** CNcomment: */
+typedef struct hiUNF_SO_COLOR_S
+{
+    HI_U8 u8Red;      /**<Red component *//**<CNcomment:R */
+    HI_U8 u8Green;    /**<Green component *//**<CNcomment:G */
+    HI_U8 u8Blue;     /**<Blue component *//**<CNcomment:B */
+    HI_U8 u8Alpha;    /**<Alpha component *//**<CNcomment:00xFF */
+} HI_UNF_SO_COLOR_S;
+
+/** Information of bitmap subtitle *//** CNcomment: */
+typedef struct hiUNF_SO_GFX_S
+{
+    HI_S64 s64Pts;         /**<Start a display time, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32Duration;    /**<Duration of displaying, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32Len;         /**<Bytes of subtitle data *//**<CNcomment: */
+    HI_U8  *pu8PixData;    /**<Data of subtitle *//**<CNcomment: */
+
+    HI_UNF_SO_DISP_MSG_TYPE_E enMsgType;                   /**<Type of display message *//**<CNcomment: */
+    HI_UNF_SO_COLOR_S stPalette[HI_UNF_SO_PALETTE_ENTRY];  /**<Palette *//**<CNcomment:ARGB8888 */
+    HI_S32 s32BitWidth;    /**<Bits of Pix *//**<CNcomment: ,  2,4,8*/
+    HI_U32 x, y, w, h;     /**<Position of display subtitle *//**<CNcomment: */
+    HI_U32 u32CanvasWidth;   /**<Display canvas width *//**<CNcomment: */
+    HI_U32 u32CanvasHeight;  /**<Display canvas height *//**<CNcomment: */
+} HI_UNF_SO_GFX_S;
+
+/** Infomation of text subtitle *//** CNcomment: */
+typedef struct hiUNF_SO_TEXT_S
+{
+    HI_S64 s64Pts;              /**<Start a display time, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32Duration;         /**<Duration of displaying, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32Len;              /**<Bytes of subtitle data *//**<CNcomment: */
+    HI_U8 *pu8Data;             /**<Data of subtitle *//**<CNcomment: */
+
+    HI_U32 x, y, w, h;          /**<Position of display subtitle *//**<CNcomment: */
+} HI_UNF_SO_TEXT_S;
+
+/** Infomation of ass/ssa subtitle *//** CNcomment:ass */
+typedef struct hiUNF_SO_ASS_S
+{
+    HI_S64 s64Pts;                /**<Start a display time, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32Duration;           /**<Duration of displaying, unit is Millisecond *//**<CNcomment:ms */
+    HI_U32 u32FrameLen;           /**<Bytes of subtitle data *//**<CNcomment: */
+    HI_U8  *pu8EventData;         /**<Data of subtitle *//**<CNcomment: */
+    HI_U32 u32ExtradataSize;      /**<Length of extra data *//**<CNcomment: */
+    HI_U8  *pu8Extradata;         /**<Extra data *//**<CNcomment: */
+} HI_UNF_SO_ASS_S;
+
+/** Infomation of subtitle *//** CNcomment: */
+typedef struct hiUNF_SO_SUBTITLE_INFO_S
+{
+    HI_UNF_SO_SUBTITLE_TYPE_E eType; /**<type *//**<CNcomment: */
+
+    union
+    {
+        HI_UNF_SO_GFX_S  stGfx;      /**<Gfx subtitle *//**<CNcomment: */
+        HI_UNF_SO_TEXT_S stText;     /**<Text subtitle *//**<CNcomment: */
+        HI_UNF_SO_ASS_S  stAss;      /**<Ass subtitle *//**<CNcomment:ASS */
+    } unSubtitleParam;
+} HI_UNF_SO_SUBTITLE_INFO_S;
+
+/**
+\brief Call back funtion of getting current play time.
+CNcomment:ps64CurrentPtsHI_UNF_SO_NO_PTSCNend
+\attention \n
+None
+\param[in] pUserData Userdata.CNcomment:CNend
+\param[out] ps64CurrentPts Current play time. CNcomment:msCNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_GETPTS_FN)(HI_VOID* pUserData, HI_S64 *ps64CurrentPts);
+
+/**
+\brief Callback funtion of drawing the subtitle. CNcomment:CNend
+\attention \n
+None
+\param[in] pUserData Userdata. CNcomment:CNend
+\param[in] pstInfo Information of subtitle. CNcomment:CNend
+\param[in] pArg User data. CNcomment:CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_ONDRAW_FN)(HI_VOID* pUserData, const HI_UNF_SO_SUBTITLE_INFO_S *pstInfo, HI_VOID *pArg);
+
+/**
+\brief Call back funtion of clearing the subtitle. CNcomment:CNend
+\attention \n
+None
+\param[in] pUserData User data. CNcomment:CNend
+\param[out] pArg Parameter of clearing the subtitle, Type is HI_UNF_SO_CLEAR_PARAM_S. CNcomment:HI_UNF_SO_CLEAR_PARAM_SCNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_ONCLEAR_FN)(HI_VOID* pUserData, HI_VOID *pArg);
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SUBTITLEOUT */
+/** @{*/  /** <!-- [SUBTITLEOUT]*/
+
+/**
+\brief  Init SO module. CNcomment:subtitle output CNend
+\attention \n
+None
+\param None
+
+\retval ::HI_SUCCESS Init success. CNcomment:CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Init(HI_VOID);
+
+/**
+\brief  Deinit SO module. CNcomment:subtitle output CNend
+\attention \n
+None
+\param None
+
+\retval ::HI_SUCCESS  Deinit success. CNcomment:CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_DeInit(HI_VOID);
+
+/**
+\brief  Creates an SO instance. CNcomment:soCNend
+\attention \n
+None
+\param[out] phdl Handle of SO instance. CNcomment:CNend
+
+\retval ::HI_SUCCESS  Create success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Create(HI_HANDLE *phdl);
+
+/**
+\brief  Destroy an SO instance. CNcomment:soCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+
+\retval ::HI_SUCCESS  Destroy success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Destroy(HI_HANDLE handle);
+
+/**
+\brief  Setting offset time of the subtitle. CNcomment:CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] s64OffsetMs Offset of subtitle, unit is Millisecondes.CNcomment:msCNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetOffset(HI_HANDLE handle, HI_S64 s64OffsetMs);
+
+/**
+\brief  Register the callback function of getting current play time. CNcomment:soCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance.CNcomment:soCNend
+\param[in] pstCallback Callback function. CNcomment:CNend
+\param[in] pUserData User data. CNcomment:CNend
+
+\retval ::HI_SUCCESS  Register success. CNcomment:CNend
+\retval ::HI_FAILURE  Parameter invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_RegGetPtsCb(HI_HANDLE handle, HI_UNF_SO_GETPTS_FN pstCallback, HI_VOID* pUserData);
+
+/**
+\brief  Register the callback function of drawing subtitle.
+CNcomment:sosoCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] pfnOnDraw Callback function of drawing subtitle. CNcomment:CNend
+\param[in] pfnOnClear Callback function of clearing subtitle. CNcomment:CNend
+\param[in] pUserData User data. CNcomment:CNend
+
+\retval ::HI_SUCCESS  Register success. CNcomment:CNend
+\retval ::HI_FAILURE Parameter invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_RegOnDrawCb(HI_HANDLE handle, HI_UNF_SO_ONDRAW_FN pfnOnDraw,
+                                          HI_UNF_SO_ONCLEAR_FN pfnOnClear, HI_VOID* pUserData);
+
+/**
+\brief  Set the surface of drawing subtitle, if you do not set the ondraw callback function, SO painting subtitles with the surface.
+CNcomment:ondrawsoCNend
+\attention \n
+This feature is not implemented. CNcomment:CNend
+\param[in] handle Handle of SO instance.CNcomment:soCNend
+\param[in] hSurfaceHandle Handle of surface. CNcomment:CNend
+
+\retval ::HI_SUCCESS Success of setting surface. CNcomment:CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetDrawSurface(HI_HANDLE handle, HI_HANDLE hSurfaceHandle);
+
+/**
+\brief  Set the font of drawing subtitle.
+CNcomment:CNend
+\attention \n
+This feature is not implemented. CNcomment:CNend
+\param[in] handle Handle of SO instance.CNcomment:soCNend
+\param[in] hFont Handle of font instance.CNcomment:CNend
+
+\retval ::HI_SUCCESS  Success.CNcomment:CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetFont(HI_HANDLE handle, HI_HANDLE hFont);
+
+/**
+\brief Set the color of drawing text subtitle.
+CNcomment:CNend
+\attention \n
+This feature is not implemented. CNcomment:CNend
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] u32Color Value of the color. CNcomment:CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetColor(HI_HANDLE handle, HI_U32 u32Color);
+
+/**
+\brief Set the position of display subtitle.
+CNcomment:CNend
+\attention \n
+This feature is not implemented. CNcomment:CNend
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] u32x Value of x coordinate.CNcomment:xCNend
+\param[in] u32y Value of y coordinate. CNcomment:yCNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Parameter invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetPos(HI_HANDLE handle, HI_U32 u32x, HI_U32 u32y);
+
+/**
+\brief  Getting the number in the butitle queue.
+CNcomment:bufferCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[out] pu32SubNum Number of subtitles in queue. CNcomment:CNend
+
+\retval ::HI_SUCCESS Success. CNcomment:CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_GetSubNumInBuff(HI_HANDLE handle, HI_U32 *pu32SubNum);
+
+/**
+\brief Clear the subtitles in queue.
+CNcomment:soCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+
+\retval ::HI_SUCCESS Success. CNcomment:CNend
+\retval ::HI_FAILURE Operation invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_ResetSubBuf(HI_HANDLE handle);
+
+/**
+\brief  Clear the subtitles in queue by PTS. If PTS is 0, the same as HI_UNF_SO_ResetSubBuf.
+CNcomment:,PTS.PTS0,HI_UNF_SO_ResetSubBufCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+
+\retval ::HI_SUCCESS Success. CNcomment:CNend
+\retval ::HI_FAILURE Operation invalid. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_ResetSubBuf_ByPts(HI_HANDLE handle, HI_S64 s64Pts);
+
+/**
+\brief  Send subtitles to SO queue. If the data size and the number is larger than the value set by the user, then the transmission fails.
+CNcomment:sosizeCNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] pstSubInfo Data of subtitle. CNcomment:CNend
+\param[in] u32TimeOut Timeout of sending subtitle. CNcomment:msCNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail.CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SendData(HI_HANDLE handle, const HI_UNF_SO_SUBTITLE_INFO_S *pstSubInfo, HI_U32 u32TimeOutMs);
+
+/**
+\brief  Get current subt data in SO queue.
+CNcomment:SO CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] pstSubInfo Data of subtitle. CNcomment:CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail.CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_GetCurData(HI_HANDLE handle, HI_UNF_SO_SUBTITLE_INFO_S *pstSubInfo);
+
+/**
+\brief  Setting max interval time of the subtitle.
+CNcomment:CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:soCNend
+\param[in] u32IntervalMs max interval of subtitle, unit is Millisecondes.
+CNcomment:msCNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetMaxInterval(HI_HANDLE handle, HI_U32 u32IntervalMs );
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_SO_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_unf_sound.h b/xbmc/platform/linux/hisi/hi_unf_sound.h
new file mode 100644
index 0000000000..743663ebed
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_sound.h
@@ -0,0 +1,1931 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_sound.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/1/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : z67193
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the SOUND (SND) module. CNcomment:SOUND CNend
+ */
+
+#ifndef  __HI_UNF_SND_H__
+#define  __HI_UNF_SND_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/********************************Macro Definition********************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!-- SOUND */
+
+/**Maximum sound outputport*/
+/**CNcomment:sound*/
+#define HI_UNF_SND_OUTPUTPORT_MAX (16)
+#define HI_UNF_SND_EQ_BANDNUM_MAX (10)
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  SOUND */
+
+/**Defines the ID of the audio output (AO) device.*/
+/**CNcomment:*/
+typedef enum hiUNF_SND_E
+{
+    HI_UNF_SND_0,           /**<AO device 0*/ /**<CNcomment:0 */
+    HI_UNF_SND_1,           /**<AO device 1*/ /**<CNcomment:1 */
+    HI_UNF_SND_2,           /**<AO device 2*/ /**<CNcomment:2 */
+    HI_UNF_SND_BUTT
+} HI_UNF_SND_E;
+
+/**Audio volume attribute*/
+/**CNcomment:*/
+typedef struct hiHI_UNF_SND_GAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type of volume*/ /**<CNcomment: */
+    HI_S32  s32Gain; /**<Linear gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                     /**<Decibel gain(bLinearMode is HI_FALSE) , ranging from -70dB to 0dB */ /**<CNcomment: dB:-70~0*/
+} HI_UNF_SND_GAIN_ATTR_S;
+
+/**Audio L/R channel volume attribute*/
+/**CNcomment:*/
+typedef struct hiHI_UNF_SND_ABSGAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type*/ /**<CNcomment: */
+    HI_S32  s32GainL; /**<Linear left ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                     /**<Decibel left ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: dB:-81~+18*/
+    HI_S32  s32GainR; /**<Linear right ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:: 0~100 */
+                  /**<Decibel right ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: dB:-81~+18*/
+} HI_UNF_SND_ABSGAIN_ATTR_S;
+
+/**High Precision Gain, ranging from -81dB to 18dB, step 0.125dB*/
+/**CNcomment:-81dB18dB0.125dB*/
+typedef struct hiHI_UNF_SND_PRECIGAIN_ATTR_S
+{
+    HI_S32 s32IntegerGain; /**<Interger part of high preicision gain*/ /**<CNcomment: */
+    HI_S32 s32DecimalGain; /**<decimal part of high preicision gain, if -0.125dB, value is -125*/ /**<CNcomment:  0.125125*/
+}HI_UNF_SND_PRECIGAIN_ATTR_S;
+
+/**Audio Track Type: Master, Slave, Virtual channel,LowLatency channel*/
+/**CNcomment:Track:   */
+/**LowLatency channel not support attach avplay and the data only support 48K,stereo,16Bit.Only support one lowlatency track in a sound*/
+/**CNcomment:AVPLAY48K,,16,*/
+typedef enum hiHI_UNF_SND_TRACK_TYPE_E
+{
+    HI_UNF_SND_TRACK_TYPE_MASTER = 0,
+    HI_UNF_SND_TRACK_TYPE_SLAVE,
+    HI_UNF_SND_TRACK_TYPE_VIRTUAL,
+    HI_UNF_SND_TRACK_TYPE_LOWLATENCY,
+
+    HI_UNF_SND_TRACK_TYPE_OTTSOUND,      /**< Ott sound(PCM) MS12 ONLY. Such as app ui audio*/
+    HI_UNF_SND_TRACK_TYPE_SYSTEMAUDIO,   /**< System sound(PCM) MS12 ONLY.*/
+    HI_UNF_SND_TRACK_TYPE_APPAUDIO,      /**< App audio(PCM) MS12 ONLY. Such as tts audio*/
+    HI_UNF_SND_TRACK_TYPE_BUTT
+} HI_UNF_SND_TRACK_TYPE_E;
+
+/**Audio output attribute */
+/**CNcomment:*/
+typedef struct hiHI_UNF_AUDIOTRACK_ATTR_S
+{
+    HI_UNF_SND_TRACK_TYPE_E     enTrackType;        /**<Track Type*/ /**<CNcomment:Track*/
+    HI_U32                      u32FadeinMs;        /**<Fade in time(unit:ms)*/ /**<CNcomment:(: ms)*/
+    HI_U32                      u32FadeoutMs;       /**<Fade out time(unit:ms)*/ /**<CNcomment:(: ms)*/
+    HI_U32                      u32OutputBufSize;   /**<Track output buffer size*/ /**<CNcomment:Track*/
+    HI_U32                      u32BufLevelMs;      /**<Output buffer data size control(ms),default 400ms*/ /**<CNcomment:(ms),400ms*/
+    HI_U32                      u32StartThresholdMs;  /**<Track start threshold (ms), default value is 50ms, max value is equal to u32BufLevelMs, only valid for master track*/
+                                                      /**<CNcomment:Track50msu32BufLevelMsmaster track*/
+} HI_UNF_AUDIOTRACK_ATTR_S;
+
+/**Audiotrack config parameter*/
+/**CNcomment: Track*/
+typedef struct hiHI_UNF_AUDIOTRACK_CONFIG_S
+{
+    HI_U32      u32ConfigType;        /**<Track config type*/ /**<CNcomment:Track*/
+    HI_VOID*    pConfigData;          /**<Track config data*/ /**<CNcomment:Track*/
+} HI_UNF_AUDIOTRACK_CONFIG_S;
+
+/**Audio outputport: DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+/**CNcomment::DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+typedef enum hiUNF_SND_OUTPUTPORT_E
+{
+    HI_UNF_SND_OUTPUTPORT_DAC0 = 0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S1,
+
+    HI_UNF_SND_OUTPUTPORT_SPDIF0,
+
+    HI_UNF_SND_OUTPUTPORT_HDMI0,
+
+    HI_UNF_SND_OUTPUTPORT_ARC0,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC1 = 0x50,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC2,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC3,
+
+    HI_UNF_SND_OUTPUTPORT_ALL = 0x7fff,
+
+    HI_UNF_SND_OUTPUTPORT_BUTT,
+} HI_UNF_SND_OUTPUTPORT_E;
+
+/**Defines internal Audio DAC outport attribute */
+/**CNcomment:DAC*/
+typedef struct hiUNF_SND_DAC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_DAC_ATTR_S;
+
+/**Defines  Audio I2S outport attribute */
+/**CNcomment:I2S*/
+typedef struct hiUNF_SND_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;
+}  HI_UNF_SND_I2S_ATTR_S;
+
+/**Defines  S/PDIF outport attribute */
+/**CNcomment:S/PDIF*/
+typedef struct hiUNF_SND_SPDIF_ATTR_S
+{
+    HI_U32 u32Reserved;
+}  HI_UNF_SND_SPDIF_ATTR_S;
+
+/**Defines  HDMI Audio outport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_SND_HDMI_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_HDMI_ATTR_S;
+
+/**Defines  HDMI ARC outport attribute */
+/**CNcomment:HDMI*/
+typedef struct hiUNF_SND_ARC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_ARC_ATTR_S;
+
+/**Defines  Audio outport attribute */
+/**CNcomment:*/
+typedef struct hiUNF_SND_OUTPORT_S
+{
+    HI_UNF_SND_OUTPUTPORT_E enOutPort;
+    union
+    {
+        HI_UNF_SND_DAC_ATTR_S   stDacAttr;
+        HI_UNF_SND_I2S_ATTR_S   stI2sAttr;
+        HI_UNF_SND_SPDIF_ATTR_S stSpdifAttr;
+        HI_UNF_SND_HDMI_ATTR_S  stHDMIAttr;
+        HI_UNF_SND_ARC_ATTR_S   stArcAttr;
+    } unAttr;
+} HI_UNF_SND_OUTPORT_S;
+
+/**Defines  Render attribute */
+/**CNcomment:Render*/
+typedef struct hiUNF_SND_RENDER_ATTR_S
+{
+	HI_CHAR* pCommPath;
+} HI_UNF_SND_RENDER_ATTR_S;
+
+/**Defines  Audio Sound device attribute */
+/**CNcomment:Sound*/
+typedef struct hiHI_UNF_SND_ATTR_S
+{
+    HI_U32                  u32PortNum;  /**<Outport number attached sound*/ /**<CNcomment:Sound*/
+    HI_UNF_SND_OUTPORT_S    stOutport[HI_UNF_SND_OUTPUTPORT_MAX];  /**<Outports attached sound*/ /**<CNcomment:Sound*/
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;       /**<Sound samplerate*/ /**<CNcomment:Sound*/
+    HI_U32                  u32MasterOutputBufSize; /**<Sound master channel buffer size*/ /**<CNcomment:Sound*/
+    HI_U32                  u32SlaveOutputBufSize;  /**<Sound slave channel buffer size*/ /**<CNcomment:Sound*/
+} HI_UNF_SND_ATTR_S;
+
+/**define SND CAST config  struct */
+/**CNcomment:*/
+typedef struct hiUNF_SND_CAST_ATTR_S
+{
+    HI_U32  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer*/ /**<CNcomment: */
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data*/ /**<CNcomment: PCM*/
+    HI_BOOL bAddMute;              /**<Add mute frame in cast or not>*/ /**<CNcomment: cast*/
+} HI_UNF_SND_CAST_ATTR_S;
+
+/**HDMI MODE:AUTO,LPCM,RAW,HBR2LBR*/
+/**CNcomment:HDMI :AUTO,LPCM,RAW,HBR2LBR*/
+typedef enum hiHI_UNF_SND_HDMI_MODE_E
+{
+    HI_UNF_SND_HDMI_MODE_LPCM = 0,       /**<HDMI LCPM2.0*/ /**<CNcomment: pcm*/
+    HI_UNF_SND_HDMI_MODE_RAW,            /**<HDMI Pass-through.*/ /**<CNcomment: HDMI*/
+    HI_UNF_SND_HDMI_MODE_HBR2LBR,        /**<HDMI Pass-through force high-bitrate to low-bitrate.*/ /**<CNcomment: */
+    HI_UNF_SND_HDMI_MODE_AUTO,           /**<automatically match according to the EDID of HDMI */ /**<CNcomment: HDMI EDID*/
+    HI_UNF_SND_HDMI_MODE_BUTT
+} HI_UNF_SND_HDMI_MODE_E;
+
+/**SPDIF MODE:LPCM,RAW*/
+/**CNcomment:SPDIF :LPCM,RAW*/
+typedef enum hiHI_UNF_SND_SPDIF_MODE_E
+{
+    HI_UNF_SND_SPDIF_MODE_LPCM,           /**<SPDIF LCPM2.0*/ /**<CNcomment: pcm*/
+    HI_UNF_SND_SPDIF_MODE_RAW,            /**<SPDIF Pass-through.*/ /**<CNcomment: SPDIF*/
+    HI_UNF_SND_SPDIF_MODE_BUTT
+} HI_UNF_SND_SPDIF_MODE_E;
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/**SPDIF Category Code Setting*/
+/**CNcomment:SPDIF Category Code*/
+typedef enum hiHI_UNF_SND_SPDIF_CATEGORYCODE_E
+{
+    HI_UNF_SND_SPDIF_CATEGORY_GENERAL = 0x00,       /**<General*/                  /**<CNcomment:*/
+    /*broadcast reception of digitally encoded audio
+    with/without video signals*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_JP = 0x10,  /**<Japan*/                    /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_USA,        /**<United States*/            /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_EU,         /**<Europe*/                   /**<CNcomment:*/
+    /*digital converter & signal-processing products*/
+    HI_UNF_SND_SPDIF_CATEGORY_PCM_CODEC = 0x20,     /**<PCM Encoder/Decoder*/      /**<CNcomment:PCM*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDSAMPLER,   /**<Digital Sound Sampler*/    /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_MIXER,        /**<Digital Signal Mixer*/     /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDPROCESSOR, /**<Digital Sound Processor*/  /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_SRC,                  /**<Sample Rate Converter*/    /**<CNcomment:*/
+    /*laser optical products*/
+    HI_UNF_SND_SPDIF_CATEGORY_MD = 0x30,            /**<MiniDisc*/                 /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DVD,                  /**<Digital Versatile Disc*/   /**<CNcomment:*/
+    /*musical instruments, microphones and other sources
+    that create original sound*/
+    HI_UNF_SND_SPDIF_CATEGORY_SYNTHESISER = 0x40,   /**<Synthesiser*/              /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_MIC,                  /**<Microphone*/               /**<CNcomment:*/
+    /*magnetic tape or magnetic disc based products*/
+    HI_UNF_SND_SPDIF_CATEGORY_DAT = 0x50,           /**<Digital Audio Tape*/       /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_DCC,                  /**<Digital Compact Cassette*/ /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_CATEGORY_VCR,                  /**<Video Cassette Recorder*/  /**<CNcomment:*/
+
+    HI_UNF_SND_SPDIF_CATEGORY_BUTT
+} HI_UNF_SND_SPDIF_CATEGORYCODE_E;
+
+/**SPDIF SCMS Mode Setting*/
+/**CNcomment:SPDIF SCMS*/
+typedef enum hiHI_UNF_SND_SPDIF_SCMSMODE_E
+{
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYALLOW,                /**<Copy Allow*/      /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYONCE,                 /**<Copy Once*/       /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYNOMORE,               /**<Copy NoMore*/     /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYPROHIBITED,           /**<Copy prohibited*/ /**<CNcomment:*/
+    HI_UNF_SND_SPDIF_SCMSMODE_BUTT
+} HI_UNF_SND_SPDIF_SCMSMODE_E;
+
+/**audio effect type, HI_UNF_AUDIO_EFFECT_TYPE_E keep consistent with effect type of ARM/DSP*/
+/**CNcomment:HI_UNF_AUDIO_EFFECT_TYPE_E  ARM/DSP  */
+typedef enum
+{
+    HI_UNF_SND_AEF_TYPE_DOLBYDV258 = 0x000,  /**<Dolby audio effect*/ /**<CNcomment: Dolby*/
+
+    HI_UNF_SND_AEF_TYPE_SRS3D = 0x010,      /**<SRS audio effect*/ /**<CNcomment: SRS*/
+
+    HI_UNF_SND_AEF_TYPE_BASE = 0x080,       /**<Base audio effect*/ /**<CNcomment: */
+} HI_UNF_SND_AEF_TYPE_E;
+
+typedef enum hiUNF_PEQ_FILTER_TYPE_E
+{
+    HI_UNF_PEQ_FILTER_TYPE_HP = 0,  /**<high-pass filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_LS = 1,  /**<low-shelving filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_PK = 2,  /**<peaking filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_HS = 3,  /**<high-shelving filter*/ /**<CNcomment:   */
+    HI_UNF_PEQ_FILTER_TYPE_LP = 4,  /**<low-pass filter*/ /**<CNcomment:  */
+    HI_UNF_PEQ_FILTER_TYPE_BUTT
+} HI_UNF_PEQ_FILTER_TYPE_E;
+
+/**Defines PEQ band attribute*/
+/**CNcomment:PEQ */
+typedef struct hiHI_UNF_SND_PEQ_BAND_ATTR_S
+{
+    HI_UNF_PEQ_FILTER_TYPE_E enFltType; /**<filter type of the band*/ /**<CNcomment: */
+    HI_U32 u32freq;  /**<center frequency of the band, HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+                     /**<CNcomment: ,: HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+    HI_U32 u32Q; /**<Q value of the band, if 2.5, value is 25, range:HS and LS[0.7, 1], PK[0.5, 10],HP and LP is fix to be 0.7*/
+                 /**<CNcomment: q,2.5,25,: HS and LS[0.7, 1], PK[0.5, 10], 0.7*/
+    HI_S32 s32Gain; /**<gain of the band, if -2.125, value is -2125,Gain ranging from -15 to 15 step by 0.125dB*/
+                    /**<CNcomment: ,-2.125,-2125,:[-15, 15],0.125*/
+} HI_UNF_SND_PEQ_BAND_ATTR_S;
+
+/**Defines PEQ attribute */
+/**CNcomment:PEQ */
+typedef struct hiHI_UNF_SND_PEQ_ATTR_S
+{
+    HI_U32 u32BandNum; /**<the PEQ band number,u32BandNum ranging from 5 to 10*/ /**<CNcomment: PEQ,:[5,10]*/
+    HI_UNF_SND_PEQ_BAND_ATTR_S stEqParam[HI_UNF_SND_EQ_BANDNUM_MAX];/**<PEQ band attribute*/ /**<CNcomment: PEQ*/
+} HI_UNF_SND_PEQ_ATTR_S;
+
+/**Defines DRC attribute */
+/**CNcomment:DRC*/
+typedef struct hiHI_UNF_SND_DRC_ATTR_S
+{
+    HI_U32  u32AttackTime;   /**<the attack time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: (:ms),:[20, 2000]*/
+    HI_U32  u32ReleaseTime;  /**<the release time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: (:ms),:[20, 2000]*/
+    HI_S32  s32Thrhd;  /**<the threshold value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: ,-2.125,-2125,0.125dB,:[-80dB, -1dB)*/
+    HI_S32  s32Limit;  /**<the maximum value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: ,-2.125,-2125,0.125dB,:[-80dB, -1dB)*/
+    HI_U32  u32RefMode;  /**<refmode(0:process both channel together mode, 1:process each channel independently mode)*/ /**<CNcomment:  0:  1 */
+    HI_U32  u32SpeedCtrlMode;  /**<speedctrlmode(0:normal mode, 1:fast mode)*/ /**<CNcomment: 0:  1:  */
+} HI_UNF_SND_DRC_ATTR_S;
+
+/**Defines  AVC attribute */
+/**CNcomment:AVC*/
+typedef struct hiHI_UNF_SND_AVC_ATTR_S
+{
+    HI_S32  s32ThresholdLevel;  /**<the threshold value, if -32.125, value is -32125, ranging from -40dB to -16dB step by 0.125dB*/
+                                /**<CNcomment: ,-32.125,-32125,0.125dB,(-40dB, -16dB)*/
+    HI_S32  s32Gain;            /**<the gain value, if 2.125, value is 2125,ranging from 0dB to 8dB step by 0.125dB*/
+                                /**<CNcomment: ,2.125,2125,0.125dB,:[0dB, 8dB]*/
+    HI_S32  s32LimiterLevel;    /**<the target level value, if -2.125, value is -2125, ranging from -40dB to 0dB step by 0.125dB*/
+                                /**<CNcomment:,-2.125,-2125,0.125dB,:(-40dB, 0dB]*/
+    HI_U32  u32AttackTime;      /**<the attack time(unit:ms),ranging from 20 to 2000,default value 50(recommended)*/ /**<CNcomment: (:ms),:[20, 2000]50*/
+    HI_U32  u32ReleaseTime;     /**<the release time(unit:ms),ranging from 20 to 2000,default value 100(recommended)*/ /**<CNcomment: (:ms),:[20, 2000]100*/
+} HI_UNF_SND_AVC_ATTR_S;
+
+/**Audio output latency mode*/
+/**CNcomment:*/
+typedef enum
+{
+    HI_UNF_SND_OUTPUTLATENCY_NORMAL = 0,  /**<normal latency MS12 ONLY.*/ /**<CNcomment:*/
+    HI_UNF_SND_OUTPUTLATENCY_LOW,         /**<low latency MS12 ONLY*/     /**<CNcomment:*/
+    HI_UNF_SND_OUTPUTLATENCY_BUTT,
+} HI_UNF_SND_OUTPUTLATENCY_E;
+
+/******************************* API declaration *****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  SOUND */
+
+/**
+\brief Initializes an AO device. CNcomment: CNend
+\attention \n
+Before calling the SND module, you must call this application programming interface (API). CNcomment:SND CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AO device. CNcomment: CNend
+\attention \n
+N/A
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_DeInit(HI_VOID);
+
+/**
+\brief Obtains the default configured parameters of an AO device. CNcomment: CNend
+\attention \n
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[out] pstAttr     Audio attributes CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_E enSound, HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Starts an AO device. CNcomment: CNend
+\attention \n
+One port only can attach to one sound.
+CNcomment:sound CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] pstAttr     Attribute of an AO device CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Open(HI_UNF_SND_E enSound, const HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Destroys a AO SND instance. CNcomment:Sound CNend
+\attention \n
+An instance cannot be destroyed repeatedly. CNcomment: CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Close(HI_UNF_SND_E enSound);
+
+
+/**
+\brief Sets the mute status of  AO ports. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of AO ports. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbMute);
+
+/**
+\brief Sets the output mode of the HDMI(Auto/PCM/RAW/HBR2LBR).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enHdmiMode HDMI mode CNcomment:HDMICNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E enHdmiMode);
+
+/**
+\brief Gets the output mode of the HDMI.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] Pointer to the obtained HDMI mode CNcomment:HDMICNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E* penHdmiMode);
+
+/**
+\brief Sets the output mode of the SPDIF(PCM/RAW).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enHdmiMode SPDIF mode CNcomment:SPDIFCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E enSpdifMode);
+
+/**
+\brief Gets the output mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] penSpdifMode Pointer to the obtained SPDIF mode CNcomment:SPDIFCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E* penSpdifMode);
+
+/**
+ \brief Sets the output volume value. CNcomment: CNend
+ \attention \n
+If s32Gain is set to a value greater than 100 or 0dB, then return failure. CNcomment:s32Gain1000dB CNend
+ \param[in] enSound        ID of an AO device CNcomment: CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+ \param[in] pstGain     Volume value CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE FAILURE CNcomment: CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_SND_INVALID_ID        The parameter enSound is invalid. CNcomment:Sound ID CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_SetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Obtains the output volume value. CNcomment: CNend
+\attention \n
+The default linear volume value is 100 and abslute volume is 0dB. CNcomment:100() and 0dB() CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+ \param[out] pstGain    Pointer to the obtained volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Sets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enSpdifCategoryCode  SPDIF category code CNcomment:SPDIF CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E enSpdifCategoryCode);
+
+/**
+\brief Gets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] enSpdifCategoryCode Pointer to the obtained category code CNcomment:CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E* penSpdifCategoryCode);
+
+/**
+\brief Sets the SCMS mode of the SPDIF(COPYALLOW/COPYONCE/COPYPROHIBITED).
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[in] enSpdifSCMSMode  SPDIF SCMS mode CNcomment:SPDIF SCMS CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E enSpdifSCMSMode);
+
+/**
+\brief Gets the SCMS mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment: CNend
+\param[out] enSpdifSCMSMode Pointer to the obtained SPDIF SCMS mode CNcomment:SPDIF SCMSCNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E* enSpdifSCMSMode);
+
+/**
+\brief Sets the sampling rate during audio output. CNcomment: CNend
+\attention \n
+At present, the sampling rate cannot be set, and it is fixed at 48 kHz. The streams that are not sampled at 48 kHz are resampled at 48 kHz.
+CNcomment:48k(48K~192K)8K192K6\n
+192K(192K)32K()\n
+8K(8K~192K)HDMI32K(HDMI) CNend
+\param[in] enSound          ID of an AO device CNcomment: CNend
+\param[in] enSampleRate    Audio sampling rate. For details, see the description of ::HI_UNF_SAMPLE_RATE_E. CNcomment:::HI_UNF_SAMPLE_RATE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E enSampleRate);
+
+/**
+\brief Obtains the sampling rate during audio output. CNcomment: CNend
+\attention \n
+The 48 kHz sampling rate is returned by default. CNcomment:48kHz CNend
+\param[in] enSound           ID of an AO device CNcomment: CNend
+\param[out] penSampleRate   Pointer to the type of the audio sampling rate CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E* penSampleRate);
+
+/**
+\brief set aduiodelay for output port. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] enOutPort output port .CNcomment: CNend
+\param[in] u32DelayMs Audio delay ms .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32 u32DelayMs);
+
+/**
+\brief get aduiodelay for output port. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] enOutPort output port .CNcomment: CNend
+\param[in] pu32DelayMs Audio delay ms .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32* pu32DelayMs);
+
+/**
+\brief enable ADAC audio output. CNcomment: ADAC  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound ID of an AO device CNcomment: CNend
+\param[in] bEnable enable ADAC output .CNcomment:ADAC  CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAdacEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Sets the smart volume for audio output. CNcomment: CNend
+\attention \n
+1. The smart volume is disabled by default.\n
+2. The smart volume is valid only for the track.\n
+3. The smart volume is enabled only when the program is switched.
+CNcomment:1. \n
+2. track\n
+3.  CNend
+\param[in] hTrack           Track handle CNcomment:Track  CNend
+\param[in] bSmartVolume     Smart volume enable, HI_TRUE: enabled; HI_FALSE: disabled CNcomment:HI_TRUEHI_FALSE CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL bEnable);
+
+/**
+\brief Obtains the status of the smart volume for audio output. CNcomment: CNend
+\attention \n
+\param[in] hTrack           Track handle CNcomment:Track  CNend
+\param[out] pbSmartVolume     Pointer to the enable status of the smart volume CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE Failure CNcomment: CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL* pbEnable);
+
+/**
+\brief Seting low latency threshold for audio output. CNcomment: Sound CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  CNcomment:sound  CNend
+\param[in] u32LatecnyMs,  latency ms .CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32 u32LatecnyMs);
+
+/**
+\brief Geting low latency threshold for audio output. CNcomment: Sound CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  CNcomment:sound  CNend
+\param[in] pu32LatecnyMs,  latency ms .CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32* p32LatecnyMs);
+
+/**
+\brief Set the AO track mode. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] enOutPort   CNcomment:sound CNend
+\param[in] enMode     Audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the AO track mode. CNcomment: CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] enOutPort   CNcomment:sound CNend
+\param[out] penMode   Pointer to the AO track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+\brief Attaches the SND module to an audio/video player (AVPLAY). CNcomment:SoundAVAudio Video CNend
+\attention \n
+Before calling this API, you must create a player and ensure that the player has no output. CNcomment: CNend
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track  CNend
+\param[in] hSource           Instance handle of an AVPLAY CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_Attach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Detaches the SND module from an AVPLAY. CNcomment:TrackAV CNend
+\attention \n
+N/A
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track  CNend
+\param[in] hSource    Instance handle of an AVPLAY CNcomment:AV CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Detach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Sets the mixing weight of an audio player. CNcomment:Track  CNend
+\attention \n
+The output volumes of two players are calculated as follows: (volume x weight 1 + volume x weight 2)/100. The formula of calculating the output volumes of multiple players is similar.
+CNcomment:Track %1+%2/100 CNend
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstMixWeightGain   the MixWeight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:01000100 CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackWeight(HI_HANDLE hTrack, const HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Obtains the mixing weight of an audio player. CNcomment: CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstMixWeightGain     Pointer to the MixWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackWeight(HI_HANDLE hTrack, HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Sets the L/R channel weight of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackAbsWeight(HI_HANDLE hTrack, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of an audio player. CNcomment: CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackAbsWeight(HI_HANDLE hTrack, HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets the prescale of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] pstPreciGain        Pointer of the prescale CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackPrescale(HI_HANDLE hTrack, const HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Obtains the prescale of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[out] pstPreciGain        Pointer to the prescale CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackPrescale(HI_HANDLE hTrack, HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Sets mute or unmute of an audio player. CNcomment:Track  CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] bMute               mute or not CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackMute(HI_HANDLE hTrack, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of an audio player. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[out] pbMute               mute status CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackMute(HI_HANDLE hTrack, HI_BOOL* pbMute);
+
+/**
+\brief Sets mute or unmute of all players. CNcomment:Track  CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:soundtrack CNend
+\param[in] bMute               mute or not CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of all players. CNcomment:Track CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:sound track CNend
+\param[in] pbMute               mute status CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL* pbMute);
+
+/**
+\brief Set the track channel mode. CNcomment:Track   CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[in] enMode             The audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the track channel mode. CNcomment:Track  CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:Track CNend
+\param[out] penMode   Pointer to the audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+ \brief Obtains the default configured parameters of an AO Track. CNcomment:Track CNend
+ \attention \n
+ \param[in] enTrackType              Track Type CNcomment:Track CNend
+ \param[out] pstAttr     Audio attributes CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE  Failure  CNcomment: CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_E enTrackType, HI_UNF_AUDIOTRACK_ATTR_S* pstAttr);
+
+/**
+\brief Create a Track. CNcomment:Track CNend
+\attention \n
+Create 8 output tracks(master/slave track) and 6 virtual tracks at the most. only create 1 master track on every sound.
+CNcomment:8track(master/slave), 6tracksoundmaster track CNend
+\param[in] enSound     ID of an AO device CNcomment: CNend
+\param[in] pTrackAttr  Track attributes CNcomment:Track   CNend
+\param[out] phTrack   Pointer to the handle of the created Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE  Failure  CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_CreateTrack(HI_UNF_SND_E enSound, const HI_UNF_AUDIOTRACK_ATTR_S* pTrackAttr, HI_HANDLE* phTrack);
+
+/**
+\brief Destroy a Track. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_DestroyTrack(HI_HANDLE hTrack);
+
+/**
+\brief set the attribute of  a track, reversed. CNcomment:track  CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] stTrackAttr   the attribute of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackAttr(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief get the attribute of  a track, reversed. CNcomment:track  CNend
+\attention \n
+1.virtual track Attr not support set.\n
+2.pstTrackAttr struct: just enTrackType&u32BufLevelMs can be set ,other members not support.
+CNcomment:1.track\n
+2.pstTrackAttrenTrackType&u32BufLevelMs CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[out] pstTrackAttr   the attribute of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackAttr(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief set the config of a track. CNcomment:track CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.ms12track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] pstConfig   the config of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackConfig(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief get the config of a track. CNcomment:track CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.ms12track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[out] pstConfig   the config of the Track CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackConfig(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief Acquire the audio frame from the track. CNcomment:track CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment: CNend
+\param[out] pstAOFrame the audio frame  CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_AcquireTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Release the audio frame . CNcomment:track  CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track  CNend
+\param[in] pstAOFrame the audio frame  CNcomment:Track  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID  The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_ReleaseTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief  Transmits data to a slave track directly. CNcomment:slave track CNend
+\attention \n
+1. If HI_ERR_AO_OUT_BUF_FULL is returned, you need to transmit the data that fails to be transmitted last time to ensure the audio continuity.
+2. For the PCM data, the restrictions are as follows:
+    s32BitPerSample must be set to 16.
+    bInterleaved must be set to HI_TRUE. Only interlaced mode is supported.
+    u32Channels can be set to 1 or 2.
+    u32PtsMs can be ignored.
+    ps32PcmBuffer indicates the PCM data pointer.
+    ps32BitsBuffer can be ignored.
+    u32PcmSamplesPerFrame indicates the number of audio sampling. The data length (in byte) is calculated as follows: u32PcmSamplesPerFrame x u32Channels x sizeof(HI_u16)
+    u32BitsBytesPerFrame can be ignored.
+    u32FrameIndex can be ignored.
+CNcomment:1 HI_ERR_AO_OUT_BUF_FULL
+2 PCM 
+    s32BitPerSample: 16
+    bInterleaved: HI_TRUE, 
+    u32Channels: 1 2
+    u32PtsMs: 
+    ps32PcmBuffer: PCM 
+    ps32BitsBuffer: 
+    u32PcmSamplesPerFrame: , (unit:Bytes): u32PcmSamplesPerFrame*u32Channels*sizeof(HI_u16)
+    u32BitsBytesPerFrame: 
+    u32FrameIndex:  CNend
+\param[in] hTrack   Track handle CNcomment:Track  CNend
+\param[in] pstAOFrame   Information about the audio data CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_OUT_BUF_FULL  Data fails to be transmitted because the mixer buffer is full. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SendTrackData(HI_HANDLE hTrack, const HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief Obtains the delay ms of track. CNcomment:Track CNend
+\attention \n
+\param[in] hTrack     ID of ao track CNcomment:Track ID CNend
+\param[out] pDelayMs     DelayMs attributes CNcomment:Track CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackDelayMs(const HI_HANDLE hTrack, HI_U32* pDelayMs);
+
+/**
+\brief Sets the output high precision volume value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound        ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstPreciGain     high precision volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Obtains the output high precision volume value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pstPreciGain   Pointer to the obtained high precision volume value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Sets the output balance. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound        ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] s32Balance     balance value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32 s32Balance);
+
+/**
+\brief Obtains balance value. CNcomment: CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] ps32Balance   Pointer to the obtained balance value CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32* ps32Balance);
+
+/**
+\brief Start render engine. CNcomment:Render CNend
+\attention \n
+N/A
+\param[in] enSound  Render of the sound CNcomment:SoundRender CNend
+\param[in] pstAttr  Attr of Render CNcomment: Render CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_StartRender(HI_UNF_SND_E enSound, HI_UNF_SND_RENDER_ATTR_S* pstAttr);
+
+/**
+\brief Stop render engine. CNcomment:Render CNend
+\attention \n
+N/A
+\param[in] enSound  Render of the sound CNcomment:SoundRender CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_StopRender(HI_UNF_SND_E enSound);
+
+/**
+\brief create screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound      display channel.CNcomment: CNend
+\param[out] pstAttr      handle of default attr  .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32   HI_UNF_SND_GetDefaultCastAttr(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr);
+
+/**
+\brief create screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound      display channel.CNcomment: CNend
+\param[in] pstAttr      pointer of parameter .CNcomment:, CNend
+\param[out] phCast      handle of screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_CreateCast(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr, HI_HANDLE* phCast);
+
+/**
+\brief destroy screen share channel. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phCast      handle of screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_DestroyCast(HI_HANDLE hCast);
+
+/**
+\brief enable screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment:
+\param[in] phCast      handle of screen share .CNcomment:
+\param[in] bEnable      enable screen share .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetCastEnable(HI_HANDLE hCast, HI_BOOL bEnable);
+
+/**
+\brief get enable flag of screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phCast      handle of screen share .CNcomment: CNend
+\param[out] bEnable     flag .CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetCastEnable(HI_HANDLE hCast, HI_BOOL* pbEnable);
+
+/**
+\brief get frame info of snd cast. CNcomment:  CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as SND).
+\param[in] hCast      handle of screen share .CNcomment: CNend
+\param[out] pstCastFrame        frame info.CNcomment: CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_V_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_CAST_TIMEOUT   no enough data.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief release frame info of screen share. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] hCast      handle of screen share .CNcomment: CNend
+\param[in] pstCastFrame     frame info.CNcomment: CNend
+\param[in] u32TimeoutMs    release timeout.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_ReleaseCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame);
+
+/**
+\brief Sets the L/R channel weight of snd cast. CNcomment:Cast CNend
+\attention \n
+\param[in] hCast              ID of snd cast CNcomment:Cast ID CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:01000100 CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetCastAbsWeight(HI_HANDLE hCast, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of audio cast. CNcomment:Cast CNend
+\attention \n
+
+\param[in] hCast              ID of snd cast CNcomment:Cast ID CNend
+\param[out] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetCastAbsWeight(HI_HANDLE hCast,  HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets the mute status of audio cast. CNcomment:Cast CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetCastMute(HI_HANDLE hCast, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of audio cast. CNcomment:Cast CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetCastMute(HI_HANDLE hCast, HI_BOOL* pbMute);
+
+/**
+\brief enable/disable audio effect for output port. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  output port .CNcomment: CNend
+\param[in] bBypass    enable/disable .CNcomment: CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bBypass);
+
+/**
+\brief get info of audio effect for output port. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  output port .CNcomment: CNend
+\param[in] pbBypass   enable/disable .CNcomment: CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbBypass);
+
+/**
+\brief Registers Audio effect authorize library . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] pAefLibFileName  file name of authorize library .CNcomment: CNend
+\retval ::HI_SUCCESS    success. CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_RegisterAefAuthLib(const HI_CHAR* pAefLibFileName);
+
+/**
+\brief Create audio effect . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enAefType  audio effect type .CNcomment: CNend
+\param[in] pstAdvAttr audio effect attribute .CNcomment: CNend
+\param[in] u32AttrLen audio effect attribute length .CNcomment: CNend
+\param[out] phAef     the point of audio effect handle  .CNcomment: CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_CreateAef(HI_UNF_SND_E enSound, HI_UNF_SND_AEF_TYPE_E enAefType, HI_VOID* pstAdvAttr, HI_U32 u32AttrLen, HI_HANDLE* phAef);
+
+/**
+\brief Destroy audio effect . CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\retval ::HI_SUCCESS success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_DestroyAef(HI_HANDLE hAef);
+
+/**
+\brief start/stop audio effect postprocess. CNcomment: / CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef   audio effect handle .CNcomment: CNend
+\param[in] bEnable start/stop .CNcomment:/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefEnable(HI_HANDLE hAef, HI_BOOL bEnable);
+
+/**
+\brief Set audio effect params. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\param[in] u32ParamType parameter type .CNcomment: CNend
+\param[in] pstParms     point of parameter .CNcomment: CNend
+\param[in] u32ParamLen  input parameter buffer length .CNcomment: CNend
+\retval ::HI_SUCCESSsuccess. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, const HI_VOID* pstParms, HI_U32 u32ParamLen);
+
+/**
+\brief Get audio effect params. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef    audio effect handle .CNcomment: CNend
+\param[in] u32ParamType  parameter type .CNcomment: CNend
+\param[out] pstParms      point of parameter .CNcomment: CNend
+\param[in] u32ParamLen  output parameter buffer length .CNcomment: CNend
+\retval ::HI_SUCCESS     success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, HI_VOID* pstParms, HI_U32 u32ParamLen);
+
+/**
+\brief Set audio effect config. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef  audio effect handle .CNcomment: CNend
+\param[in] u32CfgType   config type .CNcomment: CNend
+\param[in] pstConfig    point of config .CNcomment: CNend
+\param[in] u32ConfigLen input config buffer length .CNcomment: CNend
+\retval ::HI_SUCCESS    success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, const HI_VOID* pstConfig, HI_U32 u32ConfigLen);
+
+/**
+\brief Get audio effect config. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] phAef   audio effect handle .CNcomment: CNend
+\param[in] u32CfgType  config type .CNcomment: CNend
+\param[out] pstConfig   point of config .CNcomment: CNend
+\param[in] u32ConfigLen output config buffer length .CNcomment: CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, HI_VOID* pstConfig, HI_U32 u32ConfigLen);
+
+/**
+\brief Set audio avc attr. CNcomment: avc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] pstAvcAttr  the attribute of the avc .CNcomment:avc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcAttr(HI_UNF_SND_E enSound, const HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief get the attribute of  avc, reversed. CNcomment:avc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pstAvcAttr   the attribute of avc CNcomment:avc  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetAvcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief start/stop avc process. CNcomment: /avc CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of avc postprocess. CNcomment: avc/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:avc/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio drc attr. CNcomment: drc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief Get audio drc attr. CNcomment: drc CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief start/stop drc process. CNcomment: /drc CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of drc postprocess. CNcomment: drc/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:drc/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio peq attr. CNcomment: peq CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] pstPeqAttr  the attribute of the peq .CNcomment:peq CNend
+\retval ::HI_SUCCESS   success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief get the attribute of  peq, reversed. CNcomment:peq CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pstPeqAttr   the attribute of peq CNcomment:peq  CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief start/stop peq process. CNcomment: /peq CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of peq postprocess. CNcomment: peq/ CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment: CNend
+\param[out] pbEnable start/stop status .CNcomment:peq/ CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/**
+\brief Get snd underload count. CNcomment:  CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[out] pu32Count underload count .CNcomment: CNend
+\retval ::HI_SUCCESS  success. CNcomment:  CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_GetUnderloadCount(HI_UNF_SND_E enSound, HI_U32* pu32Count);
+
+/**
+\brief set continue output MS12 only. CNcomment: continue output CNend
+\attention \n
+none. CNcomment:
+\param[in] enSound    ID of an AO device CNcomment: CNend
+\param[in] bEnable    start/stop .CNcomment: / CNend
+\retval ::HI_SUCCESS CNcomment: success. CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+*/
+HI_S32 HI_UNF_SND_SetContinueOutputEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Obtains continue output MS12 only. CNcomment:continue output CNend
+\attention \n
+none. CNcomment: CNend
+\param[in] enSound         ID of an AO device CNcomment: CNend
+\param[out] pbEnable   Pointer to the obtained continue output status CNcomment: CNend
+\retval ::HI_SUCCESS Success CNcomment: CNend
+\retval ::HI_FAILURE FAILURE CNcomment: CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+\retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR         The pointer is null. CNcomment: CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetContinueOutputEnable(HI_UNF_SND_E enSound, HI_BOOL* pbEnable);
+
+/**
+ \brief Set audio output latency mode MS12 only.CNcomment: CNend
+ \attention \n
+CNcomment: CNend
+ \param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[in] enMode Output mode .CNcomment:CNend
+ \retval ::HI_SUCCESS CNcomment: success. CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_SetOutputLatencyMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTLATENCY_E enOutMode);
+
+/**
+ \brief Get audio output latency mode MS12 only.CNcomment: CNend
+ \attention \n
+CNcomment: CNend
+ \param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[out] penMode Return output mode .CNcomment:CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE FAILURE CNcomment: CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:Sound ID CNend
+ \retval ::HI_ERR_AO_NULL_PTR         The pointer is null. CNcomment: CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_GetOutputLatencyMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTLATENCY_E *penOutMode);
+
+/**
+ \brief Set ATMOS Lock Enable.CNcomment:ATMOS Lock  CNend
+ \attention \n
+CNcomment: CNend
+ \param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[in] bAtmosLockEnable   AtmosLock flag .CNcomment:ATMOSLOCK  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE FAILURE CNcomment: CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:Sound ID CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_SetAtmosLockEnable(HI_UNF_SND_E enSound, HI_BOOL bAtmosLockEnable);
+
+/**
+ \brief Get ATMOS Lock state.CNcomment:ATMOS Lock  CNend
+ \attention \n
+CNcomment: CNend
+ \param[in] enSound         ID of an AO device CNcomment: CNend
+ \param[out] pbAtmosLockEnable   AtmosLock flag .CNcomment:ATMOSLOCK  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_FAILURE FAILURE CNcomment: CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:Sound ID CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_GetAtmosLockEnable(HI_UNF_SND_E enSound, HI_BOOL* pbAtmosLockEnable);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_SND_H__*/
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_spi.h b/xbmc/platform/linux/hisi/hi_unf_spi.h
new file mode 100644
index 0000000000..ff146051ba
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_spi.h
@@ -0,0 +1,277 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_spi.h  
+Version       : Initial Draft  
+Author        : Hisilicon STB SDK group 
+Created       : 2013/4/22  
+Last Modified : 
+Description   : output control  Function 
+Modification  : Created file
+******************************************************************************/
+#ifndef  __HI_UNF_SPI_H__
+#define  __HI_UNF_SPI_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+/*************************** Structure Definition ****************************/
+
+/** \addtogroup      SPI */
+/** @{*/  /** <!-[SPI]*/
+
+/** SPI device select */
+/** CNcomment: SPI  */
+typedef enum hiUNF_SPI_DEV_E
+{
+    HI_UNF_SPI_DEV_0 =0 ,
+    HI_UNF_SPI_DEV_1 = 1,
+    HI_UNF_SPI_DEV_BUTT
+}HI_UNF_SPI_DEV_E;
+
+/** SPI CS Config */
+/** CNcomment: SPI CS*/
+typedef enum hiUNF_SPI_CFGCS_E
+{
+    HI_UNF_SPI_LOGIC_CS =0 ,
+    HI_UNF_SPI_GPIO_CS = 1,
+}HI_UNF_SPI_CFGCS_E;
+
+
+/** SPICLOCKOUT polarity */
+/** CNcomment: SPICLOCKOUT  */
+typedef enum hiUNF_SPI_SPO_E
+{
+    HI_UNF_SPI_SPO_0 = 0,
+    HI_UNF_SPI_SPO_1 = 1 
+}HI_UNF_SPI_SPO_E;
+
+/** SPICLOCKOUT  phase */
+/** CNcomment: SPICLOCKOUT  */
+typedef enum hiUNF_SPI_SPH_E
+{
+    HI_UNF_SPI_SPH_0 = 0,
+    HI_UNF_SPI_SPH_1 = 1 
+}HI_UNF_SPI_SPH_E;
+
+/** SPI Frame format */
+/** CNcomment:  */
+typedef enum hiUNF_SPI_FRF_E
+{
+    HI_UNF_SPI_FRF_MOTO = 0,	/**< Motorola SPI */ /** CNcomment: Motorola SPI*/
+    HI_UNF_SPI_FRF_TI   = 1, 		/**< TI SPI */ /** CNcomment: TI SPI */
+    HI_UNF_SPI_FRF_NM   = 2,		/**< National Microwire */ /** CNcomment: National Microwire */
+    HI_UNF_SPI_FRF_BUTT = 3	
+}HI_UNF_SPI_FRF_E;
+
+/** SPI Data byte order */
+/** CNcomment:  */
+typedef enum hiUNF_SPI_BIGEND_E
+{
+	HI_UNF_SPI_BIGEND_LITTLE,	/**< little endian */ /** CNcomment: */
+	HI_UNF_SPI_BIGEND_BIG			/**< big endian */ /** CNcomment: */
+}HI_UNF_SPI_BIGEND_E;
+
+/** SPI addition attribute about Motorola SPI */
+/** CNcomment: Motorola SPI  */
+
+typedef struct hiUNF_SPI_ATTR_MOTO_S
+{
+	HI_UNF_SPI_SPO_E enSpo;	/**< only effactive when enCs is HI_UNF_SPI_FRF_MOTO */ /** CNcomment: motorola*/
+	HI_UNF_SPI_SPH_E enSph; /**< only effactive when enCs is HI_UNF_SPI_FRF_MOTO */ /** CNcomment: motorola*/
+}HI_UNF_SPI_ATTR_MOTO_S;
+
+/** SPI additional attribute about National Microwire SPI */
+/** CNcomment: National Microwire SPI  */
+typedef struct hiUNF_SPI_ATTR_NM_S
+{
+	HI_BOOL	bWaitEn;		/**< wait enable. */  /** CNcomment: */
+	HI_U32 u32Waitval;	/**< wait time value. */	/** CNcomment: */
+}HI_UNF_SPI_ATTR_NM_S;
+
+/** SPI additional attribute union */
+/** CNcomment: Motorola SPI/NM  */
+typedef union
+{
+	HI_UNF_SPI_ATTR_MOTO_S stMoto;
+	HI_UNF_SPI_ATTR_NM_S stNm;
+}HI_UNF_SPI_ATTR_EXT_U;
+
+/** The SPI attribute*/
+/** CNcomment: SPI*/
+typedef struct hiUNF_SPI_ATTR_S
+{
+	HI_UNF_SPI_DEV_E enDev;	/**< chip select */  /** CNcomment: */
+	HI_UNF_SPI_CFGCS_E csCfg; /**< cs select */  /** CNcomment: */
+	HI_U32	u32Baud;  /**< baud rate */  /** CNcomment: */
+	HI_UNF_SPI_FRF_E enFrf;	/**< frame format */  /** CNcomment: */
+	HI_U32 u32Dss;  /**< number of bits per transfer, 4-15bit, value of u32Dss : [4, 15]. */  /** CNcomment: 4-15*/
+	HI_UNF_SPI_BIGEND_E enBigend;	/**< byte order */  /** CNcomment: */
+	HI_UNF_SPI_ATTR_EXT_U unExtAttr; /**< addition attr when frf is moto or nm. */  /** CNcomment: MOTONM*/
+	
+}HI_UNF_SPI_ATTR_S;
+
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SPI*/
+/** @{*/  /** <!-- -SPI=*/
+
+/**
+ \brief Init the SPI device.
+CNcomment:\brief SPIthe Inter-Integrated CircuitCNend
+
+ \param N/A                                                               CNcomment:CNend
+ \retval 0 Success                                                        CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SPI_Init(HI_VOID);
+
+/**
+ \brief  DeInit the SPI device.
+CNcomment:\brief SPICNend
+
+ \param N/A                                                        CNcomment:CNend
+ \retval 0 Success                                                 CNcomment: CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SPI_DeInit(HI_VOID);
+
+
+
+/**
+ \brief Open the SPI device.
+CNcomment:\brief SPICNend
+
+  \attention \n
+ Hi3719MV100/ Hi3718MV100 has SPI0 only.\n
+ CNcomment: Hi3719MV100/ Hi3718MV100 SPI0\n CNend
+
+ \param[in] enDev  select device		  CNcomment:CNend
+  
+ \retval 0 Success                                                        CNcomment:CNend
+ \retval ::HI_ERR_SPI_OPEN_ERR  Opne Spi Error.	 	   CNcomment:SPICNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Open(HI_UNF_SPI_DEV_E enDev);	
+
+
+/**
+ \brief Close the SPI device.
+CNcomment:\brief SPICNend
+
+ \param[in] enDev  select device		  CNcomment:CNend
+
+ \retval 0 Success                                                        CNcomment:CNend
+ \retval ::HI_ERR_SPI_CLOSE_ERR  Close Spi Error.	 	   CNcomment:SPICNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Close(HI_UNF_SPI_DEV_E enDev);
+
+/**
+ \brief  Set the SPI working mode.
+CNcomment:\SPICNend
+
+ \param[in] enDev  select device		  CNcomment:CNend
+ \param[in] stAttr  The attribute of the SPI . CNcomment:SPICNend
+
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_SetAttr(HI_UNF_SPI_DEV_E enDev, HI_UNF_SPI_ATTR_S *stAttr);
+
+/**
+ \brief  Get the SPI working mode.
+CNcomment:\SPICNend
+
+ \param[in] enDev  select device          CNcomment:CNend
+ \param[out] stAttr  The attribute of the SPI . CNcomment:SPICNend
+ 
+ \retval 0 Success                                                 CNcomment: CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_GetAttr(HI_UNF_SPI_DEV_E enDev, HI_UNF_SPI_ATTR_S *stAttr);
+
+/**
+ \brief Trans data by using the SPI.
+CNcomment:\brief SPICNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:CNend
+ \param[in] pu8Send  Buffer for storing the data to be written       CNcomment:CNend
+ \param[in] u32SendCnt  Length of the data to be written        CNcomment:CNend
+ \param[in] pu8Read  Buffer for storing the data to be read . CNcomment:CNend
+ \param[in] u32ReadCnt  Length of the data to be read                                    CNcomment:CNend
+ \retval 0 Success                                                                      CNcomment:CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_ReadExt(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Send, HI_U32 u32SendCnt, HI_U8 *pu8Read, HI_U32 u32ReadCnt);
+
+/**
+ \brief Reads data by using the SPI.
+CNcomment:\brief SPICNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:CNend
+ \param[out] pu8Read  Buffer for storing the data to be read . CNcomment:CNend
+ \param[in] u32ReadCnt  Length of the data to be read                                    CNcomment:CNend
+
+ \retval 0 Success                                                                      CNcomment:CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Read(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Read, HI_U32 u32ReadCnt);
+
+/**
+ \brief Reads data by using the SPI.
+CNcomment:\brief SPICNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:CNend
+ \param[in] pu8Send  Buffer for storing the data to be written       CNcomment:CNend
+ \param[in] u32SendCnt  Length of the data to be written        CNcomment:CNend
+ 
+ \retval 0 Success                                                                      CNcomment:CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Write(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Send, HI_U32 u32SendCnt);
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+
+#endif
\ No newline at end of file
diff --git a/xbmc/platform/linux/hisi/hi_unf_subt.h b/xbmc/platform/linux/hisi/hi_unf_subt.h
new file mode 100644
index 0000000000..9c9bf7efc5
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_subt.h
@@ -0,0 +1,221 @@
+#ifndef __HI_UNF_SUBT_H__
+#define __HI_UNF_SUBT_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SUBTITLE */
+/** @{ */  /** <!-- SUBTITLE */
+
+/** Invalid handle in subtitle *//** CNcomment: */
+#define SUBT_INVALID_HANDLE   (0x0)
+/** the max item(language) in Subtitling descriptor *//** CNcomment:() */
+#define SUBT_ITEM_MAX_NUM     (32)
+/** the max subtitle instance *//** CNcomment: */
+#define SUBT_INSTANCE_MAX_NUM (8)
+
+/** Defines the subtitle data type  *//** CNcomment:  */
+typedef enum hiUNF_SUBT_DATA_TYPE_E
+{
+    HI_UNF_SUBT_DVB  = 0x1, /**<DVB subtitle *//**<CNcomment: DVB */
+    HI_UNF_SUBT_SCTE = 0x2, /**<SCTE subtitle *//**<CNcomment: SCTE */
+    HI_UNF_SUBT_BUTT
+}HI_UNF_SUBT_DATA_TYPE_E;
+
+/** Defines the type used to code the subtitle *//** CNcomment: */
+typedef enum hiUNF_SUBT_TYPE_E
+{
+    HI_UNF_SUBT_TYPE_BITMAP = 0, /**<Coding of bitmap *//**<CNcomment: */
+    HI_UNF_SUBT_TYPE_TEXT,       /**<Coded as a string of characters *//**<CNcomment: */
+    HI_UNF_SUBT_TYPE_BUTT
+}HI_UNF_SUBT_TYPE_E;
+
+/** Defines the status of the subtitling page *//** CNcomment: */
+typedef enum hiUNF_SUBT_PAGE_STATE_E
+{
+    HI_UNF_SUBT_PAGE_NORMAL_CASE        = 0,    /**<Page update, use previous page instance to display *//**<CNcomment: */
+    HI_UNF_SUBT_PAGE_ACQUISITION_POINT,         /**<Page refresh, use next page instance to display *//**<CNcomment: */
+    HI_UNF_SUBT_PAGE_MODE_CHANGE,               /**<New page, needed to display the new page *//**<CNcomment: */
+    HI_UNF_SUBT_PAGE_BUTT
+}HI_UNF_SUBT_PAGE_STATE_E;
+
+/** Defines the data of the subtitle output *//** CNcomment: */
+typedef struct hiUNF_SUBT_DATA_S
+{
+    HI_UNF_SUBT_TYPE_E enDataType;        /**<The type used to code the subtitle *//**<CNcomment: */
+    HI_UNF_SUBT_PAGE_STATE_E enPageState; /**<The status of the subtitling page *//**<CNcomment: */
+    HI_U32             u32x;              /**<The horizontal address of subtitling page *//**<CNcomment:x */
+    HI_U32             u32y;              /**<The vertical address of subtitling page *//**<CNcomment:y */
+    HI_U32             u32w;              /**<The horizontal length of subtitling page *//**<CNcomment: */
+    HI_U32             u32h;              /**<The vertical length of subtitling page *//**<CNcomment: */
+    HI_U32             u32BitWidth;       /**<Bits in pixel-code *//**<CNcomment: */
+    HI_U32             u32PTS;            /**<Presentation time stamp *//**<CNcomment: */
+    HI_U32             u32Duration;       /**<The period, expressed in ms, after which a page instance is no longer valid *//**<CNcomment:ms */
+    HI_U32             u32PaletteItem;    /**<Pixels of palette *//**<CNcomment: */
+    HI_VOID*           pvPalette;         /**<Palette data *//**<CNcomment: */
+    HI_U32             u32DataLen;        /**<Subtitling page data length *//**<CNcomment: */
+    HI_U8*             pu8SubtData;       /**<Subtitling page data *//**<CNcomment: */
+    HI_U32             u32DisplayWidth;   /**<Display canvas width *//**<CNcomment: */
+    HI_U32             u32DisplayHeight;  /**<Display canvas height *//**<CNcomment: */
+}HI_UNF_SUBT_DATA_S;
+
+/** Defines the item of the subtitling content *//** CNcomment: */
+typedef struct hiUNF_SUBT_ITEM_S
+{
+    HI_U32 u32SubtPID;      /**<The pid for playing subtitle *//**<CNcomment:pid */
+    HI_U16 u16PageID;       /**<The Subtitle page id *//**<CNcomment:id */
+    HI_U16 u16AncillaryID;  /**<The Subtitle ancillary id *//**<CNcomment:id */
+}HI_UNF_SUBT_ITEM_S;
+
+/** Defines the callback function which output the subtitling data *//** CNcomment: */
+typedef HI_S32 (*HI_UNF_SUBT_CALLBACK_FN)(HI_VOID* pUserData, HI_UNF_SUBT_DATA_S *pstData);
+
+/** Defines the callback function which get current pts *//** CNcomment: */
+typedef HI_S32 (*HI_UNF_SUBT_GETPTS_FN)(HI_VOID* pUserData, HI_S64 *ps64Pts);
+
+/** Defines the parameter of subtitle instance *//** CNcomment: */
+typedef struct hiUNF_SUBT_PARAM_S
+{
+    HI_UNF_SUBT_ITEM_S astItems[SUBT_ITEM_MAX_NUM]; /**<The item of the subtitling content *//**<CNcomment: */
+    HI_U8  u8SubtItemNum;                           /**<Amount of subtitling item *//**<CNcomment: */
+    HI_UNF_SUBT_CALLBACK_FN pfnCallback;            /**<Callback function in which output subtitling page data *//**<CNcomment: */
+    HI_VOID* pUserData;                             /**<User data used in callback function *//**<CNcomment: */
+    HI_UNF_SUBT_DATA_TYPE_E enDataType;             /**<subtitle data type in subt module *//**<CNcomment:subt */
+}HI_UNF_SUBT_PARAM_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SUBTITLE */
+/** @{*/  /** <!-- [SUBTITLE] */
+
+/**
+\brief Initialize subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\retval ::HI_SUCCESS initialize success. CNcomment:CNend
+\retval ::HI_FAILURE initialize failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_Init(HI_VOID);
+
+/**
+\brief DeInitialize subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\retval ::HI_SUCCESS deinitialize success. CNcomment:CNend
+\retval ::HI_FAILURE deinitialize failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+ HI_S32 HI_UNF_SUBT_DeInit(HI_VOID);
+
+/**
+\brief Create subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  pstSubtParam  parameters used in created subtitle. CNcomment:CNend
+\param[out] phSubt        subtitle handle. CNcomment:CNend
+\retval ::HI_SUCCESS create success. CNcomment:CNend
+\retval ::HI_FAILURE create failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_Create(HI_UNF_SUBT_PARAM_S *pstSubtParam, HI_HANDLE *phSubt);
+
+/**
+\brief Destroy subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\retval ::HI_SUCCESS destroy success. CNcomment:CNend
+\retval ::HI_FAILURE destroy failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_Destroy(HI_HANDLE hSubt);
+
+/**
+\brief Select one subtitle content to output. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\param[in]  pstSubtItem   subtitle item. CNcomment:CNend
+\retval ::HI_SUCCESS switching success. CNcomment:CNend
+\retval ::HI_FAILURE switching failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_SwitchContent(HI_HANDLE hSubt, HI_UNF_SUBT_ITEM_S *pstSubtItem);
+
+/**
+\brief Reset subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\retval ::HI_SUCCESS reset success. CNcomment:CNend
+\retval ::HI_FAILURE reset failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_Reset(HI_HANDLE hSubt);
+
+/**
+\brief Update subtitle module. CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\param[in]  pstSubtParam  the new subtitle content. CNcomment:CNend
+\retval ::HI_SUCCESS update success. CNcomment:CNend
+\retval ::HI_FAILURE update failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_Update(HI_HANDLE hSubt, HI_UNF_SUBT_PARAM_S *pstSubtParam);
+
+/**
+\brief Inject DVB subtitle stream to decoder. CNcomment:CNend
+\attention \n
+Used the PES packet syntax for carriage of DVB subtitles. CNcomment:DVBPESCNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\param[in]  u32SubtPID    the pid of subtitle stream. CNcomment:pidCNend
+\param[in]  pu8Data       subtitle stream data. CNcomment:CNend
+\param[in]  u32DataSize   the size of subtitle stream data. CNcomment:CNend
+\retval ::HI_SUCCESS inject success. CNcomment:CNend
+\retval ::HI_FAILURE inject failure. CNcomment:CNend
+\see \n
+none. CNcomment:CNend
+*/
+HI_S32 HI_UNF_SUBT_InjectData(HI_HANDLE hSubt, HI_U32 u32SubtPID, HI_U8* pu8Data, HI_U32 u32DataSize);
+
+/**
+\brief Register the callback function geted current pts.
+CNcomment:CNend
+\attention \n
+none. CNcomment:CNend
+\param[in]  hSubt         subtitle handle. CNcomment:CNend
+\param[in]  pfnGetPts     callback funtion which geted current pts. CNcomment:CNend
+\param[in]  pUserData   userdata which used in callback funtion. CNcomment:CNend
+\retval   ::HI_SUCCESS    success. CNcomment:CNend
+\retval   ::HI_FAILURE    failure. CNcomment:CNend
+\see \n
+none. CNcomment: CNend
+*/
+HI_S32 HI_UNF_SUBT_RegGetPtsCb(HI_HANDLE hSubt, HI_UNF_SUBT_GETPTS_FN pfnGetPts, HI_VOID* pUserData);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus*/
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_ttx.h b/xbmc/platform/linux/hisi/hi_unf_ttx.h
new file mode 100644
index 0000000000..96f9ec49a0
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_ttx.h
@@ -0,0 +1,550 @@
+/******************************************************************************
+
+*
+* Copyright (C) 2014 Hisilicon Technologies Co., Ltd.  All rights reserved.
+*
+* This program is confidential and proprietary to Hisilicon  Technologies Co., Ltd. (Hisilicon),
+*  and may not be copied, reproduced, modified, disclosed to others, published or used, in
+* whole or in part, without the express prior written permission of Hisilicon.
+*
+
+******************************************************************************
+  File Name     : hi_unf_ttx.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2011/10/20
+  Description   : Teletext UNF header file
+  History       :
+  1.Date        : 2011/10/20
+    Author      : sdk
+    Modification: Created file
+
+******************************************************************************/
+#ifndef __HI_UNF_TTX_H__
+#define __HI_UNF_TTX_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif  /* End of #ifdef __cplusplus */
+
+/********************************Structure Definition********************************/
+/** \addtogroup      Teletext */
+/** @{ */  /** <!-- [Teletext] */
+
+/** Teletext max line in page *//** CNcomment:teletext */
+#define HI_UNF_TTX_MAX_LINES (32)
+/** Teletext line size */ /** CNcomment:teletext */
+#define HI_UNF_TTX_LINE_SIZE (46)
+
+/** Teletext key support list *//** CNcomment: */
+typedef enum hiUNF_TTX_KEY_E
+{
+    HI_UNF_TTX_KEY_0,
+    HI_UNF_TTX_KEY_1,
+    HI_UNF_TTX_KEY_2,
+    HI_UNF_TTX_KEY_3,
+    HI_UNF_TTX_KEY_4,
+    HI_UNF_TTX_KEY_5,
+    HI_UNF_TTX_KEY_6,
+    HI_UNF_TTX_KEY_7,
+    HI_UNF_TTX_KEY_8,
+    HI_UNF_TTX_KEY_9, /**<Three number key to open a specified page *//**<CNcomment: */
+    HI_UNF_TTX_KEY_PREVIOUS_PAGE, /**<Previous page *//**<CNcomment: */
+    HI_UNF_TTX_KEY_NEXT_PAGE, /**<Next page *//**<CNcomment: */
+    HI_UNF_TTX_KEY_PREVIOUS_SUBPAGE, /**<Previous subpage *//**<CNcomment:  */
+    HI_UNF_TTX_KEY_NEXT_SUBPAGE, /**<Next subpage *//**<CNcomment:  */
+    HI_UNF_TTX_KEY_PREVIOUS_MAGAZINE, /**<Previous magazine *//**<CNcomment: */
+    HI_UNF_TTX_KEY_NEXT_MAGAZINE, /**<Next magazine *//**<CNcomment: */
+    HI_UNF_TTX_KEY_RED,    /**<First link in packet X/27, if inexistence, Show first valid page*//**<CNcomment:X/27 X/27 */
+    HI_UNF_TTX_KEY_GREEN,  /**<Second  link in packet X/27, if inexistence, Show second valid page*//**<CNcomment:X/27 X/27 */
+    HI_UNF_TTX_KEY_YELLOW, /**<Third  link in packet X/27, if inexistence, Show third valid page*//**<CNcomment:X/27 X/27 */
+    HI_UNF_TTX_KEY_CYAN,   /**<Fourth  link in packet X/27, if inexistence, Show fourth valid page. you can replace it with blue key if no cyan key on the user's control unit*/
+                           /**<CNcomment:X/27 X/27CYANBLUE*/
+    HI_UNF_TTX_KEY_INDEX,  /**<Sixth  link in packet X/27, if inexistence, Show index  page*//**<CNcomment:X/27 X/27 */
+    HI_UNF_TTX_KEY_REVEAL, /**<Reveal or hide concealed  information *//**<CNcomment:/conceal  */
+    HI_UNF_TTX_KEY_HOLD,   /**<Switch between hold and resume ttx play  *//**<CNcomment:/ */
+    HI_UNF_TTX_KEY_MIX,    /**<Switch  between  transparent and nontransparent  background *//**<CNcomment:Teletext/ */
+    HI_UNF_TTX_KEY_UPDATE, /**<Update current page*//**<CNcomment: */
+    HI_UNF_TTX_KEY_ZOOM,   /**<Send this cmd sevral times to display the upper,then the lower part of the screen and then return to the normal size teletext page*/
+                           /**<CNcomment:teletext */
+    HI_UNF_TTX_KEY_SUBPAGE,/**<switch from page num ipunt mode to subpage input mode*//**<CNcomment:subpage */
+    HI_UNF_TTX_KEY_CANCEL, /**<Hide or display current page except page number, currently not support*//**<CNcomment: ,*/
+    HI_UNF_TTX_KEY_TIME,   /**<Hide or display current time*//**<CNcomment:*/
+    HI_UNF_TTX_KEY_BUTT    /**<Invalid key*//**<CNcomment: */
+} HI_UNF_TTX_KEY_E;
+
+/** Teletext output type *//** CNcomment:Teletext */
+typedef enum hiUNF_TTX_OUTPUT_E
+{
+    HI_UNF_TTX_VBI_OUTPUT,  /**<Only VBI output *//**<CNcomment:VBI  */
+    HI_UNF_TTX_OSD_OUTPUT,  /**<Only OSD output *//**<CNcomment:OSD  */
+    HI_UNF_TTX_DUAL_OUTPUT, /**<VBI OSD dual output *//**<CNcomment:VBIOSD */
+    HI_UNF_TTX_BUTT         /**<Invalid output type *//**<CNcomment: */
+} HI_UNF_TTX_OUTPUT_E;
+
+/** Teletext type *//** CNcomment:Teletext */
+typedef enum hiUNF_TTX_TYPE_E
+{
+    HI_UNF_TTX_INITTTX = 1, /**<Initial Teletext page *//**<CNcomment:Teletext  */
+    HI_UNF_TTX_TTXSUBT = 2, /**<Teletext subtitle page *//**<CNcomment:Teletext  */
+    HI_UNF_TTX_ADDINFO = 3, /**<Nonsupport for the moment <Additional information page *//**<CNcomment: */
+    HI_UNF_TTX_PROGSCD = 4, /**<Nonsupport for the moment <Programme schedule page *//**<CNcomment: */
+    HI_UNF_TTX_TTXSUBT_HIP = 5, /**<Nonsupport for the moment <Teletext subtitle page for hearing impaired people *//**<CNcomment:Teletext */
+    HI_UNF_TTX_TTXSUBT_BUTT /**<Invalid teletext type *//**<CNcomment:teletext  */
+} HI_UNF_TTX_TYPE_E;
+
+/** Teletext page type *//** CNcomment:Teletext */
+typedef enum hiUNF_TTX_PAGE_TYPE_E
+{
+    HI_UNF_TTX_PAGE_CUR,   /**<Current reveal page *//**<CNcomment: */
+    HI_UNF_TTX_PAGE_INDEX, /**<Initial Teletext page , if  packet X/30 exist, return index page in X/30, otherwise return default index page 100*/
+                           /**<CNcomment:X/30X/30100 */
+    HI_UNF_TTX_PAGE_LINK1, /**<First link  in packet  X/27, if  inexistence, return first valid page*//**<CNcomment:X/271 */
+    HI_UNF_TTX_PAGE_LINK2, /**<Second link  in packet  X/27, if inexistence, return second valid page*//**<CNcomment:X/272 */
+    HI_UNF_TTX_PAGE_LINK3, /**<Third link  in packet  X/27, if  inexistence, return third valid page*//**<CNcomment:X/273 */
+    HI_UNF_TTX_PAGE_LINK4, /**<Fourth  link  in packet  X/27, if  inexistence, return fourth valid page*//**<CNcomment:X/274 */
+    HI_UNF_TTX_PAGE_LINK5, /**<Fifth link  in packet  X/27, if inexistence, return fifth valid page*//**<CNcomment:X/2750ff:3f7f */
+    HI_UNF_TTX_PAGE_LINK6, /**<Sixth link  in packet  X/27, if inexistence, return Sixth valid page*//**<CNcomment:X/2760ff:3f7f */
+    HI_UNF_TTX_PAGE_BUTT   /**<Invalid  page type *//**<CNcomment: */
+} HI_UNF_TTX_PAGE_TYPE_E;
+
+/** Teletext user command type *//** CNcomment:Teletext */
+typedef enum hiUNF_TTX_CMD_E
+{
+    HI_UNF_TTX_CMD_KEY,          /**<(HI_UNF_TTX_KEY_E *)Default alternation type, key *//**<CNcomment: */
+    HI_UNF_TTX_CMD_OPENPAGE,     /**<(HI_UNF_TTX_PAGE_ADDR_S *) Open specified page*//**<CNcomment:(HI_UNF_TTX_PAGE_ADDR_S *) */
+    HI_UNF_TTX_CMD_GETPAGEADDR,  /**<(HI_UNF_TTX_GETPAGEADDR_S *)Get current page , index page and  link page  address*//**<CNcomment:(HI_UNF_TTX_GETPAGEADDR_S *)  */
+    HI_UNF_TTX_CMD_CHECKPAGE,    /**<(HI_UNF_TTX_CHECK_PARAM_S *) Check the specified page be received or not*//**<CNcomment:(HI_UNF_TTX_CHECK_PARAM_S *)  */
+    HI_UNF_TTX_CMD_SETREQUEST,   /**<(HI_UNF_TTX_REQUEST_RAWDATA_S *) Sets up a request for teletext raw data*//**<CNcomment:(HI_UNF_TTX_REQUEST_RAWDATA_S *) teletext */
+    HI_UNF_TTX_CMD_CLEARREQUEST, /**<(HI_UNF_TTX_REQUEST_RAWDATA_S *) Clears a request set up by the HI_UNF_TTX_CMD_SETREQUEST*//**<CNcomment:(HI_UNF_TTX_REQUEST_RAWDATA_S *) HI_UNF_TTX_CMD_SETREQUEST */
+    HI_UNF_TTX_CMD_BUTT          /**<Invalid command type *//**<CNcomment: */
+} HI_UNF_TTX_CMD_E;
+
+/** G0 char set *//** CNcomment:G0 */
+typedef  enum   hiUNF_TTX_G0SET_E
+{
+    HI_UNF_TTX_G0SET_LATIN,      /**<LATIN G0 Primary Set  *//**<CNcomment:LATIN G0 */
+    HI_UNF_TTX_G0SET_CYRILLIC_1, /**<CYRILLIC_1 G0 Primary Set *//**<CNcomment:CYRILLIC_1  G0 */
+    HI_UNF_TTX_G0SET_CYRILLIC_2, /**<CYRILLIC_2 G0 Primary Set*//**<CNcomment:CYRILLIC_2 G0 */
+    HI_UNF_TTX_G0SET_CYRILLIC_3, /**<CYRILLIC_3 G0 Primary Set*//**<CNcomment:CYRILLIC_3 G0 */
+    HI_UNF_TTX_G0SET_GREEK,      /**<GREEK G0 Primary Set*//**<CNcomment:GREEK G0 */
+    HI_UNF_TTX_G0SET_HEBREW,     /**<HEBREW G0 Primary Set*//**<CNcomment:HEBREW  G0 */
+    HI_UNF_TTX_G0SET_ARABIC,     /**<ARABIC G0 Primary Set*//**<CNcomment:ARABIC G0 */
+    HI_UNF_TTX_G0SET_BUTT        /**<Invalid G0 Primary Set *//**<CNcomment:G0 */
+} HI_UNF_TTX_G0SET_E;
+
+/** G2 char set *//** CNcomment:G2 */
+typedef enum hiUNF_TTX_G2SET_E
+{
+    HI_UNF_TTX_G2SET_LATIN,    /**<LATIN G2 Set *//**<CNcomment:LATIN G2 */
+    HI_UNF_TTX_G2SET_CYRILLIC, /**<CYRILLIC G2 Set *//**<CNcomment:CYRILLIC G2 */
+    HI_UNF_TTX_G2SET_GREEK,    /**<GREEK G2 Set *//**<CNcomment:GREEK G2 */
+    HI_UNF_TTX_G2SET_ARABIC,   /**<ARABIC G2 Set *//**<CNcomment:ARABIC G2 */
+    HI_UNF_TTX_G2SET_BUTT      /**<Invalid G2 Set *//**<CNcomment:G2 */
+}HI_UNF_TTX_G2SET_E;
+
+/** Latin G0 National Option Sub-sets *//** CNcomment:Latin G0 */
+typedef enum hiUNF_TTX_NATION_SET_E
+{
+    HI_UNF_TTX_NATION_SET_PRIMARY,      /**<Latin G0 Primary nation sub set*//**<CNcomment:LATIN*/
+    HI_UNF_TTX_NATION_SET_CZECH,        /**<Latin czech slovak nation sub set*//**<CNcomment:LATIN czech/slovak*/
+    HI_UNF_TTX_NATION_SET_ENGLISH,      /**<Latin english nation sub set*//**<CNcomment:LATIN english*/
+    HI_UNF_TTX_NATION_SET_ESTONIAN,     /**<Latin estonian nation sub set*//**<CNcomment:LATIN estonian*/
+    HI_UNF_TTX_NATION_SET_FRENCH,       /**<Latin french nation sub set*//**<CNcomment:LATIN french*/
+    HI_UNF_TTX_NATION_SET_GERMAN,       /**<Latin german nation sub set*//**<CNcomment:LATIN german*/
+    HI_UNF_TTX_NATION_SET_ITALIAN,      /**<Latin italish nation sub set*//**<CNcomment:LATIN italish*/
+    HI_UNF_TTX_NATION_SET_LETTISH,      /**<Latin lettish lithuanian nation sub set*//**<CNcomment:LATIN lithuanian*/
+    HI_UNF_TTX_NATION_SET_POLISH,       /**<Latin polish nation sub set*//**<CNcomment:LATIN polish*/
+    HI_UNF_TTX_NATION_SET_PORTUGUESE,   /**<Latin portutuese spanish nation sub set*//**<CNcomment:LATIN portutuese/spanish*/
+    HI_UNF_TTX_NATION_SET_RUMANIAN,     /**<Latin rumanian nation sub set*//**<CNcomment:LATIN rumanian*/
+    HI_UNF_TTX_NATION_SET_SERBIAN,      /**<Latin serbian croatian slovenian nation sub set*//**<CNcomment:LATIN serbian/croatian/slovenian*/
+    HI_UNF_TTX_NATION_SET_SWEDISH,      /**<Latin swedish finnish nation sub set*//**<CNcomment:LATIN finnish*/
+    HI_UNF_TTX_NATION_SET_TURKISH,      /**<Latin turkish nation sub set*//**<CNcomment:LATIN turkish*/
+    HI_UNF_TTX_NATION_SET_BUTT          /**<Invalid nation sub Set *//**<CNcomment:*/
+
+}HI_UNF_TTX_NATION_SET_E;
+
+/** Teletext char set *//** CNcomment:Teletext */
+typedef  enum   hiUNF_TTX_CHARSET_E
+{
+    HI_UNF_TTX_CHARSET_G0,  /**<G0  character set *//**<CNcomment:G0  */
+    HI_UNF_TTX_CHARSET_G1,  /**<G1  character set*//**<CNcomment:G1  */
+    HI_UNF_TTX_CHARSET_G2,  /**<G2  character set *//**<CNcomment:G2  */
+    HI_UNF_TTX_CHARSET_G3,  /**<G3  character set *//**<CNcomment:G3  */
+    HI_UNF_TTX_CHARSET_BUTT /**<Invalid  character set *//**<CNcomment: */
+} HI_UNF_TTX_CHARSET_E;
+
+/** DRCS character size *//** CNcomment:DRCS */
+typedef enum hiUNF_TTX_DRCS_SIZE_E
+{
+    HI_UNF_TTX_DRCS_SIZE_NORMAL = 0,  /**<char size is 12*10*//**<CNcomment:12*10*/
+    HI_UNF_TTX_DRCS_SIZE_SMALL = 1,   /**<char size is 6*5*//**<CNcomment:6*5*/
+    HI_UNF_TTX_DRCS_SIZE_BUTT         /**<Invalid char size*//**<CNcomment:*/
+}HI_UNF_TTX_DRCS_SIZE_E;
+
+typedef HI_U32 HI_UNF_TTX_COLOR;
+
+/** Teletext page info *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_PAGEAREA_S
+{
+    HI_U32 u32Row         : 8; /**<The origination  row  number of the area  *//**<CNcomment: */
+    HI_U32 u32Column      : 8; /**<The origination  column  number of the area *//**<CNcomment: */
+    HI_U32 u32RowCount    : 8; /**<The count of row the area covers *//**<CNcomment: */
+    HI_U32 u32ColumnCount : 8; /**<The count of column  the area covers *//**<CNcomment: */
+} HI_UNF_TTX_PAGEAREA_S;
+
+/** Teletext char attribute *//** CNcomment:Teletext */
+typedef  struct  hiUNF_TTX_CHARATTR_S
+{
+    HI_U32               u32Index    : 8; /**<Index of a char in a character set *//**<CNcomment: */
+    HI_BOOL              bContiguous : 1; /**<Contiguous mosaic char or not *//**<CNcomment: */
+    HI_UNF_TTX_G0SET_E   enG0Set     : 3; /**<G0 Primary Set  , latin , arabic .... *//**<CNcomment:G0 */
+    HI_UNF_TTX_G2SET_E   enG2Set     : 3;  /**<G2 set ,latin, cyrillic, greek, arabic*//**<CNcomment:G2*/
+    HI_UNF_TTX_CHARSET_E enCharSet   : 3; /**<Character set  , G0 ,  G1  ....*//**<CNcomment: */
+    HI_U32               u8NationSet : 6; /**<Latin National  subset,  English ,French,  German .... *//**<CNcomment: */
+    HI_U32               u8Reserved  : 8; /**<Reserved *//**<CNcomment: */
+} HI_UNF_TTX_CHARATTR_S;
+
+/** The info of draw char *//** CNcomment: */
+typedef struct hiUNF_TTX_DRAWCAHR_S
+{
+    HI_UNF_TTX_CHARATTR_S  * pstCharAttr;   /**<Character attribution, it can decide the position of a char in  a  font */
+                                            /**<CNcomment: */
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea;    /**<Area of character in page *//**<CNcomment: */
+    HI_UNF_TTX_COLOR        u32Foreground;  /**<Foreground color *//**<CNcomment: */
+    HI_UNF_TTX_COLOR        u32Background;  /**<Background color *//**<CNcomment: */
+} HI_UNF_TTX_DRAWCAHR_S;
+
+/** The info of draw DRCS character *//** CNcomment:DRCS */
+typedef struct hiUNF_TTX_DRAWDRCSCHAR_S
+{
+    HI_UNF_TTX_PAGEAREA_S  *pstPageArea;      /**<Area of character in page *//**<CNcomment: */
+    HI_UNF_TTX_COLOR       u32Background;     /**<Background color *//**<CNcomment: */
+    HI_UNF_TTX_COLOR*      pu32DRCSColorInfo; /**<color info of DRCS char,which define the color value of  every pixel in a DRCS char*/
+                                              /**<CNcomment:DRCSDRCS*/
+    HI_UNF_TTX_DRCS_SIZE_E enDRCSSize;        /**<size of DRCS char,normal is 12*10,and small is 6*5*//**<CNcomment:DRCS12*10,6*5 */
+}HI_UNF_TTX_DRAWDRCSCHAR_S;
+
+
+/** The filled area *//** CNcomment: */
+typedef struct hiUNF_TTX_FILLRECT_S
+{
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea; /**<Destination rectangle  *//**<CNcomment: */
+    HI_UNF_TTX_COLOR        u32Color;    /**<Color *//**<CNcomment: */
+} HI_UNF_TTX_FILLRECT_S;
+
+/** Refreshed layer *//** CNcomment: */
+typedef struct hiUNF_TTX_REFRESHLAYER_S
+{
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea; /**<Destination rectangle  *//**<CNcomment:(HI_UNF_TTX_BUFFER_PARAM_S *)  */
+} HI_UNF_TTX_REFRESHLAYER_S;
+
+/** Teletext Buffer info *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_BUFFER_PARAM_S
+{
+    HI_U32 u32Row     : 8; /**<The row number of buffer page*//**<CNcomment: */
+    HI_U32 u32Column  : 8; /**<The column  number of buffer page*//**<CNcomment: */
+    HI_U32 u8Reserved : 16;/**<Reserved *//**<CNcomment: */
+} HI_UNF_TTX_BUFFER_PARAM_S;
+
+/** The set of callback cmd *//** CNcomment: */
+typedef enum hiUNF_TTX_CB_E
+{
+    HI_UNF_TTX_CB_TTX_TO_APP_MSG, /**<Send message to GUI pthread *//**<CNcomment:GUI */
+    HI_UNF_TTX_CB_APP_FILLRECT,   /**<(HI_UNF_TTX_FILLRECT_S *) Fill rectangle *//**<CNcomment:(HI_UNF_TTX_FILLRECT_S *) */
+    HI_UNF_TTX_CB_APP_DRAWCHAR,   /**<(HI_UNF_TTX_DRAWCAHR_S*)Select a char from a specified font and draw it  in specified rectangle of OSD by specified foreground and background */
+                                  /**<CNcomment:(HI_UNF_TTX_DRAWCAHR_S*) OSD */
+    HI_UNF_TTX_CB_APP_DRAWDRCSCHAR,/**<(HI_UNF_TTX_DRAWDRCSCHAR_S*)draw a DRCS char which specified by the color of every pixel*//**<CNcomment:DRCS*/
+    HI_UNF_TTX_CB_APP_REFRESH,    /**<(HI_UNF_TTX_REFRESHLAYER_S*) Refresh layer *//**<CNcomment:(HI_UNF_TTX_REFRESHLAYER_S*)  */
+    HI_UNF_TTX_CB_CREATE_BUFF,    /**<(HI_UNF_TTX_BUFFER_PARAM_S *) Create buffer *//**<CNcomment:(HI_UNF_TTX_BUFFER_PARAM_S *)  */
+    HI_UNF_TTX_CB_DESTROY_BUFF,   /**<Destroy buffer *//**<CNcomment: */
+    HI_UNF_TTX_CB_GETPTS,         /**<(HI_S64 *) Get the PTS of the stream *//**<CNcomment:(HI_S64 *) PTS */
+    HI_UNF_TTX_CB_BUTT            /**<Invalid callback type*//**<CNcomment: */
+} HI_UNF_TTX_CB_E;
+
+typedef enum hiUNF_TTX_PACKET_TYPE_E
+{
+    HI_UNF_TTX_PACKET_TYPE_PES,  /**<ETSI EN DVB 300472 teletext syntax data packets, including PES header information*//**<CNcomment:ETSI EN 300472 DVB teletext,PES*/
+    HI_UNF_TTX_PACKET_TYPE_RAW,   /**<ETSI EN DVB 300706 teletext syntax data packets, not including PES header information*//**<CNcomment:ETSI EN 300706 DVB teletext,PES*/
+    HI_UNF_TTX_PACKET_TYPE_BUTT,
+}HI_UNF_TTX_PACKET_TYPE_E;
+
+/** Callback function *//** CNcomment: */
+typedef HI_S32 (*HI_UNF_TTX_CB_FN)(HI_HANDLE hTTX, HI_UNF_TTX_CB_E enCB, HI_VOID *pvCBParam);
+
+
+typedef enum hiUNF_TTX_LEVEL_E
+{
+    HI_UNF_TTX_LEVEL_1_5 = 0, /**<TTX Level 1.5 *//**<CNcomment:TTX 1.5  */
+    HI_UNF_TTX_LEVEL_2_5 = 1, /**<TTX Level 2.5*//**<CNcomment:TTX 2.5  */
+    HI_UNF_TTX_LEVEL_3_5 = 2, /**<TTX Level 3.5*//**<CNcomment:TTX 3.5  */
+    HI_UNF_TTX_LEVEL_BUTT     /**<Invalid TTX Level*//**<CNcomment:TTX  */
+}HI_UNF_TTX_LEVEL_E;
+
+/** Teletext Init param *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_INIT_PARA_S
+{
+    HI_U8 *pu8MemAddr;       /**<The address of memory, If  0, malloc the memory in the module, Otherwise malloced outside the module */
+                             /**<CNcomment:0  */
+    HI_U32 u32MemSize;       /**<The size of memory,  If  0, the size decided in the module, Otherwise decided outside the module */
+                             /**<CNcomment:0  */
+
+    HI_UNF_TTX_LEVEL_E  enTtxLevel; /**<TTX level*//**<CNcomment:TTX  */
+
+    HI_UNF_TTX_CB_FN pfnCB;  /**<Callback function *//**<CNcomment: */
+    HI_BOOL          bFlash; /**<Permit flash or not *//**<CNcomment: */
+    HI_BOOL          bNavigation; /**<Permit navigation bar *//**<CNcomment: */
+} HI_UNF_TTX_INIT_PARA_S;
+
+/** Teletext page address *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_PAGE_ADDR_S
+{
+    HI_U8  u8MagazineNum;  /**<Magazine number *//**<CNcomment: */
+    HI_U8  u8PageNum;      /**<Page number *//**<CNcomment: */
+    HI_U16 u16PageSubCode; /**<Page sub-code *//**<CNcomment: */
+} HI_UNF_TTX_PAGE_ADDR_S;
+
+/** Teletext content param *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_CONTENT_PARA_S
+{
+    HI_UNF_TTX_TYPE_E      enType; /**<Teletext content type *//**<CNcomment:Teletext */
+    HI_U32                         u32ISO639LanCode;/**<teletext iso639  language code*//**<CNcomment:Teletext  iso639*/
+    HI_UNF_TTX_PAGE_ADDR_S stInitPgAddr; /**<Init page address, if Magazine number or Page number be equal to 0xFF,set to 100th page.sub-page numbet default  0*/
+                                         /**<CNcomment:0xff1000 */
+} HI_UNF_TTX_CONTENT_PARA_S;
+
+/** Teletext checked param *//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_CHECK_PARAM_S
+{
+    HI_UNF_TTX_PAGE_ADDR_S stPageAddr; /**<page address*//**<CNcomment:  */
+    HI_BOOL                bSucceed;   /**<success or failure*//**<CNcomment: */
+} HI_UNF_TTX_CHECK_PARAM_S;
+
+/** Get page address*//** CNcomment:Teletext */
+typedef struct hiUNF_TTX_GETPAGEADDR_S
+{
+    HI_UNF_TTX_PAGE_TYPE_E enPageType; /**<page type *//**<CNcomment: */
+    HI_UNF_TTX_PAGE_ADDR_S stPageAddr; /**<page address *//**<CNcomment:*/
+} HI_UNF_TTX_GETPAGEADDR_S;
+
+/** Teletext raw data*//** CNcomment:ttx */
+typedef struct hiUNF_TTX_RAWDATA_S
+{
+    HI_U32 u32ValidLines; /**<bit-field lines  0..31 *//**<CNcomment: */
+    HI_U8  au8Lines[HI_UNF_TTX_MAX_LINES][HI_UNF_TTX_LINE_SIZE]; /**<line data *//**<CNcomment:ttx */
+} HI_UNF_TTX_RAWDATA_S;
+
+/** Callback function in which notified raw data to consumer *//** CNcomment:ttx */
+typedef HI_S32 (*HI_UNF_TTX_REQUEST_CALLBACK_FN)(HI_UNF_TTX_RAWDATA_S *pstRawData);
+
+/** Request teletext raw data*//** CNcomment:ttx */
+typedef struct hiUNF_TTX_REQUEST_RAWDATA_S
+{
+    HI_UNF_TTX_RAWDATA_S *pstRawData;  /**<raw data address*//**<CNcomment: */
+    HI_UNF_TTX_REQUEST_CALLBACK_FN pfnRequestCallback; /**<Callback function *//**<CNcomment: */
+} HI_UNF_TTX_REQUEST_RAWDATA_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/********************************API declaration********************************/
+/** \addtogroup      Teletext  */
+/** @{ */  /** <!-- [Teletext] */
+
+/**
+\brief     Initializes  TTX  module. CNcomment:TTXCNend
+\attention \n
+none.
+\retval ::HI_SUCCESS     success. CNcomment:CNend
+\retval ::HI_FAILURE     failure. CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Init(HI_VOID);
+
+/**
+\brief  Deinitializes TTX module. CNcomment:TTXCNend
+\attention \n
+none.
+\retval ::HI_SUCCESS     success. CNcomment:CNend
+\retval ::HI_FAILURE     failure. CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_DeInit(HI_VOID);
+
+/**
+\brief  Create a TTX instance, just support for a single  instance for the moment.  CNcomment:TTXCNend
+\attention \n
+After creating a instance  successfully, the instance  default  to be enable , decode and be
+prepared to display teletext. Call  correspond interface to display teletext.
+CNcomment:enableteletextCNend
+\param[in]  pstInitParam  Initialized  parameter. CNcomment:CNend
+\param[out] phTTX         Teletext instance. CNcomment:TeletextCNend
+\retval ::HI_SUCCESS      success.  CNcomment:CNend
+\retval ::HI_FAILURE      failure.  CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Create(HI_UNF_TTX_INIT_PARA_S* pstInitParam, HI_HANDLE* phTTX);
+
+/**
+\brief    Destory  a  teletext instance.  CNcomment:TTXCNend
+\attention \n
+none.
+\param[in] hTTX        Teletext instance. CNcomment:TeletextCNend
+\retval ::HI_SUCCESS   success.  CNcomment:CNend
+\retval ::HI_FAILURE   failure.  CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Destroy(HI_HANDLE hTTX);
+
+/**
+\brief   Inject the teletext PES data . CNcomment:Teletext PES CNend
+\attention \n
+none.
+\param[in] hTTX    Teletext instance. CNcomment:TeletextCNend
+\param[in] pu8Data   Address of data. CNcomment:CNend
+\param[in] u32DataSize  the length of data. CNcomment:CNend
+\retval ::HI_SUCCESS    success.  CNcomment:CNend
+\retval ::HI_FAILURE    failure.  CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_InjectData(HI_HANDLE hTTX, HI_U8 *pu8Data, HI_U32 u32DataSize);
+
+/**
+\brief   Reset data. CNcomment:CNend
+\attention \n
+none.
+\param[in] hTTX   Teletext instance. CNcomment:TeletextCNend
+\retval ::HI_SUCCESS    success.  CNcomment:CNend
+\retval ::HI_FAILURE    failure.  CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_ResetData(HI_HANDLE hTTX);
+
+/**
+\brief  Set the initial page address of teletext. CNcomment:TeletextCNend
+\attention \n
+none.
+\param[in] hTTX   Teletext instance. CNcomment:TeletextCNend
+\param[in] pstContentParam  context  parameter.  CNcomment:CNend
+\retval ::HI_SUCCESS    success. CNcomment:CNend
+\retval ::HI_FAILURE    failure. CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_SwitchContent (HI_HANDLE hTTX, HI_UNF_TTX_CONTENT_PARA_S* pstContentParam);
+
+/**
+\brief  All operation related to OSD. CNcomment:OSDCNend
+\attention \n
+none.
+\param[in] hTTX    Teletext instance.   CNcomment:TeletextCNend
+\param[in] enMsgAction  Action of the message.  CNcomment:CNend
+\retval ::HI_SUCCESS    success.   CNcomment:CNend
+\retval ::HI_FAILURE    failure.   CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Display(HI_HANDLE hTTX, HI_HANDLE hDispalyHandle);
+
+/**
+\brief   Enable  or disable teletext output, and set the type of output.
+CNcomment:teletextCNend
+\attention \n
+ The parameter can be reset  time after time.   CNcomment: CNend
+\param[in] hTTX        Teletext instance.     CNcomment:TeletextCNend
+\param[in]enOutput     Output  type: OSD,VBI or OSD  VBI dual output.   CNcomment::OSD / VBI /OSD-VBICNend
+\param[in] bEnable       HI_TRUE: enable,  HI_FALSE: disable.   CNcomment:HI_TRUE: HI_FALSE: CNend
+\retval ::HI_SUCCESS      success.  CNcomment:CNend
+\retval ::HI_FAILURE      failure.  CNcomment:CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Output (HI_HANDLE hTTX, HI_UNF_TTX_OUTPUT_E enOutput, HI_BOOL bEnable);
+
+/**
+\brief     The function  of TTX instance to handle user's operation.  CNcomment:TTXCNend
+\attention \n
+none.
+\param[in] hTTX     Teletext instance.   CNcomment:TeletextCNend
+\param[in] enCMD      Type of command.   CNcomment:CNend
+\param[in] pvCMDParam     Parameter of  command(The parameter must be  conveted to appropriate  type at every
+ specifical application), when the command is UPDATE or EXIT, the command can be NULL.
+ CNcomment:()UPDATE/EXITNULLCNend
+\param[out] pvCMDParam    Parameter of command , when the command is  GETPAGEADDR, it points to the address of specifical  pages.
+ CNcomment:GETPAGEADDRCNend
+\retval ::HI_SUCCESS    success.  CNcomment:CNend
+\retval ::HI_FAILURE    failure.  CNcomment:CNend
+\see \n
+ Please  consult  the definition of  HI_UNF_TTX_CMD_E.  CNcomment:HI_UNF_TTX_CMD_ECNend
+*/
+HI_S32 HI_UNF_TTX_ExecCmd(HI_HANDLE hTTX,
+                          HI_UNF_TTX_CMD_E enCMD, HI_VOID *pvCMDParam);
+
+/**
+\brief  Setting teletext language of region.
+CNcomment:CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTXCNend
+\param[in] pu8Language language code.
+CNcomment: CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetLanguage(HI_HANDLE hTTX, HI_U8* pu8Language);
+
+/**
+\brief  Setting max interval time of the teletext.
+CNcomment:CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTXCNend
+\param[in] u32IntervalMs max interval of teletext, unit is Millisecondes.
+CNcomment:msCNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetMaxInterval(HI_HANDLE hTTX, HI_U32 u32IntervalMs );
+
+/**
+\brief  Setting teletext packet type.
+CNcomment:CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTXCNend
+\param[in] enPacketType the type of teletext packet
+CNcomment:CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetPacketType (HI_HANDLE hTTX, HI_UNF_TTX_PACKET_TYPE_E enPacketType);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_venc.h b/xbmc/platform/linux/hisi/hi_unf_venc.h
new file mode 100644
index 0000000000..6275b1386e
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_venc.h
@@ -0,0 +1,570 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_venc.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2010/04/07
+  Description   :
+  History       :
+  1.Date        : 2010/04/07
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/** 
+ * \file
+ * \brief Describes the information about video encoding (VENC). CNcomment: VENC CNend
+ */
+
+#ifndef  __HI_UNF_VENC_H__
+#define  __HI_UNF_VENC_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+#define HI_UNF_VENC_TYPE_NUM 3
+
+/********************************Struct Definition********************************/
+/** \addtogroup      VENC */
+/** @{ */  /** <!-- VENC */
+
+/**H.264 NALU type*/
+/**CNcomment: H.264NALU */
+typedef enum hiUNF_H264E_NALU_TYPE_E
+{
+    HI_UNF_H264E_NALU_PSLICE = 1,       /**<P slice NALU*/ 
+    HI_UNF_H264E_NALU_ISLICE = 5,       /**<I slice NALU*/ 
+    HI_UNF_H264E_NALU_SEI = 6,          /**<SEI NALU*/ 
+    HI_UNF_H264E_NALU_SPS = 7,          /**<SPS NALU*/
+    HI_UNF_H264E_NALU_PPS = 8,          /**<PPS NALU*/ 
+    HI_UNF_H264E_NALU_BUTT
+} HI_UNF_H264E_NALU_TYPE_E;
+
+/**H.263 NALU type*/
+/**CNcomment: H.263NALU */
+typedef enum hiUNF_H263E_PACK_TYPE_E
+{
+    HI_UNF_H263E_NALU_PSLICE = 1,       /**<P slice NALU*/
+    HI_UNF_H263E_NALU_ISLICE = 5,       /**<I slice NALU*/
+    HI_UNF_H263E_NALU_SEI = 6,          /**<SEI NALU*/
+    HI_UNF_H263E_NALU_SPS = 7,          /**<SPS NALU*/
+    HI_UNF_H263E_NALU_PPS = 8,          /**<PPS NALU*/
+    HI_UNF_H263E_NALU_BUTT
+} HI_UNF_H263E_PACK_TYPE_E;
+
+/**MPEG4 package type*/
+/**CNcomment: MPEG4 */
+typedef enum hiUNF_MPEG4E_PACK_TYPE_E
+{
+    HI_UNF_MPEG4E_PACK_VO    = 1,          /**<VO package*/ /**<CNcomment: VO */
+    HI_UNF_MPEG4E_PACK_VOS   = 2,         /**<VOS package*/ /**<CNcomment: VOS */
+    HI_UNF_MPEG4E_PACK_VOL   = 3,         /**<VOL package*/ /**<CNcomment: VOL */
+    HI_UNF_MPEG4E_PACK_VOP   = 4,         /**<VOP package*/ /**<CNcomment: VOP */
+    HI_UNF_MPEG4E_PACK_SLICE = 5        /**<Slice package*/ /**<CNcomment: SLICE */
+} HI_UNF_MPEG4E_PACK_TYPE_E;
+
+/**HEVC NALU type*/
+/**CNcomment: HEVC NALU */
+typedef enum hiUNF_HEVCE_NALU_TYPE_E
+{
+    HI_UNF_HEVCE_NALU_PSLICE = 1,    /**<P slice NALU*/
+    HI_UNF_HEVCE_NALU_ISLICE,        /**<I slice NALU*/
+    HI_UNF_HEVCE_NALU_VPS,           /**<VPS NALU*/
+    HI_UNF_HEVCE_NALU_SPS,           /**<SPS NALU*/
+    HI_UNF_HEVCE_NALU_PPS,           /**<PPS NALU*/
+    HI_UNF_HEVCE_NALU_SEI,           /**<SEI NALU*/
+    HI_UNF_HEVCE_NALU_BUTT
+} HI_UNF_HEVCE_NALU_TYPE_E;
+
+/*VENC Rate Control Type*/
+/**CNcomment: */
+typedef enum hiUNF_VENC_RATECONTROL_TYPE_E
+{
+    HI_UNF_VENC_RATECONTROL_TYPE_CBR,
+    HI_UNF_VENC_RATECONTROL_TYPE_AVBR,
+    HI_UNF_VENC_RATECONTROL_TYPE_BUTT
+} HI_UNF_VENC_RATECONTROL_TYPE_E;
+
+/**Defines the source of input frame rate.*/
+/**CNcomment:  */
+typedef enum hiUNF_VENC_FRMRATE_TYPE_E
+{
+    HI_UNF_VENC_FRMRATE_TYPE_AUTO,         /**<Use the frame rate calculates from real-time statistics */ /**<CNcomment:*/
+    HI_UNF_VENC_FRMRATE_TYPE_STREAM,       /**<Use the frame rate comes from stream*/ /**<CNcomment:  */
+    HI_UNF_VENC_FRMRATE_TYPE_USER,         /**<Use the frame rate set by user*/ /**<CNcomment:  */
+    HI_UNF_VENC_FRMRATE_TYPE_BUTT
+}HI_UNF_VENC_FRMRATE_TYPE_E;
+
+/**Data type of the Encoder*/
+/**CNcomment:  */
+typedef union hiUNF_VENC_DATA_TYPE_U
+{
+    HI_UNF_H264E_NALU_TYPE_E   enH264EType;	/**<H.264 encoding data*/ /**<CNcomment: h264*/
+    HI_UNF_H263E_PACK_TYPE_E   enH263EType;	/**<H.263 encoding data*/ /**<CNcomment: h263*/
+    HI_UNF_MPEG4E_PACK_TYPE_E  enMPEG4EType;    /**<MPEG4 encoding data*/ /**<CNcomment: MPEG4*/
+    HI_UNF_HEVCE_NALU_TYPE_E   enHEVCEType;     /**<HEVC encoding data*/ /**<CNcomment: HEVC*/
+}HI_UNF_VENC_DATA_TYPE_U;
+
+/*Output stream attributes structure*/
+/**CNcomment:  */
+typedef struct hiVENC_STREAM_S
+{
+    HI_U8                   *pu8Addr ;       /**<Stream virtual address*/ /**<CNcomment: */
+    HI_U32                  u32SlcLen;      /**<Stream length*/ /**<CNcomment: */
+    HI_U32                  u32PtsMs;        /**<Presentation time stamp (PTS), in ms*/ /**<CNcomment: */
+    HI_BOOL                 bFrameEnd;       /**<Frame end or not*/ /**<CNcomment: */
+    HI_UNF_VENC_DATA_TYPE_U enDataType;      /**Encoding data type*/ /**<CNcomment: */
+}HI_UNF_VENC_STREAM_S;
+
+/*Coding channal attributes structure*/
+/**CNcomment:  */
+typedef struct hiUNF_VENC_CHN_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVencType;	      /**<Encoder type*/ /**<CNcomment:  */
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;       /**<Encoder level*/ /**<CNcomment:  */
+    HI_UNF_H264_PROFILE_E       enVencProfile;    /**<H264 Profile of Encoder,it is just valid for H264 Encoder*/ /**<CNcomment: H264H264*/
+    HI_U32                      u32Width;         /**<Width, 4-byte aligned. The width can be configured dynamically in the limit of encoder level.*/
+                                                  /**<CNcomment: ,4, */
+    HI_U32                      u32Height;        /**<Height, 4-byte aligned.The height can be configured dynamically in the limit of encoder level.*/
+                                                  /**<CNcomment: ,4, */
+    HI_U32                      u32StrmBufSize;   /**<Stream buffer size, the value ranges from 32*1024 to 40*1024*1024.You'd better set larger streamBufferSize if you set larger target bitrate or Qlevel.*/
+                                                  /**<CNcomment: buffer,buffer32x102440x1024x1024JPEGbuffer*/
+    HI_U32                      u32RotationAngle; /**<Rotation angle. This parameter cannot be set.It must be set to 0.*/ /**<CNcomment: ,,0*/
+    HI_BOOL                     bSlcSplitEn;      /**<Slice split enable,it is just valid for H264 Encoder*/ /**<CNcomment: slice,H264*/
+                                                  /**<CNcomment: JPGEMCU,H264MP4, H263 */
+    HI_U32                      u32TargetBitRate; /**<RC parameter for the VENC,it is just valid for H264 Encoder. It can be set dynamically.Some reference values as follows:above 5M for 1080P,above 3M for 720P, about 2M for D1*/
+                                                   /**<CNcomment: VencRC,H264.:1080P5M720P3MD12M*/
+    HI_U32                      u32TargetFrmRate; /**<Target frame rate. It can be set dynamically.*/         /**<CNcomment: , */
+    HI_U32                      u32InputFrmRate;  /**<Input frame rate. It can be set dynamically. The value of u32TargetFrmRate is less than or equal to the value of u32InputFrmRate.
+                                                   ** Attention the if in the mode of attach source to encode the InputFrmRate which set by user is in vain.*/
+                                                  /**<CNcomment: ,,u32TargetFrmRate <= u32InputFrmRate ,*/
+    HI_U32                      u32Gop;           /**<GOP size,it is just valid for H264 Encoder. It can be set dynamically.*/ /**<CNcomment: GOP,H264 */
+    HI_U32                      u32MaxQp;         /**<The maximum quantization parameter,it is just valid for H264 Encoder. It can be set dynamically.*/    /**<CNcomment: ,H264*/
+    HI_U32                      u32MinQp;         /**<The minimum quantization parameter,it is just valid for H264 Encoder. It can be set dynamically.*/    /**<CNcomment: ,H264*/
+    HI_BOOL                     bQuickEncode;     /**<Quick Encode Mode enable*/ /**<CNcomment:*/
+    HI_U8                       u8Priority;       /**<the Priority Level of the channal,should between 0 to the max num of channel minus 1.It can be set dynamically.*/
+                                                  /**<CNcomment: 0~-1,*/
+    HI_U32                      u32Qlevel;        /**<The value ranges from 1 to 99 for the JPGE, it is just valid for JPEG Encoder.*/ /**<CNcomment: JPGE1-99JPEG */
+    HI_U32                      u32DriftRateThr;  /**<Encoder bitrate fluctuation threshold.If u32DriftRateThr = 20 means the fluctuation of threshold is 20%*/
+                                                  /**<CNcomment: 2020%*/
+
+    HI_U32                      u32SplitSize;     /**<Split size. The size is in the unit of minimum coded unit (MCU) for the JPEG format and byte for the MP4 format. The split size can be ignored in H.263 format.*/
+}HI_UNF_VENC_CHN_ATTR_S;
+
+/*VENC Capability Information Of One Resolution*/
+/**CNcomment: */
+typedef struct hiUNF_VENC_CAP_RESO_S
+{
+    HI_UNF_VCODEC_CAP_LEVEL_E enCapLevel;       /**<support max enCapLevel*//**<CNcomment:  */
+    HI_U32  u32Height;                          /**<support max height*//**<CNcomment:  */
+    HI_U32  u32Width;                           /**<support min height*//**<CNcomment:  */
+    HI_U32  u32MaxFrmRate;                      /**<support max frame rate*//**<CNcomment:  */
+    HI_U32  u32MaxBitRate;                      /**<support max bit rate*//**<CNcomment: */
+    HI_U32  u32MinBitRate;                      /**<support min bit rate*//**<CNcomment: */
+    HI_U32  u32MinBufSize;                      /**<support min stream buffer size*//**<CNcomment: buffer*/
+}HI_UNF_VENC_CAP_RESO_S;
+
+/*VENC Capability Information Of One Encode Type*/
+/**CNcomment: */
+typedef struct hiUNF_VENC_CAP_INFO_S
+{
+    HI_UNF_VCODEC_TYPE_E   enCodecType;         /**<support venc type*//**<CNcomment: */
+    HI_U32                 u32MaxChnNum;        /**<support max channel num*//**<CNcomment: */
+    HI_UNF_VENC_CAP_RESO_S stMaxReso;           /**<support capability information of max resolution*//**<CNcomment: */
+    HI_UNF_VENC_CAP_RESO_S stMinReso;           /**<support capability information of min resolution*//**<CNcomment: */
+}HI_UNF_VENC_CAP_INFO_S;
+
+/*VENC Capability Information*/
+/**CNcomment: */
+typedef struct hiUNF_VENC_CAP_S
+{
+    HI_U32                 u32SupportTypeNum;                   /**<support venc type num*//**<CNcomment:  */
+    HI_UNF_VENC_CAP_INFO_S stCapInfo[HI_UNF_VENC_TYPE_NUM];     /**<capability information for venc types*//**<CNcomment:  */
+}HI_UNF_VENC_CAP_S;
+
+/** @} */  /** <!-- ==== Struct Definition End ==== */
+
+
+/********************************API declaration********************************/
+/** \addtogroup      VENC */
+/** @{ */  /** <!-- VENC */
+
+/** 
+\brief Initializes the video encoder. CNcomment:  CNend
+\attention \n
+Before using the VENC, you must call this API. CNcomment: VENC CNend
+\param[in] N/A CNcomment:  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_DEV_NOT_EXIST No VENC device exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NOT_DEV_FILE The file is not a VENC file. CNcomment:  CNend
+\retval ::HI_ERR_VENC_DEV_OPEN_ERR The VENC device fails to start. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_Init(HI_VOID);
+
+
+/** 
+\brief Deinitializes the video encoder. CNcomment:  CNend
+\attention \n
+N/A CNcomment:  CNend
+\param[in] N/A CNcomment:  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_DEV_CLOSE_ERR The video encoder fails to stop. CNcomment:  CNend
+\see \n
+N/A CNcomment:   CNend
+*/
+HI_S32 HI_UNF_VENC_DeInit(HI_VOID);
+
+
+/** 
+\brief Obtains the default attributes of a VENC channel. CNcomment:  CNend
+\attention \n
+By default, the encoding size is D1, encoding format is H.264, and a frame is a slice.
+CNcomment: D1H.264Slice CNend
+\param[out] pstAttr Pointer to the attributes of a VENC channel. CNcomment: pstAttr  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The input pointer parameter is null. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_GetDefaultAttr(HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Creates a VENC channel. CNcomment:  CNend
+\attention \n
+You must create a VENC channel before video encoding. 
+CNcomment:  CNend
+\param[in] pstAttr Pointer to the attributes of a VENC channel. CNcomment: pstAttr  CNend
+\param[out] phVenc Pointer to the handle of a VENC channel. CNcomment: phVenc  CNend
+\retval ::HI_SUCCESS Success CNcomment:   CNend
+\retval ::HI_ERR_VENC_NULL_PTR The input pointer parameter is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_CREATE_ERR The number of VENC channels exceeds the limit. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A
+CNcomment:   CNend
+*/
+HI_S32 HI_UNF_VENC_Create(HI_HANDLE *phVenc,const HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Destroys a VENC channel. CNcomment:  CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel. CNcomment: CNcomment: hVenc  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:   CNend
+*/
+HI_S32 HI_UNF_VENC_Destroy(HI_HANDLE hVenc);
+
+
+/** 
+\brief Attaches a VENC channel to the video source. CNcomment:  CNend
+\attention \n
+You must call this API before performing encoding and obtaining streams. CNcomment:  CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] hSrc Data source handle CNcomment: hSrc  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The video source is invalid. CNcomment:   CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_AttachInput(HI_HANDLE hVenc,HI_HANDLE hSrc);
+
+
+/** 
+\brief Detaches a VENC channel from the video source. CNcomment:  CNend
+\attention \n
+You must stop encoding before calling this API.
+CNcomment:  CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\retval ::HI_SUCCESS Success CNcomment:   CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The video source is invalid. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT Invalid state which the video encoder does not stop encoding. CNcomment: , CNend
+\retval ::HI_ERR_VENC_CHN_NO_ATTACH The VENC channel doesn't attach any source. CNcomment:  CNend
+\see \n
+N/A CNcomment:   CNend
+*/
+HI_S32 HI_UNF_VENC_DetachInput(HI_HANDLE hVencChn);
+
+
+/** 
+\brief Starts to perform encoding. CNcomment:  CNend
+\attention \n
+You must initialize the video encoder, create a VENC channel, and attach the channel to the video source before calling this API.
+CNcomment:  CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_Start(HI_HANDLE hVenc);
+
+
+/** 
+\brief Stops encoding. CNcomment:  CNend
+\attention \n
+You must initialize the video encoder, create a VENC channel, attach the channel to the video source, and start to perform encoding before calling this API.
+CNcomment:  CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_Stop(HI_HANDLE hVenc);
+
+/** 
+\brief Obtains VENC streams. CNcomment:  CNend
+\attention \n
+You must attach a VENC channel to the video source and start to perform encoding before calling this API.
+The block time (in ms) is configurable. If u32TimeOutMs is set to 0, the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait. \n
+If the block time is reached but no data is received, ::HI_ERR_VENC_BUF_EMPTY is returned.\n
+If the wait time is 0 and there is no data, ::HI_ERR_VENC_BUF_EMPTY is returned.
+CNcomment: 
+00xffffffff\n
+::HI_ERR_VENC_BUF_EMPTY\n
+0::HI_ERR_VENC_BUF_EMPTY\n CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[out] pstStream Pointer to the structure for storing streams CNcomment: pstStream  CNend
+\param[in] u32TimeoutMs: Wait timeout, count in ms CNcomment: u32TimeoutMsms CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The stream pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_BUF_EMPTY Streams fail to be obtained. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_AcquireStream(HI_HANDLE hVenc,HI_UNF_VENC_STREAM_S *pstStream, HI_U32 u32TimeoutMs);
+
+
+/** 
+\brief Releases VENC streams. CNcomment:  CNend
+\attention \n
+You must obtain streams and keep the streams unchanged before calling this API.
+The stream which you get first should be release first.
+CNcomment: 
+ CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] pstStream Pointer to the structure for storing streams CNcomment: pstStream  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The stream pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_RELEASE_ERR Streams fail to be released. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_ReleaseStream(HI_HANDLE hVenc, const HI_UNF_VENC_STREAM_S *pstStream);
+
+
+/** 
+\brief Sets the encoding channel attributes dynamically. CNcomment:  CNend
+\attention \n
+You must create a VENC channel before calling this API.
+This API just can change these attributes as follows:input framerate,target output framerate,target output bitrate,gop,
+max/min QP,channel priority, whether use QuickEncode mode and even the encode width and height within the limits of the encoder level.
+Moreover,even though you can't change the attributes of encoder level,encoder type,Stream buffer size,Rotation angle,Slice split enable and so on,
+you should still assign the real value to them at that time.
+It's better that you should call HI_UNF_VENC_GetAttr() to obtain the attributes of a VENC channel before calling this API.
+CNcomment:  .:GOP/
+ buffer
+HI_UNF_VENC_GetAttr() CNend
+\param[in] Venc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] pstAttr Pointer to the attributes of a VENC channel CNcomment: pstAttr  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NOT_SUPPORT This change of attributes dosen't be supported. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_SetAttr(HI_HANDLE hVenc,const HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Obtains the attributes of a VENC channel. CNcomment:  CNend
+\attention \n
+You must create a VENC channel before calling this API.
+CNcomment:  CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[out] pstAttr Encoding channel attribute CNcomment: pstAttr  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The pointer is null. CNcomment:  CNend
+\see \n 
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_GetAttr(HI_HANDLE hVenc, HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Applies for I frames. CNcomment: I CNend
+\attention \n
+The video encoder encodes an I frame as soon as possible after you call this API.\n
+You can call this API when you set up a video call or fix errors.\n
+If you call this API repeatedly in a short period, I frames may be not generated each time.\n
+CNcomment: I.\n
+.\n
+""II.\n CNend
+\param[in] hVencChn Handle of a VENC channel CNcomment: hVencChn  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_RequestIFrame(HI_HANDLE hVencChn);
+
+
+/** 
+\brief Input frame to VENC. CNcomment:  CNend
+\attention \n
+You must create a VENC channel before calling this API.
+If the venc channel has already attach the source,::HI_ERR_VENC_CHN_INVALID_STAT is returned.
+This API should be matched with the API: HI_UNF_VENC_DequeueFrame.
+HI_UNF_VENC_QueueFrame is used to send frame data to Encoder for user and HI_UNF_VENC_DequeueFrame is used to call the Encoder 
+to receive the frame data which has already be processed.
+CNcomment: .
+HI_ERR_VENC_CHN_INVALID_STAT  
+ HI_UNF_VENC_DequeueFrame 
+HI_UNF_VENC_QueueFrameHI_UNF_VENC_DequeueFrame CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] pstFrameinfo Frame information struct CNcomment:  CNend
+\retval ::HI_SUCCESS                      Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST       No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR            The pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT             The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT    Invalid state which the VENC channel has already attach source. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_QueueFrame(HI_HANDLE hVenc, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+
+/** 
+\brief release frame from VENC. CNcomment:  CNend
+\attention \n
+You must create a VENC channel before calling this API.
+If the venc channel has already attach the source,::HI_ERR_VENC_CHN_INVALID_STAT is returned.
+Refer to the attention of the API: HI_UNF_VENC_QueueFrame.
+If HI_UNF_VENC_DequeueFrame return HI_SUCCESS, it means the corresponding frame buffer could be set free by user. 
+CNcomment: .
+HI_ERR_VENC_CHN_INVALID_STAT  
+ HI_UNF_VENC_QueueFrameHI_UNF_VENC_DequeueFrame CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[out] pstFrameinfo Frame information struct CNcomment:  CNend
+\retval ::HI_SUCCESS                       Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST        No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR             The pointer is null. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT              The video encoder is not initialized. CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT     Invalid state which the VENC channel has already attach source. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_DequeueFrame(HI_HANDLE hVenc, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief get encoding capbility from VENC. CNcomment:  CNend
+\attention \n
+\param[in] N/A CNcomment:  CNend
+\param[out] pstCapability Pointer to the capability of VENC CNcomment: pstCapability  CNend
+\retval ::HI_SUCCESS               Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_NULL_PTR     The pointer is null. CNcomment:  CNend
+\retval ::HI_FAILURE               Capability fail to be obtained. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_GetCapability(HI_UNF_VENC_CAP_S *pstCapability);
+
+/**
+\brief set encoding rate control type of VENC. CNcomment:  CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] enRcType Enum of rate control mode CNcomment: enRcType  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_SetRateControlType(HI_HANDLE hVenc, HI_UNF_VENC_RATECONTROL_TYPE_E enRcType);
+
+
+/**
+\brief get encoding rate control type of VENC. CNcomment:  CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] penRcType Enum of rate control mode CNcomment: enRcType  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_GetRateControlType(HI_HANDLE hVenc, HI_UNF_VENC_RATECONTROL_TYPE_E *penRcType);
+
+/**
+\brief set input frame rate source type of VENC. CNcomment:  CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] enInputFrmRateType Enum of input frame rate mode CNcomment: enInputFrmRateType  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_SetInputFrmRateType(HI_HANDLE hVenc, HI_UNF_VENC_FRMRATE_TYPE_E enInputFrmRateType);
+
+/**
+\brief get input frame rate source type of VENC. CNcomment:  CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc  CNend
+\param[in] penInputFrmRateType Enum of input frame rate control mode CNcomment: enRcType  CNend
+\retval ::HI_SUCCESS Success CNcomment:  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment:  CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment:  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment:  CNend
+\see \n
+N/A CNcomment:  CNend
+*/
+HI_S32 HI_UNF_VENC_GetInputFrmRateType(HI_HANDLE hVenc, HI_UNF_VENC_FRMRATE_TYPE_E *penInputFrmRateType);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif//__HI_UNF_VENC_H__
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_version.h b/xbmc/platform/linux/hisi/hi_unf_version.h
new file mode 100644
index 0000000000..bf79a3356a
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_version.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_version.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2012/12/23
+Last Modified :
+Description   : this file defines the UNF version code.
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_VERSION_H__
+#define __HI_UNF_VERSION_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of UNF version code.                                                                               *
+ * CNcomment: UNF CNend                                                                         *
+ *--------------------------------------------------------------------------------------------------------------*/
+/********************************Struct Definition********************************/
+/** \addtogroup      UNF_VERSION */
+/** @{ */  /** <!-- [UNF_VERSION] */
+
+
+#ifndef UNF_VERSION
+#define UNF_VERSION(major, minor)   (((major) << 8) | (minor))
+#endif
+
+#ifndef UNF_VERSION_CODE
+#define UNF_VERSION_CODE        UNF_VERSION(3, 4)
+#define UNF_SUBVERSION_CODE     0
+#define UNF_PRODUCT_CODE        1
+#endif
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_VERSION_H__ */
+
diff --git a/xbmc/platform/linux/hisi/hi_unf_vi.h b/xbmc/platform/linux/hisi/hi_unf_vi.h
new file mode 100644
index 0000000000..7d637e2564
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_vi.h
@@ -0,0 +1,351 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2010/03/26
+  Description   :
+  History       :
+  1.Date        : 2010/03/26
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about video input (VI). CNcomment: VI CNend
+ */
+
+#ifndef  __HI_UNF_VI_H__
+#define  __HI_UNF_VI_H__
+
+#include "hi_type.h"
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/********************************Macro Definition********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- VI */
+/**Maximum external buffer number*/
+/**CNcomment: VI*/
+#define MAX_VI_EXT_BUF_NUM (16)
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/********************************Struct Definition********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- VI */
+
+/**Input port */
+/**CNcomment:  */
+typedef enum hiUNF_VI_E
+{
+    HI_UNF_VI_PORT0 = 0,      /**<Port 0 *//**<CNcomment: 0*/
+    HI_UNF_VI_PORT1,          /**<Port 1 *//**<CNcomment: 1*/
+    HI_UNF_VI_BUTT
+} HI_UNF_VI_E;
+
+/**Input interface mode */
+/**CNcomment:  */
+typedef enum hiUNF_VI_INPUT_MODE_E
+{
+    HI_UNF_VI_MODE_BT656_576I = 0,  /**<ITU-R BT.656 YUV4:2:2 standard, 576I *//**<CNcomment: ITU-R BT.656 YUV4:2:2 576I */
+    HI_UNF_VI_MODE_BT656_480I,      /**<ITU-R BT.656 YUV4:2:2 standard, 480I *//**<CNcomment: ITU-R BT.656 YUV4:2:2 480I */
+    HI_UNF_VI_MODE_BT601_576I,      /**<ITU-R BT.601 YUV4:2:2 standard, 576I *//**<CNcomment: ITU-R BT.601 YUV4:2:2  */
+    HI_UNF_VI_MODE_BT601_480I,      /**<ITU-R BT.601 YUV4:2:2 standard, 480I *//**<CNcomment: ITU-R BT.601 YUV4:2:2  */
+    HI_UNF_VI_MODE_BT1120_640X480P, /**<ITU-R BT.1120 YUV4:2:2 standard, 480P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 640x480P */
+    HI_UNF_VI_MODE_BT1120_480P,     /**<ITU-R BT.1120 YUV4:2:2 standard, 480P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 720x480P */
+    HI_UNF_VI_MODE_BT1120_576P,     /**<ITU-R BT.1120 YUV4:2:2 standard, 576P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 720x576P */
+    HI_UNF_VI_MODE_BT1120_720P_50,  /**<ITU-R BT.1120 YUV4:2:2 standard, 720P_50 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 720P_50 */
+    HI_UNF_VI_MODE_BT1120_720P_60,  /**<ITU-R BT.1120 YUV4:2:2 standard, 720P_60 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 720P_60 */
+    HI_UNF_VI_MODE_BT1120_1080I_50, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080I_50 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080I_50 */
+    HI_UNF_VI_MODE_BT1120_1080I_60, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080I_60 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080I_60 */
+    HI_UNF_VI_MODE_BT1120_1080P_25, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080P_25 */
+    HI_UNF_VI_MODE_BT1120_1080P_30, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080P_30 */
+    HI_UNF_VI_MODE_BT1120_1080P_50, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080P_50 */
+    HI_UNF_VI_MODE_BT1120_1080P_60, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 1080P_60 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_480P_30,    /**<Digital camera. The data format can be RGB or YCbCr,480P_30*//**<CNcomment:RGBYCbCr480P_30 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_576P_30,    /**<Digital camera. The data format can be RGB or YCbCr,576P_30 *//**<CNcomment:RGBYCbCr576P_30*/
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_720P_30,    /**<Digital camera. The data format can be RGB or YCbCr,720P_30 *//**<CNcomment:RGBYCbCr720P_30 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_1080P_30,   /**<Digital camera. The data format can be RGB or YCbCr,1080P_30 *//**<CNcomment:RGBYCbCr 1080P_30*/
+    HI_UNF_VI_MODE_HDMIRX,              /**HDMI INPUT *//**<CNcomment: ITU-R YUV4:4:4  */
+    HI_UNF_VI_MODE_BUTT
+} HI_UNF_VI_INPUT_MODE_E;
+
+/**VI frame buffer management mode */
+/**CNcomment: VI */
+typedef enum hiUNF_VI_BUF_MGMT_E
+{
+    HI_UNF_VI_BUF_ALLOC = 0,  /**<VI alloc buffer *//**<CNcomment: VIBUF */
+    HI_UNF_VI_BUF_MMAP,       /**<User alloc frame buffer, then maps it to VI *//**<CNcomment: BUFVI */
+    HI_UNF_VI_BUF_BUTT
+} HI_UNF_VI_BUF_MGMT_E;
+
+/**VI frame buffer struct */
+/**CNcomment: VI */
+typedef struct hiUNF_VI_BUFF_ATTR_S
+{
+    HI_VOID *pUsrVirAddr[MAX_VI_EXT_BUF_NUM];  /**<User virtual address *//**<CNcomment: */
+    HI_U32 u32PhyAddr[MAX_VI_EXT_BUF_NUM];     /**<Physical address *//**<CNcomment: */
+    HI_U32 u32BufNum;                          /**<Buffer number *//**<CNcomment: */
+    HI_U32 u32Stride;                          /**<Stride of external frame buffer *//**<CNcomment:stride*/
+} HI_UNF_VI_BUFFER_ATTR_S;
+
+
+/**Vvideo 3D to 2D transfer mode */
+/**CNcomment: 3D */
+typedef enum hiUNF_VI_3DT2D_MODE_E
+{
+    HI_UNF_VI_3DT2D_OFF = 0,        /**< Keep normal left and right eye 3D format *//**<CNcomment: 3D */
+    HI_UNF_VI_3DT2D_L,              /**< Keep normal left eye 3D format*//**<CNcomment: 3D */
+    HI_UNF_VI_3DT2D_R,              /**< Keep normal right eye 3D format*//**<CNcomment: 3D */
+
+    HI_UNF_VI_3DT2D_BUTT,
+} HI_UNF_VI_3DT2D_MODE_E;
+
+
+/**VI attributes */
+/**CNcomment: VI */
+typedef struct hiUNF_VI_ATTR_S
+{
+    HI_BOOL                           bVirtual;             /**<Whether to create virtual VI, only u32BufNum is valid in virtual VI mode *//**<CNcomment: VIVIu32BufNum*/
+    HI_UNF_VI_INPUT_MODE_E            enInputMode;          /**<Video input mode *//**<CNcomment:  */
+    HI_RECT_S                         stInputRect;          /**<Crop region of a window *//**<CNcomment:  */
+    HI_UNF_VIDEO_FORMAT_E             enVideoFormat;        /**<Output Video format *//**<CNcomment:  */
+    HI_UNF_VI_BUF_MGMT_E              enBufMgmtMode;        /**<VI frame buffer management mode *//**<CNcomment: VI */
+    HI_U32                            u32BufNum;            /**<Number of available buffers *//**<CNcomment: buf */
+
+    HI_BOOL                           bInterlace;           /**<Intput video interlace or progressive *//**<CNcomment:  */
+    HI_U32                            u32Width;             /**<Intput video width *//**<CNcomment: ,3D */
+    HI_U32                            u32Height;            /**<Intput video height *//**<CNcomment: 3D */
+    HI_U32                            u32Vblank;	        /**<Intput video field blanking width, used 3d FB*//**<CNcomment: 3DFP */
+    HI_U32                            u32FrameRate;         /**<Intput video intput frequency *//**<CNcomment:  [24Hz,85] */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E en3dFmt;              /**<Intput video format 2D or3D *//**<CNcomment: 2D/3D  */
+    HI_UNF_VIDEO_FORMAT_E             enPixFmt;             /**<Intput pixel format *//**<CNcomment:  RGB444,YUV444/422 */
+    HI_UNF_PIXEL_BITWIDTH_E           enSrcBitWidth;        /**<Intput pixel Width *//**<CNcomment:  8/10/12BIT */
+    HI_UNF_OVERSAMPLE_MODE_E          enOverSample;         /**<Intput Over Sample format *//**<CNcomment:  */
+    HI_UNF_COLOR_SPACE_E              enColorSpace;         /**<Intput Color Space *//**<CNcomment:  */
+    HI_UNF_VI_3DT2D_MODE_E            enDst3DT2DMode;       /**<video 3D to 2D mode *//**<CNcomment: ,3D(VENC/VDP) */
+    HI_UNF_PIXEL_BITWIDTH_E           enDstBitWidth;        /**<output pixel Width *//**<CNcomment: ,8bit8bit8bit10bit */
+} HI_UNF_VI_ATTR_S;
+/** @} */  /** <!-- ==== Struct Definition End ==== */
+
+/********************************API Declaration********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- VI */
+
+/**
+ \brief Initializes the video input unit (VIU). CNcomment: VI CNend
+ \attention \n
+Before calling the VIU, you must call this application programming interface (API).
+CNcomment: VI CNend
+ \param[in] N/A CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_DEV_NOT_EXIST No VI device exists. CNcomment:  CNend
+ \retval ::HI_ERR_VI_NOT_DEV_FILE The file is not a VI file. CNcomment:  CNend
+ \retval ::HI_ERR_VI_DEV_OPENED The VI device fails to be started. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_Init(HI_VOID);
+
+/**
+ \brief Deinitializes the VIU. CNcomment: VI CNend
+ \attention \n
+ \param[in] N/A CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_DeInit(HI_VOID);
+
+/**
+ \brief Obtains the attributes of a VI port. CNcomment: VI CNend
+ \attention \n
+By default, port 0 is used, half D1 and BT656 formats are used, the data of the odd field is collected, and the semi-planar YUV4:2:0 data is output.
+CNcomment: Port=0, HALF-D1, BT656SemiPlanner YUV4:2:0 CNend
+ \param[out] pstAttr Pointer to VI attributes CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_GetDefaultAttr(HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Set the attributes of a VI port. CNcomment: VI Port CNend
+ \attention \n
+This reserved API is combined with HI_UNF_VI_Create, and cannot be called dynamically.
+CNcomment: Create CNend
+ \param[in] hVi VI handle CNcomment: VI CNend
+ \param[in] pstAttr  Pointer to VI attributes CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_INIT_BUF_ERR An error occurs when the buffer is initialized. CNcomment: buffer CNend
+ \retval ::HI_ERR_VI_INVALID_PARA The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_SetAttr(HI_HANDLE hVI, HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Obtains the attributes of a VI port. CNcomment: VI Port CNend
+ \attention \n
+ \param[in] hVi VI handle CNcomment: VI CNend
+ \param[out] pstAttr Pointer to VI attributes CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_GetAttr(HI_HANDLE hVI, HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Enables a VI port to create a VI handle. CNcomment: VI PortVi CNend
+ \attention \n
+Before calling the VIU, you must call this API.\n
+Unless the virtual VI is used, the port ID must correspond to the hardware. That is, the hardware and software must use the same port\n
+CNcomment: VI \n
+           VI, PortID,Port,Port.\n CNend
+ \param[in] enViPort VI port CNcomment: VI CNend
+ \param[in] pstAttr Pointer to VI attributes CNcomment: VI CNend
+ \param[out] phandle hVi Pointer to the VI handle CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_INIT_BUF_ERR An error occurs when the buffer is initialized. CNcomment: buffer CNend
+ \retval ::HI_ERR_VI_INVALID_PARA The attribute parameters are incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+
+HI_S32 HI_UNF_VI_Create(HI_UNF_VI_E enViPort, HI_UNF_VI_ATTR_S *pstAttr, HI_HANDLE *phandle);
+
+/**
+ \brief Disable a VI port to destroy the handle. CNcomment: VI Port CNend
+ \attention \n
+ \param[in] hVi VI handle CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_Destroy(HI_HANDLE hVI);
+
+/**
+ \brief Start VI. CNcomment: VI CNend
+ \attention \n
+ \param[in] hVI VI handle CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_Start(HI_HANDLE hVI);
+
+/**
+ \brief Stop VI. CNcomment: VI CNend
+ \attention \n
+ \param[in] hVI VI handle CNcomment: VI CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_Stop(HI_HANDLE hVI);
+
+/**
+ \brief Set external buffer which will be managed by VI. CNcomment: VI CNend
+ \attention \n
+ The interface is only valid in real VI scene, and ::HI_UNF_VI_BUF_MMAP mode should be set.
+ CNcomment: VI::HI_UNF_VI_BUF_MMAP\n CNend
+ \param[in] hVI VI handle CNcomment: VI CNend
+ \param[in] pstBufAttr Buffer attributes CNcomment:  CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_SetExternBuffer(HI_HANDLE hVI, HI_UNF_VI_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+ \brief Obtains the address of a frame buffer over a VI port.
+ CNcomment:VI Port Buffer CNend
+ \attention \n
+ The interface can only be used in virual VI scene\n
+CNcomment: VI\n CNend
+ \param[in] hVI VI handle CNcomment: VI CNend
+ \param[out] pViBuf Pointer to the VI buffer CNcomment: VI buffer CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_DequeueFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/**
+ \brief Releases the VI frame buffer for the driver.
+ CNcomment: VI Port BufferPort CNend
+ \attention
+ The interface can only be used in virual VI scene\n
+CNcomment: VI\n CNend
+ \param[in] hVI VI handle CNcomment: VI CNend
+ \param[in] pViBuf Pointer to the VI buffer CNcomment: VI buffer CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_QueueFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/**
+ \brief Obtains the address of a YUV picture. CNcomment: YUV  CNend
+ \attention \n
+You do not need to call this API generally. It is recommended that you bind the VIU to the video encoder (VENC) or video output unit (VOU) to implement the encoding function or VIVO loopback function.
+CNcomment: VIVENCVOVIVO CNend
+ \param[in] hVi VI handle CNcomment: VI CNend
+ \param[out] pViBuf Pointer to the VI buffer CNcomment: VI buffer CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_AcquireFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo, HI_U32 u32TimeoutMs);
+
+/**
+ \brief Releases the frame buffer for the VIU after the VENC or VOU obtains a YUV picture.
+CNcomment: YUV  CNend
+ \attention \n
+You do not need to call this API generally. It is recommended that you bind the VIU to the VENC or VOU to implement the encoding function or VIVO loopback function.
+CNcomment: VIVENCVOVIVO CNend
+ \param[in] hVi VI handle CNcomment: VI CNend
+ \param[in] pViBuf Pointer to the VI buffer CNcomment: VI buffer CNend
+ \retval ::HI_SUCCESS Success CNcomment:  CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment:  CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment:  CNend
+ \see \n
+N/A CNcomment:  CNend
+ */
+HI_S32 HI_UNF_VI_ReleaseFrame(HI_HANDLE hVI, const HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/** @} */  /** <!-- ====API Declaration End ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_video.h b/xbmc/platform/linux/hisi/hi_unf_video.h
new file mode 100644
index 0000000000..0a0ae1a529
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_video.h
@@ -0,0 +1,662 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_video.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_VIDEO_H__
+#define __HI_UNF_VIDEO_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include "hi_common.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VIDEO */
+/** @{ */  /** <!-- [VIDEO] */
+
+/**Defines the oversample mode.*/
+/**CNcomment: */
+typedef enum hiUNF_OVERSAMPLE_MODE_E
+{
+    HI_UNF_OVERSAMPLE_1X = 0,
+    HI_UNF_OVERSAMPLE_2X,
+    HI_UNF_OVERSAMPLE_4X,
+    HI_UNF_OVERSAMPLE_BUTT,
+} HI_UNF_OVERSAMPLE_MODE_E;
+
+/**Defines the pixel width.*/
+/**CNcomment: */
+typedef enum hiUNF_PIXEL_BITWIDTH_E
+{
+    HI_UNF_PIXEL_BITWIDTH_8BIT = 0,
+    HI_UNF_PIXEL_BITWIDTH_10BIT,
+    HI_UNF_PIXEL_BITWIDTH_12BIT,
+    HI_UNF_PIXEL_BITWIDTH_BUTT,
+} HI_UNF_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: */
+typedef enum hiUNF_COLOR_SPACE_E
+{
+    HI_UNF_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_UNF_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_UNF_COLOR_SPACE_BT601_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_UNF_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_UNF_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_UNF_COLOR_SPACE_BT709_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT709_RGB_FULL,
+    HI_UNF_COLOR_SPACE_BT2020_YUV_LIMITED,/* ::::Current Used:::: BT.2020 */
+    HI_UNF_COLOR_SPACE_BT2020_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT2020_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT2020_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_UNF_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_UNF_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_UNF_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_UNF_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_UNF_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_UNF_COLOR_SPACE_JPEG = 0x90,
+    HI_UNF_COLOR_SPACE_RGB = 0xa0,
+
+    HI_UNF_COLOR_SPACE_BUTT
+}HI_UNF_COLOR_SPACE_E;
+
+/**Defines the RGB range.*/
+/**CNcomment: RGB */
+typedef enum hiUNF_RGB_RANGE_E
+{
+    HI_UNF_RGB_DEFAULT,
+    HI_UNF_RGB_LIMIT_RANGE,
+    HI_UNF_RGB_FULL_RANGE,
+    HI_UNF_RGB_RANGE_BUTT
+} HI_UNF_RGB_RANGE_E;
+/**Defines the video norm.*/
+/**CNcomment: */
+typedef enum hiUNF_ENC_FMT_E
+{
+    HI_UNF_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/
+    HI_UNF_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/
+    HI_UNF_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/
+    HI_UNF_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/
+    HI_UNF_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/
+
+    HI_UNF_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/
+    HI_UNF_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/
+
+    HI_UNF_ENC_FMT_720P_60,          /**<720p 60 Hz*/
+    HI_UNF_ENC_FMT_720P_50,          /**<720p 50 Hz */
+
+    HI_UNF_ENC_FMT_576P_50,          /**<576p 50 Hz*/
+    HI_UNF_ENC_FMT_480P_60,          /**<480p 60 Hz*/
+
+    HI_UNF_ENC_FMT_PAL,              /* B D G H I PAL */
+    HI_UNF_ENC_FMT_PAL_N,            /* (N)PAL        */
+    HI_UNF_ENC_FMT_PAL_Nc,           /* (Nc)PAL       */
+
+    HI_UNF_ENC_FMT_NTSC,             /* (M)NTSC       */
+    HI_UNF_ENC_FMT_NTSC_J,           /* NTSC-J        */
+    HI_UNF_ENC_FMT_NTSC_PAL_M,       /* (M)PAL        */
+
+    HI_UNF_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/
+    HI_UNF_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/
+
+    HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_50_FRAME_PACKING,
+
+    HI_UNF_ENC_FMT_861D_640X480_60,
+    HI_UNF_ENC_FMT_VESA_800X600_60,
+    HI_UNF_ENC_FMT_VESA_1024X768_60,
+    HI_UNF_ENC_FMT_VESA_1280X720_60,
+    HI_UNF_ENC_FMT_VESA_1280X800_60,
+    HI_UNF_ENC_FMT_VESA_1280X1024_60,
+    HI_UNF_ENC_FMT_VESA_1360X768_60,
+    HI_UNF_ENC_FMT_VESA_1366X768_60,
+    HI_UNF_ENC_FMT_VESA_1400X1050_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X1200_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60_RB,
+    HI_UNF_ENC_FMT_VESA_1920X1080_60,
+    HI_UNF_ENC_FMT_VESA_1920X1200_60,
+    HI_UNF_ENC_FMT_VESA_1920X1440_60,
+    HI_UNF_ENC_FMT_VESA_2048X1152_60,
+    HI_UNF_ENC_FMT_VESA_2560X1440_60_RB,
+    HI_UNF_ENC_FMT_VESA_2560X1600_60_RB,
+
+    HI_UNF_ENC_FMT_3840X2160_24 = 0x40,
+    HI_UNF_ENC_FMT_3840X2160_25,
+    HI_UNF_ENC_FMT_3840X2160_30,
+    HI_UNF_ENC_FMT_3840X2160_50,
+    HI_UNF_ENC_FMT_3840X2160_60,
+
+    HI_UNF_ENC_FMT_4096X2160_24,
+    HI_UNF_ENC_FMT_4096X2160_25,
+    HI_UNF_ENC_FMT_4096X2160_30,
+    HI_UNF_ENC_FMT_4096X2160_50,
+    HI_UNF_ENC_FMT_4096X2160_60,
+
+    HI_UNF_ENC_FMT_3840X2160_23_976,
+    HI_UNF_ENC_FMT_3840X2160_29_97,
+    HI_UNF_ENC_FMT_720P_59_94,
+    HI_UNF_ENC_FMT_1080P_59_94,
+    HI_UNF_ENC_FMT_1080P_29_97,
+    HI_UNF_ENC_FMT_1080P_23_976,
+    HI_UNF_ENC_FMT_1080i_59_94,
+    HI_UNF_ENC_FMT_BUTT
+}HI_UNF_ENC_FMT_E;
+
+/**Defines the mode of the video decoder.*/
+/**CNcomment: */
+typedef enum hiUNF_VCODEC_MODE_E
+{
+    HI_UNF_VCODEC_MODE_NORMAL = 0,   /**<Decode all frames.*/ /**<CNcomment: */
+    HI_UNF_VCODEC_MODE_IP,           /**<Decode only I frames and P frames.*/ /**<CNcomment: IP*/
+    HI_UNF_VCODEC_MODE_I,            /**<Decode only I frames.*/ /**<CNcomment: I*/
+    HI_UNF_VCODEC_MODE_DROP_INVALID_B,  /**<Decode all frames except the first B frame sequence behind I frames */ /**<CNcomment: IB*/
+    HI_UNF_VCODEC_MODE_FIRST_I,   /**<only decodes the first I frame in the input buffer */
+    HI_UNF_VCODEC_MODE_BUTT
+} HI_UNF_VCODEC_MODE_E;
+
+/**Defines special control operation of decoder*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VCODEC_CTRL_OPTION_E
+{
+    HI_UNF_VCODEC_CTRL_OPTION_NORMAL_DPB = 0x0,
+    HI_UNF_VCODEC_CTRL_OPTION_SIMPLE_DPB = 0x1,
+    HI_UNF_VCODEC_CTRL_OPTION_REPAIR_EN  = 0x2,/**CNcomment: miracast */
+    HI_UNF_VCODEC_CTRL_OPTION_LINEAR_EN = 0x4, /**CNcomment: 2D,Hi3716MV430 dongle */
+    HI_UNF_VCODEC_CTRL_OPTION_ONLY_VDH_FRMAE_MEM = 0x8, /**CNcomment: ,Hi3716MV430 dongle */
+    HI_UNF_VCODEC_CTRL_OPTION_MAX
+} HI_UNF_VCODEC_CTRL_OPTION_E;
+
+/**Defines the decoding capability (resolution) of the decoder.*/
+/**CNcomment: () */
+typedef enum hiUNF_VCODEC_CAP_LEVEL_E
+{
+    HI_UNF_VCODEC_CAP_LEVEL_NULL = 0, /**<Do not decode.*/ /**<CNcomment:  */
+    HI_UNF_VCODEC_CAP_LEVEL_QCIF = 0, /**<The resolution of the picture to be decoded is less than or equal to 176x144.*/ /**<CNcomment: 176*144 */
+    HI_UNF_VCODEC_CAP_LEVEL_CIF,      /**<The resolution of the picture to be decoded less than or equal to 352x288.*/ /**<CNcomment: 352*288 */
+    HI_UNF_VCODEC_CAP_LEVEL_D1,       /**<The resolution of the picture to be decoded less than or equal to 720x576.*/ /**<CNcomment: 720*576 */
+    HI_UNF_VCODEC_CAP_LEVEL_720P,     /**<The resolution of the picture to be decoded is less than or equal to 1280x720.*/ /**<CNcomment: 1280*720 */
+    HI_UNF_VCODEC_CAP_LEVEL_FULLHD,   /**<The resolution of the picture to be decoded is less than or equal to 1920x1080.*/ /**<CNcomment: 1920*1080 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_1280x800, /**<The resolution of the picture to be decoded is less than or equal to 1280x800.*/ /**<CNcomment: 1280x800*/
+    HI_UNF_VCODEC_CAP_LEVEL_800x1280, /**<The resolution of the picture to be decoded is less than or equal to 800x1280.*/ /**<CNcomment: 800x1280*/
+    HI_UNF_VCODEC_CAP_LEVEL_1488x1280, /**<The resolution of the picture to be decoded is less than or equal to 1488x1280.*/ /**<CNcomment: 1488x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x1488, /**<The resolution of the picture to be decoded is less than or equal to 1280x1488.*/ /**<CNcomment: 1280x1488 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x1280, /**<The resolution of the picture to be decoded is less than or equal to 2160x1280.*/ /**<CNcomment: 2160x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x2160, /**<The resolution of the picture to be decoded is less than or equal to 1280x2160.*/ /**<CNcomment: 1280x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x2160, /**<The resolution of the picture to be decoded is less than or equal to 2160x2160.*/ /**<CNcomment: 2160x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x2160, /**<The resolution of the picture to be decoded is less than or equal to 4096x2160.*/ /**<CNcomment: 4096x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x4096, /**<The resolution of the picture to be decoded is less than or equal to 2160x4096.*/ /**<CNcomment: 2160x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x4096, /**<The resolution of the picture to be decoded is less than or equal to 4096x4096.*/ /**<CNcomment: 4096x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x4096, /**<The resolution of the picture to be decoded is less than or equal to 8192x4096.*/ /**<CNcomment: 8192x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x8192, /**<The resolution of the picture to be decoded is less than or equal to 4096x8192.*/ /**<CNcomment: 4096x8192 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x8192, /**<The resolution of the picture to be decoded is less than or equal to 8192x8192.*/ /**<CNcomment: 8192x8192 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_BUTT
+} HI_UNF_VCODEC_CAP_LEVEL_E;
+
+/**Defines the stream type supported by the decoder.*/
+/**CNcomment:  */
+typedef enum hiUNF_VCODEC_TYPE_E
+{
+    HI_UNF_VCODEC_TYPE_MPEG2,
+    HI_UNF_VCODEC_TYPE_MPEG4,       /**<MPEG4*/
+    HI_UNF_VCODEC_TYPE_AVS,
+    HI_UNF_VCODEC_TYPE_H263,
+    HI_UNF_VCODEC_TYPE_H264,
+    HI_UNF_VCODEC_TYPE_REAL8,
+    HI_UNF_VCODEC_TYPE_REAL9,
+    HI_UNF_VCODEC_TYPE_VC1,
+    HI_UNF_VCODEC_TYPE_VP6,
+    HI_UNF_VCODEC_TYPE_VP6F,
+    HI_UNF_VCODEC_TYPE_VP6A,
+    HI_UNF_VCODEC_TYPE_MJPEG,
+    HI_UNF_VCODEC_TYPE_SORENSON,    /**<SORENSON SPARK */
+    HI_UNF_VCODEC_TYPE_DIVX3,       /**<Not Supportted */
+    HI_UNF_VCODEC_TYPE_RAW,
+    HI_UNF_VCODEC_TYPE_JPEG,        /**<Used only for VENC */
+    HI_UNF_VCODEC_TYPE_VP8,
+    HI_UNF_VCODEC_TYPE_MSMPEG4V1,   /**<MS private MPEG4 */
+    HI_UNF_VCODEC_TYPE_MSMPEG4V2,
+    HI_UNF_VCODEC_TYPE_MSVIDEO1,    /**<MS video */
+    HI_UNF_VCODEC_TYPE_WMV1,
+    HI_UNF_VCODEC_TYPE_WMV2,
+    HI_UNF_VCODEC_TYPE_RV10,
+    HI_UNF_VCODEC_TYPE_RV20,
+    HI_UNF_VCODEC_TYPE_SVQ1,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_SVQ3,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_H261,
+    HI_UNF_VCODEC_TYPE_VP3,
+    HI_UNF_VCODEC_TYPE_VP5,
+    HI_UNF_VCODEC_TYPE_CINEPAK,
+    HI_UNF_VCODEC_TYPE_INDEO2,
+    HI_UNF_VCODEC_TYPE_INDEO3,
+    HI_UNF_VCODEC_TYPE_INDEO4,
+    HI_UNF_VCODEC_TYPE_INDEO5,
+    HI_UNF_VCODEC_TYPE_MJPEGB,
+    HI_UNF_VCODEC_TYPE_MVC,
+    HI_UNF_VCODEC_TYPE_HEVC,
+    HI_UNF_VCODEC_TYPE_DV,
+    HI_UNF_VCODEC_TYPE_VP9,
+    HI_UNF_VCODEC_TYPE_AVS2,
+    HI_UNF_VCODEC_TYPE_BUTT
+}HI_UNF_VCODEC_TYPE_E;
+
+/**Defines the H264 profile of the video encoder.*/
+/**CNcomment:  H264*/
+typedef enum hiUNF_H264_PROFILE_E
+{
+    HI_UNF_H264_PROFILE_BASELINE = 0,   /**<Encode H264 stream by baseline profile.*/ /**<CNcomment: H264*/
+    HI_UNF_H264_PROFILE_MAIN,           /**<Encode H264 stream by main profile.*/     /**<CNcomment:H264*/
+    HI_UNF_H264_PROFILE_EXTENDED,       /**<Encode H264 stream by extended profile.*/ /**<CNcomment:H264*/
+    HI_UNF_H264_PROFILE_HIGH,           /**<Encode H264 stream by high profile.*/     /**<CNcomment: H264*/
+    HI_UNF_H264_PROFILE_BUTT
+}HI_UNF_H264_PROFILE_E;
+
+typedef enum hiUNF_VIDEO_HDR_TYPE_E
+{
+    HI_UNF_VIDEO_HDR_TYPE_HDR10 = 0,
+    HI_UNF_VIDEO_HDR_TYPE_HLG,
+    HI_UNF_VIDEO_HDR_TYPE_BUTT
+}HI_UNF_VIDEO_HDR_TYPE_E;
+
+typedef struct hiUNF_VCODEC_VC1_ATTR_S
+{
+    HI_BOOL  bAdvancedProfile;   /**<Whether the profile is an advanced profile*/ /**<CNcomment: Advanced Profile*/
+    HI_U32   u32CodecVersion;    /**<Version number*/ /**<CNcomment: */
+}HI_UNF_VCODEC_VC1_ATTR_S;
+
+typedef struct hiUNF_VCODEC_VP6_ATTR_S
+{
+    HI_BOOL  bReversed;     /**<To reverse a picture, set this parameter to 1. In this cases, set it to 0.*/ /**<CNcomment: 10*/
+    HI_U16   u16DispWidth;  /**<Display Width.*/ /**<CNcomment: */
+    HI_U16   u16DispHeight; /**<Display Height.*/ /**<CNcomment: */
+}HI_UNF_VCODEC_VP6_ATTR_S;
+
+typedef union hiUNF_VCODEC_EXTATTR_U
+{
+    HI_UNF_VCODEC_VC1_ATTR_S stVC1Attr;
+    HI_UNF_VCODEC_VP6_ATTR_S stVP6Attr;
+}HI_UNF_VCODEC_EXTATTR_U;
+
+/**Defines the attributes of a video decoder.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enType;          /**<Video encoding type*/ /**<CNcomment: */
+    HI_UNF_VCODEC_EXTATTR_U     unExtAttr;       /**<Extra attributes related to the video encoding type*/ /**<CNcomment: */
+    HI_UNF_VCODEC_MODE_E        enMode;          /**<Mode of a video decoder*/ /**<CNcomment: */
+    HI_U32                      u32ErrCover;     /**<Error concealment threshold of the output frames of a video decoder. The value 0 indicates that no frames are output if an error occurs; the value 100 indicates that all frames are output no matter whether errors occur.*/
+                                                 /**<CNcomment: 0:100:*/
+    HI_U32                      u32Priority;     /**<Priority of a video decoder. The value range is [1, HI_UNF_VCODEC_MAX_PRIORITY]. The value 0 is a reserved value. If you set the value to 0, no error message is displayed, but the value 1 is used automatically. The smaller the value, the lower the priority.*/
+                                                 /**<CNcomment: , : 1HI_UNF_VCODEC_MAX_PRIORITY, 001, */
+    HI_BOOL                     bOrderOutput;    /**<Whether the videos are output by the decoding sequence. You are advised to set this parameter to HI_TRUE in VP mode, and HI_FALSE in other modes.*/
+                                                 /**<CNcomment: VPHI_TRUE, HI_FALSE */
+    HI_S32                      s32CtrlOptions;  /**<The value is HI_UNF_VCODEC_CTRL_OPTION_E, or the 'or' value of several enum type*/
+                                                 /**<CNcomment: HI_UNF_VCODEC_CTRL_OPTION_E''  */
+    HI_VOID*                    pCodecContext;   /**<Private codec context */
+}HI_UNF_VCODEC_ATTR_S;
+
+/**Defines the hdr attributes of a video decoder.*/
+/**CNcomment: HDR*/
+typedef struct hiUNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S
+{
+    HI_U16 u16DisplayPrimaries_x[3];
+    HI_U16 u16DisplayPrimaries_y[3];
+    HI_U16 u16WhitePoint_x;
+    HI_U16 u16WhitePoint_y;
+    HI_U32 u32MaxDisplayMasteringLuminance;
+    HI_U32 u32MinDisplayMasteringLuminance;
+} HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S;
+
+typedef struct hiUNF_VIDEO_CONTENT_LIGHT_LEVEL_S
+{
+    HI_U32 u32MaxContentLightLevel;
+    HI_U32 u32MaxPicAverageLightLevel;
+} HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S;
+
+typedef struct hiUNF_VIDEO_HDR10__S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering,0:1:*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content,0:1:*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+} HI_UNF_VIDEO_HDR10_INFO_S;
+
+typedef struct hiUNF_VIDEO_HLG_INFO_S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering,0:1:*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content,0:1:*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+    HI_U8  u8BackWardsCompatible;
+} HI_UNF_VIDEO_HLG_INFO_S;
+
+typedef union hiUNF_VIDEO_HDR_METADATA_U
+{
+    HI_UNF_VIDEO_HDR10_INFO_S stHdr10Info;
+    HI_UNF_VIDEO_HLG_INFO_S   stHlgInfo;
+}HI_UNF_VIDEO_HDR_METADATA_U;
+
+typedef struct hiUNF_VIDEO_HDR_INFO_S
+{
+    HI_UNF_VIDEO_HDR_TYPE_E          enHdrType;
+    HI_UNF_VIDEO_HDR_METADATA_U      unHdrMetadata;
+} HI_UNF_VIDEO_HDR_INFO_S;
+
+/**Defines the sub stream protocol.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_SUB_STANDARD_E
+{
+    HI_UNF_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2MPEG1 */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4SHV*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4XVID*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4DIVX*/
+
+    HI_UNF_VIDEO_SUB_STANDARD_BUTT
+}HI_UNF_VIDEO_SUB_STANDARD_E;
+
+/**Defines the frame rate of the video stream.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_FRMRATE_S
+{
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+                              /**<CNcomment: 3, fps */
+}HI_UNF_VCODEC_FRMRATE_S;
+
+/**Defines the information about video streams.*/
+/**CNcomment: */
+typedef struct hiUNF_VCODEC_STREAMINFO_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Stream type*/ /**<CNcomment:  */
+    HI_UNF_VIDEO_SUB_STANDARD_E enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                      u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                      u32Profile;     /**<Stream profile*/ /**<CNcomment: profile */
+    HI_U32                      u32Level;       /**<Stream level*/ /**<CNcomment: level */
+    HI_UNF_ENC_FMT_E            enDisplayNorm;  /**<Display norm (PAL or NTSC)*/ /**<CNcomment: (P/N) */
+    HI_BOOL                     bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_U32                      u32AspectWidth; /**<Output aspect ratio: width*/ /**<CNcomment:  */
+    HI_U32                      u32AspectHeight;/**<Output aspect ratio: height*/ /**<CNcomment:  */
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: , Kbps */
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 3, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+    HI_UNF_PIXEL_BITWIDTH_E enBitWidth; /**<Bit width decoded from stream*/ /**<CNcomment: */
+    HI_UNF_COLOR_SPACE_E       enSrcColorSpace; /**<Color space decoded from stream*/ /**<CNcomment: */
+}HI_UNF_VCODEC_STREAMINFO_S;
+
+
+/**Defines the types of the user data in the video information.*/
+/**CNcomment:  */
+typedef enum hiHI_UNF_VIDEO_USERDATA_TYPE_E
+{
+    HI_UNF_VIDEO_USERDATA_UNKNOWN = 0,      /**<Unknown type*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_DVB1_CC = 0x1,    /**<Closed Caption Data*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_DVB1_BAR = 0x2,   /**<Bar Data*/ /**<CNcomment: Bar*/
+    HI_UNF_VIDEO_USERDATA_AFD = 0x10000,    /**<Active Format Description*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USERDATA_BUTT
+}HI_UNF_VIDEO_USERDATA_TYPE_E;
+
+/**Defines the profile of video broadcasting.*/
+/**CNcomment: profile*/
+typedef enum hiUNF_VIDEO_BROADCAST_PROFILE_E
+{
+    HI_UNF_VIDEO_BROADCAST_DVB,        /**<Digital video broadcasting (DVB)*/ /**<CNcomment: DVB*/
+    HI_UNF_VIDEO_BROADCAST_DIRECTV,    /**<American live broadcast operator DirecTV*/ /**<CNcomment: DirecTV*/
+    HI_UNF_VIDEO_BROADCAST_ATSC,       /**<Advanced Television Systems Committee (ATSC)*/ /**<CNcomment: ATSCAdvanced Television Systems Committee*/
+    HI_UNF_VIDEO_BROADCAST_DVD,        /**<Digital video disc (DVD)*/ /**<CNcomment: */
+    HI_UNF_VIDEO_BROADCAST_ARIB,       /**<Association of Radio Industries and Businesses (ARIB)*/ /**<CNcomment: */
+    HI_UNF_VIDEO_BROADCAST_BUTT
+}HI_UNF_VIDEO_BROADCAST_PROFILE_E;
+
+/**Defines the position of the user data in the video information.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_USER_DATA_POSITION_E
+{
+    HI_UNF_VIDEO_USER_DATA_POSITION_UNKNOWN,       /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_SEQ,     /**<The data is parsed from sequences under the MPEG2 protocol.*/ /**<CNcomment: MPEG2*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_GOP,     /**<The data is parsed from the group of pictures (GOP) under the MPEG2 protocol.*/ /**<CNcomment: MPEG2GOPGroup Of Pictures*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_FRAME,   /**<The data is parsed from picture frames under the MPEG2 protocol.*/ /**<CNcomment: MPEG2*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSOS,    /**<The data is parsed from the sequences of visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSO,     /**<The data is parsed from visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VOL,     /**<The data is parsed from the video object layer under the MPEG4 protocol.*/ /**<CNcomment: MPEG4*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_GOP,     /**<The data is parsed from the GOP under the MPEG4 protocol.*/ /**<CNcomment: MPEG4GOP*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_REG,      /**<The data is parsed from the user_data_regestered_itu_t_t35() syntax under the H.264 protocol.*/ /**<CNcomment: H.264user_data_regestered_itu_t_t35()*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_UNREG,    /**<The data is parsed from the user_data_unregestered() syntax under the H.264 protocol.*/ /**<CNcomment: H.264user_data_unregestered()*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_BUTT
+}HI_UNF_VIDEO_USER_DATA_POSITION_E;
+
+/**Defines the structure of the user data in the video information.*/
+/**CNcomment: */
+typedef struct hiUNF_VIDEO_USERDATA_S
+{
+    HI_UNF_VIDEO_BROADCAST_PROFILE_E   enBroadcastProfile;   /**<Broadcasting profile of the user data*/ /**<CNcomment: profile*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_E  enPositionInStream;   /**<Position of the user data in video streams*/ /**<CNcomment: */
+    HI_U32                             u32Pts;               /**<PTS corresponding to the user data*/ /**<CNcomment: */
+    HI_U32                             u32SeqCnt;            /**<Sequence ID of the user data*/ /**<CNcomment: */
+    HI_U32                             u32SeqFrameCnt;       /**<Frame number of the user data*/ /**<CNcomment: */
+    HI_U8                              *pu8Buffer;           /**<Initial address of the user data memory, output parameter*/ /**<CNcomment: ,*/
+    HI_U32                             u32Length;            /**<User data size (a multiple of 1 byte)*/ /**<CNcomment: 1byte*/
+    HI_BOOL                            bBufferOverflow;      /**<Indicate that whether the user data size exceeds the maximum size defined by MAX_USER_DATA_LEN.*/ /**<CNcomment: MAX_USER_DATA_LEN*/
+    HI_BOOL                            bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: */
+}HI_UNF_VIDEO_USERDATA_S;
+
+/**Defines the parameters of format changing */
+/**CNcomment: */
+typedef struct hiUNF_NORMCHANGE_PARAM_S
+{
+    HI_UNF_ENC_FMT_E            enNewFormat;            /**<New format*/ /**<CNcomment: */
+    HI_U32                      u32ImageWidth;          /**<Width of image*/ /**<CNcomment: */
+    HI_U32                      u32ImageHeight;         /**<Height of image*/ /**<CNcomment: */
+    HI_BOOL                     bProgressive;           /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_U32                      u32FrameRate;           /**<Frame rate*//**<CNcomment:*/
+}HI_UNF_NORMCHANGE_PARAM_S;
+
+/**Defines the video format.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FORMAT_E
+{
+    /* Semi-Planner */
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422,       /**<The YUV spatial sampling format is 4:2:2.*/ /**<CNcomment: YUV4:2:2*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is 4:2:0, V first.*/ /**<CNcomment: YUV4:2:0V*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_400,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_411,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_444,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420_UV,   /**<The YUV spatial sampling format is 4:2:0,U first.*/ /**<CNcomment: YUV4:2:0, U*/
+
+
+    /* Package */
+    HI_UNF_FORMAT_YUV_PACKAGE_UYVY,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUVpackage,UYVY*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YUYV,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUVpackage,YUYV*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YVYU,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUVpackage,YVYU*/
+
+    /* Planner */
+    HI_UNF_FORMAT_YUV_PLANAR_400,
+    HI_UNF_FORMAT_YUV_PLANAR_411,
+    HI_UNF_FORMAT_YUV_PLANAR_420,
+    HI_UNF_FORMAT_YUV_PLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_PLANAR_422_2X1,
+    HI_UNF_FORMAT_YUV_PLANAR_444,
+    HI_UNF_FORMAT_YUV_PLANAR_410,
+    HI_UNF_FORMAT_YUV_TILE_420,             /**<The YUV spatial sampling format is TILE 4:2:0, V first.*/
+    HI_UNF_FORMAT_YUV_TILE_420_UV,          /**<The YUV spatial sampling format is TILE 4:2:0, U first.*/
+    HI_UNF_FORMAT_YUV_BUTT,
+
+    HI_UNF_FORMAT_RGB_SEMIPLANAR_444,
+    HI_UNF_FORMAT_RGB_888,
+    HI_UNF_FORMAT_ARGB_8888,
+    HI_UNF_FORMAT_RGB_BUTT
+}HI_UNF_VIDEO_FORMAT_E;
+
+/**Defines the type of the video frame.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FRAME_TYPE_E
+{
+    HI_UNF_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: */
+    HI_UNF_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I*/
+    HI_UNF_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P*/
+    HI_UNF_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B*/
+    HI_UNF_FRAME_TYPE_IDR,       /**<IDR frame*/ /**<CNcomment: IDR*/
+    HI_UNF_FRAME_TYPE_BLA,       /**<BLA frame*/ /**<CNcomment: BLA*/
+    HI_UNF_FRAME_TYPE_CRA,       /**<CRA frame*/ /**<CNcomment: CRA*/
+    HI_UNF_FRAME_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode.*/
+/**CNcomment: */
+typedef enum hiUNF_VIDEO_FIELD_MODE_E
+{
+    HI_UNF_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FIELD_BUTT
+}HI_UNF_VIDEO_FIELD_MODE_E;
+
+
+/**Defines 3D frame packing type*/
+typedef enum hiUNF_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_UNF_FRAME_PACKING_TYPE_NONE,             /**< Normal frame, not a 3D frame */
+    HI_UNF_FRAME_PACKING_TYPE_SIDE_BY_SIDE,     /**< Side by side */
+    HI_UNF_FRAME_PACKING_TYPE_TOP_AND_BOTTOM,   /**< Top and bottom */
+    HI_UNF_FRAME_PACKING_TYPE_TIME_INTERLACED,  /**< Time interlaced: one frame for left eye, the next frame for right eye */
+    HI_UNF_FRAME_PACKING_TYPE_FRAME_PACKING,    /**< frame packing */
+    HI_UNF_FRAME_PACKING_TYPE_3D_TILE,          /**< Tile 3D */
+    HI_UNF_FRAME_PACKING_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_PACKING_TYPE_E;
+
+typedef struct hiUNF_VIDEO_FRAME_ADDR_S
+{
+    HI_U32             u32YAddr;    /**<Physical address of the Y  component in the current frame*/ /**<CNcomment: Y*/
+    HI_U32             u32CAddr;    /**<Physical address of the C  component in the current frame*/ /**<CNcomment: C*/
+    HI_U32             u32CrAddr;   /**<Physical address of the Cr component in the current frame*/ /**<CNcomment: Cr*/
+
+    HI_U32             u32YStride;  /**<Stride of the Y component*/ /**<CNcomment: Y*/
+    HI_U32             u32CStride;  /**<Stride of the C component*/ /**<CNcomment: C*/
+    HI_U32             u32CrStride; /**<Stride of the Cr component*/ /**<CNcomment: Cr*/
+}HI_UNF_VIDEO_FRAME_ADDR_S;
+
+typedef struct hiUNF_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32FrameIndex;      /**<Frame index ID of a video sequence*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FRAME_ADDR_S           stVideoFrameAddr[2];
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32SrcPts;          /**<Original PTS of a video frame*/ /**<CNcomment: */
+    HI_U32                              u32Pts;             /**<PTS of a video frame*/ /**<CNcomment: */
+    HI_U32                              u32AspectWidth;
+    HI_U32                              u32AspectHeight;
+    HI_UNF_VCODEC_FRMRATE_S             stFrameRate;
+
+    HI_UNF_VIDEO_FORMAT_E               enVideoFormat;      /**<Video YUV format*/ /**<CNcomment: YUV*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+    HI_UNF_VIDEO_FIELD_MODE_E           enFieldMode;        /**<Frame or field encoding mode*/ /**<CNcomment: */
+    HI_BOOL                             bTopFieldFirst;     /**<Top field first flag*/ /**<CNcomment: */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+    HI_U32                              u32Circumrotate;    /**<Need circumrotate, 1 need */
+    HI_BOOL                             bVerticalMirror;
+    HI_BOOL                             bHorizontalMirror;
+    HI_U32                              u32DisplayWidth;    /**<Width of the displayed picture*/ /**<CNcomment: */
+    HI_U32                              u32DisplayHeight;   /**<Height of the displayed picture*/ /**<CNcomment: */
+    HI_U32                              u32DisplayCenterX;  /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: x*/
+    HI_U32                              u32DisplayCenterY;  /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: y*/
+    HI_U32                              u32ErrorLevel;      /**<Error percentage of a decoded picture, ranging from 0% to 100%*/ /**<CNcomment: 0100*/
+    HI_U32                              u32Private[64];     /**<Private data for every frame:
+                                                                u32Private[0]: securty flag, if u32Private[0] == 1, this is a secure frame;
+                                                                */
+
+
+}HI_UNF_VIDEO_FRAME_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_STATUS_INFO_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E enVidFrmType; /**<Type of video frame*/ /**<CNcomment: */
+    HI_U32 u32VidFrmStreamSize;             /**<Size of video frame*/ /**<CNcomment: */
+    HI_U32 u32VidFrmQP;                     /**<QP of video frame*/ /**<CNcomment: QP*/
+    HI_U32 u32VidFrmPTS;                    /**<PTS of video frame*/ /**<CNcomment: pts*/
+    HI_U32 u32MaxMV;                        /**<MAX MV*/ /**<CNcomment: MV*/
+    HI_U32 u32MinMV;                        /**<MIN MV*/ /**<CNcomment: MV*/
+    HI_U32 u32AvgMV;                        /**<AVG MV*/ /**<CNcomment: MV*/
+    HI_U32 u32SkipRatio;                    /**<MB ratio */ /**<CNcomment: MB0~100*/
+    HI_U32 u32DecoderBuffer;                /**<BUFFER STATE>*/ /**<CNcomment: 0-ok, 2-UnderFlow, 3-DecodeErr*/
+}HI_UNF_VIDEO_FRM_STATUS_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_DISPLAY_TIME_S
+{
+    HI_S64 s64PTS;                          /**<PTS of video frame*/ /**<CNcomment: PTS*/
+    HI_S64 s64DisplayTime;                  /**<Estimated time of display */ /**<CNcomment: */
+} HI_UNF_VIDEO_FRM_DISPLAY_TIME_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_VIDEO_ H*/
diff --git a/xbmc/platform/linux/hisi/hi_unf_vo.h b/xbmc/platform/linux/hisi/hi_unf_vo.h
new file mode 100644
index 0000000000..4a7a1ae395
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_vo.h
@@ -0,0 +1,857 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vo.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/16
+  Description   :
+  History       :
+  1.Date        : 2009/12/16
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief  supply info of vo module.
+ */
+
+#ifndef  __HI_UNF_VO_H__
+#define  __HI_UNF_VO_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+
+
+/**defines the ROTATION type.*/
+/**CNcomment:*/
+typedef enum hiUNF_VO_ROTATION_E
+{
+    HI_UNF_VO_ROTATION_0, /**< 0 degree rotation*//**<CNcomment: 0*/
+    HI_UNF_VO_ROTATION_90, /**< 90 degree rotation*//**<CNcomment: 90*/
+    HI_UNF_VO_ROTATION_180, /**< 180 degree rotation*//**<CNcomment: 180*/
+    HI_UNF_VO_ROTATION_270, /**< 270 degree rotation*//**<CNcomment: 270*/
+    HI_UNF_VO_ROTATION_BUTT
+}HI_UNF_VO_ROTATION_E;
+
+
+/**conversion mode of AspectRatio.*/
+/**CNcomment:*/
+typedef enum hiUNF_VO_ASPECT_CVRS_E
+{
+    HI_UNF_VO_ASPECT_CVRS_IGNORE = 0x0,
+    HI_UNF_VO_ASPECT_CVRS_LETTERBOX,      /**<Add black borders*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_PAN_SCAN,      /**<Clip the picture*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_COMBINED,       /**<Add black borders and clip the picture*//**<CNcomment: */
+
+    HI_UNF_VO_ASPECT_CVRS_HORIZONTAL_FULL,  /**<keep picture's HORIZONTAL be full*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_VERTICAL_FULL,    /**<keep picture's VERTICAL be full*//**<CNcomment: */
+    HI_UNF_VO_ASPECT_CVRS_BUTT,
+} HI_UNF_VO_ASPECT_CVRS_E;
+
+/** AspectRatio attribute.*/
+/**CNcomment:*/
+typedef struct hiUNF_WINDOW_ASPECT_ATTR_S
+{
+    HI_UNF_VO_ASPECT_CVRS_E   enAspectCvrs;  /**<the method to the aspect ratio transfer.\n*//**<CNcomment:  */
+    HI_BOOL                   bUserDefAspectRatio;  /**<use or not user define aspectratio. \n
+                                                     if this is true, u32UserAspectWidth and u32UserAspectHeight will be effective.\n*/
+                                                    /**<CNcomment: , TRUEu32UserAspectWidthu32UserAspectHeight*/
+    HI_U32                    u32UserAspectWidth; /**<aspect width of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                  /**<CNcomment:  \n
+                                                   0~3840 \n
+                                                   0*/
+    HI_U32                    u32UserAspectHeight; /**<aspect height of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                    /**<CNcomment:  \n
+                                                    0~3840 \n
+                                                    0*/
+} HI_UNF_WINDOW_ASPECT_ATTR_S;
+
+/**define the attribution of window.*/
+/**CNcomment:WINDOW*/
+typedef struct hiUNF_WINDOW_ATTR_S
+{
+    HI_UNF_DISP_E             enDisp;          /**<the display channel where window locate in. can not be modified.\n*//**<CNcomment: ,  */
+    HI_BOOL                   bVirtual;      /**< whether is virtual window or not. can not be modified.\n*//**<CNcomment:  */
+    HI_UNF_VIDEO_FORMAT_E     enVideoFormat; /**<the data format of virtual window.\n*//**<CNcomment:  */
+    HI_UNF_WINDOW_ASPECT_ATTR_S     stWinAspectAttr;  /**<the AspectRatio of window.\n*//**<CNcomment:  */
+    HI_BOOL                   bUseCropRect;     /**<cut video frame as stCropRect struct or as stInputRect struct \n
+                                                    if this is TRUE, stCropRect will be effective \n
+                                                    if this is false, stInputRect will be effective.*/
+                                                   /**<CNcomment: stCropRect \n
+                                                    TRUEstCropRect \n
+                                                    FALSEstInputRect*/
+
+    HI_UNF_CROP_RECT_S        stCropRect;   /**<clip window of user define ,clip pix num of top,buttom,left,right.\n*/
+                                            /**<CNcomment: , */
+
+    HI_RECT_S                 stInputRect;       /**<the crop area .\n
+                                                  all values are zero indicate outputing whole video stream \n
+                                                  if the value is bigger than video frame, the whole video frame will be displayed \n
+                                                  width and height should not be less than 64.\n*/
+                                                 /**<CNcomment:   \n
+                                                  0 \n
+                                                  , \n
+                                                  6464*64*/
+
+    HI_RECT_S                 stOutputRect;  /**<the window display area on the virtual screen. \n
+                                                The width and height of display area should not larger than virtual screen,\n
+                                                and all parameters are zero means to fill whole virtual screen.\n
+                                                The area could move out of virtual screen, and the outside part will not display.\n*/
+                                                /**<CNcomment: \n
+                                                0\n
+                                                */
+
+
+
+} HI_UNF_WINDOW_ATTR_S;
+
+
+/**define user buffer management attribute.*/
+/**CNcomment:*/
+typedef struct hiUNF_BUFFER_ATTR_S
+{
+    HI_S32              s32Stride;          /**<the stride of the buffer.*//**<CNcomment: */
+    HI_U32              u32PhyAddr[16];     /**<start physics addrss of the buffer.*//**<CNcomment: */
+    HI_U32              u32BuffIndex[16];   /**<Stride of the buffer.*//**<CNcomment: */
+    HI_S32              s32BuffNum;         /**<the number of the buffer.*//**<CNcomment: */
+} HI_UNF_BUFFER_ATTR_S;
+
+/** the running mode of vo*/
+/**CNcomment:VO */
+typedef enum hiUNF_VO_DEV_MODE_E
+{
+    HI_UNF_VO_DEV_MODE_NORMAL,  /**<normal mode:
+                                  3716 V100/V200 :no more than 2 windows to be created.
+                                  3716 v300:no more than 3 windows to be created.
+                                  3712 v300:no more than 1 windows to be created.*/
+                                  /**<CNcomment: 
+                                   3716 V100/V200:2WINDOW
+                                   3716 v300: 3WINDOW
+                                   3712 v300: 1WINDOW*/
+    HI_UNF_VO_DEV_MODE_MOSAIC,  /**<mosaic mode: can create more than 2 windows.
+                                 3712 v300: not support*/
+                                /**<CNcomment: WINDOW
+                                 3712 v300: */
+    HI_UNF_VO_DEV_MODE_STANDALONE,  /**<seperate mode,only 1 window can be created,and  the aspect ratio set seperately.
+                                        3716 v300: not support*/
+                                    /**<CNcomment: standalone
+                                     3716 v300 : */
+    HI_UNF_VO_DEV_MODE_BUTT
+} HI_UNF_VO_DEV_MODE_E;
+
+/**define the freeze mode enumeration.*/
+/**CNcomment:Freeze*/
+typedef enum hiUNF_WINDOW_FREEZE_MODE_E
+{
+    HI_UNF_WINDOW_FREEZE_MODE_LAST = 0,   /**<display the last frame when freeze.*//**<CNcomment: freeze*/
+    HI_UNF_WINDOW_FREEZE_MODE_BLACK = 1,  /**<display a black frame when freeze.*//**<CNcomment: freeze*/
+    HI_UNF_WINDOW_FREEZE_MODE_BUTT
+} HI_UNF_WINDOW_FREEZE_MODE_E;
+
+/**<Frosted glass effect level*/
+/**<CNcomment: CNend*/
+typedef enum hiUNF_WINDOW_FROST_E
+{
+    HI_UNF_WINDOW_FROST_CLOSE = 0x0 ,       /**<Close  */ /**<CNcomment: CNend*/
+    HI_UNF_WINDOW_FROST_LOW         ,       /**<Low    */ /**<CNcomment:   CNend*/
+    HI_UNF_WINDOW_FROST_MIDDLE      ,       /**<Middle */ /**<CNcomment:   CNend*/
+    HI_UNF_WINDOW_FROST_HIGH        ,       /**<High   */ /**<CNcomment:   CNend*/
+
+    HI_UNF_WINDOW_FROST_BUTT
+}HI_UNF_WINDOW_FROST_E;
+
+typedef struct hiUNF_WIN_PLAY_INFO_S
+{
+    HI_U32    u32Underload;        /**< Compared with the normal play ,frame underload count  */ /**<CNcomment: CNend*/
+}HI_UNF_WIN_PLAY_INFO_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+/**
+\brief  init vo module.CNcomment:VO CNend
+\attention \n
+Before call this func, you should confirm that HI_UNF_DISP_Init and HI_UNF_DISP_Open have been called yet.
+call this func before any other vo funcs .
+CNcomment:DISPLAYVO CNend
+\param[in]   enDevMode  the vo running mode.  CNcomment:VO CNend
+\retval ::HI_SUCCESS successs.CNcomment: CNend
+\retval ::HI_ERR_VO_DEV_NOT_EXIST  vo device not exist. CNcomment:VO CNend
+\retval ::HI_ERR_VO_NOT_DEV_FILE   not vo device. CNcomment:VO CNend
+\retval ::HI_ERR_VO_DEV_OPEN_ERR   open vo failed. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal param. CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+/**
+\brief  deinit vo module.CNcomment:VO CNend
+\attention \n
+before calling this func ,you should call HI_UNF_VO_Close to close all the windows first.
+CNcomment:::HI_UNF_VO_CloseVO CNend
+\param CNcomment: CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_DEV_CLOSE_ERR  vo deinited failed. CNcomment:VO CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DeInit(HI_VOID);
+
+/**
+\brief create the window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO CNend
+\param[in] phWindow   the window handler to be created.CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S *pWinAttr, HI_HANDLE *phWindow);
+
+/**
+\brief create the window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO CNend
+\param[in] phWindow   the window handler to be created.CNcomment:WINDOW CNend
+\param[in] bVirtScreen   flag indicates whether creating with virtscreen coordinate.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindowExt(const HI_UNF_WINDOW_ATTR_S* pWinAttr,
+                                  HI_HANDLE *phWindow,
+                                  HI_BOOL bVirtScreen);
+
+/**
+\brief  destroy the given window.CNcomment:WINDOW CNend
+\attention \n
+user should disable window before call this func
+CNcomment:disable  CNend
+\param[in] hWindow    the input window handler. CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow);
+
+
+/**
+\brief to enable or disable the given window.CNcomment:/WINDOW CNend
+\attention \n
+Window can only be disabled after the corresponding avplay is stopped, else data will overflow.
+CNcomment:AVPLAYVIDstopwindow CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable     the flag  of enable or disable window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief get the status of the given window: enable or not.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pbEnable    the status of window:enable or disable.CNcomment:/. CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowEnable(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+/**
+\brief set the attribution of the given window.CNcomment:WINDOW CNend
+\attention \n
+the two members of pWinAttr:enDisp and bVirtual are fixed when window created, and they can't be modified here.
+Each value as HI_UNF_WINDOW_ATTR_S Definition
+CNcomment:enDispbVirtualHI_UNF_WINDOW_ATTR_S CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW CNend
+\param[in] pWinAttr   the pointer of windows attr.CNcomment:WINDO CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowAttr(HI_HANDLE hWindow, const HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the attribution of the given window.CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pWinAttr    the pointer of windows attr. CNcomment:WINDO CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowAttr(HI_HANDLE hWindow, HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the frame from given window.CNcomment:WINDOWFrame CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[out] pstFrameinfo  frame information. CNcomment:Frame CNend
+\param[in] u32TimeoutMs wait time in ms.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited.CNcomment: VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AcquireFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief return the frame back to the given window, used for 3d graphics testing.CNcomment:WINDOWFrame3D CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_ReleaseFrame(HI_HANDLE hWindow,HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief set the zorder of the given window.CNcomment:WINDOWZ CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW CNend
+\param[in] enZFlag    how to adjust zorder. CNcomment:Z CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowZorder(HI_HANDLE hWindow, HI_LAYER_ZORDER_E enZFlag);
+
+/**
+\brief get the zorder of the given window.CNcomment:WINDOWZ CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow       the input window handler.CNcomment:WINDOW CNend
+\param[in] pu32Zorder    value of zoder, bigger value means higher prioty. CNcomment:Z CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowZorder(HI_HANDLE hWindow, HI_U32 *pu32Zorder);
+
+/**
+\brief attach the window with video source such as vi/avplay.CNcomment:WINDOWAVPLAY/VI CNend
+\attention \n
+it can attach the handler of avplay or vi to the window.
+CNcomment:AVPLAYVIWINDOW CNend
+\param[in] hWindow     the input window handler. CNcomment:WINDOW CNend
+\param[in] hSrc        the handler of video source. CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params. CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+
+/**
+\brief detach the window from the video source such as avplay or vi.CNcomment:WINDOWAVPLAY/VI CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] hSrc        the handler of video source.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+/**
+\brief Set frost glass effect level at one window .CNcomment: CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow         the input window handler.CNcomment:WINDOW CNend
+\param[in] enWinFrostMode  Frost glass level.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E enWinFrostMode);
+
+/**
+\brief Get frost glass effect level at one window .CNcomment: CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] *penWinFrostMode  Frost glass level.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E* penWinFrostMode);
+
+/**
+\brief  to freeze the video content of given window.CNcomment:WINDOW CNend
+\attention \n
+the display will be freezed after calling this func, but backgrounddly,the data flow is normal from video decoder.
+so when freezing is cacelled, the newest video content can be display at once.
+CNcomment:WINDOW\n
+ CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable           shows whether to freeze window.CNcomment:/ CNend
+\param[in] enWinFreezeMode   the mode of freeze.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_FreezeWindow(HI_HANDLE hWindow, HI_BOOL bEnable, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief  to get the freeze status of the given window.CNcomment: CNend
+\attention \n
+\param[in] hWindow            the input window handler.CNcomment:WINDOW CNend
+\param[out] pbEnable           shows whether to freeze window.CNcomment:/ CNend
+\param[out] penWinFreezeMode   the mode of freeze.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment:  CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFreezeStatus(HI_HANDLE hWindow, HI_BOOL *pbEnable, HI_UNF_WINDOW_FREEZE_MODE_E *penWinFreezeMode);
+
+
+/**
+\brief reset the window.CNcomment:WINDOW CNend
+\attention \n
+this function can reset buffers of the given window, and black frame or the last frame will be displayed according configuration.
+CNcomment:window CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] enWinFreezeMode   method of freeze the window.CNcomment: CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_ResetWindow(HI_HANDLE hWindow, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief pass the external allocated buffer to this function to test 3d graphics.CNcomment:WINDOWbuffer3D CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] pstBufAttr  external buffer.CNcomment:buffer CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_AttachExternBuffer(HI_HANDLE hWindow,HI_UNF_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+\brief to set the work mode of window: quick output or not. Deinterlace alg will be disabled when quick output is enabled.
+CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[in] bQuickOutputEnable  whether determine the output mode of window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetQuickOutputEnable(HI_HANDLE hWindow, HI_BOOL bQuickOutputEnable);
+
+/**
+\brief to get the work mode of window: quick output or not.
+CNcomment:WINDOW CNend
+\attention \n
+CNcomment: CNend
+\param[in]  hWindow     the input window handler.CNcomment:WINDOW CNend
+\param[out] pbQuickOutputEnable  whether determine the output mode of window. CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetQuickOutputStatus(HI_HANDLE hWindow, HI_BOOL *pbQuickOutputEnable);
+
+/**
+\brief  to set the filed mode of given window.CNcomment: CNend
+\attention \n
+when fast-backward playing, there will be no abnormity through calling this func. But calling of this
+func is forbidden when normal playing. It should be called after HI_UNF_VO_AttachWindow.
+CNcomment:\n
+HI_UNF_VO_AttachWindow CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] bEnable           wether to enable field play.CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief  to get the filed mode of given window.CNcomment: CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[out] pbEnable         wether to enable field play.CNcomment:/ CNend
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+
+/**
+\brief capture the current frame of given window.CNcomment:WINDOW CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment:  CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CapturePicture(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief if you capture picture is finished, release the memory.CNcomment: CNend
+\attention \n
+this function will release captured picture, so user should call this function
+after you used this captured picture.
+CNcomment: CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:  CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment:  CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_CapturePictureRelease(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+/**
+\brief set window rotion type.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] enRotation    rotion type.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E enRotation);
+
+
+/**
+\brief get window rotion type.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] enRotation    rotion type.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E *penRotation);
+
+/**
+\brief flip window.CNcomment:window CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] bHoriFlip    horizon flip.CNcomment: CNend
+\param[in] bVertFlip    vertical flip.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_SetFlip(HI_HANDLE hWindow, HI_BOOL bHoriFlip, HI_BOOL bVertFlip);
+
+/**
+\brief get fliping tpye of window.CNcomment: CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712 CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] bHoriFlip    horizon flip flag.CNcomment: CNend
+\param[in] bVertFlip    vertical flip flag.CNcomment: CNend
+\retval ::HI_SUCCESS openned success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment: CNend
+\see \n
+CNcomment: CNend
+*/
+HI_S32 HI_UNF_VO_GetFlip(HI_HANDLE hWindow, HI_BOOL *pbHoriFlip, HI_BOOL *pbVertFlip);
+
+/**
+\brief set video stereo depth for 3D output.CNcomment:3D CNend
+\attention \n
+3716/3712: not support.Only take effect in 3D output mode.
+CNcomment: 3716/3712 .3D CNend
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] s32Depth Depth of filed. the range is [-50,50].CNcomment:[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_SetStereoDetpth(HI_HANDLE hWindow, HI_S32 s32Depth);
+
+/**
+\brief get video stereo depth for 3D output.CNcomment: 3D CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[out] ps32Depth Depth of filed. the range is [-50,50].CNcomment:[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_GetStereoDetpth(HI_HANDLE hWindow, HI_S32 *ps32Depth);
+
+/**
+\brief Queue frame into the specified window.CNcomment:  CNend
+\attention \n
+\param[in] hWindow    window handle. CNcomment: CNend
+\param[in] pstFrameinfo  frame infor to be passed into. CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\retval ::HI_ERR_VO_BUFQUE_FULL   buffer is full .CNcomment:buffer  CNend
+\retval ::HI_ERR_VO_INVALID_OPT   invalid opt.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_QueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief dequeue frame from window.CNcomment: CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[out] pstFrameinfo  frame infor dequeued from window .CNcomment:. CNend
+\param[in] u32TimeoutMs  timeout when get frame failed .CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_DeQueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief set  window alpha.CNcomment: alphaCNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] u32Alpha  window alpha .CNcomment:alpha. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_SetWindowAlpha(HI_HANDLE hWindow, HI_U32 u32Alpha);
+/**
+\brief get  window alpha.CNcomment: alphaCNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] pu32Alpha  window alpha .CNcomment:alpha. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_GetWindowAlpha(HI_HANDLE hWindow, HI_U32 *pu32Alpha);
+
+
+/**
+\brief get  window play information.CNcomment: CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] pstPlayInfo  window play information .CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+
+HI_S32 HI_UNF_VO_GetWindowPlayInfo(HI_HANDLE hWindow, HI_UNF_WIN_PLAY_INFO_S *pstPlayInfo);
+
+
+/**
+\brief get  window frame delay time.CNcomment: CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment: CNend
+\param[in] pu32DelayMs  window frame delay time.CNcomment:. CNend
+\retval ::HI_SUCCESS  success.CNcomment: CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO  CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment: CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment: CNend
+\see \n
+none.CNcomment: CNend
+ */
+HI_S32 HI_UNF_VO_GetDelayMs(const HI_HANDLE hWindow, HI_U32 *pu32DelayMs);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+/************************************** The End Of File **************************************/
diff --git a/xbmc/platform/linux/hisi/hi_unf_vp.h b/xbmc/platform/linux/hisi/hi_unf_vp.h
new file mode 100644
index 0000000000..2772711140
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_vp.h
@@ -0,0 +1,531 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vp.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2011/03/25
+  Description   :
+  History       :
+  1.Date        : 2011/03/25
+    Author      :
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the video phone (VP) engine. CNcomment: VPCNend
+ */
+#ifndef __HI_UNF_VP_H__
+#define __HI_UNF_VP_H__
+#include <netinet/in.h>
+#include "hi_common.h"
+#include "hi_unf_common.h"
+#include "hi_unf_venc.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VP*/
+/** @{ */  /** <!-- [VP] */
+
+/** Video source mode */
+/**CNcomment: */
+typedef enum hiUNF_VP_SOURCE_MODE_E
+{
+    HI_UNF_VP_SRC_MODE_USBCAM = 0,   /**<USB camera source mode *//**<CNcomment: USB */
+    HI_UNF_VP_SRC_MODE_VI,           /**<VI camera source mode *//**<CNcomment: VI*/
+    HI_UNF_VP_SRC_MODE_BUTT,
+} HI_UNF_VP_SOURCE_MODE_E;
+
+/**Video source attribute*/
+/**CNcomment:  */
+typedef struct hiUNF_VP_SOURCE_ATTR_S
+{
+    HI_HANDLE               hSrc;        /**<video source handle, can be set to VI handle or USB camera handle in v4l2*//**<CNcomment: VIv4l2USB*/
+    HI_UNF_VP_SOURCE_MODE_E enSrcMode;   /**<Video source mode *//**<CNcomment: */
+    HI_U32                  u32VIBufNum; /**<VI buffer number*//**<CNcomment:VI*/
+} HI_UNF_VP_SOURCE_ATTR_S;
+
+/**Network attribute*/
+/**CNcomment:  */
+typedef union hiUNF_VP_NET_ATTR_U
+{
+    struct sockaddr_in  stIpv4Attr;      /**<IPV4 attribute*//**<CNcomment:IPV4*/
+    struct sockaddr_in6 stIpv6Attr;      /**<IPV6 attribute*//**<CNcomment:IPV6*/
+} HI_UNF_VP_NET_ATTR_U;
+
+/**RTP attribute*/
+/**CNcomment: RTP*/
+typedef struct hiUNF_VP_RTP_ATTR_S
+{
+    HI_U32 u32SplitSize;                       /**< split size, should be less than MTU size*//**<CNcomment:*/
+    HI_U32 u32PayLoadType;                     /**< pay load type *//**<CNcomment:*/
+    HI_U32 u32SortDepth;                       /**< sort in order when receive RTP packets, this para indicates sort depth *//**<CNcomment:*/
+    HI_U32 u32RecvBufSize;                     /**< buffer size, usually 1500 bytes , should be bigger than u32SplitSize*//**<CNcomment:buf*/
+    HI_U32 u32RecvBufNum;                      /**< buffer number (total_size = u32BufSize * u32BufNum) *//**<CNcomment:buf*/
+} HI_UNF_VP_RTP_ATTR_S;
+
+/**Video engine attribute*/
+/**CNcomment:  */
+typedef struct hiUNF_VP_ATTR_S
+{
+    HI_UNF_VENC_CHN_ATTR_S stVencAttr;        /**<VENC attribute*//**<CNcomment: */
+    HI_UNF_VCODEC_TYPE_E   enDecType;         /**<VDEC attribute*//**<CNcomment: */
+    HI_BOOL                bIsIpv4;           /**<whether use IPV4 attribute, use 1 to demonstrate IPV4, use 0 to demonstrate IPV6 *//**<CNcomment: IPV41IPV40IPV6*/
+    HI_UNF_VP_NET_ATTR_U   stLocalNetAttr;    /**<Local network attribute*//**<CNcomment: */
+    HI_UNF_VP_NET_ATTR_U   stRemoteNetAttr;   /**<Remote network attribute*//**<CNcomment: */
+    HI_UNF_VP_RTP_ATTR_S   stRtpAttr;         /**<RTP attribute. Generally, We highly recommend that you don't modify it.*//**<CNcomment: RTP*/
+} HI_UNF_VP_ATTR_S;
+
+/**Remote mode*/
+/**CNcomment: */
+typedef enum hiUNF_VP_REMOTE_MODE_E
+{
+    HI_UNF_VP_RMT_MODE_SEND = 0x1,         /**<Send local video to remote mode*//**<CNcomment: */
+    HI_UNF_VP_RMT_MODE_RECV = 0x2,         /**<Receive remote video mode*//**<CNcomment: */
+    HI_UNF_VP_RMT_MODE_BUTT = 0x4,
+} HI_UNF_VP_REMOTE_MODE_E;
+
+/**RTCP configure of video engine*/
+/**CNcomment: RTCP */
+typedef struct hiUNF_VP_RTCP_CFG_S
+{
+    HI_U32 u32EnableFlag;     /**<Enable RTCP function: 0--disable, 1--enable*//**<CNcomment: RTCP: 0--, 1--*/
+    HI_U32 u32SendInterval;   /**<Send interval of RTCP report, [500, 65535]ms, must be integer of 500ms*//**<CNcomment: RTCP, [500, 65535] ms , 500ms*/
+} HI_UNF_VP_RTCP_CFG_S;
+
+/**RTCP statistics information*/
+/**CNcomment: RTCP */
+typedef struct hiUNF_VP_RTCP_STATIC_INFO_S
+{
+    HI_U32 u32TotalLostPacket;     /**<Total lost packet, this value may reset to 0 when network connection become abnormal *//**<CNcomment: */
+    HI_U32 u32LossFraction;        /**<Lost rate(%)*//**<CNcomment: (%) */
+    HI_U32 u32Jitter;              /**<Jitter(ms)*//**<CNcomment: (ms) */
+    HI_U32 u32Delay;               /**<Delay(ms)*//**<CNcomment: (ms) */
+} HI_UNF_VP_RTCP_STATIC_S;
+
+/**Statistic information of network*/
+/**CNcomment:  */
+typedef struct hiUNF_VP_NET_STA_S
+{
+    HI_U32                  u32SendPacketNum; /**<Total send packet number*//**<CNcomment: */
+    HI_U32                  u32SendBytes;     /**<Total send bytes*//**<CNcomment: */
+    HI_U32                  u32RecvPacketNum; /**<Total recv packet number*//**<CNcomment: */
+    HI_U32                  u32RecvBytes;      /**<Total recv bytes*//**<CNcomment: */
+    HI_UNF_VP_RTCP_STATIC_S stSendInfo;       /**<Send information*//**<CNcomment: */
+    HI_UNF_VP_RTCP_STATIC_S stRecvInfo;       /**<Reveive information*//**<CNcomment: */
+} HI_UNF_VP_NET_STA_S;
+
+/**Record stream format*/
+/**CNcomment: */
+typedef enum hiUNF_VP_RECORD_FORMAT_E
+{
+    HI_UNF_VP_RECORD_TS = 0x1,         /**<Record TS stream*//**<CNcomment: TS*/
+    HI_UNF_VP_RECORD_BUTT = 0x2,
+} HI_UNF_VP_RECORD_FORMAT_E;
+
+/**Statistic information of video*/
+/**CNcomment:  */
+typedef struct hiUNF_VP_VIDEO_STATICS_S
+{
+    HI_U32                  u32CaptureFrmCnt;    /**<Total camera capture frame number*//**<CNcomment: */
+    HI_U32                  u32EncoderOutFrmCnt; /**<Total encoder output frame number*//**<CNcomment: */
+    HI_U32                  u32EncoderOutBytes;  /**<Total encoder output bytes*//**<CNcomment: */
+    HI_U32                  u32DecoderInFrmCnt;  /**<Total decoder input frame number*//**<CNcomment: */
+    HI_U32                  u32DecoderInBytes;   /**<Total decoder input bytes*//**<CNcomment: */
+} HI_UNF_VP_VIDEO_STATICS_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VP */
+/** @{ */  /** <!-- VP */
+
+/**
+ \brief Initializes the VP module. CNcomment: VPCNend
+ \attention \n
+Call this application programming interface (API) before creating VP by calling ::HI_UNF_VP_Create.
+CNcomment: ::HI_UNF_VP_CreateCNend
+ \param N/A CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_DEV_NOT_EXIST The VP device does not exist. CNcomment: CNend
+ \retval ::HI_ERR_VP_DEV_OPEN_ERR The VP device fails to be started. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_Init(HI_VOID);
+
+/**
+ \brief Deinitialize the VP module. CNcomment: VPCNend
+ \attention \n
+Call this API after destroying all VPs by calling ::HI_UNF_VP_DestroyChannel.
+CNcomment: ::HI_UNF_VP_DestroyVPCNend
+ \param N/A CNcomment: CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_NOT_INIT The VP is not initialized. CNcomment: VPCNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_DeInit(HI_VOID);
+
+/**
+ \brief Obtain the default parameter values of VP. CNcomment: VPCNend
+ \attention \n
+Call this API before creating VP by calling ::HI_UNF_VP_Create. This enables you to set parameters conveniently.
+CNcomment: ::HI_UNF_VP_CreateVPCNend
+ \param[in] N/A CNcomment: CNend
+ \param[out] pstDefAttr Pointer to the default VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: VP:HI_UNF_VP_ATTR_S CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+
+HI_S32 HI_UNF_VP_GetDefaultAttr(HI_UNF_VP_ATTR_S *pstDefAttr);
+
+/**
+ \brief Create VP. CNcomment: VP  CNend
+ \attention \n
+N/A CNcomment: CNend
+ \param[in]  pstAttr parameter CNcomment: VPCNend
+ \param[out] phVP Pointer to the VP handle. CNcomment: VPCNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval ::HI_ERR_VP_NOT_SUPPORT The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NOT_SUPPORT The mode is not supported. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_Create(const HI_UNF_VP_ATTR_S *pstAttr, HI_HANDLE *phVP);
+
+/**
+ \brief Destroy VP. CNcomment: VP  CNend
+ \attention \n
+N/A CNcomment: CNend
+ \param[in] hVP VP handle CNcomment: VPCNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_NOT_INIT The VP module is not initialized. CNcomment: VPCNend
+ \retval ::HI_ERR_VP_INVALID_HANDLE The VP handle is invalid. CNcomment: VPCNend
+ \retval Other values: A fails to be destroyed. CNcomment:  CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_Destroy(HI_HANDLE hVP);
+
+/**
+ \brief Attach input source of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \param[in] stSrcAttr Video input attribute. CNcomment:CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to attach input source of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_AttachSource(HI_HANDLE hVP, HI_UNF_VP_SOURCE_ATTR_S *pstSrcAttr);
+
+/**
+ \brief Attach local window of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \param[in] hLocalWin Local window handle. CNcomment:CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to attach local window of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_AttachLocalWin(HI_HANDLE hVP, HI_HANDLE hLocalWin);
+
+/**
+ \brief Attach remote window of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \param[in] hRemoteWin Remote window handle. CNcomment:CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to attach remote window of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_AttachRemoteWin(HI_HANDLE hVP, HI_HANDLE hRemoteWin);
+
+/**
+ \brief Detach input source of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to detach input source of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_DetachSource(HI_HANDLE hVP);
+
+/**
+ \brief Detach local window of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to detach local window of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_DetachLocalWin(HI_HANDLE hVP);
+
+/**
+ \brief Detach remote window of VP. CNcomment: CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VPCNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval Other values: Failed to detach remote window of VP. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_DetachRemoteWin(HI_HANDLE hVP);
+
+/**
+ \brief Obtains the configuration of VP. CNcomment: VP CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \param[out] pstAttr Pointer to VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: VP :HI_UNF_VP_ATTR_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values:Fail to obtain attributes. CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+
+HI_S32 HI_UNF_VP_GetAttr(HI_HANDLE hVP, HI_UNF_VP_ATTR_S *pstAttr);
+
+/**
+ \brief Modifies the configuration of VP. CNcomment: VPCNend
+ \attention \n
+You are advised to obtain the current configuration by calling HI_UNF_VP_GetChAttr(), and modify parameter values as required.
+CNcomment: HI_UNF_VP_GetChAttr()CNend
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \param[in] pstAttr Pointer to VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: VP :HI_UNF_VP_ATTR_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values: Fail to modify attributes . CNcomment: CNend
+ \see \n
+N/A CNcomment:CNend
+ */
+HI_S32 HI_UNF_VP_SetAttr(HI_HANDLE hVP, const HI_UNF_VP_ATTR_S *pstAttr);
+
+/**
+ \brief Starts VP. CNcomment: VPCNend
+ \attention \n
+After setting parameters including the codec, video input (VI), and video output (VO) parameters, you can start the video engine by calling this API to transmit or receive data over the Internet and display the local or remote video output.
+CNcomment: VI/VOCNend
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values: VP fails to be started. CNcomment:  VPCNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_Start(HI_HANDLE hVP);
+
+/**
+ \brief Stops VP. CNcomment: VPCNend
+ \attention \n
+After VP is started successfully, you can stop it by calling this API to freeze the screen or stop transmitting or receiving data over Internet. You can resume the VP by calling HI_UNF_VP_Start.
+CNcomment: VPHI_UNF_VP_StartCNend
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values: VP fails to be started. CNcomment: VPCNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_Stop(HI_HANDLE hVP);
+
+/**
+ \brief Previews the local video over VP. CNcomment: VPCNend
+ \attention \n
+After the VI and hLocalWin parameters are set, you can preview the local video by calling this API.
+CNcomment: VIhLocalWinCNend
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values: VP fails to be started. CNcomment: VPCNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_StartPreView(HI_HANDLE hVP);
+
+/**
+ \brief Stops previewing the local video over VP. CNcomment: VPCNend
+ \attention \n
+When a local video is previewed over VP, you can stop previewing the video by calling this API.
+CNcomment: VPCNend
+ \param[in] hVP VP handle CNcomment: VP CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other values: VP fails to be started. CNcomment:   VPCNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_StopPreView(HI_HANDLE hVP);
+
+/**
+ \brief Starts remote VP. CNcomment: VP  CNend
+ \attention \n
+Starts remote VP, this interface enables vp start sending local video to remote, or receiving remote video.
+CNcomment:   CNend
+ \param[in] hVP VP handle CNcomment: VP   CNend
+ \param[in] enRmtMode remote mode CNcomment:   CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment:   CNend
+ \retval Other values: VP fails to be started. CNcomment: VP  CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_StartRemote(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRmtMode);
+
+/**
+ \brief Stops remote VP. CNcomment: VP  CNend
+ \attention \n
+Stops remote VP, this interface enables vp stop sending local video to remote, or receiving remote video.
+CNcomment:   CNend
+ \param[in] hVP VP handle CNcomment: VP   CNend
+ \param[in] enRmtMode remote mode CNcomment:   CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment:   CNend
+ \retval Other values: VP fails to be started. CNcomment: VP  CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_StopRemote(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRmtMode);
+
+/**
+ \brief Configs RTCP over VP. CNcomment: VPRTCP  CNend
+ \attention \n
+When VP has been created, you can config RTCP to enable and config RTCP sending frequency by calling this API.
+CNcomment: VPRTCPRTCPCNend
+ \param[in] hVP VP handle CNcomment: VPCNend
+ \param[out] pstRtcpCfg Pointer to config RTCP information, refer to HI_UNF_VP_RTCP_CFG_S. CNcomment: VP RTCP:HI_UNF_VP_RTCP_CFG_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other value CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_ConfigRtcp(HI_HANDLE hVP, HI_UNF_VP_RTCP_CFG_S *pstRtcpCfg);
+
+/**
+ \brief Gets network statistics information over VP. CNcomment: VPCNend
+ \attention \n
+When VP has been started, you can get network statistics information to config parameter of video encoder by calling this API.
+CNcomment: VPCNend
+ \param[in] hVP VP handle CNcomment: VPCNend
+ \param[out] pstNetStatics Pointer to network statistics information of VP, refer to HI_UNF_VP_NET_STA_S. CNcomment: VP:HI_UNF_VP_NET_STA_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other value CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_GetNetStatics(HI_HANDLE hVP, HI_UNF_VP_NET_STA_S *pstNetStatics);
+
+/**
+ \brief Gets VENC handle. CNcomment: VENC  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP  CNend
+ \param[out] phVenc Pointer to VENC handle. CNcomment: VENC  CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment:   CNend
+ \retval Other value CNcomment:   CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_GetVencHandle(HI_HANDLE hVp, HI_HANDLE *phVenc);
+
+/**
+ \brief Gets AVPLAY handle that play remote video. CNcomment: AVPLAY  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP  CNend
+ \param[out] phAvplay Pointer to AVPLAY handle. CNcomment: AVPLAY  CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment:   CNend
+ \retval Other value CNcomment:   CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_GetAvplayHandle(HI_HANDLE hVp, HI_HANDLE *phAvplay);
+
+/**
+ \brief Start record stream. CNcomment:   CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP  CNend
+ \param[in] enRecordFmt Record stream format. CNcomment:   CNend
+ \param[in] enRecordType Record type. CNcomment:   CNend
+ \param[in] ucFullName Record stream full name, full directory included. CNcomment:   CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment:   CNend
+ \retval Other value CNcomment:   CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_StartRecord(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRecordType,
+                                 HI_UNF_VP_RECORD_FORMAT_E enRecordFmt, HI_CHAR * ucFullName);
+
+/**
+ \brief Stop record stream. CNcomment:   CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP  CNend
+ \retval ::HI_SUCCESS Success CNcomment:   CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment:   CNend
+ \retval Other value CNcomment:   CNend
+ \see \n
+N/A CNcomment:   CNend
+ */
+HI_S32 HI_UNF_VP_StopRecord(HI_HANDLE hVP);
+
+
+/**
+ \brief Gets video statistics information over VP. CNcomment: VPCNend
+ \param[in] hVP VP handle CNcomment: VPCNend
+ \param[out] pstNetStatics Pointer to video statistics information of VP, refer to HI_UNF_VP_NET_STA_S. CNcomment: VP  CNend
+ \retval ::HI_SUCCESS Success CNcomment: CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: CNend
+ \retval Other value CNcomment: CNend
+ \see \n
+N/A CNcomment: CNend
+ */
+HI_S32 HI_UNF_VP_GetVideoStatics(HI_HANDLE hVP, HI_UNF_VP_VIDEO_STATICS_S *pstVideoStatics);
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff --git a/xbmc/platform/linux/hisi/hi_unf_wdg.h b/xbmc/platform/linux/hisi/hi_unf_wdg.h
new file mode 100644
index 0000000000..0dc050e916
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_unf_wdg.h
@@ -0,0 +1,189 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name       : hi_unf_wdg.h
+Version         : Initial draft
+Author          : HiSilicon multimedia software group
+Created Date    : 2008-06-05
+Last Modified by:
+Description     : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List   :
+Change History  :
+******************************************************************************/
+#ifndef __HI_UNF_WDG_H__
+#define __HI_UNF_WDG_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define HI_UNF_WDG_Open     HI_UNF_WDG_Init
+#define HI_UNF_WDG_Close    HI_UNF_WDG_DeInit
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      WDG*/
+/** @{*/  /** <!-- [WDG] */
+
+/**
+ \brief Starts the WDG device.
+CNcomment:\brief WDGWatch DogCNend
+
+ \attention \n
+By default, the WDG device is disabled after it is started. In this case, you need to call HI_UNF_WDG_Enable to enable it.\n
+CNcomment:WDGHI_UNF_WDG_EnableWDGCNend\N
+
+ \param N/A          	CNcomment:CNend
+ \retval 0 Success.   	CNcomment:CNend
+ \retval ::HI_ERR_WDG_FAILED_INIT	open failed
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Init(HI_VOID);
+
+/**
+ \brief Stops the WDG device.
+CNcomment:\brief WDGCNend
+
+ \attention \n
+N/A
+ \param N/A          	CNcomment:CNend
+ \retval 0 Success.   	CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_DeInit(HI_VOID);
+
+/**
+ \brief Get the number of WDG device.
+CNcomment:\brief WDGCNend
+
+ \attention \n
+You can call this API to get thenumber of WDG chipset supports after the WDG device is started.
+CNcomment:WDGWDGCNend
+
+ \param[out] pu32WdgNum  The number of WDG chipset supports        	CNcomment:WDGCNend
+ \retval 0 Success  CNcomment: CNend
+ \retval ::HI_FAILURE The Parameter pu32WdgNum is NULL.       CNcomment:pu32WdgNumCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_GetCapability(HI_U32 *pu32WdgNum);
+
+/**
+ \brief Enables the WDG device.
+CNcomment:\brief WDGCNend
+
+ \attention \n
+You must call HI_UNF_WDG_Enable after the WDG device is started.
+CNcomment:WDGCNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \retval 0 Success.  	CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT The WDG device is not initialized.       CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:CNend
+ \retval ::HI_ERR_WDG_FAILED_ENABLE enable watchdog failed.				CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Enable(HI_U32 u32WdgNum);
+
+/**
+ \brief Disables the WDG device.
+CNcomment:\brief WDGCNend
+
+ \attention \n
+After calling this API, you cannot feed and reset the WDG.
+CNcomment:CNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.      CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:CNend
+ \retval ::HI_ERR_WDG_FAILED_DISABLE  disable watchdog failed.			CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Disable(HI_U32 u32WdgNum);
+
+/**
+ \brief Obtains the interval of feeding the WDG.
+CNcomment:\brief CNend
+
+ \attention \n
+The interval precision is as high as 1000 ms.
+CNcomment:1000msCNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \param[in] pu32Value  Interval of feeding the WDG, in ms.             	CNcomment:msCNend
+ \retval 0 Success.                                                  	CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.     	CNcomment:WDG CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA  The WDG input pointer is invalid.  	CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_FAILED_SETTIMEOUT get timeout failed.			  	CNcomment:WDGCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_GetTimeout(HI_U32 u32WdgNum, HI_U32 *pu32Value);
+
+/**
+ \brief Sets the interval of feeding the WDG.
+CNcomment:\brief CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \param[out] u32Value  Interval of feeding the WDG, in ms.                		CNcomment:msCNend
+ \retval 0 Success.                                                      		CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT The WDG device is not initialized.       		CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_FAILED_SETTIMEOUT The WDG set timeout failed.   			CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_INVALID_PARA  The WDG input parameter is invalid. 		CNcomment:WDGCNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_SetTimeout(HI_U32 u32WdgNum, HI_U32 u32Value);
+
+/**
+ \brief Feeds the WDG.
+CNcomment:\brief CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \retval 0 Success.                                                   	CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.      CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_FAILED_CLEARWDG  The WDG clear watchdog failed.   CNcomment:WDG CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Clear(HI_U32 u32WdgNum);
+
+/**
+ \brief Resets the entire system.
+CNcomment:\brief CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:WDGCNend
+ \retval 0 Success. CNcomment:CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.  CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_FAILED_RESET The WDG reset failed.   			CNcomment:WDGCNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 		CNcomment:CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Reset(HI_U32 u32WdgNum);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_WDG_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_user_proc.h b/xbmc/platform/linux/hisi/hi_user_proc.h
new file mode 100644
index 0000000000..81e454aa3d
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_user_proc.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_USER_PROC_H__
+#define __HI_USER_PROC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Defines user mode proc show buffer
+ * CNcomment: PROC buffer
+ */
+typedef struct hiPROC_SHOW_BUFFER_S {
+    HI_U8 *pu8Buf;    /* Buffer address */ /* CNcomment: Buffer */
+    HI_U32 u32Size;   /* Buffer size */    /* CNcomment: Buffer */
+    HI_U32 u32Offset; /* Offset */         /* CNcomment:  */
+} HI_PROC_SHOW_BUFFER_S;
+
+/*
+ * Proc show function
+ * CNcomment: Proc
+ */
+typedef HI_S32 (* HI_PROC_SHOW_FN)(HI_PROC_SHOW_BUFFER_S *pstBuf, HI_VOID *pPrivData);
+
+/*
+ * Proc command function
+ * CNcomment: Proc
+ */
+typedef HI_S32 (* HI_PROC_CMD_FN)(HI_PROC_SHOW_BUFFER_S *pstBuf, HI_U32 u32Argc, HI_U8 *pu8Argv[], HI_VOID *pPrivData);
+
+/*
+ * Defines user mode proc entry
+ * CNcomment: PROC
+ */
+typedef struct hiPROC_ENTRY_S {
+    HI_CHAR *pszEntryName;       /* Entry name */            /* CNcomment:  */
+    HI_CHAR *pszDirectory;       /* Directory name. If null, the entry will be added to /proc/hisi/ */ /* CNcomment: /proc/hisi */
+    HI_PROC_SHOW_FN pfnShowProc; /* Proc show function */    /* CNcomment: Proc */
+    HI_PROC_CMD_FN pfnCmdProc;   /* Proc command function */ /* CNcomment: Proc */
+    HI_VOID *pPrivData;          /* Private data */          /* CNcomment: Buffer */
+} HI_PROC_ENTRY_S;
+
+/*
+ * brief User mode proc cretea directory. CNcomment:proc CNend
+ * attention You need register module before calling this API. Only support create one level directory. CNcomment: CNend
+ * param[in] pszName The directory name. CNcomment: CNend
+ * param[out] None CNcomment: CNend
+ * retval ::HI_SUCCESS Success CNcomment: CNend
+ * retval ::HI_FAILURE Failure CNcomment: CNend
+ * see \n
+ * N/A CNcomment: CNend
+ */
+HI_S32 HI_PROC_AddDir(const HI_CHAR *Name);
+
+/*
+ * brief User mode proc remove directory. CNcomment:proc CNend
+ * attention It will return fail if there are entries in the directory. CNcomment:, CNend
+ * param[in] pszName The directory name. CNcomment: CNend
+ * retval ::HI_SUCCESS Success CNcomment: CNend
+ * retval ::HI_FAILURE Failure CNcomment: CNend
+ * see \n
+ * N/A CNcomment: CNend
+ */
+HI_S32 HI_PROC_RemoveDir(const HI_CHAR *Name);
+
+/*
+ * brief User mode proc add entry. CNcomment:proc CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] u32ModuleID Module ID. CNcomment:ID CNend
+ * param[in] pstEntry Parameter of entry. CNcomment: CNend
+ * retval ::HI_SUCCESS Success CNcomment: CNend
+ * retval ::HI_FAILURE Failure CNcomment: CNend
+ * see \n
+ * N/A CNcomment: CNend
+ */
+HI_S32 HI_PROC_AddEntry(HI_U32 ModuleID, const HI_PROC_ENTRY_S *Entry);
+
+/*
+ * brief User mode proc remove entry. CNcomment:proc CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] u32ModuleID Module ID. CNcomment:ID CNend
+ * param[in] pstEntry Parameter of entry. CNcomment: CNend
+ * retval ::HI_SUCCESS Success CNcomment: CNend
+ * retval ::HI_FAILURE Failure CNcomment: CNend
+ * see \n
+ * N/A CNcomment: CNend
+ */
+HI_S32 HI_PROC_RemoveEntry(HI_U32 ModuleID, const HI_PROC_ENTRY_S *Entry);
+
+/*
+ * brief User mode proc print function. CNcomment:proc CNend
+ * attention \n
+ * N/A CNcomment:  CNend
+ * param[in] pstBuf Output buffer parameter. CNcomment:buffer CNend
+ * param[in] pFmt   Format parameter. CNcomment: CNend
+ * retval ::HI_SUCCESS Success CNcomment: CNend
+ * retval ::HI_FAILURE Failure CNcomment: CNend
+ * see \n
+ * N/A CNcomment: CNend
+ */
+HI_S32 HI_PROC_Printf(HI_PROC_SHOW_BUFFER_S *ShowBuf, const HI_CHAR *Fmt, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_USER_PROC_H__ */
diff --git a/xbmc/platform/linux/hisi/hi_video_codec.h b/xbmc/platform/linux/hisi/hi_video_codec.h
new file mode 100644
index 0000000000..9e6ce45546
--- /dev/null
+++ b/xbmc/platform/linux/hisi/hi_video_codec.h
@@ -0,0 +1,827 @@
+/******************************************************************************
+
+  Copyright (C), 2012-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_video_codec.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2012/07/31
+  Description   : Common definitions of HI_CODEC(video).
+                  The codec wants to register to HI_CODEC need to adapt to HI_CODEC_S.
+  History       :
+  1.Date        : 2012/07/31
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_VIDEO_CODEC_H__
+#define __HI_VIDEO_CODEC_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_type.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup  VCODEC  */
+/** @{ */  /** <!--[VCODEC]  */
+
+/*Codec error defination */
+/**Operate fail due to insufficient resources(eg. no enough memory) */
+/**CNcomment: ()*/ 
+#define HI_ERR_CODEC_NOENOUGHRES    (HI_S32)(0x80510001)
+/**Parameter invalid */
+/**CNcomment: */ 
+#define HI_ERR_CODEC_INVALIDPARAM   (HI_S32)(0x80510002)
+/**The (en)decoding fails due to incorrect input(streams or frames) */
+/**CNcomment: ()*/ 
+#define HI_ERR_CODEC_INPUTCORRUPT   (HI_S32)(0x80510003)
+/**The (en)decoding ends due to insufficient input data(streams or frames) */
+/**CNcomment: ()*/ 
+#define HI_ERR_CODEC_NOENOUGHDATA   (HI_S32)(0x80510004)
+/**The (en)decoding mode is not supported */
+/**CNcomment: ()*/ 
+#define HI_ERR_CODEC_INVALIDMODE    (HI_S32)(0x80510005)
+/**Operate fail */
+/**CNcomment: */ 
+#define HI_ERR_CODEC_OPERATEFAIL    (HI_S32)(0x80510006)
+/**Version unmatch*/
+/**CNcomment: */ 
+#define HI_ERR_CODEC_VERSIONUNMATCH (HI_S32)(0x80510007)
+/**Unsupport operation */
+/**CNcomment: */
+#define HI_ERR_CODEC_UNSUPPORT      (HI_S32)(0x80510008)
+/**Decorder busy */
+/**CNcomment: */ 
+#define HI_ERR_CODEC_BUSY           (HI_S32)(0x80510009)
+/**Unknown error */
+/**CNcomment: */ 
+#define HI_ERR_CODEC_UNKNOWN        (HI_S32)(0x80510010)
+
+/**Codec ID */
+/**CNcomment:  */
+typedef enum hiCODEC_ID_E
+{
+    HI_CODEC_ID_NONE = 0, 
+        
+    HI_CODEC_ID_VIDEO_MPEG1,
+    HI_CODEC_ID_VIDEO_MPEG2,
+    HI_CODEC_ID_VIDEO_MPEG2_XVMC,
+    HI_CODEC_ID_VIDEO_MPEG4,      /**<MPEG4 DIVX4 DIVX5*/
+    HI_CODEC_ID_VIDEO_MSMPEG4V1,
+    HI_CODEC_ID_VIDEO_MSMPEG4V2,
+    HI_CODEC_ID_VIDEO_MSMPEG4V3,
+
+    HI_CODEC_ID_VIDEO_DIVX3,
+    HI_CODEC_ID_VIDEO_XVID,
+
+    HI_CODEC_ID_VIDEO_H261,
+    HI_CODEC_ID_VIDEO_H263,
+    HI_CODEC_ID_VIDEO_H263P,
+    HI_CODEC_ID_VIDEO_H263I,
+    HI_CODEC_ID_VIDEO_H264,
+    HI_CODEC_ID_VIDEO_FFH264,
+
+    HI_CODEC_ID_VIDEO_AVS,
+
+    HI_CODEC_ID_VIDEO_REAL8,
+    HI_CODEC_ID_VIDEO_REAL9,
+
+    HI_CODEC_ID_VIDEO_VC1,
+    HI_CODEC_ID_VIDEO_WMV1,
+    HI_CODEC_ID_VIDEO_WMV2,
+    HI_CODEC_ID_VIDEO_WMV3,
+
+    HI_CODEC_ID_VIDEO_MSVIDEO1,
+
+    HI_CODEC_ID_VIDEO_VP3,
+    HI_CODEC_ID_VIDEO_VP5,
+    HI_CODEC_ID_VIDEO_VP6,
+    HI_CODEC_ID_VIDEO_VP6F,
+    HI_CODEC_ID_VIDEO_VP6A,
+    HI_CODEC_ID_VIDEO_VP8,
+    HI_CODEC_ID_VIDEO_VP9,
+    HI_CODEC_ID_VIDEO_AVS2,
+    HI_CODEC_ID_VIDEO_RAW,
+    HI_CODEC_ID_VIDEO_SORENSON,   /**<SORENSON SPARK*/
+
+	HI_CODEC_ID_VIDEO_HEVC,
+    HI_CODEC_ID_VIDEO_RV10,
+    HI_CODEC_ID_VIDEO_RV20,
+    HI_CODEC_ID_VIDEO_RV30,
+    HI_CODEC_ID_VIDEO_RV40,
+    
+    HI_CODEC_ID_VIDEO_SVQ1,
+    HI_CODEC_ID_VIDEO_SVQ3,
+
+    HI_CODEC_ID_VIDEO_CINEPAK,
+    HI_CODEC_ID_VIDEO_INDEO2,
+    HI_CODEC_ID_VIDEO_INDEO3,
+    HI_CODEC_ID_VIDEO_INDEO4,
+    HI_CODEC_ID_VIDEO_INDEO5,
+
+    HI_CODEC_ID_VIDEO_JPEG,
+    HI_CODEC_ID_VIDEO_JPEGLS,
+    HI_CODEC_ID_VIDEO_JPEG2000,
+    HI_CODEC_ID_VIDEO_MJPEG,
+    HI_CODEC_ID_VIDEO_MJPEGB,
+    HI_CODEC_ID_VIDEO_LJPEG,
+
+    HI_CODEC_ID_VIDEO_TIFF,
+    HI_CODEC_ID_VIDEO_GIF,
+    HI_CODEC_ID_VIDEO_PNG,
+
+    HI_CODEC_ID_VIDEO_SP5X,
+    
+    HI_CODEC_ID_VIDEO_FLV1,
+    HI_CODEC_ID_VIDEO_HUFFYUV,
+    HI_CODEC_ID_VIDEO_CYUV,
+    HI_CODEC_ID_VIDEO_THEORA,
+    HI_CODEC_ID_VIDEO_ASV1,
+    HI_CODEC_ID_VIDEO_ASV2,
+    HI_CODEC_ID_VIDEO_FFV1,
+    HI_CODEC_ID_VIDEO_4XM,
+    HI_CODEC_ID_VIDEO_VCR1,
+    HI_CODEC_ID_VIDEO_CLJR,
+    HI_CODEC_ID_VIDEO_MDEC,
+    HI_CODEC_ID_VIDEO_ROQ,
+    HI_CODEC_ID_VIDEO_INTERPLAY_VIDEO,
+    HI_CODEC_ID_VIDEO_XAN_WC3,
+    HI_CODEC_ID_VIDEO_XAN_WC4,
+    HI_CODEC_ID_VIDEO_RPZA,
+    HI_CODEC_ID_VIDEO_WS_VQA,
+    HI_CODEC_ID_VIDEO_MSRLE,
+    HI_CODEC_ID_VIDEO_IDCIN,
+    HI_CODEC_ID_VIDEO_8BPS,
+    HI_CODEC_ID_VIDEO_SMC,
+    HI_CODEC_ID_VIDEO_FLIC,
+    HI_CODEC_ID_VIDEO_TRUEMOTION1,
+    HI_CODEC_ID_VIDEO_VMDVIDEO,
+    HI_CODEC_ID_VIDEO_MSZH,
+    HI_CODEC_ID_VIDEO_ZLIB,
+    HI_CODEC_ID_VIDEO_QTRLE,
+    HI_CODEC_ID_VIDEO_SNOW,
+    HI_CODEC_ID_VIDEO_TSCC,
+    HI_CODEC_ID_VIDEO_ULTI,
+    HI_CODEC_ID_VIDEO_QDRAW,
+    HI_CODEC_ID_VIDEO_VIXL,
+    HI_CODEC_ID_VIDEO_QPEG,
+    HI_CODEC_ID_VIDEO_PPM,
+    HI_CODEC_ID_VIDEO_PBM,
+    HI_CODEC_ID_VIDEO_PGM,
+    HI_CODEC_ID_VIDEO_PGMYUV,
+    HI_CODEC_ID_VIDEO_PAM,
+    HI_CODEC_ID_VIDEO_FFVHUFF,
+    
+    HI_CODEC_ID_VIDEO_LOCO,
+    HI_CODEC_ID_VIDEO_WNV1,
+    HI_CODEC_ID_VIDEO_AASC,
+    HI_CODEC_ID_VIDEO_FRAPS,
+    HI_CODEC_ID_VIDEO_TRUEMOTION2,
+    HI_CODEC_ID_VIDEO_BMP,
+    HI_CODEC_ID_VIDEO_CSCD,
+    HI_CODEC_ID_VIDEO_MMVIDEO,
+    HI_CODEC_ID_VIDEO_ZMBV,
+    HI_CODEC_ID_VIDEO_SMACKVIDEO,
+    HI_CODEC_ID_VIDEO_NUV,
+    HI_CODEC_ID_VIDEO_KMVC,
+    HI_CODEC_ID_VIDEO_FLASHSV,
+    HI_CODEC_ID_VIDEO_CAVS,
+    
+    HI_CODEC_ID_VIDEO_VMNC,
+    
+    HI_CODEC_ID_VIDEO_TARGA,
+    HI_CODEC_ID_VIDEO_DSICINVIDEO,
+    HI_CODEC_ID_VIDEO_TIERTEXSEQVIDEO,
+    
+    HI_CODEC_ID_VIDEO_DXA,
+    HI_CODEC_ID_VIDEO_DNXHD,
+    HI_CODEC_ID_VIDEO_THP,
+    HI_CODEC_ID_VIDEO_SGI,
+    HI_CODEC_ID_VIDEO_C93,
+    HI_CODEC_ID_VIDEO_BETHSOFTVID,
+    HI_CODEC_ID_VIDEO_PTX,
+    HI_CODEC_ID_VIDEO_TXD,
+    HI_CODEC_ID_VIDEO_AMV,
+    HI_CODEC_ID_VIDEO_VB,
+    HI_CODEC_ID_VIDEO_PCX,
+    HI_CODEC_ID_VIDEO_SUNRAST,
+    HI_CODEC_ID_VIDEO_MIMIC,
+    HI_CODEC_ID_VIDEO_RL2,
+    HI_CODEC_ID_VIDEO_8SVX_EXP,
+    HI_CODEC_ID_VIDEO_8SVX_FIB,
+    HI_CODEC_ID_VIDEO_ESCAPE124,
+    HI_CODEC_ID_VIDEO_DIRAC,
+    HI_CODEC_ID_VIDEO_BFI,
+    HI_CODEC_ID_VIDEO_CMV,
+    HI_CODEC_ID_VIDEO_MOTIONPIXELS,
+    HI_CODEC_ID_VIDEO_TGV,
+    HI_CODEC_ID_VIDEO_TGQ,
+    HI_CODEC_ID_VIDEO_TQI,
+    HI_CODEC_ID_VIDEO_AURA,
+    HI_CODEC_ID_VIDEO_AURA2,
+    HI_CODEC_ID_VIDEO_V210X,
+    HI_CODEC_ID_VIDEO_TMV,
+    HI_CODEC_ID_VIDEO_V210,
+    HI_CODEC_ID_VIDEO_DPX,
+    HI_CODEC_ID_VIDEO_MAD,
+    HI_CODEC_ID_VIDEO_FRWU,
+    HI_CODEC_ID_VIDEO_FLASHSV2,
+    HI_CODEC_ID_VIDEO_CDGRAPHICS,
+    HI_CODEC_ID_VIDEO_R210,
+    HI_CODEC_ID_VIDEO_ANM,
+    HI_CODEC_ID_VIDEO_BINKVIDEO,
+    HI_CODEC_ID_VIDEO_IFF_ILBM,
+    HI_CODEC_ID_VIDEO_IFF_BYTERUN1,
+    HI_CODEC_ID_VIDEO_KGV1,
+    HI_CODEC_ID_VIDEO_YOP,
+    HI_CODEC_ID_VIDEO_DV,
+    HI_CODEC_ID_BUTT
+}HI_CODEC_ID_E;
+
+/*BIT0 of HI_CODEC_SUPPORT_S.u32Type: Driven type */
+/**Need be driven by codec manager. Like FFMPEG. */ /**CNcomment: */
+#define HI_CODEC_CAP_DRIVENOUTSIDE      (0x00000000)
+/**Self-driven, only need call Start()/Stop(). Like VFMW. */ /**CNcomment: */
+#define HI_CODEC_CAP_DRIVENSELF         (0x00000001)
+
+/*BIT1 of HI_CODEC_SUPPORT_S.u32Type: Output type */
+/**Codec outputs frame or stream to specified address directly.  */ /**CNcomment: */
+#define HI_CODEC_CAP_OUTPUT2SELFADDR    (0x00000000)
+/**Codec outputs frame or stream to the address self allocated . */ /**CNcomment: */
+#define HI_CODEC_CAP_OUTPUT2SPECADDR    (0x00000002)
+
+/**Defines codec type: encoder or decoder  */
+/**CNcomment:Codec:*/ 
+typedef enum hiCODEC_TYPE_E
+{
+    HI_CODEC_TYPE_DEC = 0x01,       /**<decoder, value is b00000001*/ /**< CNcomment: */
+    HI_CODEC_TYPE_ENC = 0x02,       /**<encoder, value is b00000010*/ /**< CNcomment: */
+    
+    HI_CODEC_TYPE_BUTT
+}HI_CODEC_TYPE_E;
+
+/**Defines codec types and formats */
+/**CNcomment:Codec*/ 
+typedef struct hiCODEC_SUPPORT_S
+{
+    HI_U32          u32Type;            /**< Codec type, OR value of HI_CODEC_TYPE_E */ /**< CNcomment:CodecHI_CODEC_TYPE_E */
+    HI_CODEC_ID_E   enID;               /**< Codec ID*/ /**< CNcomment:Codec */
+    struct hiCODEC_SUPPORT_S* pstNext;  /**< Pointer to next node*/ /**< CNcomment: */
+}HI_CODEC_SUPPORT_S;
+
+/**Defines codec capability */
+/**CNcomment:Codec*/ 
+typedef struct hiCODEC_CAP_S
+{
+    HI_U32              u32CapNumber;   /**< Codec capability index, OR value of several HI_CODEC_CAP_XXX */ /**< CNcomment:CodecHI_CODEC_CAP_XXX */
+    HI_CODEC_SUPPORT_S* pstSupport;     /**< Pointer to the support type and formats*/ /**< CNcomment:Codec */
+}HI_CODEC_CAP_S;
+
+/**Defines the codec version*/
+/**CNcomment:*/ 
+typedef union hiCODEC_VERSION_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;           /**< Major version */ /**< CNcomment: */
+        HI_U8 u8VersionMinor;           /**< Minor version */ /**< CNcomment: */
+        HI_U8 u8Revision;               /**< Revision version */ /**< CNcomment: */
+        HI_U8 u8Step;                   /**< Step version */ /**< CNcomment: */
+    } stVersion;
+    HI_U32 u32Version;
+} HI_CODEC_VERSION_U;
+
+/**Defines video decoder open parameter*/
+/**CNcomment:*/ 
+typedef struct hiCODEC_VDEC_OPENPARAM_S
+{
+    HI_U32 u32Reserve;
+    HI_VOID* pPlatformPriv;         /**< Special parameter for platform hardware codec */ /**< CNcomment: */
+}HI_CODEC_VDEC_OPENPARAM_S;
+
+/**Defines video encoder open parameter*/
+/**CNcomment:*/ 
+typedef struct hiCODEC_VENC_OPENPARAM_S
+{
+    HI_U32 u32Reserve;
+}HI_CODEC_VENC_OPENPARAM_S;
+
+/**Defines the codec open parameters*/
+/**CNcomment:*/
+typedef struct hiCODEC_OPENPARAM_S
+{
+    HI_CODEC_TYPE_E enType;       /** Encode or Decode */ /**< CNcomment: */
+    HI_CODEC_ID_E enID;           /** Format */ /**< CNcomment: */
+    union {
+        HI_CODEC_VDEC_OPENPARAM_S stVdec; /** Open parameters of video decoder */ /**< CNcomment: */
+        HI_CODEC_VENC_OPENPARAM_S stVenc; /** Open parameters of video encoder */ /**< CNcomment: */
+    }unParam;
+} HI_CODEC_OPENPARAM_S;
+
+/**Defines the codec max priority */
+/**CNcomment:*/
+#define HI_CODEC_MAX_PRIORITY (16)
+
+/**Defines attribute of video decoder */
+/**CNcomment:*/
+typedef struct hiCODEC_VDEC_ATTR_S
+{
+    HI_VOID*                pCodecContext;  /**< Codec context */ /**< CNcomment: */
+    HI_VOID*                pPlatformPriv;  /**< Only used by platform */ /**< CNcomment: */
+} HI_CODEC_VDEC_ATTR_S;
+
+/**Defines attribute of codec instance */
+/**CNcomment:*/
+typedef struct hiCODEC_ATTR_S
+{
+    HI_CODEC_ID_E           enID;   /**< Codec ID*/ /**< CNcomment:*/
+    union {
+        HI_CODEC_VDEC_ATTR_S stVdec;/**< Instance attribute*/ /**< CNcomment:*/
+    } unAttr;
+} HI_CODEC_ATTR_S;
+
+/**Defines video sub standard */
+/**CNcomment:  */
+typedef enum hiCODEC_VIDEO_SUB_STANDARD_E
+{
+    HI_CODEC_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2MPEG1 */
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4SHV*/
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4XVID*/
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4DIVX*/
+
+    HI_CODEC_VIDEO_SUB_STANDARD_BUTT
+}HI_CODEC_VIDEO_SUB_STANDARD_E;
+
+/**Defines the video norm*/
+/**CNcomment: */
+typedef enum hiCODEC_ENC_FMT_E
+{
+    HI_CODEC_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/ /**< CNcomment:1080p 60*/
+    HI_CODEC_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/ /**< CNcomment:1080p 50*/
+    HI_CODEC_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/ /**< CNcomment:1080p 30*/
+    HI_CODEC_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/ /**< CNcomment:1080p 25*/
+    HI_CODEC_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/ /**< CNcomment:1080p 24*/
+
+    HI_CODEC_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/ /**< CNcomment:1080i 60*/
+    HI_CODEC_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/ /**< CNcomment:1080i 50*/
+
+    HI_CODEC_ENC_FMT_720P_60,          /**<720p 60 Hz*/  /**< CNcomment:720p 60*/
+    HI_CODEC_ENC_FMT_720P_50,          /**<720p 50 Hz */ /**< CNcomment:720p 50*/
+
+    HI_CODEC_ENC_FMT_576P_50,          /**<576p 50 Hz*/  /**< CNcomment:576p 50*/
+    HI_CODEC_ENC_FMT_480P_60,          /**<480p 60 Hz*/  /**< CNcomment:480p 60*/
+
+    HI_CODEC_ENC_FMT_PAL,              /**<B D G H I PAL */ /**< CNcomment:B D G H I PAL*/
+    HI_CODEC_ENC_FMT_PAL_N,            /**<(N)PAL        */ /**< CNcomment:(N)PAL*/
+    HI_CODEC_ENC_FMT_PAL_Nc,           /**<(Nc)PAL       */ /**< CNcomment:(Nc)PAL*/
+
+    HI_CODEC_ENC_FMT_NTSC,             /**<(M)NTSC       */ /**< CNcomment:(M)NTSC*/
+    HI_CODEC_ENC_FMT_NTSC_J,           /**<NTSC-J        */ /**< CNcomment:NTSC-J*/
+    HI_CODEC_ENC_FMT_NTSC_PAL_M,       /**<(M)PAL        */ /**< CNcomment:(M)PAL*/
+
+    HI_CODEC_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/ /**< CNcomment:SECAM_SIN*/
+    HI_CODEC_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/ /**< CNcomment:SECAM_COS*/
+
+    HI_CODEC_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_CODEC_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_CODEC_ENC_FMT_720P_50_FRAME_PACKING,
+    
+    HI_CODEC_ENC_FMT_861D_640X480_60,
+    HI_CODEC_ENC_FMT_VESA_800X600_60,
+    HI_CODEC_ENC_FMT_VESA_1024X768_60,
+    HI_CODEC_ENC_FMT_VESA_1280X720_60,
+    HI_CODEC_ENC_FMT_VESA_1280X800_60,
+    HI_CODEC_ENC_FMT_VESA_1280X1024_60,
+    HI_CODEC_ENC_FMT_VESA_1360X768_60,
+    HI_CODEC_ENC_FMT_VESA_1366X768_60,
+    HI_CODEC_ENC_FMT_VESA_1400X1050_60,
+    HI_CODEC_ENC_FMT_VESA_1440X900_60,
+    HI_CODEC_ENC_FMT_VESA_1440X900_60_RB,
+    HI_CODEC_ENC_FMT_VESA_1600X900_60_RB,
+    HI_CODEC_ENC_FMT_VESA_1600X1200_60,
+    HI_CODEC_ENC_FMT_VESA_1680X1050_60,
+    HI_CODEC_ENC_FMT_VESA_1920X1080_60,
+    HI_CODEC_ENC_FMT_VESA_1920X1200_60,
+    HI_CODEC_ENC_FMT_VESA_2048X1152_60,
+
+    HI_CODEC_ENC_FMT_BUTT
+}HI_CODEC_ENC_FMT_E;
+
+/**Defines the video YUV format*/
+/**CNcomment: YUV*/
+typedef enum hiCODEC_COLOR_FORMAT_E
+{
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_400 = 0,   /**<The YUV spatial sampling format is SEMIPLANAR 4:0:0.*/ /**<CNcomment: YUVSEMIPLANAR 4:0:0*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_411,       /**<The YUV spatial sampling format is SEMIPLANAR 4:1:1.*/ /**<CNcomment: YUVSEMIPLANAR 4:1:1*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is SEMIPLANAR 4:2:0.*/ /**<CNcomment: YUVSEMIPLANAR 4:2:0*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_422_1X2,   /**<The YUV spatial sampling format is SEMIPLANAR 4:2:2,two Y correspond to one U and V at vertical direction.*/ /**<CNcomment: YUVSEMIPLANAR 4:2:2*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_422_2X1,   /**<The YUV spatial sampling format is SEMIPLANAR 4:2:2,two Y correspond to one U and V at horizontal direction.*/ /**<CNcomment: YUVSEMIPLANAR 4:2:2*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_444,       /**<The YUV spatial sampling format is SEMIPLANAR 4:4:4.*/ /**<CNcomment: YUVSEMIPLANAR 4:4:4*/
+
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_400 = 0x10,    /**<The YUV spatial sampling format is PLANAR 4:0:0.*/ /**<CNcomment: YUVPLANAR 4:0:0*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_411,           /**<The YUV spatial sampling format is PLANAR 4:1:1.*/ /**<CNcomment: YUVPLANAR 4:1:1*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_420,           /**<The YUV spatial sampling format is PLANAR 4:2:0.*/ /**<CNcomment: YUVPLANAR 4:2:0*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_422_1X2,       /**<The YUV spatial sampling format is PLANAR 4:2:2,two Y correspond to one U and V at vertical direction.*/ /**<CNcomment: YUVPLANAR 4:2:2*/
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_422_2X1,       /**<The YUV spatial sampling format is PLANAR 4:2:2,two Y correspond to one U and V at horizontal direction.*/ /**<CNcomment: YUVPLANAR 4:2:2*/
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_444,           /**<The YUV spatial sampling format is PLANAR 4:4:4.*/ /**<CNcomment: YUVPLANAR 4:4:4*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_410,           /**<The YUV spatial sampling format is PLANAR 4:1:0.*/ /**<CNcomment: YUVPLANAR 4:1:0*/   
+    
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_UYVY422 = 0x20,   /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUVpackage,UYVY*/
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_YUYV422,          /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUVpackage,YUYV*/
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_YVYU422,          /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUVpackage,YVYU*/
+    HI_CODEC_COLOR_FORMAT_YUV_BUTT
+}HI_CODEC_COLOR_FORMAT_E;
+
+/**Defines the type of the video frame*/
+/**CNcomment: */
+typedef enum hiCODEC_VIDEO_FRAME_TYPE_E
+{
+    HI_CODEC_VIDEO_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I*/
+    HI_CODEC_VIDEO_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P*/
+    HI_CODEC_VIDEO_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B*/
+    HI_CODEC_VIDEO_FRAME_TYPE_BUTT
+}HI_CODEC_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode*/
+/**CNcomment: */
+typedef enum hiCODEC_VIDEO_FIELD_MODE_E
+{
+    HI_CODEC_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_FIELD_BUTT
+}HI_CODEC_VIDEO_FIELD_MODE_E;
+
+/**Defines 3D frame packing type*/
+/**CNcomment: 3D */
+typedef enum hiCODEC_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_CODEC_VIDEO_FRAME_PACKING_NONE,              /**< normal frame, not a 3D frame */ /**<CNcomment: 3D*/
+    HI_CODEC_VIDEO_FRAME_PACKING_SIDE_BY_SIDE,      /**< side by side */ /**<CNcomment:3D */
+    HI_CODEC_VIDEO_FRAME_PACKING_TOP_AND_BOTTOM,    /**< top and bottom */ /**<CNcomment:3D */
+    HI_CODEC_VIDEO_FRAME_PACKING_TIME_INTERLACED,   /**< time interlaced: one frame for left eye, the next frame for right eye */ /**<CNcomment:3D */
+    HI_CODEC_VIDEO_FRAME_PACKING_BUTT             
+}HI_CODEC_VIDEO_FRAME_PACKING_TYPE_E;
+
+/**Defines address information*/
+/**CNcomment: */
+typedef struct hiCODEC_ADDRESS_S
+{
+    HI_U8   *pu8Vir;             /**<Virtual address of (frame or stream) buffer */ /**<CNcomment:  */
+    HI_U32  u32Phy;             /**<Physical address of (frame or stream) buffer */ /**<CNcomment:  */
+    HI_U32  u32Size;            /**<Size of (frame or stream) buffer*/ /**<CNcomment:  */
+}HI_CODEC_ADDRESS_S;
+
+/**Defines the pixel width.*/
+/**CNcomment: */
+typedef enum hiCODEC_PIXEL_BITWIDTH_E
+{
+    HI_CODEC_PIXEL_BITWIDTH_8BIT = 0,
+    HI_CODEC_PIXEL_BITWIDTH_10BIT,
+    HI_CODEC_PIXEL_BITWIDTH_12BIT,
+    HI_CODEC_PIXEL_BITWIDTH_BUTT,
+} HI_CODEC_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: */
+typedef enum hiCODEC_COLOR_SPACE_E
+{
+    HI_CODEC_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_CODEC_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_CODEC_COLOR_SPACE_BT601_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_CODEC_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_CODEC_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_CODEC_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_CODEC_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_CODEC_COLOR_SPACE_BT709_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT709_RGB_FULL,
+    HI_CODEC_COLOR_SPACE_BT2020_YUV_LIMITED,/* ::::Current Used:::: BT.2020 */
+    HI_CODEC_COLOR_SPACE_BT2020_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT2020_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT2020_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_CODEC_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_CODEC_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_CODEC_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_CODEC_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_CODEC_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_CODEC_COLOR_SPACE_JPEG = 0x90,
+    HI_CODEC_COLOR_SPACE_RGB = 0xa0,
+
+    HI_CODEC_COLOR_SPACE_BUTT
+}HI_CODEC_COLOR_SPACE_E;
+
+/**Defines video stream info */
+/** CNcomment: */
+typedef struct hiCODEC_VIDEO_STREAMINFO_S
+{
+    HI_CODEC_ID_E                   enCodecID;      /**<Stream type*/ /**<CNcomment:  */
+    HI_CODEC_VIDEO_SUB_STANDARD_E   enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                          u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment:  */
+    HI_U32                          u32Profile;     /**<Stream profile*/ /**<CNcomment: profile */
+    HI_U32                          u32Level;       /**<Stream level*/ /**<CNcomment: level */
+    HI_CODEC_ENC_FMT_E              enDisplayNorm;  /**<Display norm*/ /**<CNcomment:  */
+    HI_BOOL                         bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: (/) */
+
+    HI_U32                          u32AspectWidth; /**<Aspect width*/ /**<CNcomment: */
+    HI_U32                          u32AspectHeight;/**<Aspect height*/ /**<CNcomment: */
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: , Kbps */
+    HI_U32 u32FrameRateInt;   /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: , fps */
+    HI_U32 u32FrameRateDec;   /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 3, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment:  */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment:  */
+    HI_CODEC_PIXEL_BITWIDTH_E enBitWidth; /**<Bit width decoded from stream*/ /**<CNcomment: */
+    HI_CODEC_COLOR_SPACE_E      enSrcColorSpace;/**<Color space decoded from stream*/ /**<CNcomment: */
+}HI_CODEC_VIDEO_STREAMINFO_S;
+
+/**Defines stream information */
+/**CNcomment: */
+typedef union hiCODEC_STREAMINFO_S
+{
+    HI_CODEC_VIDEO_STREAMINFO_S stVideo;    /**<video stream information*/ /**<CNcomment: */
+}HI_CODEC_STREAMINFO_S;
+
+typedef struct hiCODEC_FRAME_BUF_S
+{
+	HI_U32 u32PhyAddr;
+	HI_U32 u32Size;
+}HI_CODEC_FRAME_BUF_S;
+
+/**Defines stream descriptor */
+/**CNcomment: */
+typedef struct hiCODEC_STREAM_S
+{
+    HI_U8* pu8Addr;     /**<Stream buffer address*/ /**<CNcomment: */
+	HI_U32 u32PhyAddr;  /**<Stream buffer address*/ /**<CNcomment: */
+    HI_U32 u32Size;     /**<Stream buffer size*/ /**<CNcomment: */
+    HI_S64 s64PtsMs;    /**<PTS(ms)*/ /**<CNcomment: PTS*/
+}HI_CODEC_STREAM_S;
+
+/**Defines video codec comonds */
+/**CNcomment: */
+typedef struct hiCODEC_VIDEO_CMD_S
+{
+    HI_U32      u32CmdID;   /**<Commond ID*/ /**<CNcomment: ID*/
+    HI_VOID     *pPara;     /**<Control parameter*/ /**<CNcomment: */
+}HI_CODEC_VIDEO_CMD_S;
+
+/**Defines video frame information*/
+/**CNcomment: */
+typedef struct hiCODEC_VIDEO_FRAME_S
+{
+    HI_CODEC_COLOR_FORMAT_E             enColorFormat;        /**<Video format*/ /**<CNcomment: */
+    HI_CODEC_VIDEO_FRAME_TYPE_E         enFrameType;          /**<Frame type*/ /**<CNcomment: */
+    HI_BOOL                             bProgressive;         /**<Sampling type*/ /**<CNcomment: */
+    
+    HI_CODEC_VIDEO_FIELD_MODE_E         enFieldMode;          /**<Frame or field encoding mode*/ /**<CNcomment: */
+    HI_BOOL                             bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: */
+
+    HI_CODEC_VIDEO_FRAME_PACKING_TYPE_E enFramePackingType;   /**<3D frame packing type*/ /**<CNcomment: 3D*/
+    
+    HI_U32                              u32FrameRate;         /**<Frame rate*//**<CNcomment: */
+    
+    HI_U32                              u32Width;             /**<Width of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32Height;            /**<Height of the source picture*/ /**<CNcomment: */
+    HI_U32                              u32AspectWidth;       /**<Aspect width*/ /**<CNcomment: */
+    HI_U32                              u32AspectHeight;      /**<Aspect height*/ /**<CNcomment: */
+
+    HI_U32                              u32YAddr;             /**<Address of the Y component in the current frame*/ /**<CNcomment: Y*/
+    HI_U32                              u32UAddr;             /**<Address of the U component in the current frame*/ /**<CNcomment: U*/
+    HI_U32                              u32VAddr;             /**<Address of the V component in the current frame*/ /**<CNcomment: V*/
+    HI_U32                              u32YStride;           /**<Stride of the Y component*/ /**<CNcomment: Y*/
+    HI_U32                              u32UStride;           /**<Stride of the U component*/ /**<CNcomment: C*/
+    HI_U32                              u32VStride;           /**<Stride of the V component*/ /**<CNcomment: C*/
+
+    HI_U8*                              pu8UserData;          /**<User data *//**<CNcomment: */
+    HI_U32                              u32UserDataSize;      /**<User data size *//**<CNcomment: */
+}HI_CODEC_VIDEO_FRAME_S;
+
+/**Defines frame descriptor */
+/**CNcomment: */
+typedef struct hiCODEC_FRAME_S
+{
+    HI_CODEC_ADDRESS_S          stOutputAddr;   /**< Always [in], only used by the codecs which support HI_CODEC_OUTPUT_TOSPECADDR, Only used by decoder  */
+                                                /**< CNcomment: HI_CODEC_OUTPUT_TOSPECADDR */
+    HI_S64                      s64SrcPtsMs;    /**< Decoder [out], encoder [in], The source pts(ms) */
+                                                /**< CNcomment: PTS*/
+    HI_S64                      s64PtsMs;       /**< Decoder [out], encoder [in], The pts(ms)*/
+                                                /**< CNcomment: PTS*/
+    union{
+        HI_CODEC_VIDEO_FRAME_S  stVideo;        /**< Decoder [out], encoder [in], The video frame information*/ 
+                                                /**< CNcomment: */
+    }unInfo;
+}HI_CODEC_FRAME_S;
+
+/**Defines codec*/
+/**CNcomment: CODEC*/
+typedef struct hiCODEC_S
+{
+    /**<Description information about a codec */
+    /**<CNcomment:  */ 
+    const HI_CHAR *pszName;
+
+    /**<Codec version */
+    /**<CNcomment:  */ 
+    const HI_CODEC_VERSION_U unVersion;
+
+    /**<Detailed information about a codec */
+    /**<CNcomment:  */
+    const HI_CHAR *pszDescription;
+
+    /**
+    \brief Get codec capability. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [out] pstCodecCap, Pointer of the codec capability. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_S32 (*GetCap)(HI_CODEC_CAP_S *pstCodecCap);
+  
+    /**
+    \brief Create a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] pstParam, Pointer of the open params. CNcomment: CNend
+    \param [out] phInst, Pointer to instance handle. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */
+    HI_S32 (*Create)(HI_HANDLE* phInst, const HI_CODEC_OPENPARAM_S * pstParam);
+
+    /**
+    \brief Destroy a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*Destroy)(HI_HANDLE hInst);
+
+    /**
+    \brief Start a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */       
+    HI_S32 (*Start)(HI_HANDLE hInst);
+
+    /**
+    \brief Stop a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */       
+    HI_S32 (*Stop)(HI_HANDLE hInst);
+
+    /**
+    \brief Reset a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */        
+    HI_S32 (*Reset)(HI_HANDLE hInst);
+
+    /**
+    \brief Set attribute to a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [in] pstAttr, Pointer to the instance attribute. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */      
+    HI_S32 (*SetAttr)(HI_HANDLE hInst, const HI_CODEC_ATTR_S * pstAttr);
+
+    /**
+    \brief Get attribute to a codec instance. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [out] pstAttr, Pointer to the instance attribute. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */        
+    HI_S32 (*GetAttr)(HI_HANDLE hInst, HI_CODEC_ATTR_S * pstAttr);
+
+    /**
+    \brief Decode a frame.. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [in] pstIn, Pointer to stream data descriptor. CNcomment: CNend
+    \param [out] pstOut, Pointer to frame data descriptor. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*DecodeFrame)(HI_HANDLE hInst, HI_CODEC_STREAM_S * pstIn, HI_CODEC_FRAME_S * pstOut);
+
+    /**
+    \brief Encode a frame. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [in] pstIn, Pointer to stream data descriptor. CNcomment: CNend
+    \param [out] pstOut, Pointer to frame data descriptor. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*EncodeFrame)(HI_HANDLE hInst, HI_CODEC_FRAME_S * pstIn, HI_CODEC_STREAM_S * pstOut);
+
+    /**
+    \brief Get stream information. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [out] pstAttr, Pointer to stream information. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*GetStreamInfo)(HI_HANDLE hInst, HI_CODEC_STREAMINFO_S * pstAttr);
+
+	HI_S32 (*RegFrameBuffer)(HI_HANDLE hInst, HI_CODEC_STREAM_S *pstRawPacket);
+    /**
+    \brief Other control, can be extended. CNcomment: CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment: CNend
+    \param [out] u32CMD, The commond ID. CNcomment:ID CNend
+    \param [out] pParam, Pointer to control parameter. CNcomment: CNend
+    \retval ::HI_SUCCESS CNcomment: CNend
+    \retval ::HI_FAILURE CNcomment: CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*Control)(HI_HANDLE hInst, HI_U32 u32CMD, HI_VOID * pParam);
+}HI_CODEC_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_VIDEO_CODEC_H__ */
diff --git a/xbmc/platform/posix/PlatformDefs.h b/xbmc/platform/posix/PlatformDefs.h
index e6e59fe4cc..7eea143c14 100644
--- a/xbmc/platform/posix/PlatformDefs.h
+++ b/xbmc/platform/posix/PlatformDefs.h
@@ -151,3 +151,7 @@ struct _stati64 {
 
 #define FILE_READ_DATA   ( 0x0001 )
 #define FILE_WRITE_DATA  ( 0x0002 )
+
+#ifndef BYTE
+typedef unsigned char BYTE;
+#endif
\ No newline at end of file
diff --git a/xbmc/settings/SettingConditions.cpp b/xbmc/settings/SettingConditions.cpp
index 1f11a4995e..26cc059e7b 100644
--- a/xbmc/settings/SettingConditions.cpp
+++ b/xbmc/settings/SettingConditions.cpp
@@ -408,6 +408,9 @@ void CSettingConditions::Initialize()
 #ifdef HAS_ZEROCONF
   m_simpleConditions.emplace("has_zeroconf");
 #endif
+#ifdef USE_HIPLAYER
+  m_simpleConditions.emplace("use_hiplayer");
+#endif
 #ifdef HAVE_LIBVA
   m_simpleConditions.emplace("have_libva");
 #endif
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index bfc5e6072c..9a36e4be54 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -129,6 +129,7 @@ public:
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAUMPEG4 = "videoplayer.usevdpaumpeg4";
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAUVC1 = "videoplayer.usevdpauvc1";
   static constexpr auto SETTING_VIDEOPLAYER_USEDXVA2 = "videoplayer.usedxva2";
+  static constexpr auto SETTING_VIDEOPLAYER_USEHIPLAYER = "videoplayer.usehiplayer";
   static constexpr auto SETTING_VIDEOPLAYER_USEVTB = "videoplayer.usevtb";
   static constexpr auto SETTING_VIDEOPLAYER_USEPRIMEDECODER = "videoplayer.useprimedecoder";
   static constexpr auto SETTING_VIDEOPLAYER_USESTAGEFRIGHT = "videoplayer.usestagefright";
diff --git a/xbmc/windowing/egl/WinSystemSTBContext.cpp b/xbmc/windowing/egl/WinSystemSTBContext.cpp
index 3b4e3e8d66..c70869bbd2 100644
--- a/xbmc/windowing/egl/WinSystemSTBContext.cpp
+++ b/xbmc/windowing/egl/WinSystemSTBContext.cpp
@@ -21,6 +21,8 @@
 #include "cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h"
 #endif
 
+#include "cores/VideoPlayer/VideoRenderers/HwDecRender/RendererHisi.h"
+
 #include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
@@ -58,6 +60,7 @@ bool CWinSystemSTBContext::InitWindowSystem()
   VIDEOPLAYER::CRendererFactory::ClearRenderer();
 #ifdef HAS_GLES
   CLinuxRendererGLES::Register();
+  CRendererHisi::Register();
   RETRO::CRPProcessInfo::RegisterRendererFactory(new RETRO::CRendererFactoryOpenGLES);
 #else
   CLinuxRendererGL::Register();
-- 
2.45.1.windows.1

